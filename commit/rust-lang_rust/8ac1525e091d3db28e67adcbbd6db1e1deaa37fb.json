{"sha": "8ac1525e091d3db28e67adcbbd6db1e1deaa37fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYzE1MjVlMDkxZDNkYjI4ZTY3YWRjYmJkNmRiMWUxZGVhYTM3ZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-07T19:35:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-07T19:35:26Z"}, "message": "Auto merge of #74006 - euclio:sys-unix-static-mut, r=oli-obk\n\nlibstd: remove some mutable statics in sys::unix\n\nMy understanding is that this achieves the same behavior and performance with safe code.", "tree": {"sha": "4fd27b7ba62154511de28fabcdf98fada1efcbbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fd27b7ba62154511de28fabcdf98fada1efcbbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ac1525e091d3db28e67adcbbd6db1e1deaa37fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ac1525e091d3db28e67adcbbd6db1e1deaa37fb", "html_url": "https://github.com/rust-lang/rust/commit/8ac1525e091d3db28e67adcbbd6db1e1deaa37fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ac1525e091d3db28e67adcbbd6db1e1deaa37fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1beee4992ad4b235fc700bf7af1ee86f894ea53", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1beee4992ad4b235fc700bf7af1ee86f894ea53", "html_url": "https://github.com/rust-lang/rust/commit/e1beee4992ad4b235fc700bf7af1ee86f894ea53"}, {"sha": "792f2dedd7d910d35f91f32aa222b05d91cb0c65", "url": "https://api.github.com/repos/rust-lang/rust/commits/792f2dedd7d910d35f91f32aa222b05d91cb0c65", "html_url": "https://github.com/rust-lang/rust/commit/792f2dedd7d910d35f91f32aa222b05d91cb0c65"}], "stats": {"total": 59, "additions": 33, "deletions": 26}, "files": [{"sha": "5b712e202423236757516b6d5b9359447e9b9f93", "filename": "src/libstd/sys/unix/args.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8ac1525e091d3db28e67adcbbd6db1e1deaa37fb/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac1525e091d3db28e67adcbbd6db1e1deaa37fb/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fargs.rs?ref=8ac1525e091d3db28e67adcbbd6db1e1deaa37fb", "patch": "@@ -78,19 +78,20 @@ mod imp {\n     use crate::marker::PhantomData;\n     use crate::os::unix::prelude::*;\n     use crate::ptr;\n+    use crate::sync::atomic::{AtomicIsize, AtomicPtr, Ordering};\n \n     use crate::sys_common::mutex::Mutex;\n \n-    static mut ARGC: isize = 0;\n-    static mut ARGV: *const *const u8 = ptr::null();\n+    static ARGC: AtomicIsize = AtomicIsize::new(0);\n+    static ARGV: AtomicPtr<*const u8> = AtomicPtr::new(ptr::null_mut());\n     // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n     // acquire this mutex reentrantly!\n     static LOCK: Mutex = Mutex::new();\n \n     unsafe fn really_init(argc: isize, argv: *const *const u8) {\n         let _guard = LOCK.lock();\n-        ARGC = argc;\n-        ARGV = argv;\n+        ARGC.store(argc, Ordering::Relaxed);\n+        ARGV.store(argv as *mut _, Ordering::Relaxed);\n     }\n \n     #[inline(always)]\n@@ -126,8 +127,8 @@ mod imp {\n \n     pub unsafe fn cleanup() {\n         let _guard = LOCK.lock();\n-        ARGC = 0;\n-        ARGV = ptr::null();\n+        ARGC.store(0, Ordering::Relaxed);\n+        ARGV.store(ptr::null_mut(), Ordering::Relaxed);\n     }\n \n     pub fn args() -> Args {\n@@ -137,9 +138,11 @@ mod imp {\n     fn clone() -> Vec<OsString> {\n         unsafe {\n             let _guard = LOCK.lock();\n-            (0..ARGC)\n+            let argc = ARGC.load(Ordering::Relaxed);\n+            let argv = ARGV.load(Ordering::Relaxed);\n+            (0..argc)\n                 .map(|i| {\n-                    let cstr = CStr::from_ptr(*ARGV.offset(i) as *const libc::c_char);\n+                    let cstr = CStr::from_ptr(*argv.offset(i) as *const libc::c_char);\n                     OsStringExt::from_vec(cstr.to_bytes().to_vec())\n                 })\n                 .collect()"}, {"sha": "c74fc2b5903161d08e46a7181e9dc81149889294", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8ac1525e091d3db28e67adcbbd6db1e1deaa37fb/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac1525e091d3db28e67adcbbd6db1e1deaa37fb/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=8ac1525e091d3db28e67adcbbd6db1e1deaa37fb", "patch": "@@ -48,6 +48,7 @@ mod imp {\n     use libc::{sigaltstack, SIGSTKSZ, SS_DISABLE};\n     use libc::{MAP_ANON, MAP_PRIVATE, PROT_NONE, PROT_READ, PROT_WRITE, SIGSEGV};\n \n+    use crate::sync::atomic::{AtomicBool, AtomicPtr, Ordering};\n     use crate::sys::unix::os::page_size;\n     use crate::sys_common::thread_info;\n \n@@ -113,8 +114,8 @@ mod imp {\n         }\n     }\n \n-    static mut MAIN_ALTSTACK: *mut libc::c_void = ptr::null_mut();\n-    static mut NEED_ALTSTACK: bool = false;\n+    static MAIN_ALTSTACK: AtomicPtr<libc::c_void> = AtomicPtr::new(ptr::null_mut());\n+    static NEED_ALTSTACK: AtomicBool = AtomicBool::new(false);\n \n     pub unsafe fn init() {\n         let mut action: sigaction = mem::zeroed();\n@@ -125,17 +126,17 @@ mod imp {\n                 action.sa_flags = SA_SIGINFO | SA_ONSTACK;\n                 action.sa_sigaction = signal_handler as sighandler_t;\n                 sigaction(signal, &action, ptr::null_mut());\n-                NEED_ALTSTACK = true;\n+                NEED_ALTSTACK.store(true, Ordering::Relaxed);\n             }\n         }\n \n         let handler = make_handler();\n-        MAIN_ALTSTACK = handler._data;\n+        MAIN_ALTSTACK.store(handler._data, Ordering::Relaxed);\n         mem::forget(handler);\n     }\n \n     pub unsafe fn cleanup() {\n-        Handler { _data: MAIN_ALTSTACK };\n+        Handler { _data: MAIN_ALTSTACK.load(Ordering::Relaxed) };\n     }\n \n     unsafe fn get_stackp() -> *mut libc::c_void {\n@@ -176,7 +177,7 @@ mod imp {\n     }\n \n     pub unsafe fn make_handler() -> Handler {\n-        if !NEED_ALTSTACK {\n+        if !NEED_ALTSTACK.load(Ordering::Relaxed) {\n             return Handler::null();\n         }\n         let mut stack = mem::zeroed();"}, {"sha": "c1bda6b430e13d6fcf4c8212d0be386ad5ea4ff4", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8ac1525e091d3db28e67adcbbd6db1e1deaa37fb/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ac1525e091d3db28e67adcbbd6db1e1deaa37fb/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=8ac1525e091d3db28e67adcbbd6db1e1deaa37fb", "patch": "@@ -246,10 +246,11 @@ pub mod guard {\n     use libc::{MAP_ANON, MAP_FAILED, MAP_FIXED, MAP_PRIVATE, PROT_NONE, PROT_READ, PROT_WRITE};\n \n     use crate::ops::Range;\n+    use crate::sync::atomic::{AtomicUsize, Ordering};\n     use crate::sys::os;\n \n     // This is initialized in init() and only read from after\n-    static mut PAGE_SIZE: usize = 0;\n+    static PAGE_SIZE: AtomicUsize = AtomicUsize::new(0);\n \n     pub type Guard = Range<usize>;\n \n@@ -275,7 +276,7 @@ pub mod guard {\n \n         let stackaddr = if libc::pthread_main_np() == 1 {\n             // main thread\n-            current_stack.ss_sp as usize - current_stack.ss_size + PAGE_SIZE\n+            current_stack.ss_sp as usize - current_stack.ss_size + PAGE_SIZE.load(Ordering::Relaxed)\n         } else {\n             // new thread\n             current_stack.ss_sp as usize - current_stack.ss_size\n@@ -310,7 +311,8 @@ pub mod guard {\n \n     // Precondition: PAGE_SIZE is initialized.\n     unsafe fn get_stack_start_aligned() -> Option<*mut libc::c_void> {\n-        assert!(PAGE_SIZE != 0);\n+        let page_size = PAGE_SIZE.load(Ordering::Relaxed);\n+        assert!(page_size != 0);\n         let stackaddr = get_stack_start()?;\n \n         // Ensure stackaddr is page aligned! A parent process might\n@@ -319,16 +321,17 @@ pub mod guard {\n         // stackaddr < stackaddr + stacksize, so if stackaddr is not\n         // page-aligned, calculate the fix such that stackaddr <\n         // new_page_aligned_stackaddr < stackaddr + stacksize\n-        let remainder = (stackaddr as usize) % PAGE_SIZE;\n+        let remainder = (stackaddr as usize) % page_size;\n         Some(if remainder == 0 {\n             stackaddr\n         } else {\n-            ((stackaddr as usize) + PAGE_SIZE - remainder) as *mut libc::c_void\n+            ((stackaddr as usize) + page_size - remainder) as *mut libc::c_void\n         })\n     }\n \n     pub unsafe fn init() -> Option<Guard> {\n-        PAGE_SIZE = os::page_size();\n+        let page_size = os::page_size();\n+        PAGE_SIZE.store(page_size, Ordering::Relaxed);\n \n         let stackaddr = get_stack_start_aligned()?;\n \n@@ -344,7 +347,7 @@ pub mod guard {\n             // faulting, so our handler can report \"stack overflow\", and\n             // trust that the kernel's own stack guard will work.\n             let stackaddr = stackaddr as usize;\n-            Some(stackaddr - PAGE_SIZE..stackaddr)\n+            Some(stackaddr - page_size..stackaddr)\n         } else {\n             // Reallocate the last page of the stack.\n             // This ensures SIGBUS will be raised on\n@@ -356,7 +359,7 @@ pub mod guard {\n             // no permissions at all. See issue #50313.\n             let result = mmap(\n                 stackaddr,\n-                PAGE_SIZE,\n+                page_size,\n                 PROT_READ | PROT_WRITE,\n                 MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n                 -1,\n@@ -366,22 +369,22 @@ pub mod guard {\n                 panic!(\"failed to allocate a guard page\");\n             }\n \n-            let result = mprotect(stackaddr, PAGE_SIZE, PROT_NONE);\n+            let result = mprotect(stackaddr, page_size, PROT_NONE);\n             if result != 0 {\n                 panic!(\"failed to protect the guard page\");\n             }\n \n             let guardaddr = stackaddr as usize;\n             let offset = if cfg!(target_os = \"freebsd\") { 2 } else { 1 };\n \n-            Some(guardaddr..guardaddr + offset * PAGE_SIZE)\n+            Some(guardaddr..guardaddr + offset * page_size)\n         }\n     }\n \n     #[cfg(any(target_os = \"macos\", target_os = \"openbsd\", target_os = \"solaris\"))]\n     pub unsafe fn current() -> Option<Guard> {\n         let stackaddr = get_stack_start()? as usize;\n-        Some(stackaddr - PAGE_SIZE..stackaddr)\n+        Some(stackaddr - PAGE_SIZE.load(Ordering::Relaxed)..stackaddr)\n     }\n \n     #[cfg(any(\n@@ -413,7 +416,7 @@ pub mod guard {\n             ret = if cfg!(target_os = \"freebsd\") {\n                 // FIXME does freebsd really fault *below* the guard addr?\n                 let guardaddr = stackaddr - guardsize;\n-                Some(guardaddr - PAGE_SIZE..guardaddr)\n+                Some(guardaddr - PAGE_SIZE.load(Ordering::Relaxed)..guardaddr)\n             } else if cfg!(target_os = \"netbsd\") {\n                 Some(stackaddr - guardsize..stackaddr)\n             } else if cfg!(all(target_os = \"linux\", target_env = \"gnu\")) {"}]}