{"sha": "613a5c95ae7401e08d21b8a77f53dadb1d7642d7", "node_id": "C_kwDOAAsO6NoAKDYxM2E1Yzk1YWU3NDAxZTA4ZDIxYjhhNzdmNTNkYWRiMWQ3NjQyZDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-07T14:18:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-07T14:18:05Z"}, "message": "Auto merge of #111222 - scottmcm:constify-is_ascii, r=thomcc\n\nConstify `[u8]::is_ascii` (unstably)\n\nUTF-8 checking in `const fn`-stabilized back in 1.63 (#97367), but apparently somehow ASCII checking was never const-ified, despite being simpler.\n\nNew constness-tracking issue for `is_ascii`: #111090\n\nI noticed this working on `ascii::Char`: #110998", "tree": {"sha": "bd2a7eff8177cdce0184637a900747a6df8daad2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd2a7eff8177cdce0184637a900747a6df8daad2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/613a5c95ae7401e08d21b8a77f53dadb1d7642d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/613a5c95ae7401e08d21b8a77f53dadb1d7642d7", "html_url": "https://github.com/rust-lang/rust/commit/613a5c95ae7401e08d21b8a77f53dadb1d7642d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/613a5c95ae7401e08d21b8a77f53dadb1d7642d7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dddad0dc5d614f799d7e04de4895e7a7418eccb", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dddad0dc5d614f799d7e04de4895e7a7418eccb", "html_url": "https://github.com/rust-lang/rust/commit/0dddad0dc5d614f799d7e04de4895e7a7418eccb"}, {"sha": "c8c5a587ac637aa1521c17c631fe0070aa1dc994", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8c5a587ac637aa1521c17c631fe0070aa1dc994", "html_url": "https://github.com/rust-lang/rust/commit/c8c5a587ac637aa1521c17c631fe0070aa1dc994"}], "stats": {"total": 111, "additions": 96, "deletions": 15}, "files": [{"sha": "3fea9a44049fb1e4a45d76a66417d40251eeb71c", "filename": "library/core/src/array/ascii.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/613a5c95ae7401e08d21b8a77f53dadb1d7642d7/library%2Fcore%2Fsrc%2Farray%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613a5c95ae7401e08d21b8a77f53dadb1d7642d7/library%2Fcore%2Fsrc%2Farray%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fascii.rs?ref=613a5c95ae7401e08d21b8a77f53dadb1d7642d7", "patch": "@@ -4,10 +4,23 @@ use crate::ascii;\n impl<const N: usize> [u8; N] {\n     /// Converts this array of bytes into a array of ASCII characters,\n     /// or returns `None` if any of the characters is non-ASCII.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ascii_char)]\n+    /// #![feature(const_option)]\n+    ///\n+    /// const HEX_DIGITS: [std::ascii::Char; 16] =\n+    ///     *b\"0123456789abcdef\".as_ascii().unwrap();\n+    ///\n+    /// assert_eq!(HEX_DIGITS[1].as_str(), \"1\");\n+    /// assert_eq!(HEX_DIGITS[10].as_str(), \"a\");\n+    /// ```\n     #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n     #[must_use]\n     #[inline]\n-    pub fn as_ascii(&self) -> Option<&[ascii::Char; N]> {\n+    pub const fn as_ascii(&self) -> Option<&[ascii::Char; N]> {\n         if self.is_ascii() {\n             // SAFETY: Just checked that it's ASCII\n             Some(unsafe { self.as_ascii_unchecked() })"}, {"sha": "3abf66dbe29085283cfab8a68942668f54839401", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/613a5c95ae7401e08d21b8a77f53dadb1d7642d7/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613a5c95ae7401e08d21b8a77f53dadb1d7642d7/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=613a5c95ae7401e08d21b8a77f53dadb1d7642d7", "patch": "@@ -150,6 +150,7 @@\n #![feature(const_slice_from_raw_parts_mut)]\n #![feature(const_slice_from_ref)]\n #![feature(const_slice_index)]\n+#![feature(const_slice_is_ascii)]\n #![feature(const_slice_ptr_len)]\n #![feature(const_slice_split_at_mut)]\n #![feature(const_str_from_utf8_unchecked_mut)]"}, {"sha": "f3311f76a7f0663c6c58e811aa4c9c1319ba871d", "filename": "library/core/src/slice/ascii.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/613a5c95ae7401e08d21b8a77f53dadb1d7642d7/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613a5c95ae7401e08d21b8a77f53dadb1d7642d7/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs?ref=613a5c95ae7401e08d21b8a77f53dadb1d7642d7", "patch": "@@ -10,9 +10,10 @@ use crate::ops;\n impl [u8] {\n     /// Checks if all bytes in this slice are within the ASCII range.\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_is_ascii\", issue = \"111090\")]\n     #[must_use]\n     #[inline]\n-    pub fn is_ascii(&self) -> bool {\n+    pub const fn is_ascii(&self) -> bool {\n         is_ascii(self)\n     }\n \n@@ -21,7 +22,7 @@ impl [u8] {\n     #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n     #[must_use]\n     #[inline]\n-    pub fn as_ascii(&self) -> Option<&[ascii::Char]> {\n+    pub const fn as_ascii(&self) -> Option<&[ascii::Char]> {\n         if self.is_ascii() {\n             // SAFETY: Just checked that it's ASCII\n             Some(unsafe { self.as_ascii_unchecked() })\n@@ -262,11 +263,29 @@ impl<'a> fmt::Debug for EscapeAscii<'a> {\n /// Returns `true` if any byte in the word `v` is nonascii (>= 128). Snarfed\n /// from `../str/mod.rs`, which does something similar for utf8 validation.\n #[inline]\n-fn contains_nonascii(v: usize) -> bool {\n+const fn contains_nonascii(v: usize) -> bool {\n     const NONASCII_MASK: usize = usize::repeat_u8(0x80);\n     (NONASCII_MASK & v) != 0\n }\n \n+/// ASCII test *without* the chunk-at-a-time optimizations.\n+///\n+/// This is carefully structured to produce nice small code -- it's smaller in\n+/// `-O` than what the \"obvious\" ways produces under `-C opt-level=s`.  If you\n+/// touch it, be sure to run (and update if needed) the assembly test.\n+#[unstable(feature = \"str_internals\", issue = \"none\")]\n+#[doc(hidden)]\n+#[inline]\n+pub const fn is_ascii_simple(mut bytes: &[u8]) -> bool {\n+    while let [rest @ .., last] = bytes {\n+        if !last.is_ascii() {\n+            break;\n+        }\n+        bytes = rest;\n+    }\n+    bytes.is_empty()\n+}\n+\n /// Optimized ASCII test that will use usize-at-a-time operations instead of\n /// byte-at-a-time operations (when possible).\n ///\n@@ -280,7 +299,7 @@ fn contains_nonascii(v: usize) -> bool {\n /// If any of these loads produces something for which `contains_nonascii`\n /// (above) returns true, then we know the answer is false.\n #[inline]\n-fn is_ascii(s: &[u8]) -> bool {\n+const fn is_ascii(s: &[u8]) -> bool {\n     const USIZE_SIZE: usize = mem::size_of::<usize>();\n \n     let len = s.len();\n@@ -292,7 +311,7 @@ fn is_ascii(s: &[u8]) -> bool {\n     // We also do this for architectures where `size_of::<usize>()` isn't\n     // sufficient alignment for `usize`, because it's a weird edge case.\n     if len < USIZE_SIZE || len < align_offset || USIZE_SIZE < mem::align_of::<usize>() {\n-        return s.iter().all(|b| b.is_ascii());\n+        return is_ascii_simple(s);\n     }\n \n     // We always read the first word unaligned, which means `align_offset` is\n@@ -321,18 +340,26 @@ fn is_ascii(s: &[u8]) -> bool {\n     // Paranoia check about alignment, since we're about to do a bunch of\n     // unaligned loads. In practice this should be impossible barring a bug in\n     // `align_offset` though.\n-    debug_assert_eq!(word_ptr.addr() % mem::align_of::<usize>(), 0);\n+    // While this method is allowed to spuriously fail in CTFE, if it doesn't\n+    // have alignment information it should have given a `usize::MAX` for\n+    // `align_offset` earlier, sending things through the scalar path instead of\n+    // this one, so this check should pass if it's reachable.\n+    debug_assert!(word_ptr.is_aligned_to(mem::align_of::<usize>()));\n \n     // Read subsequent words until the last aligned word, excluding the last\n     // aligned word by itself to be done in tail check later, to ensure that\n     // tail is always one `usize` at most to extra branch `byte_pos == len`.\n     while byte_pos < len - USIZE_SIZE {\n-        debug_assert!(\n-            // Sanity check that the read is in bounds\n-            (word_ptr.addr() + USIZE_SIZE) <= start.addr().wrapping_add(len) &&\n-            // And that our assumptions about `byte_pos` hold.\n-            (word_ptr.addr() - start.addr()) == byte_pos\n-        );\n+        // Sanity check that the read is in bounds\n+        debug_assert!(byte_pos + USIZE_SIZE <= len);\n+        // And that our assumptions about `byte_pos` hold.\n+        debug_assert!(matches!(\n+            word_ptr.cast::<u8>().guaranteed_eq(start.wrapping_add(byte_pos)),\n+            // These are from the same allocation, so will hopefully always be\n+            // known to match even in CTFE, but if it refuses to compare them\n+            // that's ok since it's just a debug check anyway.\n+            None | Some(true),\n+        ));\n \n         // SAFETY: We know `word_ptr` is properly aligned (because of\n         // `align_offset`), and we know that we have enough bytes between `word_ptr` and the end"}, {"sha": "4c891ba550f3c840a1f876c1177d62d7d61bc260", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/613a5c95ae7401e08d21b8a77f53dadb1d7642d7/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613a5c95ae7401e08d21b8a77f53dadb1d7642d7/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=613a5c95ae7401e08d21b8a77f53dadb1d7642d7", "patch": "@@ -44,6 +44,10 @@ mod raw;\n mod rotate;\n mod specialize;\n \n+#[unstable(feature = \"str_internals\", issue = \"none\")]\n+#[doc(hidden)]\n+pub use ascii::is_ascii_simple;\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use iter::{Chunks, ChunksMut, Windows};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "ef05b25fdd06ce4df659a78b1eab3a0652ffd8b9", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/613a5c95ae7401e08d21b8a77f53dadb1d7642d7/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613a5c95ae7401e08d21b8a77f53dadb1d7642d7/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=613a5c95ae7401e08d21b8a77f53dadb1d7642d7", "patch": "@@ -2358,9 +2358,10 @@ impl str {\n     /// assert!(!non_ascii.is_ascii());\n     /// ```\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_is_ascii\", issue = \"111090\")]\n     #[must_use]\n     #[inline]\n-    pub fn is_ascii(&self) -> bool {\n+    pub const fn is_ascii(&self) -> bool {\n         // We can treat each byte as character here: all multibyte characters\n         // start with a byte that is not in the ASCII range, so we will stop\n         // there already.\n@@ -2372,7 +2373,7 @@ impl str {\n     #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n     #[must_use]\n     #[inline]\n-    pub fn as_ascii(&self) -> Option<&[ascii::Char]> {\n+    pub const fn as_ascii(&self) -> Option<&[ascii::Char]> {\n         // Like in `is_ascii`, we can work on the bytes directly.\n         self.as_bytes().as_ascii()\n     }"}, {"sha": "b3e1fee15a715cad555cd7eb3ffc1fb6f3a18e80", "filename": "tests/assembly/slice-is_ascii.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/613a5c95ae7401e08d21b8a77f53dadb1d7642d7/tests%2Fassembly%2Fslice-is_ascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/613a5c95ae7401e08d21b8a77f53dadb1d7642d7/tests%2Fassembly%2Fslice-is_ascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fassembly%2Fslice-is_ascii.rs?ref=613a5c95ae7401e08d21b8a77f53dadb1d7642d7", "patch": "@@ -0,0 +1,35 @@\n+// revisions: WIN LIN\n+// [WIN] only-windows\n+// [LIN] only-linux\n+// assembly-output: emit-asm\n+// compile-flags: --crate-type=lib -O -C llvm-args=-x86-asm-syntax=intel\n+// min-llvm-version: 14\n+// only-x86_64\n+// ignore-sgx\n+// ignore-debug\n+\n+#![feature(str_internals)]\n+\n+// CHECK-LABEL: is_ascii_simple_demo:\n+#[no_mangle]\n+pub fn is_ascii_simple_demo(bytes: &[u8]) -> bool {\n+    // Linux (System V): pointer is rdi; length is rsi\n+    // Windows: pointer is rcx; length is rdx.\n+\n+    // CHECK-NOT: mov\n+    // CHECK-NOT: test\n+    // CHECK-NOT: cmp\n+\n+    // CHECK: .[[LOOPHEAD:.+]]:\n+    // CHECK-NEXT: mov [[TEMP:.+]], [[LEN:rsi|rdx]]\n+    // CHECK-NEXT: sub [[LEN]], 1\n+    // CHECK-NEXT: jb .[[LOOPEXIT:.+]]\n+    // CHECK-NEXT: cmp byte ptr [{{rdi|rcx}} + [[TEMP]] - 1], 0\n+    // CHECK-NEXT: jns .[[LOOPHEAD]]\n+\n+    // CHECK-NEXT: .[[LOOPEXIT]]:\n+    // CHECK-NEXT: test [[TEMP]], [[TEMP]]\n+    // CHECK-NEXT: sete al\n+    // CHECK-NEXT: ret\n+    core::slice::is_ascii_simple(bytes)\n+}"}]}