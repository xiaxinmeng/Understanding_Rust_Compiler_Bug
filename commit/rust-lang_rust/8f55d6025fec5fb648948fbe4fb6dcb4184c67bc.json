{"sha": "8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "node_id": "C_kwDOAAsO6NoAKDhmNTVkNjAyNWZlYzVmYjY0ODk0OGZiZTRmYjZkY2I0MTg0YzY3YmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-20T22:01:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-20T22:01:48Z"}, "message": "Auto merge of #108286 - matthiaskrgr:rollup-dwy99rf, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #108241 (Fix handling of reexported macro in doc hidden items)\n - #108254 (Refine error span for trait error into borrowed expression)\n - #108255 (Remove old FIXMEs referring to #19596)\n - #108257 (Remove old FIXME that no longer applies)\n - #108276 (small `opaque_type_origin` cleanup)\n - #108279 (Use named arguments for `{,u}int_impls` macro)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f859be11164820ab2f7bf328df890137ae395c6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f859be11164820ab2f7bf328df890137ae395c6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "html_url": "https://github.com/rust-lang/rust/commit/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5243ea5c29b136137c36bd773e5baa663790e097", "url": "https://api.github.com/repos/rust-lang/rust/commits/5243ea5c29b136137c36bd773e5baa663790e097", "html_url": "https://github.com/rust-lang/rust/commit/5243ea5c29b136137c36bd773e5baa663790e097"}, {"sha": "4f532dacfc50287dc61e9ab302dcbdc059bd0a1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f532dacfc50287dc61e9ab302dcbdc059bd0a1b", "html_url": "https://github.com/rust-lang/rust/commit/4f532dacfc50287dc61e9ab302dcbdc059bd0a1b"}], "stats": {"total": 632, "additions": 499, "deletions": 133}, "files": [{"sha": "3f52f174cdf6d55cefbb42039f20e50ed2455de8", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -987,7 +987,6 @@ pub struct Pat<'hir> {\n }\n \n impl<'hir> Pat<'hir> {\n-    // FIXME(#19596) this is a workaround, but there should be a better way\n     fn walk_short_(&self, it: &mut impl FnMut(&Pat<'hir>) -> bool) -> bool {\n         if !it(self) {\n             return false;\n@@ -1015,7 +1014,6 @@ impl<'hir> Pat<'hir> {\n         self.walk_short_(&mut it)\n     }\n \n-    // FIXME(#19596) this is a workaround, but there should be a better way\n     fn walk_(&self, it: &mut impl FnMut(&Pat<'hir>) -> bool) {\n         if !it(self) {\n             return;"}, {"sha": "b2f3a3abb4c50ca76bfa6abbf1916a3e8fececd5", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -32,7 +32,7 @@ use rustc_session::lint;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, NormalizeExt, ObligationCauseCode, ObligationCtxt};\n \n@@ -737,7 +737,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let ty::subst::GenericArgKind::Type(ty) = ty.unpack()\n                     && let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *ty.kind()\n                     && let Some(def_id) = def_id.as_local()\n-                    && self.opaque_type_origin(def_id, DUMMY_SP).is_some() {\n+                    && self.opaque_type_origin(def_id).is_some() {\n                     return None;\n                 }\n             }"}, {"sha": "39e0ea98f96e3263f9bb01624164ca1b0da92007", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -549,6 +549,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return Err(expr);\n         };\n \n+        if let (\n+            hir::ExprKind::AddrOf(_borrow_kind, _borrow_mutability, borrowed_expr),\n+            ty::Ref(_ty_region, ty_ref_type, _ty_mutability),\n+        ) = (&expr.kind, in_ty.kind())\n+        {\n+            // We can \"drill into\" the borrowed expression.\n+            return self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param,\n+                borrowed_expr,\n+                (*ty_ref_type).into(),\n+            );\n+        }\n+\n         if let (hir::ExprKind::Tup(expr_elements), ty::Tuple(in_ty_elements)) =\n             (&expr.kind, in_ty.kind())\n         {"}, {"sha": "4b08832eddc9d08b24aaa4d4d839c1f9a7c05c82", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -601,7 +601,6 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    // FIXME(#19596) This is a workaround, but there should be a better way to do this\n     fn cat_pattern_<F>(\n         &self,\n         mut place_with_id: PlaceWithHirId<'tcx>,"}, {"sha": "e783443502b865357a8007730bbf82ae8366c095", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -57,9 +57,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n         let mut obligations = vec![];\n         let replace_opaque_type = |def_id: DefId| {\n-            def_id\n-                .as_local()\n-                .map_or(false, |def_id| self.opaque_type_origin(def_id, span).is_some())\n+            def_id.as_local().map_or(false, |def_id| self.opaque_type_origin(def_id).is_some())\n         };\n         let value = value.fold_with(&mut BottomUpFolder {\n             tcx: self.tcx,\n@@ -144,9 +142,9 @@ impl<'tcx> InferCtxt<'tcx> {\n                         //     let x = || foo(); // returns the Opaque assoc with `foo`\n                         // }\n                         // ```\n-                        self.opaque_type_origin(def_id, cause.span)?\n+                        self.opaque_type_origin(def_id)?\n                     }\n-                    DefiningAnchor::Bubble => self.opaque_ty_origin_unchecked(def_id, cause.span),\n+                    DefiningAnchor::Bubble => self.opaque_type_origin_unchecked(def_id),\n                     DefiningAnchor::Error => return None,\n                 };\n                 if let ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }) = *b.kind() {\n@@ -155,9 +153,8 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // no one encounters it in practice.\n                     // It does occur however in `fn fut() -> impl Future<Output = i32> { async { 42 } }`,\n                     // where it is of no concern, so we only check for TAITs.\n-                    if let Some(OpaqueTyOrigin::TyAlias) = b_def_id\n-                        .as_local()\n-                        .and_then(|b_def_id| self.opaque_type_origin(b_def_id, cause.span))\n+                    if let Some(OpaqueTyOrigin::TyAlias) =\n+                        b_def_id.as_local().and_then(|b_def_id| self.opaque_type_origin(b_def_id))\n                     {\n                         self.tcx.sess.emit_err(OpaqueHiddenTypeDiag {\n                             span: cause.span,\n@@ -371,24 +368,18 @@ impl<'tcx> InferCtxt<'tcx> {\n         });\n     }\n \n+    /// Returns the origin of the opaque type `def_id` if we're currently\n+    /// in its defining scope.\n     #[instrument(skip(self), level = \"trace\", ret)]\n-    pub fn opaque_type_origin(&self, def_id: LocalDefId, span: Span) -> Option<OpaqueTyOrigin> {\n+    pub fn opaque_type_origin(&self, def_id: LocalDefId) -> Option<OpaqueTyOrigin> {\n         let opaque_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let parent_def_id = match self.defining_use_anchor {\n             DefiningAnchor::Bubble | DefiningAnchor::Error => return None,\n             DefiningAnchor::Bind(bind) => bind,\n         };\n-        let item_kind = &self.tcx.hir().expect_item(def_id).kind;\n-\n-        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) = item_kind else {\n-            span_bug!(\n-                span,\n-                \"weird opaque type: {:#?}, {:#?}\",\n-                def_id,\n-                item_kind\n-            )\n-        };\n-        let in_definition_scope = match *origin {\n+\n+        let origin = self.opaque_type_origin_unchecked(def_id);\n+        let in_definition_scope = match origin {\n             // Async `impl Trait`\n             hir::OpaqueTyOrigin::AsyncFn(parent) => parent == parent_def_id,\n             // Anonymous `impl Trait`\n@@ -398,16 +389,17 @@ impl<'tcx> InferCtxt<'tcx> {\n                 may_define_opaque_type(self.tcx, parent_def_id, opaque_hir_id)\n             }\n         };\n-        trace!(?origin);\n-        in_definition_scope.then_some(*origin)\n+        in_definition_scope.then_some(origin)\n     }\n \n+    /// Returns the origin of the opaque type `def_id` even if we are not in its\n+    /// defining scope.\n     #[instrument(skip(self), level = \"trace\", ret)]\n-    fn opaque_ty_origin_unchecked(&self, def_id: LocalDefId, span: Span) -> OpaqueTyOrigin {\n+    fn opaque_type_origin_unchecked(&self, def_id: LocalDefId) -> OpaqueTyOrigin {\n         match self.tcx.hir().expect_item(def_id).kind {\n             hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => origin,\n             ref itemkind => {\n-                span_bug!(span, \"weird opaque type: {:?}, {:#?}\", def_id, itemkind)\n+                bug!(\"weird opaque type: {:?}, {:#?}\", def_id, itemkind)\n             }\n         }\n     }"}, {"sha": "377c364961b9dd1ed6f673b589a888b7365d8af3", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -430,11 +430,6 @@ impl<D: Decoder, T: Decodable<D> + Copy> Decodable<D> for Cell<T> {\n     }\n }\n \n-// FIXME: #15036\n-// Should use `try_borrow`, returning an\n-// `encoder.error(\"attempting to Encode borrowed RefCell\")`\n-// from `encode` when `try_borrow` returns `None`.\n-\n impl<S: Encoder, T: Encodable<S>> Encodable<S> for RefCell<T> {\n     fn encode(&self, s: &mut S) {\n         self.borrow().encode(s);"}, {"sha": "572191d0f9bbbf9d2ee00246fd2df1967ee47c21", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -1,9 +1,24 @@\n macro_rules! int_impl {\n-    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr, $BITS_MINUS_ONE:expr, $Min:expr, $Max:expr,\n-     $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n-     $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n-     $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr,\n-     $bound_condition:expr) => {\n+    (\n+        Self = $SelfT:ty,\n+        ActualT = $ActualT:ident,\n+        UnsignedT = $UnsignedT:ty,\n+        BITS = $BITS:expr,\n+        BITS_MINUS_ONE = $BITS_MINUS_ONE:expr,\n+        Min = $Min:expr,\n+        Max = $Max:expr,\n+        rot = $rot:expr,\n+        rot_op = $rot_op:expr,\n+        rot_result = $rot_result:expr,\n+        swap_op = $swap_op:expr,\n+        swapped = $swapped:expr,\n+        reversed = $reversed:expr,\n+        le_bytes = $le_bytes:expr,\n+        be_bytes = $be_bytes:expr,\n+        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n+        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n+        bound_condition = $bound_condition:expr,\n+    ) => {\n         /// The smallest value that can be represented by this integer type\n         #[doc = concat!(\"(&minus;2<sup>\", $BITS_MINUS_ONE, \"</sup>\", $bound_condition, \").\")]\n         ///"}, {"sha": "a50c91579fa76818e4c467148616f9654464b738", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 317, "deletions": 67, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -226,72 +226,217 @@ macro_rules! widening_impl {\n }\n \n impl i8 {\n-    int_impl! { i8, i8, u8, 8, 7, -128, 127, 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n-    \"[0x12]\", \"[0x12]\", \"\", \"\", \"\" }\n+    int_impl! {\n+        Self = i8,\n+        ActualT = i8,\n+        UnsignedT = u8,\n+        BITS = 8,\n+        BITS_MINUS_ONE = 7,\n+        Min = -128,\n+        Max = 127,\n+        rot = 2,\n+        rot_op = \"-0x7e\",\n+        rot_result = \"0xa\",\n+        swap_op = \"0x12\",\n+        swapped = \"0x12\",\n+        reversed = \"0x48\",\n+        le_bytes = \"[0x12]\",\n+        be_bytes = \"[0x12]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n }\n \n impl i16 {\n-    int_impl! { i16, i16, u16, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n-    \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\", \"\" }\n+    int_impl! {\n+        Self = i16,\n+        ActualT = i16,\n+        UnsignedT = u16,\n+        BITS = 16,\n+        BITS_MINUS_ONE = 15,\n+        Min = -32768,\n+        Max = 32767,\n+        rot = 4,\n+        rot_op = \"-0x5ffd\",\n+        rot_result = \"0x3a\",\n+        swap_op = \"0x1234\",\n+        swapped = \"0x3412\",\n+        reversed = \"0x2c48\",\n+        le_bytes = \"[0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n }\n \n impl i32 {\n-    int_impl! { i32, i32, u32, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n-    \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\", \"\" }\n+    int_impl! {\n+        Self = i32,\n+        ActualT = i32,\n+        UnsignedT = u32,\n+        BITS = 32,\n+        BITS_MINUS_ONE = 31,\n+        Min = -2147483648,\n+        Max = 2147483647,\n+        rot = 8,\n+        rot_op = \"0x10000b3\",\n+        rot_result = \"0xb301\",\n+        swap_op = \"0x12345678\",\n+        swapped = \"0x78563412\",\n+        reversed = \"0x1e6a2c48\",\n+        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n }\n \n impl i64 {\n-    int_impl! { i64, i64, u64, 64, 63, -9223372036854775808, 9223372036854775807, 12,\n-    \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n-    \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\", \"\", \"\", \"\" }\n+    int_impl! {\n+        Self = i64,\n+        ActualT = i64,\n+        UnsignedT = u64,\n+        BITS = 64,\n+        BITS_MINUS_ONE = 63,\n+        Min = -9223372036854775808,\n+        Max = 9223372036854775807,\n+        rot = 12,\n+        rot_op = \"0xaa00000000006e1\",\n+        rot_result = \"0x6e10aa\",\n+        swap_op = \"0x1234567890123456\",\n+        swapped = \"0x5634129078563412\",\n+        reversed = \"0x6a2c48091e6a2c48\",\n+        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n }\n \n impl i128 {\n-    int_impl! { i128, i128, u128, 128, 127, -170141183460469231731687303715884105728,\n-    170141183460469231731687303715884105727, 16,\n-    \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n-    \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n-    \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n-      0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n-      0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\", \"\", \"\", \"\" }\n+    int_impl! {\n+        Self = i128,\n+        ActualT = i128,\n+        UnsignedT = u128,\n+        BITS = 128,\n+        BITS_MINUS_ONE = 127,\n+        Min = -170141183460469231731687303715884105728,\n+        Max = 170141183460469231731687303715884105727,\n+        rot = 16,\n+        rot_op = \"0x13f40000000000000000000000004f76\",\n+        rot_result = \"0x4f7613f4\",\n+        swap_op = \"0x12345678901234567890123456789012\",\n+        swapped = \"0x12907856341290785634129078563412\",\n+        reversed = \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n+        le_bytes = \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n+            0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n+            0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n impl isize {\n-    int_impl! { isize, i16, usize, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n-    \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n-    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!(),\n-    \" on 16-bit targets\" }\n+    int_impl! {\n+        Self = isize,\n+        ActualT = i16,\n+        UnsignedT = usize,\n+        BITS = 16,\n+        BITS_MINUS_ONE = 15,\n+        Min = -32768,\n+        Max = 32767,\n+        rot = 4,\n+        rot_op = \"-0x5ffd\",\n+        rot_result = \"0x3a\",\n+        swap_op = \"0x1234\",\n+        swapped = \"0x3412\",\n+        reversed = \"0x2c48\",\n+        le_bytes = \"[0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34]\",\n+        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n+        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n+        bound_condition = \" on 16-bit targets\",\n+    }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n impl isize {\n-    int_impl! { isize, i32, usize, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n-    \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78]\",\n-    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!(),\n-    \" on 32-bit targets\" }\n+    int_impl! {\n+        Self = isize,\n+        ActualT = i32,\n+        UnsignedT = usize,\n+        BITS = 32,\n+        BITS_MINUS_ONE = 31,\n+        Min = -2147483648,\n+        Max = 2147483647,\n+        rot = 8,\n+        rot_op = \"0x10000b3\",\n+        rot_result = \"0xb301\",\n+        swap_op = \"0x12345678\",\n+        swapped = \"0x78563412\",\n+        reversed = \"0x1e6a2c48\",\n+        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n+        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n+        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n+        bound_condition = \" on 32-bit targets\",\n+    }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n impl isize {\n-    int_impl! { isize, i64, usize, 64, 63, -9223372036854775808, 9223372036854775807,\n-    12, \"0xaa00000000006e1\", \"0x6e10aa\",  \"0x1234567890123456\", \"0x5634129078563412\",\n-    \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n-    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!(),\n-    \" on 64-bit targets\" }\n+    int_impl! {\n+        Self = isize,\n+        ActualT = i64,\n+        UnsignedT = usize,\n+        BITS = 64,\n+        BITS_MINUS_ONE = 63,\n+        Min = -9223372036854775808,\n+        Max = 9223372036854775807,\n+        rot = 12,\n+        rot_op = \"0xaa00000000006e1\",\n+        rot_result = \"0x6e10aa\",\n+        swap_op = \"0x1234567890123456\",\n+        swapped = \"0x5634129078563412\",\n+        reversed = \"0x6a2c48091e6a2c48\",\n+        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n+        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n+        bound_condition = \" on 64-bit targets\",\n+    }\n }\n \n /// If 6th bit set ascii is upper case.\n const ASCII_CASE_MASK: u8 = 0b0010_0000;\n \n impl u8 {\n-    uint_impl! { u8, u8, i8, NonZeroU8, 8, 255, 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n-    \"[0x12]\", \"\", \"\", \"\" }\n+    uint_impl! {\n+        Self = u8,\n+        ActualT = u8,\n+        SignedT = i8,\n+        NonZeroT = NonZeroU8,\n+        BITS = 8,\n+        MAX = 255,\n+        rot = 2,\n+        rot_op = \"0x82\",\n+        rot_result = \"0xa\",\n+        swap_op = \"0x12\",\n+        swapped = \"0x12\",\n+        reversed = \"0x48\",\n+        le_bytes = \"[0x12]\",\n+        be_bytes = \"[0x12]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n     widening_impl! { u8, u16, 8, unsigned }\n \n     /// Checks if the value is within the ASCII range.\n@@ -875,8 +1020,25 @@ impl u8 {\n }\n \n impl u16 {\n-    uint_impl! { u16, u16, i16, NonZeroU16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n-    \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\", \"\" }\n+    uint_impl! {\n+        Self = u16,\n+        ActualT = u16,\n+        SignedT = i16,\n+        NonZeroT = NonZeroU16,\n+        BITS = 16,\n+        MAX = 65535,\n+        rot = 4,\n+        rot_op = \"0xa003\",\n+        rot_result = \"0x3a\",\n+        swap_op = \"0x1234\",\n+        swapped = \"0x3412\",\n+        reversed = \"0x2c48\",\n+        le_bytes = \"[0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n     widening_impl! { u16, u32, 16, unsigned }\n \n     /// Checks if the value is a Unicode surrogate code point, which are disallowed values for [`char`].\n@@ -906,56 +1068,144 @@ impl u16 {\n }\n \n impl u32 {\n-    uint_impl! { u32, u32, i32, NonZeroU32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n-    \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\", \"\" }\n+    uint_impl! {\n+        Self = u32,\n+        ActualT = u32,\n+        SignedT = i32,\n+        NonZeroT = NonZeroU32,\n+        BITS = 32,\n+        MAX = 4294967295,\n+        rot = 8,\n+        rot_op = \"0x10000b3\",\n+        rot_result = \"0xb301\",\n+        swap_op = \"0x12345678\",\n+        swapped = \"0x78563412\",\n+        reversed = \"0x1e6a2c48\",\n+        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n     widening_impl! { u32, u64, 32, unsigned }\n }\n \n impl u64 {\n-    uint_impl! { u64, u64, i64, NonZeroU64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n-    \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n-    \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n-    \"\", \"\", \"\"}\n+    uint_impl! {\n+        Self = u64,\n+        ActualT = u64,\n+        SignedT = i64,\n+        NonZeroT = NonZeroU64,\n+        BITS = 64,\n+        MAX = 18446744073709551615,\n+        rot = 12,\n+        rot_op = \"0xaa00000000006e1\",\n+        rot_result = \"0x6e10aa\",\n+        swap_op = \"0x1234567890123456\",\n+        swapped = \"0x5634129078563412\",\n+        reversed = \"0x6a2c48091e6a2c48\",\n+        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n     widening_impl! { u64, u128, 64, unsigned }\n }\n \n impl u128 {\n-    uint_impl! { u128, u128, i128, NonZeroU128, 128, 340282366920938463463374607431768211455, 16,\n-    \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n-    \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n-    \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n-      0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n-      0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\",\n-     \"\", \"\", \"\"}\n+    uint_impl! {\n+        Self = u128,\n+        ActualT = u128,\n+        SignedT = i128,\n+        NonZeroT = NonZeroU128,\n+        BITS = 128,\n+        MAX = 340282366920938463463374607431768211455,\n+        rot = 16,\n+        rot_op = \"0x13f40000000000000000000000004f76\",\n+        rot_result = \"0x4f7613f4\",\n+        swap_op = \"0x12345678901234567890123456789012\",\n+        swapped = \"0x12907856341290785634129078563412\",\n+        reversed = \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n+        le_bytes = \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n+            0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n+            0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n impl usize {\n-    uint_impl! { usize, u16, isize, NonZeroUsize, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n-    \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n-    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!(),\n-    \" on 16-bit targets\" }\n+    uint_impl! {\n+        Self = usize,\n+        ActualT = u16,\n+        SignedT = isize,\n+        NonZeroT = NonZeroUsize,\n+        BITS = 16,\n+        MAX = 65535,\n+        rot = 4,\n+        rot_op = \"0xa003\",\n+        rot_result = \"0x3a\",\n+        swap_op = \"0x1234\",\n+        swapped = \"0x3412\",\n+        reversed = \"0x2c48\",\n+        le_bytes = \"[0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34]\",\n+        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n+        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n+        bound_condition = \" on 16-bit targets\",\n+    }\n     widening_impl! { usize, u32, 16, unsigned }\n }\n+\n #[cfg(target_pointer_width = \"32\")]\n impl usize {\n-    uint_impl! { usize, u32, isize, NonZeroUsize, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n-    \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n-    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!(),\n-    \" on 32-bit targets\" }\n+    uint_impl! {\n+        Self = usize,\n+        ActualT = u32,\n+        SignedT = isize,\n+        NonZeroT = NonZeroUsize,\n+        BITS = 32,\n+        MAX = 4294967295,\n+        rot = 8,\n+        rot_op = \"0x10000b3\",\n+        rot_result = \"0xb301\",\n+        swap_op = \"0x12345678\",\n+        swapped = \"0x78563412\",\n+        reversed = \"0x1e6a2c48\",\n+        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n+        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n+        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n+        bound_condition = \" on 32-bit targets\",\n+    }\n     widening_impl! { usize, u64, 32, unsigned }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n impl usize {\n-    uint_impl! { usize, u64, isize, NonZeroUsize, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n-    \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n-    \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n-    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!(),\n-    \" on 64-bit targets\" }\n+    uint_impl! {\n+        Self = usize,\n+        ActualT = u64,\n+        SignedT = isize,\n+        NonZeroT = NonZeroUsize,\n+        BITS = 64,\n+        MAX = 18446744073709551615,\n+        rot = 12,\n+        rot_op = \"0xaa00000000006e1\",\n+        rot_result = \"0x6e10aa\",\n+        swap_op = \"0x1234567890123456\",\n+        swapped = \"0x5634129078563412\",\n+        reversed = \"0x6a2c48091e6a2c48\",\n+        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n+        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n+        bound_condition = \" on 64-bit targets\",\n+    }\n     widening_impl! { usize, u128, 64, unsigned }\n }\n "}, {"sha": "c4fe8e966fdbff23daccf7a491db6ca1a1b277b0", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -1,10 +1,23 @@\n macro_rules! uint_impl {\n-    ($SelfT:ty, $ActualT:ident, $SignedT:ident, $NonZeroT:ident,\n-        $BITS:expr, $MaxV:expr,\n-        $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n-        $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n-        $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr,\n-        $bound_condition:expr) => {\n+    (\n+        Self = $SelfT:ty,\n+        ActualT = $ActualT:ident,\n+        SignedT = $SignedT:ident,\n+        NonZeroT = $NonZeroT:ident,\n+        BITS = $BITS:expr,\n+        MAX = $MaxV:expr,\n+        rot = $rot:expr,\n+        rot_op = $rot_op:expr,\n+        rot_result = $rot_result:expr,\n+        swap_op = $swap_op:expr,\n+        swapped = $swapped:expr,\n+        reversed = $reversed:expr,\n+        le_bytes = $le_bytes:expr,\n+        be_bytes = $be_bytes:expr,\n+        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n+        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n+        bound_condition = $bound_condition:expr,\n+    ) => {\n         /// The smallest value that can be represented by this integer type.\n         ///\n         /// # Examples"}, {"sha": "890b3e8d67f7a9e7a8f9378adfb843aec9bb0823", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> Stripper<'a, 'tcx> {\n \n     /// In case `i` is a non-hidden impl block, then we special-case it by changing the value\n     /// of `is_in_hidden_item` to `true` because the impl children inherit its visibility.\n-    fn recurse_in_impl(&mut self, i: Item) -> Item {\n+    fn recurse_in_impl_or_exported_macro(&mut self, i: Item) -> Item {\n         let prev = mem::replace(&mut self.is_in_hidden_item, false);\n         let ret = self.fold_item_recur(i);\n         self.is_in_hidden_item = prev;\n@@ -73,9 +73,17 @@ impl<'a, 'tcx> Stripper<'a, 'tcx> {\n impl<'a, 'tcx> DocFolder for Stripper<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         let has_doc_hidden = i.attrs.lists(sym::doc).has_word(sym::hidden);\n-        let is_impl = matches!(*i.kind, clean::ImplItem(..));\n+        let is_impl_or_exported_macro = match *i.kind {\n+            clean::ImplItem(..) => true,\n+            // If the macro has the `#[macro_export]` attribute, it means it's accessible at the\n+            // crate level so it should be handled differently.\n+            clean::MacroItem(..) => {\n+                i.attrs.other_attrs.iter().any(|attr| attr.has_name(sym::macro_export))\n+            }\n+            _ => false,\n+        };\n         let mut is_hidden = has_doc_hidden;\n-        if !is_impl {\n+        if !is_impl_or_exported_macro {\n             is_hidden = self.is_in_hidden_item || has_doc_hidden;\n             if !is_hidden && i.inline_stmt_id.is_none() {\n                 // We don't need to check if it's coming from a reexport since the reexport itself was\n@@ -92,8 +100,8 @@ impl<'a, 'tcx> DocFolder for Stripper<'a, 'tcx> {\n             if self.update_retained {\n                 self.retained.insert(i.item_id);\n             }\n-            return Some(if is_impl {\n-                self.recurse_in_impl(i)\n+            return Some(if is_impl_or_exported_macro {\n+                self.recurse_in_impl_or_exported_macro(i)\n             } else {\n                 self.set_is_in_hidden_item_and_fold(false, i)\n             });"}, {"sha": "684f0494fd5e7cb5863789e4f4ee9d2974a1daf6", "filename": "tests/rustdoc/issue-108231.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/tests%2Frustdoc%2Fissue-108231.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/tests%2Frustdoc%2Fissue-108231.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-108231.rs?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -0,0 +1,23 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/108231>.\n+// Macros with `#[macro_export]` attribute should be visible at the top level\n+// even if they are inside a doc hidden item.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+// @count - '//*[@id=\"main-content\"]//a[@class=\"macro\"]' 1\n+// @has - '//*[@id=\"main-content\"]//a[@class=\"macro\"]' 'foo'\n+\n+#[doc(hidden)]\n+pub mod __internal {\n+    /// This one should be visible.\n+    #[macro_export]\n+    macro_rules! foo {\n+        () => {};\n+    }\n+\n+    /// This one should be hidden.\n+    macro_rules! bar {\n+        () => {};\n+    }\n+}"}, {"sha": "afcfa979616ecba9fef8fee430fb30d175db9d33", "filename": "tests/rustdoc/reexport-hidden-macro.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/tests%2Frustdoc%2Freexport-hidden-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/tests%2Frustdoc%2Freexport-hidden-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-hidden-macro.rs?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -0,0 +1,22 @@\n+// Ensure that inlined reexport of hidden macros is working as expected.\n+// Part of <https://github.com/rust-lang/rust/issues/59368>.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+// @has - '//*[@id=\"main-content\"]//a[@href=\"macro.Macro2.html\"]' 'Macro2'\n+\n+// @has 'foo/macro.Macro2.html'\n+// @has - '//*[@class=\"docblock\"]' 'Displayed'\n+\n+#[macro_export]\n+#[doc(hidden)]\n+macro_rules! foo {\n+    () => {};\n+}\n+\n+/// not displayed\n+pub use crate::foo as Macro;\n+/// Displayed\n+#[doc(inline)]\n+pub use crate::foo as Macro2;"}, {"sha": "6fea409ed4716244a484c2ba1c86f3ff4c86e76c", "filename": "tests/ui/errors/traits/blame-trait-error-spans-on-exprs.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -71,6 +71,8 @@ struct DoubleWrapper<T> {\n \n impl<T: T1> T1 for DoubleWrapper<T> {}\n \n+impl<'a, T: T2> T1 for &'a T {}\n+\n fn example<Q>(q: Q) {\n     // In each of the following examples, we expect the error span to point at the 'q' variable,\n     // since the missing constraint is `Q: T3`.\n@@ -126,6 +128,10 @@ fn example<Q>(q: Q) {\n         Two { a: Two { a: (), b: Two { a: Two { a: (), b: q }, b: () } }, b: () },\n         //~^ ERROR the trait bound `Q: T1` is not satisfied [E0277]\n     );\n+\n+    // Verifies for reference:\n+    want(&Burrito { spicy: false, filling: q });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n }\n \n fn main() {}"}, {"sha": "6913771f2883e020f23898696f41545245c73246", "filename": "tests/ui/errors/traits/blame-trait-error-spans-on-exprs.stderr", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:79:60\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:81:60\n    |\n LL |     want(Wrapper { value: Burrito { spicy: false, filling: q } });\n    |     ---- required by a bound introduced by this call       ^ the trait `T3` is not implemented for `Q`\n@@ -29,7 +29,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:83:84\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:85:84\n    |\n LL |     want(Wrapper { value: BurritoKinds::SmallBurrito { spicy: true, small_filling: q } });\n    |     ---- required by a bound introduced by this call                               ^ the trait `T3` is not implemented for `Q`\n@@ -59,7 +59,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:87:39\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:89:39\n    |\n LL |     want(Wrapper { value: Taco(false, q) });\n    |     ----                              ^ the trait `T3` is not implemented for `Q`\n@@ -91,7 +91,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:91:27\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:93:27\n    |\n LL |     want(Wrapper { value: TacoKinds::OneTaco(false, q) });\n    |     ----                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `T3` is not implemented for `Q`\n@@ -123,7 +123,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:95:74\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:97:74\n    |\n LL |     want(Wrapper { value: GenericBurrito { spiciness: NotSpicy, filling: q } });\n    |     ---- required by a bound introduced by this call                     ^ the trait `T3` is not implemented for `Q`\n@@ -153,7 +153,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T2` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:99:14\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:101:14\n    |\n LL |     want((3, q));\n    |     ----     ^ the trait `T2` is not implemented for `Q`\n@@ -178,7 +178,7 @@ LL | fn example<Q: T2>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:103:31\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:105:31\n    |\n LL |     want(Wrapper { value: (3, q) });\n    |     ----                      ^ the trait `T3` is not implemented for `Q`\n@@ -210,7 +210,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:107:15\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:109:15\n    |\n LL |     want(((3, q), 5));\n    |     ----      ^ the trait `T3` is not implemented for `Q`\n@@ -242,7 +242,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T1` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:110:49\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:112:49\n    |\n LL |     want(DoubleWrapper { item: Wrapper { value: q } });\n    |     ----                                        ^ the trait `T1` is not implemented for `Q`\n@@ -267,7 +267,7 @@ LL | fn example<Q: T1>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T1` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:113:88\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:115:88\n    |\n LL |     want(DoubleWrapper { item: Wrapper { value: DoubleWrapper { item: Wrapper { value: q } } } });\n    |     ---- required by a bound introduced by this call                                   ^ the trait `T1` is not implemented for `Q`\n@@ -292,7 +292,7 @@ LL | fn example<Q: T1>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:117:27\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:119:27\n    |\n LL |     want(Wrapper { value: AliasBurrito { spiciness: q, filling: q } });\n    |     ----                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `T3` is not implemented for `Q`\n@@ -324,7 +324,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T1` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:120:35\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:122:35\n    |\n LL |     want(Two { a: Two { a: (), b: q }, b: () });\n    |     ----                          ^ the trait `T1` is not implemented for `Q`\n@@ -349,7 +349,7 @@ LL | fn example<Q: T1>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T1` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:126:59\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:128:59\n    |\n LL |     want(\n    |     ---- required by a bound introduced by this call\n@@ -375,6 +375,38 @@ help: consider restricting type parameter `Q`\n LL | fn example<Q: T1>(q: Q) {\n    |             ++++\n \n-error: aborting due to 13 previous errors\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:133:44\n+   |\n+LL |     want(&Burrito { spicy: false, filling: q });\n+   |     ----                                   ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `Burrito<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:22:13\n+   |\n+LL | impl<A: T3> T2 for Burrito<A> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `&Burrito<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:74:17\n+   |\n+LL | impl<'a, T: T2> T1 for &'a T {}\n+   |             --  ^^     ^^^^^\n+   |             |\n+   |             unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error: aborting due to 14 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "49105de3d691dd395b7f7f450c8fba5b862d69a6", "filename": "tests/ui/traits/suggest-deferences/issue-39029.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/tests%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-39029.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8f55d6025fec5fb648948fbe4fb6dcb4184c67bc/tests%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-39029.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-39029.stderr?ref=8f55d6025fec5fb648948fbe4fb6dcb4184c67bc", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `NoToSocketAddrs: ToSocketAddrs` is not satisfied\n-  --> $DIR/issue-39029.rs:16:37\n+  --> $DIR/issue-39029.rs:16:38\n    |\n LL |     let _errors = TcpListener::bind(&bad);\n-   |                   ----------------- ^^^^ the trait `ToSocketAddrs` is not implemented for `NoToSocketAddrs`\n+   |                   -----------------  ^^^ the trait `ToSocketAddrs` is not implemented for `NoToSocketAddrs`\n    |                   |\n    |                   required by a bound introduced by this call\n    |"}]}