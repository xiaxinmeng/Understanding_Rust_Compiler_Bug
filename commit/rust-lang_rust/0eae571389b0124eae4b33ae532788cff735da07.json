{"sha": "0eae571389b0124eae4b33ae532788cff735da07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYWU1NzEzODliMDEyNGVhZTRiMzNhZTUzMjc4OGNmZjczNWRhMDc=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-11T00:46:19Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-11T00:53:09Z"}, "message": "Implement mutex_arc and rw_arc; add some tests", "tree": {"sha": "60e849f5a1341e542973ef8872043101654580a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60e849f5a1341e542973ef8872043101654580a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0eae571389b0124eae4b33ae532788cff735da07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0eae571389b0124eae4b33ae532788cff735da07", "html_url": "https://github.com/rust-lang/rust/commit/0eae571389b0124eae4b33ae532788cff735da07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0eae571389b0124eae4b33ae532788cff735da07/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42825fbea659b555e7624c5a4f2e0f5bc3264c24", "url": "https://api.github.com/repos/rust-lang/rust/commits/42825fbea659b555e7624c5a4f2e0f5bc3264c24", "html_url": "https://github.com/rust-lang/rust/commit/42825fbea659b555e7624c5a4f2e0f5bc3264c24"}], "stats": {"total": 274, "additions": 274, "deletions": 0}, "files": [{"sha": "49ec3b3c86d711827da2326da21cbc1217bda47d", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/0eae571389b0124eae4b33ae532788cff735da07/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eae571389b0124eae4b33ae532788cff735da07/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=0eae571389b0124eae4b33ae532788cff735da07", "patch": "@@ -5,8 +5,10 @@\n \n import unsafe::{shared_mutable_state, clone_shared_mutable_state,\n                 get_shared_mutable_state, get_shared_immutable_state};\n+import sync::{condvar, mutex, rwlock};\n \n export arc, clone, get;\n+export mutex_arc, rw_arc;\n \n /****************************************************************************\n  * Immutable ARC\n@@ -43,10 +45,181 @@ fn clone<T: const send>(rc: &arc<T>) -> arc<T> {\n  * Mutex protected ARC (unsafe)\n  ****************************************************************************/\n \n+struct mutex_arc_inner<T: send> { lock: mutex; failed: bool; data: T; }\n+/// An ARC with mutable data protected by a blocking mutex.\n+struct mutex_arc<T: send> { x: shared_mutable_state<mutex_arc_inner<T>>; }\n+\n+/// Create a mutex-protected ARC with the supplied data.\n+fn mutex_arc<T: send>(+user_data: T) -> mutex_arc<T> {\n+    let data = mutex_arc_inner {\n+        lock: mutex(), failed: false, data: user_data\n+    };\n+    mutex_arc { x: unsafe { shared_mutable_state(data) } }\n+}\n+\n+impl<T: send> &mutex_arc<T> {\n+    /// Duplicate a mutex-protected ARC, as arc::clone.\n+    fn clone() -> mutex_arc<T> {\n+        // NB: Cloning the underlying mutex is not necessary. Its reference\n+        // count would be exactly the same as the shared state's.\n+        mutex_arc { x: unsafe { clone_shared_mutable_state(&self.x) } }\n+    }\n+\n+    /**\n+     * Access the underlying mutable data with mutual exclusion from other\n+     * tasks. The argument closure will be run with the mutex locked; all\n+     * other tasks wishing to access the data will block until the closure\n+     * finishes running.\n+     *\n+     * The reason this function is 'unsafe' is because it is possible to\n+     * construct a circular reference among multiple ARCs by mutating the\n+     * underlying data. This creates potential for deadlock, but worse, this\n+     * will guarantee a memory leak of all involved ARCs. Using mutex ARCs\n+     * inside of other ARCs is safe in absence of circular references.\n+     *\n+     * If you wish to nest mutex_arcs, one strategy for ensuring safety at\n+     * runtime is to add a \"nesting level counter\" inside the stored data, and\n+     * when traversing the arcs, assert that they monotonically decrease.\n+     *\n+     * # Failure\n+     *\n+     * Failing while inside the ARC will unlock the ARC while unwinding, so\n+     * that other tasks won't block forever. It will also poison the ARC:\n+     * any tasks that subsequently try to access it (including those already\n+     * blocked on the mutex) will also fail immediately.\n+     */\n+    #[inline(always)]\n+    unsafe fn access<U>(blk: fn(x: &mut T) -> U) -> U {\n+        let state = unsafe { get_shared_mutable_state(&self.x) };\n+        // Borrowck would complain about this if the function were not already\n+        // unsafe. See borrow_rwlock, far below.\n+        do (&state.lock).lock {\n+            check_poison(true, state.failed);\n+            state.failed = true;\n+            let result = blk(&mut state.data);\n+            state.failed = false;\n+            result\n+        }\n+    }\n+/* FIXME(#3145): Make this compile; borrowck doesn't like it..?\n+    /// As access(), but with a condvar, as sync::mutex.lock_cond().\n+    #[inline(always)]\n+    unsafe fn access_cond<U>(blk: fn(x: &mut T, condvar) -> U) -> U {\n+        let state = unsafe { get_shared_mutable_state(&self.x) };\n+        do (&state.lock).lock_cond |cond| {\n+            check_poison(true, state.failed);\n+            state.failed = true;\n+            let result = blk(&mut state.data, cond);\n+            state.failed = false;\n+            result\n+        }\n+    }\n+*/\n+}\n+\n+// Common code for {mutex.access,rwlock.write}{,_cond}.\n+#[inline(always)]\n+fn check_poison(is_mutex: bool, failed: bool) {\n+    if failed {\n+        if is_mutex {\n+            fail ~\"Poisoned mutex_arc - another task failed inside!\";\n+        } else {\n+            fail ~\"Poisoned rw_arc - another task failed inside!\";\n+        }\n+    }\n+}\n+\n /****************************************************************************\n  * R/W lock protected ARC\n  ****************************************************************************/\n \n+struct rw_arc_inner<T: const send> { lock: rwlock; failed: bool; data: T; }\n+/**\n+ * A dual-mode ARC protected by a reader-writer lock. The data can be accessed\n+ * mutably or immutably, and immutably-accessing tasks may run concurrently.\n+ *\n+ * Unlike mutex_arcs, rw_arcs are safe, because they cannot be nested.\n+ */\n+struct rw_arc<T: const send> {\n+    x: shared_mutable_state<rw_arc_inner<T>>;\n+    mut cant_nest: ();\n+}\n+\n+/// Create a reader/writer ARC with the supplied data.\n+fn rw_arc<T: const send>(+user_data: T) -> rw_arc<T> {\n+    let data = rw_arc_inner {\n+        lock: rwlock(), failed: false, data: user_data\n+    };\n+    rw_arc { x: unsafe { shared_mutable_state(data) }, cant_nest: () }\n+}\n+\n+impl<T: const send> &rw_arc<T> {\n+    /// Duplicate a rwlock-protected ARC, as arc::clone.\n+    fn clone() -> rw_arc<T> {\n+        rw_arc { x: unsafe { clone_shared_mutable_state(&self.x) },\n+                 cant_nest: () }\n+    }\n+\n+    /**\n+     * Access the underlying data mutably. Locks the rwlock in write mode;\n+     * other readers and writers will block.\n+     *\n+     * # Failure\n+     *\n+     * Failing while inside the ARC will unlock the ARC while unwinding, so\n+     * that other tasks won't block forever. As mutex_arc.access, it will also\n+     * poison the ARC, so subsequent readers and writers will both also fail.\n+     */\n+    #[inline(always)]\n+    fn write<U>(blk: fn(x: &mut T) -> U) -> U {\n+        let state = unsafe { get_shared_mutable_state(&self.x) };\n+        do borrow_rwlock(state).write {\n+            check_poison(false, state.failed);\n+            state.failed = true;\n+            let result = blk(&mut state.data);\n+            state.failed = false;\n+            result\n+        }\n+    }\n+/* FIXME(#3145): Make this compile; borrowck doesn't like it..?\n+    /// As write(), but with a condvar, as sync::rwlock.write_cond().\n+    #[inline(always)]\n+    fn write_cond<U>(blk: fn(x: &mut T, condvar) -> U) -> U {\n+        let state = unsafe { get_shared_mutable_state(&self.x) };\n+        do borrow_rwlock(state).write_cond |cond| {\n+            check_poison(false, state.failed);\n+            state.failed = true;\n+            let result = blk(&mut state.data, cond);\n+            state.failed = false;\n+            result\n+        }\n+    }\n+*/\n+    /**\n+     * Access the underlying data immutably. May run concurrently with other\n+     * reading tasks.\n+     *\n+     * # Failure\n+     *\n+     * Failing will unlock the ARC while unwinding. However, unlike all other\n+     * access modes, this will not poison the ARC.\n+     */\n+    fn read<U>(blk: fn(x: &T) -> U) -> U {\n+        let state = unsafe { get_shared_immutable_state(&self.x) };\n+        do (&state.lock).read {\n+            check_poison(false, state.failed);\n+            blk(&state.data)\n+        }\n+    }\n+}\n+\n+// Borrowck rightly complains about immutably aliasing the rwlock in order to\n+// lock it. This wraps the unsafety, with the justification that the 'lock'\n+// field is never overwritten; only 'failed' and 'data'.\n+fn borrow_rwlock<T: const send>(state: &mut rw_arc_inner<T>) -> &rwlock {\n+    unsafe { unsafe::reinterpret_cast(&state.lock) }\n+}\n+\n /****************************************************************************\n  * Tests\n  ****************************************************************************/\n@@ -80,4 +253,104 @@ mod tests {\n \n         log(info, arc_v);\n     }\n+\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    fn test_mutex_arc_poison() {\n+        let arc = ~mutex_arc(1);\n+        let arc2 = ~arc.clone();\n+        do task::try {\n+            do arc2.access |one| {\n+                assert *one == 2;\n+            }\n+        };\n+        do arc.access |one| {\n+            assert *one == 1;\n+        }\n+    }\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    fn test_rw_arc_poison_wr() {\n+        let arc = ~rw_arc(1);\n+        let arc2 = ~arc.clone();\n+        do task::try {\n+            do arc2.write |one| {\n+                assert *one == 2;\n+            }\n+        };\n+        do arc.read |one| {\n+            assert *one == 1;\n+        }\n+    }\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    fn test_rw_arc_poison_ww() {\n+        let arc = ~rw_arc(1);\n+        let arc2 = ~arc.clone();\n+        do task::try {\n+            do arc2.write |one| {\n+                assert *one == 2;\n+            }\n+        };\n+        do arc.write |one| {\n+            assert *one == 1;\n+        }\n+    }\n+    #[test] #[ignore(cfg(windows))]\n+    fn test_rw_arc_no_poison_rr() {\n+        let arc = ~rw_arc(1);\n+        let arc2 = ~arc.clone();\n+        do task::try {\n+            do arc2.read |one| {\n+                assert *one == 2;\n+            }\n+        };\n+        do arc.read |one| {\n+            assert *one == 1;\n+        }\n+    }\n+    #[test] #[ignore(cfg(windows))]\n+    fn test_rw_arc_no_poison_rw() {\n+        let arc = ~rw_arc(1);\n+        let arc2 = ~arc.clone();\n+        do task::try {\n+            do arc2.read |one| {\n+                assert *one == 2;\n+            }\n+        };\n+        do arc.write |one| {\n+            assert *one == 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_rw_arc() {\n+        let arc = ~rw_arc(0);\n+        let arc2 = ~arc.clone();\n+        let (c,p) = pipes::stream();\n+\n+        do task::spawn {\n+            do arc2.write |num| {\n+                for 10.times {\n+                    let tmp = *num;\n+                    *num = -1;\n+                    task::yield();\n+                    *num = tmp + 1;\n+                }\n+                c.send(());\n+            }\n+        }\n+        // Readers try to catch the writer in the act\n+        let mut children = ~[];\n+        for 5.times {\n+            let arc3 = ~arc.clone();\n+            do task::task().future_result(|+r| vec::push(children, r)).spawn {\n+                do arc3.read |num| {\n+                    assert *num >= 0;\n+                }\n+            }\n+        }\n+        // Wait for children to pass their asserts\n+        for vec::each(children) |r| { future::get(r); }\n+        // Wait for writer to finish\n+        p.recv();\n+        do arc.read |num| { assert *num == 10; }\n+    }\n }"}, {"sha": "dfc659781dea64dd81fff37a819544982fb1a15c", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0eae571389b0124eae4b33ae532788cff735da07/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0eae571389b0124eae4b33ae532788cff735da07/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=0eae571389b0124eae4b33ae532788cff735da07", "patch": "@@ -18,6 +18,7 @@ import core::*;\n export net, net_tcp, net_ip, net_url;\n export uv, uv_ll, uv_iotask, uv_global_loop;\n export c_vec, timer;\n+export sync, arc;\n export bitv, deque, fun_treemap, list, map;\n export smallintmap, sort, treemap;\n export rope, arena, par;"}]}