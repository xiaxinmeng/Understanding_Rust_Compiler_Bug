{"sha": "a08e589390993d27bf8504c1c8c54586bbfa3d37", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwOGU1ODkzOTA5OTNkMjdiZjg1MDRjMWM4YzU0NTg2YmJmYTNkMzc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-06T14:29:56Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-06T16:06:19Z"}, "message": "Handle built-in typenames in the resolve pass, rather than in parser\n\nCloses #1728\n\nComments out a section of debuginfo.rs. This code was already broken\n(only being called when --xg was passed, and only working on trivial\nprograms).", "tree": {"sha": "4f21c31fe36d996877f263b08e1a6d6c01be5abf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f21c31fe36d996877f263b08e1a6d6c01be5abf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a08e589390993d27bf8504c1c8c54586bbfa3d37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a08e589390993d27bf8504c1c8c54586bbfa3d37", "html_url": "https://github.com/rust-lang/rust/commit/a08e589390993d27bf8504c1c8c54586bbfa3d37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a08e589390993d27bf8504c1c8c54586bbfa3d37/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8673c4f195be8377f8e0d83929f9a16bb99092a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8673c4f195be8377f8e0d83929f9a16bb99092a0", "html_url": "https://github.com/rust-lang/rust/commit/8673c4f195be8377f8e0d83929f9a16bb99092a0"}], "stats": {"total": 356, "additions": 188, "deletions": 168}, "files": [{"sha": "779ab5ed9ffa133a6eb57a55d9465af7975c29b1", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=a08e589390993d27bf8504c1c8c54586bbfa3d37", "patch": "@@ -377,8 +377,9 @@ fn mk_test_wrapper(cx: test_ctxt,\n }\n \n fn mk_main(cx: test_ctxt) -> @ast::item {\n-\n-    let args_mt: ast::mt = {ty: @nospan(ast::ty_str), mut: ast::imm};\n+    let str_pt = @nospan({global: false, idents: [\"str\"], types: []});\n+    let str_ty = @nospan(ast::ty_path(str_pt, cx.sess.next_node_id()));\n+    let args_mt: ast::mt = {ty: str_ty, mut: ast::imm};\n     let args_ty: ast::ty = nospan(ast::ty_vec(args_mt));\n \n     let args_arg: ast::arg ="}, {"sha": "49304b6bd273533a50f6ef39f05e811b208128df", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 69, "deletions": 37, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=a08e589390993d27bf8504c1c8c54586bbfa3d37", "patch": "@@ -230,8 +230,8 @@ fn create_block(cx: @block_ctxt) -> @metadata<block_md> {\n     let cx = cx;\n     while option::is_none(cx.block_span) {\n         alt cx.parent {\n-          parent_none { fail \"BAD\"; /*break;*/ }\n           parent_some(b) { cx = b; }\n+          parent_none { fail; }\n         }\n     }\n     let sp = option::get(cx.block_span);\n@@ -275,7 +275,7 @@ fn size_and_align_of<T>() -> (int, int) {\n     (sys::size_of::<T>() as int, sys::align_of::<T>() as int)\n }\n \n-fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n+fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: ast::prim_ty, span: span)\n     -> @metadata<tydesc_md> {\n     let cache = get_cache(cx);\n     let tg = BasicTypeDescriptorTag;\n@@ -285,7 +285,7 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n       option::none {}\n     }\n \n-    let (name, (size, align), encoding) = alt ty.node {\n+    let (name, (size, align), encoding) = alt ty {\n       ast::ty_bool {(\"bool\", size_and_align_of::<bool>(), DW_ATE_boolean)}\n       ast::ty_int(m) { alt m {\n         ast::ty_char {(\"char\", size_and_align_of::<char>(), DW_ATE_unsigned)}\n@@ -307,11 +307,10 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n         ast::ty_f32 {(\"f32\", size_and_align_of::<f32>(), DW_ATE_float)}\n         ast::ty_f64 {(\"f64\", size_and_align_of::<f64>(), DW_ATE_float)}\n       }}\n-      _ { cx.tcx.sess.span_bug(ty.span,\n-             \"create_basic_type: unhandled type\"); }\n+      _ { fail; }\n     };\n \n-    let fname = filename_from_span(cx, ty.span);\n+    let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n     let cu_node = create_compile_unit(cx, fname);\n     let lldata = [lltag(tg),\n@@ -415,7 +414,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n     for field in fields {\n         let field_t = ty::get_field(ccx_tcx(cx), t, field.node.ident).mt.ty;\n         let ty_md = create_ty(cx, field_t, field.node.mt.ty);\n-        let (size, align) = member_size_and_align(field.node.mt.ty);\n+        let (size, align) = member_size_and_align(cx.tcx, field.node.mt.ty);\n         add_member(scx, field.node.ident,\n                    line_from_span(cx.sess.codemap, field.span) as int,\n                    size as int, align as int, ty_md.node);\n@@ -439,8 +438,8 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n     //let cu_node = create_compile_unit_metadata(cx, fname);\n     let tcx = ccx_tcx(cx);\n     let uint_t = ty::mk_uint(tcx);\n-    let uint_ty = @{node: ast::ty_uint(ast::ty_u), span: span};\n-    let refcount_type = create_basic_type(cx, uint_t, uint_ty);\n+    let refcount_type = create_basic_type(cx, uint_t,\n+                                          ast::ty_uint(ast::ty_u), span);\n     let scx = create_structure(file_node, ty_to_str(ccx_tcx(cx), outer), 0);\n     add_member(scx, \"refcnt\", 0, sys::size_of::<uint>() as int,\n                sys::align_of::<uint>() as int, refcount_type.node);\n@@ -492,14 +491,14 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n     let elem_ty_md = create_ty(cx, elem_t, elem_ty);\n     let tcx = ccx_tcx(cx);\n     let scx = create_structure(file_node, ty_to_str(tcx, vec_t), 0);\n-    let uint_ty = @{node: ast::ty_uint(ast::ty_u), span: vec_ty_span};\n-    let size_t_type = create_basic_type(cx, ty::mk_uint(tcx), uint_ty);\n+    let size_t_type = create_basic_type(cx, ty::mk_uint(tcx),\n+                                        ast::ty_uint(ast::ty_u), vec_ty_span);\n     add_member(scx, \"fill\", 0, sys::size_of::<ctypes::size_t>() as int,\n                sys::align_of::<ctypes::size_t>() as int, size_t_type.node);\n     add_member(scx, \"alloc\", 0, sys::size_of::<ctypes::size_t>() as int,\n                sys::align_of::<ctypes::size_t>() as int, size_t_type.node);\n     let subrange = llmdnode([lltag(SubrangeTag), lli64(0), lli64(0)]);\n-    let (arr_size, arr_align) = member_size_and_align(elem_ty);\n+    let (arr_size, arr_align) = member_size_and_align(tcx, elem_ty);\n     let data_ptr = create_composite_type(ArrayTypeTag, \"\", file_node.node, 0,\n                                          arr_size, arr_align, 0,\n                                          option::some(elem_ty_md.node),\n@@ -510,36 +509,46 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n     ret @{node: llnode, data: {hash: ty::type_id(vec_t)}};\n }\n \n-fn member_size_and_align(ty: @ast::ty) -> (int, int) {\n+fn member_size_and_align(tcx: ty::ctxt, ty: @ast::ty) -> (int, int) {\n     alt ty.node {\n-      ast::ty_bool { size_and_align_of::<bool>() }\n-      ast::ty_int(m) { alt m {\n-        ast::ty_char { size_and_align_of::<char>() }\n-        ast::ty_i { size_and_align_of::<int>() }\n-        ast::ty_i8 { size_and_align_of::<i8>() }\n-        ast::ty_i16 { size_and_align_of::<i16>() }\n-        ast::ty_i32 { size_and_align_of::<i32>() }\n-        ast::ty_i64 { size_and_align_of::<i64>() }\n-      }}\n-      ast::ty_uint(m) { alt m {\n-        ast::ty_u { size_and_align_of::<uint>() }\n-        ast::ty_u8 { size_and_align_of::<i8>() }\n-        ast::ty_u16 { size_and_align_of::<u16>() }\n-        ast::ty_u32 { size_and_align_of::<u32>() }\n-        ast::ty_u64 { size_and_align_of::<u64>() }\n-      }}\n-      ast::ty_float(m) { alt m {\n-        ast::ty_f { size_and_align_of::<float>() }\n-        ast::ty_f32 { size_and_align_of::<f32>() }\n-        ast::ty_f64 { size_and_align_of::<f64>() }\n-      }}\n+      ast::ty_path(_, id) {\n+        alt tcx.def_map.get(id) {\n+          ast::def_prim_ty(nty) {\n+            alt nty {\n+              ast::ty_bool { size_and_align_of::<bool>() }\n+              ast::ty_int(m) { alt m {\n+                ast::ty_char { size_and_align_of::<char>() }\n+                ast::ty_i { size_and_align_of::<int>() }\n+                ast::ty_i8 { size_and_align_of::<i8>() }\n+                ast::ty_i16 { size_and_align_of::<i16>() }\n+                ast::ty_i32 { size_and_align_of::<i32>() }\n+                ast::ty_i64 { size_and_align_of::<i64>() }\n+              }}\n+              ast::ty_uint(m) { alt m {\n+                ast::ty_u { size_and_align_of::<uint>() }\n+                ast::ty_u8 { size_and_align_of::<i8>() }\n+                ast::ty_u16 { size_and_align_of::<u16>() }\n+                ast::ty_u32 { size_and_align_of::<u32>() }\n+                ast::ty_u64 { size_and_align_of::<u64>() }\n+              }}\n+              ast::ty_float(m) { alt m {\n+                ast::ty_f { size_and_align_of::<float>() }\n+                ast::ty_f32 { size_and_align_of::<f32>() }\n+                ast::ty_f64 { size_and_align_of::<f64>() }\n+              }}\n+              _ { fail; }\n+            }\n+          }\n+          _ { fail; }\n+        }\n+      }\n       ast::ty_box(_) | ast::ty_uniq(_) {\n         size_and_align_of::<ctypes::uintptr_t>()\n       }\n       ast::ty_rec(fields) {\n         let total_size = 0;\n         for field in fields {\n-            let (size, _) = member_size_and_align(field.node.mt.ty);\n+            let (size, _) = member_size_and_align(tcx, field.node.mt.ty);\n             total_size += size;\n         }\n         (total_size, 64) //XXX different align for other arches?\n@@ -551,7 +560,7 @@ fn member_size_and_align(ty: @ast::ty) -> (int, int) {\n     }\n }\n \n-fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n+fn create_ty(_cx: @crate_ctxt, _t: ty::t, _ty: @ast::ty)\n     -> @metadata<tydesc_md> {\n     /*let cache = get_cache(cx);\n     alt cached_metadata::<@metadata<tydesc_md>>(\n@@ -560,6 +569,19 @@ fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n       option::none {}\n     }*/\n \n+    /* FIXME I am disabling this code as part of the patch that moves\n+     * recognition of named builtin types into resolve. I tried to fix\n+     * it, but it seems to already be broken -- it's only called when\n+     * --xg is given, and compiling with --xg fails on trivial programs.\n+     *\n+     * Generating an ast::ty from a ty::t seems like it should not be\n+     * needed. It is only done to track spans, but you will not get the\n+     * right spans anyway -- types tend to refer to stuff defined\n+     * elsewhere, not be self-contained.\n+     */\n+\n+    fail;\n+    /*\n     fn t_to_ty(cx: @crate_ctxt, t: ty::t, span: span) -> @ast::ty {\n         let ty = alt ty::get(t).struct {\n           ty::ty_nil { ast::ty_nil }\n@@ -628,8 +650,18 @@ fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n         ret create_pointer_type(cx, t, ty.span, v);\n       }\n \n-      _ { ret create_basic_type(cx, t, ty); }\n+      ast::ty_path(_, id) {\n+        alt ccx_tcx(cx).def_map.get(id) {\n+          ast::def_prim_ty(pty) {\n+            ret create_basic_type(cx, t, pty, ty.span);\n+          }\n+          _ {}\n+        }\n+      }\n+\n+      _ {}\n     };\n+    */\n }\n \n fn filename_from_span(cx: @crate_ctxt, sp: codemap::span) -> str {"}, {"sha": "ff1b97b958746e3e9eb7c2d4a14d6ce9471c91fc", "filename": "src/comp/middle/lint.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flint.rs?ref=a08e589390993d27bf8504c1c8c54586bbfa3d37", "patch": "@@ -99,17 +99,22 @@ fn check_ctypes(tcx: ty::ctxt, crate: @ast::crate) {\n         let tys = vec::map(decl.inputs) {|a| a.ty };\n         for ty in (tys + [decl.output]) {\n             alt ty.node {\n-              ast::ty_int(ast::ty_i) {\n-                tcx.sess.span_warn(\n-                    ty.span,\n-                    \"found rust type `int` in native module, while \\\n-                     ctypes::c_int or ctypes::long should be used\");\n-              }\n-              ast::ty_uint(ast::ty_u) {\n-                tcx.sess.span_warn(\n-                    ty.span,\n-                    \"found rust type `uint` in native module, while \\\n-                     ctypes::c_uint or ctypes::ulong should be used\");\n+              ast::ty_path(_, id) {\n+                alt tcx.def_map.get(id) {\n+                  ast::def_prim_ty(ast::ty_int(ast::ty_i)) {\n+                    tcx.sess.span_warn(\n+                        ty.span,\n+                        \"found rust type `int` in native module, while \\\n+                         ctypes::c_int or ctypes::long should be used\");\n+                  }\n+                  ast::def_prim_ty(ast::ty_uint(ast::ty_u)) {\n+                    tcx.sess.span_warn(\n+                        ty.span,\n+                        \"found rust type `uint` in native module, while \\\n+                         ctypes::c_uint or ctypes::ulong should be used\");\n+                  }\n+                  _ { }\n+                }\n               }\n               _ { }\n             }"}, {"sha": "7fbc2ad0c05ec169df496e17a6fd8365c23aae60", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=a08e589390993d27bf8504c1c8c54586bbfa3d37", "patch": "@@ -31,6 +31,7 @@ export _impl, iscopes, method_info;\n // them, storing the resulting def in the AST nodes.\n \n enum scope {\n+    scope_toplevel,\n     scope_crate,\n     scope_item(@ast::item),\n     scope_bare_fn(ast::fn_decl, node_id, [ast::ty_param]),\n@@ -44,6 +45,10 @@ enum scope {\n \n type scopes = list<scope>;\n \n+fn top_scope() -> scopes {\n+    cons(scope_crate, @cons(scope_toplevel, @nil))\n+}\n+\n enum import_state {\n     todo(ast::node_id, ast::ident, @[ast::ident], span, scopes),\n     is_glob(@[ast::ident], scopes, span),\n@@ -190,7 +195,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n           visit_item: bind index_i(e, _, _, _),\n           visit_block: visit_block_with_scope\n           with *visit::default_visitor::<scopes>()};\n-    visit::visit_crate(*c, cons(scope_crate, @nil), visit::mk_vt(v_map_mod));\n+    visit::visit_crate(*c, top_scope(), visit::mk_vt(v_map_mod));\n \n     // Register the top-level mod\n     e.mod_map.insert(ast::crate_node_id,\n@@ -257,8 +262,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n           visit_block: visit_block_with_scope,\n           visit_item: bind visit_item_with_scope(e, _, _, _)\n           with *visit::default_visitor::<scopes>()};\n-    visit::visit_crate(*c, cons(scope_crate, @nil),\n-                       visit::mk_vt(v_link_glob));\n+    visit::visit_crate(*c, top_scope(), visit::mk_vt(v_link_glob));\n     fn link_glob(e: @env, vi: @ast::view_item, sc: scopes, _v: vt<scopes>) {\n         alt vi.node {\n           //if it really is a glob import, that is\n@@ -344,7 +348,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           visit_constr: bind walk_constr(e, _, _, _, _, _),\n           visit_fn: bind visit_fn_with_scope(e, _, _, _, _, _, _, _)\n           with *visit::default_visitor()};\n-    visit::visit_crate(*c, cons(scope_crate, @nil), visit::mk_vt(v));\n+    visit::visit_crate(*c, top_scope(), visit::mk_vt(v));\n     e.used_imports.track = false;\n     e.sess.abort_if_errors();\n \n@@ -808,10 +812,7 @@ fn lookup_path_strict(e: env, sc: scopes, sp: span, pth: ast::path_,\n     let n_idents = vec::len(pth.idents);\n     let headns = if n_idents == 1u { ns } else { ns_module };\n \n-    let first_scope;\n-    if pth.global {\n-        first_scope = list::cons(scope_crate, @list::nil);\n-    } else { first_scope = sc; }\n+    let first_scope = if pth.global { top_scope() } else { sc };\n \n     let dcur =\n         lookup_in_scope_strict(e, first_scope, sp, pth.idents[0], headns);\n@@ -879,6 +880,29 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n     fn in_scope(e: env, sp: span, name: ident, s: scope, ns: namespace) ->\n        option<def> {\n         alt s {\n+          scope_toplevel {\n+            if ns == ns_type {\n+                ret some(ast::def_prim_ty(alt name {\n+                  \"bool\" { ast::ty_bool }\n+                  \"int\" { ast::ty_int(ast::ty_i) }\n+                  \"uint\" { ast::ty_uint(ast::ty_u) }\n+                  \"float\" { ast::ty_float(ast::ty_f) }\n+                  \"str\" { ast::ty_str }\n+                  \"char\" { ast::ty_int(ast::ty_char) }\n+                  \"i8\" { ast::ty_int(ast::ty_i8) }\n+                  \"i16\" { ast::ty_int(ast::ty_i16) }\n+                  \"i32\" { ast::ty_int(ast::ty_i32) }\n+                  \"i64\" { ast::ty_int(ast::ty_i64) }\n+                  \"u8\" { ast::ty_uint(ast::ty_u8) }\n+                  \"u16\" { ast::ty_uint(ast::ty_u16) }\n+                  \"u32\" { ast::ty_uint(ast::ty_u32) }\n+                  \"u64\" { ast::ty_uint(ast::ty_u64) }\n+                  \"f32\" { ast::ty_float(ast::ty_f32) }\n+                  \"f64\" { ast::ty_float(ast::ty_f64) }\n+                  _ { ret none; }\n+                }));\n+            }\n+          }\n           scope_crate {\n             ret lookup_in_local_mod(e, ast::crate_node_id, sp,\n                                     name, ns, inside);\n@@ -950,7 +974,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n             }\n           }\n         }\n-        ret none::<def>;\n+        ret none;\n     }\n     let left_fn = false;\n     let closing = [];\n@@ -959,7 +983,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n     let sc = sc;\n     while true {\n         alt copy sc {\n-          nil { ret none::<def>; }\n+          nil { ret none; }\n           cons(hd, tl) {\n             let fnd = in_scope(e, sp, name, hd, ns);\n             if !is_none(fnd) {\n@@ -1019,7 +1043,7 @@ fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n         } { ret some(ast::def_ty_param(local_def(tp.id), n)); }\n         n += 1u;\n     }\n-    ret none::<def>;\n+    ret none;\n }\n \n fn lookup_in_pat(e: env, name: ident, pat: @ast::pat) -> option<def_id> {\n@@ -1043,10 +1067,10 @@ fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n                 ret some(ast::def_arg(local_def(a.id), a.mode));\n             }\n         }\n-        ret none::<def>;\n+        ret none;\n       }\n       ns_type { ret lookup_in_ty_params(e, name, ty_params); }\n-      _ { ret none::<def>; }\n+      _ { ret none; }\n     }\n }\n \n@@ -1261,7 +1285,7 @@ fn lookup_in_local_mod(e: env, node_id: node_id, sp: span, id: ident,\n     let info = e.mod_map.get(node_id);\n     if dr == outside && !is_exported(e, id, option::get(info.m)) {\n         // if we're in a native mod, then dr==inside, so info.m is some _mod\n-        ret none::<def>; // name is not visible\n+        ret none; // name is not visible\n     }\n     alt info.index.find(id) {\n       none { }\n@@ -1334,7 +1358,7 @@ fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n     }\n     alt info.glob_imported_names.get(id) {\n       glob_resolving(sp) {\n-          ret none::<def>;\n+          ret none;\n       }\n       glob_resolved(val, typ, md) {\n         ret alt wanted_ns {\n@@ -1361,7 +1385,7 @@ fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n                ret some(ast::def_variant(local_def(parent_id),\n                                         local_def(vid)));\n             }\n-            _ { ret none::<def>; }\n+            _ { ret none; }\n          }\n       }\n       mie_native_item(native_item) {\n@@ -1375,7 +1399,7 @@ fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n         }\n       }\n     }\n-    ret none::<def>;\n+    ret none;\n }\n \n \n@@ -1473,7 +1497,7 @@ fn ns_for_def(d: def) -> namespace {\n       ast::def_upvar(_, _, _) |  ast::def_self(_) { ns_val(ns_any_value) }\n       ast::def_mod(_) | ast::def_native_mod(_) { ns_module }\n       ast::def_ty(_) | ast::def_binding(_) | ast::def_use(_) |\n-      ast::def_ty_param(_, _) { ns_type }\n+      ast::def_ty_param(_, _) | ast::def_prim_ty(_) { ns_type }\n     }\n }\n \n@@ -1497,7 +1521,7 @@ fn lookup_external(e: env, cnum: int, ids: [ident], ns: namespace) ->\n         e.ext_map.insert(def_id_of_def(d), ids);\n         if ns_ok(ns, ns_for_def(d)) { ret some(d); }\n     }\n-    ret none::<def>;\n+    ret none;\n }\n \n "}, {"sha": "08f67f5f5b87328c398a9184a8ef33fcc6798341", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=a08e589390993d27bf8504c1c8c54586bbfa3d37", "patch": "@@ -116,7 +116,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n         let typ = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, sp, id.node));\n         ret {bounds: @[], ty: typ};\n       }\n-      ast::def_ty(_) {\n+      ast::def_ty(_) | ast::def_prim_ty(_) {\n         fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found type\");\n       }\n       ast::def_upvar(_, inner, _) {\n@@ -273,53 +273,56 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n                                        ty_param_bounds_and_ty.ty);\n         ret typ;\n     }\n-    let typ;\n-    alt ast_ty.node {\n-      ast::ty_nil { typ = ty::mk_nil(tcx); }\n-      ast::ty_bot { typ = ty::mk_bot(tcx); }\n-      ast::ty_bool { typ = ty::mk_bool(tcx); }\n-      ast::ty_int(it) { typ = ty::mk_mach_int(tcx, it); }\n-      ast::ty_uint(uit) { typ = ty::mk_mach_uint(tcx, uit); }\n-      ast::ty_float(ft) { typ = ty::mk_mach_float(tcx, ft); }\n-      ast::ty_str { typ = ty::mk_str(tcx); }\n+    let typ = alt ast_ty.node {\n+      ast::ty_nil { ty::mk_nil(tcx) }\n+      ast::ty_bot { ty::mk_bot(tcx) }\n       ast::ty_box(mt) {\n-        typ = ty::mk_box(tcx, ast_mt_to_mt(tcx, mode, mt));\n+        ty::mk_box(tcx, ast_mt_to_mt(tcx, mode, mt))\n       }\n       ast::ty_uniq(mt) {\n-        typ = ty::mk_uniq(tcx, ast_mt_to_mt(tcx, mode, mt));\n+        ty::mk_uniq(tcx, ast_mt_to_mt(tcx, mode, mt))\n       }\n       ast::ty_vec(mt) {\n-        typ = ty::mk_vec(tcx, ast_mt_to_mt(tcx, mode, mt));\n+        ty::mk_vec(tcx, ast_mt_to_mt(tcx, mode, mt))\n       }\n       ast::ty_ptr(mt) {\n-        typ = ty::mk_ptr(tcx, ast_mt_to_mt(tcx, mode, mt));\n+        ty::mk_ptr(tcx, ast_mt_to_mt(tcx, mode, mt))\n       }\n       ast::ty_tup(fields) {\n         let flds = vec::map(fields, bind ast_ty_to_ty(tcx, mode, _));\n-        typ = ty::mk_tup(tcx, flds);\n+        ty::mk_tup(tcx, flds)\n       }\n       ast::ty_rec(fields) {\n         let flds: [field] = [];\n         for f: ast::ty_field in fields {\n             let tm = ast_mt_to_mt(tcx, mode, f.node.mt);\n             flds += [{ident: f.node.ident, mt: tm}];\n         }\n-        typ = ty::mk_rec(tcx, flds);\n+        ty::mk_rec(tcx, flds)\n       }\n       ast::ty_fn(proto, decl) {\n-        typ = ty::mk_fn(tcx, ty_of_fn_decl(tcx, mode, proto, decl));\n+        ty::mk_fn(tcx, ty_of_fn_decl(tcx, mode, proto, decl))\n       }\n       ast::ty_path(path, id) {\n         alt tcx.def_map.get(id) {\n           ast::def_ty(id) {\n-            typ = instantiate(tcx, ast_ty.span, mode, id, path.node.types);\n+            instantiate(tcx, ast_ty.span, mode, id, path.node.types)\n+          }\n+          ast::def_prim_ty(nty) {\n+            alt nty {\n+              ast::ty_bool { ty::mk_bool(tcx) }\n+              ast::ty_int(it) { ty::mk_mach_int(tcx, it) }\n+              ast::ty_uint(uit) { ty::mk_mach_uint(tcx, uit) }\n+              ast::ty_float(ft) { ty::mk_mach_float(tcx, ft) }\n+              ast::ty_str { ty::mk_str(tcx) }\n+            }\n           }\n           ast::def_ty_param(id, n) {\n             if vec::len(path.node.types) > 0u {\n                 tcx.sess.span_err(ast_ty.span, \"provided type parameters to \\\n                                                 a type parameter\");\n             }\n-            typ = ty::mk_param(tcx, n, id);\n+            ty::mk_param(tcx, n, id)\n           }\n           ast::def_self(iface_id) {\n             alt tcx.items.get(iface_id.node) {\n@@ -328,9 +331,9 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n                     tcx.sess.span_err(ast_ty.span, \"incorrect number of type \\\n                                                     parameter to self type\");\n                 }\n-                typ = ty::mk_self(tcx, vec::map(path.node.types, {|ast_ty|\n+                ty::mk_self(tcx, vec::map(path.node.types, {|ast_ty|\n                     ast_ty_to_ty(tcx, mode, ast_ty)\n-                }));\n+                }))\n               }\n               _ { fail; }\n             }\n@@ -346,7 +349,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         for constr: @ast::ty_constr in cs {\n             out_cs += [ty::ast_constr_to_constr(tcx, constr)];\n         }\n-        typ = ty::mk_constr(tcx, ast_ty_to_ty(tcx, mode, t), out_cs);\n+        ty::mk_constr(tcx, ast_ty_to_ty(tcx, mode, t), out_cs)\n       }\n       ast::ty_infer {\n         alt mode {\n@@ -359,7 +362,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n           tcx.sess.span_bug(ast_ty.span,\n                                 \"found `ty_mac` in unexpected place\");\n       }\n-    }\n+    };\n     tcx.ast_ty_to_ty_cache.insert(ast_ty, some(typ));\n     ret typ;\n }"}, {"sha": "fd70d642501dd8d6e8c3e0aeaf91679418f149a9", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=a08e589390993d27bf8504c1c8c54586bbfa3d37", "patch": "@@ -42,6 +42,7 @@ enum def {\n     def_local(def_id, let_style),\n     def_variant(def_id /* enum */, def_id /* variant */),\n     def_ty(def_id),\n+    def_prim_ty(prim_ty),\n     def_ty_param(def_id, uint),\n     def_binding(def_id),\n     def_use(def_id),\n@@ -327,20 +328,18 @@ enum float_ty { ty_f, ty_f32, ty_f64, }\n \n type ty = spanned<ty_>;\n \n-enum ty_ {\n-    ty_nil,\n-    ty_bot, /* return type of ! functions and type of\n-             ret/fail/break/cont. there is no syntax\n-             for this type. */\n-\n-     /* bot represents the value of functions that don't return a value\n-        locally to their context. in contrast, things like log that do\n-        return, but don't return a meaningful value, have result type nil. */\n-    ty_bool,\n+// Not represented directly in the AST, referred to by name through a ty_path.\n+enum prim_ty {\n     ty_int(int_ty),\n     ty_uint(uint_ty),\n     ty_float(float_ty),\n     ty_str,\n+    ty_bool,\n+}\n+\n+enum ty_ {\n+    ty_nil,\n+    ty_bot, /* bottom type */\n     ty_box(mt),\n     ty_uniq(mt),\n     ty_vec(mt),"}, {"sha": "6e44b56d0a06b5d54baf13f81c38a3dc29cf4b84", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=a08e589390993d27bf8504c1c8c54586bbfa3d37", "patch": "@@ -31,6 +31,7 @@ fn def_id_of_def(d: def) -> def_id {\n       def_native_mod(id) | def_const(id) | def_arg(id, _) | def_local(id, _) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n       def_binding(id) | def_use(id) | def_upvar(id, _, _) { id }\n+      def_prim_ty(_) { fail; }\n     }\n }\n "}, {"sha": "f7151e7e838ce875145ad34433658324bd885fdb", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=a08e589390993d27bf8504c1c8c54586bbfa3d37", "patch": "@@ -446,8 +446,7 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n          span: fld.new_span(f.span)}\n     }\n     alt t {\n-      ty_nil | ty_bot | ty_bool | ty_str {t}\n-      ty_int(_) | ty_uint(_) | ty_float(_) {t}\n+      ty_nil | ty_bot {t}\n       ty_box(mt) {ty_box(fold_mt(mt, fld))}\n       ty_uniq(mt) {ty_uniq(fold_mt(mt, fld))}\n       ty_vec(mt) {ty_vec(fold_mt(mt, fld))}"}, {"sha": "65611c2f30f0a0e826f6bb5bb3fa646063506621", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 53, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=a08e589390993d27bf8504c1c8c54586bbfa3d37", "patch": "@@ -152,7 +152,6 @@ fn bad_expr_word_table() -> hashmap<str, ()> {\n                  \"assert\", \"claim\", \"native\", \"fn\", \"pure\",\n                  \"unsafe\", \"import\", \"export\", \"let\", \"const\",\n                  \"log\", \"copy\", \"impl\", \"iface\", \"enum\",\n-                 \"m32\", \"m64\", \"m128\", \"f80\", \"f16\", \"f128\",\n                  \"class\", \"trait\"] {\n         words.insert(word, ());\n     }\n@@ -427,96 +426,62 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n       none {}\n     }\n \n-    let t: ast::ty_;\n-    // FIXME: do something with this\n-\n-    if eat_word(p, \"bool\") {\n-        t = ast::ty_bool;\n-    } else if eat_word(p, \"int\") {\n-        t = ast::ty_int(ast::ty_i);\n-    } else if eat_word(p, \"uint\") {\n-        t = ast::ty_uint(ast::ty_u);\n-    } else if eat_word(p, \"float\") {\n-        t = ast::ty_float(ast::ty_f);\n-    } else if eat_word(p, \"str\") {\n-        t = ast::ty_str;\n-    } else if eat_word(p, \"char\") {\n-        t = ast::ty_int(ast::ty_char);\n-    } else if eat_word(p, \"i8\") {\n-        t = ast::ty_int(ast::ty_i8);\n-    } else if eat_word(p, \"i16\") {\n-        t = ast::ty_int(ast::ty_i16);\n-    } else if eat_word(p, \"i32\") {\n-        t = ast::ty_int(ast::ty_i32);\n-    } else if eat_word(p, \"i64\") {\n-        t = ast::ty_int(ast::ty_i64);\n-    } else if eat_word(p, \"u8\") {\n-        t = ast::ty_uint(ast::ty_u8);\n-    } else if eat_word(p, \"u16\") {\n-        t = ast::ty_uint(ast::ty_u16);\n-    } else if eat_word(p, \"u32\") {\n-        t = ast::ty_uint(ast::ty_u32);\n-    } else if eat_word(p, \"u64\") {\n-        t = ast::ty_uint(ast::ty_u64);\n-    } else if eat_word(p, \"f32\") {\n-        t = ast::ty_float(ast::ty_f32);\n-    } else if eat_word(p, \"f64\") {\n-        t = ast::ty_float(ast::ty_f64);\n-    } else if p.token == token::LPAREN {\n+    let t = if p.token == token::LPAREN {\n         p.bump();\n         if p.token == token::RPAREN {\n             p.bump();\n-            t = ast::ty_nil;\n+            ast::ty_nil\n         } else {\n             let ts = [parse_ty(p, false)];\n             while p.token == token::COMMA {\n                 p.bump();\n                 ts += [parse_ty(p, false)];\n             }\n-            if vec::len(ts) == 1u {\n-                t = ts[0].node;\n-            } else { t = ast::ty_tup(ts); }\n+            let t = if vec::len(ts) == 1u { ts[0].node }\n+                    else { ast::ty_tup(ts) };\n             expect(p, token::RPAREN);\n+            t\n         }\n     } else if p.token == token::AT {\n         p.bump();\n-        t = ast::ty_box(parse_mt(p));\n+        ast::ty_box(parse_mt(p))\n     } else if p.token == token::TILDE {\n         p.bump();\n-        t = ast::ty_uniq(parse_mt(p));\n+        ast::ty_uniq(parse_mt(p))\n     } else if p.token == token::BINOP(token::STAR) {\n         p.bump();\n-        t = ast::ty_ptr(parse_mt(p));\n+        ast::ty_ptr(parse_mt(p))\n     } else if p.token == token::LBRACE {\n         let elems =\n             parse_seq(token::LBRACE, token::RBRACE, seq_sep_opt(token::COMMA),\n                       parse_ty_field, p);\n         if vec::len(elems.node) == 0u { unexpected(p, token::RBRACE); }\n         let hi = elems.span.hi;\n-        t = ast::ty_rec(elems.node);\n+\n+        let t = ast::ty_rec(elems.node);\n         if p.token == token::COLON {\n             p.bump();\n-            t = ast::ty_constr(@spanned(lo, hi, t),\n-                               parse_type_constraints(p));\n-        }\n+            ast::ty_constr(@spanned(lo, hi, t), parse_type_constraints(p))\n+        } else { t }\n     } else if p.token == token::LBRACKET {\n         expect(p, token::LBRACKET);\n-        t = ast::ty_vec(parse_mt(p));\n+        let t = ast::ty_vec(parse_mt(p));\n         expect(p, token::RBRACKET);\n+        t\n     } else if eat_word(p, \"fn\") {\n         let proto = parse_fn_ty_proto(p);\n         alt proto {\n           ast::proto_bare { p.warn(\"fn is deprecated, use native fn\"); }\n           _ { /* fallthrough */ }\n         }\n-        t = ast::ty_fn(proto, parse_ty_fn(p));\n+        ast::ty_fn(proto, parse_ty_fn(p))\n     } else if eat_word(p, \"native\") {\n         expect_word(p, \"fn\");\n-        t = ast::ty_fn(ast::proto_bare, parse_ty_fn(p));\n+        ast::ty_fn(ast::proto_bare, parse_ty_fn(p))\n     } else if p.token == token::MOD_SEP || is_ident(p.token) {\n         let path = parse_path(p);\n-        t = ast::ty_path(path, p.get_id());\n-    } else { p.fatal(\"expecting type\"); }\n+        ast::ty_path(path, p.get_id())\n+    } else { p.fatal(\"expecting type\"); };\n     ret parse_ty_postfix(t, p, colons_before_params, lo);\n }\n "}, {"sha": "121a57b24f7f49f1940f4e8673176d61d4ea5984", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a08e589390993d27bf8504c1c8c54586bbfa3d37/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=a08e589390993d27bf8504c1c8c54586bbfa3d37", "patch": "@@ -137,7 +137,7 @@ fn test_res_to_str() {\n     let decl: ast::fn_decl = {\n         inputs: [{\n             mode: ast::expl(ast::by_val),\n-            ty: @ast_util::respan(ast_util::dummy_sp(), ast::ty_bool),\n+            ty: @ast_util::respan(ast_util::dummy_sp(), ast::ty_nil),\n             ident: \"b\",\n             id: 0\n         }],\n@@ -146,7 +146,7 @@ fn test_res_to_str() {\n         cf: ast::return_val,\n         constraints: []\n     };\n-    assert res_to_str(decl, \"a\", []) == \"resource a(b: bool)\";\n+    assert res_to_str(decl, \"a\", []) == \"resource a(b: ())\";\n }\n \n fn block_to_str(blk: ast::blk) -> str {\n@@ -317,16 +317,7 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n     ibox(s, 0u);\n     alt ty.node {\n       ast::ty_nil { word(s.s, \"()\"); }\n-      ast::ty_bool { word(s.s, \"bool\"); }\n       ast::ty_bot { word(s.s, \"!\"); }\n-      ast::ty_int(ast::ty_i) { word(s.s, \"int\"); }\n-      ast::ty_int(ast::ty_char) { word(s.s, \"char\"); }\n-      ast::ty_int(t) { word(s.s, ast_util::int_ty_to_str(t)); }\n-      ast::ty_uint(ast::ty_u) { word(s.s, \"uint\"); }\n-      ast::ty_uint(t) { word(s.s, ast_util::uint_ty_to_str(t)); }\n-      ast::ty_float(ast::ty_f) { word(s.s, \"float\"); }\n-      ast::ty_float(t) { word(s.s, ast_util::float_ty_to_str(t)); }\n-      ast::ty_str { word(s.s, \"str\"); }\n       ast::ty_box(mt) { word(s.s, \"@\"); print_mt(s, mt); }\n       ast::ty_uniq(mt) { word(s.s, \"~\"); print_mt(s, mt); }\n       ast::ty_vec(mt) {"}]}