{"sha": "568840707cd5f98a1970a44d632b833439d5312e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ODg0MDcwN2NkNWY5OGExOTcwYTQ0ZDYzMmI4MzM0MzlkNTMxMmU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-09-30T20:13:58Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-11-01T17:08:24Z"}, "message": "std: Move elf TLS to sys::fast_thread_local", "tree": {"sha": "1af928fa937262dde945101029eb6efb5dfc94cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1af928fa937262dde945101029eb6efb5dfc94cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/568840707cd5f98a1970a44d632b833439d5312e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/568840707cd5f98a1970a44d632b833439d5312e", "html_url": "https://github.com/rust-lang/rust/commit/568840707cd5f98a1970a44d632b833439d5312e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/568840707cd5f98a1970a44d632b833439d5312e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac968c466451cb9aafd9e8598ddb396ed0e6fe31", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac968c466451cb9aafd9e8598ddb396ed0e6fe31", "html_url": "https://github.com/rust-lang/rust/commit/ac968c466451cb9aafd9e8598ddb396ed0e6fe31"}], "stats": {"total": 334, "additions": 171, "deletions": 163}, "files": [{"sha": "0c625e7add9d0eb81b3efa976a3374eaf929c8d4", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/568840707cd5f98a1970a44d632b833439d5312e/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/568840707cd5f98a1970a44d632b833439d5312e/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=568840707cd5f98a1970a44d632b833439d5312e", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg(target_thread_local)]\n+#![unstable(feature = \"thread_local_internals\", issue = \"0\")]\n+\n+use cell::{Cell, UnsafeCell};\n+use intrinsics;\n+use ptr;\n+\n+pub struct Key<T> {\n+    inner: UnsafeCell<Option<T>>,\n+\n+    // Metadata to keep track of the state of the destructor. Remember that\n+    // these variables are thread-local, not global.\n+    dtor_registered: Cell<bool>,\n+    dtor_running: Cell<bool>,\n+}\n+\n+unsafe impl<T> ::marker::Sync for Key<T> { }\n+\n+impl<T> Key<T> {\n+    pub const fn new() -> Key<T> {\n+        Key {\n+            inner: UnsafeCell::new(None),\n+            dtor_registered: Cell::new(false),\n+            dtor_running: Cell::new(false)\n+        }\n+    }\n+\n+    pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n+        unsafe {\n+            if intrinsics::needs_drop::<T>() && self.dtor_running.get() {\n+                return None\n+            }\n+            self.register_dtor();\n+        }\n+        Some(&self.inner)\n+    }\n+\n+    unsafe fn register_dtor(&self) {\n+        if !intrinsics::needs_drop::<T>() || self.dtor_registered.get() {\n+            return\n+        }\n+\n+        register_dtor(self as *const _ as *mut u8,\n+                      destroy_value::<T>);\n+        self.dtor_registered.set(true);\n+    }\n+}\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\"))]\n+unsafe fn register_dtor_fallback(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    // The fallback implementation uses a vanilla OS-based TLS key to track\n+    // the list of destructors that need to be run for this thread. The key\n+    // then has its own destructor which runs all the other destructors.\n+    //\n+    // The destructor for DTORS is a little special in that it has a `while`\n+    // loop to continuously drain the list of registered destructors. It\n+    // *should* be the case that this loop always terminates because we\n+    // provide the guarantee that a TLS key cannot be set after it is\n+    // flagged for destruction.\n+    use sys_common::thread_local as os;\n+\n+    static DTORS: os::StaticKey = os::StaticKey::new(Some(run_dtors));\n+    type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n+    if DTORS.get().is_null() {\n+        let v: Box<List> = box Vec::new();\n+        DTORS.set(Box::into_raw(v) as *mut u8);\n+    }\n+    let list: &mut List = &mut *(DTORS.get() as *mut List);\n+    list.push((t, dtor));\n+\n+    unsafe extern fn run_dtors(mut ptr: *mut u8) {\n+        while !ptr.is_null() {\n+            let list: Box<List> = Box::from_raw(ptr as *mut List);\n+            for &(ptr, dtor) in list.iter() {\n+                dtor(ptr);\n+            }\n+            ptr = DTORS.get();\n+            DTORS.set(ptr::null_mut());\n+        }\n+    }\n+}\n+\n+// Since what appears to be glibc 2.18 this symbol has been shipped which\n+// GCC and clang both use to invoke destructors in thread_local globals, so\n+// let's do the same!\n+//\n+// Note, however, that we run on lots older linuxes, as well as cross\n+// compiling from a newer linux to an older linux, so we also have a\n+// fallback implementation to use as well.\n+//\n+// Due to rust-lang/rust#18804, make sure this is not generic!\n+#[cfg(target_os = \"linux\")]\n+unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    use mem;\n+    use libc;\n+\n+    extern {\n+        #[linkage = \"extern_weak\"]\n+        static __dso_handle: *mut u8;\n+        #[linkage = \"extern_weak\"]\n+        static __cxa_thread_atexit_impl: *const libc::c_void;\n+    }\n+    if !__cxa_thread_atexit_impl.is_null() {\n+        type F = unsafe extern fn(dtor: unsafe extern fn(*mut u8),\n+                                  arg: *mut u8,\n+                                  dso_handle: *mut u8) -> libc::c_int;\n+        mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)\n+            (dtor, t, &__dso_handle as *const _ as *mut _);\n+        return\n+    }\n+    register_dtor_fallback(t, dtor);\n+}\n+\n+// OSX's analog of the above linux function is this _tlv_atexit function.\n+// The disassembly of thread_local globals in C++ (at least produced by\n+// clang) will have this show up in the output.\n+#[cfg(target_os = \"macos\")]\n+unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    extern {\n+        fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),\n+                       arg: *mut u8);\n+    }\n+    _tlv_atexit(dtor, t);\n+}\n+\n+// Just use the thread_local fallback implementation, at least until there's\n+// a more direct implementation.\n+#[cfg(target_os = \"fuchsia\")]\n+unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+    register_dtor_fallback(t, dtor);\n+}\n+\n+pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n+    let ptr = ptr as *mut Key<T>;\n+    // Right before we run the user destructor be sure to flag the\n+    // destructor as running for this thread so calls to `get` will return\n+    // `None`.\n+    (*ptr).dtor_running.set(true);\n+\n+    // The OSX implementation of TLS apparently had an odd aspect to it\n+    // where the pointer we have may be overwritten while this destructor\n+    // is running. Specifically if a TLS destructor re-accesses TLS it may\n+    // trigger a re-initialization of all TLS variables, paving over at\n+    // least some destroyed ones with initial values.\n+    //\n+    // This means that if we drop a TLS value in place on OSX that we could\n+    // revert the value to its original state halfway through the\n+    // destructor, which would be bad!\n+    //\n+    // Hence, we use `ptr::read` on OSX (to move to a \"safe\" location)\n+    // instead of drop_in_place.\n+    if cfg!(target_os = \"macos\") {\n+        ptr::read((*ptr).inner.get());\n+    } else {\n+        ptr::drop_in_place((*ptr).inner.get());\n+    }\n+}"}, {"sha": "0e28426b32f205c9d1eddc7e50fdb491ed2b1b7b", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/568840707cd5f98a1970a44d632b833439d5312e/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/568840707cd5f98a1970a44d632b833439d5312e/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=568840707cd5f98a1970a44d632b833439d5312e", "patch": "@@ -38,6 +38,7 @@ pub mod backtrace;\n pub mod condvar;\n pub mod env;\n pub mod ext;\n+pub mod fast_thread_local;\n pub mod fd;\n pub mod fs;\n pub mod memchr;"}, {"sha": "f74dd5924951c1f02daaa2d6835e91ac919bbcba", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 2, "deletions": 161, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/568840707cd5f98a1970a44d632b833439d5312e/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/568840707cd5f98a1970a44d632b833439d5312e/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=568840707cd5f98a1970a44d632b833439d5312e", "patch": "@@ -166,8 +166,8 @@ macro_rules! __thread_local_inner {\n         {\n             #[thread_local]\n             #[cfg(target_thread_local)]\n-            static __KEY: $crate::thread::__ElfLocalKeyInner<$t> =\n-                $crate::thread::__ElfLocalKeyInner::new();\n+            static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n+                $crate::thread::__FastLocalKeyInner::new();\n \n             #[cfg(not(target_thread_local))]\n             static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n@@ -310,165 +310,6 @@ impl<T: 'static> LocalKey<T> {\n     }\n }\n \n-#[cfg(target_thread_local)]\n-#[doc(hidden)]\n-pub mod elf {\n-    use cell::{Cell, UnsafeCell};\n-    use intrinsics;\n-    use ptr;\n-\n-    pub struct Key<T> {\n-        inner: UnsafeCell<Option<T>>,\n-\n-        // Metadata to keep track of the state of the destructor. Remember that\n-        // these variables are thread-local, not global.\n-        dtor_registered: Cell<bool>,\n-        dtor_running: Cell<bool>,\n-    }\n-\n-    unsafe impl<T> ::marker::Sync for Key<T> { }\n-\n-    impl<T> Key<T> {\n-        pub const fn new() -> Key<T> {\n-            Key {\n-                inner: UnsafeCell::new(None),\n-                dtor_registered: Cell::new(false),\n-                dtor_running: Cell::new(false)\n-            }\n-        }\n-\n-        pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n-            unsafe {\n-                if intrinsics::needs_drop::<T>() && self.dtor_running.get() {\n-                    return None\n-                }\n-                self.register_dtor();\n-            }\n-            Some(&self.inner)\n-        }\n-\n-        unsafe fn register_dtor(&self) {\n-            if !intrinsics::needs_drop::<T>() || self.dtor_registered.get() {\n-                return\n-            }\n-\n-            register_dtor(self as *const _ as *mut u8,\n-                          destroy_value::<T>);\n-            self.dtor_registered.set(true);\n-        }\n-    }\n-\n-    #[cfg(any(target_os = \"linux\", target_os = \"fuchsia\"))]\n-    unsafe fn register_dtor_fallback(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-        // The fallback implementation uses a vanilla OS-based TLS key to track\n-        // the list of destructors that need to be run for this thread. The key\n-        // then has its own destructor which runs all the other destructors.\n-        //\n-        // The destructor for DTORS is a little special in that it has a `while`\n-        // loop to continuously drain the list of registered destructors. It\n-        // *should* be the case that this loop always terminates because we\n-        // provide the guarantee that a TLS key cannot be set after it is\n-        // flagged for destruction.\n-        use sys_common::thread_local as os;\n-\n-        static DTORS: os::StaticKey = os::StaticKey::new(Some(run_dtors));\n-        type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n-        if DTORS.get().is_null() {\n-            let v: Box<List> = box Vec::new();\n-            DTORS.set(Box::into_raw(v) as *mut u8);\n-        }\n-        let list: &mut List = &mut *(DTORS.get() as *mut List);\n-        list.push((t, dtor));\n-\n-        unsafe extern fn run_dtors(mut ptr: *mut u8) {\n-            while !ptr.is_null() {\n-                let list: Box<List> = Box::from_raw(ptr as *mut List);\n-                for &(ptr, dtor) in list.iter() {\n-                    dtor(ptr);\n-                }\n-                ptr = DTORS.get();\n-                DTORS.set(ptr::null_mut());\n-            }\n-        }\n-    }\n-\n-    // Since what appears to be glibc 2.18 this symbol has been shipped which\n-    // GCC and clang both use to invoke destructors in thread_local globals, so\n-    // let's do the same!\n-    //\n-    // Note, however, that we run on lots older linuxes, as well as cross\n-    // compiling from a newer linux to an older linux, so we also have a\n-    // fallback implementation to use as well.\n-    //\n-    // Due to rust-lang/rust#18804, make sure this is not generic!\n-    #[cfg(target_os = \"linux\")]\n-    unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-        use mem;\n-        use libc;\n-\n-        extern {\n-            #[linkage = \"extern_weak\"]\n-            static __dso_handle: *mut u8;\n-            #[linkage = \"extern_weak\"]\n-            static __cxa_thread_atexit_impl: *const libc::c_void;\n-        }\n-        if !__cxa_thread_atexit_impl.is_null() {\n-            type F = unsafe extern fn(dtor: unsafe extern fn(*mut u8),\n-                                      arg: *mut u8,\n-                                      dso_handle: *mut u8) -> libc::c_int;\n-            mem::transmute::<*const libc::c_void, F>(__cxa_thread_atexit_impl)\n-            (dtor, t, &__dso_handle as *const _ as *mut _);\n-            return\n-        }\n-        register_dtor_fallback(t, dtor);\n-    }\n-\n-    // OSX's analog of the above linux function is this _tlv_atexit function.\n-    // The disassembly of thread_local globals in C++ (at least produced by\n-    // clang) will have this show up in the output.\n-    #[cfg(target_os = \"macos\")]\n-    unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-        extern {\n-            fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),\n-                           arg: *mut u8);\n-        }\n-        _tlv_atexit(dtor, t);\n-    }\n-\n-    // Just use the thread_local fallback implementation, at least until there's\n-    // a more direct implementation.\n-    #[cfg(target_os = \"fuchsia\")]\n-    unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n-        register_dtor_fallback(t, dtor);\n-    }\n-\n-    pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n-        let ptr = ptr as *mut Key<T>;\n-        // Right before we run the user destructor be sure to flag the\n-        // destructor as running for this thread so calls to `get` will return\n-        // `None`.\n-        (*ptr).dtor_running.set(true);\n-\n-        // The OSX implementation of TLS apparently had an odd aspect to it\n-        // where the pointer we have may be overwritten while this destructor\n-        // is running. Specifically if a TLS destructor re-accesses TLS it may\n-        // trigger a re-initialization of all TLS variables, paving over at\n-        // least some destroyed ones with initial values.\n-        //\n-        // This means that if we drop a TLS value in place on OSX that we could\n-        // revert the value to its original state halfway through the\n-        // destructor, which would be bad!\n-        //\n-        // Hence, we use `ptr::read` on OSX (to move to a \"safe\" location)\n-        // instead of drop_in_place.\n-        if cfg!(target_os = \"macos\") {\n-            ptr::read((*ptr).inner.get());\n-        } else {\n-            ptr::drop_in_place((*ptr).inner.get());\n-        }\n-    }\n-}\n-\n #[doc(hidden)]\n pub mod os {\n     use cell::{Cell, UnsafeCell};"}, {"sha": "4c3980b3c7b34495a3c3f5314619e3c0005986a9", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/568840707cd5f98a1970a44d632b833439d5312e/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/568840707cd5f98a1970a44d632b833439d5312e/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=568840707cd5f98a1970a44d632b833439d5312e", "patch": "@@ -183,7 +183,7 @@ pub use self::local::{LocalKey, LocalKeyState};\n \n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[cfg(target_thread_local)]\n-#[doc(hidden)] pub use self::local::elf::Key as __ElfLocalKeyInner;\n+#[doc(hidden)] pub use sys::fast_thread_local::Key as __FastLocalKeyInner;\n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[doc(hidden)] pub use self::local::os::Key as __OsLocalKeyInner;\n "}, {"sha": "80a2d22691b8b4880eb865b4e92bee2fb7c55f51", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/568840707cd5f98a1970a44d632b833439d5312e/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/568840707cd5f98a1970a44d632b833439d5312e/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=568840707cd5f98a1970a44d632b833439d5312e", "patch": "@@ -69,7 +69,6 @@ const EXCEPTION_PATHS: &'static [&'static str] = &[\n     \"src/libstd/io/stdio.rs\",\n     \"src/libstd/num/f32.rs\",\n     \"src/libstd/num/f64.rs\",\n-    \"src/libstd/thread/local.rs\",\n     \"src/libstd/sys/common/mod.rs\",\n     \"src/libstd/sys/common/net.rs\",\n     \"src/libstd/sys/common/util.rs\","}]}