{"sha": "92725ae765a75b139d5d5fc27305f4436dbb456e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNzI1YWU3NjVhNzViMTM5ZDVkNWZjMjczMDVmNDQzNmRiYjQ1NmU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-09-29T15:29:28Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-09T11:22:42Z"}, "message": "std::rand: Add a trait for seeding RNGs: SeedableRng.\n\nThis provides 2 methods: .reseed() and ::from_seed that modify and\ncreate respecitively.\n\nImplement this trait for the RNGs in the stdlib for which this makes\nsense.", "tree": {"sha": "168c40b54768a00a27960a32c8d2d0478947acca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/168c40b54768a00a27960a32c8d2d0478947acca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92725ae765a75b139d5d5fc27305f4436dbb456e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92725ae765a75b139d5d5fc27305f4436dbb456e", "html_url": "https://github.com/rust-lang/rust/commit/92725ae765a75b139d5d5fc27305f4436dbb456e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92725ae765a75b139d5d5fc27305f4436dbb456e/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0223cf65e41cc1046b306dcd0e3959a20729e0cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0223cf65e41cc1046b306dcd0e3959a20729e0cf", "html_url": "https://github.com/rust-lang/rust/commit/0223cf65e41cc1046b306dcd0e3959a20729e0cf"}], "stats": {"total": 345, "additions": 232, "deletions": 113}, "files": [{"sha": "4f8cd4d33088369873cdacad04336c84d61c2126", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=92725ae765a75b139d5d5fc27305f4436dbb456e", "patch": "@@ -1524,8 +1524,8 @@ mod tests {\n     }\n \n     fn rng() -> rand::IsaacRng {\n-        let seed = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n-        rand::IsaacRng::new_seeded(seed)\n+        let seed = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n+        rand::SeedableRng::from_seed(seed)\n     }\n \n     #[bench]"}, {"sha": "66e1fd0c2c3dc05e2df9bb604932b095f5feb09f", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=92725ae765a75b139d5d5fc27305f4436dbb456e", "patch": "@@ -1013,7 +1013,7 @@ mod test_treemap {\n         check_equal(ctrl, &map);\n         assert!(map.find(&5).is_none());\n \n-        let mut rng = rand::IsaacRng::new_seeded(&[42]);\n+        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(&[42]);\n \n         do 3.times {\n             do 90.times {"}, {"sha": "6d338a922becaa1411d7528e021b157220a0310c", "filename": "src/libstd/rand/isaac.rs", "status": "modified", "additions": 133, "deletions": 80, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Flibstd%2Frand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Flibstd%2Frand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fisaac.rs?ref=92725ae765a75b139d5d5fc27305f4436dbb456e", "patch": "@@ -10,15 +10,10 @@\n \n //! The ISAAC random number generator.\n \n-use rand::{seed, Rng};\n-use iter::{Iterator, range, range_step};\n+use rand::{seed, Rng, SeedableRng};\n+use iter::{Iterator, range, range_step, Repeat};\n use option::{None, Some};\n \n-use cast;\n-use cmp;\n-use sys;\n-use vec;\n-\n static RAND_SIZE_LEN: u32 = 8;\n static RAND_SIZE: u32 = 1 << RAND_SIZE_LEN;\n \n@@ -38,30 +33,8 @@ pub struct IsaacRng {\n impl IsaacRng {\n     /// Create an ISAAC random number generator with a random seed.\n     pub fn new() -> IsaacRng {\n-        IsaacRng::new_seeded(seed(RAND_SIZE as uint * 4))\n-    }\n-\n-    /// Create an ISAAC random number generator with a seed. This can be any\n-    /// length, although the maximum number of bytes used is 1024 and any more\n-    /// will be silently ignored. A generator constructed with a given seed\n-    /// will generate the same sequence of values as all other generators\n-    /// constructed with the same seed.\n-    pub fn new_seeded(seed: &[u8]) -> IsaacRng {\n-        let mut rng = IsaacRng {\n-            cnt: 0,\n-            rsl: [0, .. RAND_SIZE],\n-            mem: [0, .. RAND_SIZE],\n-            a: 0, b: 0, c: 0\n-        };\n-\n-        let array_size = sys::size_of_val(&rng.rsl);\n-        let copy_length = cmp::min(array_size, seed.len());\n-\n-        // manually create a &mut [u8] slice of randrsl to copy into.\n-        let dest = unsafe { cast::transmute((&mut rng.rsl, array_size)) };\n-        vec::bytes::copy_memory(dest, seed, copy_length);\n-        rng.init(true);\n-        rng\n+        let s = unsafe {seed::<u32>(RAND_SIZE as uint)};\n+        SeedableRng::from_seed(s.as_slice())\n     }\n \n     /// Create an ISAAC random number generator using the default\n@@ -197,6 +170,43 @@ impl Rng for IsaacRng {\n     }\n }\n \n+impl<'self> SeedableRng<&'self [u32]> for IsaacRng {\n+    fn reseed(&mut self, seed: &'self [u32]) {\n+        // make the seed into [seed[0], seed[1], ..., seed[seed.len()\n+        // - 1], 0, 0, ...], to fill rng.rsl.\n+        let seed_iter = seed.iter().map(|&x| x).chain(Repeat::new(0u32));\n+\n+        for (rsl_elem, seed_elem) in self.rsl.mut_iter().zip(seed_iter) {\n+            *rsl_elem = seed_elem;\n+        }\n+        self.cnt = 0;\n+        self.a = 0;\n+        self.b = 0;\n+        self.c = 0;\n+\n+        self.init(true);\n+    }\n+\n+    /// Create an ISAAC random number generator with a seed. This can\n+    /// be any length, although the maximum number of elements used is\n+    /// 256 and any more will be silently ignored. A generator\n+    /// constructed with a given seed will generate the same sequence\n+    /// of values as all other generators constructed with that seed.\n+    fn from_seed(seed: &'self [u32]) -> IsaacRng {\n+        let mut rng = IsaacRng {\n+            cnt: 0,\n+            rsl: [0, .. RAND_SIZE],\n+            mem: [0, .. RAND_SIZE],\n+            a: 0, b: 0, c: 0\n+        };\n+\n+        rng.reseed(seed);\n+\n+        rng\n+    }\n+}\n+\n+\n static RAND_SIZE_64_LEN: uint = 8;\n static RAND_SIZE_64: uint = 1 << RAND_SIZE_64_LEN;\n \n@@ -218,31 +228,8 @@ impl Isaac64Rng {\n     /// Create a 64-bit ISAAC random number generator with a random\n     /// seed.\n     pub fn new() -> Isaac64Rng {\n-        Isaac64Rng::new_seeded(seed(RAND_SIZE_64 as uint * 8))\n-    }\n-\n-    /// Create a 64-bit ISAAC random number generator with a\n-    /// seed. This can be any length, although the maximum number of\n-    /// bytes used is 2048 and any more will be silently ignored. A\n-    /// generator constructed with a given seed will generate the same\n-    /// sequence of values as all other generators constructed with\n-    /// the same seed.\n-    pub fn new_seeded(seed: &[u8]) -> Isaac64Rng {\n-        let mut rng = Isaac64Rng {\n-            cnt: 0,\n-            rsl: [0, .. RAND_SIZE_64],\n-            mem: [0, .. RAND_SIZE_64],\n-            a: 0, b: 0, c: 0,\n-        };\n-\n-        let array_size = sys::size_of_val(&rng.rsl);\n-        let copy_length = cmp::min(array_size, seed.len());\n-\n-        // manually create a &mut [u8] slice of randrsl to copy into.\n-        let dest = unsafe { cast::transmute((&mut rng.rsl, array_size)) };\n-        vec::bytes::copy_memory(dest, seed, copy_length);\n-        rng.init(true);\n-        rng\n+        let s = unsafe {seed::<u64>(RAND_SIZE_64)};\n+        SeedableRng::from_seed(s.as_slice())\n     }\n \n     /// Create a 64-bit ISAAC random number generator using the\n@@ -378,52 +365,118 @@ impl Rng for Isaac64Rng {\n     }\n }\n \n+impl<'self> SeedableRng<&'self [u64]> for Isaac64Rng {\n+    fn reseed(&mut self, seed: &'self [u64]) {\n+        // make the seed into [seed[0], seed[1], ..., seed[seed.len()\n+        // - 1], 0, 0, ...], to fill rng.rsl.\n+        let seed_iter = seed.iter().map(|&x| x).chain(Repeat::new(0u64));\n+\n+        for (rsl_elem, seed_elem) in self.rsl.mut_iter().zip(seed_iter) {\n+            *rsl_elem = seed_elem;\n+        }\n+        self.cnt = 0;\n+        self.a = 0;\n+        self.b = 0;\n+        self.c = 0;\n+\n+        self.init(true);\n+    }\n+\n+    /// Create an ISAAC random number generator with a seed. This can\n+    /// be any length, although the maximum number of elements used is\n+    /// 256 and any more will be silently ignored. A generator\n+    /// constructed with a given seed will generate the same sequence\n+    /// of values as all other generators constructed with that seed.\n+    fn from_seed(seed: &'self [u64]) -> Isaac64Rng {\n+        let mut rng = Isaac64Rng {\n+            cnt: 0,\n+            rsl: [0, .. RAND_SIZE_64],\n+            mem: [0, .. RAND_SIZE_64],\n+            a: 0, b: 0, c: 0,\n+        };\n+        rng.reseed(seed);\n+        rng\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use rand::{Rng, seed};\n-    use option::{Option, Some};\n+    use rand::{Rng, SeedableRng, seed};\n+    use option::Some;\n+    use iter::range;\n+    use vec;\n \n     #[test]\n     fn test_rng_seeded() {\n-        let seed = seed(1024);\n-        let mut ra = IsaacRng::new_seeded(seed);\n-        let mut rb = IsaacRng::new_seeded(seed);\n+        let s = unsafe {seed::<u32>(256)};\n+        let mut ra: IsaacRng = SeedableRng::from_seed(s.as_slice());\n+        let mut rb: IsaacRng = SeedableRng::from_seed(s.as_slice());\n         assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n \n-        let seed = seed(2048);\n-        let mut ra = Isaac64Rng::new_seeded(seed);\n-        let mut rb = Isaac64Rng::new_seeded(seed);\n+        let s = unsafe {seed::<u64>(256)};\n+        let mut ra: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n+        let mut rb: Isaac64Rng = SeedableRng::from_seed(s.as_slice());\n         assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n     }\n \n     #[test]\n     fn test_rng_seeded_custom_seed() {\n         // much shorter than generated seeds which are 1024 & 2048\n         // bytes resp.\n-        let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n-        let mut ra = IsaacRng::new_seeded(seed);\n-        let mut rb = IsaacRng::new_seeded(seed);\n+        let seed = &[2, 32, 4, 32, 51];\n+        let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n+        let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n \n-        let mut ra = Isaac64Rng::new_seeded(seed);\n-        let mut rb = Isaac64Rng::new_seeded(seed);\n+        let seed = &[2, 32, 4, 32, 51];\n+        let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n+        let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n     }\n \n     #[test]\n-    fn test_rng_seeded_custom_seed2() {\n-        let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n-        let mut ra = IsaacRng::new_seeded(seed);\n+    fn test_rng_32_true_values() {\n+        let seed = &[2, 32, 4, 32, 51];\n+        let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n-        let r = ra.next_u32();\n-        error2!(\"{:?}\", r);\n-        assert_eq!(r, 2935188040u32);\n-\n-        let mut ra = Isaac64Rng::new_seeded(seed);\n+        let v = vec::from_fn(10, |_| ra.next_u32());\n+        assert_eq!(v,\n+                   ~[447462228, 2081944040, 3163797308, 2379916134, 2377489184,\n+                     1132373754, 536342443, 2995223415, 1265094839, 345325140]);\n+\n+        let seed = &[500, -4000, 123456, 9876543, 1, 1, 1, 1, 1];\n+        let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n+        // skip forward to the 10000th number\n+        for _ in range(0, 10000) { rb.next_u32(); }\n+\n+        let v = vec::from_fn(10, |_| rb.next_u32());\n+        assert_eq!(v,\n+                   ~[612373032, 292987903, 1819311337, 3141271980, 422447569,\n+                     310096395, 1083172510, 867909094, 2478664230, 2073577855]);\n+    }\n+    #[test]\n+    fn test_rng_64_true_values() {\n+        let seed = &[2, 32, 4, 32, 51];\n+        let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n-        let r = ra.next_u64();\n-        error2!(\"{:?}\", r);\n-        assert!(r == 0 && r == 1); // FIXME: find true value\n+        let v = vec::from_fn(10, |_| ra.next_u64());\n+        assert_eq!(v,\n+                   ~[15015576812873463115, 12461067598045625862, 14818626436142668771,\n+                     5562406406765984441, 11813289907965514161, 13443797187798420053,\n+                     6935026941854944442, 7750800609318664042, 14428747036317928637,\n+                     14028894460301215947]);\n+\n+        let seed = &[500, -4000, 123456, 9876543, 1, 1, 1, 1, 1];\n+        let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n+        // skip forward to the 10000th number\n+        for _ in range(0, 10000) { rb.next_u64(); }\n+\n+        let v = vec::from_fn(10, |_| rb.next_u64());\n+        assert_eq!(v,\n+                   ~[13557216323596688637, 17060829581390442094, 4927582063811333743,\n+                     2699639759356482270, 4819341314392384881, 6047100822963614452,\n+                     11086255989965979163, 11901890363215659856, 5370800226050011580,\n+                     16496463556025356451]);\n     }\n }"}, {"sha": "64f266d00452b0628af513d8cc6a2804ca10c712", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 85, "deletions": 21, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=92725ae765a75b139d5d5fc27305f4436dbb456e", "patch": "@@ -638,6 +638,42 @@ pub trait Rng {\n     }\n }\n \n+/// A random number generator that can be explicitly seeded to produce\n+/// the same stream of randomness multiple times.\n+pub trait SeedableRng<Seed>: Rng {\n+    /// Reseed an RNG with the given seed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::rand;\n+    /// use std::rand::Rng;\n+    ///\n+    /// fn main() {\n+    ///     let mut rng: rand::XorShiftRng = rand::SeedableRng::from_seed(&[1, 2, 3, 4]);\n+    ///     println!(\"{}\", rng.gen::<f64>());\n+    ///     rng.reseed([5, 6, 7, 8]);\n+    ///     println!(\"{}\", rng.gen::<f64>());\n+    /// }\n+    /// ```\n+    fn reseed(&mut self, Seed);\n+\n+    /// Create a new RNG with the given seed.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::rand;\n+    /// use std::rand::Rng;\n+    ///\n+    /// fn main() {\n+    ///     let mut rng: rand::XorShiftRng = rand::SeedableRng::from_seed(&[1, 2, 3, 4]);\n+    ///     println!(\"{}\", rng.gen::<f64>());\n+    /// }\n+    /// ```\n+    fn from_seed(seed: Seed) -> Self;\n+}\n+\n /// Create a random number generator with a default algorithm and seed.\n ///\n /// It returns the cryptographically-safest `Rng` algorithm currently\n@@ -686,6 +722,18 @@ impl Rng for StdRng {\n     }\n }\n \n+impl<'self> SeedableRng<&'self [uint]> for StdRng {\n+    fn reseed(&mut self, seed: &'self [uint]) {\n+        // the internal RNG can just be seeded from the above\n+        // randomness.\n+        self.rng.reseed(unsafe {cast::transmute(seed)})\n+    }\n+\n+    fn from_seed(seed: &'self [uint]) -> StdRng {\n+        StdRng { rng: SeedableRng::from_seed(unsafe {cast::transmute(seed)}) }\n+    }\n+}\n+\n /// Create a weak random number generator with a default algorithm and seed.\n ///\n /// It returns the fastest `Rng` algorithm currently available in Rust without\n@@ -723,11 +771,35 @@ impl Rng for XorShiftRng {\n     }\n }\n \n+impl SeedableRng<[u32, .. 4]> for XorShiftRng {\n+    /// Reseed an XorShiftRng. This will fail if `seed` is entirely 0.\n+    fn reseed(&mut self, seed: [u32, .. 4]) {\n+        assert!(!seed.iter().all(|&x| x == 0),\n+                \"XorShiftRng.reseed called with an all zero seed.\");\n+\n+        self.x = seed[0];\n+        self.y = seed[1];\n+        self.z = seed[2];\n+        self.w = seed[3];\n+    }\n+\n+    /// Create a new XorShiftRng. This will fail if `seed` is entirely 0.\n+    fn from_seed(seed: [u32, .. 4]) -> XorShiftRng {\n+        assert!(!seed.iter().all(|&x| x == 0),\n+                \"XorShiftRng::from_seed called with an all zero seed.\");\n+\n+        XorShiftRng {\n+            x: seed[0],\n+            y: seed[1],\n+            z: seed[2],\n+            w: seed[3]\n+        }\n+    }\n+}\n+\n impl XorShiftRng {\n     /// Create an xor shift random number generator with a random seed.\n     pub fn new() -> XorShiftRng {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n         // generate seeds the same way as seed(), except we have a\n         // specific size, so we can just use a fixed buffer.\n         let mut s = [0u8, ..16];\n@@ -740,29 +812,21 @@ impl XorShiftRng {\n             }\n         }\n         let s: &[u32, ..4] = unsafe { cast::transmute(&s) };\n-        XorShiftRng::new_seeded(s[0], s[1], s[2], s[3])\n-    }\n-\n-    /**\n-     * Create a random number generator using the specified seed. A generator\n-     * constructed with a given seed will generate the same sequence of values\n-     * as all other generators constructed with the same seed.\n-     */\n-    pub fn new_seeded(x: u32, y: u32, z: u32, w: u32) -> XorShiftRng {\n-        XorShiftRng {\n-            x: x,\n-            y: y,\n-            z: z,\n-            w: w,\n-        }\n+        SeedableRng::from_seed(*s)\n     }\n }\n \n-/// Create a new random seed of length `n`.\n-pub fn seed(n: uint) -> ~[u8] {\n-    let mut s = vec::from_elem(n as uint, 0_u8);\n+/// Create a new random seed of length `n`. This should only be used\n+/// to create types for which *any* bit pattern is valid.\n+pub unsafe fn seed<T: Clone>(n: uint) -> ~[T] {\n+    use unstable::intrinsics;\n+    let mut s = vec::from_elem(n, intrinsics::init());\n     let mut r = OSRng::new();\n-    r.fill_bytes(s);\n+\n+    {\n+        let s_u8 = cast::transmute::<&mut [T], &mut [u8]>(s);\n+        r.fill_bytes(s_u8);\n+    }\n     s\n }\n "}, {"sha": "727efff0101f07efdfbf384bc23a73d52ed74824", "filename": "src/libstd/rand/reseeding.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Flibstd%2Frand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Flibstd%2Frand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freseeding.rs?ref=92725ae765a75b139d5d5fc27305f4436dbb456e", "patch": "@@ -97,6 +97,8 @@ mod test {\n     use super::*;\n     use rand::Rng;\n     use default::Default;\n+    use iter::range;\n+    use option::{None, Some};\n \n     struct Counter {\n         i: u32\n@@ -117,7 +119,7 @@ mod test {\n \n     #[test]\n     fn test_reseeding() {\n-        let mut rs = ReseedingRng::from_options(Counter {i:0}, 100, ReseedWithDefault);\n+        let mut rs = ReseedingRng::new(Counter {i:0}, 400, ReseedWithDefault);\n \n         let mut i = 0;\n         for _ in range(0, 1000) {"}, {"sha": "c1ca484754d20aa4064a43416ccb6bf9ded48a67", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=92725ae765a75b139d5d5fc27305f4436dbb456e", "patch": "@@ -26,7 +26,7 @@ use rt::local::Local;\n use rt::rtio::{RemoteCallback, PausibleIdleCallback};\n use borrow::{to_uint};\n use cell::Cell;\n-use rand::{XorShiftRng, Rng, Rand};\n+use rand::{SeedableRng, XorShiftRng, Rng, Rand};\n use iter::range;\n use vec::{OwnedVector};\n \n@@ -895,7 +895,7 @@ fn new_sched_rng() -> XorShiftRng {\n     // know that the only way that we can fail here is `abort`ing?\n     unsafe {libc::fclose(file);}\n \n-    XorShiftRng::new_seeded(seeds[0], seeds[1], seeds[2], seeds[3])\n+    SeedableRng::from_seed(seeds)\n }\n \n #[cfg(test)]"}, {"sha": "2d209e40e424942a0c7cd4d20ee0ae383219b2ec", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=92725ae765a75b139d5d5fc27305f4436dbb456e", "patch": "@@ -15,7 +15,7 @@ use extra::treemap::TreeMap;\n use std::hashmap::{HashMap, HashSet};\n use std::io;\n use std::os;\n-use std::rand::Rng;\n+use std::rand::{Rng, IsaacRng, SeedableRng};\n use std::trie::TrieMap;\n use std::uint;\n use std::vec;\n@@ -106,7 +106,7 @@ fn main() {\n     let mut rand = vec::with_capacity(n_keys);\n \n     {\n-        let mut rng = std::rand::IsaacRng::new_seeded([1, 1, 1, 1, 1, 1, 1]);\n+        let mut rng: IsaacRng = SeedableRng::from_seed(&[1, 1, 1, 1, 1, 1, 1]);\n         let mut set = HashSet::new();\n         while set.len() != n_keys {\n             let next = rng.gen();"}, {"sha": "b9a8e74668fa9683dadb99efe31b2ae5e1610d91", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92725ae765a75b139d5d5fc27305f4436dbb456e/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=92725ae765a75b139d5d5fc27305f4436dbb456e", "patch": "@@ -163,11 +163,11 @@ fn main() {\n         }\n     };\n \n-    let seed = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let seed = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let max = 200000;\n \n     {\n-        let mut rng = rand::IsaacRng::new_seeded(seed);\n+        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n         let mut results = empty_results();\n         results.bench_int(&mut rng, num_keys, max, || {\n             let s: HashSet<uint> = HashSet::new();\n@@ -181,7 +181,7 @@ fn main() {\n     }\n \n     {\n-        let mut rng = rand::IsaacRng::new_seeded(seed);\n+        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n         let mut results = empty_results();\n         results.bench_int(&mut rng, num_keys, max, || {\n             let s: TreeSet<uint> = TreeSet::new();\n@@ -195,7 +195,7 @@ fn main() {\n     }\n \n     {\n-        let mut rng = rand::IsaacRng::new_seeded(seed);\n+        let mut rng: rand::IsaacRng = rand::SeedableRng::from_seed(seed);\n         let mut results = empty_results();\n         results.bench_int(&mut rng, num_keys, max, || BitvSet::new());\n         write_results(\"extra::bitv::BitvSet\", &results);"}]}