{"sha": "441dc3640a408e612064464b0c6308bdca6c16ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MWRjMzY0MGE0MDhlNjEyMDY0NDY0YjBjNjMwOGJkY2E2YzE2Y2U=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-03-16T05:50:34Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-03-28T02:16:33Z"}, "message": "Remove (lots of) dead code\n\nFound with https://github.com/est31/warnalyzer.\n\nDubious changes:\n- Is anyone else using rustc_apfloat? I feel weird completely deleting\n  x87 support.\n- Maybe some of the dead code in rustc_data_structures, in case someone\n  wants to use it in the future?\n- Don't change rustc_serialize\n\n  I plan to scrap most of the json module in the near future (see\n  https://github.com/rust-lang/compiler-team/issues/418) and fixing the\n  tests needed more work than I expected.\n\nTODO: check if any of the comments on the deleted code should be kept.", "tree": {"sha": "15e0bbd467ae94a5993efa451354076c396b4809", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15e0bbd467ae94a5993efa451354076c396b4809"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/441dc3640a408e612064464b0c6308bdca6c16ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/441dc3640a408e612064464b0c6308bdca6c16ce", "html_url": "https://github.com/rust-lang/rust/commit/441dc3640a408e612064464b0c6308bdca6c16ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/441dc3640a408e612064464b0c6308bdca6c16ce/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "785aeac521e54da8c6826396d05446227e19ee40", "url": "https://api.github.com/repos/rust-lang/rust/commits/785aeac521e54da8c6826396d05446227e19ee40", "html_url": "https://github.com/rust-lang/rust/commit/785aeac521e54da8c6826396d05446227e19ee40"}], "stats": {"total": 1358, "additions": 60, "deletions": 1298}, "files": [{"sha": "c3e4945c4464cfadf866398839075ea2d82b5811", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -236,26 +236,6 @@ impl<T> TypedArena<T> {\n         start_ptr\n     }\n \n-    /// Allocates a slice of objects that are copied into the `TypedArena`, returning a mutable\n-    /// reference to it. Will panic if passed a zero-sized types.\n-    ///\n-    /// Panics:\n-    ///\n-    ///  - Zero-sized types\n-    ///  - Zero-length slices\n-    #[inline]\n-    pub fn alloc_slice(&self, slice: &[T]) -> &mut [T]\n-    where\n-        T: Copy,\n-    {\n-        unsafe {\n-            let len = slice.len();\n-            let start_ptr = self.alloc_raw_slice(len);\n-            slice.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n-            slice::from_raw_parts_mut(start_ptr, len)\n-        }\n-    }\n-\n     #[inline]\n     pub fn alloc_from_iter<I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n         assert!(mem::size_of::<T>() != 0);"}, {"sha": "2cffddfcd0b95ff42bcaba15772114a086cbdd99", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -762,14 +762,6 @@ pub enum Mutability {\n }\n \n impl Mutability {\n-    /// Returns `MutMutable` only if both `self` and `other` are mutable.\n-    pub fn and(self, other: Self) -> Self {\n-        match self {\n-            Mutability::Mut => other,\n-            Mutability::Not => Mutability::Not,\n-        }\n-    }\n-\n     pub fn invert(self) -> Self {\n         match self {\n             Mutability::Mut => Mutability::Not,\n@@ -1722,13 +1714,6 @@ impl FloatTy {\n             FloatTy::F64 => sym::f64,\n         }\n     }\n-\n-    pub fn bit_width(self) -> u64 {\n-        match self {\n-            FloatTy::F32 => 32,\n-            FloatTy::F64 => 64,\n-        }\n-    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n@@ -1764,29 +1749,6 @@ impl IntTy {\n             IntTy::I128 => sym::i128,\n         }\n     }\n-\n-    pub fn bit_width(&self) -> Option<u64> {\n-        Some(match *self {\n-            IntTy::Isize => return None,\n-            IntTy::I8 => 8,\n-            IntTy::I16 => 16,\n-            IntTy::I32 => 32,\n-            IntTy::I64 => 64,\n-            IntTy::I128 => 128,\n-        })\n-    }\n-\n-    pub fn normalize(&self, target_width: u32) -> Self {\n-        match self {\n-            IntTy::Isize => match target_width {\n-                16 => IntTy::I16,\n-                32 => IntTy::I32,\n-                64 => IntTy::I64,\n-                _ => unreachable!(),\n-            },\n-            _ => *self,\n-        }\n-    }\n }\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Debug)]\n@@ -1822,29 +1784,6 @@ impl UintTy {\n             UintTy::U128 => sym::u128,\n         }\n     }\n-\n-    pub fn bit_width(&self) -> Option<u64> {\n-        Some(match *self {\n-            UintTy::Usize => return None,\n-            UintTy::U8 => 8,\n-            UintTy::U16 => 16,\n-            UintTy::U32 => 32,\n-            UintTy::U64 => 64,\n-            UintTy::U128 => 128,\n-        })\n-    }\n-\n-    pub fn normalize(&self, target_width: u32) -> Self {\n-        match self {\n-            UintTy::Usize => match target_width {\n-                16 => UintTy::U16,\n-                32 => UintTy::U32,\n-                64 => UintTy::U64,\n-                _ => unreachable!(),\n-            },\n-            _ => *self,\n-        }\n-    }\n }\n \n /// A constraint on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n@@ -2215,9 +2154,6 @@ pub struct FnDecl {\n }\n \n impl FnDecl {\n-    pub fn get_self(&self) -> Option<ExplicitSelf> {\n-        self.inputs.get(0).and_then(Param::to_self)\n-    }\n     pub fn has_self(&self) -> bool {\n         self.inputs.get(0).map_or(false, Param::is_self)\n     }"}, {"sha": "0fbe4d0120caff421751c9a8671224d133905cab", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -100,16 +100,7 @@ impl NestedMetaItem {\n         self.meta_item().map_or(false, |meta_item| meta_item.is_word())\n     }\n \n-    /// Returns `true` if `self` is a `MetaItem` and the meta item is a `ValueString`.\n-    pub fn is_value_str(&self) -> bool {\n-        self.value_str().is_some()\n-    }\n-\n-    /// Returns `true` if `self` is a `MetaItem` and the meta item is a list.\n-    pub fn is_meta_item_list(&self) -> bool {\n-        self.meta_item_list().is_some()\n-    }\n-\n+    /// See [`MetaItem::name_value_literal_span`].\n     pub fn name_value_literal_span(&self) -> Option<Span> {\n         self.meta_item()?.name_value_literal_span()\n     }\n@@ -165,31 +156,6 @@ impl Attribute {\n             false\n         }\n     }\n-\n-    pub fn is_meta_item_list(&self) -> bool {\n-        self.meta_item_list().is_some()\n-    }\n-\n-    /// Indicates if the attribute is a `ValueString`.\n-    pub fn is_value_str(&self) -> bool {\n-        self.value_str().is_some()\n-    }\n-\n-    /// This is used in case you want the value span instead of the whole attribute. Example:\n-    ///\n-    /// ```text\n-    /// #[doc(alias = \"foo\")]\n-    /// ```\n-    ///\n-    /// In here, it'll return a span for `\"foo\"`.\n-    pub fn name_value_literal_span(&self) -> Option<Span> {\n-        match self.kind {\n-            AttrKind::Normal(ref item, _) => {\n-                item.meta(self.span).and_then(|meta| meta.name_value_literal_span())\n-            }\n-            AttrKind::DocComment(..) => None,\n-        }\n-    }\n }\n \n impl MetaItem {\n@@ -236,10 +202,6 @@ impl MetaItem {\n         self.path == name\n     }\n \n-    pub fn is_value_str(&self) -> bool {\n-        self.value_str().is_some()\n-    }\n-\n     /// This is used in case you want the value span instead of the whole attribute. Example:\n     ///\n     /// ```text"}, {"sha": "06d49c7524a58189bcd2645155792a00fb9ff4f0", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -89,10 +89,6 @@ impl TokenTree {\n         }\n     }\n \n-    pub fn joint(self) -> TokenStream {\n-        TokenStream::new(vec![(self, Spacing::Joint)])\n-    }\n-\n     pub fn token(kind: TokenKind, span: Span) -> TokenTree {\n         TokenTree::Token(Token::new(kind, span))\n     }\n@@ -278,14 +274,6 @@ impl TokenStream {\n         self.0.len()\n     }\n \n-    pub fn span(&self) -> Option<Span> {\n-        match &**self.0 {\n-            [] => None,\n-            [(tt, _)] => Some(tt.span()),\n-            [(tt_start, _), .., (tt_end, _)] => Some(tt_start.span().to(tt_end.span())),\n-        }\n-    }\n-\n     pub fn from_streams(mut streams: SmallVec<[TokenStream; 2]>) -> TokenStream {\n         match streams.len() {\n             0 => TokenStream::default(),\n@@ -325,10 +313,6 @@ impl TokenStream {\n         }\n     }\n \n-    pub fn trees_ref(&self) -> CursorRef<'_> {\n-        CursorRef::new(self)\n-    }\n-\n     pub fn trees(&self) -> Cursor {\n         self.clone().into_trees()\n     }\n@@ -427,10 +411,6 @@ pub struct CursorRef<'t> {\n }\n \n impl<'t> CursorRef<'t> {\n-    fn new(stream: &TokenStream) -> CursorRef<'_> {\n-        CursorRef { stream, index: 0 }\n-    }\n-\n     fn next_with_spacing(&mut self) -> Option<&'t TreeAndSpacing> {\n         self.stream.0.get(self.index).map(|tree| {\n             self.index += 1;"}, {"sha": "976725b308e02d6f2631b79db7f29c519acd4e93", "filename": "compiler/rustc_ast_pretty/src/pprust/mod.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -22,10 +22,6 @@ pub fn token_to_string(token: &Token) -> String {\n     State::new().token_to_string(token)\n }\n \n-pub fn token_to_string_ext(token: &Token, convert_dollar_crate: bool) -> String {\n-    State::new().token_to_string_ext(token, convert_dollar_crate)\n-}\n-\n pub fn ty_to_string(ty: &ast::Ty) -> String {\n     State::new().ty_to_string(ty)\n }\n@@ -50,18 +46,10 @@ pub fn tts_to_string(tokens: &TokenStream) -> String {\n     State::new().tts_to_string(tokens)\n }\n \n-pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n-    State::new().stmt_to_string(stmt)\n-}\n-\n pub fn item_to_string(i: &ast::Item) -> String {\n     State::new().item_to_string(i)\n }\n \n-pub fn generic_params_to_string(generic_params: &[ast::GenericParam]) -> String {\n-    State::new().generic_params_to_string(generic_params)\n-}\n-\n pub fn path_to_string(p: &ast::Path) -> String {\n     State::new().path_to_string(p)\n }\n@@ -74,26 +62,14 @@ pub fn vis_to_string(v: &ast::Visibility) -> String {\n     State::new().vis_to_string(v)\n }\n \n-pub fn block_to_string(blk: &ast::Block) -> String {\n-    State::new().block_to_string(blk)\n-}\n-\n pub fn meta_list_item_to_string(li: &ast::NestedMetaItem) -> String {\n     State::new().meta_list_item_to_string(li)\n }\n \n-pub fn attr_item_to_string(ai: &ast::AttrItem) -> String {\n-    State::new().attr_item_to_string(ai)\n-}\n-\n pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n     State::new().attribute_to_string(attr)\n }\n \n-pub fn param_to_string(arg: &ast::Param) -> String {\n-    State::new().param_to_string(arg)\n-}\n-\n pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n     State::new().to_string(f)\n }"}, {"sha": "627c0584b6114c7af1fd81fd628533b2e7b314c4", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -2292,10 +2292,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_usize(&mut self, i: usize) {\n-        self.s.word(i.to_string())\n-    }\n-\n     crate fn print_name(&mut self, name: Symbol) {\n         self.s.word(name.to_string());\n         self.ann.post(self, AnnNode::Name(&name))"}, {"sha": "4a1b76079b37a325886ea4c8a2089a473261fd7b", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 87, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -190,33 +190,6 @@ pub enum RealPredicate {\n     RealPredicateTrue = 15,\n }\n \n-impl RealPredicate {\n-    pub fn from_generic(realpred: rustc_codegen_ssa::common::RealPredicate) -> Self {\n-        match realpred {\n-            rustc_codegen_ssa::common::RealPredicate::RealPredicateFalse => {\n-                RealPredicate::RealPredicateFalse\n-            }\n-            rustc_codegen_ssa::common::RealPredicate::RealOEQ => RealPredicate::RealOEQ,\n-            rustc_codegen_ssa::common::RealPredicate::RealOGT => RealPredicate::RealOGT,\n-            rustc_codegen_ssa::common::RealPredicate::RealOGE => RealPredicate::RealOGE,\n-            rustc_codegen_ssa::common::RealPredicate::RealOLT => RealPredicate::RealOLT,\n-            rustc_codegen_ssa::common::RealPredicate::RealOLE => RealPredicate::RealOLE,\n-            rustc_codegen_ssa::common::RealPredicate::RealONE => RealPredicate::RealONE,\n-            rustc_codegen_ssa::common::RealPredicate::RealORD => RealPredicate::RealORD,\n-            rustc_codegen_ssa::common::RealPredicate::RealUNO => RealPredicate::RealUNO,\n-            rustc_codegen_ssa::common::RealPredicate::RealUEQ => RealPredicate::RealUEQ,\n-            rustc_codegen_ssa::common::RealPredicate::RealUGT => RealPredicate::RealUGT,\n-            rustc_codegen_ssa::common::RealPredicate::RealUGE => RealPredicate::RealUGE,\n-            rustc_codegen_ssa::common::RealPredicate::RealULT => RealPredicate::RealULT,\n-            rustc_codegen_ssa::common::RealPredicate::RealULE => RealPredicate::RealULE,\n-            rustc_codegen_ssa::common::RealPredicate::RealUNE => RealPredicate::RealUNE,\n-            rustc_codegen_ssa::common::RealPredicate::RealPredicateTrue => {\n-                RealPredicate::RealPredicateTrue\n-            }\n-        }\n-    }\n-}\n-\n /// LLVMTypeKind\n #[derive(Copy, Clone, PartialEq, Debug)]\n #[repr(C)]\n@@ -711,7 +684,7 @@ pub mod coverageinfo {\n     }\n \n     impl CounterMappingRegion {\n-        pub fn code_region(\n+        crate fn code_region(\n             counter: coverage_map::Counter,\n             file_id: u32,\n             start_line: u32,\n@@ -730,65 +703,6 @@ pub mod coverageinfo {\n                 kind: RegionKind::CodeRegion,\n             }\n         }\n-\n-        pub fn expansion_region(\n-            file_id: u32,\n-            expanded_file_id: u32,\n-            start_line: u32,\n-            start_col: u32,\n-            end_line: u32,\n-            end_col: u32,\n-        ) -> Self {\n-            Self {\n-                counter: coverage_map::Counter::zero(),\n-                file_id,\n-                expanded_file_id,\n-                start_line,\n-                start_col,\n-                end_line,\n-                end_col,\n-                kind: RegionKind::ExpansionRegion,\n-            }\n-        }\n-\n-        pub fn skipped_region(\n-            file_id: u32,\n-            start_line: u32,\n-            start_col: u32,\n-            end_line: u32,\n-            end_col: u32,\n-        ) -> Self {\n-            Self {\n-                counter: coverage_map::Counter::zero(),\n-                file_id,\n-                expanded_file_id: 0,\n-                start_line,\n-                start_col,\n-                end_line,\n-                end_col,\n-                kind: RegionKind::SkippedRegion,\n-            }\n-        }\n-\n-        pub fn gap_region(\n-            counter: coverage_map::Counter,\n-            file_id: u32,\n-            start_line: u32,\n-            start_col: u32,\n-            end_line: u32,\n-            end_col: u32,\n-        ) -> Self {\n-            Self {\n-                counter,\n-                file_id,\n-                expanded_file_id: 0,\n-                start_line,\n-                start_col,\n-                end_line,\n-                end_col: ((1 as u32) << 31) | end_col,\n-                kind: RegionKind::GapRegion,\n-            }\n-        }\n     }\n }\n "}, {"sha": "c17c28df872b316f5799cb546b60799f6ef0cabf", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -43,46 +43,6 @@ cfg_if! {\n         use std::ops::Add;\n         use std::panic::{resume_unwind, catch_unwind, AssertUnwindSafe};\n \n-        /// This is a single threaded variant of AtomicCell provided by crossbeam.\n-        /// Unlike `Atomic` this is intended for all `Copy` types,\n-        /// but it lacks the explicit ordering arguments.\n-        #[derive(Debug)]\n-        pub struct AtomicCell<T: Copy>(Cell<T>);\n-\n-        impl<T: Copy> AtomicCell<T> {\n-            #[inline]\n-            pub fn new(v: T) -> Self {\n-                AtomicCell(Cell::new(v))\n-            }\n-\n-            #[inline]\n-            pub fn get_mut(&mut self) -> &mut T {\n-                self.0.get_mut()\n-            }\n-        }\n-\n-        impl<T: Copy> AtomicCell<T> {\n-            #[inline]\n-            pub fn into_inner(self) -> T {\n-                self.0.into_inner()\n-            }\n-\n-            #[inline]\n-            pub fn load(&self) -> T {\n-                self.0.get()\n-            }\n-\n-            #[inline]\n-            pub fn store(&self, val: T) {\n-                self.0.set(val)\n-            }\n-\n-            #[inline]\n-            pub fn swap(&self, val: T) -> T {\n-                self.0.replace(val)\n-            }\n-        }\n-\n         /// This is a single threaded variant of `AtomicU64`, `AtomicUsize`, etc.\n         /// It differs from `AtomicCell` in that it has explicit ordering arguments\n         /// and is only intended for use with the native atomic types.\n@@ -99,11 +59,6 @@ cfg_if! {\n         }\n \n         impl<T: Copy> Atomic<T> {\n-            #[inline]\n-            pub fn into_inner(self) -> T {\n-                self.0.into_inner()\n-            }\n-\n             #[inline]\n             pub fn load(&self, _: Ordering) -> T {\n                 self.0.get()\n@@ -113,11 +68,6 @@ cfg_if! {\n             pub fn store(&self, val: T, _: Ordering) {\n                 self.0.set(val)\n             }\n-\n-            #[inline]\n-            pub fn swap(&self, val: T, _: Ordering) -> T {\n-                self.0.replace(val)\n-            }\n         }\n \n         impl<T: Copy + PartialEq> Atomic<T> {\n@@ -159,22 +109,6 @@ cfg_if! {\n             (oper_a(), oper_b())\n         }\n \n-        pub struct SerialScope;\n-\n-        impl SerialScope {\n-            pub fn spawn<F>(&self, f: F)\n-                where F: FnOnce(&SerialScope)\n-            {\n-                f(self)\n-            }\n-        }\n-\n-        pub fn scope<F, R>(f: F) -> R\n-            where F: FnOnce(&SerialScope) -> R\n-        {\n-            f(&SerialScope)\n-        }\n-\n         #[macro_export]\n         macro_rules! parallel {\n             ($($blocks:tt),*) => {\n@@ -246,12 +180,6 @@ cfg_if! {\n             pub fn new<F: FnMut(usize) -> T>(mut f: F) -> WorkerLocal<T> {\n                 WorkerLocal(OneThread::new(f(0)))\n             }\n-\n-            /// Returns the worker-local value for each thread\n-            #[inline]\n-            pub fn into_inner(self) -> Vec<T> {\n-                vec![OneThread::into_inner(self.0)]\n-            }\n         }\n \n         impl<T> Deref for WorkerLocal<T> {\n@@ -279,16 +207,6 @@ cfg_if! {\n                 self.0\n             }\n \n-            #[inline(always)]\n-            pub fn get_mut(&mut self) -> &mut T {\n-                &mut self.0\n-            }\n-\n-            #[inline(always)]\n-            pub fn lock(&self) -> &T {\n-                &self.0\n-            }\n-\n             #[inline(always)]\n             pub fn lock_mut(&mut self) -> &mut T {\n                 &mut self.0\n@@ -521,16 +439,6 @@ impl<T> RwLock<T> {\n         RwLock(InnerRwLock::new(inner))\n     }\n \n-    #[inline(always)]\n-    pub fn into_inner(self) -> T {\n-        self.0.into_inner()\n-    }\n-\n-    #[inline(always)]\n-    pub fn get_mut(&mut self) -> &mut T {\n-        self.0.get_mut()\n-    }\n-\n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n     pub fn read(&self) -> ReadGuard<'_, T> {\n@@ -547,11 +455,6 @@ impl<T> RwLock<T> {\n         }\n     }\n \n-    #[inline(always)]\n-    pub fn with_read_lock<F: FnOnce(&T) -> R, R>(&self, f: F) -> R {\n-        f(&*self.read())\n-    }\n-\n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n     pub fn try_write(&self) -> Result<WriteGuard<'_, T>, ()> {\n@@ -580,11 +483,6 @@ impl<T> RwLock<T> {\n         }\n     }\n \n-    #[inline(always)]\n-    pub fn with_write_lock<F: FnOnce(&mut T) -> R, R>(&self, f: F) -> R {\n-        f(&mut *self.write())\n-    }\n-\n     #[inline(always)]\n     pub fn borrow(&self) -> ReadGuard<'_, T> {\n         self.read()\n@@ -633,12 +531,6 @@ impl<T> OneThread<T> {\n             inner,\n         }\n     }\n-\n-    #[inline(always)]\n-    pub fn into_inner(value: Self) -> T {\n-        value.check();\n-        value.inner\n-    }\n }\n \n impl<T> Deref for OneThread<T> {"}, {"sha": "d44ccd368b3cbb507c630fca26432c7a7da39da2", "filename": "compiler/rustc_data_structures/src/tagged_ptr/drop.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -42,18 +42,9 @@ where\n     pub fn pointer_ref(&self) -> &P::Target {\n         self.raw.pointer_ref()\n     }\n-    pub fn pointer_mut(&mut self) -> &mut P::Target\n-    where\n-        P: std::ops::DerefMut,\n-    {\n-        self.raw.pointer_mut()\n-    }\n     pub fn tag(&self) -> T {\n         self.raw.tag()\n     }\n-    pub fn set_tag(&mut self, tag: T) {\n-        self.raw.set_tag(tag);\n-    }\n }\n \n impl<P, T, const COMPARE_PACKED: bool> std::ops::Deref for TaggedPtr<P, T, COMPARE_PACKED>"}, {"sha": "10317f1afff673e3db6f0355fcc26591205c2dde", "filename": "compiler/rustc_data_structures/src/work_queue.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -41,10 +41,4 @@ impl<T: Idx> WorkQueue<T> {\n             None\n         }\n     }\n-\n-    /// Returns `true` if nothing is enqueued.\n-    #[inline]\n-    pub fn is_empty(&self) -> bool {\n-        self.deque.is_empty()\n-    }\n }"}, {"sha": "2a61fb5477203a5f30b07796628d43529f5fb3de", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -146,6 +146,7 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n     pub fn new(at_args: &'a [String], callbacks: &'b mut (dyn Callbacks + Send)) -> Self {\n         Self { at_args, callbacks, file_loader: None, emitter: None, make_codegen_backend: None }\n     }\n+    /// Used by cg_clif.\n     pub fn set_make_codegen_backend(\n         &mut self,\n         make_codegen_backend: Option<\n@@ -155,10 +156,13 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n         self.make_codegen_backend = make_codegen_backend;\n         self\n     }\n-    pub fn set_emitter(&mut self, emitter: Option<Box<dyn Write + Send>>) -> &mut Self {\n-        self.emitter = emitter;\n-        self\n+    /// Used by RLS.\n+    pub fn set_emitter(&mut self, emitter: Option<Box<dyn Write + Send>>) -> &mut Self\n+    {\n+           self.emitter = emitter;\n+           self\n     }\n+    /// Used by RLS.\n     pub fn set_file_loader(\n         &mut self,\n         file_loader: Option<Box<dyn FileLoader + Send + Sync>>,"}, {"sha": "e0c140b143be89326b7f743ecfd5a1413ae5cc35", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -108,13 +108,6 @@ trait HirPrinterSupport<'hir>: pprust_hir::PpAnn {\n     /// (Rust does not yet support upcasting from a trait object to\n     /// an object for one of its super-traits.)\n     fn pp_ann(&self) -> &dyn pprust_hir::PpAnn;\n-\n-    /// Computes an user-readable representation of a path, if possible.\n-    fn node_path(&self, id: hir::HirId) -> Option<String> {\n-        self.hir_map().and_then(|map| map.def_path_from_hir_id(id)).map(|path| {\n-            path.data.into_iter().map(|elem| elem.data.to_string()).collect::<Vec<_>>().join(\"::\")\n-        })\n-    }\n }\n \n struct NoAnn<'hir> {\n@@ -327,10 +320,6 @@ impl<'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n     fn pp_ann(&self) -> &dyn pprust_hir::PpAnn {\n         self\n     }\n-\n-    fn node_path(&self, id: hir::HirId) -> Option<String> {\n-        Some(self.tcx.def_path_str(self.tcx.hir().local_def_id(id).to_def_id()))\n-    }\n }\n \n impl<'tcx> pprust_hir::PpAnn for TypedAnnotation<'tcx> {"}, {"sha": "b2f6a0c10142df0645e35d21f3b6ad9e3a18d5b5", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 8, "deletions": 50, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -69,10 +69,6 @@ impl DiagnosticStyledString {\n     pub fn highlighted<S: Into<String>>(t: S) -> DiagnosticStyledString {\n         DiagnosticStyledString(vec![StringPart::Highlighted(t.into())])\n     }\n-\n-    pub fn content(&self) -> String {\n-        self.0.iter().map(|x| x.content()).collect::<String>()\n-    }\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -81,14 +77,6 @@ pub enum StringPart {\n     Highlighted(String),\n }\n \n-impl StringPart {\n-    pub fn content(&self) -> &str {\n-        match self {\n-            &StringPart::Normal(ref s) | &StringPart::Highlighted(ref s) => s,\n-        }\n-    }\n-}\n-\n impl Diagnostic {\n     pub fn new(level: Level, message: &str) -> Self {\n         Diagnostic::new_with_code(level, None, message)\n@@ -156,7 +144,7 @@ impl Diagnostic {\n         self\n     }\n \n-    pub fn note_expected_found(\n+    crate fn note_expected_found(\n         &mut self,\n         expected_label: &dyn fmt::Display,\n         expected: DiagnosticStyledString,\n@@ -166,7 +154,7 @@ impl Diagnostic {\n         self.note_expected_found_extra(expected_label, expected, found_label, found, &\"\", &\"\")\n     }\n \n-    pub fn note_unsuccessful_coercion(\n+    crate fn note_unsuccessful_coercion(\n         &mut self,\n         expected: DiagnosticStyledString,\n         found: DiagnosticStyledString,\n@@ -256,33 +244,33 @@ impl Diagnostic {\n \n     /// Prints the span with a note above it.\n     /// This is like [`Diagnostic::note()`], but it gets its own span.\n-    pub fn span_note<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    crate fn span_note<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Note, msg, sp.into(), None);\n         self\n     }\n \n     /// Add a warning attached to this diagnostic.\n-    pub fn warn(&mut self, msg: &str) -> &mut Self {\n+    crate fn warn(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Warning, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with a warning above it.\n     /// This is like [`Diagnostic::warn()`], but it gets its own span.\n-    pub fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    crate fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Warning, msg, sp.into(), None);\n         self\n     }\n \n     /// Add a help message attached to this diagnostic.\n-    pub fn help(&mut self, msg: &str) -> &mut Self {\n+    crate fn help(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Help, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with some help above it.\n     /// This is like [`Diagnostic::help()`], but it gets its own span.\n-    pub fn span_help<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    crate fn span_help<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Help, msg, sp.into(), None);\n         self\n     }\n@@ -311,36 +299,6 @@ impl Diagnostic {\n         self\n     }\n \n-    /// Show multiple suggestions that have multiple parts.\n-    /// See also [`Diagnostic::multipart_suggestion()`].\n-    pub fn multipart_suggestions(\n-        &mut self,\n-        msg: &str,\n-        suggestions: Vec<Vec<(Span, String)>>,\n-        applicability: Applicability,\n-    ) -> &mut Self {\n-        assert!(!suggestions.is_empty());\n-        for s in &suggestions {\n-            assert!(!s.is_empty());\n-        }\n-        self.suggestions.push(CodeSuggestion {\n-            substitutions: suggestions\n-                .into_iter()\n-                .map(|suggestion| Substitution {\n-                    parts: suggestion\n-                        .into_iter()\n-                        .map(|(span, snippet)| SubstitutionPart { snippet, span })\n-                        .collect(),\n-                })\n-                .collect(),\n-            msg: msg.to_owned(),\n-            style: SuggestionStyle::ShowCode,\n-            applicability,\n-            tool_metadata: Default::default(),\n-        });\n-        self\n-    }\n-\n     /// Prints out a message with for a multipart suggestion without showing the suggested code.\n     ///\n     /// This is intended to be used for suggestions that are obvious in what the changes need to\n@@ -567,7 +525,7 @@ impl Diagnostic {\n         self.code.clone()\n     }\n \n-    pub fn set_primary_message<M: Into<String>>(&mut self, msg: M) -> &mut Self {\n+    crate fn set_primary_message<M: Into<String>>(&mut self, msg: M) -> &mut Self {\n         self.message[0] = (msg.into(), Style::NoStyle);\n         self\n     }"}, {"sha": "282877d5dd10962f9c7be3e66e0e96189d9529fc", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -257,20 +257,6 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n-    /// See [`Diagnostic::multipart_suggestions()`].\n-    pub fn multipart_suggestions(\n-        &mut self,\n-        msg: &str,\n-        suggestions: Vec<Vec<(Span, String)>>,\n-        applicability: Applicability,\n-    ) -> &mut Self {\n-        if !self.0.allow_suggestions {\n-            return self;\n-        }\n-        self.0.diagnostic.multipart_suggestions(msg, suggestions, applicability);\n-        self\n-    }\n-\n     /// See [`Diagnostic::tool_only_multipart_suggestion()`].\n     pub fn tool_only_multipart_suggestion(\n         &mut self,"}, {"sha": "ac7353730ad6c94fb027486c84c8b5e40d030cb0", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -691,10 +691,6 @@ impl Handler {\n         db\n     }\n \n-    pub fn failure(&self, msg: &str) {\n-        self.inner.borrow_mut().failure(msg);\n-    }\n-\n     pub fn fatal(&self, msg: &str) -> FatalError {\n         self.inner.borrow_mut().fatal(msg)\n     }"}, {"sha": "da764d993bbdb2ad7996a963677f2e696d16f771", "filename": "compiler/rustc_errors/src/registry.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fregistry.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -13,10 +13,6 @@ impl Registry {\n         Registry { long_descriptions: long_descriptions.iter().copied().collect() }\n     }\n \n-    /// This will panic if an invalid error code is passed in\n-    pub fn find_description(&self, code: &str) -> Option<&'static str> {\n-        self.long_descriptions[code]\n-    }\n     /// Returns `InvalidErrorCode` if the code requested does not exist in the\n     /// registry. Otherwise, returns an `Option` where `None` means the error\n     /// code is valid but has no extended information."}, {"sha": "3fe02bd0ceecf22bba43524631b7a32fa617eeb2", "filename": "compiler/rustc_errors/src/snippet.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -121,16 +121,6 @@ impl Annotation {\n         matches!(self.annotation_type, AnnotationType::MultilineLine(_))\n     }\n \n-    pub fn is_multiline(&self) -> bool {\n-        matches!(\n-            self.annotation_type,\n-            AnnotationType::Multiline(_)\n-                | AnnotationType::MultilineStart(_)\n-                | AnnotationType::MultilineLine(_)\n-                | AnnotationType::MultilineEnd(_)\n-        )\n-    }\n-\n     pub fn len(&self) -> usize {\n         // Account for usize underflows\n         if self.end_col > self.start_col {"}, {"sha": "cb8b9398283ef963b2cc68acd2f76b27d17887bc", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -253,17 +253,6 @@ impl<'a> ExtCtxt<'a> {\n         let pathexpr = self.expr_path(self.path_global(sp, fn_path));\n         self.expr_call(sp, pathexpr, args)\n     }\n-    pub fn expr_method_call(\n-        &self,\n-        span: Span,\n-        expr: P<ast::Expr>,\n-        ident: Ident,\n-        mut args: Vec<P<ast::Expr>>,\n-    ) -> P<ast::Expr> {\n-        args.insert(0, expr);\n-        let segment = ast::PathSegment::from_ident(ident.with_span_pos(span));\n-        self.expr(span, ast::ExprKind::MethodCall(segment, args, span))\n-    }\n     pub fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {\n         self.expr(b.span, ast::ExprKind::Block(b, None))\n     }"}, {"sha": "8b546e7e4a343a1bb39fe177457bd85459ca8fd6", "filename": "compiler/rustc_expand/src/tokenstream/tests.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -1,7 +1,7 @@\n use crate::tests::string_to_stream;\n \n use rustc_ast::token;\n-use rustc_ast::tokenstream::{TokenStream, TokenStreamBuilder, TokenTree};\n+use rustc_ast::tokenstream::{Spacing, TokenStream, TokenStreamBuilder, TokenTree};\n use rustc_span::with_default_session_globals;\n use rustc_span::{BytePos, Span, Symbol};\n use smallvec::smallvec;\n@@ -14,6 +14,10 @@ fn sp(a: u32, b: u32) -> Span {\n     Span::with_root_ctxt(BytePos(a), BytePos(b))\n }\n \n+fn joint(tree: TokenTree) -> TokenStream {\n+    TokenStream::new(vec![(tree, Spacing::Joint)])\n+}\n+\n #[test]\n fn test_concat() {\n     with_default_session_globals(|| {\n@@ -99,8 +103,8 @@ fn test_is_empty() {\n fn test_dotdotdot() {\n     with_default_session_globals(|| {\n         let mut builder = TokenStreamBuilder::new();\n-        builder.push(TokenTree::token(token::Dot, sp(0, 1)).joint());\n-        builder.push(TokenTree::token(token::Dot, sp(1, 2)).joint());\n+        builder.push(joint(TokenTree::token(token::Dot, sp(0, 1))));\n+        builder.push(joint(TokenTree::token(token::Dot, sp(1, 2))));\n         builder.push(TokenTree::token(token::Dot, sp(2, 3)));\n         let stream = builder.build();\n         assert!(stream.eq_unspanned(&string_to_ts(\"...\")));"}, {"sha": "db70beb59141b52682b0bbe9b3caa154472768bb", "filename": "compiler/rustc_graphviz/src/lib.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Flib.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -413,10 +413,6 @@ impl<'a> Id<'a> {\n     pub fn as_slice(&'a self) -> &'a str {\n         &*self.name\n     }\n-\n-    pub fn name(self) -> Cow<'a, str> {\n-        self.name\n-    }\n }\n \n /// Each instance of a type that implements `Label<C>` maps to a\n@@ -484,10 +480,6 @@ impl<'a> LabelText<'a> {\n         LabelStr(s.into())\n     }\n \n-    pub fn escaped<S: Into<Cow<'a, str>>>(s: S) -> LabelText<'a> {\n-        EscStr(s.into())\n-    }\n-\n     pub fn html<S: Into<Cow<'a, str>>>(s: S) -> LabelText<'a> {\n         HtmlStr(s.into())\n     }\n@@ -543,11 +535,6 @@ impl<'a> LabelText<'a> {\n         }\n     }\n \n-    /// Puts `prefix` on a line above this label, with a blank line separator.\n-    pub fn prefix_line(self, prefix: LabelText<'_>) -> LabelText<'static> {\n-        prefix.suffix_line(self)\n-    }\n-\n     /// Puts `suffix` on a line below this label, with a blank line separator.\n     pub fn suffix_line(self, suffix: LabelText<'_>) -> LabelText<'static> {\n         let mut prefix = self.pre_escaped_content().into_owned();\n@@ -602,11 +589,6 @@ pub enum RenderOption {\n     DarkTheme,\n }\n \n-/// Returns vec holding all the default render options.\n-pub fn default_options() -> Vec<RenderOption> {\n-    vec![]\n-}\n-\n /// Renders directed graph `g` into the writer `w` in DOT syntax.\n /// (Simple wrapper around `render_opts` that passes a default set of options.)\n pub fn render<'a, N, E, G, W>(g: &'a G, w: &mut W) -> io::Result<()>"}, {"sha": "a297bac86c410406c116d5679130ff033a3df6b1", "filename": "compiler/rustc_graphviz/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_graphviz%2Fsrc%2Ftests.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -111,7 +111,7 @@ impl<'a> Labeller<'a> for LabelledGraph {\n     fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n         match self.node_labels[*n] {\n             Some(l) => LabelStr(l.into()),\n-            None => LabelStr(id_name(n).name()),\n+            None => LabelStr(id_name(n).name),\n         }\n     }\n     fn edge_label(&'a self, e: &&'a Edge) -> LabelText<'a> {"}, {"sha": "0f77de9fb250fed5d7764b0404e8ce07f9d9d68f", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -87,6 +87,7 @@ impl DefPathTable {\n         hash\n     }\n \n+    /// Used by librustdoc for fake DefIds.\n     pub fn num_def_ids(&self) -> usize {\n         self.index_to_key.len()\n     }\n@@ -319,12 +320,6 @@ impl Definitions {\n         self.table.def_path_hash(id.local_def_index)\n     }\n \n-    #[inline]\n-    pub fn def_path_hash_to_def_id(&self, def_path_hash: DefPathHash) -> LocalDefId {\n-        let local_def_index = self.table.def_path_hash_to_index[&def_path_hash];\n-        LocalDefId { local_def_index }\n-    }\n-\n     /// Returns the path from the crate root to `index`. The root\n     /// nodes are not included in the path (i.e., this will be an\n     /// empty vector for the crate root). For an inlined item, this"}, {"sha": "aaf15c60f1e0ef1b33f6d6216d27433456240207", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -1,5 +1,5 @@\n // ignore-tidy-filelength\n-use crate::def::{CtorKind, DefKind, Namespace, Res};\n+use crate::def::{CtorKind, DefKind, Res};\n use crate::def_id::DefId;\n crate use crate::hir_id::HirId;\n use crate::{itemlikevisit, LangItem};\n@@ -2118,15 +2118,6 @@ pub enum ImplItemKind<'hir> {\n     TyAlias(&'hir Ty<'hir>),\n }\n \n-impl ImplItemKind<'_> {\n-    pub fn namespace(&self) -> Namespace {\n-        match self {\n-            ImplItemKind::TyAlias(..) => Namespace::TypeNS,\n-            ImplItemKind::Const(..) | ImplItemKind::Fn(..) => Namespace::ValueNS,\n-        }\n-    }\n-}\n-\n // The name of the associated type for `Fn` return types.\n pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n \n@@ -2215,6 +2206,9 @@ impl PrimTy {\n         Self::Str,\n     ];\n \n+    /// [`PrimTy::name`], but returns a &str instead of a symbol.\n+    ///\n+    /// Used by rustdoc.\n     pub fn name_str(self) -> &'static str {\n         match self {\n             PrimTy::Int(i) => i.name_str(),"}, {"sha": "e24eb5e449002e3133bfa1c2cde40cda1b3ce6b8", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -1,5 +1,4 @@\n use crate::def_id::{LocalDefId, CRATE_DEF_INDEX};\n-use rustc_index::vec::IndexVec;\n use std::fmt;\n \n /// Uniquely identifies a node in the HIR of the current crate. It is\n@@ -62,69 +61,3 @@ pub const CRATE_HIR_ID: HirId = HirId {\n     owner: LocalDefId { local_def_index: CRATE_DEF_INDEX },\n     local_id: ItemLocalId::from_u32(0),\n };\n-\n-#[derive(Clone, Default, Debug, Encodable, Decodable)]\n-pub struct HirIdVec<T> {\n-    map: IndexVec<LocalDefId, IndexVec<ItemLocalId, T>>,\n-}\n-\n-impl<T> HirIdVec<T> {\n-    pub fn push_owner(&mut self, id: LocalDefId) {\n-        self.map.ensure_contains_elem(id, IndexVec::new);\n-    }\n-\n-    pub fn push(&mut self, id: HirId, value: T) {\n-        if id.local_id == ItemLocalId::from_u32(0) {\n-            self.push_owner(id.owner);\n-        }\n-        let submap = &mut self.map[id.owner];\n-        let _ret_id = submap.push(value);\n-        debug_assert_eq!(_ret_id, id.local_id);\n-    }\n-\n-    pub fn push_sparse(&mut self, id: HirId, value: T)\n-    where\n-        T: Default,\n-    {\n-        self.map.ensure_contains_elem(id.owner, IndexVec::new);\n-        let submap = &mut self.map[id.owner];\n-        let i = id.local_id.index();\n-        let len = submap.len();\n-        if i >= len {\n-            submap.extend(std::iter::repeat_with(T::default).take(i - len + 1));\n-        }\n-        submap[id.local_id] = value;\n-    }\n-\n-    pub fn get(&self, id: HirId) -> Option<&T> {\n-        self.map.get(id.owner)?.get(id.local_id)\n-    }\n-\n-    pub fn get_owner(&self, id: LocalDefId) -> &IndexVec<ItemLocalId, T> {\n-        &self.map[id]\n-    }\n-\n-    pub fn iter(&self) -> impl Iterator<Item = &T> {\n-        self.map.iter().flat_map(|la| la.iter())\n-    }\n-\n-    pub fn iter_enumerated(&self) -> impl Iterator<Item = (HirId, &T)> {\n-        self.map.iter_enumerated().flat_map(|(owner, la)| {\n-            la.iter_enumerated().map(move |(local_id, attr)| (HirId { owner, local_id }, attr))\n-        })\n-    }\n-}\n-\n-impl<T> std::ops::Index<HirId> for HirIdVec<T> {\n-    type Output = T;\n-\n-    fn index(&self, id: HirId) -> &T {\n-        &self.map[id.owner][id.local_id]\n-    }\n-}\n-\n-impl<T> std::ops::IndexMut<HirId> for HirIdVec<T> {\n-    fn index_mut(&mut self, id: HirId) -> &mut T {\n-        &mut self.map[id.owner][id.local_id]\n-    }\n-}"}, {"sha": "28529affd5d5ab02b1698747ab76f91554f7790b", "filename": "compiler/rustc_hir/src/pat_util.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fpat_util.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -89,26 +89,6 @@ impl hir::Pat<'_> {\n         })\n     }\n \n-    /// Checks if the pattern contains any patterns that bind something to\n-    /// an ident, e.g., `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-    pub fn contains_bindings(&self) -> bool {\n-        self.satisfies(|p| matches!(p.kind, PatKind::Binding(..)))\n-    }\n-\n-    /// Checks if the pattern satisfies the given predicate on some sub-pattern.\n-    fn satisfies(&self, pred: impl Fn(&hir::Pat<'_>) -> bool) -> bool {\n-        let mut satisfies = false;\n-        self.walk_short(|p| {\n-            if pred(p) {\n-                satisfies = true;\n-                false // Found one, can short circuit now.\n-            } else {\n-                true\n-            }\n-        });\n-        satisfies\n-    }\n-\n     pub fn simple_ident(&self) -> Option<Ident> {\n         match self.kind {\n             PatKind::Binding("}, {"sha": "89d56ed317402aa822591428be1f2306397ee159", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -221,10 +221,6 @@ pub fn bounds_to_string<'b>(bounds: impl IntoIterator<Item = &'b hir::GenericBou\n     to_string(NO_ANN, |s| s.print_bounds(\"\", bounds))\n }\n \n-pub fn param_to_string(arg: &hir::Param<'_>) -> String {\n-    to_string(NO_ANN, |s| s.print_param(arg))\n-}\n-\n pub fn ty_to_string(ty: &hir::Ty<'_>) -> String {\n     to_string(NO_ANN, |s| s.print_type(ty))\n }\n@@ -1701,21 +1697,10 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_usize(&mut self, i: usize) {\n-        self.s.word(i.to_string())\n-    }\n-\n     pub fn print_name(&mut self, name: Symbol) {\n         self.print_ident(Ident::with_dummy_span(name))\n     }\n \n-    pub fn print_for_decl(&mut self, loc: &hir::Local<'_>, coll: &hir::Expr<'_>) {\n-        self.print_local_decl(loc);\n-        self.s.space();\n-        self.word_space(\"in\");\n-        self.print_expr(coll)\n-    }\n-\n     pub fn print_path(&mut self, path: &hir::Path<'_>, colons_before_params: bool) {\n         self.maybe_print_comment(path.span.lo());\n \n@@ -2430,24 +2415,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_opt_abi_and_extern_if_nondefault(&mut self, opt_abi: Option<Abi>) {\n-        match opt_abi {\n-            Some(Abi::Rust) => {}\n-            Some(abi) => {\n-                self.word_nbsp(\"extern\");\n-                self.word_nbsp(abi.to_string())\n-            }\n-            None => {}\n-        }\n-    }\n-\n-    pub fn print_extern_opt_abi(&mut self, opt_abi: Option<Abi>) {\n-        if let Some(abi) = opt_abi {\n-            self.word_nbsp(\"extern\");\n-            self.word_nbsp(abi.to_string())\n-        }\n-    }\n-\n     pub fn print_fn_header_info(&mut self, header: hir::FnHeader, vis: &hir::Visibility<'_>) {\n         self.s.word(visibility_qualified(vis, \"\"));\n "}, {"sha": "91b7221f2055284814fe7d0d195bc2d0e9738e71", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -74,16 +74,6 @@ const BASE_STRUCT: &[&str] =\n     &[label_strs::generics_of, label_strs::predicates_of, label_strs::type_of];\n \n /// Trait definition `DepNode`s.\n-const BASE_TRAIT_DEF: &[&str] = &[\n-    label_strs::associated_item_def_ids,\n-    label_strs::generics_of,\n-    label_strs::object_safety_violations,\n-    label_strs::predicates_of,\n-    label_strs::specialization_graph_of,\n-    label_strs::trait_def,\n-    label_strs::trait_impls_of,\n-];\n-\n /// Extra `DepNode`s for functions and methods.\n const EXTRA_ASSOCIATED: &[&str] = &[label_strs::associated_item];\n \n@@ -118,10 +108,6 @@ const LABELS_IMPL: &[&[&str]] = &[BASE_HIR, BASE_IMPL];\n /// Abstract data type (struct, enum, union) `DepNode`s.\n const LABELS_ADT: &[&[&str]] = &[BASE_HIR, BASE_STRUCT];\n \n-/// Trait definition `DepNode`s.\n-#[allow(dead_code)]\n-const LABELS_TRAIT: &[&[&str]] = &[BASE_HIR, BASE_TRAIT_DEF];\n-\n // FIXME: Struct/Enum/Unions Fields (there is currently no way to attach these)\n //\n // Fields are kind of separate from their containers, as they can change independently from"}, {"sha": "9fb045e8e400b81adc0e955335692f9e7da9a564", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -1266,15 +1266,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.resolve_vars_if_possible(t).to_string()\n     }\n \n-    pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n-        let tstrs: Vec<String> = ts.iter().map(|t| self.ty_to_string(*t)).collect();\n-        format!(\"({})\", tstrs.join(\", \"))\n-    }\n-\n-    pub fn trait_ref_to_string(&self, t: ty::TraitRef<'tcx>) -> String {\n-        self.resolve_vars_if_possible(t).print_only_trait_path().to_string()\n-    }\n-\n     /// If `TyVar(vid)` resolves to a type, return that type. Else, return the\n     /// universe index of `TyVar(vid)`.\n     pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'tcx>, ty::UniverseIndex> {\n@@ -1704,14 +1695,6 @@ impl<'tcx> TypeTrace<'tcx> {\n     ) -> TypeTrace<'tcx> {\n         TypeTrace { cause: cause.clone(), values: Consts(ExpectedFound::new(a_is_expected, a, b)) }\n     }\n-\n-    pub fn dummy(tcx: TyCtxt<'tcx>) -> TypeTrace<'tcx> {\n-        let err = tcx.ty_error();\n-        TypeTrace {\n-            cause: ObligationCause::dummy(),\n-            values: Types(ExpectedFound { expected: err, found: err }),\n-        }\n-    }\n }\n \n impl<'tcx> SubregionOrigin<'tcx> {"}, {"sha": "9e04773c5fa2056c9bb4865d9051e938b5a0f86b", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -92,11 +92,6 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n         &self.region_bound_pairs_map\n     }\n \n-    /// Returns ownership of the `free_region_map`.\n-    pub fn into_free_region_map(self) -> FreeRegionMap<'tcx> {\n-        self.free_region_map\n-    }\n-\n     /// This is a hack to support the old-skool regionck, which\n     /// processes region constraints from the main function and the\n     /// closure together. In that context, when we enter a closure, we"}, {"sha": "3e2978fd170aea36526f911f1faa6486dc38a1cf", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -186,28 +186,6 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n             }\n         }\n     }\n-\n-    /// Processes a single ad-hoc region obligation that was not\n-    /// registered in advance.\n-    pub fn type_must_outlive(\n-        &self,\n-        region_bound_pairs: &RegionBoundPairs<'tcx>,\n-        implicit_region_bound: Option<ty::Region<'tcx>>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        origin: infer::SubregionOrigin<'tcx>,\n-        ty: Ty<'tcx>,\n-        region: ty::Region<'tcx>,\n-    ) {\n-        let outlives = &mut TypeOutlives::new(\n-            self,\n-            self.tcx,\n-            region_bound_pairs,\n-            implicit_region_bound,\n-            param_env,\n-        );\n-        let ty = self.resolve_vars_if_possible(ty);\n-        outlives.type_must_outlive(origin, ty, region);\n-    }\n }\n \n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`"}, {"sha": "9ffcddfae99443d1bfc75dbf84b07edef719c48c", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -309,31 +309,6 @@ pub struct RegionSnapshot {\n     any_unifications: bool,\n }\n \n-/// When working with placeholder regions, we often wish to find all of\n-/// the regions that are either reachable from a placeholder region, or\n-/// which can reach a placeholder region, or both. We call such regions\n-/// *tainted* regions. This struct allows you to decide what set of\n-/// tainted regions you want.\n-#[derive(Debug)]\n-pub struct TaintDirections {\n-    incoming: bool,\n-    outgoing: bool,\n-}\n-\n-impl TaintDirections {\n-    pub fn incoming() -> Self {\n-        TaintDirections { incoming: true, outgoing: false }\n-    }\n-\n-    pub fn outgoing() -> Self {\n-        TaintDirections { incoming: false, outgoing: true }\n-    }\n-\n-    pub fn both() -> Self {\n-        TaintDirections { incoming: true, outgoing: true }\n-    }\n-}\n-\n impl<'tcx> RegionConstraintStorage<'tcx> {\n     pub fn new() -> Self {\n         Self::default()\n@@ -472,11 +447,6 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         self.var_infos[vid].universe\n     }\n \n-    /// Returns the origin for the given variable.\n-    pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n-        self.var_infos[vid].origin\n-    }\n-\n     fn add_constraint(&mut self, constraint: Constraint<'tcx>, origin: SubregionOrigin<'tcx>) {\n         // cannot add constraints once regions are resolved\n         debug!(\"RegionConstraintCollector: add_constraint({:?})\", constraint);\n@@ -795,16 +765,6 @@ impl<'tcx> VerifyBound<'tcx> {\n             VerifyBound::AnyBound(vec![self, vb])\n         }\n     }\n-\n-    pub fn and(self, vb: VerifyBound<'tcx>) -> VerifyBound<'tcx> {\n-        if self.must_hold() && vb.must_hold() {\n-            self\n-        } else if self.cannot_hold() && vb.cannot_hold() {\n-            self\n-        } else {\n-            VerifyBound::AllBounds(vec![self, vb])\n-        }\n-    }\n }\n \n impl<'tcx> RegionConstraintData<'tcx> {"}, {"sha": "49fb2d7993ca0baa425750da38bf48d29eb1b374", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -146,9 +146,7 @@ impl<'tcx> TypeVariableValue<'tcx> {\n     }\n }\n \n-pub(crate) struct Instantiate {\n-    vid: ty::TyVid,\n-}\n+pub(crate) struct Instantiate {}\n \n pub(crate) struct Delegate;\n \n@@ -224,7 +222,7 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n         // Hack: we only need this so that `types_escaping_snapshot`\n         // can see what has been unified; see the Delegate impl for\n         // more details.\n-        self.undo_log.push(Instantiate { vid });\n+        self.undo_log.push(Instantiate {});\n     }\n \n     /// Creates a new type variable.\n@@ -346,56 +344,6 @@ impl<'tcx> TypeVariableTable<'_, 'tcx> {\n         )\n     }\n \n-    /// Finds the set of type variables that existed *before* `s`\n-    /// but which have only been unified since `s` started, and\n-    /// return the types with which they were unified. So if we had\n-    /// a type variable `V0`, then we started the snapshot, then we\n-    /// created a type variable `V1`, unified `V0` with `T0`, and\n-    /// unified `V1` with `T1`, this function would return `{T0}`.\n-    pub fn types_escaping_snapshot(&mut self, s: &super::Snapshot<'tcx>) -> Vec<Ty<'tcx>> {\n-        let mut new_elem_threshold = u32::MAX;\n-        let mut escaping_types = Vec::new();\n-        let actions_since_snapshot = self.undo_log.actions_since_snapshot(s);\n-        debug!(\"actions_since_snapshot.len() = {}\", actions_since_snapshot.len());\n-        for i in 0..actions_since_snapshot.len() {\n-            let actions_since_snapshot = self.undo_log.actions_since_snapshot(s);\n-            match actions_since_snapshot[i] {\n-                super::UndoLog::TypeVariables(UndoLog::Values(sv::UndoLog::NewElem(index))) => {\n-                    // if any new variables were created during the\n-                    // snapshot, remember the lower index (which will\n-                    // always be the first one we see). Note that this\n-                    // action must precede those variables being\n-                    // specified.\n-                    new_elem_threshold = cmp::min(new_elem_threshold, index as u32);\n-                    debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n-                }\n-\n-                super::UndoLog::TypeVariables(UndoLog::Values(sv::UndoLog::Other(\n-                    Instantiate { vid, .. },\n-                ))) => {\n-                    if vid.index < new_elem_threshold {\n-                        // quick check to see if this variable was\n-                        // created since the snapshot started or not.\n-                        let mut eq_relations = ut::UnificationTable::with_log(\n-                            &mut self.storage.eq_relations,\n-                            &mut *self.undo_log,\n-                        );\n-                        let escaping_type = match eq_relations.probe_value(vid) {\n-                            TypeVariableValue::Unknown { .. } => bug!(),\n-                            TypeVariableValue::Known { value } => value,\n-                        };\n-                        escaping_types.push(escaping_type);\n-                    }\n-                    debug!(\"SpecifyVar({:?}) new_elem_threshold={}\", vid, new_elem_threshold);\n-                }\n-\n-                _ => {}\n-            }\n-        }\n-\n-        escaping_types\n-    }\n-\n     /// Returns indices of all variables that are not yet\n     /// instantiated.\n     pub fn unsolved_variables(&mut self) -> Vec<ty::TyVid> {"}, {"sha": "f41e872e00488aef6c9469b8b124107c27bd4781", "filename": "compiler/rustc_infer/src/infer/undo_log.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -165,10 +165,6 @@ impl<'tcx> InferCtxtInner<'tcx> {\n }\n \n impl<'tcx> InferCtxtUndoLogs<'tcx> {\n-    pub fn actions_since_snapshot(&self, snapshot: &Snapshot<'tcx>) -> &[UndoLog<'tcx>] {\n-        &self.logs[snapshot.undo_len..]\n-    }\n-\n     pub fn start_snapshot(&mut self) -> Snapshot<'tcx> {\n         self.num_open_snapshots += 1;\n         Snapshot { undo_len: self.logs.len(), _marker: PhantomData }"}, {"sha": "218248e715b4b492f0b62a5dc06f72eeee9f97fe", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -481,7 +481,7 @@ fn has_doc(sess: &Session, attr: &ast::Attribute) -> bool {\n         return false;\n     }\n \n-    if attr.is_value_str() {\n+    if attr.value_str().is_some() {\n         return true;\n     }\n "}, {"sha": "e4403f879ffcd4bf6651be0eb5b4f4f324a3e540", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -177,6 +177,7 @@ impl LintStore {\n         self.early_passes.push(Box::new(pass));\n     }\n \n+    /// Used by clippy.\n     pub fn register_pre_expansion_pass(\n         &mut self,\n         pass: impl Fn() -> EarlyLintPassObject + 'static + sync::Send + sync::Sync,\n@@ -862,6 +863,8 @@ impl<'tcx> LateContext<'tcx> {\n     ///     // The given `def_id` is that of an `Option` type\n     /// }\n     /// ```\n+    ///\n+    /// Used by clippy, but should be replaced by diagnostic items eventually.\n     pub fn match_def_path(&self, def_id: DefId, path: &[Symbol]) -> bool {\n         let names = self.get_def_path(def_id);\n "}, {"sha": "863023fa7b54d25e01f099df0d0711affcb7cd8f", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -564,10 +564,6 @@ impl<'s> LintLevelsBuilder<'s> {\n         self.id_to_set.insert(id, self.cur);\n     }\n \n-    pub fn build(self) -> LintLevelSets {\n-        self.sets\n-    }\n-\n     pub fn build_map(self) -> LintLevelMap {\n         LintLevelMap { sets: self.sets, id_to_set: self.id_to_set }\n     }"}, {"sha": "9e763befe2912b9bfaaba7476a3b21cdd4346e14", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -550,24 +550,6 @@ impl<'hir> Map<'hir> {\n         ParentHirIterator { current_id, map: self }\n     }\n \n-    /// Checks if the node is an argument. An argument is a local variable whose\n-    /// immediate parent is an item or a closure.\n-    pub fn is_argument(&self, id: HirId) -> bool {\n-        match self.find(id) {\n-            Some(Node::Binding(_)) => (),\n-            _ => return false,\n-        }\n-        matches!(\n-            self.find(self.get_parent_node(id)),\n-            Some(\n-                Node::Item(_)\n-                    | Node::TraitItem(_)\n-                    | Node::ImplItem(_)\n-                    | Node::Expr(Expr { kind: ExprKind::Closure(..), .. }),\n-            )\n-        )\n-    }\n-\n     /// Checks if the node is left-hand side of an assignment.\n     pub fn is_lhs(&self, id: HirId) -> bool {\n         match self.find(self.get_parent_node(id)) {\n@@ -779,17 +761,6 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn expect_variant_data(&self, id: HirId) -> &'hir VariantData<'hir> {\n-        match self.find(id) {\n-            Some(\n-                Node::Ctor(vd)\n-                | Node::Item(Item { kind: ItemKind::Struct(vd, _) | ItemKind::Union(vd, _), .. }),\n-            ) => vd,\n-            Some(Node::Variant(variant)) => &variant.data,\n-            _ => bug!(\"expected struct or variant, found {}\", self.node_to_string(id)),\n-        }\n-    }\n-\n     pub fn expect_variant(&self, id: HirId) -> &'hir Variant<'hir> {\n         match self.find(id) {\n             Some(Node::Variant(variant)) => variant,"}, {"sha": "b2fef731b7e2059f8bcde6c5d3db8053f71400d4", "filename": "compiler/rustc_middle/src/ich/hcx.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -119,11 +119,6 @@ impl<'a> StableHashingContext<'a> {\n         Self::new_with_or_without_spans(sess, krate, definitions, cstore, always_ignore_spans)\n     }\n \n-    #[inline]\n-    pub fn sess(&self) -> &'a Session {\n-        self.sess\n-    }\n-\n     #[inline]\n     pub fn while_hashing_hir_bodies<F: FnOnce(&mut Self)>(&mut self, hash_bodies: bool, f: F) {\n         let prev_hash_bodies = self.hash_bodies;"}, {"sha": "7ed4cbf034fe129b6b6f90433f6a5f002e4e1d10", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -228,20 +228,12 @@ impl Certainty {\n             Certainty::Ambiguous => false,\n         }\n     }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n }\n \n impl<'tcx, R> QueryResponse<'tcx, R> {\n     pub fn is_proven(&self) -> bool {\n         self.certainty.is_proven()\n     }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n }\n \n impl<'tcx, R> Canonical<'tcx, QueryResponse<'tcx, R>> {"}, {"sha": "641cf23781e2c7407a568b64aea61e1810ca8694", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -97,13 +97,6 @@ impl<'tcx> ConstVariableValue<'tcx> {\n             ConstVariableValue::Known { value } => Some(value),\n         }\n     }\n-\n-    pub fn is_unknown(&self) -> bool {\n-        match *self {\n-            ConstVariableValue::Unknown { .. } => true,\n-            ConstVariableValue::Known { .. } => false,\n-        }\n-    }\n }\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "5440e63543d40a83e9d8973fcb572f486a4ca3b6", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -430,6 +430,8 @@ impl ScopeTree {\n \n     /// Returns `true` if `subscope` is equal to or is lexically nested inside `superscope`, and\n     /// `false` otherwise.\n+    ///\n+    /// Used by clippy.\n     pub fn is_subscope_of(&self, subscope: Scope, superscope: Scope) -> bool {\n         let mut s = subscope;\n         debug!(\"is_subscope_of({:?}, {:?})\", subscope, superscope);"}, {"sha": "fc9a2970e00aeb41f7ebe215ab21eb93ea42e586", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -29,12 +29,6 @@ pub enum StabilityLevel {\n     Stable,\n }\n \n-impl StabilityLevel {\n-    pub fn from_attr_level(level: &attr::StabilityLevel) -> Self {\n-        if level.is_stable() { Stable } else { Unstable }\n-    }\n-}\n-\n /// An entry in the `depr_map`.\n #[derive(Clone, HashStable, Debug)]\n pub struct DeprecationEntry {"}, {"sha": "ad48b236a9a1db4c636f8c0b208be6bccbe6a3ab", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -117,17 +117,9 @@ impl CoverageKind {\n         }\n     }\n \n-    pub fn is_counter(&self) -> bool {\n-        matches!(self, Self::Counter { .. })\n-    }\n-\n     pub fn is_expression(&self) -> bool {\n         matches!(self, Self::Expression { .. })\n     }\n-\n-    pub fn is_unreachable(&self) -> bool {\n-        *self == Self::Unreachable\n-    }\n }\n \n impl Debug for CoverageKind {"}, {"sha": "888777a9418b3909dbc50a7869593f194e553b87", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -307,16 +307,6 @@ impl<'tcx, Tag> Scalar<Tag> {\n             .unwrap_or_else(|| bug!(\"Signed value {:#x} does not fit in {} bits\", i, size.bits()))\n     }\n \n-    #[inline]\n-    pub fn from_i8(i: i8) -> Self {\n-        Self::from_int(i, Size::from_bits(8))\n-    }\n-\n-    #[inline]\n-    pub fn from_i16(i: i16) -> Self {\n-        Self::from_int(i, Size::from_bits(16))\n-    }\n-\n     #[inline]\n     pub fn from_i32(i: i32) -> Self {\n         Self::from_int(i, Size::from_bits(32))"}, {"sha": "abca2ecdb060bc5e83d8ef61e6bf24095365be8b", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -379,24 +379,6 @@ impl<'tcx> Body<'tcx> {\n         }\n     }\n \n-    /// Returns an iterator over all temporaries.\n-    #[inline]\n-    pub fn temps_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n-        (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n-            let local = Local::new(index);\n-            if self.local_decls[local].is_user_variable() { None } else { Some(local) }\n-        })\n-    }\n-\n-    /// Returns an iterator over all user-declared locals.\n-    #[inline]\n-    pub fn vars_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {\n-        (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n-            let local = Local::new(index);\n-            self.local_decls[local].is_user_variable().then_some(local)\n-        })\n-    }\n-\n     /// Returns an iterator over all user-declared mutable locals.\n     #[inline]\n     pub fn mut_vars_iter<'a>(&'a self) -> impl Iterator<Item = Local> + 'a {"}, {"sha": "725448584dd29cbe3d763067bbbf5394afc2da06", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -264,10 +264,6 @@ impl<'a, 'tcx> ReversePostorder<'a, 'tcx> {\n \n         ReversePostorder { body, blocks, idx: len }\n     }\n-\n-    pub fn reset(&mut self) {\n-        self.idx = self.blocks.len();\n-    }\n }\n \n pub fn reverse_postorder<'a, 'tcx>(body: &'a Body<'tcx>) -> ReversePostorder<'a, 'tcx> {"}, {"sha": "32b4cd665d03fc151519f4d9107cd790cf46b543", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -1247,12 +1247,6 @@ impl PlaceContext {\n         matches!(self, PlaceContext::MutatingUse(..))\n     }\n \n-    /// Returns `true` if this place context represents a use that does not change the value.\n-    #[inline]\n-    pub fn is_nonmutating_use(&self) -> bool {\n-        matches!(self, PlaceContext::NonMutatingUse(..))\n-    }\n-\n     /// Returns `true` if this place context represents a use.\n     #[inline]\n     pub fn is_use(&self) -> bool {"}, {"sha": "eac3ab7282f527158ac1e207bc438c60e9c53562", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -44,24 +44,12 @@ pub mod type_op {\n         pub b: Ty<'tcx>,\n     }\n \n-    impl<'tcx> Eq<'tcx> {\n-        pub fn new(a: Ty<'tcx>, b: Ty<'tcx>) -> Self {\n-            Self { a, b }\n-        }\n-    }\n-\n     #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n     pub struct Subtype<'tcx> {\n         pub sub: Ty<'tcx>,\n         pub sup: Ty<'tcx>,\n     }\n \n-    impl<'tcx> Subtype<'tcx> {\n-        pub fn new(sub: Ty<'tcx>, sup: Ty<'tcx>) -> Self {\n-            Self { sub, sup }\n-        }\n-    }\n-\n     #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n     pub struct ProvePredicate<'tcx> {\n         pub predicate: Predicate<'tcx>,"}, {"sha": "52cb6b301b070eb715772e6417315f86cdff6c9d", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -6,7 +6,6 @@ use crate::ty;\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_hir::lang_items::LangItem;\n use rustc_span::Span;\n \n use super::{Ty, TyCtxt};\n@@ -113,14 +112,6 @@ impl<'tcx> ClosureKind {\n     // This is the initial value used when doing upvar inference.\n     pub const LATTICE_BOTTOM: ClosureKind = ClosureKind::Fn;\n \n-    pub fn trait_did(&self, tcx: TyCtxt<'tcx>) -> DefId {\n-        match *self {\n-            ClosureKind::Fn => tcx.require_lang_item(LangItem::Fn, None),\n-            ClosureKind::FnMut => tcx.require_lang_item(LangItem::FnMut, None),\n-            ClosureKind::FnOnce => tcx.require_lang_item(LangItem::FnOnce, None),\n-        }\n-    }\n-\n     /// Returns `true` if a type that impls this closure kind\n     /// must also implement `other`.\n     pub fn extends(self, other: ty::ClosureKind) -> bool {\n@@ -377,12 +368,4 @@ impl BorrowKind {\n             UniqueImmBorrow => hir::Mutability::Mut,\n         }\n     }\n-\n-    pub fn to_user_str(&self) -> &'static str {\n-        match *self {\n-            MutBorrow => \"mutable\",\n-            ImmBorrow => \"immutable\",\n-            UniqueImmBorrow => \"uniquely immutable\",\n-        }\n-    }\n }"}, {"sha": "59e1695cdb9d0cb0d36ca548caeb710238112883", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -188,7 +188,7 @@ pub trait TyDecoder<'tcx>: Decoder {\n }\n \n #[inline]\n-pub fn decode_arena_allocable<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n+fn decode_arena_allocable<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n     decoder: &mut D,\n ) -> Result<&'tcx T, D::Error>\n where\n@@ -198,7 +198,7 @@ where\n }\n \n #[inline]\n-pub fn decode_arena_allocable_slice<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n+fn decode_arena_allocable_slice<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n     decoder: &mut D,\n ) -> Result<&'tcx [T], D::Error>\n where"}, {"sha": "da3bdc5c7215e4eaad4121d51256bdf3b62231dd", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -14,7 +14,7 @@ use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstValue, Scalar};\n use crate::mir::{Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::traits;\n-use crate::ty::query::{self, OnDiskCache, TyCtxtAt};\n+use crate::ty::query::{self, OnDiskCache};\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSubsts};\n use crate::ty::TyKind::*;\n use crate::ty::{\n@@ -2288,11 +2288,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ptr(TypeAndMut { ty, mutbl: hir::Mutability::Not })\n     }\n \n-    #[inline]\n-    pub fn mk_nil_ptr(self) -> Ty<'tcx> {\n-        self.mk_imm_ptr(self.mk_unit())\n-    }\n-\n     #[inline]\n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n         self.mk_ty(Array(ty, ty::Const::from_usize(self, n)))\n@@ -2655,21 +2650,6 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-impl TyCtxtAt<'tcx> {\n-    /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` to ensure it gets used.\n-    #[track_caller]\n-    pub fn ty_error(self) -> Ty<'tcx> {\n-        self.tcx.ty_error_with_message(self.span, \"TyKind::Error constructed but no error reported\")\n-    }\n-\n-    /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg to\n-    /// ensure it gets used.\n-    #[track_caller]\n-    pub fn ty_error_with_message(self, msg: &str) -> Ty<'tcx> {\n-        self.tcx.ty_error_with_message(self.span, msg)\n-    }\n-}\n-\n pub trait InternAs<T: ?Sized, R> {\n     type Output;\n     fn intern_with<F>(self, f: F) -> Self::Output"}, {"sha": "6a1ea6df3f01df32ee99c2d63c3abc69e5a29b48", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -618,22 +618,12 @@ pub struct ProjectionPredicate<'tcx> {\n pub type PolyProjectionPredicate<'tcx> = Binder<ProjectionPredicate<'tcx>>;\n \n impl<'tcx> PolyProjectionPredicate<'tcx> {\n-    /// Returns the `DefId` of the associated item being projected.\n-    pub fn item_def_id(&self) -> DefId {\n-        self.skip_binder().projection_ty.item_def_id\n-    }\n-\n     /// Returns the `DefId` of the trait of the associated item being projected.\n     #[inline]\n     pub fn trait_def_id(&self, tcx: TyCtxt<'tcx>) -> DefId {\n         self.skip_binder().projection_ty.trait_def_id(tcx)\n     }\n \n-    #[inline]\n-    pub fn projection_self_ty(&self) -> Binder<Ty<'tcx>> {\n-        self.map_bound(|predicate| predicate.projection_ty.self_ty())\n-    }\n-\n     /// Get the [PolyTraitRef] required for this projection to be well formed.\n     /// Note that for generic associated types the predicates of the associated\n     /// type also need to be checked.\n@@ -1039,10 +1029,6 @@ impl WithOptConstParam<DefId> {\n         None\n     }\n \n-    pub fn expect_local(self) -> WithOptConstParam<LocalDefId> {\n-        self.as_local().unwrap()\n-    }\n-\n     pub fn is_local(self) -> bool {\n         self.did.is_local()\n     }\n@@ -1222,11 +1208,6 @@ pub trait WithConstness: Sized {\n         ConstnessAnd { constness, value: self }\n     }\n \n-    #[inline]\n-    fn with_const(self) -> ConstnessAnd<Self> {\n-        self.with_constness(Constness::Const)\n-    }\n-\n     #[inline]\n     fn without_const(self) -> ConstnessAnd<Self> {\n         self.with_constness(Constness::NotConst)"}, {"sha": "b42375aec6ef826df54205d4fa371555d971b619", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 80, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -977,22 +977,6 @@ impl<T> Binder<T> {\n         Binder(value)\n     }\n \n-    /// Wraps `value` in a binder without actually binding any currently\n-    /// unbound variables.\n-    ///\n-    /// Note that this will shift all debrujin indices of escaping bound variables\n-    /// by 1 to avoid accidential captures.\n-    pub fn wrap_nonbinding(tcx: TyCtxt<'tcx>, value: T) -> Binder<T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        if value.has_escaping_bound_vars() {\n-            Binder::bind(super::fold::shift_vars(tcx, value, 1))\n-        } else {\n-            Binder::dummy(value)\n-        }\n-    }\n-\n     /// Skips the binder and returns the \"bound\" value. This is a\n     /// risky thing to do because it's easy to get confused about\n     /// De Bruijn indices and the like. It is usually better to\n@@ -1074,20 +1058,6 @@ impl<T> Binder<T> {\n     {\n         Binder(f(self.0, u.0))\n     }\n-\n-    /// Splits the contents into two things that share the same binder\n-    /// level as the original, returning two distinct binders.\n-    ///\n-    /// `f` should consider bound regions at depth 1 to be free, and\n-    /// anything it produces with bound regions at depth 1 will be\n-    /// bound in the resulting return values.\n-    pub fn split<U, V, F>(self, f: F) -> (Binder<U>, Binder<V>)\n-    where\n-        F: FnOnce(T) -> (U, V),\n-    {\n-        let (u, v) = f(self.0);\n-        (Binder(u), Binder(v))\n-    }\n }\n \n impl<T> Binder<Option<T>> {\n@@ -1157,18 +1127,6 @@ pub struct GenSig<'tcx> {\n \n pub type PolyGenSig<'tcx> = Binder<GenSig<'tcx>>;\n \n-impl<'tcx> PolyGenSig<'tcx> {\n-    pub fn resume_ty(&self) -> ty::Binder<Ty<'tcx>> {\n-        self.map_bound_ref(|sig| sig.resume_ty)\n-    }\n-    pub fn yield_ty(&self) -> ty::Binder<Ty<'tcx>> {\n-        self.map_bound_ref(|sig| sig.yield_ty)\n-    }\n-    pub fn return_ty(&self) -> ty::Binder<Ty<'tcx>> {\n-        self.map_bound_ref(|sig| sig.return_ty)\n-    }\n-}\n-\n /// Signature of a function type, which we have arbitrarily\n /// decided to use to refer to the input/output types.\n ///\n@@ -1248,10 +1206,6 @@ impl<'tcx> ParamTy {\n         ParamTy { index, name }\n     }\n \n-    pub fn for_self() -> ParamTy {\n-        ParamTy::new(0, kw::SelfUpper)\n-    }\n-\n     pub fn for_def(def: &ty::GenericParamDef) -> ParamTy {\n         ParamTy::new(def.index, def.name)\n     }\n@@ -1269,18 +1223,14 @@ pub struct ParamConst {\n     pub name: Symbol,\n }\n \n-impl<'tcx> ParamConst {\n+impl ParamConst {\n     pub fn new(index: u32, name: Symbol) -> ParamConst {\n         ParamConst { index, name }\n     }\n \n     pub fn for_def(def: &ty::GenericParamDef) -> ParamConst {\n         ParamConst::new(def.index, def.name)\n     }\n-\n-    pub fn to_const(self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        tcx.mk_const_param(self.index, self.name, ty)\n-    }\n }\n \n pub type Region<'tcx> = &'tcx RegionKind;\n@@ -1580,35 +1530,6 @@ impl RegionKind {\n         }\n     }\n \n-    /// Adjusts any De Bruijn indices so as to make `to_binder` the\n-    /// innermost binder. That is, if we have something bound at `to_binder`,\n-    /// it will now be bound at INNERMOST. This is an appropriate thing to do\n-    /// when moving a region out from inside binders:\n-    ///\n-    /// ```\n-    ///             for<'a>   fn(for<'b>   for<'c>   fn(&'a u32), _)\n-    /// // Binder:  D3           D2        D1            ^^\n-    /// ```\n-    ///\n-    /// Here, the region `'a` would have the De Bruijn index D3,\n-    /// because it is the bound 3 binders out. However, if we wanted\n-    /// to refer to that region `'a` in the second argument (the `_`),\n-    /// those two binders would not be in scope. In that case, we\n-    /// might invoke `shift_out_to_binder(D3)`. This would adjust the\n-    /// De Bruijn index of `'a` to D1 (the innermost binder).\n-    ///\n-    /// If we invoke `shift_out_to_binder` and the region is in fact\n-    /// bound by one of the binders we are shifting out of, that is an\n-    /// error (and should fail an assertion failure).\n-    pub fn shifted_out_to_binder(&self, to_binder: ty::DebruijnIndex) -> RegionKind {\n-        match *self {\n-            ty::ReLateBound(debruijn, r) => {\n-                ty::ReLateBound(debruijn.shifted_out_to_binder(to_binder), r)\n-            }\n-            r => r,\n-        }\n-    }\n-\n     pub fn type_flags(&self) -> TypeFlags {\n         let mut flags = TypeFlags::empty();\n "}, {"sha": "c000e49c14bc1b72483803e310601e420be49193", "filename": "compiler/rustc_mir/src/dataflow/framework/cursor.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fcursor.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -64,10 +64,6 @@ where\n         }\n     }\n \n-    pub fn body(&self) -> &'mir mir::Body<'tcx> {\n-        self.body\n-    }\n-\n     /// Returns the underlying `Results`.\n     pub fn results(&self) -> &Results<'tcx, A> {\n         &self.results.borrow()"}, {"sha": "3f20a83fc25bfa8c820465ff06d8ebd274cb3add", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -226,16 +226,6 @@ impl<'mir, 'tcx, Tag> Frame<'mir, 'tcx, Tag> {\n }\n \n impl<'mir, 'tcx, Tag, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n-    /// Get the current location within the Frame.\n-    ///\n-    /// If this is `Err`, we are not currently executing any particular statement in\n-    /// this frame (can happen e.g. during frame initialization, and during unwinding on\n-    /// frames without cleanup code).\n-    /// We basically abuse `Result` as `Either`.\n-    pub fn current_loc(&self) -> Result<mir::Location, Span> {\n-        self.loc\n-    }\n-\n     /// Return the `SourceInfo` of the current instruction.\n     pub fn current_source_info(&self) -> Option<&mir::SourceInfo> {\n         self.loc.ok().map(|loc| self.body.source_info(loc))\n@@ -459,11 +449,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ty.size.truncate(value)\n     }\n \n-    #[inline]\n-    pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx, self.param_env)\n-    }\n-\n     #[inline]\n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n         ty.is_freeze(self.tcx, self.param_env)"}, {"sha": "593a90cb54d4dd79e6c4acf27c546f27e57fa6ca", "filename": "compiler/rustc_mir/src/interpret/machine.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmachine.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -71,11 +71,6 @@ pub trait AllocMap<K: Hash + Eq, V> {\n     fn get(&self, k: K) -> Option<&V> {\n         self.get_or(k, || Err(())).ok()\n     }\n-\n-    /// Mutable lookup.\n-    fn get_mut(&mut self, k: K) -> Option<&mut V> {\n-        self.get_mut_or(k, || Err(())).ok()\n-    }\n }\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail"}, {"sha": "0f436fb3b033183f3b1d031118d6c21e775db151", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -77,14 +77,6 @@ impl<'tcx, Tag> Immediate<Tag> {\n     pub fn to_scalar(self) -> InterpResult<'tcx, Scalar<Tag>> {\n         self.to_scalar_or_uninit().check_init()\n     }\n-\n-    #[inline]\n-    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n-        match self {\n-            Immediate::Scalar(..) => bug!(\"Got a thin pointer where a scalar pair was expected\"),\n-            Immediate::ScalarPair(a, b) => Ok((a.check_init()?, b.check_init()?)),\n-        }\n-    }\n }\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together"}, {"sha": "21c18b28e258ba2d389099d61a2100d3f1cf43a5", "filename": "compiler/rustc_mir/src/util/generic_graphviz.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fgeneric_graphviz.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -40,22 +40,6 @@ impl<\n         }\n     }\n \n-    pub fn new_subgraph(\n-        graph: &'a G,\n-        graphviz_name: &str,\n-        node_content_fn: NodeContentFn,\n-        edge_labels_fn: EdgeLabelsFn,\n-    ) -> Self {\n-        Self {\n-            graph,\n-            is_subgraph: true,\n-            graphviz_name: graphviz_name.to_owned(),\n-            graph_label: None,\n-            node_content_fn,\n-            edge_labels_fn,\n-        }\n-    }\n-\n     pub fn set_graph_label(&mut self, graph_label: &str) {\n         self.graph_label = Some(graph_label.to_owned());\n     }"}, {"sha": "374bc19c7115ac01e0e78018b059d53d5d7cfe83", "filename": "compiler/rustc_mir/src/util/patch.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpatch.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -117,10 +117,6 @@ impl<'tcx> MirPatch<'tcx> {\n         self.add_statement(loc, StatementKind::Assign(box (place, rv)));\n     }\n \n-    pub fn make_nop(&mut self, loc: Location) {\n-        self.make_nop.push(loc);\n-    }\n-\n     pub fn apply(self, body: &mut Body<'tcx>) {\n         debug!(\"MirPatch: make nops at: {:?}\", self.make_nop);\n         for loc in self.make_nop {"}, {"sha": "d592812f79b6b8f333e2e6e12092abf75760aeb1", "filename": "compiler/rustc_query_system/src/cache.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -3,7 +3,6 @@\n use crate::dep_graph::{DepContext, DepNodeIndex};\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::HashMapExt;\n use rustc_data_structures::sync::Lock;\n \n use std::hash::Hash;\n@@ -34,13 +33,6 @@ impl<Key: Eq + Hash, Value: Clone> Cache<Key, Value> {\n     pub fn insert(&self, key: Key, dep_node: DepNodeIndex, value: Value) {\n         self.hashmap.borrow_mut().insert(key, WithDepNode::new(dep_node, value));\n     }\n-\n-    pub fn insert_same(&self, key: Key, dep_node: DepNodeIndex, value: Value)\n-    where\n-        Value: Eq,\n-    {\n-        self.hashmap.borrow_mut().insert_same(key, WithDepNode::new(dep_node, value));\n-    }\n }\n \n #[derive(Clone, Eq, PartialEq)]"}, {"sha": "43429cd11a2b7abf465550068d3461b7bb5a85bc", "filename": "compiler/rustc_query_system/src/dep_graph/debug.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -52,6 +52,7 @@ impl EdgeFilter {\n         }\n     }\n \n+    #[cfg(debug_assertions)]\n     pub fn test<K: DepKind>(&self, source: &DepNode<K>, target: &DepNode<K>) -> bool {\n         self.source.test(source) && self.target.test(target)\n     }"}, {"sha": "9fe2497a57bda6045821fca392d7c809cc096582", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -488,8 +488,8 @@ impl<K: DepKind> DepGraph<K> {\n         self.data.is_some() && self.dep_node_index_of_opt(dep_node).is_some()\n     }\n \n-    #[inline]\n-    pub fn dep_node_of(&self, dep_node_index: DepNodeIndex) -> DepNode<K> {\n+    #[cfg(debug_assertions)]\n+    fn dep_node_of(&self, dep_node_index: DepNodeIndex) -> DepNode<K> {\n         let data = self.data.as_ref().unwrap();\n         let previous = &data.previous;\n         let data = data.current.data.lock();"}, {"sha": "6303bbf53b9c45ffc7187c4db9dc64c4dbfa085a", "filename": "compiler/rustc_query_system/src/dep_graph/prev.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fprev.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -35,11 +35,6 @@ impl<K: DepKind> PreviousDepGraph<K> {\n         self.data.nodes[dep_node_index]\n     }\n \n-    #[inline]\n-    pub fn node_to_index(&self, dep_node: &DepNode<K>) -> SerializedDepNodeIndex {\n-        self.index[dep_node]\n-    }\n-\n     #[inline]\n     pub fn node_to_index_opt(&self, dep_node: &DepNode<K>) -> Option<SerializedDepNodeIndex> {\n         self.index.get(dep_node).cloned()"}, {"sha": "e678a16249b108ced67fb7f09bfd90c826708c65", "filename": "compiler/rustc_query_system/src/dep_graph/query.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -31,10 +31,6 @@ impl<K: DepKind> DepGraphQuery<K> {\n         DepGraphQuery { graph, indices }\n     }\n \n-    pub fn contains_node(&self, node: &DepNode<K>) -> bool {\n-        self.indices.contains_key(&node)\n-    }\n-\n     pub fn nodes(&self) -> Vec<&DepNode<K>> {\n         self.graph.all_nodes().iter().map(|n| &n.data).collect()\n     }"}, {"sha": "1ef3204a2aae431912edab685efa0a090c120da2", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -516,19 +516,6 @@ impl<'tcx> SaveContext<'tcx> {\n         })\n     }\n \n-    pub fn get_trait_ref_data(&self, trait_ref: &hir::TraitRef<'_>) -> Option<Ref> {\n-        self.lookup_def_id(trait_ref.hir_ref_id).and_then(|def_id| {\n-            let span = trait_ref.path.span;\n-            if generated_code(span) {\n-                return None;\n-            }\n-            let sub_span = trait_ref.path.segments.last().unwrap().ident.span;\n-            filter!(self.span_utils, sub_span);\n-            let span = self.span_from_span(sub_span);\n-            Some(Ref { kind: RefKind::Type, span, ref_id: id_from_def_id(def_id) })\n-        })\n-    }\n-\n     pub fn get_expr_data(&self, expr: &hir::Expr<'_>) -> Option<Data> {\n         let ty = self.typeck_results().expr_ty_adjusted_opt(expr)?;\n         if matches!(ty.kind(), ty::Error(_)) {\n@@ -784,7 +771,10 @@ impl<'tcx> SaveContext<'tcx> {\n     /// For a given piece of AST defined by the supplied Span and NodeId,\n     /// returns `None` if the node is not macro-generated or the span is malformed,\n     /// else uses the expansion callsite and callee to return some MacroRef.\n-    pub fn get_macro_use_data(&self, span: Span) -> Option<MacroRef> {\n+    ///\n+    /// FIXME: [`dump_visitor::process_macro_use`] should actually dump this data\n+    #[allow(dead_code)]\n+    fn get_macro_use_data(&self, span: Span) -> Option<MacroRef> {\n         if !generated_code(span) {\n             return None;\n         }"}, {"sha": "6540d4610473ca68e8dff72aad3a277633ef3137", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -505,6 +505,7 @@ impl<'a> From<&'a ExternDepSpec> for rustc_lint_defs::ExternDepSpec {\n }\n \n impl Externs {\n+    /// Used for testing.\n     pub fn new(data: BTreeMap<String, ExternEntry>) -> Externs {\n         Externs(data)\n     }\n@@ -604,13 +605,6 @@ impl Input {\n         }\n     }\n \n-    pub fn get_input(&mut self) -> Option<&mut String> {\n-        match *self {\n-            Input::File(_) => None,\n-            Input::Str { ref mut input, .. } => Some(input),\n-        }\n-    }\n-\n     pub fn source_name(&self) -> FileName {\n         match *self {\n             Input::File(ref ifile) => ifile.clone().into(),\n@@ -778,12 +772,6 @@ impl Options {\n             || self.debugging_opts.query_dep_graph\n     }\n \n-    #[inline(always)]\n-    pub fn enable_dep_node_debug_strs(&self) -> bool {\n-        cfg!(debug_assertions)\n-            && (self.debugging_opts.query_dep_graph || self.debugging_opts.incremental_info)\n-    }\n-\n     pub fn file_path_mapping(&self) -> FilePathMapping {\n         FilePathMapping::new(self.remap_path_prefix.clone())\n     }\n@@ -1060,9 +1048,6 @@ mod opt {\n     pub fn flag_s(a: S, b: S, c: S) -> R {\n         stable(longer(a, b), move |opts| opts.optflag(a, b, c))\n     }\n-    pub fn flagopt_s(a: S, b: S, c: S, d: S) -> R {\n-        stable(longer(a, b), move |opts| opts.optflagopt(a, b, c, d))\n-    }\n     pub fn flagmulti_s(a: S, b: S, c: S) -> R {\n         stable(longer(a, b), move |opts| opts.optflagmulti(a, b, c))\n     }\n@@ -1073,15 +1058,6 @@ mod opt {\n     pub fn multi(a: S, b: S, c: S, d: S) -> R {\n         unstable(longer(a, b), move |opts| opts.optmulti(a, b, c, d))\n     }\n-    pub fn flag(a: S, b: S, c: S) -> R {\n-        unstable(longer(a, b), move |opts| opts.optflag(a, b, c))\n-    }\n-    pub fn flagopt(a: S, b: S, c: S, d: S) -> R {\n-        unstable(longer(a, b), move |opts| opts.optflagopt(a, b, c, d))\n-    }\n-    pub fn flagmulti(a: S, b: S, c: S) -> R {\n-        unstable(longer(a, b), move |opts| opts.optflagmulti(a, b, c))\n-    }\n }\n \n /// Returns the \"short\" subset of the rustc command line options,\n@@ -2459,7 +2435,7 @@ crate mod dep_tracking {\n     }\n \n     // This is a stable hash because BTreeMap is a sorted container\n-    pub fn stable_hash(\n+    crate fn stable_hash(\n         sub_hashes: BTreeMap<&'static str, &dyn DepTrackingHash>,\n         hasher: &mut DefaultHasher,\n         error_format: ErrorOutputType,"}, {"sha": "65d5d96aba1de5a39e0557533e82581d1cf3a65b", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -140,6 +140,7 @@ pub struct ParseSess {\n }\n \n impl ParseSess {\n+    /// Used for testing.\n     pub fn new(file_path_mapping: FilePathMapping) -> Self {\n         let sm = Lrc::new(SourceMap::new(file_path_mapping));\n         let handler = Handler::with_tty_emitter(ColorConfig::Auto, true, None, Some(sm.clone()));"}, {"sha": "621907f19aa74d39bbb0be7079cb0e20bc97c5b7", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 2, "deletions": 89, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -20,7 +20,7 @@ use rustc_errors::annotate_snippet_emitter_writer::AnnotateSnippetEmitterWriter;\n use rustc_errors::emitter::{Emitter, EmitterWriter, HumanReadableErrorType};\n use rustc_errors::json::JsonEmitter;\n use rustc_errors::registry::Registry;\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticId, ErrorReported};\n+use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticId, ErrorReported};\n use rustc_lint_defs::FutureBreakage;\n pub use rustc_span::crate_disambiguator::CrateDisambiguator;\n use rustc_span::edition::Edition;\n@@ -241,8 +241,7 @@ pub struct PerfStats {\n enum DiagnosticBuilderMethod {\n     Note,\n     SpanNote,\n-    SpanSuggestion(String), // suggestion\n-                            // Add more variants as needed to support one-time diagnostics.\n+    // Add more variants as needed to support one-time diagnostics.\n }\n \n /// Trait implemented by error types. This should not be implemented manually. Instead, use\n@@ -365,14 +364,6 @@ impl Session {\n     pub fn struct_span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_span_warn(sp, msg)\n     }\n-    pub fn struct_span_warn_with_code<S: Into<MultiSpan>>(\n-        &self,\n-        sp: S,\n-        msg: &str,\n-        code: DiagnosticId,\n-    ) -> DiagnosticBuilder<'_> {\n-        self.diagnostic().struct_span_warn_with_code(sp, msg, code)\n-    }\n     pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_warn(msg)\n     }\n@@ -411,37 +402,16 @@ impl Session {\n     ) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_span_fatal_with_code(sp, msg, code)\n     }\n-    pub fn struct_fatal(&self, msg: &str) -> DiagnosticBuilder<'_> {\n-        self.diagnostic().struct_fatal(msg)\n-    }\n \n     pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n         self.diagnostic().span_fatal(sp, msg).raise()\n     }\n-    pub fn span_fatal_with_code<S: Into<MultiSpan>>(\n-        &self,\n-        sp: S,\n-        msg: &str,\n-        code: DiagnosticId,\n-    ) -> ! {\n-        self.diagnostic().span_fatal_with_code(sp, msg, code).raise()\n-    }\n     pub fn fatal(&self, msg: &str) -> ! {\n         self.diagnostic().fatal(msg).raise()\n     }\n-    pub fn span_err_or_warn<S: Into<MultiSpan>>(&self, is_warning: bool, sp: S, msg: &str) {\n-        if is_warning {\n-            self.span_warn(sp, msg);\n-        } else {\n-            self.span_err(sp, msg);\n-        }\n-    }\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.diagnostic().span_err(sp, msg)\n     }\n-    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n-        self.diagnostic().span_err_with_code(sp, &msg, code)\n-    }\n     pub fn err(&self, msg: &str) {\n         self.diagnostic().err(msg)\n     }\n@@ -481,18 +451,9 @@ impl Session {\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.diagnostic().span_warn(sp, msg)\n     }\n-    pub fn span_warn_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n-        self.diagnostic().span_warn_with_code(sp, msg, code)\n-    }\n     pub fn warn(&self, msg: &str) {\n         self.diagnostic().warn(msg)\n     }\n-    pub fn opt_span_warn<S: Into<MultiSpan>>(&self, opt_sp: Option<S>, msg: &str) {\n-        match opt_sp {\n-            Some(sp) => self.span_warn(sp, msg),\n-            None => self.warn(msg),\n-        }\n-    }\n     /// Delay a span_bug() call until abort_if_errors()\n     #[track_caller]\n     pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n@@ -519,9 +480,6 @@ impl Session {\n     pub fn note_without_error(&self, msg: &str) {\n         self.diagnostic().note_without_error(msg)\n     }\n-    pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.diagnostic().span_note_without_error(sp, msg)\n-    }\n     pub fn struct_note_without_error(&self, msg: &str) -> DiagnosticBuilder<'_> {\n         self.diagnostic().struct_note_without_error(msg)\n     }\n@@ -551,15 +509,6 @@ impl Session {\n                     let span = span_maybe.expect(\"`span_note` needs a span\");\n                     diag_builder.span_note(span, message);\n                 }\n-                DiagnosticBuilderMethod::SpanSuggestion(suggestion) => {\n-                    let span = span_maybe.expect(\"`span_suggestion_*` needs a span\");\n-                    diag_builder.span_suggestion(\n-                        span,\n-                        message,\n-                        suggestion,\n-                        Applicability::Unspecified,\n-                    );\n-                }\n             }\n         }\n     }\n@@ -589,23 +538,6 @@ impl Session {\n         self.diag_once(diag_builder, DiagnosticBuilderMethod::Note, msg_id, message, None);\n     }\n \n-    pub fn diag_span_suggestion_once<'a, 'b>(\n-        &'a self,\n-        diag_builder: &'b mut DiagnosticBuilder<'a>,\n-        msg_id: DiagnosticMessageId,\n-        span: Span,\n-        message: &str,\n-        suggestion: String,\n-    ) {\n-        self.diag_once(\n-            diag_builder,\n-            DiagnosticBuilderMethod::SpanSuggestion(suggestion),\n-            msg_id,\n-            message,\n-            Some(span),\n-        );\n-    }\n-\n     #[inline]\n     pub fn source_map(&self) -> &SourceMap {\n         self.parse_sess.source_map()\n@@ -631,9 +563,6 @@ impl Session {\n     pub fn verify_llvm_ir(&self) -> bool {\n         self.opts.debugging_opts.verify_llvm_ir || option_env!(\"RUSTC_VERIFY_LLVM_IR\").is_some()\n     }\n-    pub fn borrowck_stats(&self) -> bool {\n-        self.opts.debugging_opts.borrowck_stats\n-    }\n     pub fn print_llvm_passes(&self) -> bool {\n         self.opts.debugging_opts.print_llvm_passes\n     }\n@@ -890,22 +819,6 @@ impl Session {\n         )\n     }\n \n-    pub fn set_incr_session_load_dep_graph(&self, load: bool) {\n-        let mut incr_comp_session = self.incr_comp_session.borrow_mut();\n-\n-        if let IncrCompSession::Active { ref mut load_dep_graph, .. } = *incr_comp_session {\n-            *load_dep_graph = load;\n-        }\n-    }\n-\n-    pub fn incr_session_load_dep_graph(&self) -> bool {\n-        let incr_comp_session = self.incr_comp_session.borrow();\n-        match *incr_comp_session {\n-            IncrCompSession::Active { load_dep_graph, .. } => load_dep_graph,\n-            _ => false,\n-        }\n-    }\n-\n     pub fn init_incr_comp_session(\n         &self,\n         session_dir: PathBuf,"}, {"sha": "95bb0ad7ba2e1912c006d030a468c1027c115033", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -160,6 +160,8 @@ impl DefPathHash {\n     }\n \n     /// Returns the crate-local part of the [DefPathHash].\n+    ///\n+    /// Used for tests.\n     #[inline]\n     pub fn local_hash(&self) -> u64 {\n         self.0.as_value().1"}, {"sha": "6805d4f289077420d16ea58c8f3b76d895dc8c40", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -1176,11 +1176,7 @@ pub fn decode_syntax_context<\n     Ok(new_ctxt)\n }\n \n-pub fn num_syntax_ctxts() -> usize {\n-    HygieneData::with(|data| data.syntax_context_data.len())\n-}\n-\n-pub fn for_all_ctxts_in<E, F: FnMut((u32, SyntaxContext, &SyntaxContextData)) -> Result<(), E>>(\n+fn for_all_ctxts_in<E, F: FnMut((u32, SyntaxContext, &SyntaxContextData)) -> Result<(), E>>(\n     ctxts: impl Iterator<Item = SyntaxContext>,\n     mut f: F,\n ) -> Result<(), E> {\n@@ -1193,7 +1189,7 @@ pub fn for_all_ctxts_in<E, F: FnMut((u32, SyntaxContext, &SyntaxContextData)) ->\n     Ok(())\n }\n \n-pub fn for_all_expns_in<E, F: FnMut(u32, ExpnId, &ExpnData) -> Result<(), E>>(\n+fn for_all_expns_in<E, F: FnMut(u32, ExpnId, &ExpnData) -> Result<(), E>>(\n     expns: impl Iterator<Item = ExpnId>,\n     mut f: F,\n ) -> Result<(), E> {\n@@ -1206,16 +1202,6 @@ pub fn for_all_expns_in<E, F: FnMut(u32, ExpnId, &ExpnData) -> Result<(), E>>(\n     Ok(())\n }\n \n-pub fn for_all_data<E, F: FnMut((u32, SyntaxContext, &SyntaxContextData)) -> Result<(), E>>(\n-    mut f: F,\n-) -> Result<(), E> {\n-    let all_data = HygieneData::with(|data| data.syntax_context_data.clone());\n-    for (i, data) in all_data.into_iter().enumerate() {\n-        f((i as u32, SyntaxContext(i as u32), &data))?;\n-    }\n-    Ok(())\n-}\n-\n impl<E: Encoder> Encodable<E> for ExpnId {\n     default fn encode(&self, _: &mut E) -> Result<(), E::Error> {\n         panic!(\"cannot encode `ExpnId` with `{}`\", std::any::type_name::<E>());\n@@ -1228,14 +1214,6 @@ impl<D: Decoder> Decodable<D> for ExpnId {\n     }\n }\n \n-pub fn for_all_expn_data<E, F: FnMut(u32, &ExpnData) -> Result<(), E>>(mut f: F) -> Result<(), E> {\n-    let all_data = HygieneData::with(|data| data.expn_data.clone());\n-    for (i, data) in all_data.into_iter().enumerate() {\n-        f(i as u32, &data.unwrap_or_else(|| panic!(\"Missing ExpnData!\")))?;\n-    }\n-    Ok(())\n-}\n-\n pub fn raw_encode_syntax_context<E: Encoder>(\n     ctxt: SyntaxContext,\n     context: &HygieneEncodeContext,"}, {"sha": "6f6ff37c525a2659a286441d46610101f7d2619e", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -1037,10 +1037,6 @@ pub enum ExternalSourceKind {\n }\n \n impl ExternalSource {\n-    pub fn is_absent(&self) -> bool {\n-        !matches!(self, ExternalSource::Foreign { kind: ExternalSourceKind::Present(_), .. })\n-    }\n-\n     pub fn get_source(&self) -> Option<&Lrc<String>> {\n         match self {\n             ExternalSource::Foreign { kind: ExternalSourceKind::Present(ref src), .. } => Some(src),\n@@ -1433,9 +1429,6 @@ impl SourceFile {\n         self.src.is_none()\n     }\n \n-    pub fn byte_length(&self) -> u32 {\n-        self.end_pos.0 - self.start_pos.0\n-    }\n     pub fn count_lines(&self) -> usize {\n         self.lines.len()\n     }"}, {"sha": "b351af44e942d74baa7d782a44670869b10831b3", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -8,12 +8,6 @@ pub struct ImpliedOutlivesBounds<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-impl<'tcx> ImpliedOutlivesBounds<'tcx> {\n-    pub fn new(ty: Ty<'tcx>) -> Self {\n-        ImpliedOutlivesBounds { ty }\n-    }\n-}\n-\n impl<'tcx> super::QueryTypeOp<'tcx> for ImpliedOutlivesBounds<'tcx> {\n     type QueryResponse = Vec<OutlivesBound<'tcx>>;\n "}, {"sha": "5fe46065348fc88069aa3dc87143993588740362", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -516,7 +516,7 @@ fn check_needless_must_use(\n                 );\n             },\n         );\n-    } else if !attr.is_value_str() && is_must_use_ty(cx, return_ty(cx, item_id)) {\n+    } else if !attr.value_str().is_some() && is_must_use_ty(cx, return_ty(cx, item_id)) {\n         span_lint_and_help(\n             cx,\n             DOUBLE_MUST_USE,"}, {"sha": "5741aad261bb75f1a5fa3199eed96c60ad0eb492", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/441dc3640a408e612064464b0c6308bdca6c16ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/441dc3640a408e612064464b0c6308bdca6c16ce/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=441dc3640a408e612064464b0c6308bdca6c16ce", "patch": "@@ -95,7 +95,7 @@ impl MissingDoc {\n \n         let has_doc = attrs\n             .iter()\n-            .any(|a| a.is_doc_comment() || a.doc_str().is_some() || a.is_value_str() || Self::has_include(a.meta()));\n+            .any(|a| a.is_doc_comment() || a.doc_str().is_some() || a.value_str().is_some() || Self::has_include(a.meta()));\n         if !has_doc {\n             span_lint(\n                 cx,"}]}