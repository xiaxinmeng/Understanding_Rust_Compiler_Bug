{"sha": "5b75ec0a91f548a5a37afc050474ce47f3e74a40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNzVlYzBhOTFmNTQ4YTVhMzdhZmMwNTA0NzRjZTQ3ZjNlNzRhNDA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-09T15:06:57Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-13T07:09:02Z"}, "message": "fix validation around transmuting copy_op", "tree": {"sha": "7d3e072e6aba85ede621c019061f0ff0887208ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d3e072e6aba85ede621c019061f0ff0887208ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b75ec0a91f548a5a37afc050474ce47f3e74a40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b75ec0a91f548a5a37afc050474ce47f3e74a40", "html_url": "https://github.com/rust-lang/rust/commit/5b75ec0a91f548a5a37afc050474ce47f3e74a40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b75ec0a91f548a5a37afc050474ce47f3e74a40/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c47785f6beb7f2047b2915c42d1d3d4c0ab0abf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c47785f6beb7f2047b2915c42d1d3d4c0ab0abf0", "html_url": "https://github.com/rust-lang/rust/commit/c47785f6beb7f2047b2915c42d1d3d4c0ab0abf0"}], "stats": {"total": 169, "additions": 136, "deletions": 33}, "files": [{"sha": "b5137e914dc91f629f8c8d36b9574eb76643287f", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b75ec0a91f548a5a37afc050474ce47f3e74a40/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b75ec0a91f548a5a37afc050474ce47f3e74a40/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=5b75ec0a91f548a5a37afc050474ce47f3e74a40", "patch": "@@ -322,7 +322,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 // For now, upcasts are limited to changes in marker\n                 // traits, and hence never actually require an actual\n                 // change to the vtable.\n-                self.copy_op(src, dest)\n+                let val = self.read_value(src)?;\n+                self.write_value(*val, dest)\n             }\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait"}, {"sha": "5fa0fef36935df82138ccb5b87358c2fc4626d63", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b75ec0a91f548a5a37afc050474ce47f3e74a40/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b75ec0a91f548a5a37afc050474ce47f3e74a40/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=5b75ec0a91f548a5a37afc050474ce47f3e74a40", "patch": "@@ -151,11 +151,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 self.write_scalar(val, dest)?;\n             }\n             \"transmute\" => {\n-                // Go through an allocation, to make sure the completely different layouts\n-                // do not pose a problem.  (When the user transmutes through a union,\n-                // there will not be a layout mismatch.)\n-                let dest = self.force_allocation(dest)?;\n-                self.copy_op(args[0], dest.into())?;\n+                self.copy_op_transmute(args[0], dest)?;\n             }\n \n             _ => return Ok(false),"}, {"sha": "707857c809b2a430065b7d1bcbf19178e04890fb", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 128, "deletions": 25, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/5b75ec0a91f548a5a37afc050474ce47f3e74a40/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b75ec0a91f548a5a37afc050474ce47f3e74a40/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=5b75ec0a91f548a5a37afc050474ce47f3e74a40", "patch": "@@ -599,18 +599,47 @@ where\n     }\n \n     /// Write a value to a place\n+    #[inline(always)]\n     pub fn write_value(\n         &mut self,\n         src_val: Value<M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"write_value: {:?} <- {:?}\", *dest, src_val);\n-        // Check that the value actually is okay for that type\n+        self.write_value_no_validate(src_val, dest)?;\n+\n         if M::ENFORCE_VALIDITY {\n-            // Something changed somewhere, better make sure it matches the type!\n-            let op = OpTy { op: Operand::Immediate(src_val), layout: dest.layout };\n-            self.validate_operand(op, &mut vec![], None, /*const_mode*/false)?;\n+            // Data got changed, better make sure it matches the type!\n+            self.validate_operand(self.place_to_op(dest)?, &mut vec![], None, /*const_mode*/false)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Write a value to a place.\n+    /// If you use this you are responsible for validating that things got copied at the\n+    /// right type.\n+    fn write_value_no_validate(\n+        &mut self,\n+        src_val: Value<M::PointerTag>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx> {\n+        if cfg!(debug_assertions) {\n+            // This is a very common path, avoid some checks in release mode\n+            assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n+            match src_val {\n+                Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Ptr(_))) =>\n+                    assert_eq!(self.pointer_size(), dest.layout.size,\n+                        \"Size mismatch when writing pointer\"),\n+                Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { size, .. })) =>\n+                    assert_eq!(Size::from_bytes(size.into()), dest.layout.size,\n+                        \"Size mismatch when writing bits\"),\n+                Value::Scalar(ScalarMaybeUndef::Undef) => {}, // undef can have any size\n+                Value::ScalarPair(_, _) => {\n+                    // FIXME: Can we check anything here?\n+                }\n+            }\n         }\n+        trace!(\"write_value: {:?} <- {:?}: {}\", *dest, src_val, dest.layout.ty);\n \n         // See if we can avoid an allocation. This is the counterpart to `try_read_value`,\n         // but not factored as a separate function.\n@@ -627,15 +656,16 @@ where\n             },\n             Place::Ptr(mplace) => mplace, // already in memory\n         };\n+        let dest = MPlaceTy { mplace, layout: dest.layout };\n \n         // This is already in memory, write there.\n-        let dest = MPlaceTy { mplace, layout: dest.layout };\n-        self.write_value_to_mplace(src_val, dest)\n+        self.write_value_to_mplace_no_validate(src_val, dest)\n     }\n \n-    /// Write a value to memory. This does NOT do validation, so you better had already\n-    /// done that before calling this!\n-    fn write_value_to_mplace(\n+    /// Write a value to memory.\n+    /// If you use this you are responsible for validating that things git copied at the\n+    /// right type.\n+    fn write_value_to_mplace_no_validate(\n         &mut self,\n         value: Value<M::PointerTag>,\n         dest: MPlaceTy<'tcx, M::PointerTag>,\n@@ -653,8 +683,17 @@ where\n         }\n \n         let ptr = ptr.to_ptr()?;\n+        // FIXME: We should check that there are dest.layout.size many bytes available in\n+        // memory.  The code below is not sufficient, with enough padding it might not\n+        // cover all the bytes!\n         match value {\n             Value::Scalar(scalar) => {\n+                match dest.layout.abi {\n+                    layout::Abi::Scalar(_) => {}, // fine\n+                    _ => bug!(\"write_value_to_mplace: invalid Scalar layout: {:#?}\",\n+                            dest.layout)\n+                }\n+\n                 self.memory.write_scalar(\n                     ptr, ptr_align.min(dest.layout.align), scalar, dest.layout.size\n                 )\n@@ -670,45 +709,109 @@ where\n                 let b_offset = a_size.abi_align(b_align);\n                 let b_ptr = ptr.offset(b_offset, &self)?.into();\n \n+                // It is tempting to verify `b_offset` against `layout.fields.offset(1)`,\n+                // but that does not work: We could be a newtype around a pair, then the\n+                // fields do not match the `ScalarPair` components.\n+\n                 self.memory.write_scalar(ptr, ptr_align.min(a_align), a_val, a_size)?;\n                 self.memory.write_scalar(b_ptr, ptr_align.min(b_align), b_val, b_size)\n             }\n         }\n     }\n \n-    /// Copy the data from an operand to a place\n+    /// Copy the data from an operand to a place.  This does not support transmuting!\n+    /// Use `copy_op_transmute` if the layouts could disagree.\n+    #[inline(always)]\n     pub fn copy_op(\n         &mut self,\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        assert!(!src.layout.is_unsized() && !dest.layout.is_unsized(),\n+        self.copy_op_no_validate(src, dest)?;\n+\n+        if M::ENFORCE_VALIDITY {\n+            // Data got changed, better make sure it matches the type!\n+            self.validate_operand(self.place_to_op(dest)?, &mut vec![], None, /*const_mode*/false)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Copy the data from an operand to a place.  This does not support transmuting!\n+    /// Use `copy_op_transmute` if the layouts could disagree.\n+    /// Also, if you use this you are responsible for validating that things git copied at the\n+    /// right type.\n+    fn copy_op_no_validate(\n+        &mut self,\n+        src: OpTy<'tcx, M::PointerTag>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx> {\n+        debug_assert!(!src.layout.is_unsized() && !dest.layout.is_unsized(),\n             \"Cannot copy unsized data\");\n-        assert_eq!(src.layout.size, dest.layout.size,\n-            \"Size mismatch when copying!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n+        // We do NOT compare the types for equality, because well-typed code can\n+        // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n+        assert!(src.layout.details == dest.layout.details,\n+            \"Layout mismatch when copying!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n \n         // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n-        let (src_ptr, src_align) = match self.try_read_value(src)? {\n-            Ok(src_val) =>\n-                // Yay, we got a value that we can write directly.  We write with the\n-                // *source layout*, because that was used to load, and if they do not match\n-                // this is a transmute we want to support.\n-                return self.write_value(src_val, PlaceTy { place: *dest, layout: src.layout }),\n-            Err(mplace) => mplace.to_scalar_ptr_align(),\n+        let src = match self.try_read_value(src)? {\n+            Ok(src_val) => {\n+                // Yay, we got a value that we can write directly.\n+                return self.write_value_no_validate(src_val, dest);\n+            }\n+            Err(mplace) => mplace,\n         };\n         // Slow path, this does not fit into an immediate. Just memcpy.\n-        trace!(\"copy_op: {:?} <- {:?}\", *dest, *src);\n+        trace!(\"copy_op: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n+\n         let dest = self.force_allocation(dest)?;\n+        let (src_ptr, src_align) = src.to_scalar_ptr_align();\n         let (dest_ptr, dest_align) = dest.to_scalar_ptr_align();\n         self.memory.copy(\n             src_ptr, src_align,\n             dest_ptr, dest_align,\n-            src.layout.size, false\n+            dest.layout.size, false\n         )?;\n+\n+        Ok(())\n+    }\n+\n+    /// Copy the data from an operand to a place.  The layouts may disagree, but they must\n+    /// have the same size.\n+    pub fn copy_op_transmute(\n+        &mut self,\n+        src: OpTy<'tcx, M::PointerTag>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n+    ) -> EvalResult<'tcx> {\n+        if src.layout.details == dest.layout.details {\n+            // Fast path: Just use normal `copy_op`\n+            return self.copy_op(src, dest);\n+        }\n+        // We still require the sizes to match\n+        debug_assert!(!src.layout.is_unsized() && !dest.layout.is_unsized(),\n+            \"Cannot copy unsized data\");\n+        assert!(src.layout.size == dest.layout.size,\n+            \"Size mismatch when transmuting!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n+\n+        // The hard case is `ScalarPair`.  `src` is already read from memory in this case,\n+        // using `src.layout` to figure out which bytes to use for the 1st and 2nd field.\n+        // We have to write them to `dest` at the offsets they were *read at*, which is\n+        // not necessarily the same as the offsets in `dest.layout`!\n+        // Hence we do the copy with the source layout on both sides.  We also make sure to write\n+        // into memory, because if `dest` is a local we would not even have a way to write\n+        // at the `src` offsets; the fact that we came from a different layout would\n+        // just be lost.\n+        let dest = self.force_allocation(dest)?;\n+        self.copy_op_no_validate(\n+            src,\n+            PlaceTy::from(MPlaceTy { mplace: *dest, layout: src.layout }),\n+        )?;\n+\n         if M::ENFORCE_VALIDITY {\n-            // Something changed somewhere, better make sure it matches the type!\n+            // Data got changed, better make sure it matches the type!\n             self.validate_operand(dest.into(), &mut vec![], None, /*const_mode*/false)?;\n         }\n+\n         Ok(())\n     }\n \n@@ -734,7 +837,7 @@ where\n                         let ptr = self.allocate(local_layout, MemoryKind::Stack)?;\n                         // We don't have to validate as we can assume the local\n                         // was already valid for its type.\n-                        self.write_value_to_mplace(value, ptr)?;\n+                        self.write_value_to_mplace_no_validate(value, ptr)?;\n                         let mplace = ptr.mplace;\n                         // Update the local\n                         *self.stack[frame].locals[local].access_mut()? ="}, {"sha": "0ff18b0dd0b202553a6309c7c0dfdf37b4bbc1df", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b75ec0a91f548a5a37afc050474ce47f3e74a40/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b75ec0a91f548a5a37afc050474ce47f3e74a40/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=5b75ec0a91f548a5a37afc050474ce47f3e74a40", "patch": "@@ -222,7 +222,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         if !Self::check_argument_compat(caller_arg.layout, callee_arg.layout) {\n             return err!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty));\n         }\n-        self.copy_op(caller_arg, callee_arg)\n+        // We allow some transmutes here\n+        self.copy_op_transmute(caller_arg, callee_arg)\n     }\n \n     /// Call this function -- pushing the stack frame and initializing the arguments."}, {"sha": "cff4a0a323e0bc9d3266cf2b896ae544be74a3f4", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b75ec0a91f548a5a37afc050474ce47f3e74a40/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b75ec0a91f548a5a37afc050474ce47f3e74a40/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=5b75ec0a91f548a5a37afc050474ce47f3e74a40", "patch": "@@ -218,7 +218,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                                 return validation_failure!(\"unaligned reference\", path),\n                             _ =>\n                                 return validation_failure!(\n-                                    \"dangling (deallocated) reference\", path\n+                                    \"dangling (out-of-bounds) reference (might be NULL at \\\n+                                     run-time)\",\n+                                    path\n                                 ),\n                         }\n                     }"}]}