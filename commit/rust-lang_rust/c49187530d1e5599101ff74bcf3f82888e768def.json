{"sha": "c49187530d1e5599101ff74bcf3f82888e768def", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0OTE4NzUzMGQxZTU1OTkxMDFmZjc0YmNmM2Y4Mjg4OGU3NjhkZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-19T14:01:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-19T14:01:35Z"}, "message": "Auto merge of #65598 - Centril:rollup-vc6ht2c, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #64007 (Add check for overlapping ranges to unreachable patterns lint)\n - #65192 (Use structured suggestion for restricting bounds)\n - #65226 (BTreeSet symmetric_difference & union optimized)\n - #65448 (rustc_codegen_ssa: remove some unnecessary Box special-casing.)\n - #65505 (Rc: value -> allocation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "6cbfafcebd329f33d8db10c6199af49409b80b9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cbfafcebd329f33d8db10c6199af49409b80b9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c49187530d1e5599101ff74bcf3f82888e768def", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c49187530d1e5599101ff74bcf3f82888e768def", "html_url": "https://github.com/rust-lang/rust/commit/c49187530d1e5599101ff74bcf3f82888e768def", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c49187530d1e5599101ff74bcf3f82888e768def/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5b8c118a38e8f3319813de56386bf43751582d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5b8c118a38e8f3319813de56386bf43751582d7", "html_url": "https://github.com/rust-lang/rust/commit/e5b8c118a38e8f3319813de56386bf43751582d7"}, {"sha": "2de4f4335e454d3e6b635e57d5f2f56f4f5a03d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2de4f4335e454d3e6b635e57d5f2f56f4f5a03d4", "html_url": "https://github.com/rust-lang/rust/commit/2de4f4335e454d3e6b635e57d5f2f56f4f5a03d4"}], "stats": {"total": 2080, "additions": 1464, "deletions": 616}, "files": [{"sha": "f0796354e00c384076f8a47a59f62b849556cd1e", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 119, "deletions": 120, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,7 +2,7 @@\n // to TreeMap\n \n use core::borrow::Borrow;\n-use core::cmp::Ordering::{self, Less, Greater, Equal};\n+use core::cmp::Ordering::{Less, Greater, Equal};\n use core::cmp::{max, min};\n use core::fmt::{self, Debug};\n use core::iter::{Peekable, FromIterator, FusedIterator};\n@@ -109,6 +109,77 @@ pub struct Range<'a, T: 'a> {\n     iter: btree_map::Range<'a, T, ()>,\n }\n \n+/// Core of SymmetricDifference and Union.\n+/// More efficient than btree.map.MergeIter,\n+/// and crucially for SymmetricDifference, nexts() reports on both sides.\n+#[derive(Clone)]\n+struct MergeIterInner<I>\n+    where I: Iterator,\n+          I::Item: Copy,\n+{\n+    a: I,\n+    b: I,\n+    peeked: Option<MergeIterPeeked<I>>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum MergeIterPeeked<I: Iterator> {\n+    A(I::Item),\n+    B(I::Item),\n+}\n+\n+impl<I> MergeIterInner<I>\n+    where I: ExactSizeIterator + FusedIterator,\n+          I::Item: Copy + Ord,\n+{\n+    fn new(a: I, b: I) -> Self {\n+        MergeIterInner { a, b, peeked: None }\n+    }\n+\n+    fn nexts(&mut self) -> (Option<I::Item>, Option<I::Item>) {\n+        let mut a_next = match self.peeked {\n+            Some(MergeIterPeeked::A(next)) => Some(next),\n+            _ => self.a.next(),\n+        };\n+        let mut b_next = match self.peeked {\n+            Some(MergeIterPeeked::B(next)) => Some(next),\n+            _ => self.b.next(),\n+        };\n+        let ord = match (a_next, b_next) {\n+            (None, None) => Equal,\n+            (_, None) => Less,\n+            (None, _) => Greater,\n+            (Some(a1), Some(b1)) => a1.cmp(&b1),\n+        };\n+        self.peeked = match ord {\n+            Less => b_next.take().map(MergeIterPeeked::B),\n+            Equal => None,\n+            Greater => a_next.take().map(MergeIterPeeked::A),\n+        };\n+        (a_next, b_next)\n+    }\n+\n+    fn lens(&self) -> (usize, usize) {\n+        match self.peeked {\n+            Some(MergeIterPeeked::A(_)) => (1 + self.a.len(), self.b.len()),\n+            Some(MergeIterPeeked::B(_)) => (self.a.len(), 1 + self.b.len()),\n+            _ => (self.a.len(), self.b.len()),\n+        }\n+    }\n+}\n+\n+impl<I> Debug for MergeIterInner<I>\n+    where I: Iterator + Debug,\n+          I::Item: Copy + Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"MergeIterInner\")\n+            .field(&self.a)\n+            .field(&self.b)\n+            .finish()\n+    }\n+}\n+\n /// A lazy iterator producing elements in the difference of `BTreeSet`s.\n ///\n /// This `struct` is created by the [`difference`] method on [`BTreeSet`].\n@@ -120,6 +191,7 @@ pub struct Range<'a, T: 'a> {\n pub struct Difference<'a, T: 'a> {\n     inner: DifferenceInner<'a, T>,\n }\n+#[derive(Debug)]\n enum DifferenceInner<'a, T: 'a> {\n     Stitch {\n         // iterate all of self and some of other, spotting matches along the way\n@@ -137,21 +209,7 @@ enum DifferenceInner<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.inner {\n-            DifferenceInner::Stitch {\n-                self_iter,\n-                other_iter,\n-            } => f\n-                .debug_tuple(\"Difference\")\n-                .field(&self_iter)\n-                .field(&other_iter)\n-                .finish(),\n-            DifferenceInner::Search {\n-                self_iter,\n-                other_set: _,\n-            } => f.debug_tuple(\"Difference\").field(&self_iter).finish(),\n-            DifferenceInner::Iterate(iter) => f.debug_tuple(\"Difference\").field(&iter).finish(),\n-        }\n+        f.debug_tuple(\"Difference\").field(&self.inner).finish()\n     }\n }\n \n@@ -163,18 +221,12 @@ impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n /// [`BTreeSet`]: struct.BTreeSet.html\n /// [`symmetric_difference`]: struct.BTreeSet.html#method.symmetric_difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SymmetricDifference<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n-}\n+pub struct SymmetricDifference<'a, T: 'a>(MergeIterInner<Iter<'a, T>>);\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"SymmetricDifference\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        f.debug_tuple(\"SymmetricDifference\").field(&self.0).finish()\n     }\n }\n \n@@ -189,6 +241,7 @@ impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n pub struct Intersection<'a, T: 'a> {\n     inner: IntersectionInner<'a, T>,\n }\n+#[derive(Debug)]\n enum IntersectionInner<'a, T: 'a> {\n     Stitch {\n         // iterate similarly sized sets jointly, spotting matches along the way\n@@ -206,23 +259,7 @@ enum IntersectionInner<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.inner {\n-            IntersectionInner::Stitch {\n-                a,\n-                b,\n-            } => f\n-                .debug_tuple(\"Intersection\")\n-                .field(&a)\n-                .field(&b)\n-                .finish(),\n-            IntersectionInner::Search {\n-                small_iter,\n-                large_set: _,\n-            } => f.debug_tuple(\"Intersection\").field(&small_iter).finish(),\n-            IntersectionInner::Answer(answer) => {\n-                f.debug_tuple(\"Intersection\").field(&answer).finish()\n-            }\n-        }\n+        f.debug_tuple(\"Intersection\").field(&self.inner).finish()\n     }\n }\n \n@@ -234,18 +271,12 @@ impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n /// [`BTreeSet`]: struct.BTreeSet.html\n /// [`union`]: struct.BTreeSet.html#method.union\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Union<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n-}\n+pub struct Union<'a, T: 'a>(MergeIterInner<Iter<'a, T>>);\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Union\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        f.debug_tuple(\"Union\").field(&self.0).finish()\n     }\n }\n \n@@ -355,19 +386,16 @@ impl<T: Ord> BTreeSet<T> {\n                     self_iter.next_back();\n                     DifferenceInner::Iterate(self_iter)\n                 }\n-                _ => {\n-                    if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-                        DifferenceInner::Search {\n-                            self_iter: self.iter(),\n-                            other_set: other,\n-                        }\n-                    } else {\n-                        DifferenceInner::Stitch {\n-                            self_iter: self.iter(),\n-                            other_iter: other.iter().peekable(),\n-                        }\n+                _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    DifferenceInner::Search {\n+                        self_iter: self.iter(),\n+                        other_set: other,\n                     }\n                 }\n+                _ => DifferenceInner::Stitch {\n+                    self_iter: self.iter(),\n+                    other_iter: other.iter().peekable(),\n+                },\n             },\n         }\n     }\n@@ -396,10 +424,7 @@ impl<T: Ord> BTreeSet<T> {\n     pub fn symmetric_difference<'a>(&'a self,\n                                     other: &'a BTreeSet<T>)\n                                     -> SymmetricDifference<'a, T> {\n-        SymmetricDifference {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n-        }\n+        SymmetricDifference(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n     /// Visits the values representing the intersection,\n@@ -447,24 +472,22 @@ impl<T: Ord> BTreeSet<T> {\n                 (Greater, _) | (_, Less) => IntersectionInner::Answer(None),\n                 (Equal, _) => IntersectionInner::Answer(Some(self_min)),\n                 (_, Equal) => IntersectionInner::Answer(Some(self_max)),\n-                _ => {\n-                    if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-                        IntersectionInner::Search {\n-                            small_iter: self.iter(),\n-                            large_set: other,\n-                        }\n-                    } else if other.len() <= self.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-                        IntersectionInner::Search {\n-                            small_iter: other.iter(),\n-                            large_set: self,\n-                        }\n-                    } else {\n-                        IntersectionInner::Stitch {\n-                            a: self.iter(),\n-                            b: other.iter(),\n-                        }\n+                _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    IntersectionInner::Search {\n+                        small_iter: self.iter(),\n+                        large_set: other,\n+                    }\n+                }\n+                _ if other.len() <= self.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    IntersectionInner::Search {\n+                        small_iter: other.iter(),\n+                        large_set: self,\n                     }\n                 }\n+                _ => IntersectionInner::Stitch {\n+                    a: self.iter(),\n+                    b: other.iter(),\n+                },\n             },\n         }\n     }\n@@ -489,10 +512,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n-        Union {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n-        }\n+        Union(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n     /// Clears the set, removing all values.\n@@ -1166,15 +1186,6 @@ impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Range<'_, T> {}\n \n-/// Compares `x` and `y`, but return `short` if x is None and `long` if y is None\n-fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering) -> Ordering {\n-    match (x, y) {\n-        (None, _) => short,\n-        (_, None) => long,\n-        (Some(x1), Some(y1)) => x1.cmp(y1),\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Difference<'_, T> {\n     fn clone(&self) -> Self {\n@@ -1261,10 +1272,7 @@ impl<T: Ord> FusedIterator for Difference<'_, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for SymmetricDifference<'_, T> {\n     fn clone(&self) -> Self {\n-        SymmetricDifference {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n-        }\n+        SymmetricDifference(self.0.clone())\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1273,19 +1281,19 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less => return self.a.next(),\n-                Equal => {\n-                    self.a.next();\n-                    self.b.next();\n-                }\n-                Greater => return self.b.next(),\n+            let (a_next, b_next) = self.0.nexts();\n+            if a_next.and(b_next).is_none() {\n+                return a_next.or(b_next);\n             }\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(self.a.len() + self.b.len()))\n+        let (a_len, b_len) = self.0.lens();\n+        // No checked_add, because even if a and b refer to the same set,\n+        // and T is an empty type, the storage overhead of sets limits\n+        // the number of elements to less than half the range of usize.\n+        (0, Some(a_len + b_len))\n     }\n }\n \n@@ -1311,7 +1319,7 @@ impl<T> Clone for Intersection<'_, T> {\n                     small_iter: small_iter.clone(),\n                     large_set,\n                 },\n-                IntersectionInner::Answer(answer) => IntersectionInner::Answer(answer.clone()),\n+                IntersectionInner::Answer(answer) => IntersectionInner::Answer(*answer),\n             },\n         }\n     }\n@@ -1365,30 +1373,21 @@ impl<T: Ord> FusedIterator for Intersection<'_, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Union<'_, T> {\n     fn clone(&self) -> Self {\n-        Union {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n-        }\n+        Union(self.0.clone())\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Union<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n-        match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-            Less => self.a.next(),\n-            Equal => {\n-                self.b.next();\n-                self.a.next()\n-            }\n-            Greater => self.b.next(),\n-        }\n+        let (a_next, b_next) = self.0.nexts();\n+        a_next.or(b_next)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let a_len = self.a.len();\n-        let b_len = self.b.len();\n+        let (a_len, b_len) = self.0.lens();\n+        // No checked_add - see SymmetricDifference::size_hint.\n         (max(a_len, b_len), Some(a_len + b_len))\n     }\n }"}, {"sha": "f1c4c32e116ea74dcc59bec6eb349841517662b4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 72, "deletions": 59, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -3,8 +3,9 @@\n //!\n //! The type [`Rc<T>`][`Rc`] provides shared ownership of a value of type `T`,\n //! allocated in the heap. Invoking [`clone`][clone] on [`Rc`] produces a new\n-//! pointer to the same value in the heap. When the last [`Rc`] pointer to a\n-//! given value is destroyed, the pointed-to value is also destroyed.\n+//! pointer to the same allocation in the heap. When the last [`Rc`] pointer to a\n+//! given allocation is destroyed, the value stored in that allocation (often\n+//! referred to as \"inner value\") is also dropped.\n //!\n //! Shared references in Rust disallow mutation by default, and [`Rc`]\n //! is no exception: you cannot generally obtain a mutable reference to\n@@ -21,8 +22,10 @@\n //!\n //! The [`downgrade`][downgrade] method can be used to create a non-owning\n //! [`Weak`] pointer. A [`Weak`] pointer can be [`upgrade`][upgrade]d\n-//! to an [`Rc`], but this will return [`None`] if the value has\n-//! already been dropped.\n+//! to an [`Rc`], but this will return [`None`] if the value stored in the allocation has\n+//! already been dropped. In other words, `Weak` pointers do not keep the value\n+//! inside the allocation alive; however, they *do* keep the allocation\n+//! (the backing store for the inner value) alive.\n //!\n //! A cycle between [`Rc`] pointers will never be deallocated. For this reason,\n //! [`Weak`] is used to break cycles. For example, a tree could have strong\n@@ -41,13 +44,13 @@\n //! Rc::downgrade(&my_rc);\n //! ```\n //!\n-//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the value may have\n-//! already been destroyed.\n+//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the inner value may have\n+//! already been dropped.\n //!\n //! # Cloning references\n //!\n-//! Creating a new reference from an existing reference counted pointer is done using the\n-//! `Clone` trait implemented for [`Rc<T>`][`Rc`] and [`Weak<T>`][`Weak`].\n+//! Creating a new reference to the same allocation as an existing reference counted pointer\n+//! is done using the `Clone` trait implemented for [`Rc<T>`][`Rc`] and [`Weak<T>`][`Weak`].\n //!\n //! ```\n //! use std::rc::Rc;\n@@ -93,7 +96,7 @@\n //!     );\n //!\n //!     // Create `Gadget`s belonging to `gadget_owner`. Cloning the `Rc<Owner>`\n-//!     // value gives us a new pointer to the same `Owner` value, incrementing\n+//!     // gives us a new pointer to the same `Owner` allocation, incrementing\n //!     // the reference count in the process.\n //!     let gadget1 = Gadget {\n //!         id: 1,\n@@ -110,8 +113,8 @@\n //!     // Despite dropping `gadget_owner`, we're still able to print out the name\n //!     // of the `Owner` of the `Gadget`s. This is because we've only dropped a\n //!     // single `Rc<Owner>`, not the `Owner` it points to. As long as there are\n-//!     // other `Rc<Owner>` values pointing at the same `Owner`, it will remain\n-//!     // allocated. The field projection `gadget1.owner.name` works because\n+//!     // other `Rc<Owner>` pointing at the same `Owner` allocation, it will remain\n+//!     // live. The field projection `gadget1.owner.name` works because\n //!     // `Rc<Owner>` automatically dereferences to `Owner`.\n //!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n //!     println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n@@ -124,9 +127,9 @@\n //!\n //! If our requirements change, and we also need to be able to traverse from\n //! `Owner` to\u00a0`Gadget`, we will run into problems. An [`Rc`] pointer from `Owner`\n-//! to `Gadget` introduces a cycle between the values. This means that their\n-//! reference counts can never reach 0, and the values will remain allocated\n-//! forever: a memory leak. In order to get around this, we can use [`Weak`]\n+//! to `Gadget` introduces a cycle. This means that their\n+//! reference counts can never reach 0, and the allocation will never be destroyed:\n+//! a memory leak. In order to get around this, we can use [`Weak`]\n //! pointers.\n //!\n //! Rust actually makes it somewhat difficult to produce this loop in the first\n@@ -193,10 +196,10 @@\n //!     for gadget_weak in gadget_owner.gadgets.borrow().iter() {\n //!\n //!         // `gadget_weak` is a `Weak<Gadget>`. Since `Weak` pointers can't\n-//!         // guarantee the value is still allocated, we need to call\n+//!         // guarantee the allocation still exists, we need to call\n //!         // `upgrade`, which returns an `Option<Rc<Gadget>>`.\n //!         //\n-//!         // In this case we know the value still exists, so we simply\n+//!         // In this case we know the allocation still exists, so we simply\n //!         // `unwrap` the `Option`. In a more complicated program, you might\n //!         // need graceful error handling for a `None` result.\n //!\n@@ -365,7 +368,7 @@ impl<T> Rc<T> {\n         unsafe { Pin::new_unchecked(Rc::new(value)) }\n     }\n \n-    /// Returns the contained value, if the `Rc` has exactly one strong reference.\n+    /// Returns the inner value, if the `Rc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`][result] is returned with the same `Rc` that was\n     /// passed in.\n@@ -446,7 +449,7 @@ impl<T> Rc<mem::MaybeUninit<T>> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -485,7 +488,7 @@ impl<T> Rc<[mem::MaybeUninit<T>]> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -604,7 +607,7 @@ impl<T: ?Sized> Rc<T> {\n         unsafe { NonNull::new_unchecked(Rc::into_raw(this) as *mut _) }\n     }\n \n-    /// Creates a new [`Weak`][weak] pointer to this value.\n+    /// Creates a new [`Weak`][weak] pointer to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -625,7 +628,7 @@ impl<T: ?Sized> Rc<T> {\n         Weak { ptr: this.ptr }\n     }\n \n-    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -645,7 +648,7 @@ impl<T: ?Sized> Rc<T> {\n         this.weak() - 1\n     }\n \n-    /// Gets the number of strong (`Rc`) pointers to this value.\n+    /// Gets the number of strong (`Rc`) pointers to this allocation.\n     ///\n     /// # Examples\n     ///\n@@ -664,22 +667,22 @@ impl<T: ?Sized> Rc<T> {\n     }\n \n     /// Returns `true` if there are no other `Rc` or [`Weak`][weak] pointers to\n-    /// this inner value.\n+    /// this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     #[inline]\n     fn is_unique(this: &Self) -> bool {\n         Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }\n \n-    /// Returns a mutable reference to the inner value, if there are\n-    /// no other `Rc` or [`Weak`][weak] pointers to the same value.\n+    /// Returns a mutable reference into the given `Rc`, if there are\n+    /// no other `Rc` or [`Weak`][weak] pointers to the same allocation.\n     ///\n     /// Returns [`None`] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n-    /// the inner value when it's shared.\n+    /// the inner value when there are other pointers.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n@@ -710,7 +713,7 @@ impl<T: ?Sized> Rc<T> {\n         }\n     }\n \n-    /// Returns a mutable reference to the inner value,\n+    /// Returns a mutable reference into the given `Rc`,\n     /// without any check.\n     ///\n     /// See also [`get_mut`], which is safe and does appropriate checks.\n@@ -719,7 +722,7 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// # Safety\n     ///\n-    /// Any other `Rc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// Any other `Rc` or [`Weak`] pointers to the same allocation must not be dereferenced\n     /// for the duration of the returned borrow.\n     /// This is trivially the case if no such pointers exist,\n     /// for example immediately after `Rc::new`.\n@@ -745,8 +748,8 @@ impl<T: ?Sized> Rc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns `true` if the two `Rc`s point to the same value (not\n-    /// just values that compare as equal).\n+    /// Returns `true` if the two `Rc`s point to the same allocation\n+    /// (in a vein similar to [`ptr::eq`]).\n     ///\n     /// # Examples\n     ///\n@@ -760,6 +763,8 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(Rc::ptr_eq(&five, &same_five));\n     /// assert!(!Rc::ptr_eq(&five, &other_five));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n@@ -768,12 +773,12 @@ impl<T: ?Sized> Rc<T> {\n impl<T: Clone> Rc<T> {\n     /// Makes a mutable reference into the given `Rc`.\n     ///\n-    /// If there are other `Rc` pointers to the same value, then `make_mut` will\n-    /// [`clone`] the inner value to ensure unique ownership.  This is also\n+    /// If there are other `Rc` pointers to the same allocation, then `make_mut` will\n+    /// [`clone`] the inner value to a new allocation to ensure unique ownership.  This is also\n     /// referred to as clone-on-write.\n     ///\n-    /// If there are no other `Rc` pointers to this value, then [`Weak`]\n-    /// pointers to this value will be disassociated.\n+    /// If there are no other `Rc` pointers to this allocation, then [`Weak`]\n+    /// pointers to this allocation will be disassociated.\n     ///\n     /// See also [`get_mut`], which will fail rather than cloning.\n     ///\n@@ -794,7 +799,7 @@ impl<T: Clone> Rc<T> {\n     /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n     /// *Rc::make_mut(&mut other_data) *= 2;  // Won't clone anything\n     ///\n-    /// // Now `data` and `other_data` point to different values.\n+    /// // Now `data` and `other_data` point to different allocations.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n@@ -837,7 +842,7 @@ impl<T: Clone> Rc<T> {\n         // returned is the *only* pointer that will ever be returned to T. Our\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n-        // reference to the inner value.\n+        // reference to the allocation.\n         unsafe {\n             &mut this.ptr.as_mut().value\n         }\n@@ -878,7 +883,7 @@ impl Rc<dyn Any> {\n \n impl<T: ?Sized> Rc<T> {\n     /// Allocates an `RcBox<T>` with sufficient space for\n-    /// a possibly-unsized value where the value has the layout provided.\n+    /// a possibly-unsized inner value where the value has the layout provided.\n     ///\n     /// The function `mem_to_rcbox` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n@@ -908,7 +913,7 @@ impl<T: ?Sized> Rc<T> {\n         inner\n     }\n \n-    /// Allocates an `RcBox<T>` with sufficient space for an unsized value\n+    /// Allocates an `RcBox<T>` with sufficient space for an unsized inner value\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n         Self::allocate_for_layout(\n@@ -1111,7 +1116,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n impl<T: ?Sized> Clone for Rc<T> {\n     /// Makes a clone of the `Rc` pointer.\n     ///\n-    /// This creates another pointer to the same inner value, increasing the\n+    /// This creates another pointer to the same allocation, increasing the\n     /// strong reference count.\n     ///\n     /// # Examples\n@@ -1172,6 +1177,8 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n /// store large values, that are slow to clone, but also heavy to check for equality, causing this\n /// cost to pay off more easily. It's also more likely to have two `Rc` clones, that point to\n /// the same value, than two `&T`s.\n+///\n+/// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n     #[inline]\n@@ -1189,9 +1196,11 @@ impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     /// Equality for two `Rc`s.\n     ///\n-    /// Two `Rc`s are equal if their inner values are equal.\n+    /// Two `Rc`s are equal if their inner values are equal, even if they are\n+    /// stored in different allocation.\n     ///\n-    /// If `T` also implements `Eq`, two `Rc`s that point to the same value are\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Rc`s that point to the same allocation are\n     /// always equal.\n     ///\n     /// # Examples\n@@ -1212,7 +1221,8 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     ///\n     /// Two `Rc`s are unequal if their inner values are unequal.\n     ///\n-    /// If `T` also implements `Eq`, two `Rc`s that point to the same value are\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Rc`s that point to the same allocation are\n     /// never unequal.\n     ///\n     /// # Examples\n@@ -1541,17 +1551,18 @@ impl<'a, T: 'a + Clone> RcFromIter<&'a T, slice::Iter<'a, T>> for Rc<[T]> {\n }\n \n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n-/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n+/// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n ///\n /// Since a `Weak` reference does not count towards ownership, it will not\n-/// prevent the inner value from being dropped, and `Weak` itself makes no\n-/// guarantees about the value still being present and may return [`None`]\n-/// when [`upgrade`]d.\n+/// prevent the value stored in the allocation from being dropped, and `Weak` itself makes no\n+/// guarantees about the value still being present. Thus it may return [`None`]\n+/// when [`upgrade`]d. Note however that a `Weak` reference *does* prevent the allocation\n+/// itself (the backing store) from being deallocated.\n ///\n-/// A `Weak` pointer is useful for keeping a temporary reference to the value\n-/// within [`Rc`] without extending its lifetime. It is also used to prevent\n-/// circular references between [`Rc`] pointers, since mutual owning references\n+/// A `Weak` pointer is useful for keeping a temporary reference to the allocation\n+/// managed by [`Rc`] without preventing its inner value from being dropped. It is also used to\n+/// prevent circular references between [`Rc`] pointers, since mutual owning references\n /// would never allow either [`Rc`] to be dropped. For example, a tree could\n /// have strong [`Rc`] pointers from parent nodes to children, and `Weak`\n /// pointers from children back to their parents.\n@@ -1750,10 +1761,10 @@ pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Attempts to upgrade the `Weak` pointer to an [`Rc`], extending\n-    /// the lifetime of the value if successful.\n+    /// Attempts to upgrade the `Weak` pointer to an [`Rc`], delaying\n+    /// dropping of the inner value if successful.\n     ///\n-    /// Returns [`None`] if the value has since been dropped.\n+    /// Returns [`None`] if the inner value has since been dropped.\n     ///\n     /// [`Rc`]: struct.Rc.html\n     /// [`None`]: ../../std/option/enum.Option.html\n@@ -1787,7 +1798,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of strong (`Rc`) pointers pointing to this value.\n+    /// Gets the number of strong (`Rc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n     ///\n@@ -1801,11 +1812,11 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of `Weak` pointers pointing to this value.\n+    /// Gets the number of `Weak` pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return `None`. If\n     /// not, the returned value is at least 1, since `self` still points to the\n-    /// value.\n+    /// allocation.\n     ///\n     /// [`Weak::new`]: #method.new\n     #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n@@ -1830,14 +1841,14 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same value (not just\n-    /// values that compare as equal), or if both don't point to any value\n+    /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n+    /// [`ptr::eq`]), or if both don't point to any allocation\n     /// (because they were created with `Weak::new()`).\n     ///\n     /// # Notes\n     ///\n     /// Since this compares pointers it means that `Weak::new()` will equal each\n-    /// other, even though they don't point to any value.\n+    /// other, even though they don't point to any allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1869,6 +1880,8 @@ impl<T: ?Sized> Weak<T> {\n     /// let third = Rc::downgrade(&third_rc);\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -1918,7 +1931,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak` pointer that points to the same value.\n+    /// Makes a clone of the `Weak` pointer that points to the same allocation.\n     ///\n     /// # Examples\n     ///"}, {"sha": "69f8f71197c1f24e826d62c71a2c1f179350c92a", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 65, "deletions": 51, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -45,10 +45,10 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///\n /// The type `Arc<T>` provides shared ownership of a value of type `T`,\n /// allocated in the heap. Invoking [`clone`][clone] on `Arc` produces\n-/// a new `Arc` instance, which points to the same value on the heap as the\n+/// a new `Arc` instance, which points to the same allocation on the heap as the\n /// source `Arc`, while increasing a reference count. When the last `Arc`\n-/// pointer to a given value is destroyed, the pointed-to value is also\n-/// destroyed.\n+/// pointer to a given allocation is destroyed, the value stored in that allocation (often\n+/// referred to as \"inner value\") is also dropped.\n ///\n /// Shared references in Rust disallow mutation by default, and `Arc` is no\n /// exception: you cannot generally obtain a mutable reference to something\n@@ -61,7 +61,7 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// Unlike [`Rc<T>`], `Arc<T>` uses atomic operations for its reference\n /// counting. This means that it is thread-safe. The disadvantage is that\n /// atomic operations are more expensive than ordinary memory accesses. If you\n-/// are not sharing reference-counted values between threads, consider using\n+/// are not sharing reference-counted allocations between threads, consider using\n /// [`Rc<T>`] for lower overhead. [`Rc<T>`] is a safe default, because the\n /// compiler will catch any attempt to send an [`Rc<T>`] between threads.\n /// However, a library might choose `Arc<T>` in order to give library consumers\n@@ -85,8 +85,10 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n ///\n /// The [`downgrade`][downgrade] method can be used to create a non-owning\n /// [`Weak`][weak] pointer. A [`Weak`][weak] pointer can be [`upgrade`][upgrade]d\n-/// to an `Arc`, but this will return [`None`] if the value has already been\n-/// dropped.\n+/// to an `Arc`, but this will return [`None`] if the value stored in the allocation has\n+/// already been dropped. In other words, `Weak` pointers do not keep the value\n+/// inside the allocation alive; however, they *do* keep the allocation\n+/// (the backing store for the value) alive.\n ///\n /// A cycle between `Arc` pointers will never be deallocated. For this reason,\n /// [`Weak`][weak] is used to break cycles. For example, a tree could have\n@@ -121,8 +123,8 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// Arc::downgrade(&my_arc);\n /// ```\n ///\n-/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the value may have\n-/// already been destroyed.\n+/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the inner value may have\n+/// already been dropped.\n ///\n /// [arc]: struct.Arc.html\n /// [weak]: struct.Weak.html\n@@ -221,17 +223,18 @@ impl<T: ?Sized> Arc<T> {\n }\n \n /// `Weak` is a version of [`Arc`] that holds a non-owning reference to the\n-/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n+/// managed allocation. The allocation is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Arc`]`<T>>`.\n ///\n /// Since a `Weak` reference does not count towards ownership, it will not\n-/// prevent the inner value from being dropped, and `Weak` itself makes no\n-/// guarantees about the value still being present and may return [`None`]\n-/// when [`upgrade`]d.\n+/// prevent the value stored in the allocation from being dropped, and `Weak` itself makes no\n+/// guarantees about the value still being present. Thus it may return [`None`]\n+/// when [`upgrade`]d. Note however that a `Weak` reference *does* prevent the allocation\n+/// itself (the backing store) from being deallocated.\n ///\n-/// A `Weak` pointer is useful for keeping a temporary reference to the value\n-/// within [`Arc`] without extending its lifetime. It is also used to prevent\n-/// circular references between [`Arc`] pointers, since mutual owning references\n+/// A `Weak` pointer is useful for keeping a temporary reference to the allocation\n+/// managed by [`Arc`] without preventing its inner value from being dropped. It is also used to\n+/// prevent circular references between [`Arc`] pointers, since mutual owning references\n /// would never allow either [`Arc`] to be dropped. For example, a tree could\n /// have strong [`Arc`] pointers from parent nodes to children, and `Weak`\n /// pointers from children back to their parents.\n@@ -345,7 +348,7 @@ impl<T> Arc<T> {\n         unsafe { Pin::new_unchecked(Arc::new(data)) }\n     }\n \n-    /// Returns the contained value, if the `Arc` has exactly one strong reference.\n+    /// Returns the inner value, if the `Arc` has exactly one strong reference.\n     ///\n     /// Otherwise, an [`Err`][result] is returned with the same `Arc` that was\n     /// passed in.\n@@ -426,7 +429,7 @@ impl<T> Arc<mem::MaybeUninit<T>> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -465,7 +468,7 @@ impl<T> Arc<[mem::MaybeUninit<T>]> {\n     /// # Safety\n     ///\n     /// As with [`MaybeUninit::assume_init`],\n-    /// it is up to the caller to guarantee that the value\n+    /// it is up to the caller to guarantee that the inner value\n     /// really is in an initialized state.\n     /// Calling this when the content is not yet fully initialized\n     /// causes immediate undefined behavior.\n@@ -584,7 +587,7 @@ impl<T: ?Sized> Arc<T> {\n         unsafe { NonNull::new_unchecked(Arc::into_raw(this) as *mut _) }\n     }\n \n-    /// Creates a new [`Weak`][weak] pointer to this value.\n+    /// Creates a new [`Weak`][weak] pointer to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -628,7 +631,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n     ///\n@@ -659,7 +662,7 @@ impl<T: ?Sized> Arc<T> {\n         if cnt == usize::MAX { 0 } else { cnt - 1 }\n     }\n \n-    /// Gets the number of strong (`Arc`) pointers to this value.\n+    /// Gets the number of strong (`Arc`) pointers to this allocation.\n     ///\n     /// # Safety\n     ///\n@@ -710,8 +713,8 @@ impl<T: ?Sized> Arc<T> {\n \n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns `true` if the two `Arc`s point to the same value (not\n-    /// just values that compare as equal).\n+    /// Returns `true` if the two `Arc`s point to the same allocation\n+    /// (in a vein similar to [`ptr::eq`]).\n     ///\n     /// # Examples\n     ///\n@@ -725,14 +728,16 @@ impl<T: ?Sized> Arc<T> {\n     /// assert!(Arc::ptr_eq(&five, &same_five));\n     /// assert!(!Arc::ptr_eq(&five, &other_five));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n         this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n impl<T: ?Sized> Arc<T> {\n     /// Allocates an `ArcInner<T>` with sufficient space for\n-    /// a possibly-unsized value where the value has the layout provided.\n+    /// a possibly-unsized inner value where the value has the layout provided.\n     ///\n     /// The function `mem_to_arcinner` is called with the data pointer\n     /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n@@ -761,7 +766,7 @@ impl<T: ?Sized> Arc<T> {\n         inner\n     }\n \n-    /// Allocates an `ArcInner<T>` with sufficient space for an unsized value.\n+    /// Allocates an `ArcInner<T>` with sufficient space for an unsized inner value.\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n         Self::allocate_for_layout(\n@@ -903,7 +908,7 @@ impl<T: Copy> ArcFromSlice<T> for Arc<[T]> {\n impl<T: ?Sized> Clone for Arc<T> {\n     /// Makes a clone of the `Arc` pointer.\n     ///\n-    /// This creates another pointer to the same inner value, increasing the\n+    /// This creates another pointer to the same allocation, increasing the\n     /// strong reference count.\n     ///\n     /// # Examples\n@@ -965,15 +970,19 @@ impl<T: ?Sized> Receiver for Arc<T> {}\n impl<T: Clone> Arc<T> {\n     /// Makes a mutable reference into the given `Arc`.\n     ///\n-    /// If there are other `Arc` or [`Weak`][weak] pointers to the same value,\n-    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n-    /// ensure unique ownership. This is also referred to as clone-on-write.\n+    /// If there are other `Arc` or [`Weak`][weak] pointers to the same allocation,\n+    /// then `make_mut` will create a new allocation and invoke [`clone`][clone] on the inner value\n+    /// to ensure unique ownership. This is also referred to as clone-on-write.\n+    ///\n+    /// Note that this differs from the behavior of [`Rc::make_mut`] which disassociates\n+    /// any remaining `Weak` pointers.\n     ///\n     /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n     /// [get_mut]: struct.Arc.html#method.get_mut\n+    /// [`Rc::make_mut`]: ../rc/struct.Rc.html#method.make_mut\n     ///\n     /// # Examples\n     ///\n@@ -988,7 +997,7 @@ impl<T: Clone> Arc<T> {\n     /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n     /// *Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n     ///\n-    /// // Now `data` and `other_data` point to different values.\n+    /// // Now `data` and `other_data` point to different allocations.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n@@ -1048,14 +1057,14 @@ impl<T: Clone> Arc<T> {\n }\n \n impl<T: ?Sized> Arc<T> {\n-    /// Returns a mutable reference to the inner value, if there are\n-    /// no other `Arc` or [`Weak`][weak] pointers to the same value.\n+    /// Returns a mutable reference into the given `Arc`, if there are\n+    /// no other `Arc` or [`Weak`][weak] pointers to the same allocation.\n     ///\n     /// Returns [`None`][option] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n-    /// the inner value when it's shared.\n+    /// the inner value when there are other pointers.\n     ///\n     /// [weak]: struct.Weak.html\n     /// [option]: ../../std/option/enum.Option.html\n@@ -1091,7 +1100,7 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Returns a mutable reference to the inner value,\n+    /// Returns a mutable reference into the given `Arc`,\n     /// without any check.\n     ///\n     /// See also [`get_mut`], which is safe and does appropriate checks.\n@@ -1100,7 +1109,7 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// # Safety\n     ///\n-    /// Any other `Arc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// Any other `Arc` or [`Weak`] pointers to the same allocation must not be dereferenced\n     /// for the duration of the returned borrow.\n     /// This is trivially the case if no such pointers exist,\n     /// for example immediately after `Arc::new`.\n@@ -1424,10 +1433,10 @@ impl<T> Weak<T> {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Attempts to upgrade the `Weak` pointer to an [`Arc`], extending\n-    /// the lifetime of the value if successful.\n+    /// Attempts to upgrade the `Weak` pointer to an [`Arc`], delaying\n+    /// dropping of the inner value if successful.\n     ///\n-    /// Returns [`None`] if the value has since been dropped.\n+    /// Returns [`None`] if the inner value has since been dropped.\n     ///\n     /// [`Arc`]: struct.Arc.html\n     /// [`None`]: ../../std/option/enum.Option.html#variant.None\n@@ -1482,7 +1491,7 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Gets the number of strong (`Arc`) pointers pointing to this value.\n+    /// Gets the number of strong (`Arc`) pointers pointing to this allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0.\n     ///\n@@ -1497,17 +1506,17 @@ impl<T: ?Sized> Weak<T> {\n     }\n \n     /// Gets an approximation of the number of `Weak` pointers pointing to this\n-    /// value.\n+    /// allocation.\n     ///\n     /// If `self` was created using [`Weak::new`], this will return 0. If not,\n     /// the returned value is at least 1, since `self` still points to the\n-    /// value.\n+    /// allocation.\n     ///\n     /// # Accuracy\n     ///\n     /// Due to implementation details, the returned value can be off by 1 in\n     /// either direction when other threads are manipulating any `Arc`s or\n-    /// `Weak`s pointing to the same value.\n+    /// `Weak`s pointing to the same allocation.\n     ///\n     /// [`Weak::new`]: #method.new\n     #[unstable(feature = \"weak_counts\", issue = \"57977\")]\n@@ -1548,14 +1557,14 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same value (not just\n-    /// values that compare as equal), or if both don't point to any value\n+    /// Returns `true` if the two `Weak`s point to the same allocation (similar to\n+    /// [`ptr::eq`]), or if both don't point to any allocation\n     /// (because they were created with `Weak::new()`).\n     ///\n     /// # Notes\n     ///\n     /// Since this compares pointers it means that `Weak::new()` will equal each\n-    /// other, even though they don't point to any value.\n+    /// other, even though they don't point to any allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1587,6 +1596,8 @@ impl<T: ?Sized> Weak<T> {\n     /// let third = Arc::downgrade(&third_rc);\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n+    ///\n+    /// [`ptr::eq`]: ../../std/ptr/fn.eq.html\n     #[inline]\n     #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n@@ -1596,7 +1607,7 @@ impl<T: ?Sized> Weak<T> {\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak` pointer that points to the same value.\n+    /// Makes a clone of the `Weak` pointer that points to the same allocation.\n     ///\n     /// # Examples\n     ///\n@@ -1726,6 +1737,8 @@ impl<T: ?Sized + PartialEq> ArcEqIdent<T> for Arc<T> {\n /// store large values, that are slow to clone, but also heavy to check for equality, causing this\n /// cost to pay off more easily. It's also more likely to have two `Arc` clones, that point to\n /// the same value, than two `&T`s.\n+///\n+/// We can only do this when `T: Eq` as a `PartialEq` might be deliberately irreflexive.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n     #[inline]\n@@ -1743,10 +1756,11 @@ impl<T: ?Sized + Eq> ArcEqIdent<T> for Arc<T> {\n impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     /// Equality for two `Arc`s.\n     ///\n-    /// Two `Arc`s are equal if their inner values are equal.\n+    /// Two `Arc`s are equal if their inner values are equal, even if they are\n+    /// stored in different allocation.\n     ///\n-    /// If `T` also implements `Eq`, two `Arc`s that point to the same value are\n-    /// always equal.\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Arc`s that point to the same allocation are always equal.\n     ///\n     /// # Examples\n     ///\n@@ -1766,8 +1780,8 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     ///\n     /// Two `Arc`s are unequal if their inner values are unequal.\n     ///\n-    /// If `T` also implements `Eq`, two `Arc`s that point to the same value are\n-    /// never unequal.\n+    /// If `T` also implements `Eq` (implying reflexivity of equality),\n+    /// two `Arc`s that point to the same value are never unequal.\n     ///\n     /// # Examples\n     ///"}, {"sha": "e4883abc8b56c3362d1fd4726f0d73746f430971", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -221,6 +221,18 @@ fn test_symmetric_difference() {\n                                &[-2, 1, 5, 11, 14, 22]);\n }\n \n+#[test]\n+fn test_symmetric_difference_size_hint() {\n+    let x: BTreeSet<i32> = [2, 4].iter().copied().collect();\n+    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let mut iter = x.symmetric_difference(&y);\n+    assert_eq!(iter.size_hint(), (0, Some(5)));\n+    assert_eq!(iter.next(), Some(&1));\n+    assert_eq!(iter.size_hint(), (0, Some(4)));\n+    assert_eq!(iter.next(), Some(&3));\n+    assert_eq!(iter.size_hint(), (0, Some(1)));\n+}\n+\n #[test]\n fn test_union() {\n     fn check_union(a: &[i32], b: &[i32], expected: &[i32]) {\n@@ -235,6 +247,18 @@ fn test_union() {\n                 &[-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n }\n \n+#[test]\n+fn test_union_size_hint() {\n+    let x: BTreeSet<i32> = [2, 4].iter().copied().collect();\n+    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let mut iter = x.union(&y);\n+    assert_eq!(iter.size_hint(), (3, Some(5)));\n+    assert_eq!(iter.next(), Some(&1));\n+    assert_eq!(iter.size_hint(), (2, Some(4)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (1, Some(2)));\n+}\n+\n #[test]\n // Only tests the simple function definition with respect to intersection\n fn test_is_disjoint() {\n@@ -244,7 +268,7 @@ fn test_is_disjoint() {\n }\n \n #[test]\n-// Also tests the trivial function definition of is_superset\n+// Also implicitly tests the trivial function definition of is_superset\n fn test_is_subset() {\n     fn is_subset(a: &[i32], b: &[i32]) -> bool {\n         let set_a = a.iter().collect::<BTreeSet<_>>();"}, {"sha": "568e051aaf08fc750e618bad84e220338dde626b", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -669,6 +669,12 @@ impl WhereClause {\n             Some(self.span)\n         }\n     }\n+\n+    /// The `WhereClause` under normal circumstances points at either the predicates or the empty\n+    /// space where the `where` clause should be. Only of use for diagnostic suggestions.\n+    pub fn span_for_predicates_or_empty_place(&self) -> Span {\n+        self.span\n+    }\n }\n \n /// A single predicate in a where-clause.\n@@ -989,6 +995,15 @@ pub enum RangeEnd {\n     Excluded,\n }\n \n+impl fmt::Display for RangeEnd {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            RangeEnd::Included => \"..=\",\n+            RangeEnd::Excluded => \"..\",\n+        })\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum PatKind {\n     /// Represents a wildcard pattern (i.e., `_`)."}, {"sha": "4c28f6372fe2c6db543819ea21a7d9324e4b39ba", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -80,6 +80,12 @@ declare_lint! {\n     \"detects unreachable patterns\"\n }\n \n+declare_lint! {\n+    pub OVERLAPPING_PATTERNS,\n+    Warn,\n+    \"detects overlapping patterns\"\n+}\n+\n declare_lint! {\n     pub UNUSED_MACROS,\n     Warn,\n@@ -423,6 +429,7 @@ declare_lint_pass! {\n         DEAD_CODE,\n         UNREACHABLE_CODE,\n         UNREACHABLE_PATTERNS,\n+        OVERLAPPING_PATTERNS,\n         UNUSED_MACROS,\n         WARNINGS,\n         UNUSED_FEATURES,"}, {"sha": "daa4a215a238a4623f1f73685ce4e1bb112dc4b4", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 174, "deletions": 2, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -715,8 +715,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             // these notes will often be of the form\n                             //     \"the type `T` can't be frobnicated\"\n                             // which is somewhat confusing.\n-                            err.help(&format!(\"consider adding a `where {}` bound\",\n-                                              trait_ref.to_predicate()));\n+                            self.suggest_restricting_param_bound(\n+                                &mut err,\n+                                &trait_ref,\n+                                obligation.cause.body_id,\n+                            );\n                         } else {\n                             if !have_alt_message {\n                                 // Can't show anything else useful, try to find similar impls.\n@@ -960,6 +963,175 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n+    fn suggest_restricting_param_bound(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::PolyTraitRef<'_>,\n+        body_id: hir::HirId,\n+    ) {\n+        let self_ty = trait_ref.self_ty();\n+        let (param_ty, projection) = match &self_ty.kind {\n+            ty::Param(_) => (true, None),\n+            ty::Projection(projection) => (false, Some(projection)),\n+            _ => return,\n+        };\n+\n+        let mut suggest_restriction = |generics: &hir::Generics, msg| {\n+            let span = generics.where_clause.span_for_predicates_or_empty_place();\n+            if !span.from_expansion() && span.desugaring_kind().is_none() {\n+                err.span_suggestion(\n+                    generics.where_clause.span_for_predicates_or_empty_place().shrink_to_hi(),\n+                    &format!(\"consider further restricting {}\", msg),\n+                    format!(\n+                        \"{} {} \",\n+                        if !generics.where_clause.predicates.is_empty() {\n+                            \",\"\n+                        } else {\n+                            \" where\"\n+                        },\n+                        trait_ref.to_predicate(),\n+                    ),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        };\n+\n+        // FIXME: Add check for trait bound that is already present, particularly `?Sized` so we\n+        //        don't suggest `T: Sized + ?Sized`.\n+        let mut hir_id = body_id;\n+        while let Some(node) = self.tcx.hir().find(hir_id) {\n+            match node {\n+                hir::Node::TraitItem(hir::TraitItem {\n+                    generics,\n+                    kind: hir::TraitItemKind::Method(..), ..\n+                }) if param_ty && self_ty == self.tcx.types.self_param => {\n+                    // Restricting `Self` for a single method.\n+                    suggest_restriction(&generics, \"`Self`\");\n+                    return;\n+                }\n+\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Fn(_, _, generics, _), ..\n+                }) |\n+                hir::Node::TraitItem(hir::TraitItem {\n+                    generics,\n+                    kind: hir::TraitItemKind::Method(..), ..\n+                }) |\n+                hir::Node::ImplItem(hir::ImplItem {\n+                    generics,\n+                    kind: hir::ImplItemKind::Method(..), ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, generics, _, _), ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Impl(_, _, _, generics, ..), ..\n+                }) if projection.is_some() => {\n+                    // Missing associated type bound.\n+                    suggest_restriction(&generics, \"the associated type\");\n+                    return;\n+                }\n+\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Struct(_, generics), span, .. }) |\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Enum(_, generics), span, .. }) |\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Union(_, generics), span, .. }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, generics, ..), span, ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Impl(_, _, _, generics, ..), span, ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Fn(_, _, generics, _), span, ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::TyAlias(_, generics), span, ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::TraitAlias(generics, _), span, ..\n+                }) |\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::OpaqueTy(hir::OpaqueTy { generics, .. }), span, ..\n+                }) |\n+                hir::Node::TraitItem(hir::TraitItem { generics, span, .. }) |\n+                hir::Node::ImplItem(hir::ImplItem { generics, span, .. })\n+                if param_ty => {\n+                    // Missing generic type parameter bound.\n+                    let restrict_msg = \"consider further restricting this bound\";\n+                    let param_name = self_ty.to_string();\n+                    for param in generics.params.iter().filter(|p| {\n+                        &param_name == std::convert::AsRef::<str>::as_ref(&p.name.ident().as_str())\n+                    }) {\n+                        if param_name.starts_with(\"impl \") {\n+                            // `impl Trait` in argument:\n+                            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n+                            err.span_suggestion(\n+                                param.span,\n+                                restrict_msg,\n+                                // `impl CurrentTrait + MissingTrait`\n+                                format!(\"{} + {}\", param.name.ident(), trait_ref),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else if generics.where_clause.predicates.is_empty() &&\n+                                param.bounds.is_empty()\n+                        {\n+                            // If there are no bounds whatsoever, suggest adding a constraint\n+                            // to the type parameter:\n+                            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+                            err.span_suggestion(\n+                                param.span,\n+                                \"consider restricting this bound\",\n+                                format!(\"{}\", trait_ref.to_predicate()),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else if !generics.where_clause.predicates.is_empty() {\n+                            // There is a `where` clause, so suggest expanding it:\n+                            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+                            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n+                            err.span_suggestion(\n+                                generics.where_clause.span().unwrap().shrink_to_hi(),\n+                                &format!(\n+                                    \"consider further restricting type parameter `{}`\",\n+                                    param_name,\n+                                ),\n+                                format!(\", {}\", trait_ref.to_predicate()),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            // If there is no `where` clause lean towards constraining to the\n+                            // type parameter:\n+                            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+                            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+                            let sp = param.span.with_hi(span.hi());\n+                            let span = self.tcx.sess.source_map()\n+                                .span_through_char(sp, ':');\n+                            if sp != param.span && sp != span {\n+                                // Only suggest if we have high certainty that the span\n+                                // covers the colon in `foo<T: Trait>`.\n+                                err.span_suggestion(span, restrict_msg, format!(\n+                                    \"{} + \",\n+                                    trait_ref.to_predicate(),\n+                                ), Applicability::MachineApplicable);\n+                            } else {\n+                                err.span_label(param.span, &format!(\n+                                    \"consider adding a `where {}` bound\",\n+                                    trait_ref.to_predicate(),\n+                                ));\n+                            }\n+                        }\n+                        return;\n+                    }\n+                }\n+\n+                hir::Node::Crate => return,\n+\n+                _ => {}\n+            }\n+\n+            hir_id = self.tcx.hir().get_parent_item(hir_id);\n+        }\n+    }\n+\n     /// When encountering an assignment of an unsized trait, like `let x = \"\"[..];`, provide a\n     /// suggestion to borrow the initializer in order to use have a slice instead.\n     fn suggest_borrow_on_unsized_slice("}, {"sha": "f4f3dd4d2d295520629a458f2d320ed11a8071db", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -168,12 +168,6 @@ pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n             (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n         }\n-        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n-            let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n-            assert!(bx.cx().type_is_sized(a));\n-            let ptr_ty = bx.cx().type_ptr_to(bx.cx().backend_type(bx.cx().layout_of(b)));\n-            (bx.pointercast(src, ptr_ty), unsized_info(bx.cx(), a, b, None))\n-        }\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n@@ -196,6 +190,8 @@ pub fn unsize_thin_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             }\n             let (lldata, llextra) = result.unwrap();\n             // HACK(eddyb) have to bitcast pointers until LLVM removes pointee types.\n+            // FIXME(eddyb) move these out of this `match` arm, so they're always\n+            // applied, uniformly, no matter the source/destination types.\n             (bx.bitcast(lldata, bx.cx().scalar_pair_element_backend_type(dst_layout, 0, true)),\n              bx.bitcast(llextra, bx.cx().scalar_pair_element_backend_type(dst_layout, 1, true)))\n         }\n@@ -212,31 +208,27 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n ) {\n     let src_ty = src.layout.ty;\n     let dst_ty = dst.layout.ty;\n-    let mut coerce_ptr = || {\n-        let (base, info) = match bx.load_operand(src).val {\n-            OperandValue::Pair(base, info) => {\n-                // fat-ptr to fat-ptr unsize preserves the vtable\n-                // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n-                // So we need to pointercast the base to ensure\n-                // the types match up.\n-                let thin_ptr = dst.layout.field(bx.cx(), FAT_PTR_ADDR);\n-                (bx.pointercast(base, bx.cx().backend_type(thin_ptr)), info)\n-            }\n-            OperandValue::Immediate(base) => {\n-                unsize_thin_ptr(bx, base, src_ty, dst_ty)\n-            }\n-            OperandValue::Ref(..) => bug!()\n-        };\n-        OperandValue::Pair(base, info).store(bx, dst);\n-    };\n     match (&src_ty.kind, &dst_ty.kind) {\n         (&ty::Ref(..), &ty::Ref(..)) |\n         (&ty::Ref(..), &ty::RawPtr(..)) |\n         (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n-            coerce_ptr()\n-        }\n-        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n-            coerce_ptr()\n+            let (base, info) = match bx.load_operand(src).val {\n+                OperandValue::Pair(base, info) => {\n+                    // fat-ptr to fat-ptr unsize preserves the vtable\n+                    // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n+                    // So we need to pointercast the base to ensure\n+                    // the types match up.\n+                    // FIXME(eddyb) use `scalar_pair_element_backend_type` here,\n+                    // like `unsize_thin_ptr` does.\n+                    let thin_ptr = dst.layout.field(bx.cx(), FAT_PTR_ADDR);\n+                    (bx.pointercast(base, bx.cx().backend_type(thin_ptr)), info)\n+                }\n+                OperandValue::Immediate(base) => {\n+                    unsize_thin_ptr(bx, base, src_ty, dst_ty)\n+                }\n+                OperandValue::Ref(..) => bug!()\n+            };\n+            OperandValue::Pair(base, info).store(bx, dst);\n         }\n \n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {"}, {"sha": "e3860e229d6b5d4b89960a3e0fc87160baf372e4", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -255,6 +255,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     UNUSED_MUT,\n                     UNREACHABLE_CODE,\n                     UNREACHABLE_PATTERNS,\n+                    OVERLAPPING_PATTERNS,\n                     UNUSED_MUST_USE,\n                     UNUSED_UNSAFE,\n                     PATH_STATEMENTS,"}, {"sha": "1d83b104177e23ead5bbcc9df2439ef66970f0aa", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 194, "deletions": 60, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -167,13 +167,14 @@ use super::{FieldPat, Pat, PatKind, PatRange};\n use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n-use rustc::hir::RangeEnd;\n+use rustc::hir::{RangeEnd, HirId};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n use rustc::mir::interpret::{ConstValue, Scalar, truncate, AllocId, Pointer};\n use rustc::util::common::ErrorReported;\n+use rustc::lint;\n \n use syntax::attr::{SignedInt, UnsignedInt};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -418,21 +419,38 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug)]\n enum Constructor<'tcx> {\n     /// The constructor of all patterns that don't vary by constructor,\n     /// e.g., struct patterns and fixed-length arrays.\n     Single,\n     /// Enum variants.\n     Variant(DefId),\n     /// Literal values.\n-    ConstantValue(&'tcx ty::Const<'tcx>),\n+    ConstantValue(&'tcx ty::Const<'tcx>, Span),\n     /// Ranges of literal values (`2..=5` and `2..5`).\n-    ConstantRange(u128, u128, Ty<'tcx>, RangeEnd),\n+    ConstantRange(u128, u128, Ty<'tcx>, RangeEnd, Span),\n     /// Array patterns of length n.\n     Slice(u64),\n }\n \n+// Ignore spans when comparing, they don't carry semantic information as they are only for lints.\n+impl<'tcx> std::cmp::PartialEq for Constructor<'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (self, other) {\n+            (Constructor::Single, Constructor::Single) => true,\n+            (Constructor::Variant(a), Constructor::Variant(b)) => a == b,\n+            (Constructor::ConstantValue(a, _), Constructor::ConstantValue(b, _)) => a == b,\n+            (\n+                Constructor::ConstantRange(a_start, a_end, a_ty, a_range_end, _),\n+                Constructor::ConstantRange(b_start, b_end, b_ty, b_range_end, _),\n+            ) => a_start == b_start && a_end == b_end && a_ty == b_ty && a_range_end == b_range_end,\n+            (Constructor::Slice(a), Constructor::Slice(b)) => a == b,\n+            _ => false,\n+        }\n+    }\n+}\n+\n impl<'tcx> Constructor<'tcx> {\n     fn is_slice(&self) -> bool {\n         match self {\n@@ -447,15 +465,33 @@ impl<'tcx> Constructor<'tcx> {\n         adt: &'tcx ty::AdtDef,\n     ) -> VariantIdx {\n         match self {\n-            &Variant(id) => adt.variant_index_with_id(id),\n-            &Single => {\n+            Variant(id) => adt.variant_index_with_id(*id),\n+            Single => {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n             }\n-            &ConstantValue(c) => crate::const_eval::const_variant_index(cx.tcx, cx.param_env, c),\n+            ConstantValue(c, _) => crate::const_eval::const_variant_index(cx.tcx, cx.param_env, c),\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt)\n         }\n     }\n+\n+    fn display(&self, tcx: TyCtxt<'tcx>) -> String {\n+        match self {\n+            Constructor::ConstantValue(val, _) => format!(\"{}\", val),\n+            Constructor::ConstantRange(lo, hi, ty, range_end, _) => {\n+                // Get the right sign on the output:\n+                let ty = ty::ParamEnv::empty().and(*ty);\n+                format!(\n+                    \"{}{}{}\",\n+                    ty::Const::from_bits(tcx, *lo, ty),\n+                    range_end,\n+                    ty::Const::from_bits(tcx, *hi, ty),\n+                )\n+            }\n+            Constructor::Slice(val) => format!(\"[{}]\", val),\n+            _ => bug!(\"bad constructor being displayed: `{:?}\", self),\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -484,6 +520,7 @@ pub enum WitnessPreference {\n struct PatCtxt<'tcx> {\n     ty: Ty<'tcx>,\n     max_slice_length: u64,\n+    span: Span,\n }\n \n /// A witness of non-exhaustiveness for error reporting, represented\n@@ -610,8 +647,8 @@ impl<'tcx> Witness<'tcx> {\n \n                 _ => {\n                     match *ctor {\n-                        ConstantValue(value) => PatKind::Constant { value },\n-                        ConstantRange(lo, hi, ty, end) => PatKind::Range(PatRange {\n+                        ConstantValue(value, _) => PatKind::Constant { value },\n+                        ConstantRange(lo, hi, ty, end, _) => PatKind::Range(PatRange {\n                             lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n                             hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n                             end,\n@@ -647,7 +684,7 @@ fn all_constructors<'a, 'tcx>(\n     let ctors = match pcx.ty.kind {\n         ty::Bool => {\n             [true, false].iter().map(|&b| {\n-                ConstantValue(ty::Const::from_bool(cx.tcx, b))\n+                ConstantValue(ty::Const::from_bool(cx.tcx, b), pcx.span)\n             }).collect()\n         }\n         ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n@@ -679,28 +716,32 @@ fn all_constructors<'a, 'tcx>(\n         ty::Char => {\n             vec![\n                 // The valid Unicode Scalar Value ranges.\n-                ConstantRange('\\u{0000}' as u128,\n-                              '\\u{D7FF}' as u128,\n-                              cx.tcx.types.char,\n-                              RangeEnd::Included\n+                ConstantRange(\n+                    '\\u{0000}' as u128,\n+                    '\\u{D7FF}' as u128,\n+                    cx.tcx.types.char,\n+                    RangeEnd::Included,\n+                    pcx.span,\n                 ),\n-                ConstantRange('\\u{E000}' as u128,\n-                              '\\u{10FFFF}' as u128,\n-                              cx.tcx.types.char,\n-                              RangeEnd::Included\n+                ConstantRange(\n+                    '\\u{E000}' as u128,\n+                    '\\u{10FFFF}' as u128,\n+                    cx.tcx.types.char,\n+                    RangeEnd::Included,\n+                    pcx.span,\n                 ),\n             ]\n         }\n         ty::Int(ity) => {\n             let bits = Integer::from_attr(&cx.tcx, SignedInt(ity)).size().bits() as u128;\n             let min = 1u128 << (bits - 1);\n             let max = min - 1;\n-            vec![ConstantRange(min, max, pcx.ty, RangeEnd::Included)]\n+            vec![ConstantRange(min, max, pcx.ty, RangeEnd::Included, pcx.span)]\n         }\n         ty::Uint(uty) => {\n             let size = Integer::from_attr(&cx.tcx, UnsignedInt(uty)).size();\n             let max = truncate(u128::max_value(), size);\n-            vec![ConstantRange(0, max, pcx.ty, RangeEnd::Included)]\n+            vec![ConstantRange(0, max, pcx.ty, RangeEnd::Included, pcx.span)]\n         }\n         _ => {\n             if cx.is_uninhabited(pcx.ty) {\n@@ -827,10 +868,11 @@ where\n ///\n /// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n /// around the (offset) space: i.e., `range.lo <= range.hi`.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n struct IntRange<'tcx> {\n     pub range: RangeInclusive<u128>,\n     pub ty: Ty<'tcx>,\n+    pub span: Span,\n }\n \n impl<'tcx> IntRange<'tcx> {\n@@ -860,6 +902,7 @@ impl<'tcx> IntRange<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &Const<'tcx>,\n+        span: Span,\n     ) -> Option<IntRange<'tcx>> {\n         if let Some((target_size, bias)) = Self::integral_size_and_signed_bias(tcx, value.ty) {\n             let ty = value.ty;\n@@ -877,7 +920,7 @@ impl<'tcx> IntRange<'tcx> {\n                 return None\n             };\n             let val = val ^ bias;\n-            Some(IntRange { range: val..=val, ty })\n+            Some(IntRange { range: val..=val, ty, span })\n         } else {\n             None\n         }\n@@ -890,6 +933,7 @@ impl<'tcx> IntRange<'tcx> {\n         hi: u128,\n         ty: Ty<'tcx>,\n         end: &RangeEnd,\n+        span: Span,\n     ) -> Option<IntRange<'tcx>> {\n         if Self::is_integral(ty) {\n             // Perform a shift if the underlying types are signed,\n@@ -901,7 +945,7 @@ impl<'tcx> IntRange<'tcx> {\n                 None\n             } else {\n                 let offset = (*end == RangeEnd::Excluded) as u128;\n-                Some(IntRange { range: lo..=(hi - offset), ty })\n+                Some(IntRange { range: lo..=(hi - offset), ty, span })\n             }\n         } else {\n             None\n@@ -916,8 +960,8 @@ impl<'tcx> IntRange<'tcx> {\n         // Floating-point ranges are permitted and we don't want\n         // to consider them when constructing integer ranges.\n         match ctor {\n-            ConstantRange(lo, hi, ty, end) => Self::from_range(tcx, *lo, *hi, ty, end),\n-            ConstantValue(val) => Self::from_const(tcx, param_env, val),\n+            ConstantRange(lo, hi, ty, end, span) => Self::from_range(tcx, *lo, *hi, ty, end, *span),\n+            ConstantValue(val, span) => Self::from_const(tcx, param_env, val, *span),\n             _ => None,\n         }\n     }\n@@ -930,7 +974,7 @@ impl<'tcx> IntRange<'tcx> {\n         loop {\n             match pat.kind {\n                 box PatKind::Constant { value } => {\n-                    return Self::from_const(tcx, param_env, value);\n+                    return Self::from_const(tcx, param_env, value, pat.span);\n                 }\n                 box PatKind::Range(PatRange { lo, hi, end }) => {\n                     return Self::from_range(\n@@ -939,6 +983,7 @@ impl<'tcx> IntRange<'tcx> {\n                         hi.eval_bits(tcx, param_env, hi.ty),\n                         &lo.ty,\n                         &end,\n+                        pat.span,\n                     );\n                 }\n                 box PatKind::AscribeUserType { ref subpattern, .. } => {\n@@ -965,14 +1010,15 @@ impl<'tcx> IntRange<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         ty: Ty<'tcx>,\n         r: RangeInclusive<u128>,\n+        span: Span,\n     ) -> Constructor<'tcx> {\n         let bias = IntRange::signed_bias(tcx, ty);\n         let (lo, hi) = r.into_inner();\n         if lo == hi {\n             let ty = ty::ParamEnv::empty().and(ty);\n-            ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty))\n+            ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty), span)\n         } else {\n-            ConstantRange(lo ^ bias, hi ^ bias, ty, RangeEnd::Included)\n+            ConstantRange(lo ^ bias, hi ^ bias, ty, RangeEnd::Included, span)\n         }\n     }\n \n@@ -995,17 +1041,23 @@ impl<'tcx> IntRange<'tcx> {\n             if lo > subrange_hi || subrange_lo > hi  {\n                 // The pattern doesn't intersect with the subrange at all,\n                 // so the subrange remains untouched.\n-                remaining_ranges.push(Self::range_to_ctor(tcx, ty, subrange_lo..=subrange_hi));\n+                remaining_ranges.push(\n+                    Self::range_to_ctor(tcx, ty, subrange_lo..=subrange_hi, self.span),\n+                );\n             } else {\n                 if lo > subrange_lo {\n                     // The pattern intersects an upper section of the\n                     // subrange, so a lower section will remain.\n-                    remaining_ranges.push(Self::range_to_ctor(tcx, ty, subrange_lo..=(lo - 1)));\n+                    remaining_ranges.push(\n+                        Self::range_to_ctor(tcx, ty, subrange_lo..=(lo - 1), self.span),\n+                    );\n                 }\n                 if hi < subrange_hi {\n                     // The pattern intersects a lower section of the\n                     // subrange, so an upper section will remain.\n-                    remaining_ranges.push(Self::range_to_ctor(tcx, ty, (hi + 1)..=subrange_hi));\n+                    remaining_ranges.push(\n+                        Self::range_to_ctor(tcx, ty, (hi + 1)..=subrange_hi, self.span),\n+                    );\n                 }\n             }\n         }\n@@ -1017,11 +1069,29 @@ impl<'tcx> IntRange<'tcx> {\n         let (lo, hi) = (*self.range.start(), *self.range.end());\n         let (other_lo, other_hi) = (*other.range.start(), *other.range.end());\n         if lo <= other_hi && other_lo <= hi {\n-            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), ty })\n+            let span = other.span;\n+            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), ty, span })\n         } else {\n             None\n         }\n     }\n+\n+    fn suspicious_intersection(&self, other: &Self) -> bool {\n+        // `false` in the following cases:\n+        // 1     ----      // 1  ----------   // 1 ----        // 1       ----\n+        // 2  ----------   // 2     ----      // 2       ----  // 2 ----\n+        //\n+        // The following are currently `false`, but could be `true` in the future (#64007):\n+        // 1 ---------       // 1     ---------\n+        // 2     ----------  // 2 ----------\n+        //\n+        // `true` in the following cases:\n+        // 1 -------          // 1       -------\n+        // 2       --------   // 2 -------\n+        let (lo, hi) = (*self.range.start(), *self.range.end());\n+        let (other_lo, other_hi) = (*other.range.start(), *other.range.end());\n+        (lo == other_hi || hi == other_lo)\n+    }\n }\n \n // A request for missing constructor data in terms of either:\n@@ -1127,6 +1197,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n     matrix: &Matrix<'p, 'tcx>,\n     v: &[&Pat<'tcx>],\n     witness: WitnessPreference,\n+    hir_id: HirId,\n ) -> Usefulness<'tcx> {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"is_useful({:#?}, {:#?})\", matrix, v);\n@@ -1149,6 +1220,10 @@ pub fn is_useful<'p, 'a, 'tcx>(\n \n     assert!(rows.iter().all(|r| r.len() == v.len()));\n \n+    let (ty, span) = rows.iter()\n+        .map(|r| (r[0].ty, r[0].span))\n+        .find(|(ty, _)| !ty.references_error())\n+        .unwrap_or((v[0].ty, v[0].span));\n     let pcx = PatCtxt {\n         // TyErr is used to represent the type of wildcard patterns matching\n         // against inaccessible (private) fields of structs, so that we won't\n@@ -1169,8 +1244,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n         // FIXME: this might lead to \"unstable\" behavior with macro hygiene\n         // introducing uninhabited patterns for inaccessible fields. We\n         // need to figure out how to model that.\n-        ty: rows.iter().map(|r| r[0].ty).find(|ty| !ty.references_error()).unwrap_or(v[0].ty),\n-        max_slice_length: max_slice_length(cx, rows.iter().map(|r| r[0]).chain(Some(v[0])))\n+        ty,\n+        max_slice_length: max_slice_length(cx, rows.iter().map(|r| r[0]).chain(Some(v[0]))),\n+        span,\n     };\n \n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v[0]);\n@@ -1184,9 +1260,9 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             Useful\n         } else {\n             split_grouped_constructors(\n-                cx.tcx, cx.param_env, constructors, matrix, pcx.ty,\n+                cx.tcx, cx.param_env, constructors, matrix, pcx.ty, pcx.span, Some(hir_id),\n             ).into_iter().map(|c|\n-                is_useful_specialized(cx, matrix, v, c, pcx.ty, witness)\n+                is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id)\n             ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n         }\n     } else {\n@@ -1239,8 +1315,11 @@ pub fn is_useful<'p, 'a, 'tcx>(\n             (pcx.ty.is_ptr_sized_integral() && !cx.tcx.features().precise_pointer_size_matching);\n \n         if cheap_missing_ctors == MissingCtors::Empty && !is_non_exhaustive {\n-            split_grouped_constructors(cx.tcx, cx.param_env, all_ctors, matrix, pcx.ty)\n-                .into_iter().map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness))\n+            split_grouped_constructors(\n+                cx.tcx, cx.param_env, all_ctors, matrix, pcx.ty, DUMMY_SP, None,\n+            )\n+                .into_iter()\n+                .map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness, hir_id))\n                 .find(|result| result.is_useful())\n                 .unwrap_or(NotUseful)\n         } else {\n@@ -1251,7 +1330,7 @@ pub fn is_useful<'p, 'a, 'tcx>(\n                     None\n                 }\n             }).collect();\n-            match is_useful(cx, &matrix, &v[1..], witness) {\n+            match is_useful(cx, &matrix, &v[1..], witness, hir_id) {\n                 UsefulWithWitness(pats) => {\n                     let cx = &*cx;\n                     // In this case, there's at least one \"free\"\n@@ -1344,6 +1423,7 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n     ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n     witness: WitnessPreference,\n+    hir_id: HirId,\n ) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n     let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n@@ -1361,7 +1441,7 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n             .collect()\n     );\n     match specialize(cx, v, &ctor, &wild_patterns) {\n-        Some(v) => match is_useful(cx, &matrix, &v, witness) {\n+        Some(v) => match is_useful(cx, &matrix, &v, witness, hir_id) {\n             UsefulWithWitness(witnesses) => UsefulWithWitness(\n                 witnesses.into_iter()\n                     .map(|witness| witness.apply_constructor(cx, &ctor, lty))\n@@ -1381,11 +1461,11 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n /// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n ///\n /// Returns `None` in case of a catch-all, which can't be specialized.\n-fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n-                          pat: &Pat<'tcx>,\n-                          pcx: PatCtxt<'tcx>)\n-                          -> Option<Vec<Constructor<'tcx>>>\n-{\n+fn pat_constructors<'tcx>(\n+    cx: &mut MatchCheckCtxt<'_, 'tcx>,\n+    pat: &Pat<'tcx>,\n+    pcx: PatCtxt<'tcx>,\n+) -> Option<Vec<Constructor<'tcx>>> {\n     match *pat.kind {\n         PatKind::AscribeUserType { ref subpattern, .. } =>\n             pat_constructors(cx, subpattern, pcx),\n@@ -1394,13 +1474,14 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n         PatKind::Variant { adt_def, variant_index, .. } => {\n             Some(vec![Variant(adt_def.variants[variant_index].def_id)])\n         }\n-        PatKind::Constant { value } => Some(vec![ConstantValue(value)]),\n+        PatKind::Constant { value } => Some(vec![ConstantValue(value, pat.span)]),\n         PatKind::Range(PatRange { lo, hi, end }) =>\n             Some(vec![ConstantRange(\n                 lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n                 hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n                 lo.ty,\n                 end,\n+                pat.span,\n             )]),\n         PatKind::Array { .. } => match pcx.ty.kind {\n             ty::Array(_, length) => Some(vec![\n@@ -1433,7 +1514,7 @@ fn constructor_arity(cx: &MatchCheckCtxt<'a, 'tcx>, ctor: &Constructor<'tcx>, ty\n         ty::Tuple(ref fs) => fs.len() as u64,\n         ty::Slice(..) | ty::Array(..) => match *ctor {\n             Slice(length) => length,\n-            ConstantValue(_) => 0,\n+            ConstantValue(..) => 0,\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         }\n         ty::Ref(..) => 1,\n@@ -1458,7 +1539,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx>(\n         ty::Tuple(ref fs) => fs.into_iter().map(|t| t.expect_ty()).collect(),\n         ty::Slice(ty) | ty::Array(ty, _) => match *ctor {\n             Slice(length) => (0..length).map(|_| ty).collect(),\n-            ConstantValue(_) => vec![],\n+            ConstantValue(..) => vec![],\n             _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n         }\n         ty::Ref(_, rty, _) => vec![rty],\n@@ -1556,8 +1637,8 @@ fn slice_pat_covered_by_const<'tcx>(\n // constructor is a range or constant with an integer type.\n fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>) -> bool {\n     let ty = match ctor {\n-        ConstantValue(value) => value.ty,\n-        ConstantRange(_, _, ty, _) => ty,\n+        ConstantValue(value, _) => value.ty,\n+        ConstantRange(_, _, ty, _, _) => ty,\n         _ => return false,\n     };\n     if let ty::Char | ty::Int(_) | ty::Uint(_) = ty.kind {\n@@ -1599,12 +1680,17 @@ fn should_treat_range_exhaustively(tcx: TyCtxt<'tcx>, ctor: &Constructor<'tcx>)\n /// boundaries for each interval range, sort them, then create constructors for each new interval\n /// between every pair of boundary points. (This essentially sums up to performing the intuitive\n /// merging operation depicted above.)\n+///\n+/// `hir_id` is `None` when we're evaluating the wildcard pattern, do not lint for overlapping in\n+/// ranges that case.\n fn split_grouped_constructors<'p, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ctors: Vec<Constructor<'tcx>>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n     ty: Ty<'tcx>,\n+    span: Span,\n+    hir_id: Option<HirId>,\n ) -> Vec<Constructor<'tcx>> {\n     let mut split_ctors = Vec::with_capacity(ctors.len());\n \n@@ -1621,7 +1707,7 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 /// Represents a border between 2 integers. Because the intervals spanning borders\n                 /// must be able to cover every integer, we need to be able to represent\n                 /// 2^128 + 1 such borders.\n-                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+                #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n                 enum Border {\n                     JustBefore(u128),\n                     AfterMax,\n@@ -1638,35 +1724,57 @@ fn split_grouped_constructors<'p, 'tcx>(\n                     vec![from, to].into_iter()\n                 }\n \n+                // Collect the span and range of all the intersecting ranges to lint on likely\n+                // incorrect range patterns. (#63987)\n+                let mut overlaps = vec![];\n                 // `borders` is the set of borders between equivalence classes: each equivalence\n                 // class lies between 2 borders.\n                 let row_borders = m.iter()\n-                    .flat_map(|row| IntRange::from_pat(tcx, param_env, row[0]))\n-                    .flat_map(|range| ctor_range.intersection(&range))\n+                    .flat_map(|row| {\n+                        IntRange::from_pat(tcx, param_env, row[0]).map(|r| (r, row.len()))\n+                    })\n+                    .flat_map(|(range, row_len)| {\n+                        let intersection = ctor_range.intersection(&range);\n+                        let should_lint = ctor_range.suspicious_intersection(&range);\n+                        if let (Some(range), 1, true) = (&intersection, row_len, should_lint) {\n+                            // FIXME: for now, only check for overlapping ranges on simple range\n+                            // patterns. Otherwise with the current logic the following is detected\n+                            // as overlapping:\n+                            //   match (10u8, true) {\n+                            //    (0 ..= 125, false) => {}\n+                            //    (126 ..= 255, false) => {}\n+                            //    (0 ..= 255, true) => {}\n+                            //  }\n+                            overlaps.push(range.clone());\n+                        }\n+                        intersection\n+                    })\n                     .flat_map(|range| range_borders(range));\n                 let ctor_borders = range_borders(ctor_range.clone());\n                 let mut borders: Vec<_> = row_borders.chain(ctor_borders).collect();\n                 borders.sort_unstable();\n \n+                lint_overlapping_patterns(tcx, hir_id, ctor_range, ty, overlaps);\n+\n                 // We're going to iterate through every pair of borders, making sure that each\n                 // represents an interval of nonnegative length, and convert each such interval\n                 // into a constructor.\n                 for IntRange { range, .. } in borders.windows(2).filter_map(|window| {\n                     match (window[0], window[1]) {\n                         (Border::JustBefore(n), Border::JustBefore(m)) => {\n                             if n < m {\n-                                Some(IntRange { range: n..=(m - 1), ty })\n+                                Some(IntRange { range: n..=(m - 1), ty, span })\n                             } else {\n                                 None\n                             }\n                         }\n                         (Border::JustBefore(n), Border::AfterMax) => {\n-                            Some(IntRange { range: n..=u128::MAX, ty })\n+                            Some(IntRange { range: n..=u128::MAX, ty, span })\n                         }\n                         (Border::AfterMax, _) => None,\n                     }\n                 }) {\n-                    split_ctors.push(IntRange::range_to_ctor(tcx, ty, range));\n+                    split_ctors.push(IntRange::range_to_ctor(tcx, ty, range, span));\n                 }\n             }\n             // Any other constructor can be used unchanged.\n@@ -1677,6 +1785,32 @@ fn split_grouped_constructors<'p, 'tcx>(\n     split_ctors\n }\n \n+fn lint_overlapping_patterns(\n+    tcx: TyCtxt<'tcx>,\n+    hir_id: Option<HirId>,\n+    ctor_range: IntRange<'tcx>,\n+    ty: Ty<'tcx>,\n+    overlaps: Vec<IntRange<'tcx>>,\n+) {\n+    if let (true, Some(hir_id)) = (!overlaps.is_empty(), hir_id) {\n+        let mut err = tcx.struct_span_lint_hir(\n+            lint::builtin::OVERLAPPING_PATTERNS,\n+            hir_id,\n+            ctor_range.span,\n+            \"multiple patterns covering the same range\",\n+        );\n+        err.span_label(ctor_range.span, \"overlapping patterns\");\n+        for int_range in overlaps {\n+            // Use the real type for user display of the ranges:\n+            err.span_label(int_range.span, &format!(\n+                \"this range overlaps on `{}`\",\n+                IntRange::range_to_ctor(tcx, ty, int_range.range, DUMMY_SP).display(tcx),\n+            ));\n+        }\n+        err.emit();\n+    }\n+}\n+\n fn constructor_covered_by_range<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -1701,13 +1835,13 @@ fn constructor_covered_by_range<'tcx>(\n         };\n     }\n     match *ctor {\n-        ConstantValue(value) => {\n+        ConstantValue(value, _) => {\n             let to = some_or_ok!(cmp_to(value));\n             let end = (to == Ordering::Less) ||\n                       (end == RangeEnd::Included && to == Ordering::Equal);\n             Ok(some_or_ok!(cmp_from(value)) && end)\n         },\n-        ConstantRange(from, to, ty, RangeEnd::Included) => {\n+        ConstantRange(from, to, ty, RangeEnd::Included, _) => {\n             let to = some_or_ok!(cmp_to(ty::Const::from_bits(\n                 tcx,\n                 to,\n@@ -1721,7 +1855,7 @@ fn constructor_covered_by_range<'tcx>(\n                 ty::ParamEnv::empty().and(ty),\n             ))) && end)\n         },\n-        ConstantRange(from, to, ty, RangeEnd::Excluded) => {\n+        ConstantRange(from, to, ty, RangeEnd::Excluded, _) => {\n             let to = some_or_ok!(cmp_to(ty::Const::from_bits(\n                 tcx,\n                 to,\n@@ -1915,7 +2049,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                         None\n                     }\n                 }\n-                ConstantValue(cv) => {\n+                ConstantValue(cv, _) => {\n                     match slice_pat_covered_by_const(\n                         cx.tcx, pat.span, cv, prefix, slice, suffix, cx.param_env,\n                     ) {"}, {"sha": "7bc4bf291ee488f5b61543b5b90ec71c197749f2", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -10,6 +10,7 @@ use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::lint;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n \n+use rustc::hir::HirId;\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -239,7 +240,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 .map(|pat| smallvec![pat.0])\n                 .collect();\n             let scrut_ty = self.tables.node_type(scrut.hir_id);\n-            check_exhaustive(cx, scrut_ty, scrut.span, &matrix);\n+            check_exhaustive(cx, scrut_ty, scrut.span, &matrix, scrut.hir_id);\n         })\n     }\n \n@@ -256,7 +257,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n                 expand_pattern(cx, pattern)\n             ]].into_iter().collect();\n \n-            let witnesses = match check_not_useful(cx, pattern_ty, &pats) {\n+            let witnesses = match check_not_useful(cx, pattern_ty, &pats, pat.hir_id) {\n                 Ok(_) => return,\n                 Err(err) => err,\n             };\n@@ -389,7 +390,7 @@ fn check_arms<'tcx>(\n         for &(pat, hir_pat) in pats {\n             let v = smallvec![pat];\n \n-            match is_useful(cx, &seen, &v, LeaveOutWitness) {\n+            match is_useful(cx, &seen, &v, LeaveOutWitness, hir_pat.hir_id) {\n                 NotUseful => {\n                     match source {\n                         hir::MatchSource::IfDesugar { .. } |\n@@ -465,9 +466,10 @@ fn check_not_useful(\n     cx: &mut MatchCheckCtxt<'_, 'tcx>,\n     ty: Ty<'tcx>,\n     matrix: &Matrix<'_, 'tcx>,\n+    hir_id: HirId,\n ) -> Result<(), Vec<super::Pat<'tcx>>> {\n     let wild_pattern = super::Pat { ty, span: DUMMY_SP, kind: box PatKind::Wild };\n-    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness) {\n+    match is_useful(cx, matrix, &[&wild_pattern], ConstructWitness, hir_id) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {\n             vec![wild_pattern]\n@@ -483,8 +485,9 @@ fn check_exhaustive<'tcx>(\n     scrut_ty: Ty<'tcx>,\n     sp: Span,\n     matrix: &Matrix<'_, 'tcx>,\n+    hir_id: HirId,\n ) {\n-    let witnesses = match check_not_useful(cx, scrut_ty, matrix) {\n+    let witnesses = match check_not_useful(cx, scrut_ty, matrix, hir_id) {\n         Ok(_) => return,\n         Err(err) => err,\n     };"}, {"sha": "7e17162dfb3ef0df1d79afabee9e8d98707b5ec4", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -312,10 +312,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n             }\n             PatKind::Range(PatRange { lo, hi, end }) => {\n                 write!(f, \"{}\", lo)?;\n-                match end {\n-                    RangeEnd::Included => write!(f, \"..=\")?,\n-                    RangeEnd::Excluded => write!(f, \"..\")?,\n-                }\n+                write!(f, \"{}\", end)?;\n                 write!(f, \"{}\", hi)\n             }\n             PatKind::Slice { ref prefix, ref slice, ref suffix } |"}, {"sha": "677e2ea3566281fa0800b1c9bacd6e9ef04d980f", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -350,11 +350,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // If the span is from a macro, then it's hard to extract the text\n         // and make a good suggestion, so don't bother.\n-        let is_desugaring = match sp.desugaring_kind() {\n-            Some(k) => sp.is_desugaring(k),\n-            None => false\n-        };\n-        let is_macro = sp.from_expansion() && !is_desugaring;\n+        let is_macro = sp.from_expansion() && sp.desugaring_kind().is_none();\n \n         // `ExprKind::DropTemps` is semantically irrelevant for these suggestions.\n         let expr = expr.peel_drop_temps();"}, {"sha": "c258892057bf26be1598d0445d5f34feedc209cc", "filename": "src/test/ui/associated-const/associated-const-type-parameter-arrays-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-type-parameter-arrays-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-type-parameter-arrays-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-type-parameter-arrays-2.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,10 +4,10 @@ error[E0277]: the trait bound `A: Foo` is not satisfied\n LL |     const Y: usize;\n    |     --------------- required by `Foo::Y`\n ...\n+LL | pub fn test<A: Foo, B: Foo>() {\n+   |             -- help: consider further restricting this bound: `A: Foo +`\n LL |     let _array = [4; <A as Foo>::Y];\n    |                      ^^^^^^^^^^^^^ the trait `Foo` is not implemented for `A`\n-   |\n-   = help: consider adding a `where A: Foo` bound\n \n error: aborting due to previous error\n "}, {"sha": "f6c8e99e27a8158cfd0276f0d789350a498a9a50", "filename": "src/test/ui/associated-const/associated-const-type-parameter-arrays.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-type-parameter-arrays.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-type-parameter-arrays.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-type-parameter-arrays.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,10 +4,10 @@ error[E0277]: the trait bound `A: Foo` is not satisfied\n LL |     const Y: usize;\n    |     --------------- required by `Foo::Y`\n ...\n+LL | pub fn test<A: Foo, B: Foo>() {\n+   |             -- help: consider further restricting this bound: `A: Foo +`\n LL |     let _array: [u32; <A as Foo>::Y];\n    |                       ^^^^^^^^^^^^^ the trait `Foo` is not implemented for `A`\n-   |\n-   = help: consider adding a `where A: Foo` bound\n \n error: aborting due to previous error\n "}, {"sha": "9f6a73cfe39104f15fe8a5564f00e2747f0dc566", "filename": "src/test/ui/associated-type-bounds/bad-bounds-on-assoc-in-trait.stderr", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -9,7 +9,10 @@ LL | impl Case1 for S1 {\n error[E0277]: `<<T as Case1>::C as std::iter::Iterator>::Item` is not an iterator\n   --> $DIR/bad-bounds-on-assoc-in-trait.rs:37:1\n    |\n-LL | / fn assume_case1<T: Case1>() {\n+LL |   fn assume_case1<T: Case1>() {\n+   |   ^                          - help: consider further restricting the associated type: `where <<T as Case1>::C as std::iter::Iterator>::Item: std::iter::Iterator`\n+   |  _|\n+   | |\n LL | |\n LL | |\n LL | |\n@@ -19,15 +22,17 @@ LL | | }\n    | |_^ `<<T as Case1>::C as std::iter::Iterator>::Item` is not an iterator\n    |\n    = help: the trait `std::iter::Iterator` is not implemented for `<<T as Case1>::C as std::iter::Iterator>::Item`\n-   = help: consider adding a `where <<T as Case1>::C as std::iter::Iterator>::Item: std::iter::Iterator` bound\n \n error[E0277]: `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be sent between threads safely\n   --> $DIR/bad-bounds-on-assoc-in-trait.rs:37:1\n    |\n LL |   trait Case1 {\n    |   ----------- required by `Case1`\n ...\n-LL | / fn assume_case1<T: Case1>() {\n+LL |   fn assume_case1<T: Case1>() {\n+   |   ^                          - help: consider further restricting the associated type: `where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Send`\n+   |  _|\n+   | |\n LL | |\n LL | |\n LL | |\n@@ -37,15 +42,17 @@ LL | | }\n    | |_^ `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be sent between threads safely\n    |\n    = help: the trait `std::marker::Send` is not implemented for `<<T as Case1>::C as std::iter::Iterator>::Item`\n-   = help: consider adding a `where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Send` bound\n \n error[E0277]: `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be shared between threads safely\n   --> $DIR/bad-bounds-on-assoc-in-trait.rs:37:1\n    |\n LL |   trait Case1 {\n    |   ----------- required by `Case1`\n ...\n-LL | / fn assume_case1<T: Case1>() {\n+LL |   fn assume_case1<T: Case1>() {\n+   |   ^                          - help: consider further restricting the associated type: `where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Sync`\n+   |  _|\n+   | |\n LL | |\n LL | |\n LL | |\n@@ -55,7 +62,6 @@ LL | | }\n    | |_^ `<<T as Case1>::C as std::iter::Iterator>::Item` cannot be shared between threads safely\n    |\n    = help: the trait `std::marker::Sync` is not implemented for `<<T as Case1>::C as std::iter::Iterator>::Item`\n-   = help: consider adding a `where <<T as Case1>::C as std::iter::Iterator>::Item: std::marker::Sync` bound\n \n error[E0277]: `<_ as Lam<&'a u8>>::App` doesn't implement `std::fmt::Debug`\n   --> $DIR/bad-bounds-on-assoc-in-trait.rs:37:1"}, {"sha": "cc47f31d0045687a8a7f38a27756fb1635ba9398", "filename": "src/test/ui/associated-types/associated-types-bound-failure.fixed", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.fixed?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -0,0 +1,29 @@\n+// run-rustfix\n+// Test equality constraints on associated types in a where clause.\n+#![allow(dead_code)]\n+\n+pub trait ToInt {\n+    fn to_int(&self) -> isize;\n+}\n+\n+pub trait GetToInt\n+{\n+    type R;\n+\n+    fn get(&self) -> <Self as GetToInt>::R;\n+}\n+\n+fn foo<G>(g: G) -> isize\n+    where G : GetToInt, <G as GetToInt>::R: ToInt \n+{\n+    ToInt::to_int(&g.get()) //~ ERROR E0277\n+}\n+\n+fn bar<G : GetToInt>(g: G) -> isize\n+    where G::R : ToInt\n+{\n+    ToInt::to_int(&g.get()) // OK\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "31e073cc7a8bde695fe07ad887dae1c4677ea596", "filename": "src/test/ui/associated-types/associated-types-bound-failure.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,4 +1,6 @@\n+// run-rustfix\n // Test equality constraints on associated types in a where clause.\n+#![allow(dead_code)]\n \n pub trait ToInt {\n     fn to_int(&self) -> isize;"}, {"sha": "c420c86a2758f1b696d9df295e80dee25902750e", "filename": "src/test/ui/associated-types/associated-types-bound-failure.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-bound-failure.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,13 +1,14 @@\n error[E0277]: the trait bound `<G as GetToInt>::R: ToInt` is not satisfied\n-  --> $DIR/associated-types-bound-failure.rs:17:19\n+  --> $DIR/associated-types-bound-failure.rs:19:19\n    |\n LL |     fn to_int(&self) -> isize;\n    |     -------------------------- required by `ToInt::to_int`\n ...\n+LL |     where G : GetToInt\n+   |                       - help: consider further restricting the associated type: `, <G as GetToInt>::R: ToInt`\n+LL | {\n LL |     ToInt::to_int(&g.get())\n    |                   ^^^^^^^^ the trait `ToInt` is not implemented for `<G as GetToInt>::R`\n-   |\n-   = help: consider adding a `where <G as GetToInt>::R: ToInt` bound\n \n error: aborting due to previous error\n "}, {"sha": "aa23326506f63e6b2f097a41a5048205104d4739", "filename": "src/test/ui/associated-types/associated-types-for-unimpl-trait.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.fixed?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+#![allow(unused_variables)]\n+\n+trait Get {\n+    type Value;\n+    fn get(&self) -> <Self as Get>::Value;\n+}\n+\n+trait Other {\n+    fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get  {}\n+    //~^ ERROR the trait bound `Self: Get` is not satisfied\n+}\n+\n+fn main() {\n+}"}, {"sha": "0f6cea8e69fcf29ef4e43816581e868427216875", "filename": "src/test/ui/associated-types/associated-types-for-unimpl-trait.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,3 +1,6 @@\n+// run-rustfix\n+#![allow(unused_variables)]\n+\n trait Get {\n     type Value;\n     fn get(&self) -> <Self as Get>::Value;"}, {"sha": "83d5390417e77c771b336a27c610e6ffa69d0ff4", "filename": "src/test/ui/associated-types/associated-types-for-unimpl-trait.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-for-unimpl-trait.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,10 +1,11 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-for-unimpl-trait.rs:7:5\n+  --> $DIR/associated-types-for-unimpl-trait.rs:10:5\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n-   |\n-   = help: consider adding a `where Self: Get` bound\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-^^\n+   |     |                                                       |\n+   |     |                                                       help: consider further restricting `Self`: `where Self: Get`\n+   |     the trait `Get` is not implemented for `Self`\n \n error: aborting due to previous error\n "}, {"sha": "0b8b7fab1359ffcaafd27b7d0c530f364fb98ab4", "filename": "src/test/ui/associated-types/associated-types-invalid-trait-ref-issue-18865.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-invalid-trait-ref-issue-18865.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-invalid-trait-ref-issue-18865.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-invalid-trait-ref-issue-18865.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,10 +1,10 @@\n error[E0277]: the trait bound `T: Foo<usize>` is not satisfied\n   --> $DIR/associated-types-invalid-trait-ref-issue-18865.rs:10:12\n    |\n+LL | fn f<T:Foo<isize>>(t: &T) {\n+   |      -- help: consider further restricting this bound: `T: Foo<usize> +`\n LL |     let u: <T as Foo<usize>>::Bar = t.get_bar();\n    |            ^^^^^^^^^^^^^^^^^^^^^^ the trait `Foo<usize>` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: Foo<usize>` bound\n \n error: aborting due to previous error\n "}, {"sha": "78198322913c7579fd92590525fb33c46843e0d6", "filename": "src/test/ui/associated-types/associated-types-no-suitable-bound.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-bound.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,9 +2,10 @@ error[E0277]: the trait bound `T: Get` is not satisfied\n   --> $DIR/associated-types-no-suitable-bound.rs:11:5\n    |\n LL |     fn uhoh<T>(foo: <T as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: Get` bound\n+   |     ^^^^^^^^-^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |     |       |\n+   |     |       help: consider restricting this bound: `T: Get`\n+   |     the trait `Get` is not implemented for `T`\n \n error: aborting due to previous error\n "}, {"sha": "6aa0403088d3c1586facd10853ced9358efacd3e", "filename": "src/test/ui/associated-types/associated-types-no-suitable-supertrait-2.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait-2.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,9 +2,10 @@ error[E0277]: the trait bound `Self: Get` is not satisfied\n   --> $DIR/associated-types-no-suitable-supertrait-2.rs:17:5\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n-   |\n-   = help: consider adding a `where Self: Get` bound\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-^^\n+   |     |                                                       |\n+   |     |                                                       help: consider further restricting `Self`: `where Self: Get`\n+   |     the trait `Get` is not implemented for `Self`\n \n error: aborting due to previous error\n "}, {"sha": "8c242be979611c32df6c6e44b85592177909c89b", "filename": "src/test/ui/associated-types/associated-types-no-suitable-supertrait.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-no-suitable-supertrait.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,9 +2,10 @@ error[E0277]: the trait bound `Self: Get` is not satisfied\n   --> $DIR/associated-types-no-suitable-supertrait.rs:17:5\n    |\n LL |     fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n-   |\n-   = help: consider adding a `where Self: Get` bound\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-^^\n+   |     |                                                       |\n+   |     |                                                       help: consider further restricting `Self`: `where Self: Get`\n+   |     the trait `Get` is not implemented for `Self`\n \n error[E0277]: the trait bound `(T, U): Get` is not satisfied\n   --> $DIR/associated-types-no-suitable-supertrait.rs:22:5"}, {"sha": "f357045a456e604be9652adf46c5e958ed761756", "filename": "src/test/ui/associated-types/associated-types-projection-to-unrelated-trait-in-method-without-default.fixed", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.fixed?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -0,0 +1,30 @@\n+// run-rustfix\n+// Check that we get an error when you use `<Self as Get>::Value` in\n+// the trait definition even if there is no default method.\n+\n+trait Get {\n+    type Value;\n+}\n+\n+trait Other {\n+    fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value) where Self: Get ;\n+    //~^ ERROR E0277\n+}\n+\n+impl Get for () {\n+    type Value = f32;\n+}\n+\n+impl Get for f64 {\n+    type Value = u32;\n+}\n+\n+impl Other for () {\n+    fn okay<U:Get>(&self, _foo: U, _bar: <Self as Get>::Value) { }\n+}\n+\n+impl Other for f64 {\n+    fn okay<U:Get>(&self, _foo: U, _bar: <Self as Get>::Value) { }\n+}\n+\n+fn main() { }"}, {"sha": "549fc8fc618e03d7b2155a2c294ac01f9ddd935b", "filename": "src/test/ui/associated-types/associated-types-projection-to-unrelated-trait-in-method-without-default.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n // Check that we get an error when you use `<Self as Get>::Value` in\n // the trait definition even if there is no default method.\n "}, {"sha": "cb01488fa34d46d417c1c6269199dbdea2ceaee6", "filename": "src/test/ui/associated-types/associated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-projection-to-unrelated-trait-in-method-without-default.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,10 +1,11 @@\n error[E0277]: the trait bound `Self: Get` is not satisfied\n-  --> $DIR/associated-types-projection-to-unrelated-trait-in-method-without-default.rs:9:5\n+  --> $DIR/associated-types-projection-to-unrelated-trait-in-method-without-default.rs:10:5\n    |\n LL |     fn okay<U:Get>(&self, foo: U, bar: <Self as Get>::Value);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Get` is not implemented for `Self`\n-   |\n-   = help: consider adding a `where Self: Get` bound\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |                                                       |\n+   |     |                                                       help: consider further restricting `Self`: `where Self: Get`\n+   |     the trait `Get` is not implemented for `Self`\n \n error: aborting due to previous error\n "}, {"sha": "f780d171fee8e029030a462fb5a6fd0370af26a1", "filename": "src/test/ui/associated-types/associated-types-unsized.fixed", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.fixed?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+#![allow(dead_code, unused_variables)]\n+\n+trait Get {\n+    type Value: ?Sized;\n+    fn get(&self) -> <Self as Get>::Value;\n+}\n+\n+fn foo<T:Get>(t: T) where <T as Get>::Value: std::marker::Sized  {\n+    let x = t.get(); //~ ERROR the size for values of type\n+}\n+\n+fn main() {\n+}"}, {"sha": "bdba4c7ff16a10344f5465b87147da0cb55de27b", "filename": "src/test/ui/associated-types/associated-types-unsized.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,3 +1,6 @@\n+// run-rustfix\n+#![allow(dead_code, unused_variables)]\n+\n trait Get {\n     type Value: ?Sized;\n     fn get(&self) -> <Self as Get>::Value;"}, {"sha": "2352ac4ad3822cdd0770c326b4d4ecf76dfb3815", "filename": "src/test/ui/associated-types/associated-types-unsized.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-unsized.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,12 +1,13 @@\n error[E0277]: the size for values of type `<T as Get>::Value` cannot be known at compilation time\n-  --> $DIR/associated-types-unsized.rs:7:9\n+  --> $DIR/associated-types-unsized.rs:10:9\n    |\n+LL | fn foo<T:Get>(t: T) {\n+   |                    - help: consider further restricting the associated type: `where <T as Get>::Value: std::marker::Sized`\n LL |     let x = t.get();\n    |         ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `<T as Get>::Value`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where <T as Get>::Value: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n "}, {"sha": "740667f1466801c4605a3ddf6ce2967021c9de91", "filename": "src/test/ui/bad/bad-method-typaram-kind.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fbad%2Fbad-method-typaram-kind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fbad%2Fbad-method-typaram-kind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-method-typaram-kind.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,11 +1,12 @@\n error[E0277]: `T` cannot be sent between threads safely\n   --> $DIR/bad-method-typaram-kind.rs:2:7\n    |\n+LL | fn foo<T:'static>() {\n+   |        -- help: consider further restricting this bound: `T: std::marker::Send +`\n LL |     1.bar::<T>();\n    |       ^^^ `T` cannot be sent between threads safely\n    |\n    = help: the trait `std::marker::Send` is not implemented for `T`\n-   = help: consider adding a `where T: std::marker::Send` bound\n \n error: aborting due to previous error\n "}, {"sha": "5be6ab05d6607d014eadda611c8bc6f5494cd116", "filename": "src/test/ui/builtin-superkinds/builtin-superkinds-double-superkind.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-double-superkind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-double-superkind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-double-superkind.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,20 +2,22 @@ error[E0277]: `T` cannot be sent between threads safely\n   --> $DIR/builtin-superkinds-double-superkind.rs:6:24\n    |\n LL | impl <T: Sync+'static> Foo for (T,) { }\n-   |                        ^^^ `T` cannot be sent between threads safely\n+   |       --               ^^^ `T` cannot be sent between threads safely\n+   |       |\n+   |       help: consider further restricting this bound: `T: std::marker::Send +`\n    |\n    = help: within `(T,)`, the trait `std::marker::Send` is not implemented for `T`\n-   = help: consider adding a `where T: std::marker::Send` bound\n    = note: required because it appears within the type `(T,)`\n \n error[E0277]: `T` cannot be shared between threads safely\n   --> $DIR/builtin-superkinds-double-superkind.rs:9:16\n    |\n LL | impl <T: Send> Foo for (T,T) { }\n-   |                ^^^ `T` cannot be shared between threads safely\n+   |       --       ^^^ `T` cannot be shared between threads safely\n+   |       |\n+   |       help: consider further restricting this bound: `T: std::marker::Sync +`\n    |\n    = help: within `(T, T)`, the trait `std::marker::Sync` is not implemented for `T`\n-   = help: consider adding a `where T: std::marker::Sync` bound\n    = note: required because it appears within the type `(T, T)`\n \n error: aborting due to 2 previous errors"}, {"sha": "8cce9bfdf52a82915d1ff85c07e1f0eb9f557fb7", "filename": "src/test/ui/builtin-superkinds/builtin-superkinds-in-metadata.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-in-metadata.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-in-metadata.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-in-metadata.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,10 +2,11 @@ error[E0277]: `T` cannot be sent between threads safely\n   --> $DIR/builtin-superkinds-in-metadata.rs:13:23\n    |\n LL | impl <T:Sync+'static> RequiresRequiresShareAndSend for X<T> { }\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `T` cannot be sent between threads safely\n+   |       --              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `T` cannot be sent between threads safely\n+   |       |\n+   |       help: consider further restricting this bound: `T: std::marker::Send +`\n    |\n    = help: within `X<T>`, the trait `std::marker::Send` is not implemented for `T`\n-   = help: consider adding a `where T: std::marker::Send` bound\n    = note: required because it appears within the type `X<T>`\n \n error: aborting due to previous error"}, {"sha": "4381a5b8682628a4274b9dd262db6326180e9ec2", "filename": "src/test/ui/builtin-superkinds/builtin-superkinds-typaram-not-send.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-typaram-not-send.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-typaram-not-send.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbuiltin-superkinds%2Fbuiltin-superkinds-typaram-not-send.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,10 +2,11 @@ error[E0277]: `T` cannot be sent between threads safely\n   --> $DIR/builtin-superkinds-typaram-not-send.rs:5:24\n    |\n LL | impl <T: Sync+'static> Foo for T { }\n-   |                        ^^^ `T` cannot be sent between threads safely\n+   |       --               ^^^ `T` cannot be sent between threads safely\n+   |       |\n+   |       help: consider further restricting this bound: `T: std::marker::Send +`\n    |\n    = help: the trait `std::marker::Send` is not implemented for `T`\n-   = help: consider adding a `where T: std::marker::Send` bound\n \n error: aborting due to previous error\n "}, {"sha": "5c6834459f0d4021538bb4f5f6ca5d4b5f9fe80f", "filename": "src/test/ui/check_match/issue-43253.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,7 +1,7 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n-\n+// check-pass\n #![feature(exclusive_range_pattern)]\n #![warn(unreachable_patterns)]\n+#![warn(overlapping_patterns)]\n \n fn main() {\n     // These cases should generate no warning.\n@@ -13,7 +13,7 @@ fn main() {\n \n     match 10 {\n         1..10 => {},\n-        9..=10 => {},\n+        9..=10 => {}, //~ WARNING multiple patterns covering the same range\n         _ => {},\n     }\n \n@@ -23,22 +23,25 @@ fn main() {\n         _ => {},\n     }\n \n-    // These cases should generate an \"unreachable pattern\" warning.\n+    // These cases should generate \"unreachable pattern\" warnings.\n     match 10 {\n         1..10 => {},\n-        9 => {},\n+        9 => {}, //~ WARNING unreachable pattern\n         _ => {},\n     }\n \n     match 10 {\n         1..10 => {},\n-        8..=9 => {},\n+        8..=9 => {}, //~ WARNING multiple patterns covering the same range\n         _ => {},\n     }\n \n     match 10 {\n-        1..10 => {},\n-        9..=9 => {},\n+        5..7 => {},\n+        6 => {}, //~ WARNING unreachable pattern\n+        1..10 => {}, //~ WARNING multiple patterns covering the same range\n+        9..=9 => {}, //~ WARNING unreachable pattern\n+        6 => {}, //~ WARNING unreachable pattern\n         _ => {},\n     }\n }"}, {"sha": "cb4a0486eef9ab244f6884659a7dc1a2982a649d", "filename": "src/test/ui/check_match/issue-43253.stderr", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-43253.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,11 +1,25 @@\n+warning: multiple patterns covering the same range\n+  --> $DIR/issue-43253.rs:16:9\n+   |\n+LL |         1..10 => {},\n+   |         ----- this range overlaps on `9i32`\n+LL |         9..=10 => {},\n+   |         ^^^^^^ overlapping patterns\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-43253.rs:4:9\n+   |\n+LL | #![warn(overlapping_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n warning: unreachable pattern\n   --> $DIR/issue-43253.rs:29:9\n    |\n LL |         9 => {},\n    |         ^\n    |\n note: lint level defined here\n-  --> $DIR/issue-43253.rs:4:9\n+  --> $DIR/issue-43253.rs:3:9\n    |\n LL | #![warn(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n@@ -19,6 +33,18 @@ LL |         8..=9 => {},\n warning: unreachable pattern\n   --> $DIR/issue-43253.rs:41:9\n    |\n+LL |         6 => {},\n+   |         ^\n+\n+warning: unreachable pattern\n+  --> $DIR/issue-43253.rs:43:9\n+   |\n LL |         9..=9 => {},\n    |         ^^^^^\n \n+warning: unreachable pattern\n+  --> $DIR/issue-43253.rs:44:9\n+   |\n+LL |         6 => {},\n+   |         ^\n+"}, {"sha": "3c8f637e13369722bcb1157496ac9e677851272c", "filename": "src/test/ui/closures/closure-bounds-cant-promote-superkind-in-struct.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fclosures%2Fclosure-bounds-cant-promote-superkind-in-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fclosures%2Fclosure-bounds-cant-promote-superkind-in-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-bounds-cant-promote-superkind-in-struct.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,14 +4,16 @@ error[E0277]: `F` cannot be sent between threads safely\n LL |   struct X<F> where F: FnOnce() + 'static + Send {\n    |   ---------------------------------------------- required by `X`\n ...\n-LL | / fn foo<F>(blk: F) -> X<F> where F: FnOnce() + 'static {\n+LL |   fn foo<F>(blk: F) -> X<F> where F: FnOnce() + 'static {\n+   |   ^                                                    - help: consider further restricting type parameter `F`: `, F: std::marker::Send`\n+   |  _|\n+   | |\n LL | |\n LL | |     return X { field: blk };\n LL | | }\n    | |_^ `F` cannot be sent between threads safely\n    |\n    = help: the trait `std::marker::Send` is not implemented for `F`\n-   = help: consider adding a `where F: std::marker::Send` bound\n \n error: aborting due to previous error\n "}, {"sha": "05d5bb1e8d5a8d35fdada3b1859c57d02022f3cb", "filename": "src/test/ui/closures/closure-bounds-subtype.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fclosures%2Fclosure-bounds-subtype.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fclosures%2Fclosure-bounds-subtype.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-bounds-subtype.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,11 +4,13 @@ error[E0277]: `F` cannot be shared between threads safely\n LL | fn take_const_owned<F>(_: F) where F: FnOnce() + Sync + Send {\n    |    ----------------                              ---- required by this bound in `take_const_owned`\n ...\n+LL | fn give_owned<F>(f: F) where F: FnOnce() + Send {\n+   |                                                - help: consider further restricting type parameter `F`: `, F: std::marker::Sync`\n+LL |     take_any(f);\n LL |     take_const_owned(f);\n    |                      ^ `F` cannot be shared between threads safely\n    |\n    = help: the trait `std::marker::Sync` is not implemented for `F`\n-   = help: consider adding a `where F: std::marker::Sync` bound\n \n error: aborting due to previous error\n "}, {"sha": "2fb9977f4d700a87d0fed2afab0fbc2ec5fc5f06", "filename": "src/test/ui/consts/too_generic_eval_ice.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -16,26 +16,30 @@ error[E0277]: the size for values of type `A` cannot be known at compilation tim\n    |\n LL | pub struct Foo<A, B>(A, B);\n    | --------------------------- required by `Foo`\n+LL | \n+LL | impl<A, B> Foo<A, B> {\n+   |      - help: consider restricting this bound: `A: std::marker::Sized`\n ...\n LL |         [5; Self::HOST_SIZE] == [6; 0]\n    |             ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `A`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where A: std::marker::Sized` bound\n \n error[E0277]: the size for values of type `B` cannot be known at compilation time\n   --> $DIR/too_generic_eval_ice.rs:7:13\n    |\n LL | pub struct Foo<A, B>(A, B);\n    | --------------------------- required by `Foo`\n+LL | \n+LL | impl<A, B> Foo<A, B> {\n+   |         - help: consider restricting this bound: `B: std::marker::Sized`\n ...\n LL |         [5; Self::HOST_SIZE] == [6; 0]\n    |             ^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `B`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where B: std::marker::Sized` bound\n \n error: aborting due to 3 previous errors\n "}, {"sha": "40db575eabd38c5c278385ddb7877e446521e0c9", "filename": "src/test/ui/dst/dst-object-from-unsized-type.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fdst%2Fdst-object-from-unsized-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fdst%2Fdst-object-from-unsized-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-object-from-unsized-type.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,23 +1,25 @@\n error[E0277]: the size for values of type `T` cannot be known at compilation time\n   --> $DIR/dst-object-from-unsized-type.rs:8:23\n    |\n+LL | fn test1<T: ?Sized + Foo>(t: &T) {\n+   |          -- help: consider further restricting this bound: `T: std::marker::Sized +`\n LL |     let u: &dyn Foo = t;\n    |                       ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where T: std::marker::Sized` bound\n    = note: required for the cast to the object type `dyn Foo`\n \n error[E0277]: the size for values of type `T` cannot be known at compilation time\n   --> $DIR/dst-object-from-unsized-type.rs:13:23\n    |\n+LL | fn test2<T: ?Sized + Foo>(t: &T) {\n+   |          -- help: consider further restricting this bound: `T: std::marker::Sized +`\n LL |     let v: &dyn Foo = t as &dyn Foo;\n    |                       ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where T: std::marker::Sized` bound\n    = note: required for the cast to the object type `dyn Foo`\n \n error[E0277]: the size for values of type `str` cannot be known at compilation time"}, {"sha": "59f749198971b5a1931817cdc9a91e48380d1476", "filename": "src/test/ui/exhaustive_integer_patterns.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,7 +1,7 @@\n #![feature(precise_pointer_size_matching)]\n #![feature(exclusive_range_pattern)]\n-\n #![deny(unreachable_patterns)]\n+#![deny(overlapping_patterns)]\n \n use std::{char, u8, u16, u32, u64, u128, i8, i16, i32, i64, i128};\n \n@@ -41,7 +41,8 @@ fn main() {\n     match x { //~ ERROR non-exhaustive patterns\n         -7 => {}\n         -5..=120 => {}\n-        -2..=20 => {} //~ ERROR unreachable pattern\n+        -2..=20 => {}\n+        //~^ ERROR unreachable pattern\n         125 => {}\n     }\n \n@@ -135,9 +136,9 @@ fn main() {\n         (125 .. 128, false) => {}\n     }\n \n-    match 0u8 { // ok\n+    match 0u8 {\n         0 .. 2 => {}\n-        1 ..= 2 => {}\n+        1 ..= 2 => {} //~ ERROR multiple patterns covering the same range\n         _ => {}\n     }\n "}, {"sha": "7a3a36a820c65cfc1540aae208b095030f99d11c", "filename": "src/test/ui/exhaustive_integer_patterns.stderr", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexhaustive_integer_patterns.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -5,7 +5,7 @@ LL |         200 => {}\n    |         ^^^\n    |\n note: lint level defined here\n-  --> $DIR/exhaustive_integer_patterns.rs:4:9\n+  --> $DIR/exhaustive_integer_patterns.rs:3:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n@@ -41,69 +41,83 @@ LL |     match x {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `std::i8::MIN` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:82:11\n+  --> $DIR/exhaustive_integer_patterns.rs:83:11\n    |\n LL |     match 0i8 {\n    |           ^^^ pattern `std::i8::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `0i16` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:90:11\n+  --> $DIR/exhaustive_integer_patterns.rs:91:11\n    |\n LL |     match 0i16 {\n    |           ^^^^ pattern `0i16` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `128u8..=std::u8::MAX` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:108:11\n+  --> $DIR/exhaustive_integer_patterns.rs:109:11\n    |\n LL |     match 0u8 {\n    |           ^^^ pattern `128u8..=std::u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `(0u8, Some(_))` and `(2u8..=std::u8::MAX, Some(_))` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:120:11\n+  --> $DIR/exhaustive_integer_patterns.rs:121:11\n    |\n LL |     match (0u8, Some(())) {\n    |           ^^^^^^^^^^^^^^^ patterns `(0u8, Some(_))` and `(2u8..=std::u8::MAX, Some(_))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `(126u8..=127u8, false)` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:125:11\n+  --> $DIR/exhaustive_integer_patterns.rs:126:11\n    |\n LL |     match (0u8, true) {\n    |           ^^^^^^^^^^^ pattern `(126u8..=127u8, false)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n+error: multiple patterns covering the same range\n+  --> $DIR/exhaustive_integer_patterns.rs:141:9\n+   |\n+LL |         0 .. 2 => {}\n+   |         ------ this range overlaps on `1u8`\n+LL |         1 ..= 2 => {}\n+   |         ^^^^^^^ overlapping patterns\n+   |\n+note: lint level defined here\n+  --> $DIR/exhaustive_integer_patterns.rs:4:9\n+   |\n+LL | #![deny(overlapping_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n error[E0004]: non-exhaustive patterns: `std::u128::MAX` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:145:11\n+  --> $DIR/exhaustive_integer_patterns.rs:146:11\n    |\n LL |     match 0u128 {\n    |           ^^^^^ pattern `std::u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `5u128..=std::u128::MAX` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:149:11\n+  --> $DIR/exhaustive_integer_patterns.rs:150:11\n    |\n LL |     match 0u128 {\n    |           ^^^^^ pattern `5u128..=std::u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n error[E0004]: non-exhaustive patterns: `0u128..=3u128` not covered\n-  --> $DIR/exhaustive_integer_patterns.rs:153:11\n+  --> $DIR/exhaustive_integer_patterns.rs:154:11\n    |\n LL |     match 0u128 {\n    |           ^^^^^ pattern `0u128..=3u128` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 14 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}, {"sha": "afcb467ad471170a2e9503b2edf7404dc1218182", "filename": "src/test/ui/hrtb/hrtb-higher-ranker-supertraits-transitive.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -6,10 +6,11 @@ LL | fn want_bar_for_any_ccx<B>(b: &B)\n LL |     where B : for<'ccx> Bar<'ccx>\n    |               ------------------- required by this bound in `want_bar_for_any_ccx`\n ...\n+LL |     where B : Qux\n+   |                  - help: consider further restricting type parameter `B`: `, for<'ccx> B: Bar<'ccx>`\n+...\n LL |     want_bar_for_any_ccx(b);\n    |                          ^ the trait `for<'ccx> Bar<'ccx>` is not implemented for `B`\n-   |\n-   = help: consider adding a `where for<'ccx> B: Bar<'ccx>` bound\n \n error: aborting due to previous error\n "}, {"sha": "20913b4f28c8e7a3da9aa9ed4d874e126a1f5ff1", "filename": "src/test/ui/hrtb/hrtb-higher-ranker-supertraits.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,28 +1,30 @@\n error[E0277]: the trait bound `for<'tcx> F: Foo<'tcx>` is not satisfied\n   --> $DIR/hrtb-higher-ranker-supertraits.rs:18:26\n    |\n+LL |     where F : Foo<'x>\n+   |                      - help: consider further restricting type parameter `F`: `, for<'tcx> F: Foo<'tcx>`\n+...\n LL |     want_foo_for_any_tcx(f);\n    |                          ^ the trait `for<'tcx> Foo<'tcx>` is not implemented for `F`\n ...\n LL | fn want_foo_for_any_tcx<F>(f: &F)\n    |    --------------------\n LL |     where F : for<'tcx> Foo<'tcx>\n    |               ------------------- required by this bound in `want_foo_for_any_tcx`\n-   |\n-   = help: consider adding a `where for<'tcx> F: Foo<'tcx>` bound\n \n error[E0277]: the trait bound `for<'ccx> B: Bar<'ccx>` is not satisfied\n   --> $DIR/hrtb-higher-ranker-supertraits.rs:35:26\n    |\n+LL |     where B : Bar<'x>\n+   |                      - help: consider further restricting type parameter `B`: `, for<'ccx> B: Bar<'ccx>`\n+...\n LL |     want_bar_for_any_ccx(b);\n    |                          ^ the trait `for<'ccx> Bar<'ccx>` is not implemented for `B`\n ...\n LL | fn want_bar_for_any_ccx<B>(b: &B)\n    |    --------------------\n LL |     where B : for<'ccx> Bar<'ccx>\n    |               ------------------- required by this bound in `want_bar_for_any_ccx`\n-   |\n-   = help: consider adding a `where for<'ccx> B: Bar<'ccx>` bound\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0d8ee61b5ba13926040563ae61e362b76e227449", "filename": "src/test/ui/impl-trait/issue-55872-1.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-1.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,10 +1,11 @@\n error[E0277]: the trait bound `S: std::marker::Copy` is not satisfied in `(S, T)`\n   --> $DIR/issue-55872-1.rs:12:5\n    |\n+LL | impl<S: Default> Bar for S {\n+   |      -- help: consider further restricting this bound: `S: std::marker::Copy +`\n LL |     type E = impl Copy;\n    |     ^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `S`\n    |\n-   = help: consider adding a `where S: std::marker::Copy` bound\n    = note: required because it appears within the type `(S, T)`\n    = note: the return type of a function must have a statically known size\n \n@@ -13,8 +14,10 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied in `(S, T)\n    |\n LL |     type E = impl Copy;\n    |     ^^^^^^^^^^^^^^^^^^^ within `(S, T)`, the trait `std::marker::Copy` is not implemented for `T`\n+...\n+LL |     fn foo<T: Default>() -> Self::E {\n+   |            -- help: consider further restricting this bound: `T: std::marker::Copy +`\n    |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n    = note: required because it appears within the type `(S, T)`\n    = note: the return type of a function must have a statically known size\n "}, {"sha": "9510aae77534158245da2265c6bf2d22fae18340", "filename": "src/test/ui/issues/issue-13867.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-13867.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-13867.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13867.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,7 +2,6 @@\n // Test that codegen works correctly when there are multiple refutable\n // patterns in match expression.\n \n-\n enum Foo {\n     FooUint(usize),\n     FooNullary,"}, {"sha": "31376f2d1be0fa557a43dfdacb6521eaecbf69e5", "filename": "src/test/ui/issues/issue-20005.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-20005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-20005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20005.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -7,13 +7,13 @@ LL |   trait From<Src> {\n LL | /     fn to<Dst>(\n LL | |         self\n LL | |     ) -> <Dst as From<Self>>::Result where Dst: From<Self> {\n+   | |                                                           - help: consider further restricting `Self`: `, Self: std::marker::Sized`\n LL | |         From::from(self)\n LL | |     }\n    | |_____^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Self`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where Self: std::marker::Sized` bound\n \n error: aborting due to previous error\n "}, {"sha": "ab0a18869632a986e9253cba7c7e506b9163506a", "filename": "src/test/ui/issues/issue-21475.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-21475.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-21475.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21475.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-#![allow(unused_imports)]\n+#![allow(unused_imports, overlapping_patterns)]\n // pretty-expanded FIXME #23616\n \n use m::{START, END};"}, {"sha": "50fdf2d6185be93f30e276adb11f6f8ee27a01d6", "filename": "src/test/ui/issues/issue-21837.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-21837.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-21837.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21837.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -5,9 +5,9 @@ LL | pub struct Foo<T: Bound>(T);\n    | ---------------------------- required by `Foo`\n ...\n LL | impl<T> Trait2 for Foo<T> {}\n-   |         ^^^^^^ the trait `Bound` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: Bound` bound\n+   |      -  ^^^^^^ the trait `Bound` is not implemented for `T`\n+   |      |\n+   |      help: consider restricting this bound: `T: Bound`\n \n error: aborting due to previous error\n "}, {"sha": "283a5e04a8b6f8d19199e5cb28e65719999c9731", "filename": "src/test/ui/issues/issue-22872.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-22872.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-22872.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22872.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,11 +1,12 @@\n error[E0277]: `<P as Process<'_>>::Item` is not an iterator\n   --> $DIR/issue-22872.rs:20:40\n    |\n+LL | fn push_process<P>(process: P) where P: Process<'static> {\n+   |                                                         - help: consider further restricting the associated type: `, <P as Process<'_>>::Item: std::iter::Iterator`\n LL |     let _: Box<dyn for<'b> Wrap<'b>> = Box::new(Wrapper(process));\n    |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ `<P as Process<'_>>::Item` is not an iterator\n    |\n    = help: the trait `std::iter::Iterator` is not implemented for `<P as Process<'_>>::Item`\n-   = help: consider adding a `where <P as Process<'_>>::Item: std::iter::Iterator` bound\n    = note: required because of the requirements on the impl of `for<'b> Wrap<'b>` for `Wrapper<P>`\n    = note: required for the cast to the object type `dyn for<'b> Wrap<'b>`\n "}, {"sha": "edb06fea8ad5333db9322141654ee1cbd24ca6e5", "filename": "src/test/ui/issues/issue-26251.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-26251.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-26251.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26251.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,4 +1,6 @@\n // run-pass\n+#![allow(overlapping_patterns)]\n+\n fn main() {\n     let x = 'a';\n "}, {"sha": "553041c5106c56c3102398c83d54e46b7976376b", "filename": "src/test/ui/issues/issue-27060-2.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-27060-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-27060-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27060-2.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,12 +1,13 @@\n error[E0277]: the size for values of type `T` cannot be known at compilation time\n   --> $DIR/issue-27060-2.rs:3:5\n    |\n+LL | pub struct Bad<T: ?Sized> {\n+   |                -- help: consider further restricting this bound: `T: std::marker::Sized +`\n LL |     data: T,\n    |     ^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where T: std::marker::Sized` bound\n    = note: the last field of a packed struct may only have a dynamically sized type if it does not need drop to be run\n \n error: aborting due to previous error"}, {"sha": "fbc72d063f37cc687a1862ecaf9446f38193852b", "filename": "src/test/ui/issues/issue-27078.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-27078.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-27078.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27078.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,11 +2,12 @@ error[E0277]: the size for values of type `Self` cannot be known at compilation\n   --> $DIR/issue-27078.rs:5:12\n    |\n LL |     fn foo(self) -> &'static i32 {\n-   |            ^^^^ doesn't have a size known at compile-time\n+   |            ^^^^                 - help: consider further restricting `Self`: `where Self: std::marker::Sized`\n+   |            |\n+   |            doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Self`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where Self: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n "}, {"sha": "0687fc940dec1ce9b5642ae9aa055a212d92f613", "filename": "src/test/ui/issues/issue-38821.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-38821.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-38821.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38821.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,7 +4,6 @@ error[E0277]: the trait bound `<Col as Expression>::SqlType: NotNull` is not sat\n LL | #[derive(Debug, Copy, Clone)]\n    |                 ^^^^ the trait `NotNull` is not implemented for `<Col as Expression>::SqlType`\n    |\n-   = help: consider adding a `where <Col as Expression>::SqlType: NotNull` bound\n    = note: required because of the requirements on the impl of `IntoNullable` for `<Col as Expression>::SqlType`\n \n error: aborting due to previous error"}, {"sha": "6688203147eaf2ea38323f9dd07304e66f7119d2", "filename": "src/test/ui/issues/issue-42312.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-42312.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-42312.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-42312.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,11 +2,12 @@ error[E0277]: the size for values of type `<Self as std::ops::Deref>::Target` ca\n   --> $DIR/issue-42312.rs:4:29\n    |\n LL |     fn baz(_: Self::Target) where Self: Deref {}\n-   |                             ^ doesn't have a size known at compile-time\n+   |                             ^                - help: consider further restricting the associated type: `, <Self as std::ops::Deref>::Target: std::marker::Sized`\n+   |                             |\n+   |                             doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `<Self as std::ops::Deref>::Target`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where <Self as std::ops::Deref>::Target: std::marker::Sized` bound\n    = note: all function arguments must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n "}, {"sha": "e91e53499ce6c1f83218c9a96e24deb4449c5a05", "filename": "src/test/ui/issues/issue-43784-associated-type.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-43784-associated-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-43784-associated-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43784-associated-type.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,9 +2,9 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n   --> $DIR/issue-43784-associated-type.rs:13:9\n    |\n LL | impl<T> Complete for T {\n-   |         ^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n+   |      -  ^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |      |\n+   |      help: consider restricting this bound: `T: std::marker::Copy`\n \n error: aborting due to previous error\n "}, {"sha": "5ac32041bce481291119238c5dc3e2c6421c4d26", "filename": "src/test/ui/issues/issue-43784-supertrait.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-43784-supertrait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fissues%2Fissue-43784-supertrait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-43784-supertrait.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,9 +2,9 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n   --> $DIR/issue-43784-supertrait.rs:8:9\n    |\n LL | impl<T> Complete for T {}\n-   |         ^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n+   |      -  ^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |      |\n+   |      help: consider restricting this bound: `T: std::marker::Copy`\n \n error: aborting due to previous error\n "}, {"sha": "82efa83990553e16cc68326b257343b6710af87d", "filename": "src/test/ui/kindck/kindck-impl-type-params.nll.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.nll.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,42 +1,50 @@\n error[E0277]: `T` cannot be sent between threads safely\n   --> $DIR/kindck-impl-type-params.rs:18:13\n    |\n+LL | fn f<T>(val: T) {\n+   |      - help: consider restricting this bound: `T: std::marker::Send`\n+LL |     let t: S<T> = S(marker::PhantomData);\n LL |     let a = &t as &dyn Gettable<T>;\n    |             ^^ `T` cannot be sent between threads safely\n    |\n    = help: the trait `std::marker::Send` is not implemented for `T`\n-   = help: consider adding a `where T: std::marker::Send` bound\n    = note: required because of the requirements on the impl of `Gettable<T>` for `S<T>`\n    = note: required for the cast to the object type `dyn Gettable<T>`\n \n error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n   --> $DIR/kindck-impl-type-params.rs:18:13\n    |\n+LL | fn f<T>(val: T) {\n+   |      - help: consider restricting this bound: `T: std::marker::Copy`\n+LL |     let t: S<T> = S(marker::PhantomData);\n LL |     let a = &t as &dyn Gettable<T>;\n    |             ^^ the trait `std::marker::Copy` is not implemented for `T`\n    |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n    = note: required because of the requirements on the impl of `Gettable<T>` for `S<T>`\n    = note: required for the cast to the object type `dyn Gettable<T>`\n \n error[E0277]: `T` cannot be sent between threads safely\n   --> $DIR/kindck-impl-type-params.rs:25:31\n    |\n+LL | fn g<T>(val: T) {\n+   |      - help: consider restricting this bound: `T: std::marker::Send`\n+LL |     let t: S<T> = S(marker::PhantomData);\n LL |     let a: &dyn Gettable<T> = &t;\n    |                               ^^ `T` cannot be sent between threads safely\n    |\n    = help: the trait `std::marker::Send` is not implemented for `T`\n-   = help: consider adding a `where T: std::marker::Send` bound\n    = note: required because of the requirements on the impl of `Gettable<T>` for `S<T>`\n    = note: required for the cast to the object type `dyn Gettable<T>`\n \n error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n   --> $DIR/kindck-impl-type-params.rs:25:31\n    |\n+LL | fn g<T>(val: T) {\n+   |      - help: consider restricting this bound: `T: std::marker::Copy`\n+LL |     let t: S<T> = S(marker::PhantomData);\n LL |     let a: &dyn Gettable<T> = &t;\n    |                               ^^ the trait `std::marker::Copy` is not implemented for `T`\n    |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n    = note: required because of the requirements on the impl of `Gettable<T>` for `S<T>`\n    = note: required for the cast to the object type `dyn Gettable<T>`\n "}, {"sha": "777a553c2a58a7900cdaf40da1ec43fafc7e7b4c", "filename": "src/test/ui/kindck/kindck-impl-type-params.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,42 +1,50 @@\n error[E0277]: `T` cannot be sent between threads safely\n   --> $DIR/kindck-impl-type-params.rs:18:13\n    |\n+LL | fn f<T>(val: T) {\n+   |      - help: consider restricting this bound: `T: std::marker::Send`\n+LL |     let t: S<T> = S(marker::PhantomData);\n LL |     let a = &t as &dyn Gettable<T>;\n    |             ^^ `T` cannot be sent between threads safely\n    |\n    = help: the trait `std::marker::Send` is not implemented for `T`\n-   = help: consider adding a `where T: std::marker::Send` bound\n    = note: required because of the requirements on the impl of `Gettable<T>` for `S<T>`\n    = note: required for the cast to the object type `dyn Gettable<T>`\n \n error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n   --> $DIR/kindck-impl-type-params.rs:18:13\n    |\n+LL | fn f<T>(val: T) {\n+   |      - help: consider restricting this bound: `T: std::marker::Copy`\n+LL |     let t: S<T> = S(marker::PhantomData);\n LL |     let a = &t as &dyn Gettable<T>;\n    |             ^^ the trait `std::marker::Copy` is not implemented for `T`\n    |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n    = note: required because of the requirements on the impl of `Gettable<T>` for `S<T>`\n    = note: required for the cast to the object type `dyn Gettable<T>`\n \n error[E0277]: `T` cannot be sent between threads safely\n   --> $DIR/kindck-impl-type-params.rs:25:31\n    |\n+LL | fn g<T>(val: T) {\n+   |      - help: consider restricting this bound: `T: std::marker::Send`\n+LL |     let t: S<T> = S(marker::PhantomData);\n LL |     let a: &dyn Gettable<T> = &t;\n    |                               ^^ `T` cannot be sent between threads safely\n    |\n    = help: the trait `std::marker::Send` is not implemented for `T`\n-   = help: consider adding a `where T: std::marker::Send` bound\n    = note: required because of the requirements on the impl of `Gettable<T>` for `S<T>`\n    = note: required for the cast to the object type `dyn Gettable<T>`\n \n error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n   --> $DIR/kindck-impl-type-params.rs:25:31\n    |\n+LL | fn g<T>(val: T) {\n+   |      - help: consider restricting this bound: `T: std::marker::Copy`\n+LL |     let t: S<T> = S(marker::PhantomData);\n LL |     let a: &dyn Gettable<T> = &t;\n    |                               ^^ the trait `std::marker::Copy` is not implemented for `T`\n    |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n    = note: required because of the requirements on the impl of `Gettable<T>` for `S<T>`\n    = note: required for the cast to the object type `dyn Gettable<T>`\n "}, {"sha": "7de7b7e79be44faf85c4b75fe98ff73dd672e40b", "filename": "src/test/ui/match/match-range-fail-dominate.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,39 +1,45 @@\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-//error-pattern: unreachable\n-\n-#![deny(unreachable_patterns)]\n+#![deny(unreachable_patterns, overlapping_patterns)]\n \n fn main() {\n     match 5 {\n       1 ..= 10 => { }\n       5 ..= 6 => { }\n+      //~^ ERROR unreachable pattern\n       _ => {}\n     };\n \n     match 5 {\n       3 ..= 6 => { }\n       4 ..= 6 => { }\n+      //~^ ERROR unreachable pattern\n       _ => {}\n     };\n \n     match 5 {\n       4 ..= 6 => { }\n       4 ..= 6 => { }\n+      //~^ ERROR unreachable pattern\n       _ => {}\n     };\n \n     match 'c' {\n       'A' ..= 'z' => {}\n       'a' ..= 'z' => {}\n+      //~^ ERROR unreachable pattern\n       _ => {}\n     };\n \n     match 1.0f64 {\n       0.01f64 ..= 6.5f64 => {}\n-      0.02f64 => {}\n+      //~^ WARNING floating-point types cannot be used in patterns\n+      //~| WARNING floating-point types cannot be used in patterns\n+      //~| WARNING floating-point types cannot be used in patterns\n+      //~| WARNING this was previously accepted by the compiler\n+      //~| WARNING this was previously accepted by the compiler\n+      //~| WARNING this was previously accepted by the compiler\n+      0.02f64 => {} //~ ERROR unreachable pattern\n+      //~^ WARNING floating-point types cannot be used in patterns\n+      //~| WARNING this was previously accepted by the compiler\n       _ => {}\n     };\n }"}, {"sha": "c15186d2558f24402c0746132a7f3fbf4c3b1783", "filename": "src/test/ui/match/match-range-fail-dominate.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-range-fail-dominate.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,35 +1,35 @@\n error: unreachable pattern\n-  --> $DIR/match-range-fail-dominate.rs:12:7\n+  --> $DIR/match-range-fail-dominate.rs:6:7\n    |\n LL |       5 ..= 6 => { }\n    |       ^^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/match-range-fail-dominate.rs:7:9\n+  --> $DIR/match-range-fail-dominate.rs:1:9\n    |\n-LL | #![deny(unreachable_patterns)]\n+LL | #![deny(unreachable_patterns, overlapping_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/match-range-fail-dominate.rs:18:7\n+  --> $DIR/match-range-fail-dominate.rs:13:7\n    |\n LL |       4 ..= 6 => { }\n    |       ^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/match-range-fail-dominate.rs:24:7\n+  --> $DIR/match-range-fail-dominate.rs:20:7\n    |\n LL |       4 ..= 6 => { }\n    |       ^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/match-range-fail-dominate.rs:30:7\n+  --> $DIR/match-range-fail-dominate.rs:27:7\n    |\n LL |       'a' ..= 'z' => {}\n    |       ^^^^^^^^^^^\n \n warning: floating-point types cannot be used in patterns\n-  --> $DIR/match-range-fail-dominate.rs:35:7\n+  --> $DIR/match-range-fail-dominate.rs:33:7\n    |\n LL |       0.01f64 ..= 6.5f64 => {}\n    |       ^^^^^^^\n@@ -39,7 +39,7 @@ LL |       0.01f64 ..= 6.5f64 => {}\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n warning: floating-point types cannot be used in patterns\n-  --> $DIR/match-range-fail-dominate.rs:35:19\n+  --> $DIR/match-range-fail-dominate.rs:33:19\n    |\n LL |       0.01f64 ..= 6.5f64 => {}\n    |                   ^^^^^^\n@@ -48,7 +48,7 @@ LL |       0.01f64 ..= 6.5f64 => {}\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n warning: floating-point types cannot be used in patterns\n-  --> $DIR/match-range-fail-dominate.rs:36:7\n+  --> $DIR/match-range-fail-dominate.rs:40:7\n    |\n LL |       0.02f64 => {}\n    |       ^^^^^^^\n@@ -57,13 +57,13 @@ LL |       0.02f64 => {}\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n error: unreachable pattern\n-  --> $DIR/match-range-fail-dominate.rs:36:7\n+  --> $DIR/match-range-fail-dominate.rs:40:7\n    |\n LL |       0.02f64 => {}\n    |       ^^^^^^^\n \n warning: floating-point types cannot be used in patterns\n-  --> $DIR/match-range-fail-dominate.rs:35:7\n+  --> $DIR/match-range-fail-dominate.rs:33:7\n    |\n LL |       0.01f64 ..= 6.5f64 => {}\n    |       ^^^^^^^"}, {"sha": "6acc09b62c811cf97a2b3ab4a34e7134cdc9f8db", "filename": "src/test/ui/partialeq_help.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fpartialeq_help.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fpartialeq_help.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpartialeq_help.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -5,7 +5,6 @@ LL |     a == b;\n    |       ^^ no implementation for `&T == T`\n    |\n    = help: the trait `std::cmp::PartialEq<T>` is not implemented for `&T`\n-   = help: consider adding a `where &T: std::cmp::PartialEq<T>` bound\n \n error: aborting due to previous error\n "}, {"sha": "4d9d06b8986d5c6b15c94cb52cd12a184b149776", "filename": "src/test/ui/phantom-oibit.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fphantom-oibit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fphantom-oibit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fphantom-oibit.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -3,12 +3,13 @@ error[E0277]: `T` cannot be shared between threads safely\n    |\n LL | fn is_zen<T: Zen>(_: T) {}\n    |    ------    --- required by this bound in `is_zen`\n-...\n+LL | \n+LL | fn not_sync<T>(x: Guard<T>) {\n+   |             - help: consider restricting this bound: `T: std::marker::Sync`\n LL |     is_zen(x)\n    |            ^ `T` cannot be shared between threads safely\n    |\n    = help: the trait `std::marker::Sync` is not implemented for `T`\n-   = help: consider adding a `where T: std::marker::Sync` bound\n    = note: required because of the requirements on the impl of `Zen` for `&T`\n    = note: required because it appears within the type `std::marker::PhantomData<&T>`\n    = note: required because it appears within the type `Guard<'_, T>`\n@@ -19,11 +20,12 @@ error[E0277]: `T` cannot be shared between threads safely\n LL | fn is_zen<T: Zen>(_: T) {}\n    |    ------    --- required by this bound in `is_zen`\n ...\n+LL | fn nested_not_sync<T>(x: Nested<Guard<T>>) {\n+   |                    - help: consider restricting this bound: `T: std::marker::Sync`\n LL |     is_zen(x)\n    |            ^ `T` cannot be shared between threads safely\n    |\n    = help: the trait `std::marker::Sync` is not implemented for `T`\n-   = help: consider adding a `where T: std::marker::Sync` bound\n    = note: required because of the requirements on the impl of `Zen` for `&T`\n    = note: required because it appears within the type `std::marker::PhantomData<&T>`\n    = note: required because it appears within the type `Guard<'_, T>`"}, {"sha": "54aeb8616d959f4bb02f601e13627cab2e808304", "filename": "src/test/ui/precise_pointer_size_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -8,7 +8,7 @@\n #![feature(precise_pointer_size_matching)]\n #![feature(exclusive_range_pattern)]\n \n-#![deny(unreachable_patterns)]\n+#![deny(unreachable_patterns, overlapping_patterns)]\n \n use std::{usize, isize};\n "}, {"sha": "f8abd1b96d80e85ff959146c4f895107b28bae3b", "filename": "src/test/ui/rfcs/rfc-2005-default-binding-mode/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Frfcs%2Frfc-2005-default-binding-mode%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Frfcs%2Frfc-2005-default-binding-mode%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2005-default-binding-mode%2Frange.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -3,7 +3,7 @@ pub fn main() {\n     let i = 5;\n     match &&&&i {\n         1 ..= 3 => panic!(),\n-        3 ..= 8 => {},\n+        4 ..= 8 => {},\n         _ => panic!(),\n     }\n }"}, {"sha": "5275b7b1ddfa57e11fa37710d48c8ffc448a76b9", "filename": "src/test/ui/specialization/defaultimpl/specialization-wfcheck.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-wfcheck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-wfcheck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-wfcheck.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,9 +2,9 @@ error[E0277]: the trait bound `U: std::cmp::Eq` is not satisfied\n   --> $DIR/specialization-wfcheck.rs:7:17\n    |\n LL | default impl<U> Foo<'static, U> for () {}\n-   |                 ^^^^^^^^^^^^^^^ the trait `std::cmp::Eq` is not implemented for `U`\n-   |\n-   = help: consider adding a `where U: std::cmp::Eq` bound\n+   |              -  ^^^^^^^^^^^^^^^ the trait `std::cmp::Eq` is not implemented for `U`\n+   |              |\n+   |              help: consider restricting this bound: `U: std::cmp::Eq`\n \n error: aborting due to previous error\n "}, {"sha": "265ccb3125ca3b015d2c9e7009e5932f72c0d6cb", "filename": "src/test/ui/suggestions/missing-assoc-type-bound-restriction.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -0,0 +1,25 @@\n+// Running rustfix would cause the same suggestion to be applied multiple times, which results in\n+// invalid code.\n+\n+trait Parent {\n+    type Ty;\n+    type Assoc: Child<Self::Ty>;\n+}\n+\n+trait Child<T> {}\n+\n+struct ChildWrapper<T>(T);\n+\n+impl<A, T> Child<A> for ChildWrapper<T> where T: Child<A> {}\n+\n+struct ParentWrapper<T>(T);\n+\n+impl<A, T: Parent<Ty = A>> Parent for ParentWrapper<T> {\n+    //~^ ERROR the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n+    //~| ERROR the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n+    type Ty = A;\n+    type Assoc = ChildWrapper<T::Assoc>;\n+    //~^ ERROR the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "bdea8ab97e5b52f163171b8d9377ebce10c624b7", "filename": "src/test/ui/suggestions/missing-assoc-type-bound-restriction.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-assoc-type-bound-restriction.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -0,0 +1,43 @@\n+error[E0277]: the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n+  --> $DIR/missing-assoc-type-bound-restriction.rs:17:1\n+   |\n+LL |   trait Parent {\n+   |   ------------ required by `Parent`\n+...\n+LL |   impl<A, T: Parent<Ty = A>> Parent for ParentWrapper<T> {\n+   |   ^                                                     - help: consider further restricting the associated type: `where <T as Parent>::Assoc: Child<A>`\n+   |  _|\n+   | |\n+LL | |\n+LL | |\n+LL | |     type Ty = A;\n+LL | |     type Assoc = ChildWrapper<T::Assoc>;\n+LL | |\n+LL | | }\n+   | |_^ the trait `Child<A>` is not implemented for `<T as Parent>::Assoc`\n+\n+error[E0277]: the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n+  --> $DIR/missing-assoc-type-bound-restriction.rs:17:28\n+   |\n+LL | impl<A, T: Parent<Ty = A>> Parent for ParentWrapper<T> {\n+   |                            ^^^^^^                     - help: consider further restricting the associated type: `where <T as Parent>::Assoc: Child<A>`\n+   |                            |\n+   |                            the trait `Child<A>` is not implemented for `<T as Parent>::Assoc`\n+   |\n+   = note: required because of the requirements on the impl of `Child<A>` for `ChildWrapper<<T as Parent>::Assoc>`\n+\n+error[E0277]: the trait bound `<T as Parent>::Assoc: Child<A>` is not satisfied\n+  --> $DIR/missing-assoc-type-bound-restriction.rs:21:5\n+   |\n+LL | trait Parent {\n+   | ------------ required by `Parent`\n+...\n+LL | impl<A, T: Parent<Ty = A>> Parent for ParentWrapper<T> {\n+   |                                                       - help: consider further restricting the associated type: `where <T as Parent>::Assoc: Child<A>`\n+...\n+LL |     type Assoc = ChildWrapper<T::Assoc>;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Child<A>` is not implemented for `<T as Parent>::Assoc`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c4ebfbe922c094182ecbe9d5a65302421bf5f154", "filename": "src/test/ui/suggestions/restrict-type-argument.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-argument.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -0,0 +1,31 @@\n+fn is_send<T: Send>(val: T) {}\n+\n+fn use_impl_sync(val: impl Sync) {\n+    is_send(val); //~ ERROR `impl Sync` cannot be sent between threads safely\n+}\n+\n+fn use_where<S>(val: S) where S: Sync {\n+    is_send(val); //~ ERROR `S` cannot be sent between threads safely\n+}\n+\n+fn use_bound<S: Sync>(val: S) {\n+    is_send(val); //~ ERROR `S` cannot be sent between threads safely\n+}\n+\n+fn use_bound_2<\n+    S // Make sure we can synthezise a correct suggestion span for this case\n+    :\n+    Sync\n+>(val: S) {\n+    is_send(val); //~ ERROR `S` cannot be sent between threads safely\n+}\n+\n+fn use_bound_and_where<S: Sync>(val: S) where S: std::fmt::Debug {\n+    is_send(val); //~ ERROR `S` cannot be sent between threads safely\n+}\n+\n+fn use_unbound<S>(val: S) {\n+    is_send(val); //~ ERROR `S` cannot be sent between threads safely\n+}\n+\n+fn main() {}"}, {"sha": "d6840ca4d7265d3c5ec1b1f9456b8ac8a1adf309", "filename": "src/test/ui/suggestions/restrict-type-argument.stderr", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-argument.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -0,0 +1,83 @@\n+error[E0277]: `impl Sync` cannot be sent between threads safely\n+  --> $DIR/restrict-type-argument.rs:4:13\n+   |\n+LL | fn is_send<T: Send>(val: T) {}\n+   |    -------    ---- required by this bound in `is_send`\n+LL | \n+LL | fn use_impl_sync(val: impl Sync) {\n+   |                       --------- help: consider further restricting this bound: `impl Sync + std::marker::Send`\n+LL |     is_send(val);\n+   |             ^^^ `impl Sync` cannot be sent between threads safely\n+   |\n+   = help: the trait `std::marker::Send` is not implemented for `impl Sync`\n+\n+error[E0277]: `S` cannot be sent between threads safely\n+  --> $DIR/restrict-type-argument.rs:8:13\n+   |\n+LL | fn is_send<T: Send>(val: T) {}\n+   |    -------    ---- required by this bound in `is_send`\n+...\n+LL | fn use_where<S>(val: S) where S: Sync {\n+   |                                      - help: consider further restricting type parameter `S`: `, S: std::marker::Send`\n+LL |     is_send(val);\n+   |             ^^^ `S` cannot be sent between threads safely\n+   |\n+   = help: the trait `std::marker::Send` is not implemented for `S`\n+\n+error[E0277]: `S` cannot be sent between threads safely\n+  --> $DIR/restrict-type-argument.rs:12:13\n+   |\n+LL | fn is_send<T: Send>(val: T) {}\n+   |    -------    ---- required by this bound in `is_send`\n+...\n+LL | fn use_bound<S: Sync>(val: S) {\n+   |              -- help: consider further restricting this bound: `S: std::marker::Send +`\n+LL |     is_send(val);\n+   |             ^^^ `S` cannot be sent between threads safely\n+   |\n+   = help: the trait `std::marker::Send` is not implemented for `S`\n+\n+error[E0277]: `S` cannot be sent between threads safely\n+  --> $DIR/restrict-type-argument.rs:20:13\n+   |\n+LL |   fn is_send<T: Send>(val: T) {}\n+   |      -------    ---- required by this bound in `is_send`\n+...\n+LL | /     S // Make sure we can synthezise a correct suggestion span for this case\n+LL | |     :\n+   | |_____- help: consider further restricting this bound: `S: std::marker::Send +`\n+...\n+LL |       is_send(val);\n+   |               ^^^ `S` cannot be sent between threads safely\n+   |\n+   = help: the trait `std::marker::Send` is not implemented for `S`\n+\n+error[E0277]: `S` cannot be sent between threads safely\n+  --> $DIR/restrict-type-argument.rs:24:13\n+   |\n+LL | fn is_send<T: Send>(val: T) {}\n+   |    -------    ---- required by this bound in `is_send`\n+...\n+LL | fn use_bound_and_where<S: Sync>(val: S) where S: std::fmt::Debug {\n+   |                                                                 - help: consider further restricting type parameter `S`: `, S: std::marker::Send`\n+LL |     is_send(val);\n+   |             ^^^ `S` cannot be sent between threads safely\n+   |\n+   = help: the trait `std::marker::Send` is not implemented for `S`\n+\n+error[E0277]: `S` cannot be sent between threads safely\n+  --> $DIR/restrict-type-argument.rs:28:13\n+   |\n+LL | fn is_send<T: Send>(val: T) {}\n+   |    -------    ---- required by this bound in `is_send`\n+...\n+LL | fn use_unbound<S>(val: S) {\n+   |                - help: consider restricting this bound: `S: std::marker::Send`\n+LL |     is_send(val);\n+   |             ^^^ `S` cannot be sent between threads safely\n+   |\n+   = help: the trait `std::marker::Send` is not implemented for `S`\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "4355a517bd724dad62cbafa094128ed54d7012f0", "filename": "src/test/ui/traits/trait-alias/trait-alias-wf.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias%2Ftrait-alias-wf.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,9 +4,10 @@ error[E0277]: the trait bound `T: Foo` is not satisfied\n LL | trait A<T: Foo> {}\n    | --------------- required by `A`\n LL | trait B<T> = A<T>;\n-   | ^^^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: Foo` bound\n+   | ^^^^^^^^-^^^^^^^^^\n+   | |       |\n+   | |       help: consider restricting this bound: `T: Foo`\n+   | the trait `Foo` is not implemented for `T`\n \n error: aborting due to previous error\n "}, {"sha": "96bbd1f3e4f1753add73e5010fcab1dd0c79b6cf", "filename": "src/test/ui/traits/trait-bounds-on-structs-and-enums.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-on-structs-and-enums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-on-structs-and-enums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-bounds-on-structs-and-enums.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -5,9 +5,9 @@ LL | struct Foo<T:Trait> {\n    | ------------------- required by `Foo`\n ...\n LL | impl<T> Foo<T> {\n-   |         ^^^^^^ the trait `Trait` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: Trait` bound\n+   |      -  ^^^^^^ the trait `Trait` is not implemented for `T`\n+   |      |\n+   |      help: consider restricting this bound: `T: Trait`\n \n error[E0277]: the trait bound `isize: Trait` is not satisfied\n   --> $DIR/trait-bounds-on-structs-and-enums.rs:19:5\n@@ -33,21 +33,21 @@ error[E0277]: the trait bound `U: Trait` is not satisfied\n LL | struct Foo<T:Trait> {\n    | ------------------- required by `Foo`\n ...\n+LL | struct Badness<U> {\n+   |                - help: consider restricting this bound: `U: Trait`\n LL |     b: Foo<U>,\n    |     ^^^^^^^^^ the trait `Trait` is not implemented for `U`\n-   |\n-   = help: consider adding a `where U: Trait` bound\n \n error[E0277]: the trait bound `V: Trait` is not satisfied\n   --> $DIR/trait-bounds-on-structs-and-enums.rs:31:21\n    |\n LL | enum Bar<T:Trait> {\n    | ----------------- required by `Bar`\n ...\n+LL | enum MoreBadness<V> {\n+   |                  - help: consider restricting this bound: `V: Trait`\n LL |     EvenMoreBadness(Bar<V>),\n    |                     ^^^^^^ the trait `Trait` is not implemented for `V`\n-   |\n-   = help: consider adding a `where V: Trait` bound\n \n error[E0277]: the trait bound `i32: Trait` is not satisfied\n   --> $DIR/trait-bounds-on-structs-and-enums.rs:35:5"}, {"sha": "f1004ea9dc6ee3e0eb823048ada3f9db22f2aaec", "filename": "src/test/ui/traits/trait-suggest-where-clause.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-suggest-where-clause.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,6 +1,9 @@\n error[E0277]: the size for values of type `U` cannot be known at compilation time\n   --> $DIR/trait-suggest-where-clause.rs:9:20\n    |\n+LL | fn check<T: Iterator, U: ?Sized>() {\n+   |                       -- help: consider further restricting this bound: `U: std::marker::Sized +`\n+LL |     // suggest a where-clause, if needed\n LL |     mem::size_of::<U>();\n    |                    ^ doesn't have a size known at compile-time\n    | \n@@ -11,11 +14,13 @@ LL | pub const fn size_of<T>() -> usize {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `U`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where U: std::marker::Sized` bound\n \n error[E0277]: the size for values of type `U` cannot be known at compilation time\n   --> $DIR/trait-suggest-where-clause.rs:12:5\n    |\n+LL | fn check<T: Iterator, U: ?Sized>() {\n+   |                       -- help: consider further restricting this bound: `U: std::marker::Sized +`\n+...\n LL |     mem::size_of::<Misc<U>>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    | \n@@ -26,7 +31,6 @@ LL | pub const fn size_of<T>() -> usize {\n    |\n    = help: within `Misc<U>`, the trait `std::marker::Sized` is not implemented for `U`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where U: std::marker::Sized` bound\n    = note: required because it appears within the type `Misc<U>`\n \n error[E0277]: the trait bound `u64: std::convert::From<T>` is not satisfied\n@@ -35,7 +39,6 @@ error[E0277]: the trait bound `u64: std::convert::From<T>` is not satisfied\n LL |     <u64 as From<T>>::from;\n    |     ^^^^^^^^^^^^^^^^^^^^^^ the trait `std::convert::From<T>` is not implemented for `u64`\n    |\n-   = help: consider adding a `where u64: std::convert::From<T>` bound\n    = note: required by `std::convert::From::from`\n \n error[E0277]: the trait bound `u64: std::convert::From<<T as std::iter::Iterator>::Item>` is not satisfied\n@@ -44,7 +47,6 @@ error[E0277]: the trait bound `u64: std::convert::From<<T as std::iter::Iterator\n LL |     <u64 as From<<T as Iterator>::Item>>::from;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::convert::From<<T as std::iter::Iterator>::Item>` is not implemented for `u64`\n    |\n-   = help: consider adding a `where u64: std::convert::From<<T as std::iter::Iterator>::Item>` bound\n    = note: required by `std::convert::From::from`\n \n error[E0277]: the trait bound `Misc<_>: std::convert::From<T>` is not satisfied"}, {"sha": "85c7a55c31379c14bf696804401ed5890d9fbe5a", "filename": "src/test/ui/traits/traits-repeated-supertrait-ambig.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftraits%2Ftraits-repeated-supertrait-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftraits%2Ftraits-repeated-supertrait-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftraits-repeated-supertrait-ambig.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -7,10 +7,10 @@ LL |     c.same_as(22)\n error[E0277]: the trait bound `C: CompareTo<i32>` is not satisfied\n   --> $DIR/traits-repeated-supertrait-ambig.rs:30:7\n    |\n+LL | fn with_trait<C:CompareToInts>(c: &C) -> bool {\n+   |               -- help: consider further restricting this bound: `C: CompareTo<i32> +`\n LL |     c.same_as(22)\n    |       ^^^^^^^ the trait `CompareTo<i32>` is not implemented for `C`\n-   |\n-   = help: consider adding a `where C: CompareTo<i32>` bound\n \n error[E0277]: the trait bound `dyn CompareToInts: CompareTo<i32>` is not satisfied\n   --> $DIR/traits-repeated-supertrait-ambig.rs:34:5\n@@ -27,10 +27,10 @@ error[E0277]: the trait bound `C: CompareTo<i32>` is not satisfied\n LL |     fn same_as(&self, t: T) -> bool;\n    |     -------------------------------- required by `CompareTo::same_as`\n ...\n+LL | fn with_ufcs2<C:CompareToInts>(c: &C) -> bool {\n+   |               -- help: consider further restricting this bound: `C: CompareTo<i32> +`\n LL |     CompareTo::same_as(c, 22)\n    |     ^^^^^^^^^^^^^^^^^^ the trait `CompareTo<i32>` is not implemented for `C`\n-   |\n-   = help: consider adding a `where C: CompareTo<i32>` bound\n \n error[E0277]: the trait bound `i64: CompareTo<i32>` is not satisfied\n   --> $DIR/traits-repeated-supertrait-ambig.rs:42:23"}, {"sha": "63c07224353e2e018343760e098e2b0834a031bc", "filename": "src/test/ui/type-alias-impl-trait/generic_underconstrained.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -9,8 +9,10 @@ error[E0277]: the trait bound `T: Trait` is not satisfied\n    |\n LL | type Underconstrained<T: Trait> = impl 'static;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait` is not implemented for `T`\n+...\n+LL | fn underconstrain<T>(_: T) -> Underconstrained<T> {\n+   |                   - help: consider restricting this bound: `T: Trait`\n    |\n-   = help: consider adding a `where T: Trait` bound\n    = note: the return type of a function must have a statically known size\n \n error: aborting due to 2 previous errors"}, {"sha": "ba892f6ed7c7b7918811f34d0816e7fd1d92973a", "filename": "src/test/ui/type-alias-impl-trait/generic_underconstrained2.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -15,19 +15,23 @@ error[E0277]: `U` doesn't implement `std::fmt::Debug`\n    |\n LL | type Underconstrained<T: std::fmt::Debug> = impl 'static;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `U` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+...\n+LL | fn underconstrained<U>(_: U) -> Underconstrained<U> {\n+   |                     - help: consider restricting this bound: `U: std::fmt::Debug`\n    |\n    = help: the trait `std::fmt::Debug` is not implemented for `U`\n-   = help: consider adding a `where U: std::fmt::Debug` bound\n    = note: the return type of a function must have a statically known size\n \n error[E0277]: `V` doesn't implement `std::fmt::Debug`\n   --> $DIR/generic_underconstrained2.rs:14:1\n    |\n LL | type Underconstrained2<T: std::fmt::Debug> = impl 'static;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `V` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+...\n+LL | fn underconstrained2<U, V>(_: U, _: V) -> Underconstrained2<V> {\n+   |                         - help: consider restricting this bound: `V: std::fmt::Debug`\n    |\n    = help: the trait `std::fmt::Debug` is not implemented for `V`\n-   = help: consider adding a `where V: std::fmt::Debug` bound\n    = note: the return type of a function must have a statically known size\n \n error: aborting due to 4 previous errors"}, {"sha": "6802bc38b89c9fce2598826baec09d3d1edd6ab2", "filename": "src/test/ui/type/type-check-defaults.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftype%2Ftype-check-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftype%2Ftype-check-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check-defaults.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -52,9 +52,10 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n LL | trait Super<T: Copy> { }\n    | -------------------- required by `Super`\n LL | trait Base<T = String>: Super<T> { }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n+   | ^^^^^^^^^^^-^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |          |\n+   | |          help: consider restricting this bound: `T: std::marker::Copy`\n+   | the trait `std::marker::Copy` is not implemented for `T`\n \n error[E0277]: cannot add `u8` to `i32`\n   --> $DIR/type-check-defaults.rs:24:66"}, {"sha": "7ce249a60b85eefa6bb0f11f5ac8b21c157719b3", "filename": "src/test/ui/type/type-params-in-different-spaces-2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-params-in-different-spaces-2.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,21 +4,21 @@ error[E0277]: the trait bound `Self: Tr<U>` is not satisfied\n LL |     fn op(_: T) -> Self;\n    |     -------------------- required by `Tr::op`\n ...\n+LL |     fn test<U>(u: U) -> Self {\n+   |                             - help: consider further restricting `Self`: `where Self: Tr<U>`\n LL |         Tr::op(u)\n    |         ^^^^^^ the trait `Tr<U>` is not implemented for `Self`\n-   |\n-   = help: consider adding a `where Self: Tr<U>` bound\n \n error[E0277]: the trait bound `Self: Tr<U>` is not satisfied\n   --> $DIR/type-params-in-different-spaces-2.rs:16:9\n    |\n LL |     fn op(_: T) -> Self;\n    |     -------------------- required by `Tr::op`\n ...\n+LL |     fn test<U>(u: U) -> Self {\n+   |                             - help: consider further restricting `Self`: `where Self: Tr<U>`\n LL |         Tr::op(u)\n    |         ^^^^^^ the trait `Tr<U>` is not implemented for `Self`\n-   |\n-   = help: consider adding a `where Self: Tr<U>` bound\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7a108d880bed3df1f4dbc5578c9d5dacc3986608", "filename": "src/test/ui/typeck/typeck-default-trait-impl-assoc-type.fixed", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.fixed?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -0,0 +1,17 @@\n+// run-rustfix\n+// Test that we do not consider associated types to be sendable without\n+// some applicable trait bound (and we don't ICE).\n+#![allow(dead_code)]\n+\n+trait Trait {\n+    type AssocType;\n+    fn dummy(&self) { }\n+}\n+fn bar<T:Trait+Send>() where <T as Trait>::AssocType: std::marker::Send  {\n+    is_send::<T::AssocType>(); //~ ERROR E0277\n+}\n+\n+fn is_send<T:Send>() {\n+}\n+\n+fn main() { }"}, {"sha": "bafc1657737f44c0110ebfefd3e05e349e8d0894", "filename": "src/test/ui/typeck/typeck-default-trait-impl-assoc-type.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.rs?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,5 +1,7 @@\n+// run-rustfix\n // Test that we do not consider associated types to be sendable without\n // some applicable trait bound (and we don't ICE).\n+#![allow(dead_code)]\n \n trait Trait {\n     type AssocType;"}, {"sha": "2e54cdf01320d50beb13b6690b35102a2b709a5f", "filename": "src/test/ui/typeck/typeck-default-trait-impl-assoc-type.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-assoc-type.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,14 +1,15 @@\n error[E0277]: `<T as Trait>::AssocType` cannot be sent between threads safely\n-  --> $DIR/typeck-default-trait-impl-assoc-type.rs:9:5\n+  --> $DIR/typeck-default-trait-impl-assoc-type.rs:11:5\n    |\n+LL | fn bar<T:Trait+Send>() {\n+   |                       - help: consider further restricting the associated type: `where <T as Trait>::AssocType: std::marker::Send`\n LL |     is_send::<T::AssocType>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ `<T as Trait>::AssocType` cannot be sent between threads safely\n ...\n LL | fn is_send<T:Send>() {\n    |    -------   ---- required by this bound in `is_send`\n    |\n    = help: the trait `std::marker::Send` is not implemented for `<T as Trait>::AssocType`\n-   = help: consider adding a `where <T as Trait>::AssocType: std::marker::Send` bound\n \n error: aborting due to previous error\n "}, {"sha": "a84aef5fdbdb66d5090c008114f82b442f21b079", "filename": "src/test/ui/typeck/typeck-default-trait-impl-send-param.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-send-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-send-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-send-param.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,14 +1,15 @@\n error[E0277]: `T` cannot be sent between threads safely\n   --> $DIR/typeck-default-trait-impl-send-param.rs:5:15\n    |\n+LL | fn foo<T>() {\n+   |        - help: consider restricting this bound: `T: std::marker::Send`\n LL |     is_send::<T>()\n    |               ^ `T` cannot be sent between threads safely\n ...\n LL | fn is_send<T:Send>() {\n    |    -------   ---- required by this bound in `is_send`\n    |\n    = help: the trait `std::marker::Send` is not implemented for `T`\n-   = help: consider adding a `where T: std::marker::Send` bound\n \n error: aborting due to previous error\n "}, {"sha": "c9fec1d21d152026214290203c561e73e648843b", "filename": "src/test/ui/union/union-sized-field.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funion%2Funion-sized-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funion%2Funion-sized-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-sized-field.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,34 +1,37 @@\n error[E0277]: the size for values of type `T` cannot be known at compilation time\n   --> $DIR/union-sized-field.rs:4:5\n    |\n+LL | union Foo<T: ?Sized> {\n+   |           -- help: consider further restricting this bound: `T: std::marker::Sized +`\n LL |     value: T,\n    |     ^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where T: std::marker::Sized` bound\n    = note: no field of a union may have a dynamically sized type\n \n error[E0277]: the size for values of type `T` cannot be known at compilation time\n   --> $DIR/union-sized-field.rs:9:5\n    |\n+LL | struct Foo2<T: ?Sized> {\n+   |             -- help: consider further restricting this bound: `T: std::marker::Sized +`\n LL |     value: T,\n    |     ^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where T: std::marker::Sized` bound\n    = note: only the last field of a struct may have a dynamically sized type\n \n error[E0277]: the size for values of type `T` cannot be known at compilation time\n   --> $DIR/union-sized-field.rs:15:11\n    |\n+LL | enum Foo3<T: ?Sized> {\n+   |           -- help: consider further restricting this bound: `T: std::marker::Sized +`\n LL |     Value(T),\n    |           ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where T: std::marker::Sized` bound\n    = note: no field of an enum variant may have a dynamically sized type\n \n error: aborting due to 3 previous errors"}, {"sha": "bd97b0203b5104fcde519a193e7bef21440efd9e", "filename": "src/test/ui/unsized/unsized-bare-typaram.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized%2Funsized-bare-typaram.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized%2Funsized-bare-typaram.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-bare-typaram.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,11 +4,12 @@ error[E0277]: the size for values of type `T` cannot be known at compilation tim\n LL | fn bar<T: Sized>() { }\n    |    --- - required by this bound in `bar`\n LL | fn foo<T: ?Sized>() { bar::<T>() }\n-   |                             ^ doesn't have a size known at compile-time\n+   |        --                   ^ doesn't have a size known at compile-time\n+   |        |\n+   |        help: consider further restricting this bound: `T: std::marker::Sized +`\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where T: std::marker::Sized` bound\n \n error: aborting due to previous error\n "}, {"sha": "341d3e4cc2df2926248e5ea81459b4b122e9c6a8", "filename": "src/test/ui/unsized/unsized-enum.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized%2Funsized-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized%2Funsized-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-enum.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -5,11 +5,12 @@ LL | enum Foo<U> { FooSome(U), FooNone }\n    | ----------- required by `Foo`\n LL | fn foo1<T>() { not_sized::<Foo<T>>() } // Hunky dory.\n LL | fn foo2<T: ?Sized>() { not_sized::<Foo<T>>() }\n-   |                                    ^^^^^^ doesn't have a size known at compile-time\n+   |         --                         ^^^^^^ doesn't have a size known at compile-time\n+   |         |\n+   |         help: consider further restricting this bound: `T: std::marker::Sized +`\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where T: std::marker::Sized` bound\n \n error: aborting due to previous error\n "}, {"sha": "e85b6d662f9d56b8e3c8cc5976b744818b2f928c", "filename": "src/test/ui/unsized/unsized-enum2.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized%2Funsized-enum2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized%2Funsized-enum2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-enum2.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,45 +1,53 @@\n error[E0277]: the size for values of type `W` cannot be known at compilation time\n   --> $DIR/unsized-enum2.rs:23:8\n    |\n+LL | enum E<W: ?Sized, X: ?Sized, Y: ?Sized, Z: ?Sized> {\n+   |        -- help: consider further restricting this bound: `W: std::marker::Sized +`\n+LL |     // parameter\n LL |     VA(W),\n    |        ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `W`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where W: std::marker::Sized` bound\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized-enum2.rs:25:8\n    |\n+LL | enum E<W: ?Sized, X: ?Sized, Y: ?Sized, Z: ?Sized> {\n+   |                   -- help: consider further restricting this bound: `X: std::marker::Sized +`\n+...\n LL |     VB{x: X},\n    |        ^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `Y` cannot be known at compilation time\n   --> $DIR/unsized-enum2.rs:27:15\n    |\n+LL | enum E<W: ?Sized, X: ?Sized, Y: ?Sized, Z: ?Sized> {\n+   |                              -- help: consider further restricting this bound: `Y: std::marker::Sized +`\n+...\n LL |     VC(isize, Y),\n    |               ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Y`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where Y: std::marker::Sized` bound\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `Z` cannot be known at compilation time\n   --> $DIR/unsized-enum2.rs:29:18\n    |\n+LL | enum E<W: ?Sized, X: ?Sized, Y: ?Sized, Z: ?Sized> {\n+   |                                         -- help: consider further restricting this bound: `Z: std::marker::Sized +`\n+...\n LL |     VD{u: isize, x: Z},\n    |                  ^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Z`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where Z: std::marker::Sized` bound\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `[u8]` cannot be known at compilation time"}, {"sha": "280b8fd43cab0ecc07fa18e55b8c44d3719fc6d1", "filename": "src/test/ui/unsized/unsized-inherent-impl-self-type.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized%2Funsized-inherent-impl-self-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized%2Funsized-inherent-impl-self-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-inherent-impl-self-type.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -5,11 +5,12 @@ LL | struct S5<Y>(Y);\n    | ---------------- required by `S5`\n LL | \n LL | impl<X: ?Sized> S5<X> {\n-   |                 ^^^^^ doesn't have a size known at compile-time\n+   |      --         ^^^^^ doesn't have a size known at compile-time\n+   |      |\n+   |      help: consider further restricting this bound: `X: std::marker::Sized +`\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n \n error: aborting due to previous error\n "}, {"sha": "2894d5d56710dd3384ad1b7ad6732863dc3e5590", "filename": "src/test/ui/unsized/unsized-struct.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized%2Funsized-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized%2Funsized-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-struct.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -5,11 +5,12 @@ LL | struct Foo<T> { data: T }\n    | ------------- required by `Foo`\n LL | fn foo1<T>() { not_sized::<Foo<T>>() } // Hunky dory.\n LL | fn foo2<T: ?Sized>() { not_sized::<Foo<T>>() }\n-   |                                    ^^^^^^ doesn't have a size known at compile-time\n+   |         --                         ^^^^^^ doesn't have a size known at compile-time\n+   |         |\n+   |         help: consider further restricting this bound: `T: std::marker::Sized +`\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `T`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where T: std::marker::Sized` bound\n \n error[E0277]: the size for values of type `T` cannot be known at compilation time\n   --> $DIR/unsized-struct.rs:13:24\n@@ -18,11 +19,12 @@ LL | fn is_sized<T:Sized>() { }\n    |    -------- - required by this bound in `is_sized`\n ...\n LL | fn bar2<T: ?Sized>() { is_sized::<Bar<T>>() }\n-   |                        ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |         --             ^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |         |\n+   |         help: consider further restricting this bound: `T: std::marker::Sized +`\n    |\n    = help: within `Bar<T>`, the trait `std::marker::Sized` is not implemented for `T`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where T: std::marker::Sized` bound\n    = note: required because it appears within the type `Bar<T>`\n \n error: aborting due to 2 previous errors"}, {"sha": "ba1550439c0d9b51bae147932d593f65fbf956d4", "filename": "src/test/ui/unsized/unsized-trait-impl-self-type.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-self-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-self-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-self-type.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -5,11 +5,12 @@ LL | struct S5<Y>(Y);\n    | ---------------- required by `S5`\n LL | \n LL | impl<X: ?Sized> T3<X> for S5<X> {\n-   |                 ^^^^^ doesn't have a size known at compile-time\n+   |      --         ^^^^^ doesn't have a size known at compile-time\n+   |      |\n+   |      help: consider further restricting this bound: `X: std::marker::Sized +`\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n \n error: aborting due to previous error\n "}, {"sha": "41371d63f9e53eaa0215188b7094934d07c2ed97", "filename": "src/test/ui/unsized/unsized-trait-impl-trait-arg.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-trait-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-trait-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Funsized-trait-impl-trait-arg.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,11 +2,12 @@ error[E0277]: the size for values of type `X` cannot be known at compilation tim\n   --> $DIR/unsized-trait-impl-trait-arg.rs:8:17\n    |\n LL | impl<X: ?Sized> T2<X> for S4<X> {\n-   |                 ^^^^^ doesn't have a size known at compile-time\n+   |      --         ^^^^^ doesn't have a size known at compile-time\n+   |      |\n+   |      help: consider further restricting this bound: `X: std::marker::Sized +`\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n \n error: aborting due to previous error\n "}, {"sha": "232296ad09126b3e7194f6d848e8c01a56fbae4b", "filename": "src/test/ui/unsized3.stderr", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized3.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,6 +1,8 @@\n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized3.rs:7:13\n    |\n+LL | fn f1<X: ?Sized>(x: &X) {\n+   |       -- help: consider further restricting this bound: `X: std::marker::Sized +`\n LL |     f2::<X>(x);\n    |             ^ doesn't have a size known at compile-time\n ...\n@@ -9,11 +11,12 @@ LL | fn f2<X>(x: &X) {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized3.rs:18:13\n    |\n+LL | fn f3<X: ?Sized + T>(x: &X) {\n+   |       -- help: consider further restricting this bound: `X: std::marker::Sized +`\n LL |     f4::<X>(x);\n    |             ^ doesn't have a size known at compile-time\n ...\n@@ -22,43 +25,45 @@ LL | fn f4<X: T>(x: &X) {\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized3.rs:33:8\n    |\n LL | fn f5<Y>(x: &Y) {}\n    |    -- - required by this bound in `f5`\n ...\n+LL | fn f8<X: ?Sized>(x1: &S<X>, x2: &S<X>) {\n+   |       -- help: consider further restricting this bound: `X: std::marker::Sized +`\n LL |     f5(x1);\n    |        ^^ doesn't have a size known at compile-time\n    |\n    = help: within `S<X>`, the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: required because it appears within the type `S<X>`\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized3.rs:40:8\n    |\n+LL | fn f9<X: ?Sized>(x1: Box<S<X>>) {\n+   |       -- help: consider further restricting this bound: `X: std::marker::Sized +`\n LL |     f5(&(*x1, 34));\n    |        ^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: within `S<X>`, the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: required because it appears within the type `S<X>`\n    = note: only the last element of a tuple may have a dynamically sized type\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized3.rs:45:9\n    |\n+LL | fn f10<X: ?Sized>(x1: Box<S<X>>) {\n+   |        -- help: consider further restricting this bound: `X: std::marker::Sized +`\n LL |     f5(&(32, *x1));\n    |         ^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: within `({integer}, S<X>)`, the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: required because it appears within the type `S<X>`\n    = note: required because it appears within the type `({integer}, S<X>)`\n    = note: tuples must have a statically known size to be initialized\n@@ -69,12 +74,13 @@ error[E0277]: the size for values of type `X` cannot be known at compilation tim\n LL | fn f5<Y>(x: &Y) {}\n    |    -- - required by this bound in `f5`\n ...\n+LL | fn f10<X: ?Sized>(x1: Box<S<X>>) {\n+   |        -- help: consider further restricting this bound: `X: std::marker::Sized +`\n LL |     f5(&(32, *x1));\n    |        ^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: within `({integer}, S<X>)`, the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: required because it appears within the type `S<X>`\n    = note: required because it appears within the type `({integer}, S<X>)`\n "}, {"sha": "bfd3f4aa691eb7deae80216873bc2034816db17d", "filename": "src/test/ui/unsized5.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized5.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,23 +1,26 @@\n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized5.rs:4:5\n    |\n+LL | struct S1<X: ?Sized> {\n+   |           -- help: consider further restricting this bound: `X: std::marker::Sized +`\n LL |     f1: X,\n    |     ^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: only the last field of a struct may have a dynamically sized type\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized5.rs:10:5\n    |\n+LL | struct S2<X: ?Sized> {\n+   |           -- help: consider further restricting this bound: `X: std::marker::Sized +`\n+LL |     f: isize,\n LL |     g: X,\n    |     ^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: only the last field of a struct may have a dynamically sized type\n \n error[E0277]: the size for values of type `str` cannot be known at compilation time\n@@ -43,23 +46,25 @@ LL |     f: [u8],\n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized5.rs:25:8\n    |\n+LL | enum E<X: ?Sized> {\n+   |        -- help: consider further restricting this bound: `X: std::marker::Sized +`\n LL |     V1(X, isize),\n    |        ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: no field of an enum variant may have a dynamically sized type\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized5.rs:29:8\n    |\n+LL | enum F<X: ?Sized> {\n+   |        -- help: consider further restricting this bound: `X: std::marker::Sized +`\n LL |     V2{f1: X, f: isize},\n    |        ^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: no field of an enum variant may have a dynamically sized type\n \n error: aborting due to 6 previous errors"}, {"sha": "95acd987a5a272f11f9d92f1a8a449a8e861f06a", "filename": "src/test/ui/unsized6.stderr", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized6.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -1,153 +1,174 @@\n error[E0277]: the size for values of type `Y` cannot be known at compilation time\n   --> $DIR/unsized6.rs:9:9\n    |\n+LL | fn f1<W: ?Sized, X: ?Sized, Y: ?Sized, Z: ?Sized>(x: &X) {\n+   |                             -- help: consider further restricting this bound: `Y: std::marker::Sized +`\n+...\n LL |     let y: Y;\n    |         ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Y`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where Y: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:7:12\n    |\n+LL | fn f1<W: ?Sized, X: ?Sized, Y: ?Sized, Z: ?Sized>(x: &X) {\n+   |                  -- help: consider further restricting this bound: `X: std::marker::Sized +`\n+LL |     let _: W; // <-- this is OK, no bindings created, no initializer.\n LL |     let _: (isize, (X, isize));\n    |            ^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: only the last element of a tuple may have a dynamically sized type\n \n error[E0277]: the size for values of type `Z` cannot be known at compilation time\n   --> $DIR/unsized6.rs:11:12\n    |\n+LL | fn f1<W: ?Sized, X: ?Sized, Y: ?Sized, Z: ?Sized>(x: &X) {\n+   |                                        -- help: consider further restricting this bound: `Z: std::marker::Sized +`\n+...\n LL |     let y: (isize, (Z, usize));\n    |            ^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Z`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where Z: std::marker::Sized` bound\n    = note: only the last element of a tuple may have a dynamically sized type\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:15:9\n    |\n+LL | fn f2<X: ?Sized, Y: ?Sized>(x: &X) {\n+   |       -- help: consider further restricting this bound: `X: std::marker::Sized +`\n LL |     let y: X;\n    |         ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `Y` cannot be known at compilation time\n   --> $DIR/unsized6.rs:17:12\n    |\n+LL | fn f2<X: ?Sized, Y: ?Sized>(x: &X) {\n+   |                  -- help: consider further restricting this bound: `Y: std::marker::Sized +`\n+...\n LL |     let y: (isize, (Y, isize));\n    |            ^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `Y`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where Y: std::marker::Sized` bound\n    = note: only the last element of a tuple may have a dynamically sized type\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:22:9\n    |\n+LL | fn f3<X: ?Sized>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n+   |       -- help: consider further restricting this bound: `X: std::marker::Sized +`\n LL |     let y: X = *x1;\n    |         ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:24:9\n    |\n+LL | fn f3<X: ?Sized>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n+   |       -- help: consider further restricting this bound: `X: std::marker::Sized +`\n+...\n LL |     let y = *x2;\n    |         ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:26:10\n    |\n+LL | fn f3<X: ?Sized>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n+   |       -- help: consider further restricting this bound: `X: std::marker::Sized +`\n+...\n LL |     let (y, z) = (*x3, 4);\n    |          ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:30:9\n    |\n+LL | fn f4<X: ?Sized + T>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n+   |       -- help: consider further restricting this bound: `X: std::marker::Sized +`\n LL |     let y: X = *x1;\n    |         ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:32:9\n    |\n+LL | fn f4<X: ?Sized + T>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n+   |       -- help: consider further restricting this bound: `X: std::marker::Sized +`\n+...\n LL |     let y = *x2;\n    |         ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:34:10\n    |\n+LL | fn f4<X: ?Sized + T>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {\n+   |       -- help: consider further restricting this bound: `X: std::marker::Sized +`\n+...\n LL |     let (y, z) = (*x3, 4);\n    |          ^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:38:18\n    |\n LL | fn g1<X: ?Sized>(x: X) {}\n-   |                  ^ doesn't have a size known at compile-time\n+   |       --         ^ doesn't have a size known at compile-time\n+   |       |\n+   |       help: consider further restricting this bound: `X: std::marker::Sized +`\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n \n error[E0277]: the size for values of type `X` cannot be known at compilation time\n   --> $DIR/unsized6.rs:40:22\n    |\n LL | fn g2<X: ?Sized + T>(x: X) {}\n-   |                      ^ doesn't have a size known at compile-time\n+   |       --             ^ doesn't have a size known at compile-time\n+   |       |\n+   |       help: consider further restricting this bound: `X: std::marker::Sized +`\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n    = note: all local variables must have a statically known size\n    = help: unsized locals are gated as an unstable feature\n "}, {"sha": "c77503a6f87aa705a74d87c466bae6425d3fbba0", "filename": "src/test/ui/unsized7.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Funsized7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized7.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -2,11 +2,12 @@ error[E0277]: the size for values of type `X` cannot be known at compilation tim\n   --> $DIR/unsized7.rs:12:21\n    |\n LL | impl<X: ?Sized + T> T1<X> for S3<X> {\n-   |                     ^^^^^ doesn't have a size known at compile-time\n+   |      --             ^^^^^ doesn't have a size known at compile-time\n+   |      |\n+   |      help: consider further restricting this bound: `X: std::marker::Sized +`\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `X`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = help: consider adding a `where X: std::marker::Sized` bound\n \n error: aborting due to previous error\n "}, {"sha": "eaacd6b6881eff2831f1479c23aaaa5be4abe570", "filename": "src/test/ui/wf/wf-enum-bound.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-enum-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-enum-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-enum-bound.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -6,12 +6,11 @@ LL |   trait ExtraCopy<T:Copy> { }\n LL | \n LL | / enum SomeEnum<T,U>\n LL | |     where T: ExtraCopy<U>\n+   | |                          - help: consider further restricting type parameter `U`: `, U: std::marker::Copy`\n LL | | {\n LL | |     SomeVariant(T,U)\n LL | | }\n    | |_^ the trait `std::marker::Copy` is not implemented for `U`\n-   |\n-   = help: consider adding a `where U: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "52882c460d228ad7f707bd583dc1cdbdd2470c78", "filename": "src/test/ui/wf/wf-enum-fields-struct-variant.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-enum-fields-struct-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-enum-fields-struct-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-enum-fields-struct-variant.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,10 +4,11 @@ error[E0277]: the trait bound `A: std::marker::Copy` is not satisfied\n LL | struct IsCopy<T:Copy> {\n    | --------------------- required by `IsCopy`\n ...\n+LL | enum AnotherEnum<A> {\n+   |                  - help: consider restricting this bound: `A: std::marker::Copy`\n+LL |     AnotherVariant {\n LL |         f: IsCopy<A>\n    |         ^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `A`\n-   |\n-   = help: consider adding a `where A: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "0fea35d68ea6ff435e206ae6ca743aedaae9790a", "filename": "src/test/ui/wf/wf-enum-fields.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-enum-fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-enum-fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-enum-fields.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,10 +4,10 @@ error[E0277]: the trait bound `A: std::marker::Copy` is not satisfied\n LL | struct IsCopy<T:Copy> {\n    | --------------------- required by `IsCopy`\n ...\n+LL | enum SomeEnum<A> {\n+   |               - help: consider restricting this bound: `A: std::marker::Copy`\n LL |     SomeVariant(IsCopy<A>)\n    |                 ^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `A`\n-   |\n-   = help: consider adding a `where A: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "9b8b04a7b86a3153d6236de59c7e8037552d340a", "filename": "src/test/ui/wf/wf-fn-where-clause.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-fn-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-fn-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-fn-where-clause.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,12 +4,13 @@ error[E0277]: the trait bound `U: std::marker::Copy` is not satisfied\n LL |   trait ExtraCopy<T:Copy> { }\n    |   ----------------------- required by `ExtraCopy`\n LL | \n-LL | / fn foo<T,U>() where T: ExtraCopy<U>\n+LL |   fn foo<T,U>() where T: ExtraCopy<U>\n+   |   ^                                  - help: consider further restricting type parameter `U`: `, U: std::marker::Copy`\n+   |  _|\n+   | |\n LL | | {\n LL | | }\n    | |_^ the trait `std::marker::Copy` is not implemented for `U`\n-   |\n-   = help: consider adding a `where U: std::marker::Copy` bound\n \n error[E0277]: the size for values of type `(dyn std::marker::Copy + 'static)` cannot be known at compilation time\n   --> $DIR/wf-fn-where-clause.rs:12:1"}, {"sha": "6d71670e6a84c0e8b091891cd5cce241e27b207b", "filename": "src/test/ui/wf/wf-impl-associated-type-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-impl-associated-type-trait.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,10 +4,10 @@ error[E0277]: the trait bound `T: MyHash` is not satisfied\n LL | pub struct MySet<T:MyHash> {\n    | -------------------------- required by `MySet`\n ...\n+LL | impl<T> Foo for T {\n+   |      - help: consider restricting this bound: `T: MyHash`\n LL |     type Bar = MySet<T>;\n    |     ^^^^^^^^^^^^^^^^^^^^ the trait `MyHash` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: MyHash` bound\n \n error: aborting due to previous error\n "}, {"sha": "3798ba1ec6e75a095479ffca6a14ce081c5f9cec", "filename": "src/test/ui/wf/wf-in-fn-arg.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-arg.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,12 +4,13 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n LL |   struct MustBeCopy<T:Copy> {\n    |   ------------------------- required by `MustBeCopy`\n ...\n-LL | / fn bar<T>(_: &MustBeCopy<T>)\n+LL |   fn bar<T>(_: &MustBeCopy<T>)\n+   |   ^      - help: consider restricting this bound: `T: std::marker::Copy`\n+   |  _|\n+   | |\n LL | | {\n LL | | }\n    | |_^ the trait `std::marker::Copy` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "2e46ce4900033f132b03ce3c392365f64424c9d5", "filename": "src/test/ui/wf/wf-in-fn-ret.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-ret.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,12 +4,13 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n LL |   struct MustBeCopy<T:Copy> {\n    |   ------------------------- required by `MustBeCopy`\n ...\n-LL | / fn bar<T>() -> MustBeCopy<T>\n+LL |   fn bar<T>() -> MustBeCopy<T>\n+   |   ^      - help: consider restricting this bound: `T: std::marker::Copy`\n+   |  _|\n+   | |\n LL | | {\n LL | | }\n    | |_^ the trait `std::marker::Copy` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "db4fb9f97f52d6377753177f0d9c404a3184edd6", "filename": "src/test/ui/wf/wf-in-fn-type-arg.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-arg.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,10 +4,11 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n LL | struct MustBeCopy<T:Copy> {\n    | ------------------------- required by `MustBeCopy`\n ...\n+LL | struct Bar<T> {\n+   |            - help: consider restricting this bound: `T: std::marker::Copy`\n+LL |     // needs T: Copy\n LL |     x: fn(MustBeCopy<T>)\n    |     ^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "09f8aa2a2018202c8f3a90ef2e5028c083234fe3", "filename": "src/test/ui/wf/wf-in-fn-type-ret.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-type-ret.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,10 +4,11 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n LL | struct MustBeCopy<T:Copy> {\n    | ------------------------- required by `MustBeCopy`\n ...\n+LL | struct Foo<T> {\n+   |            - help: consider restricting this bound: `T: std::marker::Copy`\n+LL |     // needs T: 'static\n LL |     x: fn() -> MustBeCopy<T>\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "979802dec49986d050d293ec70d790cfdbebf0ed", "filename": "src/test/ui/wf/wf-in-fn-where-clause.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-fn-where-clause.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -6,11 +6,10 @@ LL |   trait MustBeCopy<T:Copy> {\n ...\n LL | / fn bar<T,U>()\n LL | |     where T: MustBeCopy<U>\n+   | |                           - help: consider further restricting type parameter `U`: `, U: std::marker::Copy`\n LL | | {\n LL | | }\n    | |_^ the trait `std::marker::Copy` is not implemented for `U`\n-   |\n-   = help: consider adding a `where U: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "2711820d82c651081bd2a150b9da056d7577249f", "filename": "src/test/ui/wf/wf-in-obj-type-trait.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-in-obj-type-trait.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,10 +4,11 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n LL | struct MustBeCopy<T:Copy> {\n    | ------------------------- required by `MustBeCopy`\n ...\n+LL | struct Bar<T> {\n+   |            - help: consider restricting this bound: `T: std::marker::Copy`\n+LL |     // needs T: Copy\n LL |     x: dyn Object<MustBeCopy<T>>\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "21f825ac9ef9af71085207a9ea7a00e766df68e0", "filename": "src/test/ui/wf/wf-inherent-impl-method-where-clause.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-inherent-impl-method-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-inherent-impl-method-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-inherent-impl-method-where-clause.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,11 +4,11 @@ error[E0277]: the trait bound `U: std::marker::Copy` is not satisfied\n LL |   trait ExtraCopy<T:Copy> { }\n    |   ----------------------- required by `ExtraCopy`\n ...\n+LL |   impl<T,U> Foo<T,U> {\n+   |          - help: consider restricting this bound: `U: std::marker::Copy`\n LL | /     fn foo(self) where T: ExtraCopy<U>\n LL | |     {}\n    | |______^ the trait `std::marker::Copy` is not implemented for `U`\n-   |\n-   = help: consider adding a `where U: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "35b90933813299c85f42b27509d8556aebd88ca7", "filename": "src/test/ui/wf/wf-inherent-impl-where-clause.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-inherent-impl-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-inherent-impl-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-inherent-impl-where-clause.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,12 +4,13 @@ error[E0277]: the trait bound `U: std::marker::Copy` is not satisfied\n LL |   trait ExtraCopy<T:Copy> { }\n    |   ----------------------- required by `ExtraCopy`\n ...\n-LL | / impl<T,U> Foo<T,U> where T: ExtraCopy<U>\n+LL |   impl<T,U> Foo<T,U> where T: ExtraCopy<U>\n+   |   ^                                       - help: consider further restricting type parameter `U`: `, U: std::marker::Copy`\n+   |  _|\n+   | |\n LL | | {\n LL | | }\n    | |_^ the trait `std::marker::Copy` is not implemented for `U`\n-   |\n-   = help: consider adding a `where U: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "2155977349256cd9378a8583f0d5674b44c523b9", "filename": "src/test/ui/wf/wf-struct-bound.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-struct-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-struct-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-struct-bound.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -6,12 +6,11 @@ LL |   trait ExtraCopy<T:Copy> { }\n LL | \n LL | / struct SomeStruct<T,U>\n LL | |     where T: ExtraCopy<U>\n+   | |                          - help: consider further restricting type parameter `U`: `, U: std::marker::Copy`\n LL | | {\n LL | |     data: (T,U)\n LL | | }\n    | |_^ the trait `std::marker::Copy` is not implemented for `U`\n-   |\n-   = help: consider adding a `where U: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "6ac4f1e2da8d22a428a57a177ae0d66f2988e604", "filename": "src/test/ui/wf/wf-struct-field.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-struct-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-struct-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-struct-field.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,10 +4,10 @@ error[E0277]: the trait bound `A: std::marker::Copy` is not satisfied\n LL | struct IsCopy<T:Copy> {\n    | --------------------- required by `IsCopy`\n ...\n+LL | struct SomeStruct<A> {\n+   |                   - help: consider restricting this bound: `A: std::marker::Copy`\n LL |     data: IsCopy<A>\n    |     ^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `A`\n-   |\n-   = help: consider adding a `where A: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "af0433fd22f6e30f4997eeb8c86b785f62954180", "filename": "src/test/ui/wf/wf-trait-associated-type-bound.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-bound.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,12 +4,13 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n LL |   trait ExtraCopy<T:Copy> { }\n    |   ----------------------- required by `ExtraCopy`\n LL | \n-LL | / trait SomeTrait<T> {\n+LL |   trait SomeTrait<T> {\n+   |   ^               - help: consider restricting this bound: `T: std::marker::Copy`\n+   |  _|\n+   | |\n LL | |     type Type1: ExtraCopy<T>;\n LL | | }\n    | |_^ the trait `std::marker::Copy` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "93cb948cdbfcb0674080e6729f698e8c582110b7", "filename": "src/test/ui/wf/wf-trait-associated-type-trait.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-associated-type-trait.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -3,11 +3,12 @@ error[E0277]: the trait bound `<Self as SomeTrait>::Type1: std::marker::Copy` is\n    |\n LL | struct IsCopy<T:Copy> { x: T }\n    | --------------------- required by `IsCopy`\n-...\n+LL | \n+LL | trait SomeTrait {\n+   |                - help: consider further restricting the associated type: `where <Self as SomeTrait>::Type1: std::marker::Copy`\n+LL |     type Type1;\n LL |     type Type2 = IsCopy<Self::Type1>;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `<Self as SomeTrait>::Type1`\n-   |\n-   = help: consider adding a `where <Self as SomeTrait>::Type1: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "13e2f8f590149f0e17633d4c00fa5a84754d14d0", "filename": "src/test/ui/wf/wf-trait-bound.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-bound.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -6,11 +6,10 @@ LL |   trait ExtraCopy<T:Copy> { }\n LL | \n LL | / trait SomeTrait<T,U>\n LL | |     where T: ExtraCopy<U>\n+   | |                          - help: consider further restricting type parameter `U`: `, U: std::marker::Copy`\n LL | | {\n LL | | }\n    | |_^ the trait `std::marker::Copy` is not implemented for `U`\n-   |\n-   = help: consider adding a `where U: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "9f3545b9c6a6b3d10c5fc41c91899c95b38f07e9", "filename": "src/test/ui/wf/wf-trait-default-fn-arg.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-arg.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,14 +4,15 @@ error[E0277]: the trait bound `Self: std::cmp::Eq` is not satisfied\n LL |   struct Bar<T:Eq+?Sized> { value: Box<T> }\n    |   ----------------------- required by `Bar`\n ...\n-LL | /     fn bar(&self, x: &Bar<Self>) {\n+LL |       fn bar(&self, x: &Bar<Self>) {\n+   |       ^                           - help: consider further restricting `Self`: `where Self: std::cmp::Eq`\n+   |  _____|\n+   | |\n LL | |\n LL | |         //\n LL | |         // Here, Eq ought to be implemented.\n LL | |     }\n    | |_____^ the trait `std::cmp::Eq` is not implemented for `Self`\n-   |\n-   = help: consider adding a `where Self: std::cmp::Eq` bound\n \n error: aborting due to previous error\n "}, {"sha": "e32630a5a4a400025b55a06774fd01768d910fce", "filename": "src/test/ui/wf/wf-trait-default-fn-ret.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-ret.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,15 +4,16 @@ error[E0277]: the trait bound `Self: std::cmp::Eq` is not satisfied\n LL |   struct Bar<T:Eq+?Sized> { value: Box<T> }\n    |   ----------------------- required by `Bar`\n ...\n-LL | /     fn bar(&self) -> Bar<Self> {\n+LL |       fn bar(&self) -> Bar<Self> {\n+   |       ^                         - help: consider further restricting `Self`: `where Self: std::cmp::Eq`\n+   |  _____|\n+   | |\n LL | |\n LL | |         //\n LL | |         // Here, Eq ought to be implemented.\n LL | |         loop { }\n LL | |     }\n    | |_____^ the trait `std::cmp::Eq` is not implemented for `Self`\n-   |\n-   = help: consider adding a `where Self: std::cmp::Eq` bound\n \n error: aborting due to previous error\n "}, {"sha": "a443ff1bb63969ed2a9ecd16f3c311f04b9e726e", "filename": "src/test/ui/wf/wf-trait-default-fn-where-clause.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-default-fn-where-clause.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,14 +4,15 @@ error[E0277]: the trait bound `Self: std::cmp::Eq` is not satisfied\n LL |   trait Bar<T:Eq+?Sized> { }\n    |   ---------------------- required by `Bar`\n ...\n-LL | /     fn bar<A>(&self) where A: Bar<Self> {\n+LL |       fn bar<A>(&self) where A: Bar<Self> {\n+   |       ^                                  - help: consider further restricting `Self`: `, Self: std::cmp::Eq`\n+   |  _____|\n+   | |\n LL | |\n LL | |         //\n LL | |         // Here, Eq ought to be implemented.\n LL | |     }\n    | |_____^ the trait `std::cmp::Eq` is not implemented for `Self`\n-   |\n-   = help: consider adding a `where Self: std::cmp::Eq` bound\n \n error: aborting due to previous error\n "}, {"sha": "42a28ee676373c9638965f9f8b8739d2944a4341", "filename": "src/test/ui/wf/wf-trait-fn-arg.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-arg.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -5,9 +5,10 @@ LL | struct Bar<T:Eq+?Sized> { value: Box<T> }\n    | ----------------------- required by `Bar`\n ...\n LL |     fn bar(&self, x: &Bar<Self>);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::cmp::Eq` is not implemented for `Self`\n-   |\n-   = help: consider adding a `where Self: std::cmp::Eq` bound\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |                           |\n+   |     |                           help: consider further restricting `Self`: `where Self: std::cmp::Eq`\n+   |     the trait `std::cmp::Eq` is not implemented for `Self`\n \n error: aborting due to previous error\n "}, {"sha": "7ec4dbe0056b4acdf505748aae7b422d74176494", "filename": "src/test/ui/wf/wf-trait-fn-ret.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-ret.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -5,9 +5,10 @@ LL | struct Bar<T:Eq+?Sized> { value: Box<T> }\n    | ----------------------- required by `Bar`\n ...\n LL |     fn bar(&self) -> &Bar<Self>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::cmp::Eq` is not implemented for `Self`\n-   |\n-   = help: consider adding a `where Self: std::cmp::Eq` bound\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |                          |\n+   |     |                          help: consider further restricting `Self`: `where Self: std::cmp::Eq`\n+   |     the trait `std::cmp::Eq` is not implemented for `Self`\n \n error: aborting due to previous error\n "}, {"sha": "256edb5b2ca1d0a3fe8fc4855412268452279dc0", "filename": "src/test/ui/wf/wf-trait-fn-where-clause.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-fn-where-clause.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -5,9 +5,10 @@ LL | struct Bar<T:Eq+?Sized> { value: Box<T> }\n    | ----------------------- required by `Bar`\n ...\n LL |     fn bar(&self) where Self: Sized, Bar<Self>: Copy;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::cmp::Eq` is not implemented for `Self`\n-   |\n-   = help: consider adding a `where Self: std::cmp::Eq` bound\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |     |                                               |\n+   |     |                                               help: consider further restricting `Self`: `, Self: std::cmp::Eq`\n+   |     the trait `std::cmp::Eq` is not implemented for `Self`\n \n error: aborting due to previous error\n "}, {"sha": "a61b8dd3a3849ffff54cf1f48ee62ae6213582ab", "filename": "src/test/ui/wf/wf-trait-superbound.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-superbound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwf%2Fwf-trait-superbound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fwf-trait-superbound.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,11 +4,12 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n LL |   trait ExtraCopy<T:Copy> { }\n    |   ----------------------- required by `ExtraCopy`\n LL | \n-LL | / trait SomeTrait<T>: ExtraCopy<T> {\n+LL |   trait SomeTrait<T>: ExtraCopy<T> {\n+   |   ^               - help: consider restricting this bound: `T: std::marker::Copy`\n+   |  _|\n+   | |\n LL | | }\n    | |_^ the trait `std::marker::Copy` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "995b544600389fb58411d3cd654eaf236142b601", "filename": "src/test/ui/where-clauses/where-clause-constraints-are-local-for-inherent-impl.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-clause-constraints-are-local-for-inherent-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-clause-constraints-are-local-for-inherent-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-clause-constraints-are-local-for-inherent-impl.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,10 +4,11 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n LL | fn require_copy<T: Copy>(x: T) {}\n    |    ------------    ---- required by this bound in `require_copy`\n ...\n+LL | impl<T> Foo<T> {\n+   |      - help: consider restricting this bound: `T: std::marker::Copy`\n+...\n LL |         require_copy(self.x);\n    |                      ^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}, {"sha": "fe575f3a28a9ea13c32c7ec8a366480de2b546ff", "filename": "src/test/ui/where-clauses/where-clause-constraints-are-local-for-trait-impl.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-clause-constraints-are-local-for-trait-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c49187530d1e5599101ff74bcf3f82888e768def/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-clause-constraints-are-local-for-trait-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-clause-constraints-are-local-for-trait-impl.stderr?ref=c49187530d1e5599101ff74bcf3f82888e768def", "patch": "@@ -4,10 +4,11 @@ error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n LL | fn require_copy<T: Copy>(x: T) {}\n    |    ------------    ---- required by this bound in `require_copy`\n ...\n+LL | impl<T> Foo<T> for Bar<T> {\n+   |      - help: consider restricting this bound: `T: std::marker::Copy`\n+...\n LL |         require_copy(self.x);\n    |                      ^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n-   |\n-   = help: consider adding a `where T: std::marker::Copy` bound\n \n error: aborting due to previous error\n "}]}