{"sha": "9544c1760c5dbfe50b2f514bae4ef573f8c519cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NDRjMTc2MGM1ZGJmZTUwYjJmNTE0YmFlNGVmNTczZjhjNTE5Y2Y=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-12-15T09:17:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-12-15T09:17:32Z"}, "message": "Rollup merge of #56746 - pnkfelix:issue-56537-add-test-of-closure-using-region-from-containing-fn, r=nikomatsakis\n\nAdd test of current behavior (infer free region within closure body)\n\nThis behavior was previously not encoded in our test suite.\n\nit is pretty important that we test this behavior. In particular, in #56537  I had proposed expanding the lifetime elision rules so that they would apply to some of the cases encoded in this test, which would cause them to start failing to compile successfully (because the lifetime attached to the return type would start being treated as connected to the lifetime on the input parameter to the lambda expression, which is explicitly *not* what the code wants in this particular case).\n\nIn other words, I am trying to ensure that anyone who tries such experiments with lifetime elision in the future quickly finds out why we don't support lifetime elision on lambda expressions (at least not in the naive manner described on #56537).", "tree": {"sha": "9c206592fee8e54234dd735693e2b21bfc73407c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c206592fee8e54234dd735693e2b21bfc73407c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9544c1760c5dbfe50b2f514bae4ef573f8c519cf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcFMasCRBK7hj4Ov3rIwAAdHIIAHyguC1qncdlCswHQoJY1WkY\n/3NP8qSTMLcDpGGG7vFXQSiOvHd79D7C9bVsrRG4Phbrzlq8SwKvSQv2XtVggSb4\neTg2A8mUJ/q2XRrwf9tDUfvoOc/GVY6SdHuILM/4RrKC2Hno2xfpwyohlX57+fb3\nghZmGFZuQ6Eajna+Fw4Gq5bKIvGD58TTUshigcycNEvc2ieOq1HwB45vDF+DOes1\nlPGMrtzbtIAKw+3EQlDeA+MtWZwykcYyWRWF299s7GL4rHv9kZo58BrRt2JSkbPF\ngrL6vJtC4rx8qMk1ec1aufS3bsH+13tE2OYJBYitSbEyQ7jfMYftKSq+lBlbcXM=\n=5R4/\n-----END PGP SIGNATURE-----\n", "payload": "tree 9c206592fee8e54234dd735693e2b21bfc73407c\nparent 846db94c667e534ec4886842030a8128186a51dd\nparent 29e7ca940b781537605147455410914e8167f40f\nauthor Pietro Albini <pietro@pietroalbini.org> 1544865452 +0100\ncommitter GitHub <noreply@github.com> 1544865452 +0100\n\nRollup merge of #56746 - pnkfelix:issue-56537-add-test-of-closure-using-region-from-containing-fn, r=nikomatsakis\n\nAdd test of current behavior (infer free region within closure body)\n\nThis behavior was previously not encoded in our test suite.\n\nit is pretty important that we test this behavior. In particular, in #56537  I had proposed expanding the lifetime elision rules so that they would apply to some of the cases encoded in this test, which would cause them to start failing to compile successfully (because the lifetime attached to the return type would start being treated as connected to the lifetime on the input parameter to the lambda expression, which is explicitly *not* what the code wants in this particular case).\n\nIn other words, I am trying to ensure that anyone who tries such experiments with lifetime elision in the future quickly finds out why we don't support lifetime elision on lambda expressions (at least not in the naive manner described on #56537).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9544c1760c5dbfe50b2f514bae4ef573f8c519cf", "html_url": "https://github.com/rust-lang/rust/commit/9544c1760c5dbfe50b2f514bae4ef573f8c519cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9544c1760c5dbfe50b2f514bae4ef573f8c519cf/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "846db94c667e534ec4886842030a8128186a51dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/846db94c667e534ec4886842030a8128186a51dd", "html_url": "https://github.com/rust-lang/rust/commit/846db94c667e534ec4886842030a8128186a51dd"}, {"sha": "29e7ca940b781537605147455410914e8167f40f", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e7ca940b781537605147455410914e8167f40f", "html_url": "https://github.com/rust-lang/rust/commit/29e7ca940b781537605147455410914e8167f40f"}], "stats": {"total": 74, "additions": 74, "deletions": 0}, "files": [{"sha": "24676fe5e5bd9dffbcea74991d93b37f96e53faa", "filename": "src/test/ui/regions/issue-56537-closure-uses-region-from-container.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9544c1760c5dbfe50b2f514bae4ef573f8c519cf/src%2Ftest%2Fui%2Fregions%2Fissue-56537-closure-uses-region-from-container.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9544c1760c5dbfe50b2f514bae4ef573f8c519cf/src%2Ftest%2Fui%2Fregions%2Fissue-56537-closure-uses-region-from-container.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fissue-56537-closure-uses-region-from-container.rs?ref=9544c1760c5dbfe50b2f514bae4ef573f8c519cf", "patch": "@@ -0,0 +1,74 @@\n+// This is a collection of examples where a function's formal\n+// parameter has an explicit lifetime and a closure within that\n+// function returns that formal parameter. The closure's return type,\n+// to be correctly inferred, needs to include the lifetime introduced\n+// by the function.\n+//\n+// This works today, which precludes changing things so that closures\n+// follow the same lifetime-elision rules used elsehwere. See\n+// rust-lang/rust#56537\n+\n+// compile-pass\n+// We are already testing NLL explicitly via the revision system below.\n+// ignore-compare-mode-nll\n+\n+// revisions: ll nll migrate\n+//[ll] compile-flags:-Zborrowck=ast\n+//[nll] compile-flags:-Zborrowck=mir -Z two-phase-borrows\n+//[migrate] compile-flags:-Zborrowck=migrate -Z two-phase-borrows\n+\n+fn willy_no_annot<'w>(p: &'w str, q: &str) -> &'w str {\n+    let free_dumb = |_x| { p }; // no type annotation at all\n+    let hello = format!(\"Hello\");\n+    free_dumb(&hello)\n+}\n+\n+fn willy_ret_type_annot<'w>(p: &'w str, q: &str) -> &'w str {\n+    let free_dumb = |_x| -> &str { p }; // type annotation on the return type\n+    let hello = format!(\"Hello\");\n+    free_dumb(&hello)\n+}\n+\n+fn willy_ret_region_annot<'w>(p: &'w str, q: &str) -> &'w str {\n+    let free_dumb = |_x| -> &'w str { p }; // type+region annotation on return type\n+    let hello = format!(\"Hello\");\n+    free_dumb(&hello)\n+}\n+\n+fn willy_arg_type_ret_type_annot<'w>(p: &'w str, q: &str) -> &'w str {\n+    let free_dumb = |_x: &str| -> &str { p }; // type annotation on arg and return types\n+    let hello = format!(\"Hello\");\n+    free_dumb(&hello)\n+}\n+\n+fn willy_arg_type_ret_region_annot<'w>(p: &'w str, q: &str) -> &'w str {\n+    let free_dumb = |_x: &str| -> &'w str { p }; // fully annotated\n+    let hello = format!(\"Hello\");\n+    free_dumb(&hello)\n+}\n+\n+fn main() {\n+    let world = format!(\"World\");\n+    let w1: &str = {\n+        let hello = format!(\"He11o\");\n+        willy_no_annot(&world, &hello)\n+    };\n+    let w2: &str = {\n+        let hello = format!(\"He22o\");\n+        willy_ret_type_annot(&world, &hello)\n+    };\n+    let w3: &str = {\n+        let hello = format!(\"He33o\");\n+        willy_ret_region_annot(&world, &hello)\n+    };\n+    let w4: &str = {\n+        let hello = format!(\"He44o\");\n+        willy_arg_type_ret_type_annot(&world, &hello)\n+    };\n+    let w5: &str = {\n+        let hello = format!(\"He55o\");\n+        willy_arg_type_ret_region_annot(&world, &hello)\n+    };\n+    assert_eq!((w1, w2, w3, w4, w5),\n+               (\"World\",\"World\",\"World\",\"World\",\"World\"));\n+}"}]}