{"sha": "6efd16629c695e5ab6575ac5a0593b264cdfe04b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlZmQxNjYyOWM2OTVlNWFiNjU3NWFjNWEwNTkzYjI2NGNkZmUwNGI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-19T16:30:09Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-19T18:04:44Z"}, "message": "rustc: Add official support for weak failure\n\nThis commit is part of the ongoing libstd facade efforts (cc #13851). The\ncompiler now recognizes some language items as \"extern { fn foo(...); }\" and\nwill automatically perform the following actions:\n\n1. The foreign function has a pre-defined name.\n2. The crate and downstream crates can only be built as rlibs until a crate\n   defines the lang item itself.\n3. The actual lang item has a pre-defined name.\n\nThis is essentially nicer compiler support for the hokey\ncore-depends-on-std-failure scheme today, but it is implemented the same way.\nThe details are a little more hidden under the covers.\n\nIn addition to failure, this commit promotes the eh_personality and\nrust_stack_exhausted functions to official lang items. The compiler can generate\ncalls to these functions, causing linkage errors if they are left undefined. The\nchecking for these items is not as precise as it could be. Crates compiling with\n`-Z no-landing-pads` will not need the eh_personality lang item, and crates\ncompiling with no split stacks won't need the stack exhausted lang item. For\nease, however, these items are checked for presence in all final outputs of the\ncompiler.\n\nIt is quite easy to define dummy versions of the functions necessary:\n\n    #[lang = \"stack_exhausted\"]\n    extern fn stack_exhausted() { /* ... */ }\n\n    #[lang = \"eh_personality\"]\n    extern fn eh_personality() { /* ... */ }\n\ncc #11922, rust_stack_exhausted is now a lang item\ncc #13851, libcollections is blocked on eh_personality becoming weak", "tree": {"sha": "c365372d5da652613cc3a68545cf3339adc4a293", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c365372d5da652613cc3a68545cf3339adc4a293"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6efd16629c695e5ab6575ac5a0593b264cdfe04b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6efd16629c695e5ab6575ac5a0593b264cdfe04b", "html_url": "https://github.com/rust-lang/rust/commit/6efd16629c695e5ab6575ac5a0593b264cdfe04b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6efd16629c695e5ab6575ac5a0593b264cdfe04b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed156772bd95b8d621d50102922e5f5ac886d4a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed156772bd95b8d621d50102922e5f5ac886d4a1", "html_url": "https://github.com/rust-lang/rust/commit/ed156772bd95b8d621d50102922e5f5ac886d4a1"}], "stats": {"total": 435, "additions": 403, "deletions": 32}, "files": [{"sha": "003ebed63644f67ced884a71d745412c28cae8fb", "filename": "src/libcore/failure.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibcore%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibcore%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffailure.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -60,10 +60,19 @@ fn fail_bounds_check(file: *u8, line: uint, index: uint, len: uint) -> ! {\n \n #[cold]\n pub fn begin_unwind(fmt: &fmt::Arguments, file: &'static str, line: uint) -> ! {\n-    // FIXME: this should be a proper lang item, it should not just be some\n-    //        undefined symbol sitting in the middle of nowhere.\n     #[allow(ctypes)]\n-    extern { fn rust_begin_unwind(fmt: &fmt::Arguments, file: &'static str,\n-                                  line: uint) -> !; }\n-    unsafe { rust_begin_unwind(fmt, file, line) }\n+    #[cfg(stage0)]\n+    extern {\n+        #[link_name = \"rust_begin_unwind\"]\n+        fn begin_unwind(fmt: &fmt::Arguments, file: &'static str,\n+                        line: uint) -> !;\n+    }\n+    #[allow(ctypes)]\n+    #[cfg(not(stage0))]\n+    extern {\n+        #[lang = \"begin_unwind\"]\n+        fn begin_unwind(fmt: &fmt::Arguments, file: &'static str,\n+                        line: uint) -> !;\n+    }\n+    unsafe { begin_unwind(fmt, file, line) }\n }"}, {"sha": "5f13ed4942edda3f33087469d053f5fb4523903e", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -78,6 +78,7 @@ pub mod middle {\n     pub mod dead;\n     pub mod expr_use_visitor;\n     pub mod dependency_format;\n+    pub mod weak_lang_items;\n }\n \n pub mod front {"}, {"sha": "f30d6119339ab5dfd612a84b5755589dd1f85cca", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -167,8 +167,9 @@ pub static tag_lang_items: uint = 0x70;\n pub static tag_lang_items_item: uint = 0x71;\n pub static tag_lang_items_item_id: uint = 0x72;\n pub static tag_lang_items_item_node_id: uint = 0x73;\n+pub static tag_lang_items_missing: uint = 0x74;\n \n-pub static tag_item_unnamed_field: uint = 0x74;\n+pub static tag_item_unnamed_field: uint = 0x75;\n pub static tag_items_data_item_visibility: uint = 0x76;\n pub static tag_items_data_item_sized: uint = 0x77;\n "}, {"sha": "f30e24a3151d79822ace3b95762f4f0a438b6ae5", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -15,6 +15,7 @@\n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n+use middle::lang_items;\n use middle::ty;\n use middle::typeck;\n \n@@ -298,3 +299,10 @@ pub fn get_dylib_dependency_formats(cstore: &cstore::CStore,\n     let cdata = cstore.get_crate_data(cnum);\n     decoder::get_dylib_dependency_formats(&*cdata)\n }\n+\n+pub fn get_missing_lang_items(cstore: &cstore::CStore, cnum: ast::CrateNum)\n+    -> Vec<lang_items::LangItem>\n+{\n+    let cdata = cstore.get_crate_data(cnum);\n+    decoder::get_missing_lang_items(&*cdata)\n+}"}, {"sha": "b3ef888c0b466da89068758bfc97c8e165f46244", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -21,6 +21,7 @@ use metadata::cstore;\n use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_type_param_def_data,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n+use middle::lang_items;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty;\n use middle::typeck;\n@@ -1299,3 +1300,17 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n     }\n     return result;\n }\n+\n+pub fn get_missing_lang_items(cdata: Cmd)\n+    -> Vec<lang_items::LangItem>\n+{\n+    let items = reader::get_doc(reader::Doc(cdata.data()), tag_lang_items);\n+    let mut result = Vec::new();\n+    reader::tagged_docs(items, tag_lang_items_missing, |missing_doc| {\n+        let item: lang_items::LangItem =\n+            FromPrimitive::from_u32(reader::doc_as_u32(missing_doc)).unwrap();\n+        result.push(item);\n+        true\n+    });\n+    return result;\n+}"}, {"sha": "34baed3acc8e7e18c7223e7d80c323cb7815d67e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -1518,6 +1518,10 @@ fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n         }\n     }\n \n+    for i in ecx.tcx.lang_items.missing.iter() {\n+        ebml_w.wr_tagged_u32(tag_lang_items_missing, *i as u32);\n+    }\n+\n     ebml_w.end_tag();   // tag_lang_items\n }\n "}, {"sha": "81e9c3f5ec6b22a3183a5c89624ddf1de993bde4", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -23,6 +23,7 @@\n use driver::session::Session;\n use metadata::csearch::each_lang_item;\n use middle::ty;\n+use middle::weak_lang_items;\n use syntax::ast;\n use syntax::ast_util::local_def;\n use syntax::attr::AttrMetaMethods;\n@@ -41,21 +42,23 @@ macro_rules! lets_do_this {\n         $( $variant:ident, $name:expr, $method:ident; )*\n     ) => {\n \n-#[deriving(FromPrimitive)]\n+#[deriving(FromPrimitive, Eq, TotalEq, Hash)]\n pub enum LangItem {\n     $($variant),*\n }\n \n pub struct LanguageItems {\n-    pub items: Vec<Option<ast::DefId>> ,\n+    pub items: Vec<Option<ast::DefId>>,\n+    pub missing: Vec<LangItem>,\n }\n \n impl LanguageItems {\n     pub fn new() -> LanguageItems {\n         fn foo(_: LangItem) -> Option<ast::DefId> { None }\n \n         LanguageItems {\n-            items: vec!($(foo($variant)),*)\n+            items: vec!($(foo($variant)),*),\n+            missing: Vec::new(),\n         }\n     }\n \n@@ -198,7 +201,8 @@ pub fn collect_language_items(krate: &ast::Crate,\n                               session: &Session) -> LanguageItems {\n     let mut collector = LanguageItemCollector::new(session);\n     collector.collect(krate);\n-    let LanguageItemCollector { items, .. } = collector;\n+    let LanguageItemCollector { mut items, .. } = collector;\n+    weak_lang_items::check_crate(krate, session, &mut items);\n     session.abort_if_errors();\n     items\n }\n@@ -240,8 +244,20 @@ lets_do_this! {\n \n     StrEqFnLangItem,                 \"str_eq\",                  str_eq_fn;\n     UniqStrEqFnLangItem,             \"uniq_str_eq\",             uniq_str_eq_fn;\n+\n+    // A number of failure-related lang items. The `fail_` item corresponds to\n+    // divide-by-zero and various failure cases with `match`. The\n+    // `fail_bounds_check` item is for indexing arrays.\n+    //\n+    // The `begin_unwind` lang item has a predefined symbol name and is sort of\n+    // a \"weak lang item\" in the sense that a crate is not required to have it\n+    // defined to use it, but a final product is required to define it\n+    // somewhere. Additionally, there are restrictions on crates that use a weak\n+    // lang item, but do not have it defined.\n     FailFnLangItem,                  \"fail_\",                   fail_fn;\n     FailBoundsCheckFnLangItem,       \"fail_bounds_check\",       fail_bounds_check_fn;\n+    BeginUnwindLangItem,             \"begin_unwind\",            begin_unwind;\n+\n     ExchangeMallocFnLangItem,        \"exchange_malloc\",         exchange_malloc_fn;\n     ClosureExchangeMallocFnLangItem, \"closure_exchange_malloc\", closure_exchange_malloc_fn;\n     ExchangeFreeFnLangItem,          \"exchange_free\",           exchange_free_fn;\n@@ -257,7 +273,7 @@ lets_do_this! {\n \n     TypeIdLangItem,                  \"type_id\",                 type_id;\n \n-    EhPersonalityLangItem,           \"eh_personality\",          eh_personality_fn;\n+    EhPersonalityLangItem,           \"eh_personality\",          eh_personality;\n \n     ManagedHeapLangItem,             \"managed_heap\",            managed_heap;\n     ExchangeHeapLangItem,            \"exchange_heap\",           exchange_heap;\n@@ -276,4 +292,6 @@ lets_do_this! {\n     NoCopyItem,                      \"no_copy_bound\",           no_copy_bound;\n     NoShareItem,                     \"no_share_bound\",          no_share_bound;\n     ManagedItem,                     \"managed_bound\",           managed_bound;\n+\n+    StackExhaustedLangItem,          \"stack_exhausted\",         stack_exhausted;\n }"}, {"sha": "a88bc2432772bdcc1bfe3b845741dfc774efdc7a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -38,6 +38,7 @@ use lib;\n use metadata::{csearch, encoder};\n use middle::astencode;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n+use middle::weak_lang_items;\n use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::build::*;\n@@ -1679,6 +1680,19 @@ fn finish_register_fn(ccx: &CrateContext, sp: Span, sym: StrBuf, node_id: ast::N\n         lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     }\n \n+    // The stack exhaustion lang item shouldn't have a split stack because\n+    // otherwise it would continue to be exhausted (bad), and both it and the\n+    // eh_personality functions need to be externally linkable.\n+    let def = ast_util::local_def(node_id);\n+    if ccx.tcx.lang_items.stack_exhausted() == Some(def) {\n+        unset_split_stack(llfn);\n+        lib::llvm::SetLinkage(llfn, lib::llvm::ExternalLinkage);\n+    }\n+    if ccx.tcx.lang_items.eh_personality() == Some(def) {\n+        lib::llvm::SetLinkage(llfn, lib::llvm::ExternalLinkage);\n+    }\n+\n+\n     if is_entry_fn(ccx.sess(), node_id) {\n         create_entry_wrapper(ccx, sp, llfn);\n     }\n@@ -1816,8 +1830,13 @@ fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n                 // Don't mangle\n                 path.last().unwrap().to_str().to_strbuf()\n             } else {\n-                // Usual name mangling\n-                mangle_exported_name(ccx, path, ty, id)\n+                match weak_lang_items::link_name(attrs) {\n+                    Some(name) => name.get().to_strbuf(),\n+                    None => {\n+                        // Usual name mangling\n+                        mangle_exported_name(ccx, path, ty, id)\n+                    }\n+                }\n             }\n         })\n     }"}, {"sha": "87cde42e39863e0966490043524a8a0a47f77770", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -14,7 +14,6 @@\n  */\n \n use lib::llvm::{BasicBlockRef, ValueRef};\n-use middle::lang_items::{EhPersonalityLangItem};\n use middle::trans::base;\n use middle::trans::build;\n use middle::trans::callee;\n@@ -665,8 +664,31 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n                                     false);\n \n         // The exception handling personality function.\n-        let def_id = common::langcall(pad_bcx, None, \"\", EhPersonalityLangItem);\n-        let llpersonality = callee::trans_fn_ref(pad_bcx, def_id, ExprId(0));\n+        //\n+        // If our compilation unit has the `eh_personality` lang item somewhere\n+        // within it, then we just need to translate that. Otherwise, we're\n+        // building an rlib which will depend on some upstream implementation of\n+        // this function, so we just codegen a generic reference to it. We don't\n+        // specify any of the types for the function, we just make it a symbol\n+        // that LLVM can later use.\n+        let llpersonality = match pad_bcx.tcx().lang_items.eh_personality() {\n+            Some(def_id) => callee::trans_fn_ref(pad_bcx, def_id, ExprId(0)),\n+            None => {\n+                let mut personality = self.ccx.eh_personality.borrow_mut();\n+                match *personality {\n+                    Some(llpersonality) => llpersonality,\n+                    None => {\n+                        let fty = Type::variadic_func(&[], &Type::i32(self.ccx));\n+                        let f = base::decl_cdecl_fn(self.ccx.llmod,\n+                                                    \"rust_eh_personality\",\n+                                                    fty,\n+                                                    ty::mk_i32());\n+                        *personality = Some(f);\n+                        f\n+                    }\n+                }\n+            }\n+        };\n \n         // The only landing pad clause will be 'cleanup'\n         let llretval = build::LandingPad(pad_bcx, llretty, llpersonality, 1u);"}, {"sha": "a737361b55a117b97fb3b7ec60f27d1af59483d4", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -122,6 +122,8 @@ pub struct CrateContext {\n     pub uses_gc: bool,\n     pub dbg_cx: Option<debuginfo::CrateDebugContext>,\n \n+    pub eh_personality: RefCell<Option<ValueRef>>,\n+\n     intrinsics: RefCell<HashMap<&'static str, ValueRef>>,\n }\n \n@@ -224,6 +226,7 @@ impl CrateContext {\n                 builder: BuilderRef_res(llvm::LLVMCreateBuilderInContext(llcx)),\n                 uses_gc: false,\n                 dbg_cx: dbg_cx,\n+                eh_personality: RefCell::new(None),\n                 intrinsics: RefCell::new(HashMap::new()),\n             };\n "}, {"sha": "fb6aff0e26ed1d7ae27dfd1a63199d43d0d20033", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -13,6 +13,7 @@ use back::{link};\n use lib::llvm::llvm;\n use lib::llvm::{ValueRef, CallConv, StructRetAttribute, Linkage};\n use lib;\n+use middle::weak_lang_items;\n use middle::trans::base::push_ctxt;\n use middle::trans::base;\n use middle::trans::build::*;\n@@ -815,10 +816,12 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n // the massive simplifications that have occurred.\n \n pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n-     match attr::first_attr_value_str_by_name(i.attrs.as_slice(),\n-                                              \"link_name\") {\n-        None => token::get_ident(i.ident),\n+    match attr::first_attr_value_str_by_name(i.attrs.as_slice(), \"link_name\") {\n         Some(ln) => ln.clone(),\n+        None => match weak_lang_items::link_name(i.attrs.as_slice()) {\n+            Some(name) => name,\n+            None => token::get_ident(i.ident),\n+        }\n     }\n }\n "}, {"sha": "cbe04e4fcda79ae2a60f634d6235995c38f8c824", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Validity checking for weak lang items\n+\n+use driver::config;\n+use driver::session::Session;\n+use metadata::csearch;\n+use middle::lang_items;\n+\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use syntax::parse::token::InternedString;\n+use syntax::visit::Visitor;\n+use syntax::visit;\n+\n+use collections::HashSet;\n+\n+macro_rules! weak_lang_items( ($($name:ident, $item:ident, $sym:ident;)*) => (\n+\n+struct Context<'a> {\n+    sess: &'a Session,\n+    items: &'a mut lang_items::LanguageItems,\n+}\n+\n+/// Checks the crate for usage of weak lang items, returning a vector of all the\n+/// language items required by this crate, but not defined yet.\n+pub fn check_crate(krate: &ast::Crate,\n+                   sess: &Session,\n+                   items: &mut lang_items::LanguageItems) {\n+    // These are never called by user code, they're generated by the compiler.\n+    // They will never implicitly be added to the `missing` array unless we do\n+    // so here.\n+    if items.stack_exhausted().is_none() {\n+        items.missing.push(lang_items::StackExhaustedLangItem);\n+    }\n+    if items.eh_personality().is_none() {\n+        items.missing.push(lang_items::EhPersonalityLangItem);\n+    }\n+\n+    {\n+        let mut cx = Context { sess: sess, items: items };\n+        visit::walk_crate(&mut cx, krate, ());\n+    }\n+    verify(sess, items);\n+}\n+\n+pub fn link_name(attrs: &[ast::Attribute]) -> Option<InternedString> {\n+    lang_items::extract(attrs).and_then(|name| {\n+        $(if name.get() == stringify!($name) {\n+            Some(InternedString::new(stringify!($sym)))\n+        } else)* {\n+            None\n+        }\n+    })\n+}\n+\n+fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n+    // We only need to check for the presence of weak lang items if we're\n+    // emitting something that's not an rlib.\n+    let needs_check = sess.crate_types.borrow().iter().any(|kind| {\n+        match *kind {\n+            config::CrateTypeDylib |\n+            config::CrateTypeExecutable |\n+            config::CrateTypeStaticlib => true,\n+            config::CrateTypeRlib => false,\n+        }\n+    });\n+    if !needs_check { return }\n+\n+    let mut missing = HashSet::new();\n+    sess.cstore.iter_crate_data(|cnum, _| {\n+        for item in csearch::get_missing_lang_items(&sess.cstore, cnum).iter() {\n+            missing.insert(*item);\n+        }\n+    });\n+\n+    $(\n+        if missing.contains(&lang_items::$item) && items.$name().is_none() {\n+            sess.err(format!(\"language item required, but not found: `{}`\",\n+                             stringify!($name)));\n+\n+        }\n+    )*\n+}\n+\n+impl<'a> Context<'a> {\n+    fn register(&mut self, name: &str, span: Span) {\n+        $(if name == stringify!($name) {\n+            if self.items.$name().is_none() {\n+                self.items.missing.push(lang_items::$item);\n+            }\n+        } else)* {\n+            self.sess.span_err(span,\n+                               format!(\"unknown external lang item: `{}`\",\n+                                       name));\n+        }\n+    }\n+}\n+\n+impl<'a> Visitor<()> for Context<'a> {\n+    fn visit_foreign_item(&mut self, i: &ast::ForeignItem, _: ()) {\n+        match lang_items::extract(i.attrs.as_slice()) {\n+            None => {}\n+            Some(lang_item) => self.register(lang_item.get(), i.span),\n+        }\n+        visit::walk_foreign_item(self, i, ())\n+    }\n+}\n+\n+) )\n+\n+weak_lang_items!(\n+    begin_unwind,       BeginUnwindLangItem,        rust_begin_unwind;\n+    stack_exhausted,    StackExhaustedLangItem,     rust_stack_exhausted;\n+    eh_personality,     EhPersonalityLangItem,      rust_eh_personality;\n+)"}, {"sha": "4e2b23310ab49903ea31de066239bfbe23c885e5", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -71,7 +71,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<StrBuf>)\n     let sessopts = driver::config::Options {\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),\n         addl_lib_search_paths: RefCell::new(libs),\n-        crate_types: vec!(driver::config::CrateTypeDylib),\n+        crate_types: vec!(driver::config::CrateTypeRlib),\n         lint_opts: vec!((lint::Warnings, lint::allow)),\n         ..rustc::driver::config::basic_options().clone()\n     };"}, {"sha": "b3be742e1edc3b1dd6ef258e334645159565edab", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -30,12 +30,9 @@ pub static RED_ZONE: uint = 20 * 1024;\n /// stacks are currently not enabled as segmented stacks, but rather one giant\n /// stack segment. This means that whenever we run out of stack, we want to\n /// truly consider it to be stack overflow rather than allocating a new stack.\n-#[no_mangle]      // - this is called from C code\n-#[no_split_stack] // - it would be sad for this function to trigger __morestack\n-#[doc(hidden)]    // - Function must be `pub` to get exported, but it's\n-                  //   irrelevant for documentation purposes.\n-#[cfg(not(test))] // in testing, use the original libstd's version\n-pub extern \"C\" fn rust_stack_exhausted() {\n+#[cfg(not(test), not(stage0))] // in testing, use the original libstd's version\n+#[lang = \"stack_exhausted\"]\n+extern fn stack_exhausted() {\n     use option::{Option, None, Some};\n     use owned::Box;\n     use rt::local::Local;\n@@ -106,6 +103,35 @@ pub extern \"C\" fn rust_stack_exhausted() {\n     }\n }\n \n+#[no_mangle]      // - this is called from C code\n+#[no_split_stack] // - it would be sad for this function to trigger __morestack\n+#[doc(hidden)]    // - Function must be `pub` to get exported, but it's\n+                  //   irrelevant for documentation purposes.\n+#[cfg(stage0, not(test))] // in testing, use the original libstd's version\n+pub extern \"C\" fn rust_stack_exhausted() {\n+    use option::{Option, None, Some};\n+    use owned::Box;\n+    use rt::local::Local;\n+    use rt::task::Task;\n+    use str::Str;\n+    use intrinsics;\n+\n+    unsafe {\n+        let limit = get_sp_limit();\n+        record_sp_limit(limit - RED_ZONE / 2);\n+        let task: Option<Box<Task>> = Local::try_take();\n+        let name = match task {\n+            Some(ref task) => {\n+                task.name.as_ref().map(|n| n.as_slice())\n+            }\n+            None => None\n+        };\n+        let name = name.unwrap_or(\"<unknown>\");\n+        rterrln!(\"task '{}' has overflowed its stack\", name);\n+        intrinsics::abort();\n+    }\n+}\n+\n #[inline(always)]\n pub unsafe fn record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n     // When the old runtime had segmented stacks, it used a calculation that was"}, {"sha": "af87a31b7bd81d1ae34305957d52f24bc9000a2a", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -211,8 +211,24 @@ pub mod eabi {\n             -> uw::_Unwind_Reason_Code;\n     }\n \n+    #[lang=\"eh_personality\"]\n+    #[cfg(not(stage0))]\n+    extern fn eh_personality(\n+        version: c_int,\n+        actions: uw::_Unwind_Action,\n+        exception_class: uw::_Unwind_Exception_Class,\n+        ue_header: *uw::_Unwind_Exception,\n+        context: *uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        unsafe {\n+            __gcc_personality_v0(version, actions, exception_class, ue_header,\n+                                 context)\n+        }\n+    }\n     #[lang=\"eh_personality\"]\n     #[no_mangle] // so we can reference it by name from middle/trans/base.rs\n+    #[cfg(stage0)]\n     pub extern \"C\" fn rust_eh_personality(\n         version: c_int,\n         actions: uw::_Unwind_Action,\n@@ -263,8 +279,22 @@ pub mod eabi {\n             -> uw::_Unwind_Reason_Code;\n     }\n \n+    #[lang=\"eh_personality\"]\n+    #[cfg(not(stage0))]\n+    extern \"C\" fn eh_personality(\n+        state: uw::_Unwind_State,\n+        ue_header: *uw::_Unwind_Exception,\n+        context: *uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        unsafe {\n+            __gcc_personality_v0(state, ue_header, context)\n+        }\n+    }\n+\n     #[lang=\"eh_personality\"]\n     #[no_mangle] // so we can reference it by name from middle/trans/base.rs\n+    #[cfg(stage0)]\n     pub extern \"C\" fn rust_eh_personality(\n         state: uw::_Unwind_State,\n         ue_header: *uw::_Unwind_Exception,\n@@ -296,8 +326,15 @@ pub mod eabi {\n }\n \n // Entry point of failure from the libcore crate\n+#[cfg(not(test), not(stage0))]\n+#[lang = \"begin_unwind\"]\n+pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n+                                file: &'static str, line: uint) -> ! {\n+    begin_unwind_fmt(msg, file, line)\n+}\n+\n #[no_mangle]\n-#[cfg(not(test))]\n+#[cfg(not(test), stage0)]\n pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n                                 file: &'static str, line: uint) -> ! {\n     begin_unwind_fmt(msg, file, line)\n@@ -310,7 +347,8 @@ pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n /// on (e.g.) the inlining of other functions as possible), by moving\n /// the actual formatting into this shared place.\n #[inline(never)] #[cold]\n-pub fn begin_unwind_fmt(msg: &fmt::Arguments, file: &'static str, line: uint) -> ! {\n+pub fn begin_unwind_fmt(msg: &fmt::Arguments, file: &'static str,\n+                        line: uint) -> ! {\n     // We do two allocations here, unfortunately. But (a) they're\n     // required with the current scheme, and (b) we don't handle\n     // failure + OOM properly anyway (see comment in begin_unwind"}, {"sha": "2c9a5bc433fb4b0fcd940d2d61c17a710116c4bd", "filename": "src/test/auxiliary/lang-item-public.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flang-item-public.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -13,5 +13,8 @@\n #[lang=\"fail_\"]\n fn fail(_: *i8, _: *i8, _: uint) -> ! { loop {} }\n \n-#[no_mangle]\n-pub extern \"C\" fn rust_stack_exhausted() {}\n+#[lang = \"stack_exhausted\"]\n+extern fn stack_exhausted() {}\n+\n+#[lang = \"eh_personality\"]\n+extern fn eh_personality() {}"}, {"sha": "68a2ae24b8563309fdaf3643a9a4128c0ba04879", "filename": "src/test/auxiliary/weak-lang-items.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+// This aux-file will require the eh_personality function to be codegen'd, but\n+// it hasn't been defined just yet. Make sure we don't explode.\n+\n+#![no_std]\n+#![feature(phase)]\n+#![crate_type = \"rlib\"]\n+\n+#[phase(syntax, link)]\n+extern crate core;\n+\n+struct A;\n+\n+impl core::ops::Drop for A {\n+    fn drop(&mut self) {}\n+}\n+\n+pub fn foo() {\n+    let _a = A;\n+    fail!(\"wut\");\n+}\n+\n+mod std {\n+    pub use core::{option, fmt};\n+}\n+"}, {"sha": "a1b64b77ac162c70bfb372f84789efaaf625d861", "filename": "src/test/compile-fail/weak-lang-item.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Ftest%2Fcompile-fail%2Fweak-lang-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Ftest%2Fcompile-fail%2Fweak-lang-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fweak-lang-item.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:weak-lang-items.rs\n+// error-pattern: language item required, but not found: `begin_unwind`\n+// error-pattern: language item required, but not found: `stack_exhausted`\n+// error-pattern: language item required, but not found: `eh_personality`\n+\n+#![no_std]\n+\n+extern crate core;\n+extern crate other = \"weak-lang-items\";"}, {"sha": "0dbd4c67530767f6e1bab8de5845039a0c1d34d9", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -19,8 +19,8 @@ extern crate libc;\n extern { fn puts(s: *u8); }\n extern \"rust-intrinsic\" { fn transmute<T, U>(t: T) -> U; }\n \n-#[no_mangle]\n-pub extern fn rust_stack_exhausted() {}\n+#[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n+#[lang = \"eh_personality\"] extern fn eh_personality() {}\n \n #[start]\n #[no_split_stack]"}, {"sha": "889259b6acd06f4eaa918b4a0288a0e9f120e026", "filename": "src/test/run-pass/weak-lang-item.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efd16629c695e5ab6575ac5a0593b264cdfe04b/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs?ref=6efd16629c695e5ab6575ac5a0593b264cdfe04b", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:weak-lang-items.rs\n+\n+extern crate other = \"weak-lang-items\";\n+\n+use std::task;\n+\n+fn main() {\n+    let _ = task::try(proc() {\n+        other::foo()\n+    });\n+}"}]}