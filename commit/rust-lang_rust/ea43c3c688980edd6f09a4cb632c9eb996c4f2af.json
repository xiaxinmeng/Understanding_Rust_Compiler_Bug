{"sha": "ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhNDNjM2M2ODg5ODBlZGQ2ZjA5YTRjYjYzMmM5ZWI5OTZjNGYyYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-26T06:13:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-26T06:13:27Z"}, "message": "Auto merge of #58561 - ljedrz:HirIdify_some_nodes, r=Zoxc\n\nRemove NodeId from some HIR nodes\n\nThe next iteration of https://github.com/rust-lang/rust/pull/57578.\n\nRemoves `NodeId` from:\n\n- [x] `Lifetime`\n- [x] `Ty`\n- [x] `GenericParam`\n- [x] `WhereClause`\n- [x] `WhereEqPredicate`\n- [x] `MacroDef`\n- [x] `Block`\n- [x] `Expr`\n\nr? @Zoxc", "tree": {"sha": "b6414389576be62f7ae6058a1f7ff69a46277944", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6414389576be62f7ae6058a1f7ff69a46277944"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "html_url": "https://github.com/rust-lang/rust/commit/ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb162e69449b423c5aed0d9c39f6c046fa300c30", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb162e69449b423c5aed0d9c39f6c046fa300c30", "html_url": "https://github.com/rust-lang/rust/commit/fb162e69449b423c5aed0d9c39f6c046fa300c30"}, {"sha": "77a30ec593002b8e1c7887a14432e9a60f8f74db", "url": "https://api.github.com/repos/rust-lang/rust/commits/77a30ec593002b8e1c7887a14432e9a60f8f74db", "html_url": "https://github.com/rust-lang/rust/commit/77a30ec593002b8e1c7887a14432e9a60f8f74db"}], "stats": {"total": 1315, "additions": 642, "deletions": 673}, "files": [{"sha": "30a0477467d8016ff94d58cebc0a5174a2175239", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -398,7 +398,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             args: I) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        let m = self.tcx.hir().get_module_parent(call_expr.id);\n+        let m = self.tcx.hir().get_module_parent_by_hir_id(call_expr.hir_id);\n         if self.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(call_expr)) {\n             self.add_unreachable_node()\n         } else {"}, {"sha": "0211dd7287563d911148e0b2283f788d1fd53d11", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 23, "deletions": 48, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -780,7 +780,6 @@ impl<'a> LoweringContext<'a> {\n                 );\n \n                 hir::GenericParam {\n-                    id: node_id,\n                     hir_id,\n                     name: hir_name,\n                     attrs: hir_vec![],\n@@ -964,7 +963,6 @@ impl<'a> LoweringContext<'a> {\n         let closure_hir_id = self.lower_node_id(closure_node_id).hir_id;\n         let decl = self.lower_fn_decl(&decl, None, /* impl trait allowed */ false, None);\n         let generator = hir::Expr {\n-            id: closure_node_id,\n             hir_id: closure_hir_id,\n             node: hir::ExprKind::Closure(capture_clause, decl, body_id, span,\n                 Some(hir::GeneratorMovability::Static)),\n@@ -1300,7 +1298,6 @@ impl<'a> LoweringContext<'a> {\n                         // Set the name to `impl Bound1 + Bound2`.\n                         let ident = Ident::from_str(&pprust::ty_to_string(t)).with_span_pos(span);\n                         in_band_ty_params.push(hir::GenericParam {\n-                            id: def_node_id,\n                             hir_id,\n                             name: ParamName::Plain(ident),\n                             pure_wrt_drop: false,\n@@ -1350,9 +1347,8 @@ impl<'a> LoweringContext<'a> {\n             TyKind::Mac(_) => panic!(\"TyMac should have been expanded by now.\"),\n         };\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(t.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(t.id);\n         hir::Ty {\n-            id: node_id,\n             node: kind,\n             span: t.span,\n             hir_id,\n@@ -1394,12 +1390,11 @@ impl<'a> LoweringContext<'a> {\n         );\n \n         self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n-            let LoweredNodeId { node_id, hir_id } = lctx.next_id();\n+            let LoweredNodeId { node_id: _, hir_id } = lctx.next_id();\n             let exist_ty_item_kind = hir::ItemKind::Existential(hir::ExistTy {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n                     where_clause: hir::WhereClause {\n-                        id: node_id,\n                         hir_id,\n                         predicates: Vec::new().into(),\n                     },\n@@ -1533,9 +1528,8 @@ impl<'a> LoweringContext<'a> {\n                     && !self.already_defined_lifetimes.contains(&name) {\n                     self.already_defined_lifetimes.insert(name);\n \n-                    let LoweredNodeId { node_id, hir_id } = self.context.next_id();\n+                    let LoweredNodeId { node_id: _, hir_id } = self.context.next_id();\n                     self.output_lifetimes.push(hir::GenericArg::Lifetime(hir::Lifetime {\n-                        id: node_id,\n                         hir_id,\n                         span: lifetime.span,\n                         name,\n@@ -1569,7 +1563,6 @@ impl<'a> LoweringContext<'a> {\n                     };\n \n                     self.output_lifetime_params.push(hir::GenericParam {\n-                        id: def_node_id,\n                         hir_id,\n                         name,\n                         span: lifetime.span,\n@@ -1980,8 +1973,8 @@ impl<'a> LoweringContext<'a> {\n                     .map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed()))\n                     .collect();\n                 let mk_tup = |this: &mut Self, tys, span| {\n-                    let LoweredNodeId { node_id, hir_id } = this.next_id();\n-                    hir::Ty { node: hir::TyKind::Tup(tys), id: node_id, hir_id, span }\n+                    let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n+                    hir::Ty { node: hir::TyKind::Tup(tys), hir_id, span }\n                 };\n                 let LoweredNodeId { node_id, hir_id } = this.next_id();\n \n@@ -2318,9 +2311,8 @@ impl<'a> LoweringContext<'a> {\n                     this.lower_ty(ty, ImplTraitContext::Existential(Some(fn_def_id)))\n                 }\n                 FunctionRetTy::Default(span) => {\n-                    let LoweredNodeId { node_id, hir_id } = this.next_id();\n+                    let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n                     P(hir::Ty {\n-                        id: node_id,\n                         hir_id,\n                         node: hir::TyKind::Tup(hir_vec![]),\n                         span: *span,\n@@ -2362,17 +2354,16 @@ impl<'a> LoweringContext<'a> {\n             ];\n \n             if let Some((name, span)) = bound_lifetime {\n-                let LoweredNodeId { node_id, hir_id } = this.next_id();\n+                let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n                 bounds.push(hir::GenericBound::Outlives(\n-                    hir::Lifetime { id: node_id, hir_id, name, span }));\n+                    hir::Lifetime { hir_id, name, span }));\n             }\n \n             hir::HirVec::from(bounds)\n         });\n \n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n         let impl_trait_ty = P(hir::Ty {\n-            id: node_id,\n             node: impl_trait_ty,\n             span,\n             hir_id,\n@@ -2431,10 +2422,9 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         name: hir::LifetimeName,\n     ) -> hir::Lifetime {\n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n \n         hir::Lifetime {\n-            id: node_id,\n             hir_id,\n             span,\n             name: name,\n@@ -2524,10 +2514,9 @@ impl<'a> LoweringContext<'a> {\n             }\n         };\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(param.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(param.id);\n \n         hir::GenericParam {\n-            id: node_id,\n             hir_id,\n             name,\n             span: param.ident.span,\n@@ -2608,10 +2597,9 @@ impl<'a> LoweringContext<'a> {\n         self.with_anonymous_lifetime_mode(\n             AnonymousLifetimeMode::ReportError,\n             |this| {\n-                let LoweredNodeId { node_id, hir_id } = this.lower_node_id(wc.id);\n+                let LoweredNodeId { node_id: _, hir_id } = this.lower_node_id(wc.id);\n \n                 hir::WhereClause {\n-                    id: node_id,\n                     hir_id,\n                     predicates: wc.predicates\n                         .iter()\n@@ -2672,10 +2660,9 @@ impl<'a> LoweringContext<'a> {\n                 ref rhs_ty,\n                 span,\n             }) => {\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(id);\n \n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                    id: node_id,\n                     hir_id,\n                     lhs_ty: self.lower_ty(lhs_ty, ImplTraitContext::disallowed()),\n                     rhs_ty: self.lower_ty(rhs_ty, ImplTraitContext::disallowed()),\n@@ -2816,10 +2803,9 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(b.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(b.id);\n \n         P(hir::Block {\n-            id: node_id,\n             hir_id,\n             stmts: stmts.into(),\n             expr,\n@@ -3544,7 +3530,6 @@ impl<'a> LoweringContext<'a> {\n                     name: ident.name,\n                     vis,\n                     attrs,\n-                    id: i.id,\n                     hir_id,\n                     span: i.span,\n                     body,\n@@ -3900,11 +3885,10 @@ impl<'a> LoweringContext<'a> {\n                             // Wrap the `if let` expr in a block.\n                             let span = els.span;\n                             let els = P(self.lower_expr(els));\n-                            let LoweredNodeId { node_id, hir_id } = self.next_id();\n+                            let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n                             let blk = P(hir::Block {\n                                 stmts: hir_vec![],\n                                 expr: Some(els),\n-                                id: node_id,\n                                 hir_id,\n                                 rules: hir::DefaultBlock,\n                                 span,\n@@ -3947,10 +3931,9 @@ impl<'a> LoweringContext<'a> {\n                     let mut block = this.lower_block(body, true).into_inner();\n                     let tail = block.expr.take().map_or_else(\n                         || {\n-                            let LoweredNodeId { node_id, hir_id } = this.next_id();\n+                            let LoweredNodeId { node_id: _, hir_id } = this.next_id();\n                             let span = this.sess.source_map().end_point(unstable_span);\n                             hir::Expr {\n-                                id: node_id,\n                                 span,\n                                 node: hir::ExprKind::Tup(hir_vec![]),\n                                 attrs: ThinVec::new(),\n@@ -4135,10 +4118,9 @@ impl<'a> LoweringContext<'a> {\n                 let struct_path = self.std_path(e.span, &struct_path, None, is_unit);\n                 let struct_path = hir::QPath::Resolved(None, P(struct_path));\n \n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(e.id);\n \n                 return hir::Expr {\n-                    id: node_id,\n                     hir_id,\n                     node: if is_unit {\n                         hir::ExprKind::Path(struct_path)\n@@ -4488,9 +4470,8 @@ impl<'a> LoweringContext<'a> {\n                     self.lower_label(opt_label),\n                     hir::LoopSource::ForLoop,\n                 );\n-                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+                let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(e.id);\n                 let loop_expr = P(hir::Expr {\n-                    id: node_id,\n                     hir_id,\n                     node: loop_expr,\n                     span: e.span,\n@@ -4635,10 +4616,9 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         };\n \n-        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+        let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(e.id);\n \n         hir::Expr {\n-            id: node_id,\n             hir_id,\n             node: kind,\n             span: e.span,\n@@ -4910,9 +4890,8 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr(&mut self, span: Span, node: hir::ExprKind, attrs: ThinVec<Attribute>) -> hir::Expr {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n         hir::Expr {\n-            id: node_id,\n             hir_id,\n             node,\n             span,\n@@ -4978,12 +4957,11 @@ impl<'a> LoweringContext<'a> {\n         stmts: hir::HirVec<hir::Stmt>,\n         expr: Option<P<hir::Expr>>,\n     ) -> hir::Block {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n         hir::Block {\n             stmts,\n             expr,\n-            id: node_id,\n             hir_id,\n             rules: hir::DefaultBlock,\n             span,\n@@ -5108,7 +5086,6 @@ impl<'a> LoweringContext<'a> {\n             _ => hir::TyKind::Path(qpath),\n         };\n         hir::Ty {\n-            id: id.node_id,\n             hir_id: id.hir_id,\n             node,\n             span,\n@@ -5124,9 +5101,8 @@ impl<'a> LoweringContext<'a> {\n             // `'f`.\n             AnonymousLifetimeMode::CreateParameter => {\n                 let fresh_name = self.collect_fresh_in_band_lifetime(span);\n-                let LoweredNodeId { node_id, hir_id } = self.next_id();\n+                let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n                 hir::Lifetime {\n-                    id: node_id,\n                     hir_id,\n                     span,\n                     name: hir::LifetimeName::Param(fresh_name),\n@@ -5227,10 +5203,9 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn new_implicit_lifetime(&mut self, span: Span) -> hir::Lifetime {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+        let LoweredNodeId { node_id: _, hir_id } = self.next_id();\n \n         hir::Lifetime {\n-            id: node_id,\n             hir_id,\n             span,\n             name: hir::LifetimeName::Implicit,"}, {"sha": "1114ef52bbc0c8aba1e10c5a599809fde89ed8d9", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -75,10 +75,10 @@ pub enum Code<'a> {\n }\n \n impl<'a> Code<'a> {\n-    pub fn id(&self) -> NodeId {\n+    pub fn id(&self) -> ast::HirId {\n         match *self {\n             Code::FnLike(node) => node.id(),\n-            Code::Expr(block) => block.id,\n+            Code::Expr(block) => block.hir_id,\n         }\n     }\n \n@@ -104,7 +104,7 @@ struct ItemFnParts<'a> {\n     vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n     body:     ast::BodyId,\n-    id:       NodeId,\n+    id:       ast::HirId,\n     span:     Span,\n     attrs:    &'a [Attribute],\n }\n@@ -114,13 +114,13 @@ struct ItemFnParts<'a> {\n struct ClosureParts<'a> {\n     decl: &'a FnDecl,\n     body: ast::BodyId,\n-    id: NodeId,\n+    id: ast::HirId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl, b: ast::BodyId, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n+    fn new(d: &'a FnDecl, b: ast::BodyId, id: ast::HirId, s: Span, attrs: &'a [Attribute]) -> Self {\n         ClosureParts {\n             decl: d,\n             body: b,\n@@ -168,7 +168,7 @@ impl<'a> FnLikeNode<'a> {\n                     |c: ClosureParts<'_>| c.span)\n     }\n \n-    pub fn id(self) -> NodeId {\n+    pub fn id(self) -> ast::HirId {\n         self.handle(|i: ItemFnParts<'_>| i.id,\n                     |id, _, _: &'a ast::MethodSig, _, _, _, _| id,\n                     |c: ClosureParts<'_>| c.id)\n@@ -213,7 +213,7 @@ impl<'a> FnLikeNode<'a> {\n \n     fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A where\n         I: FnOnce(ItemFnParts<'a>) -> A,\n-        M: FnOnce(NodeId,\n+        M: FnOnce(ast::HirId,\n                   Ident,\n                   &'a ast::MethodSig,\n                   Option<&'a ast::Visibility>,\n@@ -227,7 +227,7 @@ impl<'a> FnLikeNode<'a> {\n             map::Node::Item(i) => match i.node {\n                 ast::ItemKind::Fn(ref decl, header, ref generics, block) =>\n                     item_fn(ItemFnParts {\n-                        id: i.id,\n+                        id: i.hir_id,\n                         ident: i.ident,\n                         decl: &decl,\n                         body: block,\n@@ -241,21 +241,21 @@ impl<'a> FnLikeNode<'a> {\n             },\n             map::Node::TraitItem(ti) => match ti.node {\n                 ast::TraitItemKind::Method(ref sig, ast::TraitMethod::Provided(body)) => {\n-                    method(ti.id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n+                    method(ti.hir_id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             map::Node::ImplItem(ii) => {\n                 match ii.node {\n                     ast::ImplItemKind::Method(ref sig, body) => {\n-                        method(ii.id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n+                        method(ii.hir_id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                     }\n                     _ => bug!(\"impl method FnLikeNode that is not fn-like\")\n                 }\n             },\n             map::Node::Expr(e) => match e.node {\n                 ast::ExprKind::Closure(_, ref decl, block, _fn_decl_span, _gen) =>\n-                    closure(ClosureParts::new(&decl, block, e.id, e.span, &e.attrs)),\n+                    closure(ClosureParts::new(&decl, block, e.hir_id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => bug!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "588b986aad29d6a3f1d5b31efbc97b2462e72e26", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -507,7 +507,8 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'hir MacroDef) {\n-        let def_index = self.definitions.opt_def_index(macro_def.id).unwrap();\n+        let node_id = self.hir_to_node_id[&macro_def.hir_id];\n+        let def_index = self.definitions.opt_def_index(node_id).unwrap();\n \n         self.with_dep_node_owner(def_index, macro_def, |this| {\n             this.insert(macro_def.span, macro_def.hir_id, Node::MacroDef(macro_def));"}, {"sha": "41e48e46ea5b6116d76cc4f62d397099e6cb6663", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -390,14 +390,19 @@ impl<'hir> Map<'hir> {\n                 Some(Def::Local(local.id))\n             }\n             Node::MacroDef(macro_def) => {\n-                Some(Def::Macro(self.local_def_id(macro_def.id),\n+                Some(Def::Macro(self.local_def_id_from_hir_id(macro_def.hir_id),\n                                 MacroKind::Bang))\n             }\n             Node::GenericParam(param) => {\n                 Some(match param.kind {\n-                    GenericParamKind::Lifetime { .. } => Def::Local(param.id),\n-                    GenericParamKind::Type { .. } => Def::TyParam(self.local_def_id(param.id)),\n-                    GenericParamKind::Const { .. } => Def::ConstParam(self.local_def_id(param.id)),\n+                    GenericParamKind::Lifetime { .. } => {\n+                        let node_id = self.hir_to_node_id(param.hir_id);\n+                        Def::Local(node_id)\n+                    },\n+                    GenericParamKind::Type { .. } => Def::TyParam(\n+                        self.local_def_id_from_hir_id(param.hir_id)),\n+                    GenericParamKind::Const { .. } => Def::ConstParam(\n+                        self.local_def_id_from_hir_id(param.hir_id)),\n                 })\n             }\n         }\n@@ -794,7 +799,7 @@ impl<'hir> Map<'hir> {\n     ///     false\n     /// }\n     /// ```\n-    pub fn get_return_block(&self, id: NodeId) -> Option<NodeId> {\n+    pub fn get_return_block(&self, id: HirId) -> Option<HirId> {\n         let match_fn = |node: &Node<'_>| {\n             match *node {\n                 Node::Item(_) |\n@@ -817,7 +822,10 @@ impl<'hir> Map<'hir> {\n             }\n         };\n \n-        self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n+        let node_id = self.hir_to_node_id(id);\n+        self.walk_parent_nodes(node_id, match_fn, match_non_returning_block)\n+            .ok()\n+            .map(|return_node_id| self.node_to_hir_id(return_node_id))\n     }\n \n     /// Retrieves the `NodeId` for `id`'s parent item, or `id` itself if no"}, {"sha": "38e6e61592b1a4fc321220eb9393f21a1012c7a2", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -19,7 +19,7 @@ use errors::FatalError;\n use syntax_pos::{Span, DUMMY_SP, symbol::InternedString};\n use syntax::source_map::Spanned;\n use rustc_target::spec::abi::Abi;\n-use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n+use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, Lit, StrStyle, FloatTy, IntTy, UintTy};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n use syntax::ext::hygiene::SyntaxContext;\n@@ -112,6 +112,12 @@ impl serialize::UseSpecializedDecodable for HirId {\n     }\n }\n \n+impl fmt::Display for HirId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n // hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module\n mod item_local_id_inner {\n     use rustc_data_structures::indexed_vec::Idx;\n@@ -145,7 +151,6 @@ pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId::MAX;\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Copy)]\n pub struct Lifetime {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub span: Span,\n \n@@ -266,7 +271,7 @@ impl fmt::Debug for Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f,\n                \"lifetime({}: {})\",\n-               self.id,\n+               self.hir_id,\n                print::to_string(print::NO_ANN, |s| s.print_lifetime(self)))\n     }\n }\n@@ -411,11 +416,11 @@ impl GenericArg {\n         }\n     }\n \n-    pub fn id(&self) -> NodeId {\n+    pub fn id(&self) -> HirId {\n         match self {\n-            GenericArg::Lifetime(l) => l.id,\n-            GenericArg::Type(t) => t.id,\n-            GenericArg::Const(c) => c.value.id,\n+            GenericArg::Lifetime(l) => l.hir_id,\n+            GenericArg::Type(t) => t.hir_id,\n+            GenericArg::Const(c) => c.value.hir_id,\n         }\n     }\n }\n@@ -547,7 +552,6 @@ pub enum GenericParamKind {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct GenericParam {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub name: ParamName,\n     pub attrs: HirVec<Attribute>,\n@@ -579,7 +583,6 @@ impl Generics {\n         Generics {\n             params: HirVec::new(),\n             where_clause: WhereClause {\n-                id: DUMMY_NODE_ID,\n                 hir_id: DUMMY_HIR_ID,\n                 predicates: HirVec::new(),\n             },\n@@ -624,7 +627,6 @@ pub enum SyntheticTyParamKind {\n /// A where-clause in a definition.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereClause {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub predicates: HirVec<WherePredicate>,\n }\n@@ -685,7 +687,6 @@ pub struct WhereRegionPredicate {\n /// An equality predicate (e.g., `T = int`); currently unsupported.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereEqPredicate {\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub span: Span,\n     pub lhs_ty: P<Ty>,\n@@ -808,7 +809,6 @@ pub struct MacroDef {\n     pub name: Name,\n     pub vis: Visibility,\n     pub attrs: HirVec<Attribute>,\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     pub span: Span,\n     pub body: TokenStream,\n@@ -822,7 +822,6 @@ pub struct Block {\n     /// An expression at the end of the block\n     /// without a semicolon, if any.\n     pub expr: Option<P<Expr>>,\n-    pub id: NodeId,\n     pub hir_id: HirId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n     pub rules: BlockCheckMode,\n@@ -1334,7 +1333,6 @@ pub struct AnonConst {\n /// An expression\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Expr {\n-    pub id: NodeId,\n     pub span: Span,\n     pub node: ExprKind,\n     pub attrs: ThinVec<Attribute>,\n@@ -1437,7 +1435,7 @@ impl Expr {\n \n impl fmt::Debug for Expr {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"expr({}: {})\", self.id,\n+        write!(f, \"expr({}: {})\", self.hir_id,\n                print::to_string(print::NO_ANN, |s| s.print_expr(self)))\n     }\n }\n@@ -1754,7 +1752,6 @@ pub struct TypeBinding {\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Ty {\n-    pub id: NodeId,\n     pub node: TyKind,\n     pub span: Span,\n     pub hir_id: HirId,"}, {"sha": "17d374884134a86f429dba2f548f10d2dbce9732", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -2248,7 +2248,6 @@ impl<'a> State<'a> {\n         let generics = hir::Generics {\n             params: hir::HirVec::new(),\n             where_clause: hir::WhereClause {\n-                id: ast::DUMMY_NODE_ID,\n                 hir_id: hir::DUMMY_HIR_ID,\n                 predicates: hir::HirVec::new(),\n             },"}, {"sha": "d1161dda1e2ff592c04f5a7469634e0cc38620a0", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -158,7 +158,6 @@ impl_stable_hash_for!(struct ast::Label {\n });\n \n impl_stable_hash_for!(struct hir::Lifetime {\n-    id,\n     hir_id,\n     span,\n     name\n@@ -207,7 +206,6 @@ impl_stable_hash_for!(enum hir::TraitBoundModifier {\n });\n \n impl_stable_hash_for!(struct hir::GenericParam {\n-    id,\n     hir_id,\n     name,\n     pure_wrt_drop,\n@@ -255,7 +253,6 @@ impl_stable_hash_for!(enum hir::SyntheticTyParamKind {\n });\n \n impl_stable_hash_for!(struct hir::WhereClause {\n-    id,\n     hir_id,\n     predicates\n });\n@@ -280,7 +277,6 @@ impl_stable_hash_for!(struct hir::WhereRegionPredicate {\n });\n \n impl_stable_hash_for!(struct hir::WhereEqPredicate {\n-    id,\n     hir_id,\n     span,\n     lhs_ty,\n@@ -318,7 +314,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty {\n-                id: _,\n                 hir_id: _,\n                 ref node,\n                 ref span,\n@@ -411,7 +406,6 @@ impl_stable_hash_for!(struct hir::MacroDef {\n     name,\n     vis,\n     attrs,\n-    id,\n     hir_id,\n     span,\n     legacy,\n@@ -421,7 +415,6 @@ impl_stable_hash_for!(struct hir::MacroDef {\n impl_stable_hash_for!(struct hir::Block {\n     stmts,\n     expr,\n-    id -> _,\n     hir_id -> _,\n     rules,\n     span,\n@@ -566,7 +559,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n-                id: _,\n                 hir_id: _,\n                 ref span,\n                 ref node,"}, {"sha": "86d7a19bc83090cc1aeb7db4a54294f14b37ec00", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n \n         let (span_1, span_2, main_label, span_label) = match (sup_is_ret_type, sub_is_ret_type) {\n             (None, None) => {\n-                let (main_label_1, span_label_1) = if ty_sup.id == ty_sub.id {\n+                let (main_label_1, span_label_1) = if ty_sup.hir_id == ty_sub.hir_id {\n                     (\n                         \"this type is declared with multiple lifetimes...\".to_owned(),\n                         \"...but data with one lifetime flows into the other here\".to_owned()"}, {"sha": "dd003e44bea09d8bba7acb41ca40af89e46ac595", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -723,7 +723,7 @@ fn lint_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, cnum: CrateNum)\n     };\n     let krate = tcx.hir().krate();\n \n-    builder.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |builder| {\n+    builder.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |builder| {\n         intravisit::walk_crate(builder, krate);\n     });\n \n@@ -737,13 +737,13 @@ struct LintLevelMapBuilder<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> LintLevelMapBuilder<'a, 'tcx> {\n     fn with_lint_attrs<F>(&mut self,\n-                          id: ast::NodeId,\n+                          id: hir::HirId,\n                           attrs: &[ast::Attribute],\n                           f: F)\n         where F: FnOnce(&mut Self)\n     {\n         let push = self.levels.push(attrs);\n-        self.levels.register_id(self.tcx.hir().definitions().node_to_hir_id(id));\n+        self.levels.register_id(id);\n         f(self);\n         self.levels.pop(push);\n     }\n@@ -755,25 +755,25 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n-        self.with_lint_attrs(it.id, &it.attrs, |builder| {\n+        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n             intravisit::walk_item(builder, it);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n-        self.with_lint_attrs(it.id, &it.attrs, |builder| {\n+        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n             intravisit::walk_foreign_item(builder, it);\n         })\n     }\n \n     fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n-        self.with_lint_attrs(e.id, &e.attrs, |builder| {\n+        self.with_lint_attrs(e.hir_id, &e.attrs, |builder| {\n             intravisit::walk_expr(builder, e);\n         })\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n-        self.with_lint_attrs(s.id, &s.attrs, |builder| {\n+        self.with_lint_attrs(s.hir_id, &s.attrs, |builder| {\n             intravisit::walk_struct_field(builder, s);\n         })\n     }\n@@ -782,25 +782,25 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        self.with_lint_attrs(v.node.data.id(), &v.node.attrs, |builder| {\n+        self.with_lint_attrs(v.node.data.hir_id(), &v.node.attrs, |builder| {\n             intravisit::walk_variant(builder, v, g, item_id);\n         })\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local) {\n-        self.with_lint_attrs(l.id, &l.attrs, |builder| {\n+        self.with_lint_attrs(l.hir_id, &l.attrs, |builder| {\n             intravisit::walk_local(builder, l);\n         })\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |builder| {\n+        self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |builder| {\n             intravisit::walk_trait_item(builder, trait_item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |builder| {\n+        self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |builder| {\n             intravisit::walk_impl_item(builder, impl_item);\n         });\n     }"}, {"sha": "201a779ee1827adef9f99b6939f81db110bc0d6d", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -99,10 +99,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_field_access(&mut self, lhs: &hir::Expr, node_id: ast::NodeId) {\n+    fn handle_field_access(&mut self, lhs: &hir::Expr, hir_id: hir::HirId) {\n         match self.tables.expr_ty_adjusted(lhs).sty {\n             ty::Adt(def, _) => {\n-                let index = self.tcx.field_index(node_id, self.tables);\n+                let index = self.tcx.field_index(hir_id, self.tables);\n                 self.insert_def_id(def.non_enum_variant().fields[index].did);\n             }\n             ty::Tuple(..) => {}\n@@ -120,7 +120,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             if let PatKind::Wild = pat.node.pat.node {\n                 continue;\n             }\n-            let index = self.tcx.field_index(pat.node.id, self.tables);\n+            let index = self.tcx.field_index(pat.node.hir_id, self.tables);\n             self.insert_def_id(variant.fields[index].did);\n         }\n     }\n@@ -190,7 +190,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn mark_as_used_if_union(&mut self, adt: &ty::AdtDef, fields: &hir::HirVec<hir::Field>) {\n         if adt.is_union() && adt.non_enum_variant().fields.len() > 1 && adt.did.is_local() {\n             for field in fields {\n-                let index = self.tcx.field_index(field.id, self.tables);\n+                let index = self.tcx.field_index(field.hir_id, self.tables);\n                 self.insert_def_id(adt.non_enum_variant().fields[index].did);\n             }\n         }\n@@ -232,7 +232,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.lookup_and_handle_method(expr.hir_id);\n             }\n             hir::ExprKind::Field(ref lhs, ..) => {\n-                self.handle_field_access(&lhs, expr.id);\n+                self.handle_field_access(&lhs, expr.hir_id);\n             }\n             hir::ExprKind::Struct(_, ref fields, _) => {\n                 if let ty::Adt(ref adt, _) = self.tables.expr_ty(expr).sty {"}, {"sha": "7fc01e302a7d2c22e131117fed35a817fa166994", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -33,7 +33,7 @@ pub trait Delegate<'tcx> {\n     // The value found at `cmt` is either copied or moved, depending\n     // on mode.\n     fn consume(&mut self,\n-               consume_id: ast::NodeId,\n+               consume_id: hir::HirId,\n                consume_span: Span,\n                cmt: &mc::cmt_<'tcx>,\n                mode: ConsumeMode);\n@@ -65,7 +65,7 @@ pub trait Delegate<'tcx> {\n     // The value found at `borrow` is being borrowed at the point\n     // `borrow_id` for the region `loan_region` with kind `bk`.\n     fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n+              borrow_id: hir::HirId,\n               borrow_span: Span,\n               cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n@@ -79,7 +79,7 @@ pub trait Delegate<'tcx> {\n \n     // The path at `cmt` is being assigned to.\n     fn mutate(&mut self,\n-              assignment_id: ast::NodeId,\n+              assignment_id: hir::HirId,\n               assignment_span: Span,\n               assignee_cmt: &mc::cmt_<'tcx>,\n               mode: MutateMode);\n@@ -329,7 +329,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn delegate_consume(&mut self,\n-                        consume_id: ast::NodeId,\n+                        consume_id: hir::HirId,\n                         consume_span: Span,\n                         cmt: &mc::cmt_<'tcx>) {\n         debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n@@ -349,7 +349,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"consume_expr(expr={:?})\", expr);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate_consume(expr.id, expr.span, &cmt);\n+        self.delegate_consume(expr.hir_id, expr.span, &cmt);\n         self.walk_expr(expr);\n     }\n \n@@ -359,7 +359,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                    expr: &hir::Expr,\n                    mode: MutateMode) {\n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.mutate(assignment_expr.id, span, &cmt, mode);\n+        self.delegate.mutate(assignment_expr.hir_id, span, &cmt, mode);\n         self.walk_expr(expr);\n     }\n \n@@ -372,7 +372,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                expr, r, bk);\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.borrow(expr.id, expr.span, &cmt, r, bk, cause);\n+        self.delegate.borrow(expr.hir_id, expr.span, &cmt, r, bk, cause);\n \n         self.walk_expr(expr)\n     }\n@@ -629,7 +629,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     /// Indicates that the value of `blk` will be consumed, meaning either copied or moved\n     /// depending on its type.\n     fn walk_block(&mut self, blk: &hir::Block) {\n-        debug!(\"walk_block(blk.id={})\", blk.id);\n+        debug!(\"walk_block(blk.hir_id={})\", blk.hir_id);\n \n         for stmt in &blk.stmts {\n             self.walk_stmt(stmt);\n@@ -662,7 +662,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // Consume those fields of the with expression that are needed.\n                 for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n                     let is_mentioned = fields.iter().any(|f| {\n-                        self.tcx().field_index(f.id, self.mc.tables) == f_index\n+                        self.tcx().field_index(f.hir_id, self.mc.tables) == f_index\n                     });\n                     if !is_mentioned {\n                         let cmt_field = self.mc.cat_field(\n@@ -672,7 +672,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                             with_field.ident,\n                             with_field.ty(self.tcx(), substs)\n                         );\n-                        self.delegate_consume(with_expr.id, with_expr.span, &cmt_field);\n+                        self.delegate_consume(with_expr.hir_id, with_expr.span, &cmt_field);\n                     }\n                 }\n             }\n@@ -711,7 +711,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 adjustment::Adjust::Unsize => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n-                    self.delegate_consume(expr.id, expr.span, &cmt);\n+                    self.delegate_consume(expr.hir_id, expr.span, &cmt);\n                 }\n \n                 adjustment::Adjust::Deref(None) => {}\n@@ -723,7 +723,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // this is an autoref of `x`.\n                 adjustment::Adjust::Deref(Some(ref deref)) => {\n                     let bk = ty::BorrowKind::from_mutbl(deref.mutbl);\n-                    self.delegate.borrow(expr.id, expr.span, &cmt, deref.region, bk, AutoRef);\n+                    self.delegate.borrow(expr.hir_id, expr.span, &cmt, deref.region, bk, AutoRef);\n                 }\n \n                 adjustment::Adjust::Borrow(ref autoref) => {\n@@ -741,14 +741,14 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     expr: &hir::Expr,\n                     cmt_base: &mc::cmt_<'tcx>,\n                     autoref: &adjustment::AutoBorrow<'tcx>) {\n-        debug!(\"walk_autoref(expr.id={} cmt_base={:?} autoref={:?})\",\n-               expr.id,\n+        debug!(\"walk_autoref(expr.hir_id={} cmt_base={:?} autoref={:?})\",\n+               expr.hir_id,\n                cmt_base,\n                autoref);\n \n         match *autoref {\n             adjustment::AutoBorrow::Ref(r, m) => {\n-                self.delegate.borrow(expr.id,\n+                self.delegate.borrow(expr.hir_id,\n                                      expr.span,\n                                      cmt_base,\n                                      r,\n@@ -757,8 +757,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {\n-                debug!(\"walk_autoref: expr.id={} cmt_base={:?}\",\n-                       expr.id,\n+                debug!(\"walk_autoref: expr.hir_id={} cmt_base={:?}\",\n+                       expr.hir_id,\n                        cmt_base);\n \n                 // Converting from a &T to *T (or &mut T to *mut T) is\n@@ -770,7 +770,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         data: region::ScopeData::Node\n                     }));\n \n-                self.delegate.borrow(expr.id,\n+                self.delegate.borrow(expr.hir_id,\n                                      expr.span,\n                                      cmt_base,\n                                      r,\n@@ -864,15 +864,15 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     // binding being produced.\n                     let def = Def::Local(canonical_id);\n                     if let Ok(ref binding_cmt) = mc.cat_def(pat.hir_id, pat.span, pat_ty, def) {\n-                        delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n+                        delegate.mutate(pat.hir_id, pat.span, binding_cmt, MutateMode::Init);\n                     }\n \n                     // It is also a borrow or copy/move of the value being matched.\n                     match bm {\n                         ty::BindByReference(m) => {\n                             if let ty::Ref(r, _, _) = pat_ty.sty {\n                                 let bk = ty::BorrowKind::from_mutbl(m);\n-                                delegate.borrow(pat.id, pat.span, &cmt_pat, r, bk, RefBinding);\n+                                delegate.borrow(pat.hir_id, pat.span, &cmt_pat, r, bk, RefBinding);\n                             }\n                         }\n                         ty::BindByValue(..) => {\n@@ -920,10 +920,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_captures(&mut self, closure_expr: &hir::Expr, fn_decl_span: Span) {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n-        self.tcx().with_freevars(closure_expr.id, |freevars| {\n+        let closure_node_id = self.tcx().hir().hir_to_node_id(closure_expr.hir_id);\n+        let closure_def_id = self.tcx().hir().local_def_id(closure_node_id);\n+        self.tcx().with_freevars(closure_node_id, |freevars| {\n             for freevar in freevars {\n                 let var_hir_id = self.tcx().hir().node_to_hir_id(freevar.var_id());\n-                let closure_def_id = self.tcx().hir().local_def_id(closure_expr.id);\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_hir_id },\n                     closure_expr_id: closure_def_id.to_local(),\n@@ -938,10 +939,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                                 self.param_env,\n                                                 &cmt_var,\n                                                 CaptureMove);\n-                        self.delegate.consume(closure_expr.id, freevar.span, &cmt_var, mode);\n+                        self.delegate.consume(closure_expr.hir_id, freevar.span, &cmt_var, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                        self.delegate.borrow(closure_expr.id,\n+                        self.delegate.borrow(closure_expr.hir_id,\n                                              fn_decl_span,\n                                              &cmt_var,\n                                              upvar_borrow.region,"}, {"sha": "76933a6e3484b02194d3341ba3b2bd0b6748c696", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -265,7 +265,7 @@ struct IrMaps<'a, 'tcx: 'a> {\n     num_vars: usize,\n     live_node_map: HirIdMap<LiveNode>,\n     variable_map: HirIdMap<Variable>,\n-    capture_info_map: NodeMap<Rc<Vec<CaptureInfo>>>,\n+    capture_info_map: HirIdMap<Rc<Vec<CaptureInfo>>>,\n     var_kinds: Vec<VarKind>,\n     lnks: Vec<LiveNodeKind>,\n }\n@@ -344,8 +344,8 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n         }\n     }\n \n-    fn set_captures(&mut self, node_id: NodeId, cs: Vec<CaptureInfo>) {\n-        self.capture_info_map.insert(node_id, Rc::new(cs));\n+    fn set_captures(&mut self, hir_id: HirId, cs: Vec<CaptureInfo>) {\n+        self.capture_info_map.insert(hir_id, Rc::new(cs));\n     }\n \n     fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n@@ -460,7 +460,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) => {\n-        debug!(\"expr {}: path that leads to {:?}\", expr.id, path.def);\n+        debug!(\"expr {}: path that leads to {:?}\", expr.hir_id, path.def);\n         if let Def::Local(..) = path.def {\n             ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         }\n@@ -476,7 +476,8 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n         // in better error messages than just pointing at the closure\n         // construction site.\n         let mut call_caps = Vec::new();\n-        ir.tcx.with_freevars(expr.id, |freevars| {\n+        let node_id = ir.tcx.hir().hir_to_node_id(expr.hir_id);\n+        ir.tcx.with_freevars(node_id, |freevars| {\n             call_caps.extend(freevars.iter().filter_map(|fv| {\n                 if let Def::Local(rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n@@ -487,7 +488,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n                 }\n             }));\n         });\n-        ir.set_captures(expr.id, call_caps);\n+        ir.set_captures(expr.hir_id, call_caps);\n \n         intravisit::walk_expr(ir, expr);\n       }\n@@ -925,7 +926,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn compute(&mut self, body: &hir::Expr) -> LiveNode {\n-        debug!(\"compute: using id for body, {}\", self.ir.tcx.hir().node_to_pretty_string(body.id));\n+        debug!(\"compute: using id for body, {}\",\n+               self.ir.tcx.hir().hir_to_pretty_string(body.hir_id));\n \n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n@@ -940,7 +942,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                    for ln_idx in 0..self.ir.num_live_nodes {\n                         debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx as u32)));\n                    }\n-                   body.id\n+                   body.hir_id\n                },\n                entry_ln);\n \n@@ -950,7 +952,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn propagate_through_block(&mut self, blk: &hir::Block, succ: LiveNode)\n                                -> LiveNode {\n         if blk.targeted_by_break {\n-            self.break_ln.insert(blk.id, succ);\n+            let node_id = self.ir.tcx.hir().hir_to_node_id(blk.hir_id);\n+            self.break_ln.insert(node_id, succ);\n         }\n         let succ = self.propagate_through_opt_expr(blk.expr.as_ref().map(|e| &**e), succ);\n         blk.stmts.iter().rev().fold(succ, |succ, stmt| {\n@@ -1002,7 +1005,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn propagate_through_expr(&mut self, expr: &Expr, succ: LiveNode)\n                               -> LiveNode {\n-        debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().node_to_pretty_string(expr.id));\n+        debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id));\n \n         match expr.node {\n             // Interesting cases with control flow or which gen/kill\n@@ -1016,11 +1019,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::Closure(..) => {\n                 debug!(\"{} is an ExprKind::Closure\",\n-                       self.ir.tcx.hir().node_to_pretty_string(expr.id));\n+                       self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id));\n \n                 // the construction of a closure itself is not important,\n                 // but we have to consider the closed over variables.\n-                let caps = self.ir.capture_info_map.get(&expr.id).cloned().unwrap_or_else(||\n+                let caps = self.ir.capture_info_map.get(&expr.hir_id).cloned().unwrap_or_else(||\n                     span_bug!(expr.span, \"no registered caps\"));\n \n                 caps.iter().rev().fold(succ, |succ, cap| {\n@@ -1169,7 +1172,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Call(ref f, ref args) => {\n-                let m = self.ir.tcx.hir().get_module_parent(expr.id);\n+                let m = self.ir.tcx.hir().get_module_parent_by_hir_id(expr.hir_id);\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n                     self.s.exit_ln\n                 } else {\n@@ -1180,7 +1183,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::MethodCall(.., ref args) => {\n-                let m = self.ir.tcx.hir().get_module_parent(expr.id);\n+                let m = self.ir.tcx.hir().get_module_parent_by_hir_id(expr.hir_id);\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n                     self.s.exit_ln\n                 } else {\n@@ -1386,17 +1389,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n         }\n         debug!(\"propagate_through_loop: using id for loop body {} {}\",\n-               expr.id, self.ir.tcx.hir().node_to_pretty_string(body.id));\n+               expr.hir_id, self.ir.tcx.hir().hir_to_pretty_string(body.hir_id));\n \n-\n-        self.break_ln.insert(expr.id, succ);\n+        let node_id = self.ir.tcx.hir().hir_to_node_id(expr.hir_id);\n+        self.break_ln.insert(node_id, succ);\n \n         let cond_ln = match kind {\n             LoopLoop => ln,\n             WhileLoop(ref cond) => self.propagate_through_expr(&cond, ln),\n         };\n \n-        self.cont_ln.insert(expr.id, cond_ln);\n+        self.cont_ln.insert(node_id, cond_ln);\n \n         let body_ln = self.propagate_through_block(body, cond_ln);\n "}, {"sha": "822a42b374f38fc5a13e9b7d65e34776eff2be3d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -632,7 +632,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn cat_expr_unadjusted(&self, expr: &hir::Expr) -> McResult<cmt_<'tcx>> {\n-        debug!(\"cat_expr: id={} expr={:?}\", expr.id, expr);\n+        debug!(\"cat_expr: id={} expr={:?}\", expr.hir_id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n         match expr.node {\n@@ -648,10 +648,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Field(ref base, f_ident) => {\n                 let base_cmt = Rc::new(self.cat_expr(&base)?);\n                 debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n-                       expr.id,\n+                       expr.hir_id,\n                        expr,\n                        base_cmt);\n-                let f_index = self.tcx.field_index(expr.id, self.tables);\n+                let f_index = self.tcx.field_index(expr.hir_id, self.tables);\n                 Ok(self.cat_field(expr, base_cmt, f_index, f_ident, expr_ty))\n             }\n \n@@ -1321,7 +1321,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n                 for fp in field_pats {\n                     let field_ty = self.pat_ty_adjusted(&fp.node.pat)?; // see (*2)\n-                    let f_index = self.tcx.field_index(fp.node.id, self.tables);\n+                    let f_index = self.tcx.field_index(fp.node.hir_id, self.tables);\n                     let cmt_field = Rc::new(self.cat_field(pat, cmt.clone(), f_index,\n                                                            fp.node.ident, field_ty));\n                     self.cat_pattern_(cmt_field, &fp.node.pat, op)?;"}, {"sha": "3499138fb7915da07eaecdb938a8aac90433fd3f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -745,7 +745,7 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor<'_, '_>,\n }\n \n fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk: &'tcx hir::Block) {\n-    debug!(\"resolve_block(blk.id={:?})\", blk.id);\n+    debug!(\"resolve_block(blk.hir_id={:?})\", blk.hir_id);\n \n     let prev_cx = visitor.cx;\n "}, {"sha": "31e9eb9b7463ca861c25b2aa0f2ae77ed57798c1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -13,7 +13,7 @@ use crate::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n \n use crate::rustc::lint;\n use crate::session::Session;\n-use crate::util::nodemap::{DefIdMap, FxHashMap, FxHashSet, NodeMap, NodeSet};\n+use crate::util::nodemap::{DefIdMap, FxHashMap, FxHashSet, HirIdMap, HirIdSet, NodeMap};\n use errors::{Applicability, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n use std::borrow::Cow;\n@@ -83,15 +83,15 @@ impl Region {\n     fn early(hir_map: &Map<'_>, index: &mut u32, param: &GenericParam) -> (ParamName, Region) {\n         let i = *index;\n         *index += 1;\n-        let def_id = hir_map.local_def_id(param.id);\n+        let def_id = hir_map.local_def_id_from_hir_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n         (param.name.modern(), Region::EarlyBound(i, def_id, origin))\n     }\n \n     fn late(hir_map: &Map<'_>, param: &GenericParam) -> (ParamName, Region) {\n         let depth = ty::INNERMOST;\n-        let def_id = hir_map.local_def_id(param.id);\n+        let def_id = hir_map.local_def_id_from_hir_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\n             \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n@@ -151,7 +151,7 @@ impl Region {\n         if let Region::EarlyBound(index, _, _) = self {\n             params\n                 .nth(index as usize)\n-                .and_then(|lifetime| map.defs.get(&lifetime.id).cloned())\n+                .and_then(|lifetime| map.defs.get(&lifetime.hir_id).cloned())\n         } else {\n             Some(self)\n         }\n@@ -195,12 +195,12 @@ pub type ObjectLifetimeDefault = Set1<Region>;\n struct NamedRegionMap {\n     // maps from every use of a named (not anonymous) lifetime to a\n     // `Region` describing how that region is bound\n-    pub defs: NodeMap<Region>,\n+    pub defs: HirIdMap<Region>,\n \n     // the set of lifetime def ids that are late-bound; a region can\n     // be late-bound if (a) it does NOT appear in a where-clause and\n     // (b) it DOES appear in the arguments.\n-    pub late_bound: NodeSet,\n+    pub late_bound: HirIdSet,\n \n     // For each type and trait definition, maps type parameters\n     // to the trait object lifetime defaults computed from them.\n@@ -385,13 +385,11 @@ fn resolve_lifetimes<'tcx>(\n \n     let mut rl = ResolveLifetimes::default();\n \n-    for (k, v) in named_region_map.defs {\n-        let hir_id = tcx.hir().node_to_hir_id(k);\n+    for (hir_id, v) in named_region_map.defs {\n         let map = rl.defs.entry(hir_id.owner_local_def_id()).or_default();\n         Lrc::get_mut(map).unwrap().insert(hir_id.local_id, v);\n     }\n-    for k in named_region_map.late_bound {\n-        let hir_id = tcx.hir().node_to_hir_id(k);\n+    for hir_id in named_region_map.late_bound {\n         let map = rl.late_bound\n             .entry(hir_id.owner_local_def_id())\n             .or_default();\n@@ -570,7 +568,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        debug!(\"visit_ty: id={:?} ty={:?}\", ty.id, ty);\n+        debug!(\"visit_ty: id={:?} ty={:?}\", ty.hir_id, ty);\n         match ty.node {\n             hir::TyKind::BareFn(ref c) => {\n                 let next_early_index = self.next_early_index();\n@@ -629,7 +627,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             hir::TyKind::Rptr(ref lifetime_ref, ref mt) => {\n                 self.visit_lifetime(lifetime_ref);\n                 let scope = Scope::ObjectLifetimeDefault {\n-                    lifetime: self.map.defs.get(&lifetime_ref.id).cloned(),\n+                    lifetime: self.map.defs.get(&lifetime_ref.hir_id).cloned(),\n                     s: self.scope,\n                 };\n                 self.with(scope, |_, this| this.visit_ty(&mt.ty));\n@@ -672,7 +670,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // and ban them. Type variables instantiated inside binders aren't\n                         // well-supported at the moment, so this doesn't work.\n                         // In the future, this should be fixed and this error should be removed.\n-                        let def = self.map.defs.get(&lifetime.id).cloned();\n+                        let def = self.map.defs.get(&lifetime.hir_id).cloned();\n                         if let Some(Region::LateBound(_, def_id, _)) = def {\n                             if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n                                 // Ensure that the parent of the def is an item, not HRTB\n@@ -1339,7 +1337,7 @@ fn object_lifetime_defaults_for_item(\n \n                 add_bounds(&mut set, &param.bounds);\n \n-                let param_def_id = tcx.hir().local_def_id(param.id);\n+                let param_def_id = tcx.hir().local_def_id_from_hir_id(param.hir_id);\n                 for predicate in &generics.where_clause.predicates {\n                     // Look for `type: ...` where clauses.\n                     let data = match *predicate {\n@@ -1374,7 +1372,7 @@ fn object_lifetime_defaults_for_item(\n                                 .iter()\n                                 .filter_map(|param| match param.kind {\n                                     GenericParamKind::Lifetime { .. } => Some((\n-                                        param.id,\n+                                        param.hir_id,\n                                         hir::LifetimeName::Param(param.name),\n                                         LifetimeDefOrigin::from_param(param),\n                                     )),\n@@ -1383,7 +1381,7 @@ fn object_lifetime_defaults_for_item(\n                                 .enumerate()\n                                 .find(|&(_, (_, lt_name, _))| lt_name == name)\n                                 .map_or(Set1::Many, |(i, (id, _, origin))| {\n-                                    let def_id = tcx.hir().local_def_id(id);\n+                                    let def_id = tcx.hir().local_def_id_from_hir_id(id);\n                                     Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n                                 })\n                         }\n@@ -1501,8 +1499,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n         };\n-        if let Node::Lifetime(hir_lifetime) = self.tcx.hir().get(lifetime.id) {\n-            if let Some(parent) = self.tcx.hir().find(self.tcx.hir().get_parent(hir_lifetime.id)) {\n+        if let Node::Lifetime(hir_lifetime) = self.tcx.hir().get_by_hir_id(lifetime.hir_id) {\n+            if let Some(parent) = self.tcx.hir().find_by_hir_id(\n+                self.tcx.hir().get_parent_item(hir_lifetime.hir_id))\n+            {\n                 match parent {\n                     Node::Item(item) => {\n                         if let hir::ItemKind::Fn(decl, _, _, _) = &item.node {\n@@ -1582,22 +1582,22 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     debug!(\"node id first={:?}\", node_id);\n                     if let Some((id, span, name)) = match self.tcx.hir().get(node_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n-                            hir_lifetime.id,\n+                            hir_lifetime.hir_id,\n                             hir_lifetime.span,\n                             hir_lifetime.name.ident(),\n                         )),\n                         Node::GenericParam(param) => {\n-                            Some((param.id, param.span, param.name.ident()))\n+                            Some((param.hir_id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n                     } {\n-                        debug!(\"id = {:?} span = {:?} name = {:?}\", node_id, span, name);\n+                        debug!(\"id = {:?} span = {:?} name = {:?}\", id, span, name);\n \n                         if name == keywords::UnderscoreLifetime.ident() {\n                             continue;\n                         }\n \n-                        let mut err = self.tcx.struct_span_lint_node(\n+                        let mut err = self.tcx.struct_span_lint_hir(\n                             lint::builtin::SINGLE_USE_LIFETIMES,\n                             id,\n                             span,\n@@ -1622,17 +1622,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     let node_id = self.tcx.hir().as_local_node_id(def_id).unwrap();\n                     if let Some((id, span, name)) = match self.tcx.hir().get(node_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n-                            hir_lifetime.id,\n+                            hir_lifetime.hir_id,\n                             hir_lifetime.span,\n                             hir_lifetime.name.ident(),\n                         )),\n                         Node::GenericParam(param) => {\n-                            Some((param.id, param.span, param.name.ident()))\n+                            Some((param.hir_id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n                     } {\n-                        debug!(\"id ={:?} span = {:?} name = {:?}\", node_id, span, name);\n-                        let mut err = self.tcx.struct_span_lint_node(\n+                        debug!(\"id ={:?} span = {:?} name = {:?}\", id, span, name);\n+                        let mut err = self.tcx.struct_span_lint_hir(\n                             lint::builtin::UNUSED_LIFETIMES,\n                             id,\n                             span,\n@@ -1706,7 +1706,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut non_lifetime_count = 0;\n         let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n             GenericParamKind::Lifetime { .. } => {\n-                if self.map.late_bound.contains(&param.id) {\n+                if self.map.late_bound.contains(&param.hir_id) {\n                     Some(Region::late(&self.tcx.hir(), param))\n                 } else {\n                     Some(Region::early(&self.tcx.hir(), &mut index, param))\n@@ -2049,8 +2049,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // and whether there's a `self` argument (treated specially).\n         let mut assoc_item_kind = None;\n         let mut impl_self = None;\n-        let parent = self.tcx.hir().get_parent_node(output.id);\n-        let body = match self.tcx.hir().get(parent) {\n+        let parent = self.tcx.hir().get_parent_node_by_hir_id(output.hir_id);\n+        let body = match self.tcx.hir().get_by_hir_id(parent) {\n             // `fn` definitions and methods.\n             Node::Item(&hir::Item {\n                 node: hir::ItemKind::Fn(.., body),\n@@ -2063,12 +2063,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }) => {\n                 if let hir::ItemKind::Trait(.., ref trait_items) = self.tcx\n                     .hir()\n-                    .expect_item(self.tcx.hir().get_parent(parent))\n+                    .expect_item_by_hir_id(self.tcx.hir().get_parent_item(parent))\n                     .node\n                 {\n+                    let parent_node_id = self.tcx.hir().hir_to_node_id(parent);\n                     assoc_item_kind = trait_items\n                         .iter()\n-                        .find(|ti| ti.id.node_id == parent)\n+                        .find(|ti| ti.id.node_id == parent_node_id)\n                         .map(|ti| ti.kind);\n                 }\n                 match *m {\n@@ -2083,13 +2084,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }) => {\n                 if let hir::ItemKind::Impl(.., ref self_ty, ref impl_items) = self.tcx\n                     .hir()\n-                    .expect_item(self.tcx.hir().get_parent(parent))\n+                    .expect_item_by_hir_id(self.tcx.hir().get_parent_item(parent))\n                     .node\n                 {\n                     impl_self = Some(self_ty);\n+                    let parent_node_id = self.tcx.hir().hir_to_node_id(parent);\n                     assoc_item_kind = impl_items\n                         .iter()\n-                        .find(|ii| ii.id.node_id == parent)\n+                        .find(|ii| ii.id.node_id == parent_node_id)\n                         .map(|ii| ii.kind);\n                 }\n                 Some(body)\n@@ -2143,7 +2145,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             if let hir::TyKind::Rptr(lifetime_ref, ref mt) = inputs[0].node {\n                 if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = mt.ty.node {\n                     if is_self_ty(path.def) {\n-                        if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n+                        if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n                             let scope = Scope::Elision {\n                                 elide: Elide::Exact(lifetime),\n                                 s: self.scope,\n@@ -2262,7 +2264,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n-                if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.id) {\n+                if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n                     match lifetime {\n                         Region::LateBound(debruijn, _, _) | Region::LateBoundAnon(debruijn, _)\n                             if debruijn < self.outer_index =>\n@@ -2653,7 +2655,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: Region) {\n-        if lifetime_ref.id == ast::DUMMY_NODE_ID {\n+        if lifetime_ref.hir_id == hir::DUMMY_HIR_ID {\n             span_bug!(\n                 lifetime_ref.span,\n                 \"lifetime reference not renumbered, \\\n@@ -2663,11 +2665,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         debug!(\n             \"insert_lifetime: {} resolved to {:?} span={:?}\",\n-            self.tcx.hir().node_to_string(lifetime_ref.id),\n+            self.tcx.hir().hir_to_string(lifetime_ref.hir_id),\n             def,\n             self.tcx.sess.source_map().span_to_string(lifetime_ref.span)\n         );\n-        self.map.defs.insert(lifetime_ref.id, def);\n+        self.map.defs.insert(lifetime_ref.hir_id, def);\n \n         match def {\n             Region::LateBoundAnon(..) | Region::Static => {\n@@ -2699,7 +2701,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// error (esp. around impl trait). In that case, we remove the\n     /// entry into `map.defs` so as not to confuse later code.\n     fn uninsert_lifetime_on_error(&mut self, lifetime_ref: &'tcx hir::Lifetime, bad_def: Region) {\n-        let old_value = self.map.defs.remove(&lifetime_ref.id);\n+        let old_value = self.map.defs.remove(&lifetime_ref.hir_id);\n         assert_eq!(old_value, Some(bad_def));\n     }\n }\n@@ -2789,11 +2791,11 @@ fn insert_late_bound_lifetimes(\n         debug!(\n             \"insert_late_bound_lifetimes: lifetime {:?} with id {:?} is late-bound\",\n             param.name.ident(),\n-            param.id\n+            param.hir_id\n         );\n \n-        let inserted = map.late_bound.insert(param.id);\n-        assert!(inserted, \"visited lifetime {:?} twice\", param.id);\n+        let inserted = map.late_bound.insert(param.hir_id);\n+        assert!(inserted, \"visited lifetime {:?} twice\", param.hir_id);\n     }\n \n     return;"}, {"sha": "55572c637f80ad729d6b243314415c57e12745b9", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 34, "deletions": 40, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -14,7 +14,7 @@ use crate::session::{DiagnosticMessageId, Session};\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, MultiSpan};\n use syntax::ast;\n-use syntax::ast::{NodeId, Attribute};\n+use syntax::ast::Attribute;\n use syntax::errors::Applicability;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::attr::{self, Stability, Deprecation};\n@@ -117,13 +117,13 @@ struct Annotator<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n-    fn annotate<F>(&mut self, id: NodeId, attrs: &[Attribute],\n+    fn annotate<F>(&mut self, hir_id: HirId, attrs: &[Attribute],\n                    item_sp: Span, kind: AnnotationKind, visit_children: F)\n         where F: FnOnce(&mut Self)\n     {\n         if self.tcx.features().staged_api {\n             // This crate explicitly wants staged API.\n-            debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n+            debug!(\"annotate(id = {:?}, attrs = {:?})\", hir_id, attrs);\n             if let Some(..) = attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp) {\n                 self.tcx.sess.span_err(item_sp, \"`#[deprecated]` cannot be used in staged api, \\\n                                                  use `#[rustc_deprecated]` instead\");\n@@ -178,7 +178,6 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                     }\n                 }\n \n-                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 self.index.stab_map.insert(hir_id, stab);\n \n                 let orig_parent_stab = replace(&mut self.parent_stab, Some(stab));\n@@ -188,7 +187,6 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n                 if let Some(stab) = self.parent_stab {\n                     if stab.level.is_unstable() {\n-                        let hir_id = self.tcx.hir().node_to_hir_id(id);\n                         self.index.stab_map.insert(hir_id, stab);\n                     }\n                 }\n@@ -209,7 +207,6 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n             // -Zforce-unstable-if-unmarked is set.\n             if let Some(stab) = self.parent_stab {\n                 if stab.level.is_unstable() {\n-                    let hir_id = self.tcx.hir().node_to_hir_id(id);\n                     self.index.stab_map.insert(hir_id, stab);\n                 }\n             }\n@@ -220,7 +217,6 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 }\n \n                 // `Deprecation` is just two pointers, no need to intern it\n-                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 let depr_entry = DeprecationEntry::local(depr, hir_id);\n                 self.index.depr_map.insert(hir_id, depr_entry.clone());\n \n@@ -229,7 +225,6 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 visit_children(self);\n                 self.parent_depr = orig_parent_depr;\n             } else if let Some(parent_depr) = self.parent_depr.clone() {\n-                let hir_id = self.tcx.hir().node_to_hir_id(id);\n                 self.index.depr_map.insert(hir_id, parent_depr);\n                 visit_children(self);\n             } else {\n@@ -264,20 +259,20 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             }\n             hir::ItemKind::Struct(ref sd, _) => {\n                 if !sd.is_struct() {\n-                    self.annotate(sd.id(), &i.attrs, i.span, AnnotationKind::Required, |_| {})\n+                    self.annotate(sd.hir_id(), &i.attrs, i.span, AnnotationKind::Required, |_| {})\n                 }\n             }\n             _ => {}\n         }\n \n-        self.annotate(i.id, &i.attrs, i.span, kind, |v| {\n+        self.annotate(i.hir_id, &i.attrs, i.span, kind, |v| {\n             intravisit::walk_item(v, i)\n         });\n         self.in_trait_impl = orig_in_trait_impl;\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        self.annotate(ti.id, &ti.attrs, ti.span, AnnotationKind::Required, |v| {\n+        self.annotate(ti.hir_id, &ti.attrs, ti.span, AnnotationKind::Required, |v| {\n             intravisit::walk_trait_item(v, ti);\n         });\n     }\n@@ -288,31 +283,30 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         } else {\n             AnnotationKind::Required\n         };\n-        self.annotate(ii.id, &ii.attrs, ii.span, kind, |v| {\n+        self.annotate(ii.hir_id, &ii.attrs, ii.span, kind, |v| {\n             intravisit::walk_impl_item(v, ii);\n         });\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n-        self.annotate(var.node.data.id(), &var.node.attrs, var.span, AnnotationKind::Required, |v| {\n-            intravisit::walk_variant(v, var, g, item_id);\n-        })\n+        self.annotate(var.node.data.hir_id(), &var.node.attrs, var.span, AnnotationKind::Required,\n+            |v| { intravisit::walk_variant(v, var, g, item_id) })\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx StructField) {\n-        self.annotate(s.id, &s.attrs, s.span, AnnotationKind::Required, |v| {\n+        self.annotate(s.hir_id, &s.attrs, s.span, AnnotationKind::Required, |v| {\n             intravisit::walk_struct_field(v, s);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n-        self.annotate(i.id, &i.attrs, i.span, AnnotationKind::Required, |v| {\n+        self.annotate(i.hir_id, &i.attrs, i.span, AnnotationKind::Required, |v| {\n             intravisit::walk_foreign_item(v, i);\n         });\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        self.annotate(md.id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n+        self.annotate(md.hir_id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n     }\n }\n \n@@ -322,12 +316,12 @@ struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n-    fn check_missing_stability(&self, id: NodeId, span: Span, name: &str) {\n-        let hir_id = self.tcx.hir().node_to_hir_id(id);\n+    fn check_missing_stability(&self, hir_id: HirId, span: Span, name: &str) {\n         let stab = self.tcx.stability().local_stability(hir_id);\n+        let node_id = self.tcx.hir().hir_to_node_id(hir_id);\n         let is_error = !self.tcx.sess.opts.test &&\n                         stab.is_none() &&\n-                        self.access_levels.is_reachable(id);\n+                        self.access_levels.is_reachable(node_id);\n         if is_error {\n             self.tcx.sess.span_err(\n                 span,\n@@ -350,42 +344,42 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n             // optional. They inherit stability from their parents when unannotated.\n             hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {}\n \n-            _ => self.check_missing_stability(i.id, i.span, i.node.descriptive_variant())\n+            _ => self.check_missing_stability(i.hir_id, i.span, i.node.descriptive_variant())\n         }\n \n         intravisit::walk_item(self, i)\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        self.check_missing_stability(ti.id, ti.span, \"item\");\n+        self.check_missing_stability(ti.hir_id, ti.span, \"item\");\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         let impl_def_id = self.tcx.hir().local_def_id(self.tcx.hir().get_parent(ii.id));\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n-            self.check_missing_stability(ii.id, ii.span, \"item\");\n+            self.check_missing_stability(ii.hir_id, ii.span, \"item\");\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n-        self.check_missing_stability(var.node.data.id(), var.span, \"variant\");\n+        self.check_missing_stability(var.node.data.hir_id(), var.span, \"variant\");\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx StructField) {\n-        self.check_missing_stability(s.id, s.span, \"field\");\n+        self.check_missing_stability(s.hir_id, s.span, \"field\");\n         intravisit::walk_struct_field(self, s);\n     }\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n-        self.check_missing_stability(i.id, i.span, i.node.descriptive_variant());\n+        self.check_missing_stability(i.hir_id, i.span, i.node.descriptive_variant());\n         intravisit::walk_foreign_item(self, i);\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        self.check_missing_stability(md.id, md.span, \"macro\");\n+        self.check_missing_stability(md.hir_id, md.span, \"macro\");\n     }\n }\n \n@@ -441,7 +435,7 @@ impl<'a, 'tcx> Index<'tcx> {\n                 annotator.parent_stab = Some(stability);\n             }\n \n-            annotator.annotate(ast::CRATE_NODE_ID,\n+            annotator.annotate(hir::CRATE_HIR_ID,\n                                &krate.attrs,\n                                krate.span,\n                                AnnotationKind::Required,\n@@ -563,9 +557,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// If `id` is `Some(_)`, this function will also check if the item at `def_id` has been\n     /// deprecated. If the item is indeed deprecated, we will emit a deprecation lint attached to\n     /// `id`.\n-    pub fn eval_stability(self, def_id: DefId, id: Option<NodeId>, span: Span) -> EvalResult {\n+    pub fn eval_stability(self, def_id: DefId, id: Option<HirId>, span: Span) -> EvalResult {\n         let lint_deprecated = |def_id: DefId,\n-                               id: NodeId,\n+                               id: HirId,\n                                note: Option<Symbol>,\n                                suggestion: Option<Symbol>,\n                                message: &str,\n@@ -576,9 +570,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"{}\", message)\n             };\n \n-            let mut diag = self.struct_span_lint_node(lint, id, span, &msg);\n+            let mut diag = self.struct_span_lint_hir(lint, id, span, &msg);\n             if let Some(suggestion) = suggestion {\n-                if let hir::Node::Expr(_) = self.hir().get(id) {\n+                if let hir::Node::Expr(_) = self.hir().get_by_hir_id(id) {\n                     diag.span_suggestion(\n                         span,\n                         &msg,\n@@ -588,15 +582,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             diag.emit();\n-            if id == ast::DUMMY_NODE_ID {\n-                span_bug!(span, \"emitted a {} lint with dummy node id: {:?}\", lint.name, def_id);\n+            if id == hir::DUMMY_HIR_ID {\n+                span_bug!(span, \"emitted a {} lint with dummy HIR id: {:?}\", lint.name, def_id);\n             }\n         };\n \n         // Deprecated attributes apply in-crate and cross-crate.\n         if let Some(id) = id {\n             if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n-                let parent_def_id = self.hir().local_def_id(self.hir().get_parent(id));\n+                let parent_def_id = self.hir().local_def_id_from_hir_id(\n+                    self.hir().get_parent_item(id));\n                 let skip = self.lookup_deprecation_entry(parent_def_id)\n                                .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n \n@@ -709,7 +704,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// Additionally, this function will also check if the item is deprecated. If so, and `id` is\n     /// not `None`, a deprecated lint attached to `id` will be emitted.\n-    pub fn check_stability(self, def_id: DefId, id: Option<NodeId>, span: Span) {\n+    pub fn check_stability(self, def_id: DefId, id: Option<HirId>, span: Span) {\n         match self.eval_stability(def_id, id, span) {\n             EvalResult::Allow => {}\n             EvalResult::Deny { feature, reason, issue } => {\n@@ -769,7 +764,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     None => return,\n                 };\n                 let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-                self.tcx.check_stability(def_id, Some(item.id), item.span);\n+                self.tcx.check_stability(def_id, Some(item.hir_id), item.span);\n             }\n \n             // For implementations of traits, check the stability of each item\n@@ -817,7 +812,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &'tcx hir::Path, id: hir::HirId) {\n-        let id = self.tcx.hir().hir_to_node_id(id);\n         if let Some(def_id) = path.def.opt_def_id() {\n             self.tcx.check_stability(def_id, Some(id), path.span)\n         }\n@@ -843,7 +837,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n             tcx,\n             access_levels,\n         };\n-        missing.check_missing_stability(ast::CRATE_NODE_ID, krate.span, \"crate\");\n+        missing.check_missing_stability(hir::CRATE_HIR_ID, krate.span, \"crate\");\n         intravisit::walk_crate(&mut missing, krate);\n         krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n     }"}, {"sha": "c4e1860bd8333e7985cf16266227f17d3e220c6f", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -1,5 +1,6 @@\n use std::{fmt, env};\n \n+use crate::hir;\n use crate::hir::map::definitions::DefPathData;\n use crate::mir;\n use crate::ty::{self, Ty, layout};\n@@ -14,7 +15,6 @@ use crate::ty::query::TyCtxtAt;\n use errors::DiagnosticBuilder;\n \n use syntax_pos::{Pos, Span};\n-use syntax::ast;\n use syntax::symbol::Symbol;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n@@ -50,7 +50,7 @@ pub struct ConstEvalErr<'tcx> {\n pub struct FrameInfo<'tcx> {\n     pub call_site: Span, // this span is in the caller!\n     pub instance: ty::Instance<'tcx>,\n-    pub lint_root: Option<ast::NodeId>,\n+    pub lint_root: Option<hir::HirId>,\n }\n \n impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n@@ -98,7 +98,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n     pub fn report_as_lint(&self,\n         tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n         message: &str,\n-        lint_root: ast::NodeId,\n+        lint_root: hir::HirId,\n     ) -> ErrorHandled {\n         let lint = self.struct_generic(\n             tcx,\n@@ -118,7 +118,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         &self,\n         tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n         message: &str,\n-        lint_root: Option<ast::NodeId>,\n+        lint_root: Option<hir::HirId>,\n     ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n         match self.error {\n             EvalErrorKind::Layout(LayoutError::Unknown(_)) |\n@@ -129,15 +129,15 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         }\n         trace!(\"reporting const eval failure at {:?}\", self.span);\n         let mut err = if let Some(lint_root) = lint_root {\n-            let node_id = self.stacktrace\n+            let hir_id = self.stacktrace\n                 .iter()\n                 .rev()\n                 .filter_map(|frame| frame.lint_root)\n                 .next()\n                 .unwrap_or(lint_root);\n-            tcx.struct_span_lint_node(\n+            tcx.struct_span_lint_hir(\n                 crate::rustc::lint::builtin::CONST_ERR,\n-                node_id,\n+                hir_id,\n                 tcx.span,\n                 message,\n             )"}, {"sha": "001a347c3313aaef36ce613282bb93ec416eeac5", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -413,7 +413,7 @@ pub enum Safety {\n     /// Unsafe because of an unsafe fn\n     FnUnsafe,\n     /// Unsafe because of an `unsafe` block\n-    ExplicitUnsafe(ast::NodeId),\n+    ExplicitUnsafe(hir::HirId),\n }\n \n impl_stable_hash_for!(struct Mir<'tcx> {\n@@ -2103,8 +2103,8 @@ pub struct SourceScopeData {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct SourceScopeLocalData {\n-    /// A NodeId with lint levels equivalent to this scope's lint levels.\n-    pub lint_root: ast::NodeId,\n+    /// A HirId with lint levels equivalent to this scope's lint levels.\n+    pub lint_root: hir::HirId,\n     /// The unsafe block that contains this node.\n     pub safety: Safety,\n }\n@@ -2854,8 +2854,8 @@ pub enum UnsafetyViolationKind {\n     General,\n     /// Permitted in const fn and regular fns.\n     GeneralAndConstFn,\n-    ExternStatic(ast::NodeId),\n-    BorrowPacked(ast::NodeId),\n+    ExternStatic(hir::HirId),\n+    BorrowPacked(hir::HirId),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n@@ -2872,7 +2872,7 @@ pub struct UnsafetyCheckResult {\n     pub violations: Lrc<[UnsafetyViolation]>,\n     /// unsafe blocks in this function, along with whether they are used. This is\n     /// used for the \"unused_unsafe\" lint.\n-    pub unsafe_blocks: Lrc<[(ast::NodeId, bool)]>,\n+    pub unsafe_blocks: Lrc<[(hir::HirId, bool)]>,\n }\n \n /// The layout of generator state"}, {"sha": "be6a95948edb9d5201e8cfac86225b0f3c947f01", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -257,10 +257,10 @@ pub enum ObligationCauseCode<'tcx> {\n     ReturnNoExpression,\n \n     /// `return` with an expression\n-    ReturnType(ast::NodeId),\n+    ReturnType(hir::HirId),\n \n     /// Block implicit return\n-    BlockTailExpression(ast::NodeId),\n+    BlockTailExpression(hir::HirId),\n \n     /// #[feature(trivial_bounds)] is not enabled\n     TrivialBound,"}, {"sha": "5c24b0ebfe05e7c20e7cc64f65972cbe074ed919", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -10,6 +10,7 @@\n \n use super::elaborate_predicates;\n \n+use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::lint;\n use crate::traits::{self, Obligation, ObligationCause};\n@@ -129,7 +130,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n                     // It's also hard to get a use site span, so we use the method definition span.\n                     self.lint_node_note(\n                         lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY,\n-                        ast::CRATE_NODE_ID,\n+                        hir::CRATE_HIR_ID,\n                         *span,\n                         &format!(\"the trait `{}` cannot be made into an object\",\n                                  self.item_path_str(trait_def_id)),"}, {"sha": "a71c0d4ab963dd6ec830f6f1f032cd43c0e0e594", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -2859,11 +2859,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn lint_node_note<S: Into<MultiSpan>>(self,\n                                               lint: &'static Lint,\n-                                              id: NodeId,\n+                                              id: hir::HirId,\n                                               span: S,\n                                               msg: &str,\n                                               note: &str) {\n-        let mut err = self.struct_span_lint_node(lint, id, span.into(), msg);\n+        let mut err = self.struct_span_lint_hir(lint, id, span.into(), msg);\n         err.note(note);\n         err.emit()\n     }"}, {"sha": "a3cf7bf488ee71ad0398cc66095f8b5f7428179e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -2775,8 +2775,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn field_index(self, node_id: NodeId, tables: &TypeckTables<'_>) -> usize {\n-        let hir_id = self.hir().node_to_hir_id(node_id);\n+    pub fn field_index(self, hir_id: hir::HirId, tables: &TypeckTables<'_>) -> usize {\n         tables.field_indices().get(hir_id).cloned().expect(\"no index for a field\")\n     }\n "}, {"sha": "c74d7f00cf5169626e5f634b1ed84878aa97988b", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -89,15 +89,14 @@ struct CheckLoanCtxt<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n-               consume_id: ast::NodeId,\n+               consume_id: hir::HirId,\n                consume_span: Span,\n                cmt: &mc::cmt_<'tcx>,\n                mode: euv::ConsumeMode) {\n         debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n                consume_id, cmt, mode);\n \n-        let hir_id = self.tcx().hir().node_to_hir_id(consume_id);\n-        self.consume_common(hir_id.local_id, consume_span, cmt, mode);\n+        self.consume_common(consume_id.local_id, consume_span, cmt, mode);\n     }\n \n     fn matched_pat(&mut self,\n@@ -118,7 +117,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n+              borrow_id: hir::HirId,\n               borrow_span: Span,\n               cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n@@ -130,22 +129,21 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n-        let hir_id = self.tcx().hir().node_to_hir_id(borrow_id);\n         if let Some(lp) = opt_loan_path(cmt) {\n             let moved_value_use_kind = match loan_cause {\n                 euv::ClosureCapture(_) => MovedInCapture,\n                 _ => MovedInUse,\n             };\n-            self.check_if_path_is_moved(hir_id.local_id, borrow_span, moved_value_use_kind, &lp);\n+            self.check_if_path_is_moved(borrow_id.local_id, borrow_span, moved_value_use_kind, &lp);\n         }\n \n-        self.check_for_conflicting_loans(hir_id.local_id);\n+        self.check_for_conflicting_loans(borrow_id.local_id);\n \n         self.check_for_loans_across_yields(cmt, loan_region, borrow_span);\n     }\n \n     fn mutate(&mut self,\n-              assignment_id: ast::NodeId,\n+              assignment_id: hir::HirId,\n               assignment_span: Span,\n               assignee_cmt: &mc::cmt_<'tcx>,\n               mode: euv::MutateMode)\n@@ -176,8 +174,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                 }\n             }\n         }\n-        self.check_assignment(self.tcx().hir().node_to_hir_id(assignment_id).local_id,\n-                              assignment_span, assignee_cmt);\n+        self.check_assignment(assignment_id.local_id, assignment_span, assignee_cmt);\n     }\n \n     fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) { }\n@@ -188,7 +185,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                      move_data: &move_data::FlowedMoveData<'c, 'tcx>,\n                                      all_loans: &[Loan<'tcx>],\n                                      body: &hir::Body) {\n-    debug!(\"check_loans(body id={})\", body.value.id);\n+    debug!(\"check_loans(body id={})\", body.value.hir_id);\n \n     let def_id = bccx.tcx.hir().body_owner_def_id(body.id());\n "}, {"sha": "03af27997d3cbee7bdf7b4accd3f561ee603d89f", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -68,7 +68,7 @@ struct GatherLoanCtxt<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     fn consume(&mut self,\n-               consume_id: ast::NodeId,\n+               consume_id: hir::HirId,\n                _consume_span: Span,\n                cmt: &mc::cmt_<'tcx>,\n                mode: euv::ConsumeMode) {\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n             euv::Move(move_reason) => {\n                 gather_moves::gather_move_from_expr(\n                     self.bccx, &self.move_data, &mut self.move_error_collector,\n-                    self.bccx.tcx.hir().node_to_hir_id(consume_id).local_id, cmt, move_reason);\n+                    consume_id.local_id, cmt, move_reason);\n             }\n             euv::Copy => { }\n         }\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n+              borrow_id: hir::HirId,\n               borrow_span: Span,\n               cmt: &mc::cmt_<'tcx>,\n               loan_region: ty::Region<'tcx>,\n@@ -126,8 +126,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                bk={:?}, loan_cause={:?})\",\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n-        let hir_id = self.bccx.tcx.hir().node_to_hir_id(borrow_id);\n-        self.guarantee_valid(hir_id.local_id,\n+\n+        self.guarantee_valid(borrow_id.local_id,\n                              borrow_span,\n                              cmt,\n                              bk,\n@@ -136,12 +136,13 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     fn mutate(&mut self,\n-              assignment_id: ast::NodeId,\n+              assignment_id: hir::HirId,\n               assignment_span: Span,\n               assignee_cmt: &mc::cmt_<'tcx>,\n               _: euv::MutateMode)\n     {\n-        self.guarantee_assignment_valid(assignment_id,\n+        let node_id = self.bccx.tcx.hir().hir_to_node_id(assignment_id);\n+        self.guarantee_assignment_valid(node_id,\n                                         assignment_span,\n                                         assignee_cmt);\n     }"}, {"sha": "0698c15346ebc4e9792cacf3270a3e048c9e3c19", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -420,13 +420,13 @@ impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n             }\n             pprust_hir::AnnNode::Block(blk) => {\n                 s.s.space()?;\n-                s.synth_comment(format!(\"block node_id: {} hir local_id: {}\",\n-                                        blk.id, blk.hir_id.local_id.as_u32()))\n+                s.synth_comment(format!(\"block hir_id: {} hir local_id: {}\",\n+                                        blk.hir_id, blk.hir_id.local_id.as_u32()))\n             }\n             pprust_hir::AnnNode::Expr(expr) => {\n                 s.s.space()?;\n-                s.synth_comment(format!(\"node_id: {} hir local_id: {}\",\n-                                        expr.id, expr.hir_id.local_id.as_u32()))?;\n+                s.synth_comment(format!(\"expr hir_id: {} hir local_id: {}\",\n+                                        expr.hir_id, expr.hir_id.local_id.as_u32()))?;\n                 s.pclose()\n             }\n             pprust_hir::AnnNode::Pat(pat) => {\n@@ -834,15 +834,15 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n     let body_id = match code {\n         blocks::Code::Expr(expr) => {\n             // Find the function this expression is from.\n-            let mut node_id = expr.id;\n+            let mut hir_id = expr.hir_id;\n             loop {\n-                let node = tcx.hir().get(node_id);\n+                let node = tcx.hir().get_by_hir_id(hir_id);\n                 if let Some(n) = hir::map::blocks::FnLikeNode::from_node(node) {\n                     break n.body();\n                 }\n-                let parent = tcx.hir().get_parent_node(node_id);\n-                assert_ne!(node_id, parent);\n-                node_id = parent;\n+                let parent = tcx.hir().get_parent_node_by_hir_id(hir_id);\n+                assert_ne!(hir_id, parent);\n+                hir_id = parent;\n             }\n         }\n         blocks::Code::FnLike(fn_like) => fn_like.body(),"}, {"sha": "ac10b6403bd132e6a7d30c08350cb3b2fc8cb454", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -200,7 +200,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                 }\n                 if let PatKind::Binding(_, _, _, ident, None) = fieldpat.node.pat.node {\n                     if cx.tcx.find_field_index(ident, &variant) ==\n-                       Some(cx.tcx.field_index(fieldpat.node.id, cx.tables)) {\n+                       Some(cx.tcx.field_index(fieldpat.node.hir_id, cx.tables)) {\n                         let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n                                      fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant\", ident));"}, {"sha": "b6fd6412349336f15f8ef3d92693219fba100a79", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -46,12 +46,12 @@ declare_lint! {\n #[derive(Copy, Clone)]\n pub struct TypeLimits {\n     /// Id of the last visited negated expression\n-    negated_expr_id: ast::NodeId,\n+    negated_expr_id: hir::HirId,\n }\n \n impl TypeLimits {\n     pub fn new() -> TypeLimits {\n-        TypeLimits { negated_expr_id: ast::DUMMY_NODE_ID }\n+        TypeLimits { negated_expr_id: hir::DUMMY_HIR_ID }\n     }\n }\n \n@@ -71,8 +71,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         match e.node {\n             hir::ExprKind::Unary(hir::UnNeg, ref expr) => {\n                 // propagate negation, if the negation itself isn't negated\n-                if self.negated_expr_id != e.id {\n-                    self.negated_expr_id = expr.id;\n+                if self.negated_expr_id != e.hir_id {\n+                    self.negated_expr_id = expr.hir_id;\n                 }\n             }\n             hir::ExprKind::Binary(binop, ref l, ref r) => {\n@@ -95,7 +95,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                 };\n                                 let (_, max) = int_ty_range(int_type);\n                                 let max = max as u128;\n-                                let negative = self.negated_expr_id == e.id;\n+                                let negative = self.negated_expr_id == e.hir_id;\n \n                                 // Detect literal value out of range [min, max] inclusive\n                                 // avoiding use of -min to prevent overflow/panic\n@@ -136,8 +136,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             _ => bug!(),\n                         };\n                         if lit_val < min || lit_val > max {\n-                            let parent_id = cx.tcx.hir().get_parent_node(e.id);\n-                            if let Node::Expr(parent_expr) = cx.tcx.hir().get(parent_id) {\n+                            let parent_id = cx.tcx.hir().get_parent_node_by_hir_id(e.hir_id);\n+                            if let Node::Expr(parent_expr) = cx.tcx.hir().get_by_hir_id(parent_id) {\n                                 if let hir::ExprKind::Cast(..) = parent_expr.node {\n                                     if let ty::Char = cx.tables.expr_ty(parent_expr).sty {\n                                         let mut err = cx.struct_span_lint("}, {"sha": "86b8b276eafe5930d35cb7c427705892690c0c6d", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -58,7 +58,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         let t = cx.tables.expr_ty(&expr);\n         let type_permits_lack_of_use = if t.is_unit()\n-            || cx.tcx.is_ty_uninhabited_from(cx.tcx.hir().get_module_parent(expr.id), t) {\n+            || cx.tcx.is_ty_uninhabited_from(\n+                cx.tcx.hir().get_module_parent_by_hir_id(expr.hir_id), t)\n+        {\n             true\n         } else {\n             match t.sty {"}, {"sha": "5fdc5899a721ec3862365706ee6639c5fb3d7119", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -1279,7 +1279,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef) -> Entry<'tcx> {\n         use syntax::print::pprust;\n-        let def_id = self.tcx.hir().local_def_id(macro_def.id);\n+        let def_id = self.tcx.hir().local_def_id_from_hir_id(macro_def.hir_id);\n         Entry {\n             kind: EntryKind::MacroDef(self.lazy(&MacroDef {\n                 body: pprust::tts_to_string(&macro_def.body.trees().collect::<Vec<_>>()),\n@@ -1680,7 +1680,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         self.index.encode_info_for_ty(ty);\n     }\n     fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n-        let def_id = self.index.tcx.hir().local_def_id(macro_def.id);\n+        let def_id = self.index.tcx.hir().local_def_id_from_hir_id(macro_def.hir_id);\n         self.index.record(def_id, IsolatedEncoder::encode_info_for_macro_def, macro_def);\n     }\n }\n@@ -1702,13 +1702,13 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n             match param.kind {\n                 hir::GenericParamKind::Lifetime { .. } => {}\n                 hir::GenericParamKind::Type { ref default, .. } => {\n-                    let def_id = self.tcx.hir().local_def_id(param.id);\n+                    let def_id = self.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n                     let has_default = Untracked(default.is_some());\n                     let encode_info = IsolatedEncoder::encode_info_for_ty_param;\n                     self.record(def_id, encode_info, (def_id, has_default));\n                 }\n                 hir::GenericParamKind::Const { .. } => {\n-                    let def_id = self.tcx.hir().local_def_id(param.id);\n+                    let def_id = self.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n                     let encode_info = IsolatedEncoder::encode_info_for_const_param;\n                     self.record(def_id, encode_info, def_id);\n                 }\n@@ -1729,7 +1729,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprKind::Closure(..) => {\n-                let def_id = self.tcx.hir().local_def_id(expr.id);\n+                let def_id = self.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n                 self.record(def_id, IsolatedEncoder::encode_info_for_closure, def_id);\n             }\n             _ => {}"}, {"sha": "3e2571fc0b39c0ffd2dc88d2c57fdcf523c40c37", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -185,7 +185,7 @@ macro_rules! read_hir {\n     ($t:ty) => {\n         impl<'tcx> DepGraphRead for &'tcx $t {\n             fn read(&self, tcx: TyCtxt<'_, '_, '_>) {\n-                tcx.hir().read(self.id);\n+                tcx.hir().read_by_hir_id(self.hir_id);\n             }\n         }\n     }"}, {"sha": "1091646bdd5c672ebb3c9e0517ef79a0578e6d81", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -301,7 +301,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n             }\n \n             let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n-            tcx.struct_span_lint_node(\n+            tcx.struct_span_lint_hir(\n                 UNUSED_MUT,\n                 vsi[local_decl.source_info.scope].lint_root,\n                 span,"}, {"sha": "cba5039122a76a080b444f70ec151d0757383f98", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -204,14 +204,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"update_source_scope_for({:?}, {:?})\", span, safety_mode);\n         let new_unsafety = match safety_mode {\n             BlockSafety::Safe => None,\n-            BlockSafety::ExplicitUnsafe(node_id) => {\n+            BlockSafety::ExplicitUnsafe(hir_id) => {\n                 assert_eq!(self.push_unsafe_count, 0);\n                 match self.unpushed_unsafe {\n                     Safety::Safe => {}\n                     _ => return\n                 }\n-                self.unpushed_unsafe = Safety::ExplicitUnsafe(node_id);\n-                Some(Safety::ExplicitUnsafe(node_id))\n+                self.unpushed_unsafe = Safety::ExplicitUnsafe(hir_id);\n+                Some(Safety::ExplicitUnsafe(hir_id))\n             }\n             BlockSafety::PushUnsafe => {\n                 self.push_unsafe_count += 1;"}, {"sha": "a9a16024302e9354f2aae658e1ee3f56e6c72711", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -72,13 +72,13 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n     };\n \n     tcx.infer_ctxt().enter(|infcx| {\n-        let cx = Cx::new(&infcx, id);\n+        let fn_hir_id = tcx.hir().node_to_hir_id(id);\n+        let cx = Cx::new(&infcx, fn_hir_id);\n         let mut mir = if cx.tables().tainted_by_errors {\n             build::construct_error(cx, body_id)\n         } else if cx.body_owner_kind.is_fn_or_closure() {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n-            let fn_hir_id = tcx.hir().node_to_hir_id(id);\n             let fn_sig = cx.tables().liberated_fn_sigs()[fn_hir_id].clone();\n             let fn_def_id = tcx.hir().local_def_id(id);\n "}, {"sha": "71acf747d085606e971d635034f9bf0f7efab2d1", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -308,17 +308,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"in_scope(region_scope={:?}, block={:?})\", region_scope, block);\n         let source_scope = self.source_scope;\n         let tcx = self.hir.tcx();\n-        if let LintLevel::Explicit(node_id) = lint_level {\n+        if let LintLevel::Explicit(current_hir_id) = lint_level {\n             let same_lint_scopes = tcx.dep_graph.with_ignore(|| {\n                 let sets = tcx.lint_levels(LOCAL_CRATE);\n-                let parent_hir_id =\n-                    tcx.hir().definitions().node_to_hir_id(\n-                        self.source_scope_local_data[source_scope].lint_root\n-                    );\n-                let current_hir_id =\n-                    tcx.hir().definitions().node_to_hir_id(node_id);\n-                sets.lint_level_set(parent_hir_id) ==\n-                    sets.lint_level_set(current_hir_id)\n+                let parent_hir_id = self.source_scope_local_data[source_scope].lint_root;\n+                sets.lint_level_set(parent_hir_id) == sets.lint_level_set(current_hir_id)\n             });\n \n             if !same_lint_scopes {"}, {"sha": "35ca13891876c5ce52424d34309584df41c21955", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -665,11 +665,11 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n                 // because any code that existed before validation could not have failed validation\n                 // thus preventing such a hard error from being a backwards compatibility hazard\n                 Some(Def::Const(_)) | Some(Def::AssociatedConst(_)) => {\n-                    let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n+                    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                     err.report_as_lint(\n                         tcx.at(tcx.def_span(def_id)),\n                         \"any use of this value will cause an error\",\n-                        node_id,\n+                        hir_id,\n                     )\n                 },\n                 // promoting runtime code is only allowed to error if it references broken constants\n@@ -685,7 +685,7 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n                         err.report_as_lint(\n                             tcx.at(span),\n                             \"reaching this expression at runtime will panic or abort\",\n-                            tcx.hir().as_local_node_id(def_id).unwrap(),\n+                            tcx.hir().as_local_hir_id(def_id).unwrap(),\n                         )\n                     }\n                 // anything else (array lengths, enum initializers, constant patterns) are reported"}, {"sha": "f58e61915e8c99d120db8bc72a714f97e62da050", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -30,7 +30,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n                 hir::BlockCheckMode::DefaultBlock =>\n                     BlockSafety::Safe,\n                 hir::BlockCheckMode::UnsafeBlock(..) =>\n-                    BlockSafety::ExplicitUnsafe(self.id),\n+                    BlockSafety::ExplicitUnsafe(self.hir_id),\n                 hir::BlockCheckMode::PushUnsafeBlock(..) =>\n                     BlockSafety::PushUnsafe,\n                 hir::BlockCheckMode::PopUnsafeBlock(..) =>\n@@ -103,7 +103,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         },\n                         pattern,\n                         initializer: local.init.to_ref(),\n-                        lint_level: cx.lint_level_of(local.id),\n+                        lint_level: cx.lint_level_of(local.hir_id),\n                     },\n                     opt_destruction_scope: opt_dxn_ext,\n                     span: stmt_span,"}, {"sha": "699ef7138cd936f2d6a450eec6dbf6d0834a529b", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -24,7 +24,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             data: region::ScopeData::Node\n         };\n \n-        debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n+        debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.hir_id, self.span);\n \n         let mut expr = make_mirror_unadjusted(cx, self);\n \n@@ -44,7 +44,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             kind: ExprKind::Scope {\n                 region_scope: expr_scope,\n                 value: expr.to_ref(),\n-                lint_level: cx.lint_level_of(self.id),\n+                lint_level: cx.lint_level_of(self.hir_id),\n             },\n         };\n \n@@ -529,7 +529,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n             };\n-            let upvars = cx.tcx.with_freevars(expr.id, |freevars| {\n+            let expr_node_id = cx.tcx.hir().hir_to_node_id(expr.hir_id);\n+            let upvars = cx.tcx.with_freevars(expr_node_id, |freevars| {\n                 freevars.iter()\n                     .zip(substs.upvar_tys(def_id, cx.tcx))\n                     .map(|(fv, ty)| capture_freevar(cx, expr, fv, ty))\n@@ -637,7 +638,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprKind::Field(ref source, ..) => {\n             ExprKind::Field {\n                 lhs: source.to_ref(),\n-                name: Field::new(cx.tcx.field_index(expr.id, cx.tables)),\n+                name: Field::new(cx.tcx.field_index(expr.hir_id, cx.tables)),\n             }\n         }\n         hir::ExprKind::Cast(ref source, ref cast_ty) => {\n@@ -1184,7 +1185,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     let var_hir_id = cx.tcx.hir().node_to_hir_id(freevar.var_id());\n     let upvar_id = ty::UpvarId {\n         var_path: ty::UpvarPath { hir_id: var_hir_id },\n-        closure_expr_id: cx.tcx.hir().local_def_id(closure_expr.id).to_local(),\n+        closure_expr_id: cx.tcx.hir().local_def_id_from_hir_id(closure_expr.hir_id).to_local(),\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);\n@@ -1223,7 +1224,7 @@ fn field_refs<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     fields.iter()\n         .map(|field| {\n             FieldExprRef {\n-                name: Field::new(cx.tcx.field_index(field.id, cx.tables)),\n+                name: Field::new(cx.tcx.field_index(field.hir_id, cx.tables)),\n                 expr: field.expr.to_ref(),\n             }\n         })"}, {"sha": "9e19badf49db0591040ae5732149c3fb576525dc", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -26,7 +26,7 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n \n-    pub root_lint_level: ast::NodeId,\n+    pub root_lint_level: hir::HirId,\n     pub param_env: ty::ParamEnv<'gcx>,\n \n     /// Identity `Substs` for use with const-evaluation.\n@@ -51,10 +51,10 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-               src_id: ast::NodeId) -> Cx<'a, 'gcx, 'tcx> {\n+               src_id: hir::HirId) -> Cx<'a, 'gcx, 'tcx> {\n         let tcx = infcx.tcx;\n-        let src_def_id = tcx.hir().local_def_id(src_id);\n-        let body_owner_kind = tcx.hir().body_owner_kind(src_id);\n+        let src_def_id = tcx.hir().local_def_id_from_hir_id(src_id);\n+        let body_owner_kind = tcx.hir().body_owner_kind_by_hir_id(src_id);\n \n         let constness = match body_owner_kind {\n             hir::BodyOwnerKind::Const |\n@@ -63,7 +63,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             hir::BodyOwnerKind::Fn => hir::Constness::NotConst,\n         };\n \n-        let attrs = tcx.hir().attrs(src_id);\n+        let attrs = tcx.hir().attrs_by_hir_id(src_id);\n \n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n@@ -197,14 +197,13 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         ty.needs_drop(self.tcx.global_tcx(), param_env)\n     }\n \n-    fn lint_level_of(&self, node_id: ast::NodeId) -> LintLevel {\n-        let hir_id = self.tcx.hir().definitions().node_to_hir_id(node_id);\n+    fn lint_level_of(&self, hir_id: hir::HirId) -> LintLevel {\n         let has_lint_level = self.tcx.dep_graph.with_ignore(|| {\n             self.tcx.lint_levels(LOCAL_CRATE).lint_level_set(hir_id).is_some()\n         });\n \n         if has_lint_level {\n-            LintLevel::Explicit(node_id)\n+            LintLevel::Explicit(hir_id)\n         } else {\n             LintLevel::Inherited\n         }\n@@ -237,7 +236,7 @@ impl UserAnnotatedTyHelpers<'gcx, 'tcx> for Cx<'_, 'gcx, 'tcx> {\n     }\n }\n \n-fn lint_level_for_hir_id(tcx: TyCtxt<'_, '_, '_>, mut id: ast::NodeId) -> ast::NodeId {\n+fn lint_level_for_hir_id(tcx: TyCtxt<'_, '_, '_>, mut id: hir::HirId) -> hir::HirId {\n     // Right now we insert a `with_ignore` node in the dep graph here to\n     // ignore the fact that `lint_levels` below depends on the entire crate.\n     // For now this'll prevent false positives of recompiling too much when\n@@ -249,11 +248,10 @@ fn lint_level_for_hir_id(tcx: TyCtxt<'_, '_, '_>, mut id: ast::NodeId) -> ast::N\n     tcx.dep_graph.with_ignore(|| {\n         let sets = tcx.lint_levels(LOCAL_CRATE);\n         loop {\n-            let hir_id = tcx.hir().definitions().node_to_hir_id(id);\n-            if sets.lint_level_set(hir_id).is_some() {\n+            if sets.lint_level_set(id).is_some() {\n                 return id\n             }\n-            let next = tcx.hir().get_parent_node(id);\n+            let next = tcx.hir().get_parent_node_by_hir_id(id);\n             if next == id {\n                 bug!(\"lint traversal reached the root of the crate\");\n             }"}, {"sha": "fffa2ed3ec5538cc8928066f842f35fa80e7e058", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -28,7 +28,7 @@ mod util;\n #[derive(Copy, Clone, Debug)]\n pub enum LintLevel {\n     Inherited,\n-    Explicit(ast::NodeId)\n+    Explicit(hir::HirId)\n }\n \n impl LintLevel {\n@@ -54,7 +54,7 @@ pub struct Block<'tcx> {\n #[derive(Copy, Clone, Debug)]\n pub enum BlockSafety {\n     Safe,\n-    ExplicitUnsafe(ast::NodeId),\n+    ExplicitUnsafe(hir::HirId),\n     PushUnsafe,\n     PopUnsafe\n }"}, {"sha": "fff810b0e6f2cce312a087baafb2dfd1f5ba5c3a", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             }\n         }\n \n-        let module = self.tcx.hir().get_module_parent(scrut.id);\n+        let module = self.tcx.hir().get_module_parent_by_hir_id(scrut.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut have_errors = false;\n \n@@ -203,7 +203,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Then, if the match has no arms, check whether the scrutinee\n             // is uninhabited.\n             let pat_ty = self.tables.node_type(scrut.hir_id);\n-            let module = self.tcx.hir().get_module_parent(scrut.id);\n+            let module = self.tcx.hir().get_module_parent_by_hir_id(scrut.hir_id);\n             if inlined_arms.is_empty() {\n                 let scrutinee_is_uninhabited = if self.tcx.features().exhaustive_patterns {\n                     self.tcx.is_ty_uninhabited_from(module, pat_ty)\n@@ -561,10 +561,10 @@ struct MutationChecker<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n     fn matched_pat(&mut self, _: &Pat, _: &cmt_<'_>, _: euv::MatchMode) {}\n-    fn consume(&mut self, _: ast::NodeId, _: Span, _: &cmt_<'_>, _: ConsumeMode) {}\n+    fn consume(&mut self, _: hir::HirId, _: Span, _: &cmt_<'_>, _: ConsumeMode) {}\n     fn consume_pat(&mut self, _: &Pat, _: &cmt_<'_>, _: ConsumeMode) {}\n     fn borrow(&mut self,\n-              _: ast::NodeId,\n+              _: hir::HirId,\n               span: Span,\n               _: &cmt_<'_>,\n               _: ty::Region<'tcx>,\n@@ -587,7 +587,7 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n         }\n     }\n     fn decl_without_init(&mut self, _: ast::NodeId, _: Span) {}\n-    fn mutate(&mut self, _: ast::NodeId, span: Span, _: &cmt_<'_>, mode: MutateMode) {\n+    fn mutate(&mut self, _: hir::HirId, span: Span, _: &cmt_<'_>, mode: MutateMode) {\n         match mode {\n             MutateMode::JustWrite | MutateMode::WriteAndRead => {\n                 struct_span_err!(self.cx.tcx.sess, span, E0302, \"cannot assign in a pattern guard\")"}, {"sha": "9e5fdaa8afdf75b87d1359c1a500709b70254f62", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -631,7 +631,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     fields.iter()\n                           .map(|field| {\n                               FieldPattern {\n-                                  field: Field::new(self.tcx.field_index(field.node.id,\n+                                  field: Field::new(self.tcx.field_index(field.node.hir_id,\n                                                                          self.tables)),\n                                   pattern: self.lower_pattern(&field.node.pat),\n                               }"}, {"sha": "3ed63d749cd3558deefafc72f45e550b948aa798", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -12,7 +12,6 @@ use rustc::lint::builtin::{SAFE_EXTERN_STATICS, SAFE_PACKED_BORROWS, UNUSED_UNSA\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext};\n \n-use syntax::ast;\n use syntax::symbol::Symbol;\n \n use std::ops::Bound;\n@@ -29,8 +28,8 @@ pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     /// Mark an `unsafe` block as used, so we don't lint it.\n-    used_unsafe: FxHashSet<ast::NodeId>,\n-    inherited_blocks: Vec<(ast::NodeId, bool)>,\n+    used_unsafe: FxHashSet<hir::HirId>,\n+    inherited_blocks: Vec<(hir::HirId, bool)>,\n }\n \n impl<'a, 'gcx, 'tcx> UnsafetyChecker<'a, 'tcx> {\n@@ -349,7 +348,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n \n     fn register_violations(&mut self,\n                            violations: &[UnsafetyViolation],\n-                           unsafe_blocks: &[(ast::NodeId, bool)]) {\n+                           unsafe_blocks: &[(hir::HirId, bool)]) {\n         let safety = self.source_scope_local_data[self.source_info.scope].safety;\n         let within_unsafe = match safety {\n             // `unsafe` blocks are required in safe code\n@@ -375,10 +374,10 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n             }\n             // `unsafe` function bodies allow unsafe without additional unsafe blocks\n             Safety::BuiltinUnsafe | Safety::FnUnsafe => true,\n-            Safety::ExplicitUnsafe(node_id) => {\n+            Safety::ExplicitUnsafe(hir_id) => {\n                 // mark unsafe block as used if there are any unsafe operations inside\n                 if !violations.is_empty() {\n-                    self.used_unsafe.insert(node_id);\n+                    self.used_unsafe.insert(hir_id);\n                 }\n                 // only some unsafety is allowed in const fn\n                 if self.min_const_fn {\n@@ -405,8 +404,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                 true\n             }\n         };\n-        self.inherited_blocks.extend(unsafe_blocks.iter().map(|&(node_id, is_used)| {\n-            (node_id, is_used && !within_unsafe)\n+        self.inherited_blocks.extend(unsafe_blocks.iter().map(|&(hir_id, is_used)| {\n+            (hir_id, is_used && !within_unsafe)\n         }));\n     }\n     fn check_mut_borrowing_layout_constrained_field(\n@@ -467,8 +466,8 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n }\n \n struct UnusedUnsafeVisitor<'a> {\n-    used_unsafe: &'a FxHashSet<ast::NodeId>,\n-    unsafe_blocks: &'a mut Vec<(ast::NodeId, bool)>,\n+    used_unsafe: &'a FxHashSet<hir::HirId>,\n+    unsafe_blocks: &'a mut Vec<(hir::HirId, bool)>,\n }\n \n impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a> {\n@@ -482,19 +481,19 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UnusedUnsafeVisitor<'a> {\n         hir::intravisit::walk_block(self, block);\n \n         if let hir::UnsafeBlock(hir::UserProvided) = block.rules {\n-            self.unsafe_blocks.push((block.id, self.used_unsafe.contains(&block.id)));\n+            self.unsafe_blocks.push((block.hir_id, self.used_unsafe.contains(&block.hir_id)));\n         }\n     }\n }\n \n fn check_unused_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  def_id: DefId,\n-                                 used_unsafe: &FxHashSet<ast::NodeId>,\n-                                 unsafe_blocks: &'a mut Vec<(ast::NodeId, bool)>)\n+                                 used_unsafe: &FxHashSet<hir::HirId>,\n+                                 unsafe_blocks: &'a mut Vec<(hir::HirId, bool)>)\n {\n     let body_id =\n-        tcx.hir().as_local_node_id(def_id).and_then(|node_id| {\n-            tcx.hir().maybe_body_owned_by(node_id)\n+        tcx.hir().as_local_hir_id(def_id).and_then(|hir_id| {\n+            tcx.hir().maybe_body_owned_by_by_hir_id(hir_id)\n         });\n \n     let body_id = match body_id {\n@@ -574,18 +573,18 @@ fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: D\n                   &message);\n }\n \n-/// Returns the `NodeId` for an enclosing scope that is also `unsafe`.\n+/// Returns the `HirId` for an enclosing scope that is also `unsafe`.\n fn is_enclosed(tcx: TyCtxt<'_, '_, '_>,\n-               used_unsafe: &FxHashSet<ast::NodeId>,\n-               id: ast::NodeId) -> Option<(String, ast::NodeId)> {\n-    let parent_id = tcx.hir().get_parent_node(id);\n+               used_unsafe: &FxHashSet<hir::HirId>,\n+               id: hir::HirId) -> Option<(String, hir::HirId)> {\n+    let parent_id = tcx.hir().get_parent_node_by_hir_id(id);\n     if parent_id != id {\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n         } else if let Some(Node::Item(&hir::Item {\n             node: hir::ItemKind::Fn(_, header, _, _),\n             ..\n-        })) = tcx.hir().find(parent_id) {\n+        })) = tcx.hir().find_by_hir_id(parent_id) {\n             match header.unsafety {\n                 hir::Unsafety::Unsafe => Some((\"fn\".to_string(), parent_id)),\n                 hir::Unsafety::Normal => None,\n@@ -599,14 +598,14 @@ fn is_enclosed(tcx: TyCtxt<'_, '_, '_>,\n }\n \n fn report_unused_unsafe(tcx: TyCtxt<'_, '_, '_>,\n-                        used_unsafe: &FxHashSet<ast::NodeId>,\n-                        id: ast::NodeId) {\n-    let span = tcx.sess.source_map().def_span(tcx.hir().span(id));\n+                        used_unsafe: &FxHashSet<hir::HirId>,\n+                        id: hir::HirId) {\n+    let span = tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(id));\n     let msg = \"unnecessary `unsafe` block\";\n-    let mut db = tcx.struct_span_lint_node(UNUSED_UNSAFE, id, span, msg);\n+    let mut db = tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, msg);\n     db.span_label(span, msg);\n     if let Some((kind, id)) = is_enclosed(tcx, used_unsafe, id) {\n-        db.span_label(tcx.sess.source_map().def_span(tcx.hir().span(id)),\n+        db.span_label(tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(id)),\n                       format!(\"because it's nested under this `unsafe` {}\", kind));\n     }\n     db.emit();\n@@ -655,20 +654,20 @@ pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n                     .note(&details.as_str()[..])\n                     .emit();\n             }\n-            UnsafetyViolationKind::ExternStatic(lint_node_id) => {\n+            UnsafetyViolationKind::ExternStatic(lint_hir_id) => {\n                 tcx.lint_node_note(SAFE_EXTERN_STATICS,\n-                              lint_node_id,\n+                              lint_hir_id,\n                               source_info.span,\n                               &format!(\"{} is unsafe and requires unsafe function or block \\\n                                         (error E0133)\", &description.as_str()[..]),\n                               &details.as_str()[..]);\n             }\n-            UnsafetyViolationKind::BorrowPacked(lint_node_id) => {\n+            UnsafetyViolationKind::BorrowPacked(lint_hir_id) => {\n                 if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id) {\n                     tcx.unsafe_derive_on_repr_packed(impl_def_id);\n                 } else {\n                     tcx.lint_node_note(SAFE_PACKED_BORROWS,\n-                                  lint_node_id,\n+                                  lint_hir_id,\n                                   source_info.span,\n                                   &format!(\"{} is unsafe and requires unsafe function or block \\\n                                             (error E0133)\", &description.as_str()[..]),\n@@ -679,7 +678,7 @@ pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     }\n \n     let mut unsafe_blocks: Vec<_> = unsafe_blocks.into_iter().collect();\n-    unsafe_blocks.sort();\n+    unsafe_blocks.sort_by_cached_key(|(hir_id, _)| tcx.hir().hir_to_node_id(*hir_id));\n     let used_unsafe: FxHashSet<_> = unsafe_blocks.iter()\n         .flat_map(|&&(id, used)| if used { Some(id) } else { None })\n         .collect();"}, {"sha": "8b17904c7b5b0ed30d3d419c6b9d8245717694ec", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -430,10 +430,10 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                         } else {\n                             \"left\"\n                         };\n-                        let node_id = source_scope_local_data[source_info.scope].lint_root;\n-                        self.tcx.lint_node(\n+                        let hir_id = source_scope_local_data[source_info.scope].lint_root;\n+                        self.tcx.lint_hir(\n                             ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n-                            node_id,\n+                            hir_id,\n                             span,\n                             &format!(\"attempt to shift {} with overflow\", dir));\n                         return None;"}, {"sha": "c74314ce0c4b509aea306cc743dc09def8520249", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -2,7 +2,7 @@\n // pieces of AST and HIR. The resulting numbers are good approximations but not\n // completely accurate (some things might be counted twice, others missed).\n \n-use rustc::hir;\n+use rustc::hir::{self, HirId};\n use rustc::hir::intravisit as hir_visit;\n use rustc::util::common::to_readable_str;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -12,7 +12,7 @@ use syntax_pos::Span;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n enum Id {\n-    Node(NodeId),\n+    Node(HirId),\n     Attr(AttrId),\n     None,\n }\n@@ -119,7 +119,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_item(&mut self, i: &'v hir::Item) {\n-        self.record(\"Item\", Id::Node(i.id), i);\n+        self.record(\"Item\", Id::Node(i.hir_id), i);\n         hir_visit::walk_item(self, i)\n     }\n \n@@ -129,22 +129,22 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &'v hir::ForeignItem) {\n-        self.record(\"ForeignItem\", Id::Node(i.id), i);\n+        self.record(\"ForeignItem\", Id::Node(i.hir_id), i);\n         hir_visit::walk_foreign_item(self, i)\n     }\n \n     fn visit_local(&mut self, l: &'v hir::Local) {\n-        self.record(\"Local\", Id::Node(l.id), l);\n+        self.record(\"Local\", Id::Node(l.hir_id), l);\n         hir_visit::walk_local(self, l)\n     }\n \n     fn visit_block(&mut self, b: &'v hir::Block) {\n-        self.record(\"Block\", Id::Node(b.id), b);\n+        self.record(\"Block\", Id::Node(b.hir_id), b);\n         hir_visit::walk_block(self, b)\n     }\n \n     fn visit_stmt(&mut self, s: &'v hir::Stmt) {\n-        self.record(\"Stmt\", Id::Node(s.id), s);\n+        self.record(\"Stmt\", Id::Node(s.hir_id), s);\n         hir_visit::walk_stmt(self, s)\n     }\n \n@@ -154,17 +154,17 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_pat(&mut self, p: &'v hir::Pat) {\n-        self.record(\"Pat\", Id::Node(p.id), p);\n+        self.record(\"Pat\", Id::Node(p.hir_id), p);\n         hir_visit::walk_pat(self, p)\n     }\n \n     fn visit_expr(&mut self, ex: &'v hir::Expr) {\n-        self.record(\"Expr\", Id::Node(ex.id), ex);\n+        self.record(\"Expr\", Id::Node(ex.hir_id), ex);\n         hir_visit::walk_expr(self, ex)\n     }\n \n     fn visit_ty(&mut self, t: &'v hir::Ty) {\n-        self.record(\"Ty\", Id::Node(t.id), t);\n+        self.record(\"Ty\", Id::Node(t.hir_id), t);\n         hir_visit::walk_ty(self, t)\n     }\n \n@@ -184,12 +184,12 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_trait_item(&mut self, ti: &'v hir::TraitItem) {\n-        self.record(\"TraitItem\", Id::Node(ti.id), ti);\n+        self.record(\"TraitItem\", Id::Node(ti.hir_id), ti);\n         hir_visit::walk_trait_item(self, ti)\n     }\n \n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem) {\n-        self.record(\"ImplItem\", Id::Node(ii.id), ii);\n+        self.record(\"ImplItem\", Id::Node(ii.hir_id), ii);\n         hir_visit::walk_impl_item(self, ii)\n     }\n \n@@ -199,7 +199,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_struct_field(&mut self, s: &'v hir::StructField) {\n-        self.record(\"StructField\", Id::Node(s.id), s);\n+        self.record(\"StructField\", Id::Node(s.hir_id), s);\n         hir_visit::walk_struct_field(self, s)\n     }\n \n@@ -212,7 +212,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n-        self.record(\"Lifetime\", Id::Node(lifetime.id), lifetime);\n+        self.record(\"Lifetime\", Id::Node(lifetime.hir_id), lifetime);\n         hir_visit::walk_lifetime(self, lifetime)\n     }\n \n@@ -234,7 +234,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_assoc_type_binding(&mut self, type_binding: &'v hir::TypeBinding) {\n-        self.record(\"TypeBinding\", Id::Node(type_binding.id), type_binding);\n+        self.record(\"TypeBinding\", Id::Node(type_binding.hir_id), type_binding);\n         hir_visit::walk_assoc_type_binding(self, type_binding)\n     }\n \n@@ -243,7 +243,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'v hir::MacroDef) {\n-        self.record(\"MacroDef\", Id::Node(macro_def.id), macro_def);\n+        self.record(\"MacroDef\", Id::Node(macro_def.hir_id), macro_def);\n         hir_visit::walk_macro_def(self, macro_def)\n     }\n }"}, {"sha": "c25884df87ba13e49f8e4d8d13fbe34753bf1e87", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -23,7 +23,7 @@ use rustc::middle::mem_categorization::Categorization;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::Substs;\n-use rustc::util::nodemap::{ItemLocalSet, NodeSet};\n+use rustc::util::nodemap::{ItemLocalSet, HirIdSet};\n use rustc::hir;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n@@ -92,7 +92,7 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     in_fn: bool,\n     in_static: bool,\n-    mut_rvalue_borrows: NodeSet,\n+    mut_rvalue_borrows: HirIdSet,\n     param_env: ty::ParamEnv<'tcx>,\n     identity_substs: &'tcx Substs<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n@@ -169,7 +169,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     fn remove_mut_rvalue_borrow(&mut self, pat: &hir::Pat) -> bool {\n         let mut any_removed = false;\n         pat.walk(|p| {\n-            any_removed |= self.mut_rvalue_borrows.remove(&p.id);\n+            any_removed |= self.mut_rvalue_borrows.remove(&p.hir_id);\n             true\n         });\n         any_removed\n@@ -223,7 +223,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n             hir::StmtKind::Local(ref local) => {\n                 if self.remove_mut_rvalue_borrow(&local.pat) {\n                     if let Some(init) = &local.init {\n-                        self.mut_rvalue_borrows.insert(init.id);\n+                        self.mut_rvalue_borrows.insert(init.hir_id);\n                     }\n                 }\n \n@@ -248,7 +248,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         outer &= check_adjustments(self, ex);\n \n         // Handle borrows on (or inside the autorefs of) this expression.\n-        if self.mut_rvalue_borrows.remove(&ex.id) {\n+        if self.mut_rvalue_borrows.remove(&ex.hir_id) {\n             outer = NotPromotable\n         }\n \n@@ -318,7 +318,7 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n         hir::ExprKind::Cast(ref from, _) => {\n             let expr_promotability = v.check_expr(from);\n-            debug!(\"Checking const cast(id={})\", from.id);\n+            debug!(\"Checking const cast(id={})\", from.hir_id);\n             match v.tables.cast_kinds().get(from.hir_id) {\n                 None => {\n                     v.tcx.sess.delay_span_bug(e.span, \"no kind for cast\");\n@@ -456,9 +456,10 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Closure(_capture_clause, ref _box_fn_decl,\n                                body_id, _span, _option_generator_movability) => {\n             let nested_body_promotable = v.check_nested_body(body_id);\n+            let node_id = v.tcx.hir().hir_to_node_id(e.hir_id);\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n-            if v.tcx.with_freevars(e.id, |fv| !fv.is_empty()) {\n+            if v.tcx.with_freevars(node_id, |fv| !fv.is_empty()) {\n                 NotPromotable\n             } else {\n                 nested_body_promotable\n@@ -518,7 +519,7 @@ fn check_expr_kind<'a, 'tcx>(\n                 mut_borrow = v.remove_mut_rvalue_borrow(pat);\n             }\n             if mut_borrow {\n-                v.mut_rvalue_borrows.insert(expr.id);\n+                v.mut_rvalue_borrows.insert(expr.hir_id);\n             }\n \n             let _ = v.check_expr(expr);\n@@ -619,13 +620,13 @@ fn check_adjustments<'a, 'tcx>(\n \n impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n     fn consume(&mut self,\n-               _consume_id: ast::NodeId,\n+               _consume_id: hir::HirId,\n                _consume_span: Span,\n                _cmt: &mc::cmt_<'_>,\n                _mode: euv::ConsumeMode) {}\n \n     fn borrow(&mut self,\n-              borrow_id: ast::NodeId,\n+              borrow_id: hir::HirId,\n               _borrow_span: Span,\n               cmt: &mc::cmt_<'tcx>,\n               _loan_region: ty::Region<'tcx>,\n@@ -678,7 +679,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n \n     fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) {}\n     fn mutate(&mut self,\n-              _assignment_id: ast::NodeId,\n+              _assignment_id: hir::HirId,\n               _assignment_span: Span,\n               _assignee_cmt: &mc::cmt_<'_>,\n               _mode: euv::MutateMode) {"}, {"sha": "568e622bd34c2e70f494729bc4fccd094ee1e9b0", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -21,7 +21,7 @@ use rustc::ty::{self, TyCtxt, Ty, TraitRef, TypeFoldable, GenericParamDefKind};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::query::Providers;\n use rustc::ty::subst::Substs;\n-use rustc::util::nodemap::NodeSet;\n+use rustc::util::nodemap::HirIdSet;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::{self, DUMMY_NODE_ID, Ident};\n@@ -271,7 +271,8 @@ fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                     return (ctor_vis, span, descr);\n                 }\n                 Node::Expr(expr) => {\n-                    return (ty::Visibility::Restricted(tcx.hir().get_module_parent(expr.id)),\n+                    return (ty::Visibility::Restricted(\n+                        tcx.hir().get_module_parent_by_hir_id(expr.hir_id)),\n                             expr.span, \"private\")\n                 }\n                 node => bug!(\"unexpected node kind: {:?}\", node)\n@@ -695,18 +696,20 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n+        let node_id = self.tcx.hir().hir_to_node_id(md.hir_id);\n+\n         if md.legacy {\n-            self.update(md.id, Some(AccessLevel::Public));\n+            self.update(node_id, Some(AccessLevel::Public));\n             return\n         }\n \n         let module_did = ty::DefIdTree::parent(\n             self.tcx,\n-            self.tcx.hir().local_def_id(md.id)\n+            self.tcx.hir().local_def_id_from_hir_id(md.hir_id)\n         ).unwrap();\n         let mut module_id = self.tcx.hir().as_local_node_id(module_did).unwrap();\n         let level = if md.vis.node.is_pub() { self.get(module_id) } else { None };\n-        let level = self.update(md.id, level);\n+        let level = self.update(node_id, level);\n         if level.is_none() {\n             return\n         }\n@@ -870,7 +873,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                     // unmentioned fields, just check them all.\n                     for (vf_index, variant_field) in variant.fields.iter().enumerate() {\n                         let field = fields.iter().find(|f| {\n-                            self.tcx.field_index(f.id, self.tables) == vf_index\n+                            self.tcx.field_index(f.hir_id, self.tables) == vf_index\n                         });\n                         let (use_ctxt, span) = match field {\n                             Some(field) => (field.ident.span, field.span),\n@@ -881,7 +884,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 } else {\n                     for field in fields {\n                         let use_ctxt = field.ident.span;\n-                        let index = self.tcx.field_index(field.id, self.tables);\n+                        let index = self.tcx.field_index(field.hir_id, self.tables);\n                         self.check_field(use_ctxt, field.span, adt, &variant.fields[index]);\n                     }\n                 }\n@@ -900,7 +903,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n                     let use_ctxt = field.node.ident.span;\n-                    let index = self.tcx.field_index(field.node.id, self.tables);\n+                    let index = self.tcx.field_index(field.node.hir_id, self.tables);\n                     self.check_field(use_ctxt, field.span, adt, &variant.fields[index]);\n                 }\n             }\n@@ -1152,7 +1155,7 @@ struct ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n     access_levels: &'a AccessLevels,\n     in_variant: bool,\n     // Set of errors produced by this obsolete visitor.\n-    old_error_set: NodeSet,\n+    old_error_set: HirIdSet,\n }\n \n struct ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n@@ -1196,7 +1199,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn check_generic_bound(&mut self, bound: &hir::GenericBound) {\n         if let hir::GenericBound::Trait(ref trait_ref, _) = *bound {\n             if self.path_is_private_type(&trait_ref.trait_ref.path) {\n-                self.old_error_set.insert(trait_ref.trait_ref.ref_id);\n+                self.old_error_set.insert(trait_ref.trait_ref.hir_ref_id);\n             }\n         }\n     }\n@@ -1452,7 +1455,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = t.node {\n             if self.path_is_private_type(path) {\n-                self.old_error_set.insert(t.id);\n+                self.old_error_set.insert(t.hir_id);\n             }\n         }\n         intravisit::walk_ty(self, t)\n@@ -1596,7 +1599,7 @@ impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for SearchInterfaceForPrivateItemsVisitor<\n struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     has_pub_restricted: bool,\n-    old_error_set: &'a NodeSet,\n+    old_error_set: &'a HirIdSet,\n     private_crates: FxHashSet<CrateNum>\n }\n \n@@ -1608,7 +1611,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n         // Slow path taken only if there any errors in the crate.\n         for &id in self.old_error_set {\n             // Walk up the nodes until we find `item_id` (or we hit a root).\n-            let mut id = id;\n+            let mut id = self.tcx.hir().hir_to_node_id(id);\n             loop {\n                 if id == item_id {\n                     has_old_errors = true;"}, {"sha": "b82aee7c96ad296caa5b8ec2df951ac9405939f1", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -1517,7 +1517,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                         return;\n                     }\n                 };\n-                let def = self.save_ctxt.get_path_def(hir_expr.id);\n+                let node_id = self.save_ctxt.tcx.hir().hir_to_node_id(hir_expr.hir_id);\n+                let def = self.save_ctxt.get_path_def(node_id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n             }\n             ast::ExprKind::MethodCall(ref seg, ref args) => self.process_method_call(ex, seg, args),"}, {"sha": "af3f54187b0c3458933cbd5cb4fd50c10f3309e9", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -397,7 +397,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     Some(Node::Item(item)) => match item.node {\n                         hir::ItemKind::Impl(.., ref ty, _) => {\n                             let mut qualname = String::from(\"<\");\n-                            qualname.push_str(&self.tcx.hir().node_to_pretty_string(ty.id));\n+                            qualname.push_str(&self.tcx.hir().hir_to_pretty_string(ty.hir_id));\n \n                             let trait_id = self.tcx.trait_id_of_impl(impl_id);\n                             let mut decl_id = None;"}, {"sha": "db63f2aafbc24d1cb6bf528fd2dd1a9b58ec09b9", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -304,8 +304,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 } else {\n                     let mut multispan = MultiSpan::from_span(span);\n                     multispan.push_span_label(span_late, note.to_string());\n-                    tcx.lint_node(lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n-                                  args.args[0].id(), multispan, msg);\n+                    tcx.lint_hir(lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n+                                 args.args[0].id(), multispan, msg);\n                     return (false, None);\n                 }\n             }\n@@ -885,7 +885,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             let msg = format!(\"associated type `{}` is private\", binding.item_name);\n             tcx.sess.span_err(binding.span, &msg);\n         }\n-        tcx.check_stability(assoc_ty.def_id, Some(ref_id), binding.span);\n+        tcx.check_stability(assoc_ty.def_id, Some(hir_ref_id), binding.span);\n \n         if !speculative {\n             dup_bindings.entry(assoc_ty.def_id)\n@@ -1267,7 +1267,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     // parameter or `Self`.\n     pub fn associated_path_to_ty(\n         &self,\n-        ref_id: ast::NodeId,\n+        hir_ref_id: hir::HirId,\n         span: Span,\n         qself_ty: Ty<'tcx>,\n         qself_def: Def,\n@@ -1292,7 +1292,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     let def = Def::Variant(variant_def.did);\n                     if permit_variants {\n                         check_type_alias_enum_variants_enabled(tcx, span);\n-                        tcx.check_stability(variant_def.did, Some(ref_id), span);\n+                        tcx.check_stability(variant_def.did, Some(hir_ref_id), span);\n                         return (qself_ty, def);\n                     } else {\n                         variant_resolution = Some(def);\n@@ -1370,7 +1370,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         };\n \n         let trait_did = bound.def_id();\n-        let hir_ref_id = self.tcx().hir().node_to_hir_id(ref_id);\n         let (assoc_ident, def_scope) = tcx.adjust_ident(assoc_ident, trait_did, hir_ref_id);\n         let item = tcx.associated_items(trait_did).find(|i| {\n             Namespace::from(i.kind) == Namespace::Type &&\n@@ -1385,12 +1384,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), assoc_ident);\n             tcx.sess.span_err(span, &msg);\n         }\n-        tcx.check_stability(item.def_id, Some(ref_id), span);\n+        tcx.check_stability(item.def_id, Some(hir_ref_id), span);\n \n         if let Some(variant_def) = variant_resolution {\n-            let mut err = tcx.struct_span_lint_node(\n+            let mut err = tcx.struct_span_lint_hir(\n                 AMBIGUOUS_ASSOCIATED_ITEMS,\n-                ref_id,\n+                hir_ref_id,\n                 span,\n                 \"ambiguous associated item\",\n             );\n@@ -1742,7 +1741,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// internal notion of a type.\n     pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n         debug!(\"ast_ty_to_ty(id={:?}, ast_ty={:?} ty_ty={:?})\",\n-               ast_ty.id, ast_ty, ast_ty.node);\n+               ast_ty.hir_id, ast_ty, ast_ty.node);\n \n         let tcx = self.tcx();\n \n@@ -1795,7 +1794,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 } else {\n                     Def::Err\n                 };\n-                self.associated_path_to_ty(ast_ty.id, ast_ty.span, ty, def, segment, false).0\n+                self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, def, segment, false).0\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n                 let length_def_id = tcx.hir().local_def_id(length.id);"}, {"sha": "100e55fc36723848dfd71b8f6217aaf9e7b12561", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -64,7 +64,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             PatKind::Path(ref qpath) => {\n-                let (def, _, _) = self.resolve_ty_and_def_ufcs(qpath, pat.id, pat.span);\n+                let (def, _, _) = self.resolve_ty_and_def_ufcs(qpath, pat.hir_id, pat.span);\n                 match def {\n                     Def::Const(..) | Def::AssociatedConst(..) => false,\n                     _ => true,\n@@ -630,7 +630,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n \n         if self.diverges.get().always() {\n             for arm in arms {\n-                self.warn_if_unreachable(arm.body.id, arm.body.span, \"arm\");\n+                self.warn_if_unreachable(arm.body.hir_id, arm.body.span, \"arm\");\n             }\n         }\n \n@@ -725,7 +725,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 let cause = if i == 0 {\n                     // The reason for the first arm to fail is not that the match arms diverge,\n                     // but rather that there's a prior obligation that doesn't hold.\n-                    self.cause(arm_span, ObligationCauseCode::BlockTailExpression(arm.body.id))\n+                    self.cause(arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id))\n                 } else {\n                     self.cause(expr.span, ObligationCauseCode::MatchExpressionArm {\n                         arm_span,\n@@ -761,7 +761,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n     ) -> Ty<'tcx>\n     {\n         // Resolve the path and check the definition for errors.\n-        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.id) {\n+        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.hir_id)\n+        {\n             variant_ty\n         } else {\n             for field in fields {\n@@ -779,7 +780,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         self.demand_eqtype_pat(pat.span, expected, pat_ty, match_discrim_span);\n \n         // Type-check subpatterns.\n-        if self.check_struct_pat_fields(pat_ty, pat.id, pat.span, variant, fields, etc, def_bm) {\n+        if self.check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm)\n+        {\n             pat_ty\n         } else {\n             self.tcx.types.err\n@@ -795,7 +797,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let tcx = self.tcx;\n \n         // Resolve the path and check the definition for errors.\n-        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.id, pat.span);\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.hir_id, pat.span);\n         match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n@@ -818,7 +820,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         }\n \n         // Type-check the path.\n-        let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id).0;\n+        let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.hir_id).0;\n         self.demand_suptype(pat.span, expected, pat_ty);\n         pat_ty\n     }\n@@ -849,15 +851,16 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         };\n \n         // Resolve the path and check the definition for errors.\n-        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.id, pat.span);\n+        let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(qpath, pat.hir_id, pat.span);\n         if def == Def::Err {\n             self.set_tainted_by_errors();\n             on_error();\n             return self.tcx.types.err;\n         }\n \n         // Type-check the path.\n-        let (pat_ty, def) = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n+        let (pat_ty, def) = self.instantiate_value_path(segments, opt_ty, def, pat.span,\n+            pat.hir_id);\n         if !pat_ty.is_fn() {\n             report_unexpected_def(def);\n             return self.tcx.types.err;\n@@ -897,7 +900,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n                 self.check_pat_walk(&subpat, field_ty, def_bm, match_arm_pat_span);\n \n-                self.tcx.check_stability(variant.fields[i].did, Some(pat.id), subpat.span);\n+                self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n             }\n         } else {\n             let subpats_ending = if subpats.len() == 1 { \"\" } else { \"s\" };\n@@ -917,7 +920,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n \n     fn check_struct_pat_fields(&self,\n                                adt_ty: Ty<'tcx>,\n-                               pat_id: ast::NodeId,\n+                               pat_id: hir::HirId,\n                                span: Span,\n                                variant: &'tcx ty::VariantDef,\n                                fields: &'gcx [Spanned<hir::FieldPat>],\n@@ -963,7 +966,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                     vacant.insert(span);\n                     field_map.get(&ident)\n                         .map(|(i, f)| {\n-                            self.write_field_index(field.id, *i);\n+                            self.write_field_index(field.hir_id, *i);\n                             self.tcx.check_stability(f.did, Some(pat_id), span);\n                             self.field_ty(span, f, substs)\n                         })"}, {"sha": "7bf7d82540655325bca06a4f2feafec6e10b228a", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -250,7 +250,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let &ty::Adt(adt_def, ..) = t {\n                     if adt_def.is_enum() {\n                         if let hir::ExprKind::Call(ref expr, _) = call_expr.node {\n-                            unit_variant = Some(self.tcx.hir().node_to_pretty_string(expr.id))\n+                            unit_variant = Some(self.tcx.hir().hir_to_pretty_string(expr.hir_id))\n                         }\n                     }\n                 }"}, {"sha": "97ee973938ccbbe1e1d4b2d664ea069bbf55f600", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -399,9 +399,9 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         } else {\n             (\"\", lint::builtin::TRIVIAL_CASTS)\n         };\n-        let mut err = fcx.tcx.struct_span_lint_node(\n+        let mut err = fcx.tcx.struct_span_lint_hir(\n             lint,\n-            self.expr.id,\n+            self.expr.hir_id,\n             self.span,\n             &format!(\"trivial {}cast: `{}` as `{}`\",\n                      adjective,\n@@ -417,7 +417,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         self.cast_ty = fcx.structurally_resolved_type(self.span, self.cast_ty);\n \n         debug!(\"check_cast({}, {:?} as {:?})\",\n-               self.expr.id,\n+               self.expr.hir_id,\n                self.expr_ty,\n                self.cast_ty);\n "}, {"sha": "220adc2de7b6137f70b2fcc0cdecb46d7d2573c0", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             opt_kind, expected_sig\n         );\n \n-        let expr_def_id = self.tcx.hir().local_def_id(expr.id);\n+        let expr_def_id = self.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n \n         let ClosureSignatures {\n             bound_sig,\n@@ -86,7 +86,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.param_env,\n             liberated_sig,\n             decl,\n-            expr.id,\n+            expr.hir_id,\n             body,\n             gen,\n         ).1;\n@@ -131,8 +131,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n \n         debug!(\n-            \"check_closure: expr.id={:?} closure_type={:?}\",\n-            expr.id, closure_type\n+            \"check_closure: expr.hir_id={:?} closure_type={:?}\",\n+            expr.hir_id, closure_type\n         );\n \n         // Tuple up the arguments and insert the resulting function type into"}, {"sha": "ebd7dad58fd038235148168eb55e992ee2919995", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -1177,7 +1177,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         Expressions::UpFront(coercion_sites) => {\n                             // if the user gave us an array to validate, check that we got\n                             // the next expression in the list, as expected\n-                            assert_eq!(coercion_sites[self.pushed].as_coercion_site().id, e.id);\n+                            assert_eq!(coercion_sites[self.pushed].as_coercion_site().hir_id,\n+                                       e.hir_id);\n                         }\n                     }\n                     self.pushed += 1;\n@@ -1208,7 +1209,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         db.span_label(cause.span, \"return type is not `()`\");\n                     }\n                     ObligationCauseCode::BlockTailExpression(blk_id) => {\n-                        let parent_id = fcx.tcx.hir().get_parent_node(blk_id);\n+                        let parent_id = fcx.tcx.hir().get_parent_node_by_hir_id(blk_id);\n                         db = self.report_return_mismatched_types(\n                             cause,\n                             expected,\n@@ -1246,8 +1247,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         found: Ty<'tcx>,\n         err: TypeError<'tcx>,\n         fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n-        id: syntax::ast::NodeId,\n-        expression: Option<(&'gcx hir::Expr, syntax::ast::NodeId)>,\n+        id: hir::HirId,\n+        expression: Option<(&'gcx hir::Expr, hir::HirId)>,\n     ) -> DiagnosticBuilder<'a> {\n         let mut db = fcx.report_mismatched_types(cause, expected, found, err);\n \n@@ -1257,7 +1258,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         // Verify that this is a tail expression of a function, otherwise the\n         // label pointing out the cause for the type coercion will be wrong\n         // as prior return coercions would not be relevant (#57664).\n-        let parent_id = fcx.tcx.hir().get_parent_node(id);\n+        let parent_id = fcx.tcx.hir().get_parent_node_by_hir_id(id);\n         let fn_decl = if let Some((expr, blk_id)) = expression {\n             pointing_at_return_type = fcx.suggest_mismatched_types_on_tail(\n                 &mut db,\n@@ -1267,7 +1268,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                 cause.span,\n                 blk_id,\n             );\n-            let parent = fcx.tcx.hir().get(parent_id);\n+            let parent = fcx.tcx.hir().get_by_hir_id(parent_id);\n             fcx.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n         } else {\n             fcx.get_fn_decl(parent_id)"}, {"sha": "f736e7ac29d080b266c25d6305600178ef8103a1", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -2,7 +2,6 @@ use crate::check::FnCtxt;\n use rustc::infer::InferOk;\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n \n-use syntax::ast;\n use syntax::util::parser::PREC_POSTFIX;\n use syntax_pos::Span;\n use rustc::hir;\n@@ -164,7 +163,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                      probe::Mode::MethodCall,\n                                                      expected,\n                                                      checked_ty,\n-                                                     ast::DUMMY_NODE_ID);\n+                                                     hir::DUMMY_HIR_ID);\n         methods.retain(|m| {\n             self.has_no_input_arg(m) &&\n                 self.tcx.get_attrs(m.def_id).iter()\n@@ -218,15 +217,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if let hir::def::Def::Local(id) = path.def {\n                 let parent = self.tcx.hir().get_parent_node(id);\n                 if let Some(Node::Expr(hir::Expr {\n-                    id,\n+                    hir_id,\n                     node: hir::ExprKind::Closure(_, decl, ..),\n                     ..\n                 })) = self.tcx.hir().find(parent) {\n-                    let parent = self.tcx.hir().get_parent_node(*id);\n+                    let parent = self.tcx.hir().get_parent_node_by_hir_id(*hir_id);\n                     if let (Some(Node::Expr(hir::Expr {\n                         node: hir::ExprKind::MethodCall(path, span, expr),\n                         ..\n-                    })), 1) = (self.tcx.hir().find(parent), decl.inputs.len()) {\n+                    })), 1) = (self.tcx.hir().find_by_hir_id(parent), decl.inputs.len()) {\n                         let self_ty = self.tables.borrow().node_type(expr[0].hir_id);\n                         let self_ty = format!(\"{:?}\", self_ty);\n                         let name = path.ident.as_str();\n@@ -470,8 +469,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n     ) -> bool {\n-        let parent_id = self.tcx.hir().get_parent_node(expr.id);\n-        if let Some(parent) = self.tcx.hir().find(parent_id) {\n+        let parent_id = self.tcx.hir().get_parent_node_by_hir_id(expr.hir_id);\n+        if let Some(parent) = self.tcx.hir().find_by_hir_id(parent_id) {\n             // Shouldn't suggest `.into()` on `const`s.\n             if let Node::Item(Item { node: ItemKind::Const(_, _), .. }) = parent {\n                 // FIXME(estebank): modify once we decide to suggest `as` casts\n@@ -501,10 +500,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some(hir::Node::Expr(hir::Expr {\n             node: hir::ExprKind::Struct(_, fields, _),\n             ..\n-        })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.id)) {\n+        })) = self.tcx.hir().find_by_hir_id(self.tcx.hir().get_parent_node_by_hir_id(expr.hir_id)) {\n             // `expr` is a literal field for a struct, only suggest if appropriate\n             for field in fields {\n-                if field.expr.id == expr.id && field.is_shorthand {\n+                if field.expr.hir_id == expr.hir_id && field.is_shorthand {\n                     // This is a field literal\n                     prefix = format!(\"{}: \", field.ident);\n                     break;"}, {"sha": "b14c56ddad008fa03c9ed1c0bb347f1490b918f3", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn method_exists(&self,\n                          method_name: ast::Ident,\n                          self_ty: Ty<'tcx>,\n-                         call_expr_id: ast::NodeId,\n+                         call_expr_id: hir::HirId,\n                          allow_private: bool)\n                          -> bool {\n         let mode = probe::Mode::MethodCall;\n@@ -131,7 +131,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         msg: &str,\n         method_name: ast::Ident,\n         self_ty: Ty<'tcx>,\n-        call_expr_id: ast::NodeId,\n+        call_expr_id: hir::HirId,\n     ) {\n         let has_params = self\n             .probe_for_name(\n@@ -202,7 +202,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 .unwrap().insert(import_def_id);\n         }\n \n-        self.tcx.check_stability(pick.item.def_id, Some(call_expr.id), span);\n+        self.tcx.check_stability(pick.item.def_id, Some(call_expr.hir_id), span);\n \n         let result = self.confirm_method(\n             span,\n@@ -255,7 +255,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mode = probe::Mode::MethodCall;\n         let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n         self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n-                            self_ty, call_expr.id, scope)\n+                            self_ty, call_expr.hir_id, scope)\n     }\n \n     /// `lookup_method_in_trait` is used for overloaded operators.\n@@ -399,7 +399,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         method_name: ast::Ident,\n         self_ty: Ty<'tcx>,\n-        expr_id: ast::NodeId\n+        expr_id: hir::HirId\n     ) -> Result<Def, MethodError<'tcx>> {\n         debug!(\n             \"resolve_ufcs: method_name={:?} self_ty={:?} expr_id={:?}\","}, {"sha": "312d83cebbab3e631e46bcf1386356d96fbb9e53", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -209,7 +209,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  mode: Mode,\n                                  return_type: Ty<'tcx>,\n                                  self_ty: Ty<'tcx>,\n-                                 scope_expr_id: ast::NodeId)\n+                                 scope_expr_id: hir::HirId)\n                                  -> Vec<ty::AssociatedItem> {\n         debug!(\"probe(self_ty={:?}, return_type={}, scope_expr_id={})\",\n                self_ty,\n@@ -238,7 +238,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           item_name: ast::Ident,\n                           is_suggestion: IsSuggestion,\n                           self_ty: Ty<'tcx>,\n-                          scope_expr_id: ast::NodeId,\n+                          scope_expr_id: hir::HirId,\n                           scope: ProbeScope)\n                           -> PickResult<'tcx> {\n         debug!(\"probe(self_ty={:?}, item_name={}, scope_expr_id={})\",\n@@ -263,7 +263,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       return_type: Option<Ty<'tcx>>,\n                       is_suggestion: IsSuggestion,\n                       self_ty: Ty<'tcx>,\n-                      scope_expr_id: ast::NodeId,\n+                      scope_expr_id: hir::HirId,\n                       scope: ProbeScope,\n                       op: OP)\n                       -> Result<R, MethodError<'tcx>>\n@@ -340,7 +340,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               \"the type of this value must be known \\\n                                to call a method on a raw pointer on it\");\n                 } else {\n-                   self.tcx.lint_node(\n+                   self.tcx.lint_hir(\n                         lint::builtin::TYVAR_BEHIND_RAW_POINTER,\n                         scope_expr_id,\n                         span,\n@@ -825,13 +825,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_extension_candidates_for_traits_in_scope(&mut self,\n-                                                         expr_id: ast::NodeId)\n+                                                         expr_hir_id: hir::HirId)\n                                                          -> Result<(), MethodError<'tcx>> {\n-        if expr_id == ast::DUMMY_NODE_ID {\n+        if expr_hir_id == hir::DUMMY_HIR_ID {\n             return Ok(())\n         }\n         let mut duplicates = FxHashSet::default();\n-        let expr_hir_id = self.tcx.hir().node_to_hir_id(expr_id);\n         let opt_applicable_traits = self.tcx.in_scope_traits(expr_hir_id);\n         if let Some(applicable_traits) = opt_applicable_traits {\n             for trait_candidate in applicable_traits.iter() {\n@@ -1415,7 +1414,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                             steps, IsSuggestion(true));\n             pcx.allow_similar_names = true;\n             pcx.assemble_inherent_candidates();\n-            pcx.assemble_extension_candidates_for_traits_in_scope(ast::DUMMY_NODE_ID)?;\n+            pcx.assemble_extension_candidates_for_traits_in_scope(hir::DUMMY_HIR_ID)?;\n \n             let method_names = pcx.candidate_method_names();\n             pcx.allow_similar_names = false;\n@@ -1425,7 +1424,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     pcx.reset();\n                     pcx.method_name = Some(method_name);\n                     pcx.assemble_inherent_candidates();\n-                    pcx.assemble_extension_candidates_for_traits_in_scope(ast::DUMMY_NODE_ID)\n+                    pcx.assemble_extension_candidates_for_traits_in_scope(hir::DUMMY_HIR_ID)\n                         .ok().map_or(None, |_| {\n                             pcx.pick_core()\n                                 .and_then(|pick| pick.ok())"}, {"sha": "d77aabcda2d8d6bc70a4216e5badda16ed628928", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 98, "deletions": 97, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -137,7 +137,7 @@ use crate::TypeAndSubsts;\n use crate::lint;\n use crate::util::captures::Captures;\n use crate::util::common::{ErrorReported, indenter};\n-use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, NodeMap};\n+use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, HirIdMap, NodeMap};\n \n pub use self::Expectation::*;\n use self::autoderef::Autoderef;\n@@ -388,14 +388,14 @@ impl Needs {\n \n #[derive(Copy, Clone)]\n pub struct UnsafetyState {\n-    pub def: ast::NodeId,\n+    pub def: hir::HirId,\n     pub unsafety: hir::Unsafety,\n     pub unsafe_push_count: u32,\n     from_fn: bool\n }\n \n impl UnsafetyState {\n-    pub fn function(unsafety: hir::Unsafety, def: ast::NodeId) -> UnsafetyState {\n+    pub fn function(unsafety: hir::Unsafety, def: hir::HirId) -> UnsafetyState {\n         UnsafetyState { def: def, unsafety: unsafety, unsafe_push_count: 0, from_fn: true }\n     }\n \n@@ -410,11 +410,11 @@ impl UnsafetyState {\n             unsafety => {\n                 let (unsafety, def, count) = match blk.rules {\n                     hir::PushUnsafeBlock(..) =>\n-                        (unsafety, blk.id, self.unsafe_push_count.checked_add(1).unwrap()),\n+                        (unsafety, blk.hir_id, self.unsafe_push_count.checked_add(1).unwrap()),\n                     hir::PopUnsafeBlock(..) =>\n-                        (unsafety, blk.id, self.unsafe_push_count.checked_sub(1).unwrap()),\n+                        (unsafety, blk.hir_id, self.unsafe_push_count.checked_sub(1).unwrap()),\n                     hir::UnsafeBlock(..) =>\n-                        (hir::Unsafety::Unsafe, blk.id, self.unsafe_push_count),\n+                        (hir::Unsafety::Unsafe, blk.hir_id, self.unsafe_push_count),\n                     hir::DefaultBlock =>\n                         (unsafety, self.def, self.unsafe_push_count),\n                 };\n@@ -497,11 +497,11 @@ pub struct BreakableCtxt<'gcx: 'tcx, 'tcx> {\n \n pub struct EnclosingBreakables<'gcx: 'tcx, 'tcx> {\n     stack: Vec<BreakableCtxt<'gcx, 'tcx>>,\n-    by_id: NodeMap<usize>,\n+    by_id: HirIdMap<usize>,\n }\n \n impl<'gcx, 'tcx> EnclosingBreakables<'gcx, 'tcx> {\n-    fn find_breakable(&mut self, target_id: ast::NodeId) -> &mut BreakableCtxt<'gcx, 'tcx> {\n+    fn find_breakable(&mut self, target_id: hir::HirId) -> &mut BreakableCtxt<'gcx, 'tcx> {\n         let ix = *self.by_id.get(&target_id).unwrap_or_else(|| {\n             bug!(\"could not find enclosing breakable with id {}\", target_id);\n         });\n@@ -770,10 +770,10 @@ fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// (notably closures), `typeck_tables(def_id)` would wind up\n /// redirecting to the owning function.\n fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             id: ast::NodeId)\n+                             id: hir::HirId)\n                              -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)>\n {\n-    match tcx.hir().get(id) {\n+    match tcx.hir().get_by_hir_id(id) {\n         Node::Item(item) => {\n             match item.node {\n                 hir::ItemKind::Const(_, body) |\n@@ -820,7 +820,7 @@ fn has_typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return tcx.has_typeck_tables(outer_def_id);\n     }\n \n-    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     primary_body_of(tcx, id).is_some()\n }\n \n@@ -840,8 +840,8 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return tcx.typeck_tables_of(outer_def_id);\n     }\n \n-    let id = tcx.hir().as_local_node_id(def_id).unwrap();\n-    let span = tcx.hir().span(id);\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let span = tcx.hir().span_by_hir_id(id);\n \n     // Figure out what primary body this item has.\n     let (body_id, fn_decl) = primary_body_of(tcx, id).unwrap_or_else(|| {\n@@ -925,8 +925,8 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Consistency check our TypeckTables instance can hold all ItemLocalIds\n     // it will need to hold.\n-    assert_eq!(tables.local_id_root,\n-               Some(DefId::local(tcx.hir().definitions().node_to_hir_id(id).owner)));\n+    assert_eq!(tables.local_id_root, Some(DefId::local(id.owner)));\n+\n     tables\n }\n \n@@ -939,7 +939,7 @@ fn check_abi<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, abi: Abi) {\n \n struct GatherLocalsVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    parent_id: ast::NodeId,\n+    parent_id: hir::HirId,\n }\n \n impl<'a, 'gcx, 'tcx> GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n@@ -1051,7 +1051,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             param_env: ty::ParamEnv<'tcx>,\n                             fn_sig: ty::FnSig<'tcx>,\n                             decl: &'gcx hir::FnDecl,\n-                            fn_id: ast::NodeId,\n+                            fn_id: hir::HirId,\n                             body: &'gcx hir::Body,\n                             can_be_generator: Option<hir::GeneratorMovability>)\n                             -> (FnCtxt<'a, 'gcx, 'tcx>, Option<GeneratorTypes<'tcx>>)\n@@ -1085,9 +1085,9 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         fcx.yield_ty = Some(yield_ty);\n     }\n \n-    let outer_def_id = fcx.tcx.closure_base_def_id(fcx.tcx.hir().local_def_id(fn_id));\n-    let outer_node_id = fcx.tcx.hir().as_local_node_id(outer_def_id).unwrap();\n-    GatherLocalsVisitor { fcx: &fcx, parent_id: outer_node_id, }.visit_body(body);\n+    let outer_def_id = fcx.tcx.closure_base_def_id(fcx.tcx.hir().local_def_id_from_hir_id(fn_id));\n+    let outer_hir_id = fcx.tcx.hir().as_local_hir_id(outer_def_id).unwrap();\n+    GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id, }.visit_body(body);\n \n     // Add formal parameters.\n     for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n@@ -1110,8 +1110,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         fcx.write_ty(arg.hir_id, arg_ty);\n     }\n \n-    let fn_hir_id = fcx.tcx.hir().node_to_hir_id(fn_id);\n-    inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_hir_id, fn_sig);\n+    inherited.tables.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n     fcx.check_return_expr(&body.value);\n \n@@ -1164,14 +1163,13 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     // Check that the main return type implements the termination trait.\n     if let Some(term_id) = fcx.tcx.lang_items().termination() {\n         if let Some((def_id, EntryFnType::Main)) = fcx.tcx.entry_fn(LOCAL_CRATE) {\n-            let main_id = fcx.tcx.hir().as_local_node_id(def_id).unwrap();\n+            let main_id = fcx.tcx.hir().as_local_hir_id(def_id).unwrap();\n             if main_id == fn_id {\n                 let substs = fcx.tcx.mk_substs_trait(declared_ret_ty, &[]);\n                 let trait_ref = ty::TraitRef::new(term_id, substs);\n                 let return_ty_span = decl.output.span();\n-                let fn_hir_id = fcx.tcx.hir().node_to_hir_id(fn_id);\n                 let cause = traits::ObligationCause::new(\n-                    return_ty_span, fn_hir_id, ObligationCauseCode::MainFunctionType);\n+                    return_ty_span, fn_id, ObligationCauseCode::MainFunctionType);\n \n                 inherited.register_predicate(\n                     traits::Obligation::new(\n@@ -1182,7 +1180,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n     if let Some(panic_impl_did) = fcx.tcx.lang_items().panic_impl() {\n-        if panic_impl_did == fcx.tcx.hir().local_def_id(fn_id) {\n+        if panic_impl_did == fcx.tcx.hir().local_def_id_from_hir_id(fn_id) {\n             if let Some(panic_info_did) = fcx.tcx.lang_items().panic_info() {\n                 // at this point we don't care if there are duplicate handlers or if the handler has\n                 // the wrong signature as this value we'll be used when writing metadata and that\n@@ -1197,7 +1195,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir().span(fn_id);\n+                let span = fcx.tcx.hir().span_by_hir_id(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_panic_info = match inputs[0].sty {\n                         ty::Ref(region, ty, mutbl) => match ty.sty {\n@@ -1218,7 +1216,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                         );\n                     }\n \n-                    if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n+                    if let Node::Item(item) = fcx.tcx.hir().get_by_hir_id(fn_id) {\n                         if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n@@ -1240,7 +1238,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n     if let Some(alloc_error_handler_did) = fcx.tcx.lang_items().oom() {\n-        if alloc_error_handler_did == fcx.tcx.hir().local_def_id(fn_id) {\n+        if alloc_error_handler_did == fcx.tcx.hir().local_def_id_from_hir_id(fn_id) {\n             if let Some(alloc_layout_did) = fcx.tcx.lang_items().alloc_layout() {\n                 if declared_ret_ty.sty != ty::Never {\n                     fcx.tcx.sess.span_err(\n@@ -1250,7 +1248,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir().span(fn_id);\n+                let span = fcx.tcx.hir().span_by_hir_id(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_alloc_layout = match inputs[0].sty {\n                         ty::Adt(ref adt, _) => {\n@@ -1266,7 +1264,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                         );\n                     }\n \n-                    if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n+                    if let Node::Item(item) = fcx.tcx.hir().get_by_hir_id(fn_id) {\n                         if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n@@ -2030,7 +2028,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ret_coercion_span: RefCell::new(None),\n             yield_ty: None,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n-                                                     ast::CRATE_NODE_ID)),\n+                                                     hir::CRATE_HIR_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n             has_errors: Cell::new(false),\n             enclosing_breakables: RefCell::new(EnclosingBreakables {\n@@ -2051,13 +2049,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Produces warning on the given node, if the current point in the\n     /// function is unreachable, and there hasn't been another warning.\n-    fn warn_if_unreachable(&self, id: ast::NodeId, span: Span, kind: &str) {\n+    fn warn_if_unreachable(&self, id: hir::HirId, span: Span, kind: &str) {\n         if self.diverges.get() == Diverges::Always {\n             self.diverges.set(Diverges::WarnedAlways);\n \n             debug!(\"warn_if_unreachable: id={:?} span={:?} kind={}\", id, span, kind);\n \n-            self.tcx().lint_node(\n+            self.tcx().lint_hir(\n                 lint::builtin::UNREACHABLE_CODE,\n                 id, span,\n                 &format!(\"unreachable {}\", kind));\n@@ -2145,8 +2143,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn write_field_index(&self, node_id: ast::NodeId, index: usize) {\n-        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n+    pub fn write_field_index(&self, hir_id: hir::HirId, index: usize) {\n         self.tables.borrow_mut().field_indices_mut().insert(hir_id, index);\n     }\n \n@@ -2339,10 +2336,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// `InferCtxt::instantiate_opaque_types` for more details.\n     fn instantiate_opaque_types_from_value<T: TypeFoldable<'tcx>>(\n         &self,\n-        parent_id: ast::NodeId,\n+        parent_id: hir::HirId,\n         value: &T,\n     ) -> T {\n-        let parent_def_id = self.tcx.hir().local_def_id(parent_id);\n+        let parent_def_id = self.tcx.hir().local_def_id_from_hir_id(parent_id);\n         debug!(\"instantiate_opaque_types_from_value(parent_def_id={:?}, value={:?})\",\n                parent_def_id,\n                value);\n@@ -3009,7 +3006,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Closure arguments themselves can't be diverging, but\n                 // a previous argument can, e.g., `foo(panic!(), || {})`.\n                 if !check_closures {\n-                    self.warn_if_unreachable(arg.id, arg.span, \"expression\");\n+                    self.warn_if_unreachable(arg.hir_id, arg.span, \"expression\");\n                 }\n \n                 let is_closure = match arg.node {\n@@ -3340,7 +3337,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ret_coercion.borrow_mut()\n                     .coerce(self,\n                             &self.cause(return_expr.span,\n-                                        ObligationCauseCode::ReturnType(return_expr.id)),\n+                                        ObligationCauseCode::ReturnType(return_expr.hir_id)),\n                             return_expr,\n                             return_expr_ty);\n     }\n@@ -3511,13 +3508,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         // Save the index of all fields regardless of their visibility in case\n                         // of error recovery.\n-                        self.write_field_index(expr.id, index);\n+                        self.write_field_index(expr.hir_id, index);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n                             let adjustments = autoderef.adjust_steps(self, needs);\n                             self.apply_adjustments(base, adjustments);\n                             autoderef.finalize(self);\n \n-                            self.tcx.check_stability(field.did, Some(expr.id), expr.span);\n+                            self.tcx.check_stability(field.did, Some(expr.hir_id), expr.span);\n                             return field_ty;\n                         }\n                         private_candidate = Some((base_def.did, field_ty));\n@@ -3532,7 +3529,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 self.apply_adjustments(base, adjustments);\n                                 autoderef.finalize(self);\n \n-                                self.write_field_index(expr.id, index);\n+                                self.write_field_index(expr.hir_id, index);\n                                 return field_ty;\n                             }\n                         }\n@@ -3549,31 +3546,33 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                            \"field `{}` of struct `{}` is private\",\n                                            field, struct_path);\n             // Also check if an accessible method exists, which is often what is meant.\n-            if self.method_exists(field, expr_t, expr.id, false) && !self.expr_in_place(expr.id) {\n+            if self.method_exists(field, expr_t, expr.hir_id, false)\n+                && !self.expr_in_place(expr.hir_id)\n+            {\n                 self.suggest_method_call(\n                     &mut err,\n                     &format!(\"a method `{}` also exists, call it with parentheses\", field),\n                     field,\n                     expr_t,\n-                    expr.id,\n+                    expr.hir_id,\n                 );\n             }\n             err.emit();\n             field_ty\n         } else if field.name == keywords::Invalid.name() {\n             self.tcx().types.err\n-        } else if self.method_exists(field, expr_t, expr.id, true) {\n+        } else if self.method_exists(field, expr_t, expr.hir_id, true) {\n             let mut err = type_error_struct!(self.tcx().sess, field.span, expr_t, E0615,\n                                \"attempted to take value of method `{}` on type `{}`\",\n                                field, expr_t);\n \n-            if !self.expr_in_place(expr.id) {\n+            if !self.expr_in_place(expr.hir_id) {\n                 self.suggest_method_call(\n                     &mut err,\n                     \"use parentheses to call the method\",\n                     field,\n                     expr_t,\n-                    expr.id\n+                    expr.hir_id\n                 );\n             } else {\n                 err.help(\"methods are immutable and cannot be assigned to\");\n@@ -3613,7 +3612,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         ) {\n                             let base = self.tcx.sess.source_map()\n                                 .span_to_snippet(base.span)\n-                                .unwrap_or_else(|_| self.tcx.hir().node_to_pretty_string(base.id));\n+                                .unwrap_or_else(|_|\n+                                    self.tcx.hir().hir_to_pretty_string(base.hir_id));\n                             let help = \"instead of using tuple indexing, use array indexing\";\n                             let suggestion = format!(\"{}[{}]\", base, field);\n                             let applicability = if len < user_index {\n@@ -3629,7 +3629,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::RawPtr(..) => {\n                         let base = self.tcx.sess.source_map()\n                             .span_to_snippet(base.span)\n-                            .unwrap_or_else(|_| self.tcx.hir().node_to_pretty_string(base.id));\n+                            .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n                         let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n                         let suggestion = format!(\"(*{}).{}\", base, field);\n                         err.span_suggestion(\n@@ -3754,7 +3754,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_struct_fields(&self,\n                                 adt_ty: Ty<'tcx>,\n                                 expected: Expectation<'tcx>,\n-                                expr_id: ast::NodeId,\n+                                expr_id: hir::HirId,\n                                 span: Span,\n                                 variant: &'tcx ty::VariantDef,\n                                 ast_fields: &'gcx [hir::Field],\n@@ -3787,7 +3787,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let ident = tcx.adjust_ident(field.ident, variant.did, self.body_id).0;\n             let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n                 seen_fields.insert(ident, field.span);\n-                self.write_field_index(field.id, i);\n+                self.write_field_index(field.hir_id, i);\n \n                 // We don't look at stability attributes on\n                 // struct-like enums (yet...), but it's definitely not\n@@ -3875,13 +3875,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn check_struct_path(&self,\n                              qpath: &QPath,\n-                             node_id: ast::NodeId)\n+                             hir_id: hir::HirId)\n                              -> Option<(&'tcx ty::VariantDef,  Ty<'tcx>)> {\n         let path_span = match *qpath {\n             QPath::Resolved(_, ref path) => path.span,\n             QPath::TypeRelative(ref qself, _) => qself.span\n         };\n-        let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, node_id);\n+        let (def, ty) = self.finish_resolving_struct_path(qpath, path_span, hir_id);\n         let variant = match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n@@ -3909,7 +3909,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((variant, did, substs)) = variant {\n             debug!(\"check_struct_path: did={:?} substs={:?}\", did, substs);\n-            let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n             self.write_user_type_annotation_from_substs(hir_id, did, substs, None);\n \n             // Check bounds on type arguments used in the path.\n@@ -3938,7 +3937,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         // Find the relevant variant\n         let (variant, adt_ty) =\n-            if let Some(variant_ty) = self.check_struct_path(qpath, expr.id) {\n+            if let Some(variant_ty) = self.check_struct_path(qpath, expr.hir_id) {\n                 variant_ty\n             } else {\n                 self.check_struct_fields_on_error(fields, base_expr);\n@@ -3958,7 +3957,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       adt.variant_descr());\n         }\n \n-        let error_happened = self.check_expr_struct_fields(adt_ty, expected, expr.id, path_span,\n+        let error_happened = self.check_expr_struct_fields(adt_ty, expected, expr.hir_id, path_span,\n                                                            variant, fields, base_expr.is_none());\n         if let &Some(ref base_expr) = base_expr {\n             // If check_expr_struct_fields hit an error, do not attempt to populate\n@@ -4007,7 +4006,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                expr, expected);\n \n         // Warn for expressions after diverging siblings.\n-        self.warn_if_unreachable(expr.id, expr.span, \"expression\");\n+        self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\");\n \n         // Hide the outer diverging and has_errors flags.\n         let old_diverges = self.diverges.get();\n@@ -4023,7 +4022,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ExprKind::Loop(..) | ExprKind::While(..) |\n             ExprKind::If(..) | ExprKind::Match(..) => {}\n \n-            _ => self.warn_if_unreachable(expr.id, expr.span, \"expression\")\n+            _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\")\n         }\n \n         // Any expression that produces a value of type `!` must have diverged\n@@ -4040,7 +4039,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(self.diverges.get() | old_diverges);\n         self.has_errors.set(self.has_errors.get() | old_has_errors);\n \n-        debug!(\"type of {} is...\", self.tcx.hir().node_to_string(expr.id));\n+        debug!(\"type of {} is...\", self.tcx.hir().hir_to_string(expr.hir_id));\n         debug!(\"... {:?}, expected is {:?}\", ty, expected);\n \n         ty\n@@ -4060,7 +4059,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         let tcx = self.tcx;\n-        let id = expr.id;\n+        let id = expr.hir_id;\n         match expr.node {\n             ExprKind::Box(ref subexpr) => {\n                 let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n@@ -4192,7 +4191,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             ExprKind::Path(ref qpath) => {\n-                let (def, opt_ty, segs) = self.resolve_ty_and_def_ufcs(qpath, expr.id, expr.span);\n+                let (def, opt_ty, segs) = self.resolve_ty_and_def_ufcs(qpath, expr.hir_id,\n+                    expr.span);\n                 let ty = match def {\n                     Def::Err => {\n                         self.set_tainted_by_errors();\n@@ -4257,6 +4257,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::Break(destination, ref expr_opt) => {\n                 if let Ok(target_id) = destination.target_id {\n+                    let target_id = tcx.hir().node_to_hir_id(target_id);\n                     let (e_ty, cause);\n                     if let Some(ref e) = *expr_opt {\n                         // If this is a break with a value, we need to type-check\n@@ -4362,7 +4363,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         *self.ret_coercion_span.borrow_mut() = Some(expr.span);\n                     }\n                     let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n-                    if let Some((fn_decl, _)) = self.get_fn_decl(expr.id) {\n+                    if let Some((fn_decl, _)) = self.get_fn_decl(expr.hir_id) {\n                         coercion.coerce_forced_unit(\n                             self,\n                             &cause,\n@@ -4424,7 +4425,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     may_break: false,  // Will get updated if/when we find a `break`.\n                 };\n \n-                let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n+                let (ctxt, ()) = self.with_breakable_ctxt(expr.hir_id, ctxt, || {\n                     self.check_expr_has_type_or_error(&cond, tcx.types.bool);\n                     let cond_diverging = self.diverges.get();\n                     self.check_block_no_value(&body);\n@@ -4460,7 +4461,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     may_break: false, // Will get updated if/when we find a `break`.\n                 };\n \n-                let (ctxt, ()) = self.with_breakable_ctxt(expr.id, ctxt, || {\n+                let (ctxt, ()) = self.with_breakable_ctxt(expr.hir_id, ctxt, || {\n                     self.check_block_no_value(&body);\n                 });\n \n@@ -4717,7 +4718,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn finish_resolving_struct_path(&self,\n                                     qpath: &QPath,\n                                     path_span: Span,\n-                                    node_id: ast::NodeId)\n+                                    hir_id: hir::HirId)\n                                     -> (Def, Ty<'tcx>)\n     {\n         match *qpath {\n@@ -4734,11 +4735,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 } else {\n                     Def::Err\n                 };\n-                let (ty, def) = AstConv::associated_path_to_ty(self, node_id, path_span,\n+                let (ty, def) = AstConv::associated_path_to_ty(self, hir_id, path_span,\n                                                                ty, def, segment, true);\n \n                 // Write back the new resolution.\n-                let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n                 self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, def);\n \n                 (def, ty)\n@@ -4750,11 +4750,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// definition. The newly resolved definition is written into `type_dependent_defs`.\n     pub fn resolve_ty_and_def_ufcs<'b>(&self,\n                                        qpath: &'b QPath,\n-                                       node_id: ast::NodeId,\n+                                       hir_id: hir::HirId,\n                                        span: Span)\n                                        -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n-        debug!(\"resolve_ty_and_def_ufcs: qpath={:?} node_id={:?} span={:?}\", qpath, node_id, span);\n+        debug!(\"resolve_ty_and_def_ufcs: qpath={:?} hir_id={:?} span={:?}\", qpath, hir_id, span);\n         let (ty, qself, item_segment) = match *qpath {\n             QPath::Resolved(ref opt_qself, ref path) => {\n                 return (path.def,\n@@ -4765,14 +4765,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (self.to_ty(qself), qself, segment)\n             }\n         };\n-        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n         if let Some(cached_def) = self.tables.borrow().type_dependent_defs().get(hir_id) {\n             // Return directly on cache hit. This is useful to avoid doubly reporting\n             // errors with default match binding modes. See #44614.\n             return (*cached_def, Some(ty), slice::from_ref(&**item_segment))\n         }\n         let item_name = item_segment.ident;\n-        let def = match self.resolve_ufcs(span, item_name, ty, node_id) {\n+        let def = match self.resolve_ufcs(span, item_name, ty, hir_id) {\n             Ok(def) => def,\n             Err(error) => {\n                 let def = match error {\n@@ -4854,7 +4853,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::StmtKind::Local(..) | hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n         }\n \n-        self.warn_if_unreachable(stmt.id, stmt.span, \"statement\");\n+        self.warn_if_unreachable(stmt.hir_id, stmt.span, \"statement\");\n \n         // Hide the outer diverging and `has_errors` flags.\n         let old_diverges = self.diverges.get();\n@@ -4936,7 +4935,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             may_break: false,\n         };\n \n-        let (ctxt, ()) = self.with_breakable_ctxt(blk.id, ctxt, || {\n+        let (ctxt, ()) = self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n             for s in &blk.stmts {\n                 self.check_stmt(s);\n             }\n@@ -4946,12 +4945,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n \n             let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-            let ctxt = enclosing_breakables.find_breakable(blk.id);\n+            let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n             let coerce = ctxt.coerce.as_mut().unwrap();\n             if let Some(tail_expr_ty) = tail_expr_ty {\n                 let tail_expr = tail_expr.unwrap();\n                 let cause = self.cause(tail_expr.span,\n-                                       ObligationCauseCode::BlockTailExpression(blk.id));\n+                                       ObligationCauseCode::BlockTailExpression(blk.hir_id));\n                 coerce.coerce(self,\n                               &cause,\n                               tail_expr,\n@@ -4975,9 +4974,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // that highlight errors inline.\n                     let mut sp = blk.span;\n                     let mut fn_span = None;\n-                    if let Some((decl, ident)) = self.get_parent_fn_decl(blk.id) {\n+                    let blk_node_id = self.tcx.hir().hir_to_node_id(blk.hir_id);\n+                    if let Some((decl, ident)) = self.get_parent_fn_decl(blk_node_id) {\n                         let ret_sp = decl.output.span();\n-                        if let Some(block_sp) = self.parent_item_span(blk.id) {\n+                        if let Some(block_sp) = self.parent_item_span(blk_node_id) {\n                             // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n                             // output would otherwise be incorrect and even misleading. Make sure\n                             // the span we're aiming at correspond to a `fn` body.\n@@ -5067,13 +5067,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Given a `NodeId`, return the `FnDecl` of the method it is enclosed by and whether a\n+    /// Given a `HirId`, return the `FnDecl` of the method it is enclosed by and whether a\n     /// suggestion can be made, `None` otherwise.\n-    pub fn get_fn_decl(&self, blk_id: ast::NodeId) -> Option<(hir::FnDecl, bool)> {\n+    pub fn get_fn_decl(&self, blk_id: hir::HirId) -> Option<(hir::FnDecl, bool)> {\n         // Get enclosing Fn, if it is a function or a trait method, unless there's a `loop` or\n         // `while` before reaching it, as block tail returns are not available in them.\n         self.tcx.hir().get_return_block(blk_id).and_then(|blk_id| {\n-            let parent = self.tcx.hir().get(blk_id);\n+            let parent = self.tcx.hir().get_by_hir_id(blk_id);\n             self.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n         })\n     }\n@@ -5090,7 +5090,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         cause_span: Span,\n-        blk_id: ast::NodeId,\n+        blk_id: hir::HirId,\n     ) -> bool {\n         self.suggest_missing_semicolon(err, expression, expected, cause_span);\n         let mut pointing_at_return_type = false;\n@@ -5303,14 +5303,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   self_ty: Option<Ty<'tcx>>,\n                                   def: Def,\n                                   span: Span,\n-                                  node_id: ast::NodeId)\n+                                  hir_id: hir::HirId)\n                                   -> (Ty<'tcx>, Def) {\n         debug!(\n-            \"instantiate_value_path(segments={:?}, self_ty={:?}, def={:?}, node_id={})\",\n+            \"instantiate_value_path(segments={:?}, self_ty={:?}, def={:?}, hir_id={})\",\n             segments,\n             self_ty,\n             def,\n-            node_id,\n+            hir_id,\n         );\n \n         let tcx = self.tcx;\n@@ -5380,7 +5380,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Local(nid) | Def::Upvar(nid, ..) => {\n                 let ty = self.local_ty(span, nid).decl_ty;\n                 let ty = self.normalize_associated_types_in(span, &ty);\n-                self.write_ty(tcx.hir().node_to_hir_id(node_id), ty);\n+                self.write_ty(hir_id, ty);\n                 return (ty, def);\n             }\n             _ => {}\n@@ -5532,7 +5532,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(!ty.has_escaping_bound_vars());\n \n         // First, store the \"user substs\" for later.\n-        let hir_id = tcx.hir().node_to_hir_id(node_id);\n         self.write_user_type_annotation_from_substs(hir_id, def_id, substs, user_self_ty);\n \n         // Add all the obligations that are required, substituting and\n@@ -5566,10 +5565,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        self.check_rustc_args_require_const(def_id, node_id, span);\n+        self.check_rustc_args_require_const(def_id, hir_id, span);\n \n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n-               node_id,\n+               hir_id,\n                ty_substituted);\n         self.write_substs(hir_id, substs);\n \n@@ -5578,7 +5577,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn check_rustc_args_require_const(&self,\n                                       def_id: DefId,\n-                                      node_id: ast::NodeId,\n+                                      hir_id: hir::HirId,\n                                       span: Span) {\n         // We're only interested in functions tagged with\n         // #[rustc_args_required_const], so ignore anything that's not.\n@@ -5588,9 +5587,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // If our calling expression is indeed the function itself, we're good!\n         // If not, generate an error that this can only be called directly.\n-        if let Node::Expr(expr) = self.tcx.hir().get(self.tcx.hir().get_parent_node(node_id)) {\n+        if let Node::Expr(expr) = self.tcx.hir().get_by_hir_id(\n+            self.tcx.hir().get_parent_node_by_hir_id(hir_id))\n+        {\n             if let ExprKind::Call(ref callee, ..) = expr.node {\n-                if callee.id == node_id {\n+                if callee.hir_id == hir_id {\n                     return\n                 }\n             }\n@@ -5618,7 +5619,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn with_breakable_ctxt<F: FnOnce() -> R, R>(&self, id: ast::NodeId,\n+    fn with_breakable_ctxt<F: FnOnce() -> R, R>(&self, id: hir::HirId,\n                                                 ctxt: BreakableCtxt<'gcx, 'tcx>, f: F)\n                                                 -> (BreakableCtxt<'gcx, 'tcx>, R) {\n         let index;\n@@ -5655,22 +5656,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Returns `true` if an expression is contained inside the LHS of an assignment expression.\n-    fn expr_in_place(&self, mut expr_id: ast::NodeId) -> bool {\n+    fn expr_in_place(&self, mut expr_id: hir::HirId) -> bool {\n         let mut contained_in_place = false;\n \n         while let hir::Node::Expr(parent_expr) =\n-            self.tcx.hir().get(self.tcx.hir().get_parent_node(expr_id))\n+            self.tcx.hir().get_by_hir_id(self.tcx.hir().get_parent_node_by_hir_id(expr_id))\n         {\n             match &parent_expr.node {\n                 hir::ExprKind::Assign(lhs, ..) | hir::ExprKind::AssignOp(_, lhs, ..) => {\n-                    if lhs.id == expr_id {\n+                    if lhs.hir_id == expr_id {\n                         contained_in_place = true;\n                         break;\n                     }\n                 }\n                 _ => (),\n             }\n-            expr_id = parent_expr.id;\n+            expr_id = parent_expr.hir_id;\n         }\n \n         contained_in_place"}, {"sha": "9d883b22214f7a3163e37fcb60cd89b6d7378130", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -51,8 +51,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         let tcx = self.tcx;\n \n-        debug!(\"check_binop(expr.id={}, expr={:?}, op={:?}, lhs_expr={:?}, rhs_expr={:?})\",\n-               expr.id,\n+        debug!(\"check_binop(expr.hir_id={}, expr={:?}, op={:?}, lhs_expr={:?}, rhs_expr={:?})\",\n+               expr.hir_id,\n                expr,\n                op,\n                lhs_expr,\n@@ -150,8 +150,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               is_assign: IsAssign)\n                               -> (Ty<'tcx>, Ty<'tcx>, Ty<'tcx>)\n     {\n-        debug!(\"check_overloaded_binop(expr.id={}, op={:?}, is_assign={:?})\",\n-               expr.id,\n+        debug!(\"check_overloaded_binop(expr.hir_id={}, op={:?}, is_assign={:?})\",\n+               expr.hir_id,\n                op,\n                is_assign);\n "}, {"sha": "bf4df19556d0277736601ee70b26bf739cb01db7", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -90,7 +90,6 @@ use rustc_data_structures::sync::Lrc;\n use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n-use syntax::ast;\n use syntax_pos::Span;\n \n // a variation on try that just returns unit\n@@ -163,7 +162,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// rest of type check and because sometimes we need type\n     /// inference to have completed before we can determine which\n     /// constraints to add.\n-    pub fn regionck_fn(&self, fn_id: ast::NodeId, body: &'gcx hir::Body) {\n+    pub fn regionck_fn(&self, fn_id: hir::HirId, body: &'gcx hir::Body) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let subject = self.tcx.hir().body_owner_def_id(body.id());\n         let hir_id = body.value.hir_id;\n@@ -176,9 +175,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         );\n \n         if self.err_count_since_creation() == 0 {\n-            let fn_hir_id = self.tcx.hir().node_to_hir_id(fn_id);\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_hir_id, body, self.tcx.hir().span_by_hir_id(fn_hir_id));\n+            rcx.visit_fn_body(fn_id, body, self.tcx.hir().span_by_hir_id(fn_id));\n         }\n \n         rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));\n@@ -696,8 +694,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n             hir::ExprKind::Ret(Some(ref ret_expr)) => {\n                 let call_site_scope = self.call_site_scope;\n                 debug!(\n-                    \"visit_expr ExprKind::Ret ret_expr.id {} call_site_scope: {:?}\",\n-                    ret_expr.id, call_site_scope\n+                    \"visit_expr ExprKind::Ret ret_expr.hir_id {} call_site_scope: {:?}\",\n+                    ret_expr.hir_id, call_site_scope\n                 );\n                 let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope.unwrap()));\n                 self.type_of_node_must_outlive("}, {"sha": "bf6f4482e746d48807ad994dc655c281b9a936fd", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n             let body = self.fcx.tcx.hir().body(body_id);\n             self.visit_body(body);\n             self.fcx\n-                .analyze_closure(expr.id, expr.hir_id, expr.span, body, cc);\n+                .analyze_closure(expr.hir_id, expr.span, body, cc);\n         }\n \n         intravisit::walk_expr(self, expr);\n@@ -77,7 +77,6 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn analyze_closure(\n         &self,\n-        closure_node_id: ast::NodeId,\n         closure_hir_id: hir::HirId,\n         span: Span,\n         body: &hir::Body,\n@@ -89,7 +88,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\n             \"analyze_closure(id={:?}, body.id={:?})\",\n-            closure_node_id,\n+            closure_hir_id,\n             body.id()\n         );\n \n@@ -105,7 +104,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 span_bug!(\n                     span,\n                     \"type of closure expr {:?} is not a closure {:?}\",\n-                    closure_node_id,\n+                    closure_hir_id,\n                     t\n                 );\n             }\n@@ -121,6 +120,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             None\n         };\n \n+        let closure_node_id = self.tcx.hir().hir_to_node_id(closure_hir_id);\n+\n         self.tcx.with_freevars(closure_node_id, |freevars| {\n             let mut freevar_list: Vec<ty::UpvarId> = Vec::with_capacity(freevars.len());\n             for freevar in freevars {\n@@ -582,7 +583,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n     fn consume(\n         &mut self,\n-        _consume_id: ast::NodeId,\n+        _consume_id: hir::HirId,\n         _consume_span: Span,\n         cmt: &mc::cmt_<'tcx>,\n         mode: euv::ConsumeMode,\n@@ -611,7 +612,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n \n     fn borrow(\n         &mut self,\n-        borrow_id: ast::NodeId,\n+        borrow_id: hir::HirId,\n         _borrow_span: Span,\n         cmt: &mc::cmt_<'tcx>,\n         _loan_region: ty::Region<'tcx>,\n@@ -638,7 +639,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n \n     fn mutate(\n         &mut self,\n-        _assignment_id: ast::NodeId,\n+        _assignment_id: hir::HirId,\n         _assignment_span: Span,\n         assignee_cmt: &mc::cmt_<'tcx>,\n         _mode: euv::MutateMode,"}, {"sha": "7c1283a6d210866dd561e58ac0f2616f383a27a6", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -243,11 +243,11 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n             }\n             hir::ExprKind::Struct(_, ref fields, _) => {\n                 for field in fields {\n-                    self.visit_field_id(field.id);\n+                    self.visit_field_id(field.hir_id);\n                 }\n             }\n             hir::ExprKind::Field(..) => {\n-                self.visit_field_id(e.id);\n+                self.visit_field_id(e.hir_id);\n             }\n             _ => {}\n         }\n@@ -273,7 +273,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n             }\n             hir::PatKind::Struct(_, ref fields, _) => {\n                 for field in fields {\n-                    self.visit_field_id(field.node.id);\n+                    self.visit_field_id(field.node.hir_id);\n                 }\n             }\n             _ => {}\n@@ -590,8 +590,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_field_id(&mut self, node_id: ast::NodeId) {\n-        let hir_id = self.tcx().hir().node_to_hir_id(node_id);\n+    fn visit_field_id(&mut self, hir_id: hir::HirId) {\n         if let Some(index) = self.fcx\n             .tables\n             .borrow_mut()"}, {"sha": "2153582819c6f8a369195c247ad6715f90c8318e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -129,12 +129,12 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n                 hir::GenericParamKind::Type {\n                     default: Some(_), ..\n                 } => {\n-                    let def_id = self.tcx.hir().local_def_id(param.id);\n+                    let def_id = self.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n                     self.tcx.type_of(def_id);\n                 }\n                 hir::GenericParamKind::Type { .. } => {}\n                 hir::GenericParamKind::Const { .. } => {\n-                    let def_id = self.tcx.hir().local_def_id(param.id);\n+                    let def_id = self.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n                     self.tcx.type_of(def_id);\n                 }\n             }\n@@ -144,7 +144,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if let hir::ExprKind::Closure(..) = expr.node {\n-            let def_id = self.tcx.hir().local_def_id(expr.id);\n+            let def_id = self.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n             self.tcx.generics_of(def_id);\n             self.tcx.type_of(def_id);\n         }\n@@ -322,9 +322,10 @@ fn type_param_predicates<'a, 'tcx>(\n     };\n \n     let icx = ItemCtxt::new(tcx, item_def_id);\n+    let param_hir_id = tcx.hir().node_to_hir_id(param_id);\n     Lrc::make_mut(&mut result)\n         .predicates\n-        .extend(icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty,\n+        .extend(icx.type_parameter_bounds_in_generics(ast_generics, param_hir_id, ty,\n             OnlySelfBounds(true)));\n     result\n }\n@@ -337,15 +338,15 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n     fn type_parameter_bounds_in_generics(\n         &self,\n         ast_generics: &hir::Generics,\n-        param_id: ast::NodeId,\n+        param_id: hir::HirId,\n         ty: Ty<'tcx>,\n         only_self_bounds: OnlySelfBounds,\n     ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n         let from_ty_params = ast_generics\n             .params\n             .iter()\n             .filter_map(|param| match param.kind {\n-                GenericParamKind::Type { .. } if param.id == param_id => Some(&param.bounds),\n+                GenericParamKind::Type { .. } if param.hir_id == param_id => Some(&param.bounds),\n                 _ => None,\n             })\n             .flat_map(|bounds| bounds.iter())\n@@ -382,12 +383,12 @@ impl<'a, 'tcx> ItemCtxt<'a, 'tcx> {\n fn is_param<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ast_ty: &hir::Ty,\n-    param_id: ast::NodeId,\n+    param_id: hir::HirId,\n ) -> bool {\n     if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n         match path.def {\n             Def::SelfTy(Some(def_id), None) | Def::TyParam(def_id) => {\n-                def_id == tcx.hir().local_def_id(param_id)\n+                def_id == tcx.hir().local_def_id_from_hir_id(param_id)\n             }\n             _ => false,\n         }\n@@ -721,7 +722,7 @@ fn super_predicates_of<'a, 'tcx>(\n     // as one of its \"superpredicates\".\n     let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n     let superbounds2 = icx.type_parameter_bounds_in_generics(\n-        generics, item.id, self_param_ty, OnlySelfBounds(!is_trait_alias));\n+        generics, item.hir_id, self_param_ty, OnlySelfBounds(!is_trait_alias));\n \n     // Combine the two lists to form the complete set of superbounds:\n     let superbounds: Vec<_> = superbounds1.into_iter().chain(superbounds2).collect();\n@@ -987,7 +988,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n             .map(|(i, param)| ty::GenericParamDef {\n                 name: param.name.ident().as_interned_str(),\n                 index: own_start + i as u32,\n-                def_id: tcx.hir().local_def_id(param.id),\n+                def_id: tcx.hir().local_def_id_from_hir_id(param.hir_id),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind: ty::GenericParamDefKind::Lifetime,\n             }),\n@@ -1018,9 +1019,9 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n \n                     if !allow_defaults && default.is_some() {\n                         if !tcx.features().default_type_parameter_fallback {\n-                            tcx.lint_node(\n+                            tcx.lint_hir(\n                                 lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n-                                param.id,\n+                                param.hir_id,\n                                 param.span,\n                                 &format!(\n                                     \"defaults for type parameters are only allowed in \\\n@@ -1033,7 +1034,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n                     let ty_param = ty::GenericParamDef {\n                         index: type_start + i as u32,\n                         name: param.name.ident().as_interned_str(),\n-                        def_id: tcx.hir().local_def_id(param.id),\n+                        def_id: tcx.hir().local_def_id_from_hir_id(param.hir_id),\n                         pure_wrt_drop: param.pure_wrt_drop,\n                         kind: ty::GenericParamDefKind::Type {\n                             has_default: default.is_some(),\n@@ -1704,8 +1705,7 @@ fn early_bound_lifetimes_from_generics<'a, 'tcx>(\n         .iter()\n         .filter(move |param| match param.kind {\n             GenericParamKind::Lifetime { .. } => {\n-                let hir_id = tcx.hir().node_to_hir_id(param.id);\n-                !tcx.is_late_bound(hir_id)\n+                !tcx.is_late_bound(param.hir_id)\n             }\n             _ => false,\n         })\n@@ -1942,7 +1942,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n     let mut index = parent_count + has_own_self as u32;\n     for param in early_bound_lifetimes_from_generics(tcx, ast_generics) {\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            def_id: tcx.hir().local_def_id(param.id),\n+            def_id: tcx.hir().local_def_id_from_hir_id(param.hir_id),\n             index,\n             name: param.name.ident().as_interned_str(),\n         }));\n@@ -2224,7 +2224,7 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n                        &format!(\n                            \"use of SIMD type `{}` in FFI is highly experimental and \\\n                             may result in invalid code\",\n-                           tcx.hir().node_to_pretty_string(ast_ty.id)\n+                           tcx.hir().hir_to_pretty_string(ast_ty.hir_id)\n                        ),\n                    )\n                    .help(\"add #![feature(simd_ffi)] to the crate attributes to enable\")"}, {"sha": "bd9b4fecbecc1acde9d39c8fc7a48f0abc46e394", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -371,8 +371,8 @@ pub fn hir_ty_to_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, hir_ty: &hir::Ty) ->\n     // In case there are any projections etc, find the \"environment\"\n     // def-id that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n-    let env_node_id = tcx.hir().get_parent(hir_ty.id);\n-    let env_def_id = tcx.hir().local_def_id(env_node_id);\n+    let env_node_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n+    let env_def_id = tcx.hir().local_def_id_from_hir_id(env_node_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n \n     astconv::AstConv::ast_ty_to_ty(&item_cx, hir_ty)"}, {"sha": "2c2959aec9fcf7d97e95833fa51133970e1d7e27", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -1221,7 +1221,7 @@ impl Lifetime {\n \n impl Clean<Lifetime> for hir::Lifetime {\n     fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Lifetime {\n-        if self.id != ast::DUMMY_NODE_ID {\n+        if self.hir_id != hir::DUMMY_HIR_ID {\n             let def = cx.tcx.named_region(self.hir_id);\n             match def {\n                 Some(rl::Region::EarlyBound(_, node_id, _)) |\n@@ -1513,15 +1513,15 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n             }\n             hir::GenericParamKind::Type { ref default, synthetic } => {\n                 (self.name.ident().name.clean(cx), GenericParamDefKind::Type {\n-                    did: cx.tcx.hir().local_def_id(self.id),\n+                    did: cx.tcx.hir().local_def_id_from_hir_id(self.hir_id),\n                     bounds: self.bounds.clean(cx),\n                     default: default.clean(cx),\n                     synthetic: synthetic,\n                 })\n             }\n             hir::GenericParamKind::Const { ref ty } => {\n                 (self.name.ident().name.clean(cx), GenericParamDefKind::Const {\n-                    did: cx.tcx.hir().local_def_id(self.id),\n+                    did: cx.tcx.hir().local_def_id_from_hir_id(self.hir_id),\n                     ty: ty.clean(cx),\n                 })\n             }\n@@ -1988,7 +1988,7 @@ impl Clean<bool> for hir::IsAuto {\n \n impl Clean<Type> for hir::TraitRef {\n     fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Type {\n-        resolve_type(cx, self.path.clean(cx), self.ref_id)\n+        resolve_type(cx, self.path.clean(cx), self.hir_ref_id)\n     }\n }\n \n@@ -2599,15 +2599,16 @@ impl Clean<Type> for hir::Ty {\n                                     if let Some(lt) = lifetime.cloned() {\n                                         if !lt.is_elided() {\n                                             let lt_def_id =\n-                                                cx.tcx.hir().local_def_id(param.id);\n+                                                cx.tcx.hir().local_def_id_from_hir_id(param.hir_id);\n                                             lt_substs.insert(lt_def_id, lt.clean(cx));\n                                         }\n                                     }\n                                     indices.lifetimes += 1;\n                                 }\n                                 hir::GenericParamKind::Type { ref default, .. } => {\n                                     let ty_param_def =\n-                                        Def::TyParam(cx.tcx.hir().local_def_id(param.id));\n+                                        Def::TyParam(\n+                                            cx.tcx.hir().local_def_id_from_hir_id(param.hir_id));\n                                     let mut j = 0;\n                                     let type_ = generic_args.args.iter().find_map(|arg| {\n                                         match arg {\n@@ -2631,7 +2632,8 @@ impl Clean<Type> for hir::Ty {\n                                 }\n                                 hir::GenericParamKind::Const { .. } => {\n                                     let const_param_def =\n-                                        Def::ConstParam(cx.tcx.hir().local_def_id(param.id));\n+                                        Def::ConstParam(\n+                                            cx.tcx.hir().local_def_id_from_hir_id(param.hir_id));\n                                     let mut j = 0;\n                                     let const_ = generic_args.args.iter().find_map(|arg| {\n                                         match arg {\n@@ -2656,7 +2658,7 @@ impl Clean<Type> for hir::Ty {\n                     });\n                     return cx.enter_alias(ty_substs, lt_substs, const_substs, || ty.clean(cx));\n                 }\n-                resolve_type(cx, path.clean(cx), self.id)\n+                resolve_type(cx, path.clean(cx), self.hir_id)\n             }\n             TyKind::Path(hir::QPath::Resolved(Some(ref qself), ref p)) => {\n                 let mut segments: Vec<_> = p.segments.clone().into();\n@@ -2669,7 +2671,7 @@ impl Clean<Type> for hir::Ty {\n                 Type::QPath {\n                     name: p.segments.last().expect(\"segments were empty\").ident.name.clean(cx),\n                     self_type: box qself.clean(cx),\n-                    trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n+                    trait_: box resolve_type(cx, trait_path.clean(cx), self.hir_id)\n                 }\n             }\n             TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n@@ -2686,7 +2688,7 @@ impl Clean<Type> for hir::Ty {\n                 Type::QPath {\n                     name: segment.ident.name.clean(cx),\n                     self_type: box qself.clean(cx),\n-                    trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n+                    trait_: box resolve_type(cx, trait_path.clean(cx), self.hir_id)\n                 }\n             }\n             TyKind::TraitObject(ref bounds, ref lifetime) => {\n@@ -3909,8 +3911,8 @@ fn print_const_expr(cx: &DocContext<'_, '_, '_>, body: hir::BodyId) -> String {\n /// Given a type Path, resolve it to a Type using the TyCtxt\n fn resolve_type(cx: &DocContext<'_, '_, '_>,\n                 path: Path,\n-                id: ast::NodeId) -> Type {\n-    if id == ast::DUMMY_NODE_ID {\n+                id: hir::HirId) -> Type {\n+    if id == hir::DUMMY_HIR_ID {\n         debug!(\"resolve_type({:?})\", path);\n     } else {\n         debug!(\"resolve_type({:?},{:?})\", path, id);"}, {"sha": "226924c41c54137745f594fb9a55bcc114aac167", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -193,7 +193,6 @@ impl<'a, 'tcx, 'rcx> DocContext<'a, 'tcx, 'rcx> {\n         };\n \n         hir::Ty {\n-            id: ast::DUMMY_NODE_ID,\n             node: hir::TyKind::Path(hir::QPath::Resolved(None, P(new_path))),\n             span: DUMMY_SP,\n             hir_id: hir::DUMMY_HIR_ID,\n@@ -213,7 +212,6 @@ impl<'a, 'tcx, 'rcx> DocContext<'a, 'tcx, 'rcx> {\n                     };\n \n                     args.push(hir::GenericArg::Lifetime(hir::Lifetime {\n-                        id: ast::DUMMY_NODE_ID,\n                         hir_id: hir::DUMMY_HIR_ID,\n                         span: DUMMY_SP,\n                         name: hir::LifetimeName::Param(name),\n@@ -235,7 +233,6 @@ impl<'a, 'tcx, 'rcx> DocContext<'a, 'tcx, 'rcx> {\n     pub fn ty_param_to_ty(&self, param: ty::GenericParamDef) -> hir::Ty {\n         debug!(\"ty_param_to_ty({:?}) {:?}\", param, param.def_id);\n         hir::Ty {\n-            id: ast::DUMMY_NODE_ID,\n             node: hir::TyKind::Path(hir::QPath::Resolved(\n                 None,\n                 P(hir::Path {"}, {"sha": "8dad26f9292cd36b610064f4f05aac0591cc4f4f", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -868,7 +868,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n \n     fn visit_item(&mut self, item: &'hir hir::Item) {\n         let name = if let hir::ItemKind::Impl(.., ref ty, _) = item.node {\n-            self.map.node_to_pretty_string(ty.id)\n+            self.map.hir_to_pretty_string(ty.hir_id)\n         } else {\n             item.ident.to_string()\n         };"}, {"sha": "b791bfc11e01ad3f0e35e2f66c6e7ea99f93f67a", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea43c3c688980edd6f09a4cb632c9eb996c4f2af/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -66,13 +66,13 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         }\n     }\n \n-    fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n-        self.cx.tcx.hir().opt_local_def_id(id)\n+    fn stability(&self, id: hir::HirId) -> Option<attr::Stability> {\n+        self.cx.tcx.hir().opt_local_def_id_from_hir_id(id)\n             .and_then(|def_id| self.cx.tcx.lookup_stability(def_id)).cloned()\n     }\n \n-    fn deprecation(&self, id: ast::NodeId) -> Option<attr::Deprecation> {\n-        self.cx.tcx.hir().opt_local_def_id(id)\n+    fn deprecation(&self, id: hir::HirId) -> Option<attr::Deprecation> {\n+        self.cx.tcx.hir().opt_local_def_id_from_hir_id(id)\n             .and_then(|def_id| self.cx.tcx.lookup_deprecation(def_id))\n     }\n \n@@ -83,7 +83,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                                               krate.attrs.clone(),\n                                               Spanned { span: syntax_pos::DUMMY_SP,\n                                                         node: hir::VisibilityKind::Public },\n-                                              ast::CRATE_NODE_ID,\n+                                              hir::CRATE_HIR_ID,\n                                               &krate.module,\n                                               None);\n         // Attach the crate's exported macros to the top-level module:\n@@ -105,8 +105,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             struct_type,\n             name,\n             vis: item.vis.clone(),\n-            stab: self.stability(item.id),\n-            depr: self.deprecation(item.id),\n+            stab: self.stability(item.hir_id),\n+            depr: self.deprecation(item.hir_id),\n             attrs: item.attrs.clone(),\n             generics: generics.clone(),\n             fields: sd.fields().iter().cloned().collect(),\n@@ -124,8 +124,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             struct_type,\n             name,\n             vis: item.vis.clone(),\n-            stab: self.stability(item.id),\n-            depr: self.deprecation(item.id),\n+            stab: self.stability(item.hir_id),\n+            depr: self.deprecation(item.hir_id),\n             attrs: item.attrs.clone(),\n             generics: generics.clone(),\n             fields: sd.fields().iter().cloned().collect(),\n@@ -142,14 +142,14 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             variants: def.variants.iter().map(|v| Variant {\n                 name: v.node.ident.name,\n                 attrs: v.node.attrs.clone(),\n-                stab: self.stability(v.node.data.id()),\n-                depr: self.deprecation(v.node.data.id()),\n+                stab: self.stability(v.node.data.hir_id()),\n+                depr: self.deprecation(v.node.data.hir_id()),\n                 def: v.node.data.clone(),\n                 whence: v.span,\n             }).collect(),\n             vis: it.vis.clone(),\n-            stab: self.stability(it.id),\n-            depr: self.deprecation(it.id),\n+            stab: self.stability(it.hir_id),\n+            depr: self.deprecation(it.hir_id),\n             generics: params.clone(),\n             attrs: it.attrs.clone(),\n             id: it.id,\n@@ -207,16 +207,16 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     helpers,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n-                    stab: self.stability(item.id),\n-                    depr: self.deprecation(item.id),\n+                    stab: self.stability(item.hir_id),\n+                    depr: self.deprecation(item.hir_id),\n                 });\n             }\n             None => {\n                 om.fns.push(Function {\n                     id: item.id,\n                     vis: item.vis.clone(),\n-                    stab: self.stability(item.id),\n-                    depr: self.deprecation(item.id),\n+                    stab: self.stability(item.hir_id),\n+                    depr: self.deprecation(item.hir_id),\n                     attrs: item.attrs.clone(),\n                     decl: fd.clone(),\n                     name,\n@@ -230,7 +230,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n     }\n \n     pub fn visit_mod_contents(&mut self, span: Span, attrs: hir::HirVec<ast::Attribute>,\n-                              vis: hir::Visibility, id: ast::NodeId,\n+                              vis: hir::Visibility, id: hir::HirId,\n                               m: &hir::Mod,\n                               name: Option<ast::Name>) -> Module {\n         let mut om = Module::new(name);\n@@ -240,7 +240,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         om.vis = vis.clone();\n         om.stab = self.stability(id);\n         om.depr = self.deprecation(id);\n-        om.id = id;\n+        om.id = self.cx.tcx.hir().hir_to_node_id(id);\n         // Keep track of if there were any private modules in the path.\n         let orig_inside_public_path = self.inside_public_path;\n         self.inside_public_path &= vis.node.is_pub();\n@@ -460,7 +460,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 om.mods.push(self.visit_mod_contents(item.span,\n                                                      item.attrs.clone(),\n                                                      item.vis.clone(),\n-                                                     item.id,\n+                                                     item.hir_id,\n                                                      m,\n                                                      Some(ident.name)));\n             },\n@@ -481,8 +481,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis.clone(),\n-                    stab: self.stability(item.id),\n-                    depr: self.deprecation(item.id),\n+                    stab: self.stability(item.hir_id),\n+                    depr: self.deprecation(item.hir_id),\n                 };\n                 om.typedefs.push(t);\n             },\n@@ -494,8 +494,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis.clone(),\n-                    stab: self.stability(item.id),\n-                    depr: self.deprecation(item.id),\n+                    stab: self.stability(item.hir_id),\n+                    depr: self.deprecation(item.hir_id),\n                 };\n                 om.existentials.push(t);\n             },\n@@ -509,8 +509,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis.clone(),\n-                    stab: self.stability(item.id),\n-                    depr: self.deprecation(item.id),\n+                    stab: self.stability(item.hir_id),\n+                    depr: self.deprecation(item.hir_id),\n                 };\n                 om.statics.push(s);\n             },\n@@ -523,8 +523,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis.clone(),\n-                    stab: self.stability(item.id),\n-                    depr: self.deprecation(item.id),\n+                    stab: self.stability(item.hir_id),\n+                    depr: self.deprecation(item.hir_id),\n                 };\n                 om.constants.push(s);\n             },\n@@ -543,8 +543,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis.clone(),\n-                    stab: self.stability(item.id),\n-                    depr: self.deprecation(item.id),\n+                    stab: self.stability(item.hir_id),\n+                    depr: self.deprecation(item.hir_id),\n                 };\n                 om.traits.push(t);\n             },\n@@ -557,8 +557,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                     vis: item.vis.clone(),\n-                    stab: self.stability(item.id),\n-                    depr: self.deprecation(item.id),\n+                    stab: self.stability(item.hir_id),\n+                    depr: self.deprecation(item.hir_id),\n                 };\n                 om.trait_aliases.push(t);\n             },\n@@ -588,8 +588,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                         id: item.id,\n                         whence: item.span,\n                         vis: item.vis.clone(),\n-                        stab: self.stability(item.id),\n-                        depr: self.deprecation(item.id),\n+                        stab: self.stability(item.hir_id),\n+                        depr: self.deprecation(item.hir_id),\n                     };\n                     om.impls.push(i);\n                 }\n@@ -609,13 +609,14 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         let matchers = tts.chunks(4).map(|arm| arm[0].span()).collect();\n \n         Macro {\n-            def_id: self.cx.tcx.hir().local_def_id(def.id),\n+\n+            def_id: self.cx.tcx.hir().local_def_id_from_hir_id(def.hir_id),\n             attrs: def.attrs.clone(),\n             name: renamed.unwrap_or(def.name),\n             whence: def.span,\n             matchers,\n-            stab: self.stability(def.id),\n-            depr: self.deprecation(def.id),\n+            stab: self.stability(def.hir_id),\n+            depr: self.deprecation(def.hir_id),\n             imported_from: None,\n         }\n     }"}, {"sha": "7bc2e1d60d23a2f6a31d7a04d40171372d80b5b3", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=ea43c3c688980edd6f09a4cb632c9eb996c4f2af", "patch": "@@ -1 +1 @@\n-Subproject commit 1fac38088609747627b07807945224cf1ea642ca\n+Subproject commit 7bc2e1d60d23a2f6a31d7a04d40171372d80b5b3"}]}