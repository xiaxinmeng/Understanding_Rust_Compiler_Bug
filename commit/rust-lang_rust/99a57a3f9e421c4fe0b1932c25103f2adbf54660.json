{"sha": "99a57a3f9e421c4fe0b1932c25103f2adbf54660", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5YTU3YTNmOWU0MjFjNGZlMGIxOTMyYzI1MTAzZjJhZGJmNTQ2NjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-13T11:57:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-13T11:57:46Z"}, "message": "Auto merge of #1509 - samrat:fd-trait-fixes, r=RalfJung\n\nRemove lifetime from FileDescriptor trait\n\nAlso:\n- Type annotate `handles` declaration, instead of annotating every insert.\n- Add note about flush being unnecessary when writing to stderr\n\nAddresses comments in #1495 and #1497", "tree": {"sha": "c5c3ed0b0a462ceec549fe2471478ce16bee5368", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5c3ed0b0a462ceec549fe2471478ce16bee5368"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99a57a3f9e421c4fe0b1932c25103f2adbf54660", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99a57a3f9e421c4fe0b1932c25103f2adbf54660", "html_url": "https://github.com/rust-lang/rust/commit/99a57a3f9e421c4fe0b1932c25103f2adbf54660", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99a57a3f9e421c4fe0b1932c25103f2adbf54660/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bfb26d6cae6f535ac1034877635fc0cef87fe64", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bfb26d6cae6f535ac1034877635fc0cef87fe64", "html_url": "https://github.com/rust-lang/rust/commit/1bfb26d6cae6f535ac1034877635fc0cef87fe64"}, {"sha": "0c2506411700591f218c03dca19b47388bd80f60", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c2506411700591f218c03dca19b47388bd80f60", "html_url": "https://github.com/rust-lang/rust/commit/0c2506411700591f218c03dca19b47388bd80f60"}], "stats": {"total": 69, "additions": 35, "deletions": 34}, "files": [{"sha": "04bba6c33cdb654f3d4f20aa0622223ec05c2590", "filename": "src/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99a57a3f9e421c4fe0b1932c25103f2adbf54660/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a57a3f9e421c4fe0b1932c25103f2adbf54660/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=99a57a3f9e421c4fe0b1932c25103f2adbf54660", "patch": "@@ -249,7 +249,7 @@ pub struct Evaluator<'mir, 'tcx> {\n     /// Whether to enforce the validity invariant.\n     pub(crate) validate: bool,\n \n-    pub(crate) file_handler: shims::posix::FileHandler<'tcx>,\n+    pub(crate) file_handler: shims::posix::FileHandler,\n     pub(crate) dir_handler: shims::posix::DirHandler,\n \n     /// The temporary used for storing the argument of"}, {"sha": "06a8bf1cb02067389d7d3c89a6705575c37fe1ff", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/99a57a3f9e421c4fe0b1932c25103f2adbf54660/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a57a3f9e421c4fe0b1932c25103f2adbf54660/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=99a57a3f9e421c4fe0b1932c25103f2adbf54660", "patch": "@@ -22,67 +22,67 @@ struct FileHandle {\n     writable: bool,\n }\n \n-trait FileDescriptor<'tcx> : std::fmt::Debug {\n-    fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle>;\n+trait FileDescriptor : std::fmt::Debug {\n+    fn as_file_handle<'tcx>(&self) -> InterpResult<'tcx, &FileHandle>;\n \n-    fn read(&mut self, communicate_allowed: bool, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>>;\n-    fn write(&mut self, communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>>;\n-    fn seek(&mut self, communicate_allowed: bool, offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>>;\n+    fn read<'tcx>(&mut self, communicate_allowed: bool, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>>;\n+    fn write<'tcx>(&mut self, communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>>;\n+    fn seek<'tcx>(&mut self, communicate_allowed: bool, offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>>;\n }\n \n-impl<'tcx> FileDescriptor<'tcx> for FileHandle {\n-    fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle> {\n+impl FileDescriptor for FileHandle {\n+    fn as_file_handle<'tcx>(&self) -> InterpResult<'tcx, &FileHandle> {\n         Ok(&self)\n     }\n \n-    fn read(&mut self, communicate_allowed: bool, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn read<'tcx>(&mut self, communicate_allowed: bool, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n         assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n         Ok(self.file.read(bytes))\n     }\n \n-    fn write(&mut self, communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn write<'tcx>(&mut self, communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n         assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n         Ok(self.file.write(bytes))\n     }\n \n-    fn seek(&mut self, communicate_allowed: bool, offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+    fn seek<'tcx>(&mut self, communicate_allowed: bool, offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n         assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n         Ok(self.file.seek(offset))\n     }\n }\n \n-impl<'tcx> FileDescriptor<'tcx> for io::Stdin {\n-    fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle> {\n+impl FileDescriptor for io::Stdin {\n+    fn as_file_handle<'tcx>(&self) -> InterpResult<'tcx, &FileHandle> {\n         throw_unsup_format!(\"stdin cannot be used as FileHandle\");\n     }\n \n-    fn read(&mut self, communicate_allowed: bool, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn read<'tcx>(&mut self, communicate_allowed: bool, bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n         if !communicate_allowed {\n             // We want isolation mode to be deterministic, so we have to disallow all reads, even stdin.\n             helpers::isolation_error(\"read\")?;\n         }\n         Ok(Read::read(self, bytes))\n     }\n \n-    fn write(&mut self, _communicate_allowed: bool, _bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn write<'tcx>(&mut self, _communicate_allowed: bool, _bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n         throw_unsup_format!(\"cannot write to stdin\");\n     }\n \n-    fn seek(&mut self, _communicate_allowed: bool, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+    fn seek<'tcx>(&mut self, _communicate_allowed: bool, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n         throw_unsup_format!(\"cannot seek on stdin\");\n     }\n }\n \n-impl<'tcx> FileDescriptor<'tcx> for io::Stdout {\n-    fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle> {\n+impl FileDescriptor for io::Stdout {\n+    fn as_file_handle<'tcx>(&self) -> InterpResult<'tcx, &FileHandle> {\n         throw_unsup_format!(\"stdout cannot be used as FileHandle\");\n     }\n \n-    fn read(&mut self, _communicate_allowed: bool, _bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn read<'tcx>(&mut self, _communicate_allowed: bool, _bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n         throw_unsup_format!(\"cannot read from stdout\");\n     }\n \n-    fn write(&mut self, _communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn write<'tcx>(&mut self, _communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n         // We allow writing to stderr even with isolation enabled.\n         let result = Write::write(self, bytes);\n         // Stdout is buffered, flush to make sure it appears on the\n@@ -95,41 +95,42 @@ impl<'tcx> FileDescriptor<'tcx> for io::Stdout {\n         Ok(result)\n     }\n \n-    fn seek(&mut self, _communicate_allowed: bool, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+    fn seek<'tcx>(&mut self, _communicate_allowed: bool, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n         throw_unsup_format!(\"cannot seek on stdout\");\n     }\n }\n \n-impl<'tcx> FileDescriptor<'tcx> for io::Stderr {\n-    fn as_file_handle(&self) -> InterpResult<'tcx, &FileHandle> {\n+impl FileDescriptor for io::Stderr {\n+    fn as_file_handle<'tcx>(&self) -> InterpResult<'tcx, &FileHandle> {\n         throw_unsup_format!(\"stdout cannot be used as FileHandle\");\n     }\n \n-    fn read(&mut self, _communicate_allowed: bool, _bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn read<'tcx>(&mut self, _communicate_allowed: bool, _bytes: &mut [u8]) -> InterpResult<'tcx, io::Result<usize>> {\n         throw_unsup_format!(\"cannot read from stderr\");\n     }\n \n-    fn write(&mut self, _communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n+    fn write<'tcx>(&mut self, _communicate_allowed: bool, bytes: &[u8]) -> InterpResult<'tcx, io::Result<usize>> {\n         // We allow writing to stderr even with isolation enabled.\n+        // No need to flush, stderr is not buffered.\n         Ok(Write::write(self, bytes))\n     }\n \n-    fn seek(&mut self, _communicate_allowed: bool, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n+    fn seek<'tcx>(&mut self, _communicate_allowed: bool, _offset: SeekFrom) -> InterpResult<'tcx, io::Result<u64>> {\n         throw_unsup_format!(\"cannot seek on stderr\");\n     }\n }\n \n #[derive(Debug)]\n-pub struct FileHandler<'tcx> {\n-    handles: BTreeMap<i32, Box<dyn FileDescriptor<'tcx>>>,\n+pub struct FileHandler {\n+    handles: BTreeMap<i32, Box<dyn FileDescriptor>>,\n }\n \n-impl<'tcx> Default for FileHandler<'tcx> {\n+impl<'tcx> Default for FileHandler {\n     fn default() -> Self {\n-        let mut handles = BTreeMap::new();\n-        handles.insert(0i32, Box::new(io::stdin()) as Box<dyn FileDescriptor<'_>>);\n-        handles.insert(1i32, Box::new(io::stdout()) as Box<dyn FileDescriptor<'_>>);\n-        handles.insert(2i32, Box::new(io::stderr()) as Box<dyn FileDescriptor<'_>>);\n+        let mut handles: BTreeMap<_, Box<dyn FileDescriptor>> = BTreeMap::new();\n+        handles.insert(0i32, Box::new(io::stdin()));\n+        handles.insert(1i32, Box::new(io::stdout()));\n+        handles.insert(2i32, Box::new(io::stderr()));\n         FileHandler {\n             handles\n         }\n@@ -140,7 +141,7 @@ impl<'tcx> Default for FileHandler<'tcx> {\n // fd numbers 0, 1, and 2 are reserved for stdin, stdout, and stderr\n const MIN_NORMAL_FILE_FD: i32 = 3;\n \n-impl<'tcx> FileHandler<'tcx> {\n+impl<'tcx> FileHandler {\n     fn insert_fd(&mut self, file_handle: FileHandle) -> i32 {\n         self.insert_fd_with_min_fd(file_handle, 0)\n     }"}]}