{"sha": "941343e0871dd04ea774e8cee7755461b144ef29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MTM0M2UwODcxZGQwNGVhNzc0ZThjZWU3NzU1NDYxYjE0NGVmMjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-31T23:45:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-31T23:45:37Z"}, "message": "Auto merge of #81596 - jonas-schievink:rollup-utk14gr, r=jonas-schievink\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #80092 (2229: Fix issues with move closures and mutability)\n - #80404 (Remove const_in_array_repeat)\n - #81255 (Don't link with --export-dynamic on wasm32-wasi)\n - #81480 (Add suggestion for nested fields)\n - #81549 (Misc ip documentation fixes)\n - #81566 (Add a test for #71202)\n - #81568 (Fix an old FIXME in redundant paren lint)\n - #81571 (Fix typo in E0759)\n - #81572 (Edit multiple error code Markdown files)\n - #81589 (Fix small typo in string.rs)\n - #81590 (Stabilize int_bits_const)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f1b0d9272f0e8021ea13bb21054700ce52406c2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1b0d9272f0e8021ea13bb21054700ce52406c2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/941343e0871dd04ea774e8cee7755461b144ef29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/941343e0871dd04ea774e8cee7755461b144ef29", "html_url": "https://github.com/rust-lang/rust/commit/941343e0871dd04ea774e8cee7755461b144ef29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/941343e0871dd04ea774e8cee7755461b144ef29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e63af5da3400ace48a0345117980473fd21ad73", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e63af5da3400ace48a0345117980473fd21ad73", "html_url": "https://github.com/rust-lang/rust/commit/0e63af5da3400ace48a0345117980473fd21ad73"}, {"sha": "9165676d91d3e458a57f4f4eacc3975d89be9f5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9165676d91d3e458a57f4f4eacc3975d89be9f5a", "html_url": "https://github.com/rust-lang/rust/commit/9165676d91d3e458a57f4f4eacc3975d89be9f5a"}], "stats": {"total": 1925, "additions": 1599, "deletions": 326}, "files": [{"sha": "36d261fb737ce2d85f83566b85c0eba1a763ff5b", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -13,7 +13,6 @@\n #![feature(unboxed_closures)]\n #![feature(generator_trait)]\n #![feature(fn_traits)]\n-#![feature(int_bits_const)]\n #![feature(min_specialization)]\n #![feature(auto_traits)]\n #![feature(nll)]"}, {"sha": "5605302772ff689c1d9a6298f01afe67a49512fb", "filename": "compiler/rustc_error_codes/src/error_codes/E0013.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0013.md", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0013.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0013.md?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -8,7 +8,7 @@ static X: i32 = 42;\n const Y: i32 = X;\n ```\n \n-In this example, `Y` cannot refer to `X` here. To fix this, the value can be\n+In this example, `Y` cannot refer to `X`. To fix this, the value can be\n extracted as a const and then used:\n \n ```"}, {"sha": "019d54b6202ed4ff5224e7b2826fdf1eb6f98322", "filename": "compiler/rustc_error_codes/src/error_codes/E0038.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0038.md?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -287,5 +287,5 @@ the method `get_a()` would return an object of unknown type when called on the\n function. `Self` type parameters let us make object safe traits no longer safe,\n so they are forbidden when specifying supertraits.\n \n-There's no easy fix for this, generally code will need to be refactored so that\n+There's no easy fix for this. Generally, code will need to be refactored so that\n you no longer need to derive from `Super<Self>`."}, {"sha": "4e37695a529640e9a447dc5df68339b1b9a16cee", "filename": "compiler/rustc_error_codes/src/error_codes/E0107.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0107.md", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0107.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0107.md?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,4 +1,4 @@\n-An incorrect number of generic arguments were provided.\n+An incorrect number of generic arguments was provided.\n \n Erroneous code example:\n "}, {"sha": "653be60298977308436742b864245bcee5e568c6", "filename": "compiler/rustc_error_codes/src/error_codes/E0116.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0116.md", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0116.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0116.md?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -10,7 +10,7 @@ You can only define an inherent implementation for a type in the same crate\n where the type was defined. For example, an `impl` block as above is not allowed\n since `Vec` is defined in the standard library.\n \n-To fix this problem, you can do either of these things:\n+To fix this problem, you can either:\n \n  - define a trait that has the desired associated functions/types/constants and\n    implement the trait for the type in question"}, {"sha": "9f6db6ed7a225bc0a1295e667c5b2fd3fcc127dd", "filename": "compiler/rustc_error_codes/src/error_codes/E0277.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0277.md", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0277.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0277.md?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -59,9 +59,9 @@ fn main() {\n }\n ```\n \n-Note that the error here is in the definition of the generic function: Although\n+Note that the error here is in the definition of the generic function. Although\n we only call it with a parameter that does implement `Debug`, the compiler\n-still rejects the function: It must work with all possible input types. In\n+still rejects the function. It must work with all possible input types. In\n order to make this example compile, we need to restrict the generic type we're\n accepting:\n "}, {"sha": "c36a56b00ce72cf7ab2c1e7efbef9da8fea8c5e3", "filename": "compiler/rustc_error_codes/src/error_codes/E0309.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0309.md", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0309.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0309.md?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -25,7 +25,7 @@ where\n \n The type definition contains some field whose type requires an outlives\n annotation. Outlives annotations (e.g., `T: 'a`) are used to guarantee that all\n-the data in T is valid for at least the lifetime `'a`. This scenario most\n+the data in `T` is valid for at least the lifetime `'a`. This scenario most\n commonly arises when the type contains an associated type reference like\n `<T as SomeTrait<'a>>::Output`, as shown in the previous code.\n "}, {"sha": "f6e0b62e1b622d6fc49b220b9edc777832e66d24", "filename": "compiler/rustc_error_codes/src/error_codes/E0597.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0597.md", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0597.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0597.md?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,4 +1,4 @@\n-This error occurs because a value was dropped while it was still borrowed\n+This error occurs because a value was dropped while it was still borrowed.\n \n Erroneous code example:\n \n@@ -15,7 +15,7 @@ let mut x = Foo { x: None };\n println!(\"{:?}\", x.x);\n ```\n \n-In here, `y` is dropped at the end of the inner scope, but it is borrowed by\n+Here, `y` is dropped at the end of the inner scope, but it is borrowed by\n `x` until the `println`. To fix the previous example, just remove the scope\n so that `y` isn't dropped until after the println\n "}, {"sha": "24245a38ae07ffe0562603caf9c42db8ca4bbf32", "filename": "compiler/rustc_error_codes/src/error_codes/E0658.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0658.md", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0658.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0658.md?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -11,7 +11,7 @@ enum Foo {\n \n If you're using a stable or a beta version of rustc, you won't be able to use\n any unstable features. In order to do so, please switch to a nightly version of\n-rustc (by using rustup).\n+rustc (by using [rustup]).\n \n If you're using a nightly version of rustc, just add the corresponding feature\n to be able to use it:\n@@ -24,3 +24,5 @@ enum Foo {\n     Bar(u64),\n }\n ```\n+\n+[rustup]: https://rust-lang.github.io/rustup/concepts/channels.html"}, {"sha": "9f4b19cfda6b40d857e837b57339d8917b3227e9", "filename": "compiler/rustc_error_codes/src/error_codes/E0754.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0754.md", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0754.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0754.md?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,4 +1,4 @@\n-An non-ascii identifier was used in an invalid context.\n+A non-ASCII identifier was used in an invalid context.\n \n Erroneous code examples:\n \n@@ -13,7 +13,7 @@ fn \u0159\u0173\u015b\u0165() {} // error!\n fn main() {}\n ```\n \n-Non-ascii can be used as module names if it is inlined or if a `#[path]`\n+Non-ASCII can be used as module names if it is inlined or if a `#[path]`\n attribute is specified. For example:\n \n ```"}, {"sha": "2fe5ada257fc2eb3a939d80539ff71d5a3f1d58a", "filename": "compiler/rustc_error_codes/src/error_codes/E0759.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0759.md", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0759.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0759.md?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -27,7 +27,7 @@ fn bar(x: &i32) -> Box<dyn Debug + 'static> { // ok!\n }\n ```\n \n-Both [`dyn Trait`] and [`impl Trait`] in return types have a an implicit\n+Both [`dyn Trait`] and [`impl Trait`] in return types have an implicit\n `'static` requirement, meaning that the value implementing them that is being\n returned has to be either a `'static` borrow or an owned value.\n "}, {"sha": "e12b533b110d22fc4124852c52fd2d5848f49e27", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -485,9 +485,6 @@ declare_features! (\n     /// Allows `async || body` closures.\n     (active, async_closure, \"1.37.0\", Some(62290), None),\n \n-    /// Allows `[x; N]` where `x` is a constant (RFC 2203).\n-    (active, const_in_array_repeat_expressions, \"1.37.0\", Some(49147), None),\n-\n     /// Allows `impl Trait` to be used inside type aliases (RFC 2515).\n     (active, type_alias_impl_trait, \"1.38.0\", Some(63063), None),\n "}, {"sha": "38a3a4e3d4411275fe060e681570ba34d184047c", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -97,6 +97,9 @@ declare_features! (\n     (removed, extern_in_paths, \"1.33.0\", Some(55600), None,\n      Some(\"subsumed by `::foo::bar` paths\")),\n     (removed, quote, \"1.33.0\", Some(29601), None, None),\n+    /// Allows `[x; N]` where `x` is a constant (RFC 2203).\n+    (removed, const_in_array_repeat_expressions,  \"1.37.0\", Some(49147), None,\n+     Some(\"removed due to causing promotable bugs\")),\n     /// Allows using `#[unsafe_destructor_blind_to_params]` (RFC 1238).\n     (removed, dropck_parametricity, \"1.38.0\", Some(28498), None, None),\n     (removed, await_macro, \"1.38.0\", Some(50547), None,"}, {"sha": "b611aebad01b0a4de451835350cdd7e4ac3a0d77", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -977,8 +977,6 @@ impl UnusedDelimLint for UnusedBraces {\n                 }\n             }\n             ast::ExprKind::Let(_, ref expr) => {\n-                // FIXME(#60336): Properly handle `let true = (false && true)`\n-                // actually needing the parenthesis.\n                 self.check_unused_delims_expr(\n                     cx,\n                     expr,"}, {"sha": "163b400973b7cd2a0feb05f38c383223a0a02f95", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -228,8 +228,7 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Inline asm operand type must be `Sized`.\n     InlineAsmSized,\n     /// `[T, ..n]` implies that `T` must be `Copy`.\n-    /// If `true`, suggest `const_in_array_repeat_expressions` feature flag.\n-    RepeatVec(bool),\n+    RepeatVec,\n \n     /// Types of fields (other than the last, except for packed structs) in a struct must be sized.\n     FieldSized {"}, {"sha": "babab005edb2b3a85c7dd53644b012b00635069a", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -661,11 +661,28 @@ pub type RootVariableMinCaptureList<'tcx> = FxIndexMap<hir::HirId, MinCaptureLis\n /// Part of `MinCaptureInformationMap`; List of `CapturePlace`s.\n pub type MinCaptureList<'tcx> = Vec<CapturedPlace<'tcx>>;\n \n-/// A `Place` and the corresponding `CaptureInfo`.\n+/// A composite describing a `Place` that is captured by a closure.\n #[derive(PartialEq, Clone, Debug, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n pub struct CapturedPlace<'tcx> {\n+    /// The `Place` that is captured.\n     pub place: HirPlace<'tcx>,\n+\n+    /// `CaptureKind` and expression(s) that resulted in such capture of `place`.\n     pub info: CaptureInfo<'tcx>,\n+\n+    /// Represents if `place` can be mutated or not.\n+    pub mutability: hir::Mutability,\n+}\n+\n+impl CapturedPlace<'tcx> {\n+    /// Returns the hir-id of the root variable for the captured place.\n+    /// e.g., if `a.b.c` was captured, would return the hir-id for `a`.\n+    pub fn get_root_variable(&self) -> hir::HirId {\n+        match self.place.base {\n+            HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+            base => bug!(\"Expected upvar, found={:?}\", base),\n+        }\n+    }\n }\n \n pub fn place_to_string_for_capture(tcx: TyCtxt<'tcx>, place: &HirPlace<'tcx>) -> String {"}, {"sha": "04ea3cbd8b66d2fe5f823ef7e027aff15831f39d", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -215,6 +215,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             PlaceRef { local, projection: [proj_base @ .., elem] } => {\n                 match elem {\n                     ProjectionElem::Deref => {\n+                        // FIXME(project-rfc_2229#36): print capture precisely here.\n                         let upvar_field_projection = self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();\n@@ -259,6 +260,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     ProjectionElem::Field(field, _ty) => {\n                         autoderef = true;\n \n+                        // FIXME(project-rfc_2229#36): print capture precisely here.\n                         let upvar_field_projection = self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {\n                             let var_index = field.index();"}, {"sha": "fb7694b7d88e969ce71641a8ae982d71cd1e9dc5", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -345,7 +345,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 };\n \n                 let upvar = &self.upvars[upvar_field.unwrap().index()];\n-                let upvar_hir_id = upvar.var_hir_id;\n+                // FIXME(project-rfc-2229#8): Improve borrow-check diagnostics in case of precise\n+                //                            capture.\n+                let upvar_hir_id = upvar.place.get_root_variable();\n                 let upvar_name = upvar.name;\n                 let upvar_span = self.infcx.tcx.hir().span(upvar_hir_id);\n "}, {"sha": "74abe2d35ee748814c01f83ead67999cc05d9ab6", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -64,12 +64,29 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Place::ty_from(local, proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n-                item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                if self.is_upvar_field_projection(access_place.as_ref()).is_some() {\n-                    reason = \", as it is not declared as mutable\".to_string();\n+                let imm_borrow_derefed = self.upvars[upvar_index.index()]\n+                    .place\n+                    .place\n+                    .deref_tys()\n+                    .any(|ty| matches!(ty.kind(), ty::Ref(.., hir::Mutability::Not)));\n+\n+                // If the place is immutable then:\n+                //\n+                // - Either we deref a immutable ref to get to our final place.\n+                //    - We don't capture derefs of raw ptrs\n+                // - Or the final place is immut because the root variable of the capture\n+                //   isn't marked mut and we should suggest that to the user.\n+                if imm_borrow_derefed {\n+                    // If we deref an immutable ref then the suggestion here doesn't help.\n+                    return;\n                 } else {\n-                    let name = self.upvars[upvar_index.index()].name;\n-                    reason = format!(\", as `{}` is not declared as mutable\", name);\n+                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                    if self.is_upvar_field_projection(access_place.as_ref()).is_some() {\n+                        reason = \", as it is not declared as mutable\".to_string();\n+                    } else {\n+                        let name = self.upvars[upvar_index.index()].name;\n+                        reason = format!(\", as `{}` is not declared as mutable\", name);\n+                    }\n                 }\n             }\n \n@@ -259,9 +276,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Place::ty_from(local, proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n+                let captured_place = &self.upvars[upvar_index.index()].place;\n+\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n-                let upvar_hir_id = self.upvars[upvar_index.index()].var_hir_id;\n+                let upvar_hir_id = captured_place.get_root_variable();\n+\n                 if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_hir_id) {\n                     if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,"}, {"sha": "4abc623fc5f371f15a768b3958681a0861d379eb", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/var_name.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -12,7 +12,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n         local_names: &IndexVec<Local, Option<Symbol>>,\n-        upvars: &[Upvar],\n+        upvars: &[Upvar<'tcx>],\n         fr: RegionVid,\n     ) -> Option<(Option<Symbol>, Span)> {\n         debug!(\"get_var_name_and_span_for_region(fr={:?})\", fr);\n@@ -21,6 +21,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"get_var_name_and_span_for_region: attempting upvar\");\n         self.get_upvar_index_for_region(tcx, fr)\n             .map(|index| {\n+                // FIXME(project-rfc-2229#8): Use place span for diagnostics\n                 let (name, span) = self.get_upvar_name_and_span_for_region(tcx, upvars, index);\n                 (Some(name), span)\n             })\n@@ -59,10 +60,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn get_upvar_name_and_span_for_region(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        upvars: &[Upvar],\n+        upvars: &[Upvar<'tcx>],\n         upvar_index: usize,\n     ) -> (Symbol, Span) {\n-        let upvar_hir_id = upvars[upvar_index].var_hir_id;\n+        let upvar_hir_id = upvars[upvar_index].place.get_root_variable();\n         debug!(\"get_upvar_name_and_span_for_region: upvar_hir_id={:?}\", upvar_hir_id);\n \n         let upvar_name = tcx.hir().name(upvar_hir_id);"}, {"sha": "5db52db70ac685c33cf43c8d249a66510b5ddaf0", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -5,11 +5,10 @@ use rustc_data_structures::graph::dominators::Dominators;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::{HirId, Node};\n+use rustc_hir::Node;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n-use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::mir::{\n     traversal, Body, ClearCrossCrate, Local, Location, Mutability, Operand, Place, PlaceElem,\n     PlaceRef, VarDebugInfoContents,\n@@ -18,7 +17,7 @@ use rustc_middle::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind\n use rustc_middle::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, ParamEnv, RegionVid, TyCtxt};\n+use rustc_middle::ty::{self, CapturedPlace, ParamEnv, RegionVid, TyCtxt};\n use rustc_session::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT, UNUSED_MUT};\n use rustc_span::{Span, Symbol, DUMMY_SP};\n \n@@ -73,16 +72,14 @@ crate use region_infer::RegionInferenceContext;\n \n // FIXME(eddyb) perhaps move this somewhere more centrally.\n #[derive(Debug)]\n-crate struct Upvar {\n+crate struct Upvar<'tcx> {\n+    // FIXME(project-rfc_2229#36): print capture precisely here.\n     name: Symbol,\n \n-    // FIXME(project-rfc-2229#8): This should use Place or something similar\n-    var_hir_id: HirId,\n+    place: CapturedPlace<'tcx>,\n \n     /// If true, the capture is behind a reference.\n     by_ref: bool,\n-\n-    mutability: Mutability,\n }\n \n const DEREF_PROJECTION: &[PlaceElem<'_>; 1] = &[ProjectionElem::Deref];\n@@ -161,26 +158,13 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let upvars: Vec<_> = tables\n         .closure_min_captures_flattened(def.did.to_def_id())\n         .map(|captured_place| {\n-            let var_hir_id = match captured_place.place.base {\n-                HirPlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n-                _ => bug!(\"Expected upvar\"),\n-            };\n+            let var_hir_id = captured_place.get_root_variable();\n             let capture = captured_place.info.capture_kind;\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue(_) => false,\n                 ty::UpvarCapture::ByRef(..) => true,\n             };\n-            let mut upvar = Upvar {\n-                name: tcx.hir().name(var_hir_id),\n-                var_hir_id,\n-                by_ref,\n-                mutability: Mutability::Not,\n-            };\n-            let bm = *tables.pat_binding_modes().get(var_hir_id).expect(\"missing binding mode\");\n-            if bm == ty::BindByValue(hir::Mutability::Mut) {\n-                upvar.mutability = Mutability::Mut;\n-            }\n-            upvar\n+            Upvar { name: tcx.hir().name(var_hir_id), place: captured_place.clone(), by_ref }\n         })\n         .collect();\n \n@@ -549,7 +533,7 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     dominators: Dominators<BasicBlock>,\n \n     /// Information about upvars not necessarily preserved in types or MIR\n-    upvars: Vec<Upvar>,\n+    upvars: Vec<Upvar<'tcx>>,\n \n     /// Names of local (user) variables (extracted from `var_debug_info`).\n     local_names: IndexVec<Local, Option<Symbol>>,\n@@ -1374,13 +1358,38 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     fn propagate_closure_used_mut_upvar(&mut self, operand: &Operand<'tcx>) {\n         let propagate_closure_used_mut_place = |this: &mut Self, place: Place<'tcx>| {\n-            if !place.projection.is_empty() {\n-                if let Some(field) = this.is_upvar_field_projection(place.as_ref()) {\n+            // We have three possibilities here:\n+            // a. We are modifying something through a mut-ref\n+            // b. We are modifying something that is local to our parent\n+            // c. Current body is a nested closure, and we are modifying path starting from\n+            //    a Place captured by our parent closure.\n+\n+            // Handle (c), the path being modified is exactly the path captured by our parent\n+            if let Some(field) = this.is_upvar_field_projection(place.as_ref()) {\n+                this.used_mut_upvars.push(field);\n+                return;\n+            }\n+\n+            for (place_ref, proj) in place.iter_projections().rev() {\n+                // Handle (a)\n+                if proj == ProjectionElem::Deref {\n+                    match place_ref.ty(this.body(), this.infcx.tcx).ty.kind() {\n+                        // We aren't modifying a variable directly\n+                        ty::Ref(_, _, hir::Mutability::Mut) => return,\n+\n+                        _ => {}\n+                    }\n+                }\n+\n+                // Handle (c)\n+                if let Some(field) = this.is_upvar_field_projection(place_ref) {\n                     this.used_mut_upvars.push(field);\n+                    return;\n                 }\n-            } else {\n-                this.used_mut.insert(place.local);\n             }\n+\n+            // Handle(b)\n+            this.used_mut.insert(place.local);\n         };\n \n         // This relies on the current way that by-value\n@@ -2146,6 +2155,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         place: PlaceRef<'tcx>,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n     ) -> Result<RootPlace<'tcx>, PlaceRef<'tcx>> {\n+        debug!(\"is_mutable: place={:?}, is_local...={:?}\", place, is_local_mutation_allowed);\n         match place.last_projection() {\n             None => {\n                 let local = &self.body.local_decls[place.local];\n@@ -2227,11 +2237,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         if let Some(field) = upvar_field_projection {\n                             let upvar = &self.upvars[field.index()];\n                             debug!(\n-                                \"upvar.mutability={:?} local_mutation_is_allowed={:?} \\\n-                                 place={:?}\",\n-                                upvar, is_local_mutation_allowed, place\n+                                \"is_mutable: upvar.mutability={:?} local_mutation_is_allowed={:?} \\\n+                                 place={:?}, place_base={:?}\",\n+                                upvar, is_local_mutation_allowed, place, place_base\n                             );\n-                            match (upvar.mutability, is_local_mutation_allowed) {\n+                            match (upvar.place.mutability, is_local_mutation_allowed) {\n                                 (\n                                     Mutability::Not,\n                                     LocalMutationIsAllowed::No"}, {"sha": "a0265b20d127bd268d90baa60e0edcaabb917054", "filename": "compiler/rustc_mir/src/borrow_check/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fnll.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -165,7 +165,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     flow_inits: &mut ResultsCursor<'cx, 'tcx, MaybeInitializedPlaces<'cx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n-    upvars: &[Upvar],\n+    upvars: &[Upvar<'tcx>],\n ) -> NllOutput<'tcx> {\n     let mut all_facts = AllFacts::enabled(infcx.tcx).then_some(AllFacts::default());\n "}, {"sha": "80de3b4e363bfb369a40b701ff9cf944e43df84a", "filename": "compiler/rustc_mir/src/borrow_check/path_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fpath_utils.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -143,7 +143,7 @@ pub(super) fn borrow_of_local_data(place: Place<'_>) -> bool {\n /// of a closure type.\n pub(crate) fn is_upvar_field_projection(\n     tcx: TyCtxt<'tcx>,\n-    upvars: &[Upvar],\n+    upvars: &[Upvar<'tcx>],\n     place_ref: PlaceRef<'tcx>,\n     body: &Body<'tcx>,\n ) -> Option<Field> {"}, {"sha": "e689964b998585cd03b364d1bb5e0daa9e699b69", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -43,10 +43,6 @@ use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligations}\n use crate::dataflow::impls::MaybeInitializedPlaces;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::ResultsCursor;\n-use crate::transform::{\n-    check_consts::ConstCx,\n-    promote_consts::should_suggest_const_in_array_repeat_expressions_attribute,\n-};\n \n use crate::borrow_check::{\n     borrow_set::BorrowSet,\n@@ -132,7 +128,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     flow_inits: &mut ResultsCursor<'mir, 'tcx, MaybeInitializedPlaces<'mir, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n-    upvars: &[Upvar],\n+    upvars: &[Upvar<'tcx>],\n ) -> MirTypeckResults<'tcx> {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n@@ -821,7 +817,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n     all_facts: &'a mut Option<AllFacts>,\n     borrow_set: &'a BorrowSet<'tcx>,\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n-    upvars: &'a [Upvar],\n+    upvars: &'a [Upvar<'tcx>],\n }\n \n crate struct MirTypeckResults<'tcx> {\n@@ -1997,22 +1993,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             let span = body.source_info(location).span;\n                             let ty = operand.ty(body, tcx);\n                             if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span) {\n-                                let ccx = ConstCx::new_with_param_env(tcx, body, self.param_env);\n-                                // To determine if `const_in_array_repeat_expressions` feature gate should\n-                                // be mentioned, need to check if the rvalue is promotable.\n-                                let should_suggest =\n-                                    should_suggest_const_in_array_repeat_expressions_attribute(\n-                                        &ccx, operand,\n-                                    );\n-                                debug!(\"check_rvalue: should_suggest={:?}\", should_suggest);\n-\n                                 let def_id = body.source.def_id().expect_local();\n                                 self.infcx.report_selection_error(\n                                     &traits::Obligation::new(\n                                         ObligationCause::new(\n                                             span,\n                                             self.tcx().hir().local_def_id_to_hir_id(def_id),\n-                                            traits::ObligationCauseCode::RepeatVec(should_suggest),\n+                                            traits::ObligationCauseCode::RepeatVec,\n                                         ),\n                                         self.param_env,\n                                         ty::Binder::bind(ty::TraitRef::new(\n@@ -2490,7 +2477,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             body,\n         );\n         let category = if let Some(field) = field {\n-            ConstraintCategory::ClosureUpvar(self.borrowck_context.upvars[field.index()].var_hir_id)\n+            let var_hir_id = self.borrowck_context.upvars[field.index()].place.get_root_variable();\n+            // FIXME(project-rfc-2229#8): Use Place for better diagnostics\n+            ConstraintCategory::ClosureUpvar(var_hir_id)\n         } else {\n             ConstraintCategory::Boring\n         };"}, {"sha": "b4504a0e223f6899d36d7126b40567ff7a81ab19", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 63, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -102,9 +102,6 @@ pub enum Candidate {\n     /// Borrow of a constant temporary, candidate for lifetime extension.\n     Ref(Location),\n \n-    /// Promotion of the `x` in `[x; 32]`.\n-    Repeat(Location),\n-\n     /// Currently applied to function calls where the callee has the unstable\n     /// `#[rustc_args_required_const]` attribute as well as the SIMD shuffle\n     /// intrinsic. The intrinsic requires the arguments are indeed constant and\n@@ -120,14 +117,14 @@ impl Candidate {\n     /// Returns `true` if we should use the \"explicit\" rules for promotability for this `Candidate`.\n     fn forces_explicit_promotion(&self) -> bool {\n         match self {\n-            Candidate::Ref(_) | Candidate::Repeat(_) => false,\n+            Candidate::Ref(_) => false,\n             Candidate::Argument { .. } | Candidate::InlineAsm { .. } => true,\n         }\n     }\n \n     fn source_info(&self, body: &Body<'_>) -> SourceInfo {\n         match self {\n-            Candidate::Ref(location) | Candidate::Repeat(location) => *body.source_info(*location),\n+            Candidate::Ref(location) => *body.source_info(*location),\n             Candidate::Argument { bb, .. } | Candidate::InlineAsm { bb, .. } => {\n                 *body.source_info(body.terminator_loc(*bb))\n             }\n@@ -213,11 +210,6 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n             Rvalue::Ref(..) => {\n                 self.candidates.push(Candidate::Ref(location));\n             }\n-            Rvalue::Repeat(..) if self.ccx.tcx.features().const_in_array_repeat_expressions => {\n-                // FIXME(#49147) only promote the element when it isn't `Copy`\n-                // (so that code that can copy it at runtime is unaffected).\n-                self.candidates.push(Candidate::Repeat(location));\n-            }\n             _ => {}\n         }\n     }\n@@ -334,21 +326,6 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     _ => bug!(),\n                 }\n             }\n-            Candidate::Repeat(loc) => {\n-                assert!(!self.explicit);\n-\n-                let statement = &self.body[loc.block].statements[loc.statement_index];\n-                match &statement.kind {\n-                    StatementKind::Assign(box (_, Rvalue::Repeat(ref operand, _))) => {\n-                        if !self.tcx.features().const_in_array_repeat_expressions {\n-                            return Err(Unpromotable);\n-                        }\n-\n-                        self.validate_operand(operand)\n-                    }\n-                    _ => bug!(),\n-                }\n-            }\n             Candidate::Argument { bb, index } => {\n                 assert!(self.explicit);\n \n@@ -1090,18 +1067,6 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         _ => bug!(),\n                     }\n                 }\n-                Candidate::Repeat(loc) => {\n-                    let statement = &mut blocks[loc.block].statements[loc.statement_index];\n-                    match statement.kind {\n-                        StatementKind::Assign(box (_, Rvalue::Repeat(ref mut operand, _))) => {\n-                            let ty = operand.ty(local_decls, self.tcx);\n-                            let span = statement.source_info.span;\n-\n-                            Rvalue::Use(mem::replace(operand, promoted_operand(ty, span)))\n-                        }\n-                        _ => bug!(),\n-                    }\n-                }\n                 Candidate::Argument { bb, index } => {\n                     let terminator = blocks[bb].terminator_mut();\n                     match terminator.kind {\n@@ -1182,8 +1147,7 @@ pub fn promote_candidates<'tcx>(\n     let mut extra_statements = vec![];\n     for candidate in candidates.into_iter().rev() {\n         match candidate {\n-            Candidate::Repeat(Location { block, statement_index })\n-            | Candidate::Ref(Location { block, statement_index }) => {\n+            Candidate::Ref(Location { block, statement_index }) => {\n                 if let StatementKind::Assign(box (place, _)) =\n                     &body[block].statements[statement_index].kind\n                 {\n@@ -1267,27 +1231,3 @@ pub fn promote_candidates<'tcx>(\n \n     promotions\n }\n-\n-/// This function returns `true` if the `const_in_array_repeat_expressions` feature attribute should\n-/// be suggested. This function is probably quite expensive, it shouldn't be run in the happy path.\n-/// Feature attribute should be suggested if `operand` can be promoted and the feature is not\n-/// enabled.\n-crate fn should_suggest_const_in_array_repeat_expressions_attribute<'tcx>(\n-    ccx: &ConstCx<'_, 'tcx>,\n-    operand: &Operand<'tcx>,\n-) -> bool {\n-    let mut rpo = traversal::reverse_postorder(&ccx.body);\n-    let (temps, _) = collect_temps_and_candidates(&ccx, &mut rpo);\n-    let validator = Validator { ccx, temps: &temps, explicit: false };\n-\n-    let should_promote = validator.validate_operand(operand).is_ok();\n-    let feature_flag = validator.ccx.tcx.features().const_in_array_repeat_expressions;\n-    debug!(\n-        \"should_suggest_const_in_array_repeat_expressions_flag: def_id={:?} \\\n-            should_promote={:?} feature_flag={:?}\",\n-        validator.ccx.def_id(),\n-        should_promote,\n-        feature_flag\n-    );\n-    should_promote && !feature_flag\n-}"}, {"sha": "e4891eb5a3c0cc1305fbd1203bc41a8cc154632b", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -851,22 +851,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         _ => bug!(\"Expected an upvar\")\n                     };\n \n-                    let mut mutability = Mutability::Not;\n+                    let mutability = captured_place.mutability;\n \n                     // FIXME(project-rfc-2229#8): Store more precise information\n                     let mut name = kw::Empty;\n                     if let Some(Node::Binding(pat)) = tcx_hir.find(var_id) {\n                         if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n                             name = ident.name;\n-                            match hir_typeck_results\n-                                .extract_binding_mode(tcx.sess, pat.hir_id, pat.span)\n-                            {\n-                                Some(ty::BindByValue(hir::Mutability::Mut)) => {\n-                                    mutability = Mutability::Mut;\n-                                }\n-                                Some(_) => mutability = Mutability::Not,\n-                                _ => {}\n-                            }\n                         }\n                     }\n "}, {"sha": "ea04e7bb44b3bd6de21c8e83113eeef783f24864", "filename": "compiler/rustc_serialize/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_serialize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Flib.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -17,7 +17,6 @@ Core encoding and decoding interfaces.\n #![feature(min_specialization)]\n #![feature(vec_spare_capacity)]\n #![feature(core_intrinsics)]\n-#![feature(int_bits_const)]\n #![feature(maybe_uninit_slice)]\n #![feature(new_uninit)]\n #![cfg_attr(test, feature(test))]"}, {"sha": "3e2aab5125ab7b5fd98e5daf67f399639aa3414e", "filename": "compiler/rustc_serialize/tests/leb128.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_serialize%2Ftests%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_serialize%2Ftests%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fleb128.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,4 +1,3 @@\n-#![feature(int_bits_const)]\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_uninit_array)]\n "}, {"sha": "bfef3d37228f020683eadcda0b62843b392a479b", "filename": "compiler/rustc_target/src/spec/wasm32_base.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_base.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -55,15 +55,6 @@ pub fn options() -> TargetOptions {\n     // to do so.\n     arg(\"--no-demangle\");\n \n-    // The symbol visibility story is a bit in flux right now with LLD.\n-    // It's... not entirely clear to me what's going on, but this looks to\n-    // make everything work when `export_symbols` isn't otherwise called for\n-    // things like executables.\n-    //\n-    // This is really only here to get things working. If it can be removed and\n-    // basic tests still work, then sounds like it should be removed!\n-    arg(\"--export-dynamic\");\n-\n     let mut pre_link_args = BTreeMap::new();\n     pre_link_args.insert(LinkerFlavor::Lld(LldFlavor::Wasm), lld_args);\n     pre_link_args.insert(LinkerFlavor::Gcc, clang_args);"}, {"sha": "9f69ce16c215d35cae28f636bbf8684dce253fee", "filename": "compiler/rustc_target/src/spec/wasm32_unknown_emscripten.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_emscripten.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -2,6 +2,17 @@ use super::wasm32_base;\n use super::{LinkArgs, LinkerFlavor, PanicStrategy, Target, TargetOptions};\n \n pub fn target() -> Target {\n+    let mut options = wasm32_base::options();\n+\n+    let clang_args = options.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap();\n+\n+    // Rust really needs a way for users to specify exports and imports in\n+    // the source code. --export-dynamic isn't the right tool for this job,\n+    // however it does have the side effect of automatically exporting a lot\n+    // of symbols, which approximates what people want when compiling for\n+    // wasm32-unknown-unknown expect, so use it for now.\n+    clang_args.push(\"--export-dynamic\".to_string());\n+\n     let mut post_link_args = LinkArgs::new();\n     post_link_args.insert(\n         LinkerFlavor::Em,\n@@ -28,7 +39,7 @@ pub fn target() -> Target {\n         panic_strategy: PanicStrategy::Unwind,\n         post_link_args,\n         os_family: Some(\"unix\".to_string()),\n-        ..wasm32_base::options()\n+        ..options\n     };\n     Target {\n         llvm_target: \"wasm32-unknown-emscripten\".to_string(),"}, {"sha": "5e89ba2520bdd703348df19279128ff57b93f460", "filename": "compiler/rustc_target/src/spec/wasm32_unknown_unknown.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_unknown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_unknown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm32_unknown_unknown.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -26,11 +26,18 @@ pub fn target() -> Target {\n     // For now this target just never has an entry symbol no matter the output\n     // type, so unconditionally pass this.\n     clang_args.push(\"-Wl,--no-entry\".to_string());\n-    options\n-        .pre_link_args\n-        .get_mut(&LinkerFlavor::Lld(LldFlavor::Wasm))\n-        .unwrap()\n-        .push(\"--no-entry\".to_string());\n+\n+    // Rust really needs a way for users to specify exports and imports in\n+    // the source code. --export-dynamic isn't the right tool for this job,\n+    // however it does have the side effect of automatically exporting a lot\n+    // of symbols, which approximates what people want when compiling for\n+    // wasm32-unknown-unknown expect, so use it for now.\n+    clang_args.push(\"-Wl,--export-dynamic\".to_string());\n+\n+    // Add the flags to wasm-ld's args too.\n+    let lld_args = options.pre_link_args.get_mut(&LinkerFlavor::Lld(LldFlavor::Wasm)).unwrap();\n+    lld_args.push(\"--no-entry\".to_string());\n+    lld_args.push(\"--export-dynamic\".to_string());\n \n     Target {\n         llvm_target: \"wasm32-unknown-unknown\".to_string(),"}, {"sha": "690591930deb9d9af28f2de778898460d20a71a1", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1881,23 +1881,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ObligationCauseCode::Coercion { source: _, target } => {\n                 err.note(&format!(\"required by cast to type `{}`\", self.ty_to_string(target)));\n             }\n-            ObligationCauseCode::RepeatVec(suggest_const_in_array_repeat_expressions) => {\n+            ObligationCauseCode::RepeatVec => {\n                 err.note(\n                     \"the `Copy` trait is required because the repeated element will be copied\",\n                 );\n-                if suggest_const_in_array_repeat_expressions {\n-                    err.note(\n-                        \"this array initializer can be evaluated at compile-time, see issue \\\n-                         #49147 <https://github.com/rust-lang/rust/issues/49147> \\\n-                         for more information\",\n-                    );\n-                    if tcx.sess.opts.unstable_features.is_nightly_build() {\n-                        err.help(\n-                            \"add `#![feature(const_in_array_repeat_expressions)]` to the \\\n-                             crate attributes to enable\",\n-                        );\n-                    }\n-                }\n             }\n             ObligationCauseCode::VariableType(hir_id) => {\n                 let parent_node = self.tcx.hir().get_parent_node(hir_id);"}, {"sha": "04c83a7665caadadc0ee23434a8e051c028c3a0c", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 110, "deletions": 10, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -36,6 +36,7 @@ use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n+use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::Ty;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{AdtKind, Visibility};\n@@ -46,8 +47,6 @@ use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n-use std::fmt::Display;\n-\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn check_expr_eq_type(&self, expr: &'tcx hir::Expr<'tcx>, expected: Ty<'tcx>) {\n         let ty = self.check_expr_with_hint(expr, expected);\n@@ -1585,11 +1584,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base: &'tcx hir::Expr<'tcx>,\n         field: Ident,\n     ) -> Ty<'tcx> {\n+        debug!(\"check_field(expr: {:?}, base: {:?}, field: {:?})\", expr, base, field);\n         let expr_t = self.check_expr(base);\n         let expr_t = self.structurally_resolved_type(base.span, expr_t);\n         let mut private_candidate = None;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n         while let Some((base_t, _)) = autoderef.next() {\n+            debug!(\"base_t: {:?}\", base_t);\n             match base_t.kind() {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\", base_t);\n@@ -1706,7 +1707,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             \"ban_nonexisting_field: field={:?}, base={:?}, expr={:?}, expr_ty={:?}\",\n             field, base, expr, expr_t\n         );\n-        let mut err = self.no_such_field_err(field.span, field, expr_t);\n+        let mut err = self.no_such_field_err(field, expr_t);\n \n         match *expr_t.peel_refs().kind() {\n             ty::Array(_, len) => {\n@@ -1880,21 +1881,120 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn no_such_field_err<T: Display>(\n+    fn no_such_field_err(\n         &self,\n-        span: Span,\n-        field: T,\n-        expr_t: &ty::TyS<'_>,\n+        field: Ident,\n+        expr_t: &'tcx ty::TyS<'tcx>,\n     ) -> DiagnosticBuilder<'_> {\n-        type_error_struct!(\n+        let span = field.span;\n+        debug!(\"no_such_field_err(span: {:?}, field: {:?}, expr_t: {:?})\", span, field, expr_t);\n+\n+        let mut err = type_error_struct!(\n             self.tcx().sess,\n-            span,\n+            field.span,\n             expr_t,\n             E0609,\n             \"no field `{}` on type `{}`\",\n             field,\n             expr_t\n-        )\n+        );\n+\n+        // try to add a suggestion in case the field is a nested field of a field of the Adt\n+        if let Some((fields, substs)) = self.get_field_candidates(span, &expr_t) {\n+            for candidate_field in fields.iter() {\n+                if let Some(field_path) =\n+                    self.check_for_nested_field(span, field, candidate_field, substs, vec![])\n+                {\n+                    let field_path_str = field_path\n+                        .iter()\n+                        .map(|id| id.name.to_ident_string())\n+                        .collect::<Vec<String>>()\n+                        .join(\".\");\n+                    debug!(\"field_path_str: {:?}\", field_path_str);\n+\n+                    err.span_suggestion_verbose(\n+                        field.span.shrink_to_lo(),\n+                        \"one of the expressions' fields has a field of the same name\",\n+                        format!(\"{}.\", field_path_str),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+            }\n+        }\n+        err\n+    }\n+\n+    fn get_field_candidates(\n+        &self,\n+        span: Span,\n+        base_t: Ty<'tcx>,\n+    ) -> Option<(&Vec<ty::FieldDef>, SubstsRef<'tcx>)> {\n+        debug!(\"get_field_candidates(span: {:?}, base_t: {:?}\", span, base_t);\n+\n+        let mut autoderef = self.autoderef(span, base_t);\n+        while let Some((base_t, _)) = autoderef.next() {\n+            match base_t.kind() {\n+                ty::Adt(base_def, substs) if !base_def.is_enum() => {\n+                    let fields = &base_def.non_enum_variant().fields;\n+                    // For compile-time reasons put a limit on number of fields we search\n+                    if fields.len() > 100 {\n+                        return None;\n+                    }\n+                    return Some((fields, substs));\n+                }\n+                _ => {}\n+            }\n+        }\n+        None\n+    }\n+\n+    /// This method is called after we have encountered a missing field error to recursively\n+    /// search for the field\n+    fn check_for_nested_field(\n+        &self,\n+        span: Span,\n+        target_field: Ident,\n+        candidate_field: &ty::FieldDef,\n+        subst: SubstsRef<'tcx>,\n+        mut field_path: Vec<Ident>,\n+    ) -> Option<Vec<Ident>> {\n+        debug!(\n+            \"check_for_nested_field(span: {:?}, candidate_field: {:?}, field_path: {:?}\",\n+            span, candidate_field, field_path\n+        );\n+\n+        if candidate_field.ident == target_field {\n+            Some(field_path)\n+        } else if field_path.len() > 3 {\n+            // For compile-time reasons and to avoid infinite recursion we only check for fields\n+            // up to a depth of three\n+            None\n+        } else {\n+            // recursively search fields of `candidate_field` if it's a ty::Adt\n+\n+            field_path.push(candidate_field.ident.normalize_to_macros_2_0());\n+            let field_ty = candidate_field.ty(self.tcx, subst);\n+            if let Some((nested_fields, _)) = self.get_field_candidates(span, &field_ty) {\n+                for field in nested_fields.iter() {\n+                    let ident = field.ident.normalize_to_macros_2_0();\n+                    if ident == target_field {\n+                        return Some(field_path);\n+                    } else {\n+                        let field_path = field_path.clone();\n+                        if let Some(path) = self.check_for_nested_field(\n+                            span,\n+                            target_field,\n+                            field,\n+                            subst,\n+                            field_path,\n+                        ) {\n+                            return Some(path);\n+                        }\n+                    }\n+                }\n+            }\n+            None\n+        }\n     }\n \n     fn check_expr_index("}, {"sha": "f039445bf7780b60304289e25c0e24537ddd7b01", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 114, "deletions": 17, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -184,10 +184,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let origin = if self.tcx.features().capture_disjoint_fields {\n                     origin\n                 } else {\n-                    // FIXME(project-rfc-2229#26): Once rust-lang#80092 is merged, we should restrict the\n-                    // precision of origin as well. Otherwise, this will cause issues when project-rfc-2229#26\n-                    // is fixed as we might see Index projections in the origin, which we can't print because\n-                    // we don't store enough information.\n+                    // FIXME(project-rfc-2229#31): Once the changes to support reborrowing are\n+                    //                             made, make sure we are selecting and restricting\n+                    //                             the origin correctly.\n                     (origin.0, Place { projections: vec![], ..origin.1 })\n                 };\n \n@@ -252,8 +251,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let capture = captured_place.info.capture_kind;\n \n                 debug!(\n-                    \"place={:?} upvar_ty={:?} capture={:?}\",\n-                    captured_place.place, upvar_ty, capture\n+                    \"final_upvar_tys: place={:?} upvar_ty={:?} capture={:?}, mutability={:?}\",\n+                    captured_place.place, upvar_ty, capture, captured_place.mutability,\n                 );\n \n                 match capture {\n@@ -419,19 +418,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n \n-            // Arrays are captured in entirety, drop Index projections and projections\n-            // after Index projections.\n-            let first_index_projection =\n-                place.projections.split(|proj| ProjectionKind::Index == proj.kind).next();\n-            let place = Place {\n-                base_ty: place.base_ty,\n-                base: place.base,\n-                projections: first_index_projection.map_or(Vec::new(), |p| p.to_vec()),\n-            };\n+            let place = restrict_capture_precision(place, capture_info.capture_kind);\n \n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n-                    let min_cap_list = vec![ty::CapturedPlace { place, info: capture_info }];\n+                    let mutability = self.determine_capture_mutability(&place);\n+                    let min_cap_list =\n+                        vec![ty::CapturedPlace { place, info: capture_info, mutability }];\n                     root_var_min_capture_list.insert(var_hir_id, min_cap_list);\n                     continue;\n                 }\n@@ -494,8 +487,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Only need to insert when we don't have an ancestor in the existing min capture list\n             if !ancestor_found {\n+                let mutability = self.determine_capture_mutability(&place);\n                 let captured_place =\n-                    ty::CapturedPlace { place: place.clone(), info: updated_capture_info };\n+                    ty::CapturedPlace { place, info: updated_capture_info, mutability };\n                 min_cap_list.push(captured_place);\n             }\n         }\n@@ -615,6 +609,49 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    /// A captured place is mutable if\n+    /// 1. Projections don't include a Deref of an immut-borrow, **and**\n+    /// 2. PlaceBase is mut or projections include a Deref of a mut-borrow.\n+    fn determine_capture_mutability(&self, place: &Place<'tcx>) -> hir::Mutability {\n+        let var_hir_id = match place.base {\n+            PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n+            _ => unreachable!(),\n+        };\n+\n+        let bm = *self\n+            .typeck_results\n+            .borrow()\n+            .pat_binding_modes()\n+            .get(var_hir_id)\n+            .expect(\"missing binding mode\");\n+\n+        let mut is_mutbl = match bm {\n+            ty::BindByValue(mutability) => mutability,\n+            ty::BindByReference(_) => hir::Mutability::Not,\n+        };\n+\n+        for pointer_ty in place.deref_tys() {\n+            match pointer_ty.kind() {\n+                // We don't capture derefs of raw ptrs\n+                ty::RawPtr(_) => unreachable!(),\n+\n+                // Derefencing a mut-ref allows us to mut the Place if we don't deref\n+                // an immut-ref after on top of this.\n+                ty::Ref(.., hir::Mutability::Mut) => is_mutbl = hir::Mutability::Mut,\n+\n+                // The place isn't mutable once we dereference a immutable reference.\n+                ty::Ref(.., hir::Mutability::Not) => return hir::Mutability::Not,\n+\n+                // Dereferencing a box doesn't change mutability\n+                ty::Adt(def, ..) if def.is_box() => {}\n+\n+                unexpected_ty => bug!(\"deref of unexpected pointer type {:?}\", unexpected_ty),\n+            }\n+        }\n+\n+        is_mutbl\n+    }\n }\n \n struct InferBorrowKind<'a, 'tcx> {\n@@ -960,6 +997,66 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     }\n }\n \n+/// Truncate projections so that following rules are obeyed by the captured `place`:\n+///\n+/// - No Derefs in move closure, this will result in value behind a reference getting moved.\n+/// - No projections are applied to raw pointers, since these require unsafe blocks. We capture\n+///   them completely.\n+/// - No Index projections are captured, since arrays are captured completely.\n+fn restrict_capture_precision<'tcx>(\n+    mut place: Place<'tcx>,\n+    capture_kind: ty::UpvarCapture<'tcx>,\n+) -> Place<'tcx> {\n+    if place.projections.is_empty() {\n+        // Nothing to do here\n+        return place;\n+    }\n+\n+    if place.base_ty.is_unsafe_ptr() {\n+        place.projections.truncate(0);\n+        return place;\n+    }\n+\n+    let mut truncated_length = usize::MAX;\n+    let mut first_deref_projection = usize::MAX;\n+\n+    for (i, proj) in place.projections.iter().enumerate() {\n+        if proj.ty.is_unsafe_ptr() {\n+            // Don't apply any projections on top of an unsafe ptr\n+            truncated_length = truncated_length.min(i + 1);\n+            break;\n+        }\n+        match proj.kind {\n+            ProjectionKind::Index => {\n+                // Arrays are completely captured, so we drop Index projections\n+                truncated_length = truncated_length.min(i);\n+                break;\n+            }\n+            ProjectionKind::Deref => {\n+                // We only drop Derefs in case of move closures\n+                // There might be an index projection or raw ptr ahead, so we don't stop here.\n+                first_deref_projection = first_deref_projection.min(i);\n+            }\n+            ProjectionKind::Field(..) => {} // ignore\n+            ProjectionKind::Subslice => {}  // We never capture this\n+        }\n+    }\n+\n+    let length = place\n+        .projections\n+        .len()\n+        .min(truncated_length)\n+        // In case of capture `ByValue` we want to not capture derefs\n+        .min(match capture_kind {\n+            ty::UpvarCapture::ByValue(..) => first_deref_projection,\n+            ty::UpvarCapture::ByRef(..) => usize::MAX,\n+        });\n+\n+    place.projections.truncate(length);\n+\n+    place\n+}\n+\n fn construct_place_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n     let variable_name = match place.base {\n         PlaceBase::Upvar(upvar_id) => var_name(tcx, upvar_id.var_path.hir_id).to_string(),"}, {"sha": "785ce8d606b6790aee3157d708c87193d9c25eeb", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -89,7 +89,6 @@\n #![feature(coerce_unsized)]\n #![feature(const_btree_new)]\n #![feature(const_fn)]\n-#![feature(const_in_array_repeat_expressions)]\n #![feature(cow_is_borrowed)]\n #![feature(const_cow_is_borrowed)]\n #![feature(dispatch_from_dyn)]\n@@ -102,7 +101,6 @@\n #![feature(fn_traits)]\n #![feature(fundamental)]\n #![feature(inplace_iteration)]\n-#![feature(int_bits_const)]\n #![feature(lang_items)]\n #![feature(layout_for_ptr)]\n #![feature(maybe_uninit_ref)]"}, {"sha": "3218b3535c97027a43cc2b3da51ab67064cbbd66", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -972,7 +972,7 @@ impl String {\n         self.vec.try_reserve(additional)\n     }\n \n-    /// Tries to reserves the minimum capacity for exactly `additional` more elements to\n+    /// Tries to reserve the minimum capacity for exactly `additional` more elements to\n     /// be inserted in the given `String`. After calling `reserve_exact`,\n     /// capacity will be greater than or equal to `self.len() + additional`.\n     /// Does nothing if the capacity is already sufficient."}, {"sha": "7b00354629875f2ee8439d6de30f92d4b45d5eda", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -17,7 +17,6 @@\n #![feature(binary_heap_retain)]\n #![feature(inplace_iteration)]\n #![feature(iter_map_while)]\n-#![feature(int_bits_const)]\n #![feature(vecdeque_binary_search)]\n #![feature(slice_group_by)]\n "}, {"sha": "96affd17cc520d6d308c8ea752ebd36f322153f6", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -32,10 +32,9 @@ macro_rules! int_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_bits_const)]\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n         /// ```\n-        #[unstable(feature = \"int_bits_const\", issue = \"76904\")]\n+        #[stable(feature = \"int_bits_const\", since = \"1.51.0\")]\n         pub const BITS: u32 = $BITS;\n \n         /// Converts a string slice in a given base to an integer."}, {"sha": "aee424b9b1392cef13480ab1c76dae839e9db836", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -32,10 +32,9 @@ macro_rules! uint_impl {\n         /// # Examples\n         ///\n         /// ```\n-        /// #![feature(int_bits_const)]\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n         /// ```\n-        #[unstable(feature = \"int_bits_const\", issue = \"76904\")]\n+        #[stable(feature = \"int_bits_const\", since = \"1.51.0\")]\n         pub const BITS: u32 = $BITS;\n \n         /// Converts a string slice in a given base to an integer."}, {"sha": "26dbcb8569b43701055cead15c73a2de49fa0757", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -70,7 +70,6 @@\n #![feature(partition_point)]\n #![feature(once_cell)]\n #![feature(unsafe_block_in_unsafe_fn)]\n-#![feature(int_bits_const)]\n #![feature(nonzero_leading_trailing_zeros)]\n #![feature(const_option)]\n #![feature(integer_atomics)]"}, {"sha": "99a0c67fc11b90625918ef1d0a3dd5a32d493424", "filename": "library/panic_unwind/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Flib.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -18,7 +18,6 @@\n     issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\"\n )]\n #![feature(core_intrinsics)]\n-#![feature(int_bits_const)]\n #![feature(lang_items)]\n #![feature(nll)]\n #![feature(panic_unwind)]"}, {"sha": "a8a4127d40a5eb7359becfbf11853d68a4917a6f", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1217,8 +1217,8 @@ impl Ipv6Addr {\n \n     /// Returns [`true`] if the address is a unicast link-local address (`fe80::/64`).\n     ///\n-    /// A common mis-conception is to think that \"unicast link-local addresses start with\n-    /// `fe80::`\", but the [IETF RFC 4291] actually defines a stricter format for these addresses:\n+    /// A common misconception is to think that \"unicast link-local addresses start with\n+    /// `fe80::`\", but [IETF RFC 4291] actually defines a stricter format for these addresses:\n     ///\n     /// ```no_rust\n     /// |   10     |\n@@ -1228,9 +1228,9 @@ impl Ipv6Addr {\n     /// +----------+-------------------------+----------------------------+\n     /// ```\n     ///\n-    /// This method validates the format defined in the RFC and won't recognize the following\n-    /// addresses such as `fe80:0:0:1::` or `fe81::` as unicast link-local addresses for example.\n-    /// If you need a less strict validation use [`Ipv6Addr::is_unicast_link_local()`] instead.\n+    /// This method validates the format defined in the RFC and won't recognize addresses\n+    /// like `fe80:0:0:1::` or `fe81::` as unicast link-local addresses.\n+    /// If you need a less strict validation, use [`Ipv6Addr::is_unicast_link_local()`] instead.\n     ///\n     /// # Examples\n     ///\n@@ -1282,7 +1282,7 @@ impl Ipv6Addr {\n     /// +----------+-------------------------+----------------------------+\n     /// ```\n     ///\n-    /// As a result, this method consider addresses such as `fe80:0:0:1::` or `fe81::` to be\n+    /// As a result, this method considers addresses such as `fe80:0:0:1::` or `fe81::` to be\n     /// unicast link-local addresses, whereas [`Ipv6Addr::is_unicast_link_local_strict()`] does not.\n     /// If you need a strict validation fully compliant with the RFC, use\n     /// [`Ipv6Addr::is_unicast_link_local_strict()`] instead.\n@@ -1362,7 +1362,7 @@ impl Ipv6Addr {\n     }\n \n     /// Returns [`true`] if this is an address reserved for documentation\n-    /// (2001:db8::/32).\n+    /// (`2001:db8::/32`).\n     ///\n     /// This property is defined in [IETF RFC 3849].\n     ///"}, {"sha": "940916944bdaa6f5b8e78c7da1cde91a6ec9c35e", "filename": "src/doc/unstable-book/src/language-features/const-in-array-repeat-expressions.md", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0e63af5da3400ace48a0345117980473fd21ad73/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md", "raw_url": "https://github.com/rust-lang/rust/raw/0e63af5da3400ace48a0345117980473fd21ad73/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md?ref=0e63af5da3400ace48a0345117980473fd21ad73", "patch": "@@ -1,11 +0,0 @@\n-# `const_in_array_repeat_expressions`\n-\n-The tracking issue for this feature is: [#49147]\n-\n-[#49147]: https://github.com/rust-lang/rust/issues/49147\n-\n-------------------------\n-\n-Relaxes the rules for repeat expressions, `[x; N]` such that `x` may also be `const` (strictly\n-speaking rvalue promotable), in addition to `typeof(x): Copy`. The result of `[x; N]` where `x` is\n-`const` is itself also `const`."}, {"sha": "25463ea5ee84155c55eb3b6d11dd90164c449b35", "filename": "src/test/ui/array-slice-vec/repeat_empty_ok.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Farray-slice-vec%2Frepeat_empty_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Farray-slice-vec%2Frepeat_empty_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Frepeat_empty_ok.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,15 @@\n+#![crate_type = \"lib\"]\n+\n+pub struct Header<'a> {\n+    pub value: &'a [u8],\n+}\n+\n+pub fn test() {\n+    let headers = [Header{value: &[]}; 128];\n+    //~^ ERROR the trait bound\n+}\n+\n+pub fn test2() {\n+    let headers = [Header{value: &[0]}; 128];\n+    //~^ ERROR the trait bound\n+}"}, {"sha": "85baa1268bf048c9e44421945d39d74e64642ef4", "filename": "src/test/ui/array-slice-vec/repeat_empty_ok.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Farray-slice-vec%2Frepeat_empty_ok.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Farray-slice-vec%2Frepeat_empty_ok.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Frepeat_empty_ok.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `Header<'_>: Copy` is not satisfied\n+  --> $DIR/repeat_empty_ok.rs:8:19\n+   |\n+LL |     let headers = [Header{value: &[]}; 128];\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `Header<'_>`\n+   |\n+   = note: the `Copy` trait is required because the repeated element will be copied\n+\n+error[E0277]: the trait bound `Header<'_>: Copy` is not satisfied\n+  --> $DIR/repeat_empty_ok.rs:13:19\n+   |\n+LL |     let headers = [Header{value: &[0]}; 128];\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `Header<'_>`\n+   |\n+   = note: the `Copy` trait is required because the repeated element will be copied\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "1007fb582e5eda6e68f00f04f22fadd569b233fb", "filename": "src/test/ui/closures/2229_closure_analysis/by_value.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,41 @@\n+// Test that we handle derferences properly when only some of the captures are being moved with\n+// `capture_disjoint_fields` enabled.\n+\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug, Default)]\n+struct SomeLargeType;\n+struct MuchLargerType([SomeLargeType; 32]);\n+\n+// Ensure that we don't capture any derefs when moving captures into the closures,\n+// i.e. only data from the enclosing stack is moved.\n+fn big_box() {\n+    let s = MuchLargerType(Default::default());\n+    let b = Box::new(s);\n+    let t = (b, 10);\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        let p = t.0.0;\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n+        println!(\"{} {:?}\", t.1, p);\n+        //~^ NOTE: Capturing t[(1, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture t[(1, 0)] -> ImmBorrow\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    big_box();\n+}"}, {"sha": "fe04dbef6d8b55a56637bef5c78057e2981ebab1", "filename": "src/test/ui/closures/2229_closure_analysis/by_value.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,67 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/by_value.rs:22:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/by_value.rs:5:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/by_value.rs:25:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let p = t.0.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+  --> $DIR/by_value.rs:28:17\n+   |\n+LL |         let p = t.0.0;\n+   |                 ^^^^^\n+note: Capturing t[(1, 0)] -> ImmBorrow\n+  --> $DIR/by_value.rs:31:29\n+   |\n+LL |         println!(\"{} {:?}\", t.1, p);\n+   |                             ^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/by_value.rs:25:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let p = t.0.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[(0, 0)] -> ByValue\n+  --> $DIR/by_value.rs:28:17\n+   |\n+LL |         let p = t.0.0;\n+   |                 ^^^^^\n+note: Min Capture t[(1, 0)] -> ImmBorrow\n+  --> $DIR/by_value.rs:31:29\n+   |\n+LL |         println!(\"{} {:?}\", t.1, p);\n+   |                             ^^^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "1ea38e260b645d91d6ed09da639fbe57fbafa4e0", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/cant-mutate-imm-borrow.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,20 @@\n+// Test that if we deref an immutable borrow to access a Place,\n+// then we can't mutate the final place.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+fn main() {\n+    let mut x = (format!(\"\"), format!(\"X2\"));\n+    let mut y = (&x, \"Y\");\n+    let z = (&mut y, \"Z\");\n+\n+    // `x.0` is mutable but we access `x` via `z.0.0`, which is an immutable reference and\n+    // therefore can't be mutated.\n+    let mut c = || {\n+    //~^ ERROR: cannot borrow `z.0.0.0` as mutable, as it is behind a `&` reference\n+        z.0.0.0 = format!(\"X1\");\n+    };\n+\n+    c();\n+}"}, {"sha": "861bc44b78ded3a7c08c554d2796ec5e6546ee0c", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/cant-mutate-imm-borrow.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm-borrow.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,21 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/cant-mutate-imm-borrow.rs:4:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0596]: cannot borrow `z.0.0.0` as mutable, as it is behind a `&` reference\n+  --> $DIR/cant-mutate-imm-borrow.rs:14:17\n+   |\n+LL |     let mut c = || {\n+   |                 ^^ cannot borrow as mutable\n+LL |\n+LL |         z.0.0.0 = format!(\"X1\");\n+   |         - mutable borrow occurs due to use of `z.0.0.0` in closure\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "997ecc7ddddf1eb33048f08f50c2a8c48aa28205", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/cant-mutate-imm.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,35 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+// Ensure that diagnostics for mutability error (because the root variable\n+// isn't mutable) work with `capture_disjoint_fields` enabled.\n+\n+fn mut_error_struct() {\n+    let x = (10, 10);\n+    let y = (x, 10);\n+    let z = (y, 10);\n+\n+    let mut c = || {\n+        z.0.0.0 = 20;\n+        //~^ ERROR: cannot assign to `z`, as it is not declared as mutable\n+    };\n+\n+    c();\n+}\n+\n+fn mut_error_box() {\n+    let x = (10, 10);\n+    let bx = Box::new(x);\n+\n+    let mut c = || {\n+        bx.0 = 20;\n+        //~^ ERROR: cannot assign to `bx`, as it is not declared as mutable\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    mut_error_struct();\n+    mut_error_box();\n+}"}, {"sha": "5e15635ac6e1bf38f7c651c31aa06fd406e2e742", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/cant-mutate-imm.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fcant-mutate-imm.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,30 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/cant-mutate-imm.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0594]: cannot assign to `z`, as it is not declared as mutable\n+  --> $DIR/cant-mutate-imm.rs:13:9\n+   |\n+LL |     let z = (y, 10);\n+   |         - help: consider changing this to be mutable: `mut z`\n+...\n+LL |         z.0.0.0 = 20;\n+   |         ^^^^^^^^^^^^ cannot assign\n+\n+error[E0594]: cannot assign to `bx`, as it is not declared as mutable\n+  --> $DIR/cant-mutate-imm.rs:25:9\n+   |\n+LL |     let bx = Box::new(x);\n+   |         -- help: consider changing this to be mutable: `mut bx`\n+...\n+LL |         bx.0 = 20;\n+   |         ^^^^^^^^^ cannot assign\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0594`."}, {"sha": "676fde558dfbc684d81a732cef204de7effe072b", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/mut_ref.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,38 @@\n+// Test that we can't mutate a place if we need to deref an imm-borrow\n+// to reach it.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+fn imm_mut_ref() {\n+    let mut x = String::new();\n+    let y = String::new();\n+    let mref_x = &mut x;\n+    let ref_mref_x = &mref_x;\n+\n+    let c = || {\n+    //~^ ERROR: cannot borrow `**ref_mref_x` as mutable, as it is behind a `&` reference\n+        **ref_mref_x = y;\n+    };\n+\n+    c();\n+}\n+\n+fn mut_imm_ref() {\n+    let x = String::new();\n+    let y = String::new();\n+    let mut ref_x = &x;\n+    let mref_ref_x = &mut ref_x;\n+\n+    let c = || {\n+    //~^ ERROR: cannot borrow `**mref_ref_x` as mutable, as it is behind a `&` reference\n+        **mref_ref_x = y;\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    imm_mut_ref();\n+    mut_imm_ref();\n+}"}, {"sha": "8cb2ed2235d55395f2945d8e58b338e0c42226b1", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/mut_ref.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fmut_ref.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,33 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/mut_ref.rs:4:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0596]: cannot borrow `**ref_mref_x` as mutable, as it is behind a `&` reference\n+  --> $DIR/mut_ref.rs:13:13\n+   |\n+LL |     let ref_mref_x = &mref_x;\n+   |                      ------- help: consider changing this to be a mutable reference: `&mut mref_x`\n+LL | \n+LL |     let c = || {\n+   |             ^^ `ref_mref_x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n+LL |\n+LL |         **ref_mref_x = y;\n+   |           ---------- mutable borrow occurs due to use of `**ref_mref_x` in closure\n+\n+error[E0596]: cannot borrow `**mref_ref_x` as mutable, as it is behind a `&` reference\n+  --> $DIR/mut_ref.rs:27:13\n+   |\n+LL |     let c = || {\n+   |             ^^ cannot borrow as mutable\n+LL |\n+LL |         **mref_ref_x = y;\n+   |           ---------- mutable borrow occurs due to use of `**mref_ref_x` in closure\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "8bdc999ca3c3feade9f49922806945d452e0e01a", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,72 @@\n+// Test that move closures drop derefs with `capture_disjoint_fields` enabled.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+// Test we truncate derefs properly\n+fn simple_ref() {\n+    let mut s = 10;\n+    let ref_s = &mut s;\n+\n+    let mut c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    move || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        *ref_s += 10;\n+        //~^ NOTE: Capturing ref_s[Deref] -> ByValue\n+        //~| NOTE: Min Capture ref_s[] -> ByValue\n+    };\n+    c();\n+}\n+\n+// Test we truncate derefs properly\n+fn struct_contains_ref_to_another_struct() {\n+    struct S(String);\n+    struct T<'a>(&'a mut S);\n+\n+    let mut s = S(\"s\".into());\n+    let t = T(&mut s);\n+\n+    let mut c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    move || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        t.0.0 = \"new s\".into();\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n+    };\n+\n+    c();\n+}\n+\n+// Test that we don't reduce precision when there is nothing deref.\n+fn no_ref() {\n+    struct S(String);\n+    struct T(S);\n+\n+    let t = T(S(\"s\".into()));\n+    let mut c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    move || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        t.0.0 = \"new S\".into();\n+        //~^ NOTE: Capturing t[(0, 0),(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture t[(0, 0),(0, 0)] -> ByValue\n+    };\n+    c();\n+}\n+\n+fn main() {\n+    simple_ref();\n+    struct_contains_ref_to_another_struct();\n+    no_ref();\n+}"}, {"sha": "a745f14598ee2b022f10352b34f729970e223745", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.stderr", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,147 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:14:17\n+   |\n+LL |     let mut c = #[rustc_capture_analysis]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:35:17\n+   |\n+LL |     let mut c = #[rustc_capture_analysis]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:55:17\n+   |\n+LL |     let mut c = #[rustc_capture_analysis]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/move_closure.rs:3:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:17:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         *ref_s += 10;\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing ref_s[Deref] -> ByValue\n+  --> $DIR/move_closure.rs:20:9\n+   |\n+LL |         *ref_s += 10;\n+   |         ^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:17:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         *ref_s += 10;\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture ref_s[] -> ByValue\n+  --> $DIR/move_closure.rs:20:9\n+   |\n+LL |         *ref_s += 10;\n+   |         ^^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:38:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         t.0.0 = \"new s\".into();\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:41:9\n+   |\n+LL |         t.0.0 = \"new s\".into();\n+   |         ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:38:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         t.0.0 = \"new s\".into();\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:41:9\n+   |\n+LL |         t.0.0 = \"new s\".into();\n+   |         ^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:58:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         t.0.0 = \"new S\".into();\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:61:9\n+   |\n+LL |         t.0.0 = \"new S\".into();\n+   |         ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:58:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         t.0.0 = \"new S\".into();\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[(0, 0),(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:61:9\n+   |\n+LL |         t.0.0 = \"new S\".into();\n+   |         ^^^^^\n+\n+error: aborting due to 9 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "9a93e6cf1e1efd787734c446d3f9105281838ea6", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/by_value.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fby_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fby_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fby_value.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,28 @@\n+// run-pass\n+\n+// Test that ByValue captures compile sucessefully especially when the captures are\n+// derefenced within the closure.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+#[derive(Debug, Default)]\n+struct SomeLargeType;\n+struct MuchLargerType([SomeLargeType; 32]);\n+\n+fn big_box() {\n+    let s = MuchLargerType(Default::default());\n+    let b = Box::new(s);\n+    let t = (b, 10);\n+\n+    let c = || {\n+        let p = t.0.0;\n+        println!(\"{} {:?}\", t.1, p);\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    big_box();\n+}"}, {"sha": "98715c6b9436589e991cef711ef2a847ad29cde3", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/by_value.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fby_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fby_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fby_value.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/by_value.rs:6:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "4007a5a48aaecb4d94efedec5dc465996653a36c", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/move_closure.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,64 @@\n+// run-pass\n+\n+// Test that move closures compile properly with `capture_disjoint_fields` enabled.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+fn simple_ref() {\n+    let mut s = 10;\n+    let ref_s = &mut s;\n+\n+    let mut c = move || {\n+        *ref_s += 10;\n+    };\n+    c();\n+}\n+\n+fn struct_contains_ref_to_another_struct() {\n+    struct S(String);\n+    struct T<'a>(&'a mut S);\n+\n+    let mut s = S(\"s\".into());\n+    let t = T(&mut s);\n+\n+    let mut c = move || {\n+        t.0.0 = \"new s\".into();\n+    };\n+\n+    c();\n+}\n+\n+#[derive(Debug)]\n+struct S(String);\n+\n+#[derive(Debug)]\n+struct T(S);\n+\n+fn no_ref() {\n+    let mut t = T(S(\"s\".into()));\n+    let mut c = move || {\n+        t.0.0 = \"new S\".into();\n+    };\n+    c();\n+}\n+\n+fn no_ref_nested() {\n+    let mut t = T(S(\"s\".into()));\n+    let c = || {\n+        println!(\"{:?}\", t.0);\n+        let mut c = move || {\n+            t.0.0 = \"new S\".into();\n+            println!(\"{:?}\", t.0.0);\n+        };\n+        c();\n+    };\n+    c();\n+}\n+\n+fn main() {\n+    simple_ref();\n+    struct_contains_ref_to_another_struct();\n+    no_ref();\n+    no_ref_nested();\n+}"}, {"sha": "c1d8ba575d6fd0bcbf428d25ac4f6525a55c7683", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/move_closure.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/move_closure.rs:5:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "315622443c3cc83da55341277c9cf7a3e66ff6cc", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/mut_ref.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,56 @@\n+// run-pass\n+\n+// Test that we can mutate a place through a mut-borrow\n+// that is captured by the closure\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+// Check that we can mutate when one deref is required\n+fn mut_ref_1() {\n+    let mut x = String::new();\n+    let rx = &mut x;\n+\n+    let mut c = || {\n+        *rx = String::new();\n+    };\n+\n+    c();\n+}\n+\n+// Similar example as mut_ref_1, we don't deref the imm-borrow here,\n+// and so we are allowed to mutate.\n+fn mut_ref_2() {\n+    let x = String::new();\n+    let y = String::new();\n+    let mut ref_x = &x;\n+    let m_ref_x = &mut ref_x;\n+\n+    let mut c = || {\n+        *m_ref_x = &y;\n+    };\n+\n+    c();\n+}\n+\n+// Check that we can mutate when multiple derefs of mut-borrows are required to reach\n+// the target place.\n+// It works because all derefs are mutable, if either of them was an immutable\n+// borrow, then we would not be able to deref.\n+fn mut_mut_ref() {\n+    let mut x = String::new();\n+    let mut mref_x = &mut x;\n+    let m_mref_x = &mut mref_x;\n+\n+    let mut c = || {\n+        **m_mref_x = String::new();\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    mut_ref_1();\n+    mut_ref_2();\n+    mut_mut_ref();\n+}"}, {"sha": "4b37a0b405f5e0a485a8b9c7cfbdaa756e07ce5f", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/mut_ref.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/mut_ref.rs:6:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "2dba923647a2e6f4044a08ad8f467af054e77b98", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/mut_ref_struct_mem.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref_struct_mem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref_struct_mem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref_struct_mem.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,45 @@\n+// run-pass\n+\n+// Test that we can mutate a place through a mut-borrow\n+// that is captured by the closure\n+\n+// More specifically we test that the if the mutable reference isn't root variable of a capture\n+// but rather accessed while acessing the precise capture.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+fn mut_tuple() {\n+    let mut t = (10, 10);\n+\n+    let t1 = (&mut t, 10);\n+\n+    let mut c = || {\n+        // Mutable because (*t.0) is mutable\n+        t1.0.0 += 10;\n+    };\n+\n+    c();\n+}\n+\n+fn mut_tuple_nested() {\n+    let mut t = (10, 10);\n+\n+    let t1 = (&mut t, 10);\n+\n+    let mut c = || {\n+        let mut c = || {\n+            // Mutable because (*t.0) is mutable\n+            t1.0.0 += 10;\n+        };\n+\n+        c();\n+    };\n+\n+    c();\n+}\n+\n+fn main() {\n+    mut_tuple();\n+    mut_tuple_nested();\n+}"}, {"sha": "418ab29098b2a59b89bcf8727446b40cdcb0059b", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/mut_ref_struct_mem.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref_struct_mem.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref_struct_mem.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmut_ref_struct_mem.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/mut_ref_struct_mem.rs:9:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "f6e9862b26c11d7fafb2af139c1b1534e1d42444", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/unsafe_ptr.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Funsafe_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Funsafe_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Funsafe_ptr.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,47 @@\n+// run-pass\n+\n+// Test that we can use raw ptrs when using `capture_disjoint_fields`.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+\n+#[derive(Debug)]\n+struct S {\n+    s: String,\n+    t: String,\n+}\n+\n+struct T(*const S);\n+\n+fn unsafe_imm() {\n+    let s = \"\".into();\n+    let t = \"\".into();\n+    let my_speed: Box<S> = Box::new(S { s, t });\n+\n+    let p : *const S = Box::into_raw(my_speed);\n+    let t = T(p);\n+\n+    let c = || unsafe {\n+        println!(\"{:?}\", (*t.0).s);\n+    };\n+\n+    c();\n+}\n+\n+fn unsafe_mut() {\n+    let s = \"\".into();\n+    let t = \"\".into();\n+    let mut my_speed: Box<S> = Box::new(S { s, t });\n+    let p : *mut S = &mut *my_speed;\n+\n+    let c = || {\n+        let x = unsafe { &mut (*p).s };\n+        *x = \"s\".into();\n+    };\n+    c();\n+}\n+\n+fn main() {\n+    unsafe_mut();\n+    unsafe_imm();\n+}"}, {"sha": "c64c8b72e81512fc16d10467ca233e7c7fd5c8fe", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/unsafe_ptr.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Funsafe_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Funsafe_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Funsafe_ptr.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/unsafe_ptr.rs:5:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "79d3ecc2d2bedfeefa1e5469a8a683f100be1167", "filename": "src/test/ui/closures/2229_closure_analysis/unsafe_ptr.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Funsafe_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Funsafe_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Funsafe_ptr.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,63 @@\n+// Test that we restrict precision of a capture when we access a raw ptr,\n+// i.e. the capture doesn't deref the raw ptr.\n+\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| `#[warn(incomplete_features)]` on by default\n+//~| see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+#[derive(Debug)]\n+struct S {\n+    s: String,\n+    t: String,\n+}\n+\n+struct T(*const S);\n+\n+fn unsafe_imm() {\n+    let s = \"\".into();\n+    let t = \"\".into();\n+    let my_speed: Box<S> = Box::new(S { s, t });\n+\n+    let p : *const S = Box::into_raw(my_speed);\n+    let t = T(p);\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+     || unsafe {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        println!(\"{:?}\", (*t.0).s);\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture t[(0, 0)] -> ImmBorrow\n+    };\n+\n+    c();\n+}\n+\n+fn unsafe_mut() {\n+    let s = \"\".into();\n+    let t = \"\".into();\n+    let mut my_speed: Box<S> = Box::new(S { s, t });\n+    let p : *mut S = &mut *my_speed;\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let x = unsafe { &mut (*p).s };\n+        //~^ NOTE: Capturing p[Deref,(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture p[] -> ImmBorrow\n+        *x = \"s\".into();\n+    };\n+    c();\n+}\n+\n+fn main() {\n+    unsafe_mut();\n+    unsafe_imm();\n+}"}, {"sha": "4508b2426e8ff8d29596dd496fa882663848f9c8", "filename": "src/test/ui/closures/2229_closure_analysis/unsafe_ptr.stderr", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Funsafe_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Funsafe_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Funsafe_ptr.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,102 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/unsafe_ptr.rs:26:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/unsafe_ptr.rs:46:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/unsafe_ptr.rs:4:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/unsafe_ptr.rs:29:6\n+   |\n+LL | /      || unsafe {\n+LL | |\n+LL | |\n+LL | |         println!(\"{:?}\", (*t.0).s);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/unsafe_ptr.rs:32:26\n+   |\n+LL |         println!(\"{:?}\", (*t.0).s);\n+   |                          ^^^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/unsafe_ptr.rs:29:6\n+   |\n+LL | /      || unsafe {\n+LL | |\n+LL | |\n+LL | |         println!(\"{:?}\", (*t.0).s);\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[(0, 0)] -> ImmBorrow\n+  --> $DIR/unsafe_ptr.rs:32:26\n+   |\n+LL |         println!(\"{:?}\", (*t.0).s);\n+   |                          ^^^^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/unsafe_ptr.rs:49:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = unsafe { &mut (*p).s };\n+...  |\n+LL | |         *x = \"s\".into();\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing p[Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/unsafe_ptr.rs:52:31\n+   |\n+LL |         let x = unsafe { &mut (*p).s };\n+   |                               ^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/unsafe_ptr.rs:49:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         let x = unsafe { &mut (*p).s };\n+...  |\n+LL | |         *x = \"s\".into();\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture p[] -> ImmBorrow\n+  --> $DIR/unsafe_ptr.rs:52:31\n+   |\n+LL |         let x = unsafe { &mut (*p).s };\n+   |                               ^^^^^^\n+\n+error: aborting due to 6 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "78dee1717f1fade104a9b6e0a931b8b7bb449e16", "filename": "src/test/ui/const-generics/issue-71202.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconst-generics%2Fissue-71202.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconst-generics%2Fissue-71202.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-71202.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,33 @@\n+// check-pass\n+\n+#![feature(const_generics)]\n+#![allow(incomplete_features, const_evaluatable_unchecked)]\n+\n+use std::marker::PhantomData;\n+\n+struct DataHolder<T> {\n+    item: T,\n+}\n+\n+impl<T: Copy> DataHolder<T> {\n+    const ITEM_IS_COPY: [(); 1 - {\n+        trait NotCopy {\n+            const VALUE: bool = false;\n+        }\n+\n+        impl<__Type: ?Sized> NotCopy for __Type {}\n+\n+        struct IsCopy<__Type: ?Sized>(PhantomData<__Type>);\n+\n+        impl<__Type> IsCopy<__Type>\n+        where\n+            __Type: Sized + Copy,\n+        {\n+            const VALUE: bool = true;\n+        }\n+\n+        <IsCopy<T>>::VALUE\n+    } as usize] = [];\n+}\n+\n+fn main() {}"}, {"sha": "65d02317d34c57a0482fef35d2d35f94166b861d", "filename": "src/test/ui/consts/const-blocks/const-repeat.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fconst-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fconst-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fconst-repeat.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "previous_filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/const-repeat.rs"}, {"sha": "7936af75d84ac585af4af9a834b3da8ba0cbec90", "filename": "src/test/ui/consts/const-blocks/fn-call-in-const.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ffn-call-in-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ffn-call-in-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ffn-call-in-const.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,7 +1,7 @@\n // run-pass\n \n-#![allow(unused)]\n-#![feature(const_in_array_repeat_expressions)]\n+#![feature(inline_const)]\n+#![allow(unused, incomplete_features)]\n \n // Some type that is not copyable.\n struct Bar;\n@@ -18,6 +18,6 @@ const _: [u32; 2] = [type_copy(); 2];\n \n // This is allowed because all promotion contexts use the explicit rules for promotability when\n // inside an explicit const context.\n-const _: [Option<Bar>; 2] = [type_no_copy(); 2];\n+const _: [Option<Bar>; 2] = [const { type_no_copy() }; 2];\n \n fn main() {}", "previous_filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/fn-call-in-const.rs"}, {"sha": "19217843759c1a31cea0ea2f1bd3f821a8d5c7df", "filename": "src/test/ui/consts/const-blocks/fn-call-in-non-const.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ffn-call-in-non-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ffn-call-in-non-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ffn-call-in-non-const.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,5 +1,3 @@\n-#![feature(const_in_array_repeat_expressions)]\n-\n // Some type that is not copyable.\n struct Bar;\n ", "previous_filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/fn-call-in-non-const.rs"}, {"sha": "b75452cd2170270397af16e805148c89a05b8d36", "filename": "src/test/ui/consts/const-blocks/fn-call-in-non-const.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ffn-call-in-non-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ffn-call-in-non-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ffn-call-in-non-const.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `Option<Bar>: Copy` is not satisfied\n-  --> $DIR/fn-call-in-non-const.rs:16:31\n+  --> $DIR/fn-call-in-non-const.rs:14:31\n    |\n LL |     let _: [Option<Bar>; 2] = [no_copy(); 2];\n    |                               ^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `Option<Bar>`", "previous_filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/fn-call-in-non-const.stderr"}, {"sha": "bb12139a7bae93f4ffaf8eadeeae27beb6adb45b", "filename": "src/test/ui/consts/const-blocks/migrate-fail.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fmigrate-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fmigrate-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fmigrate-fail.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,6 +1,5 @@\n // ignore-compare-mode-nll\n // compile-flags: -Z borrowck=migrate\n-#![feature(const_in_array_repeat_expressions)]\n #![allow(warnings)]\n \n // Some type that is not copyable.", "previous_filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/migrate-fail.rs"}, {"sha": "0fdbbc36288e9c80f60e50f6913b5ae04bd43edf", "filename": "src/test/ui/consts/const-blocks/migrate-fail.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fmigrate-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fmigrate-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fmigrate-fail.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `Option<Bar>: Copy` is not satisfied\n-  --> $DIR/migrate-fail.rs:14:37\n+  --> $DIR/migrate-fail.rs:13:37\n    |\n LL |         let arr: [Option<Bar>; 2] = [x; 2];\n    |                                     ^^^^^^ the trait `Copy` is not implemented for `Option<Bar>`\n@@ -9,7 +9,7 @@ LL |         let arr: [Option<Bar>; 2] = [x; 2];\n    = note: the `Copy` trait is required because the repeated element will be copied\n \n error[E0277]: the trait bound `Option<Bar>: Copy` is not satisfied\n-  --> $DIR/migrate-fail.rs:20:37\n+  --> $DIR/migrate-fail.rs:19:37\n    |\n LL |         let arr: [Option<Bar>; 2] = [x; 2];\n    |                                     ^^^^^^ the trait `Copy` is not implemented for `Option<Bar>`", "previous_filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/migrate-fail.stderr"}, {"sha": "3195717fa38bac32d5bb4aa25b29736be24081a2", "filename": "src/test/ui/consts/const-blocks/migrate-pass.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fmigrate-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fmigrate-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fmigrate-pass.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,7 +1,6 @@\n // check-pass\n // compile-flags: -Z borrowck=migrate\n // ignore-compare-mode-nll\n-#![feature(const_in_array_repeat_expressions)]\n #![allow(warnings)]\n \n // Some type that is not copyable.", "previous_filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/migrate-pass.rs"}, {"sha": "871387c1fd0cf9ffce619f87568c7395decf1bc1", "filename": "src/test/ui/consts/const-blocks/nll-fail.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fnll-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fnll-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fnll-fail.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,5 +1,4 @@\n // ignore-compare-mode-nll\n-#![feature(const_in_array_repeat_expressions, nll)]\n #![allow(warnings)]\n \n // Some type that is not copyable.", "previous_filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/nll-fail.rs"}, {"sha": "81220856359778d9070432698e92b1bf5cbef1fb", "filename": "src/test/ui/consts/const-blocks/nll-fail.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fnll-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fnll-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fnll-fail.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `Option<Bar>: Copy` is not satisfied\n-  --> $DIR/nll-fail.rs:13:37\n+  --> $DIR/nll-fail.rs:12:37\n    |\n LL |         let arr: [Option<Bar>; 2] = [x; 2];\n    |                                     ^^^^^^ the trait `Copy` is not implemented for `Option<Bar>`\n@@ -9,7 +9,7 @@ LL |         let arr: [Option<Bar>; 2] = [x; 2];\n    = note: the `Copy` trait is required because the repeated element will be copied\n \n error[E0277]: the trait bound `Option<Bar>: Copy` is not satisfied\n-  --> $DIR/nll-fail.rs:19:37\n+  --> $DIR/nll-fail.rs:18:37\n    |\n LL |         let arr: [Option<Bar>; 2] = [x; 2];\n    |                                     ^^^^^^ the trait `Copy` is not implemented for `Option<Bar>`", "previous_filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/nll-fail.stderr"}, {"sha": "d8defa19483e127fe3cf4aabc7de299dfa43d85b", "filename": "src/test/ui/consts/const-blocks/nll-pass.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fnll-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fnll-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fnll-pass.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,7 +1,6 @@\n // check-pass\n // ignore-compare-mode-nll\n #![allow(warnings)]\n-#![feature(const_in_array_repeat_expressions, nll)]\n \n // Some type that is not copyable.\n struct Bar;", "previous_filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/nll-pass.rs"}, {"sha": "e11f69babf79876afa4a892d563cb9eb38d48a36", "filename": "src/test/ui/consts/const-blocks/run-pass.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Frun-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Frun-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Frun-pass.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-#![feature(const_in_array_repeat_expressions)]\n \n #[derive(Debug, Eq, PartialEq)]\n struct Bar;", "previous_filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/run-pass.rs"}, {"sha": "5a614cbdd15619c3867ffe6251da3b1339a2df1b", "filename": "src/test/ui/consts/const-blocks/trait-error.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ftrait-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ftrait-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ftrait-error.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,5 +1,3 @@\n-#![feature(const_in_array_repeat_expressions)]\n-\n #[derive(Copy, Clone)]\n struct Foo<T>(T);\n ", "previous_filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/trait-error.rs"}, {"sha": "26e2848e7f7a1bbb41106988641c807a82f2e084", "filename": "src/test/ui/consts/const-blocks/trait-error.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ftrait-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ftrait-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ftrait-error.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `Foo<String>: Copy` is not satisfied\n-  --> $DIR/trait-error.rs:7:5\n+  --> $DIR/trait-error.rs:5:5\n    |\n LL |     [Foo(String::new()); 4];\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `Foo<String>`", "previous_filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/trait-error.stderr"}, {"sha": "5ed302bbff3aa14feb6c971f14f596f2336c86d9", "filename": "src/test/ui/feature-gates/feature-gate-const_in_array_repeat_expressions.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0e63af5da3400ace48a0345117980473fd21ad73/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_in_array_repeat_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e63af5da3400ace48a0345117980473fd21ad73/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_in_array_repeat_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_in_array_repeat_expressions.rs?ref=0e63af5da3400ace48a0345117980473fd21ad73", "patch": "@@ -1,17 +0,0 @@\n-#![allow(warnings)]\n-\n-struct Bar;\n-\n-// This function would compile with the feature gate, and tests that it is suggested.\n-fn foo() {\n-    let arr: [Option<String>; 2] = [None::<String>; 2];\n-    //~^ ERROR the trait bound `Option<String>: Copy` is not satisfied [E0277]\n-}\n-\n-// This function would not compile with the feature gate, and tests that it is not suggested.\n-fn bar() {\n-    let arr: [Option<String>; 2] = [Some(\"foo\".to_string()); 2];\n-    //~^ ERROR the trait bound `Option<String>: Copy` is not satisfied [E0277]\n-}\n-\n-fn main() {}"}, {"sha": "ca1706169afc6e867e355d9c12e328809581e7c9", "filename": "src/test/ui/feature-gates/feature-gate-const_in_array_repeat_expressions.stderr", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0e63af5da3400ace48a0345117980473fd21ad73/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_in_array_repeat_expressions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e63af5da3400ace48a0345117980473fd21ad73/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_in_array_repeat_expressions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_in_array_repeat_expressions.stderr?ref=0e63af5da3400ace48a0345117980473fd21ad73", "patch": "@@ -1,25 +0,0 @@\n-error[E0277]: the trait bound `Option<String>: Copy` is not satisfied\n-  --> $DIR/feature-gate-const_in_array_repeat_expressions.rs:7:36\n-   |\n-LL |     let arr: [Option<String>; 2] = [None::<String>; 2];\n-   |                                    ^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `Option<String>`\n-   |\n-   = help: the following implementations were found:\n-             <Option<T> as Copy>\n-   = note: the `Copy` trait is required because the repeated element will be copied\n-   = note: this array initializer can be evaluated at compile-time, see issue #49147 <https://github.com/rust-lang/rust/issues/49147> for more information\n-   = help: add `#![feature(const_in_array_repeat_expressions)]` to the crate attributes to enable\n-\n-error[E0277]: the trait bound `Option<String>: Copy` is not satisfied\n-  --> $DIR/feature-gate-const_in_array_repeat_expressions.rs:13:36\n-   |\n-LL |     let arr: [Option<String>; 2] = [Some(\"foo\".to_string()); 2];\n-   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `Option<String>`\n-   |\n-   = help: the following implementations were found:\n-             <Option<T> as Copy>\n-   = note: the `Copy` trait is required because the repeated element will be copied\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0277`."}, {"sha": "98b408daa022de8351b14b01ee1f730e4cf36f40", "filename": "src/test/ui/suggestions/non-existent-field-present-in-subfield-recursion-limit.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield-recursion-limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield-recursion-limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield-recursion-limit.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,43 @@\n+// In rustc_typeck::check::expr::no_such_field_err we recursively\n+// look in subfields for the field. This recursive search is limited\n+// in depth for compile-time reasons and to avoid infinite recursion\n+// in case of cycles. This file tests that the limit in the recursion\n+// depth is enforced.\n+\n+struct Foo {\n+    first: Bar,\n+    second: u32,\n+    third: u32,\n+}\n+\n+struct Bar {\n+    bar: C,\n+}\n+\n+struct C {\n+    c: D,\n+}\n+\n+struct D {\n+    test: E,\n+}\n+\n+struct E {\n+    e: F,\n+}\n+\n+struct F {\n+    f: u32,\n+}\n+\n+fn main() {\n+    let f = F { f: 6 };\n+    let e = E { e: f };\n+    let d = D { test: e };\n+    let c = C { c: d };\n+    let bar = Bar { bar: c };\n+    let fooer = Foo { first: bar, second: 4, third: 5 };\n+\n+    let test = fooer.f;\n+    //~^ ERROR no field\n+}"}, {"sha": "b294f4da7db33394e61631e6bfbfb214bd71505d", "filename": "src/test/ui/suggestions/non-existent-field-present-in-subfield-recursion-limit.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield-recursion-limit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield-recursion-limit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield-recursion-limit.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,11 @@\n+error[E0609]: no field `f` on type `Foo`\n+  --> $DIR/non-existent-field-present-in-subfield-recursion-limit.rs:41:22\n+   |\n+LL |     let test = fooer.f;\n+   |                      ^ unknown field\n+   |\n+   = note: available fields are: `first`, `second`, `third`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0609`."}, {"sha": "167548a89defa0d74a2af619e70e2f81d68f7e74", "filename": "src/test/ui/suggestions/non-existent-field-present-in-subfield.fixed", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.fixed?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,42 @@\n+// run-rustfix\n+\n+struct Foo {\n+    first: Bar,\n+    _second: u32,\n+    _third: u32,\n+}\n+\n+struct Bar {\n+    bar: C,\n+}\n+\n+struct C {\n+    c: D,\n+}\n+\n+struct D {\n+    test: E,\n+}\n+\n+struct E {\n+    _e: F,\n+}\n+\n+struct F {\n+    _f: u32,\n+}\n+\n+fn main() {\n+    let f = F { _f: 6 };\n+    let e = E { _e: f };\n+    let d = D { test: e };\n+    let c = C { c: d };\n+    let bar = Bar { bar: c };\n+    let fooer = Foo { first: bar, _second: 4, _third: 5 };\n+\n+    let _test = &fooer.first.bar.c;\n+    //~^ ERROR no field\n+\n+    let _test2 = fooer.first.bar.c.test;\n+    //~^ ERROR no field\n+}"}, {"sha": "81cc1af4dff52f40f9b34d2e2559547128a03f5f", "filename": "src/test/ui/suggestions/non-existent-field-present-in-subfield.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,42 @@\n+// run-rustfix\n+\n+struct Foo {\n+    first: Bar,\n+    _second: u32,\n+    _third: u32,\n+}\n+\n+struct Bar {\n+    bar: C,\n+}\n+\n+struct C {\n+    c: D,\n+}\n+\n+struct D {\n+    test: E,\n+}\n+\n+struct E {\n+    _e: F,\n+}\n+\n+struct F {\n+    _f: u32,\n+}\n+\n+fn main() {\n+    let f = F { _f: 6 };\n+    let e = E { _e: f };\n+    let d = D { test: e };\n+    let c = C { c: d };\n+    let bar = Bar { bar: c };\n+    let fooer = Foo { first: bar, _second: 4, _third: 5 };\n+\n+    let _test = &fooer.c;\n+    //~^ ERROR no field\n+\n+    let _test2 = fooer.test;\n+    //~^ ERROR no field\n+}"}, {"sha": "ddb7476ec6e34b4a355ea11003cc0e1e215bff08", "filename": "src/test/ui/suggestions/non-existent-field-present-in-subfield.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnon-existent-field-present-in-subfield.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -0,0 +1,27 @@\n+error[E0609]: no field `c` on type `Foo`\n+  --> $DIR/non-existent-field-present-in-subfield.rs:37:24\n+   |\n+LL |     let _test = &fooer.c;\n+   |                        ^ unknown field\n+   |\n+   = note: available fields are: `first`, `_second`, `_third`\n+help: one of the expressions' fields has a field of the same name\n+   |\n+LL |     let _test = &fooer.first.bar.c;\n+   |                        ^^^^^^^^^^\n+\n+error[E0609]: no field `test` on type `Foo`\n+  --> $DIR/non-existent-field-present-in-subfield.rs:40:24\n+   |\n+LL |     let _test2 = fooer.test;\n+   |                        ^^^^ unknown field\n+   |\n+   = note: available fields are: `first`, `_second`, `_third`\n+help: one of the expressions' fields has a field of the same name\n+   |\n+LL |     let _test2 = fooer.first.bar.c.test;\n+   |                        ^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0609`."}, {"sha": "c96c907318ce93c67162f579e5ef5e490fcba4d3", "filename": "src/test/ui/unused/unused-closure.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Funused%2Funused-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Funused%2Funused-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funused%2Funused-closure.rs?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -2,7 +2,6 @@\n // edition:2018\n \n #![feature(async_closure)]\n-#![feature(const_in_array_repeat_expressions)]\n #![feature(generators)]\n #![deny(unused_must_use)]\n \n@@ -18,10 +17,6 @@ fn unused() {\n \n     [Box::new([|| {}; 10]); 1]; //~ ERROR unused array of boxed arrays of closures that must be used\n \n-    [|| { //~ ERROR unused array of generators that must be used\n-        yield 42u32;\n-    }; 42];\n-\n     vec![|| \"a\"].pop().unwrap(); //~ ERROR unused closure that must be used\n \n     let b = false;"}, {"sha": "265d3e8e075fdc71c5944ff1da06d4d78bbc2c36", "filename": "src/test/ui/unused/unused-closure.stderr", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Funused%2Funused-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941343e0871dd04ea774e8cee7755461b144ef29/src%2Ftest%2Fui%2Funused%2Funused-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funused%2Funused-closure.stderr?ref=941343e0871dd04ea774e8cee7755461b144ef29", "patch": "@@ -1,75 +1,65 @@\n error: unused closure that must be used\n-  --> $DIR/unused-closure.rs:10:5\n+  --> $DIR/unused-closure.rs:9:5\n    |\n LL | /     || {\n LL | |         println!(\"Hello!\");\n LL | |     };\n    | |______^\n    |\n note: the lint level is defined here\n-  --> $DIR/unused-closure.rs:7:9\n+  --> $DIR/unused-closure.rs:6:9\n    |\n LL | #![deny(unused_must_use)]\n    |         ^^^^^^^^^^^^^^^\n    = note: closures are lazy and do nothing unless called\n \n error: unused implementer of `Future` that must be used\n-  --> $DIR/unused-closure.rs:14:5\n+  --> $DIR/unused-closure.rs:13:5\n    |\n LL |     async {};\n    |     ^^^^^^^^^\n    |\n    = note: futures do nothing unless you `.await` or poll them\n \n error: unused closure that must be used\n-  --> $DIR/unused-closure.rs:15:5\n+  --> $DIR/unused-closure.rs:14:5\n    |\n LL |     || async {};\n    |     ^^^^^^^^^^^^\n    |\n    = note: closures are lazy and do nothing unless called\n \n error: unused closure that must be used\n-  --> $DIR/unused-closure.rs:16:5\n+  --> $DIR/unused-closure.rs:15:5\n    |\n LL |     async || {};\n    |     ^^^^^^^^^^^^\n    |\n    = note: closures are lazy and do nothing unless called\n \n error: unused array of boxed arrays of closures that must be used\n-  --> $DIR/unused-closure.rs:19:5\n+  --> $DIR/unused-closure.rs:18:5\n    |\n LL |     [Box::new([|| {}; 10]); 1];\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: closures are lazy and do nothing unless called\n \n-error: unused array of generators that must be used\n-  --> $DIR/unused-closure.rs:21:5\n-   |\n-LL | /     [|| {\n-LL | |         yield 42u32;\n-LL | |     }; 42];\n-   | |___________^\n-   |\n-   = note: generators are lazy and do nothing unless resumed\n-\n error: unused closure that must be used\n-  --> $DIR/unused-closure.rs:25:5\n+  --> $DIR/unused-closure.rs:20:5\n    |\n LL |     vec![|| \"a\"].pop().unwrap();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: closures are lazy and do nothing unless called\n \n error: unused closure that must be used\n-  --> $DIR/unused-closure.rs:28:9\n+  --> $DIR/unused-closure.rs:23:9\n    |\n LL |         || true;\n    |         ^^^^^^^^\n    |\n    = note: closures are lazy and do nothing unless called\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 7 previous errors\n "}]}