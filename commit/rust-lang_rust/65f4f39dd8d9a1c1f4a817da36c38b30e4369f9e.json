{"sha": "65f4f39dd8d9a1c1f4a817da36c38b30e4369f9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZjRmMzlkZDhkOWExYzFmNGE4MTdkYTM2YzM4YjMwZTQzNjlmOWU=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-20T19:28:20Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-20T20:05:41Z"}, "message": "Get rid of `locate()` in markdown handling\n\nThis function was unfortunate for several reasons:\n\n- It used `unsafe` because it wanted to tell whether a string came from\n  the same *allocation* as another, not just whether it was a textual\n  match.\n- It recalculated spans even though they were already available from\n  pulldown\n- It sometimes *failed* to calculate the span, which meant it was always\n  possible for the span to be `None`, even though in practice that\n  should never happen.\n\nThis commit has several cleanups:\n\n- Make the span required\n- Pass through the span from pulldown in the `HeadingLinks` and\n  `Footnotes` iterators\n- Only add iterator bounds on the `impl Iterator`, not on `new` and the\n  struct itself.", "tree": {"sha": "8decd9094edfb1bcdfc9d62a843f655e8083c6b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8decd9094edfb1bcdfc9d62a843f655e8083c6b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65f4f39dd8d9a1c1f4a817da36c38b30e4369f9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65f4f39dd8d9a1c1f4a817da36c38b30e4369f9e", "html_url": "https://github.com/rust-lang/rust/commit/65f4f39dd8d9a1c1f4a817da36c38b30e4369f9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65f4f39dd8d9a1c1f4a817da36c38b30e4369f9e/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50a90975c0f78219db45d3bee0676a22695ec103", "url": "https://api.github.com/repos/rust-lang/rust/commits/50a90975c0f78219db45d3bee0676a22695ec103", "html_url": "https://github.com/rust-lang/rust/commit/50a90975c0f78219db45d3bee0676a22695ec103"}], "stats": {"total": 192, "additions": 90, "deletions": 102}, "files": [{"sha": "7600b63bb88596eafcd224c8c7b2153089d0e6d2", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 62, "deletions": 68, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/65f4f39dd8d9a1c1f4a817da36c38b30e4369f9e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65f4f39dd8d9a1c1f4a817da36c38b30e4369f9e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=65f4f39dd8d9a1c1f4a817da36c38b30e4369f9e", "patch": "@@ -447,61 +447,60 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n }\n \n /// Make headings links with anchor IDs and build up TOC.\n-struct HeadingLinks<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> {\n+struct HeadingLinks<'a, 'b, 'ids, I> {\n     inner: I,\n     toc: Option<&'b mut TocBuilder>,\n-    buf: VecDeque<Event<'a>>,\n+    buf: VecDeque<(Event<'a>, Range<usize>)>,\n     id_map: &'ids mut IdMap,\n }\n \n-impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> HeadingLinks<'a, 'b, 'ids, I> {\n+impl<'a, 'b, 'ids, I> HeadingLinks<'a, 'b, 'ids, I> {\n     fn new(iter: I, toc: Option<&'b mut TocBuilder>, ids: &'ids mut IdMap) -> Self {\n         HeadingLinks { inner: iter, toc, buf: VecDeque::new(), id_map: ids }\n     }\n }\n \n-impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, 'ids, I> {\n-    type Item = Event<'a>;\n+impl<'a, 'b, 'ids, I: Iterator<Item = (Event<'a>, Range<usize>)>> Iterator\n+    for HeadingLinks<'a, 'b, 'ids, I>\n+{\n+    type Item = (Event<'a>, Range<usize>);\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(e) = self.buf.pop_front() {\n             return Some(e);\n         }\n \n         let event = self.inner.next();\n-        if let Some(Event::Start(Tag::Heading(level))) = event {\n+        if let Some((Event::Start(Tag::Heading(level)), _)) = event {\n             let mut id = String::new();\n             for event in &mut self.inner {\n-                match &event {\n+                match event.0 {\n                     Event::End(Tag::Heading(..)) => break,\n                     Event::Text(text) | Event::Code(text) => {\n                         id.extend(text.chars().filter_map(slugify));\n                     }\n-                    _ => {}\n-                }\n-                match event {\n                     Event::Start(Tag::Link(_, _, _)) | Event::End(Tag::Link(..)) => {}\n-                    event => self.buf.push_back(event),\n+                    _ => self.buf.push_back(event),\n                 }\n             }\n             let id = self.id_map.derive(id);\n \n             if let Some(ref mut builder) = self.toc {\n                 let mut html_header = String::new();\n-                html::push_html(&mut html_header, self.buf.iter().cloned());\n+                html::push_html(&mut html_header, self.buf.iter().map(|(ev, _)| ev.clone()));\n                 let sec = builder.push(level as u32, html_header, id.clone());\n-                self.buf.push_front(Event::Html(format!(\"{} \", sec).into()));\n+                self.buf.push_front((Event::Html(format!(\"{} \", sec).into()), 0..0));\n             }\n \n-            self.buf.push_back(Event::Html(format!(\"</a></h{}>\", level).into()));\n+            self.buf.push_back((Event::Html(format!(\"</a></h{}>\", level).into()), 0..0));\n \n             let start_tags = format!(\n                 \"<h{level} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n                     <a href=\\\"#{id}\\\">\",\n                 id = id,\n                 level = level\n             );\n-            return Some(Event::Html(start_tags.into()));\n+            return Some((Event::Html(start_tags.into()), 0..0));\n         }\n         event\n     }\n@@ -575,39 +574,40 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for SummaryLine<'a, I> {\n \n /// Moves all footnote definitions to the end and add back links to the\n /// references.\n-struct Footnotes<'a, I: Iterator<Item = Event<'a>>> {\n+struct Footnotes<'a, I> {\n     inner: I,\n     footnotes: FxHashMap<String, (Vec<Event<'a>>, u16)>,\n }\n \n-impl<'a, I: Iterator<Item = Event<'a>>> Footnotes<'a, I> {\n+impl<'a, I> Footnotes<'a, I> {\n     fn new(iter: I) -> Self {\n         Footnotes { inner: iter, footnotes: FxHashMap::default() }\n     }\n+\n     fn get_entry(&mut self, key: &str) -> &mut (Vec<Event<'a>>, u16) {\n         let new_id = self.footnotes.keys().count() + 1;\n         let key = key.to_owned();\n         self.footnotes.entry(key).or_insert((Vec::new(), new_id as u16))\n     }\n }\n \n-impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n-    type Item = Event<'a>;\n+impl<'a, I: Iterator<Item = (Event<'a>, Range<usize>)>> Iterator for Footnotes<'a, I> {\n+    type Item = (Event<'a>, Range<usize>);\n \n     fn next(&mut self) -> Option<Self::Item> {\n         loop {\n             match self.inner.next() {\n-                Some(Event::FootnoteReference(ref reference)) => {\n+                Some((Event::FootnoteReference(ref reference), range)) => {\n                     let entry = self.get_entry(&reference);\n                     let reference = format!(\n                         \"<sup id=\\\"fnref{0}\\\"><a href=\\\"#fn{0}\\\">{0}</a></sup>\",\n                         (*entry).1\n                     );\n-                    return Some(Event::Html(reference.into()));\n+                    return Some((Event::Html(reference.into()), range));\n                 }\n-                Some(Event::Start(Tag::FootnoteDefinition(def))) => {\n+                Some((Event::Start(Tag::FootnoteDefinition(def)), _)) => {\n                     let mut content = Vec::new();\n-                    for event in &mut self.inner {\n+                    for (event, _) in &mut self.inner {\n                         if let Event::End(Tag::FootnoteDefinition(..)) = event {\n                             break;\n                         }\n@@ -638,7 +638,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n                             ret.push_str(\"</li>\");\n                         }\n                         ret.push_str(\"</ol></div>\");\n-                        return Some(Event::Html(ret.into()));\n+                        return Some((Event::Html(ret.into()), 0..0));\n                     } else {\n                         return None;\n                     }\n@@ -946,13 +946,14 @@ impl Markdown<'_> {\n         };\n \n         let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut replacer));\n+        let p = p.into_offset_iter();\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n-        let p = LinkReplacer::new(p, links);\n-        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n+        let p = LinkReplacer::new(p.map(|(ev, _)| ev), links);\n+        let p = CodeBlocks::new(p, codes, edition, playground);\n         html::push_html(&mut s, p);\n \n         s\n@@ -963,16 +964,16 @@ impl MarkdownWithToc<'_> {\n     crate fn into_string(self) -> String {\n         let MarkdownWithToc(md, mut ids, codes, edition, playground) = self;\n \n-        let p = Parser::new_ext(md, opts());\n+        let p = Parser::new_ext(md, opts()).into_offset_iter();\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let mut toc = TocBuilder::new();\n \n         {\n             let p = HeadingLinks::new(p, Some(&mut toc), &mut ids);\n-            let p = CodeBlocks::new(p, codes, edition, playground);\n             let p = Footnotes::new(p);\n+            let p = CodeBlocks::new(p.map(|(ev, _)| ev), codes, edition, playground);\n             html::push_html(&mut s, p);\n         }\n \n@@ -988,19 +989,19 @@ impl MarkdownHtml<'_> {\n         if md.is_empty() {\n             return String::new();\n         }\n-        let p = Parser::new_ext(md, opts());\n+        let p = Parser::new_ext(md, opts()).into_offset_iter();\n \n         // Treat inline HTML as plain text.\n-        let p = p.map(|event| match event {\n-            Event::Html(text) => Event::Text(text),\n+        let p = p.map(|event| match event.0 {\n+            Event::Html(text) => (Event::Text(text), event.1),\n             _ => event,\n         });\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n         let p = HeadingLinks::new(p, None, &mut ids);\n-        let p = CodeBlocks::new(p, codes, edition, playground);\n         let p = Footnotes::new(p);\n+        let p = CodeBlocks::new(p.map(|(ev, _)| ev), codes, edition, playground);\n         html::push_html(&mut s, p);\n \n         s\n@@ -1153,50 +1154,43 @@ crate fn plain_text_summary(md: &str) -> String {\n     s\n }\n \n-crate fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n+crate fn markdown_links(md: &str) -> Vec<(String, Range<usize>)> {\n     if md.is_empty() {\n         return vec![];\n     }\n \n     let mut links = vec![];\n     let mut shortcut_links = vec![];\n \n-    {\n-        let locate = |s: &str| unsafe {\n-            let s_start = s.as_ptr();\n-            let s_end = s_start.add(s.len());\n-            let md_start = md.as_ptr();\n-            let md_end = md_start.add(md.len());\n-            if md_start <= s_start && s_end <= md_end {\n-                let start = s_start.offset_from(md_start) as usize;\n-                let end = s_end.offset_from(md_start) as usize;\n-                Some(start..end)\n-            } else {\n-                None\n-            }\n-        };\n-\n-        let mut push = |link: BrokenLink<'_>| {\n-            // FIXME: use `link.span` instead of `locate`\n-            // (doing it now includes the `[]` as well as the text)\n-            shortcut_links.push((link.reference.to_owned(), locate(link.reference)));\n-            None\n-        };\n-        let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut push));\n-\n-        // There's no need to thread an IdMap through to here because\n-        // the IDs generated aren't going to be emitted anywhere.\n-        let mut ids = IdMap::new();\n-        let iter = Footnotes::new(HeadingLinks::new(p, None, &mut ids));\n-\n-        for ev in iter {\n-            if let Event::Start(Tag::Link(_, dest, _)) = ev {\n-                debug!(\"found link: {}\", dest);\n-                links.push(match dest {\n-                    CowStr::Borrowed(s) => (s.to_owned(), locate(s)),\n-                    s @ (CowStr::Boxed(..) | CowStr::Inlined(..)) => (s.into_string(), None),\n-                });\n+    let span_for_link = |link: &str, span: Range<usize>| {\n+        // Pulldown includes the `[]` as well as the URL. Only highlight the relevant span.\n+        // NOTE: uses `rfind` in case the title and url are the same: `[Ok][Ok]`\n+        match md[span.clone()].rfind(link) {\n+            Some(start) => {\n+                let start = span.start + start;\n+                start..start + link.len()\n             }\n+            // This can happen for things other than intra-doc links, like `#1` expanded to `https://github.com/rust-lang/rust/issues/1`.\n+            None => span,\n+        }\n+    };\n+    let mut push = |link: BrokenLink<'_>| {\n+        let span = span_for_link(link.reference, link.span);\n+        shortcut_links.push((link.reference.to_owned(), span));\n+        None\n+    };\n+    let p = Parser::new_with_broken_link_callback(md, opts(), Some(&mut push));\n+\n+    // There's no need to thread an IdMap through to here because\n+    // the IDs generated aren't going to be emitted anywhere.\n+    let mut ids = IdMap::new();\n+    let iter = Footnotes::new(HeadingLinks::new(p.into_offset_iter(), None, &mut ids));\n+\n+    for ev in iter {\n+        if let Event::Start(Tag::Link(_, dest, _)) = ev.0 {\n+            debug!(\"found link: {}\", dest);\n+            let span = span_for_link(&dest, ev.1);\n+            links.push((dest.into_string(), span));\n         }\n     }\n "}, {"sha": "a8adfe08b2561168c42f00904cc7a5f5ba75b371", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/65f4f39dd8d9a1c1f4a817da36c38b30e4369f9e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65f4f39dd8d9a1c1f4a817da36c38b30e4369f9e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=65f4f39dd8d9a1c1f4a817da36c38b30e4369f9e", "patch": "@@ -180,7 +180,7 @@ struct DiagnosticInfo<'a> {\n     item: &'a Item,\n     dox: &'a str,\n     ori_link: &'a str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n }\n \n #[derive(Clone, Debug, Hash)]\n@@ -920,7 +920,7 @@ impl LinkCollector<'_, '_> {\n         parent_node: Option<DefId>,\n         krate: CrateNum,\n         ori_link: String,\n-        link_range: Option<Range<usize>>,\n+        link_range: Range<usize>,\n     ) -> Option<ItemLink> {\n         trace!(\"considering link '{}'\", ori_link);\n \n@@ -1566,7 +1566,7 @@ fn report_diagnostic(\n     msg: &str,\n     item: &Item,\n     dox: &str,\n-    link_range: &Option<Range<usize>>,\n+    link_range: &Range<usize>,\n     decorate: impl FnOnce(&mut DiagnosticBuilder<'_>, Option<rustc_span::Span>),\n ) {\n     let hir_id = match cx.as_local_hir_id(item.def_id) {\n@@ -1584,31 +1584,26 @@ fn report_diagnostic(\n     cx.tcx.struct_span_lint_hir(lint, hir_id, sp, |lint| {\n         let mut diag = lint.build(msg);\n \n-        let span = link_range\n-            .as_ref()\n-            .and_then(|range| super::source_span_for_markdown_range(cx, dox, range, attrs));\n-\n-        if let Some(link_range) = link_range {\n-            if let Some(sp) = span {\n-                diag.set_span(sp);\n-            } else {\n-                // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n-                //                       ^     ~~~~\n-                //                       |     link_range\n-                //                       last_new_line_offset\n-                let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n-                let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n-\n-                // Print the line containing the `link_range` and manually mark it with '^'s.\n-                diag.note(&format!(\n-                    \"the link appears in this line:\\n\\n{line}\\n\\\n-                     {indicator: <before$}{indicator:^<found$}\",\n-                    line = line,\n-                    indicator = \"\",\n-                    before = link_range.start - last_new_line_offset,\n-                    found = link_range.len(),\n-                ));\n-            }\n+        let span = super::source_span_for_markdown_range(cx, dox, link_range, attrs);\n+        if let Some(sp) = span {\n+            diag.set_span(sp);\n+        } else {\n+            // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n+            //                       ^     ~~~~\n+            //                       |     link_range\n+            //                       last_new_line_offset\n+            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n+\n+            // Print the line containing the `link_range` and manually mark it with '^'s.\n+            diag.note(&format!(\n+                \"the link appears in this line:\\n\\n{line}\\n\\\n+                    {indicator: <before$}{indicator:^<found$}\",\n+                line = line,\n+                indicator = \"\",\n+                before = link_range.start - last_new_line_offset,\n+                found = link_range.len(),\n+            ));\n         }\n \n         decorate(&mut diag, span);\n@@ -1628,7 +1623,7 @@ fn resolution_failure(\n     path_str: &str,\n     disambiguator: Option<Disambiguator>,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n     kinds: SmallVec<[ResolutionFailure<'_>; 3]>,\n ) {\n     report_diagnostic(\n@@ -1862,7 +1857,7 @@ fn anchor_failure(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n     failure: AnchorFailure,\n ) {\n     let msg = match failure {\n@@ -1887,7 +1882,7 @@ fn ambiguity_error(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n     candidates: Vec<Res>,\n ) {\n     let mut msg = format!(\"`{}` is \", path_str);\n@@ -1936,13 +1931,12 @@ fn suggest_disambiguator(\n     path_str: &str,\n     dox: &str,\n     sp: Option<rustc_span::Span>,\n-    link_range: &Option<Range<usize>>,\n+    link_range: &Range<usize>,\n ) {\n     let suggestion = disambiguator.suggestion();\n     let help = format!(\"to link to the {}, {}\", disambiguator.descr(), suggestion.descr());\n \n     if let Some(sp) = sp {\n-        let link_range = link_range.as_ref().expect(\"must have a link range if we have a span\");\n         let msg = if dox.bytes().nth(link_range.start) == Some(b'`') {\n             format!(\"`{}`\", suggestion.as_help(path_str))\n         } else {\n@@ -1961,7 +1955,7 @@ fn privacy_error(\n     item: &Item,\n     path_str: &str,\n     dox: &str,\n-    link_range: Option<Range<usize>>,\n+    link_range: Range<usize>,\n ) {\n     let sym;\n     let item_name = match item.name {"}]}