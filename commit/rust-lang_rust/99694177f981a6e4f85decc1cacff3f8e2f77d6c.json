{"sha": "99694177f981a6e4f85decc1cacff3f8e2f77d6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5Njk0MTc3Zjk4MWE2ZTRmODVkZWNjMWNhY2ZmM2Y4ZTJmNzdkNmM=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-18T02:08:12Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-26T00:46:26Z"}, "message": "Add RequiresStorage pass to decide which locals to save in generators\n\nThis avoids reserving storage in generators for locals that are moved\nout of (and not re-initialized) prior to yield points.", "tree": {"sha": "a763995e73210af61c357490b5d2316d6bcb6382", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a763995e73210af61c357490b5d2316d6bcb6382"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99694177f981a6e4f85decc1cacff3f8e2f77d6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99694177f981a6e4f85decc1cacff3f8e2f77d6c", "html_url": "https://github.com/rust-lang/rust/commit/99694177f981a6e4f85decc1cacff3f8e2f77d6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99694177f981a6e4f85decc1cacff3f8e2f77d6c/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a8a552b4961d7a1dbc4592902c62d0426b0140f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8a552b4961d7a1dbc4592902c62d0426b0140f", "html_url": "https://github.com/rust-lang/rust/commit/4a8a552b4961d7a1dbc4592902c62d0426b0140f"}], "stats": {"total": 191, "additions": 165, "deletions": 26}, "files": [{"sha": "7f5c77007aec323704b7b36b2d09f4bb6c957547", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99694177f981a6e4f85decc1cacff3f8e2f77d6c/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99694177f981a6e4f85decc1cacff3f8e2f77d6c/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=99694177f981a6e4f85decc1cacff3f8e2f77d6c", "patch": "@@ -61,6 +61,7 @@ pub trait FlowsAtLocation {\n /// (e.g., via `reconstruct_statement_effect` and\n /// `reconstruct_terminator_effect`; don't forget to call\n /// `apply_local_effect`).\n+#[derive(Clone)]\n pub struct FlowAtLocation<'tcx, BD, DR = DataflowResults<'tcx, BD>>\n where\n     BD: BitDenotation<'tcx>,"}, {"sha": "64d0ae016a35a2c47cdded009c0c12cebab46855", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/99694177f981a6e4f85decc1cacff3f8e2f77d6c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99694177f981a6e4f85decc1cacff3f8e2f77d6c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=99694177f981a6e4f85decc1cacff3f8e2f77d6c", "patch": "@@ -1,7 +1,13 @@\n pub use super::*;\n \n use rustc::mir::*;\n+use rustc::mir::visit::{\n+    PlaceContext, Visitor, NonMutatingUseContext,\n+};\n+use std::cell::RefCell;\n use crate::dataflow::BitDenotation;\n+use crate::dataflow::HaveBeenBorrowedLocals;\n+use crate::dataflow::{DataflowResults, DataflowResultsCursor, DataflowResultsRefCursor};\n \n #[derive(Copy, Clone)]\n pub struct MaybeStorageLive<'a, 'tcx> {\n@@ -63,3 +69,126 @@ impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n     /// bottom = dead\n     const BOTTOM_VALUE: bool = false;\n }\n+\n+/// Dataflow analysis that determines whether each local requires storage at a\n+/// given location; i.e. whether its storage can go away without being observed.\n+///\n+/// In the case of a movable generator, borrowed_locals can be `None` and we\n+/// will not consider borrows in this pass. This relies on the fact that we only\n+/// use this pass at yield points for these generators.\n+#[derive(Clone)]\n+pub struct RequiresStorage<'mir, 'tcx, 'b> {\n+    body: &'mir Body<'tcx>,\n+    borrowed_locals:\n+        RefCell<DataflowResultsRefCursor<'mir, 'tcx, 'b, HaveBeenBorrowedLocals<'mir, 'tcx>>>,\n+}\n+\n+impl<'mir, 'tcx: 'mir, 'b> RequiresStorage<'mir, 'tcx, 'b> {\n+    pub fn new(\n+        body: &'mir Body<'tcx>,\n+        borrowed_locals: &'b DataflowResults<'tcx, HaveBeenBorrowedLocals<'mir, 'tcx>>,\n+    ) -> Self {\n+        RequiresStorage {\n+            body,\n+            borrowed_locals: RefCell::new(DataflowResultsCursor::new(borrowed_locals, body)),\n+        }\n+    }\n+\n+    pub fn body(&self) -> &Body<'tcx> {\n+        self.body\n+    }\n+}\n+\n+impl<'mir, 'tcx, 'b> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx, 'b> {\n+    type Idx = Local;\n+    fn name() -> &'static str { \"requires_storage\" }\n+    fn bits_per_block(&self) -> usize {\n+        self.body.local_decls.len()\n+    }\n+\n+    fn start_block_effect(&self, _sets: &mut BitSet<Local>) {\n+        // Nothing is live on function entry\n+    }\n+\n+    fn statement_effect(&self,\n+                        sets: &mut GenKillSet<Local>,\n+                        loc: Location) {\n+        self.check_for_move(sets, loc);\n+        self.check_for_borrow(sets, loc);\n+\n+        let stmt = &self.body[loc.block].statements[loc.statement_index];\n+        match stmt.kind {\n+            StatementKind::StorageLive(l) => sets.gen(l),\n+            StatementKind::StorageDead(l) => sets.kill(l),\n+            StatementKind::Assign(ref place, _)\n+            | StatementKind::SetDiscriminant { ref place, .. } => {\n+                place.base_local().map(|l| sets.gen(l));\n+            }\n+            StatementKind::InlineAsm(box InlineAsm { ref outputs, .. }) => {\n+                for p in &**outputs {\n+                    p.base_local().map(|l| sets.gen(l));\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    fn terminator_effect(&self,\n+                         sets: &mut GenKillSet<Local>,\n+                         loc: Location) {\n+        self.check_for_move(sets, loc);\n+        self.check_for_borrow(sets, loc);\n+    }\n+\n+    fn propagate_call_return(\n+        &self,\n+        in_out: &mut BitSet<Local>,\n+        _call_bb: mir::BasicBlock,\n+        _dest_bb: mir::BasicBlock,\n+        dest_place: &mir::Place<'tcx>,\n+    ) {\n+        dest_place.base_local().map(|l| in_out.insert(l));\n+    }\n+}\n+\n+impl<'mir, 'tcx, 'b> RequiresStorage<'mir, 'tcx, 'b> {\n+    /// Kill locals that are fully moved and have not been borrowed.\n+    fn check_for_move(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n+        let mut visitor = MoveVisitor {\n+            sets,\n+            borrowed_locals: &self.borrowed_locals,\n+        };\n+        visitor.visit_location(self.body, loc);\n+    }\n+\n+    /// Gen locals that are newly borrowed. This includes borrowing any part of\n+    /// a local (we rely on this behavior of `HaveBeenBorrowedLocals`).\n+    fn check_for_borrow(&self, sets: &mut GenKillSet<Local>, loc: Location) {\n+        let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n+        borrowed_locals.seek(loc);\n+        borrowed_locals.each_gen_bit(|l| sets.gen(l));\n+    }\n+}\n+\n+impl<'mir, 'tcx, 'b> BottomValue for RequiresStorage<'mir, 'tcx, 'b> {\n+    /// bottom = dead\n+    const BOTTOM_VALUE: bool = false;\n+}\n+\n+struct MoveVisitor<'a, 'b, 'mir, 'tcx> {\n+    borrowed_locals:\n+        &'a RefCell<DataflowResultsRefCursor<'mir, 'tcx, 'b, HaveBeenBorrowedLocals<'mir, 'tcx>>>,\n+    sets: &'a mut GenKillSet<Local>,\n+}\n+\n+impl<'a, 'b, 'mir: 'a, 'tcx> Visitor<'tcx> for MoveVisitor<'a, 'b, 'mir, 'tcx> {\n+    fn visit_local(&mut self, local: &Local, context: PlaceContext, loc: Location) {\n+        if PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) == context {\n+            let mut borrowed_locals = self.borrowed_locals.borrow_mut();\n+            borrowed_locals.seek(loc);\n+            if !borrowed_locals.contains(*local) {\n+                self.sets.kill(*local);\n+            }\n+        }\n+    }\n+}"}, {"sha": "060b2be5cd92432cdd74c11eaf9a6e8d3677425d", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99694177f981a6e4f85decc1cacff3f8e2f77d6c/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99694177f981a6e4f85decc1cacff3f8e2f77d6c/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=99694177f981a6e4f85decc1cacff3f8e2f77d6c", "patch": "@@ -17,7 +17,7 @@ use std::io;\n use std::path::PathBuf;\n use std::usize;\n \n-pub use self::impls::{MaybeStorageLive};\n+pub use self::impls::{MaybeStorageLive, RequiresStorage};\n pub use self::impls::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n pub use self::impls::DefinitelyInitializedPlaces;\n pub use self::impls::EverInitializedPlaces;"}, {"sha": "54f69adb69cc6be8754d0b8d69e2373d493d7477", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 34, "deletions": 25, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/99694177f981a6e4f85decc1cacff3f8e2f77d6c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99694177f981a6e4f85decc1cacff3f8e2f77d6c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=99694177f981a6e4f85decc1cacff3f8e2f77d6c", "patch": "@@ -66,9 +66,9 @@ use std::mem;\n use crate::transform::{MirPass, MirSource};\n use crate::transform::simplify;\n use crate::transform::no_landing_pads::no_landing_pads;\n-use crate::dataflow::{DataflowResults, DataflowResultsConsumer, FlowAtLocation, FlowAtLocationOwned};\n+use crate::dataflow::{DataflowResults, DataflowResultsConsumer, FlowAtLocation};\n use crate::dataflow::{do_dataflow, DebugFormatted, state_for_location};\n-use crate::dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals};\n+use crate::dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals, RequiresStorage};\n use crate::util::dump_mir;\n use crate::util::liveness;\n \n@@ -437,16 +437,17 @@ fn locals_live_across_suspend_points(\n \n     // Calculate the MIR locals which have been previously\n     // borrowed (even if they are still active).\n-    // This is only used for immovable generators.\n-    let borrowed_locals = if !movable {\n-        let analysis = HaveBeenBorrowedLocals::new(body);\n-        let result =\n-            do_dataflow(tcx, body, def_id, &[], &dead_unwinds, analysis,\n-                        |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n-        Some((analysis, result))\n-    } else {\n-        None\n-    };\n+    let borrowed_locals_analysis = HaveBeenBorrowedLocals::new(body);\n+    let borrowed_locals_result =\n+        do_dataflow(tcx, body, def_id, &[], &dead_unwinds, borrowed_locals_analysis,\n+                    |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n+\n+    // Calculate the MIR locals that we actually need to keep storage around\n+    // for.\n+    let requires_storage_analysis = RequiresStorage::new(body, &borrowed_locals_result);\n+    let requires_storage =\n+        do_dataflow(tcx, body, def_id, &[], &dead_unwinds, requires_storage_analysis.clone(),\n+                    |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n     let mut live_locals = liveness::LiveVarSet::new_empty(body.local_decls.len());\n@@ -471,10 +472,10 @@ fn locals_live_across_suspend_points(\n                 statement_index: data.statements.len(),\n             };\n \n-            if let Some((ref analysis, ref result)) = borrowed_locals {\n+            if !movable {\n                 let borrowed_locals = state_for_location(loc,\n-                                                         analysis,\n-                                                         result,\n+                                                         &borrowed_locals_analysis,\n+                                                         &borrowed_locals_result,\n                                                          body);\n                 // The `liveness` variable contains the liveness of MIR locals ignoring borrows.\n                 // This is correct for movable generators since borrows cannot live across\n@@ -489,34 +490,42 @@ fn locals_live_across_suspend_points(\n                 liveness.outs[block].union(&borrowed_locals);\n             }\n \n-            let mut storage_liveness = state_for_location(loc,\n-                                                          &storage_live_analysis,\n-                                                          &storage_live,\n-                                                          body);\n+            let storage_liveness = state_for_location(loc,\n+                                                      &storage_live_analysis,\n+                                                      &storage_live,\n+                                                      body);\n \n             // Store the storage liveness for later use so we can restore the state\n             // after a suspension point\n             storage_liveness_map.insert(block, storage_liveness.clone());\n \n-            // Mark locals without storage statements as always having live storage\n-            storage_liveness.union(&ignored.0);\n+            let mut storage_required = state_for_location(loc,\n+                                                          &requires_storage_analysis,\n+                                                          &requires_storage,\n+                                                          body);\n+\n+            // Mark locals without storage statements as always requiring storage\n+            storage_required.union(&ignored.0);\n \n             // Locals live are live at this point only if they are used across\n             // suspension points (the `liveness` variable)\n-            // and their storage is live (the `storage_liveness` variable)\n-            let mut live_locals_here = storage_liveness;\n+            // and their storage is required (the `storage_required` variable)\n+            let mut live_locals_here = storage_required;\n             live_locals_here.intersect(&liveness.outs[block]);\n \n             // The generator argument is ignored\n             live_locals_here.remove(self_arg());\n \n+            debug!(\"loc = {:?}, live_locals_here = {:?}\", loc, live_locals_here);\n+\n             // Add the locals live at this suspension point to the set of locals which live across\n             // any suspension points\n             live_locals.union(&live_locals_here);\n \n             live_locals_at_suspension_points.push(live_locals_here);\n         }\n     }\n+    debug!(\"live_locals = {:?}\", live_locals);\n \n     // Renumber our liveness_map bitsets to include only the locals we are\n     // saving.\n@@ -627,7 +636,7 @@ struct StorageConflictVisitor<'body, 'tcx, 's> {\n impl<'body, 'tcx, 's> DataflowResultsConsumer<'body, 'tcx>\n     for StorageConflictVisitor<'body, 'tcx, 's>\n {\n-    type FlowState = FlowAtLocationOwned<'tcx, MaybeStorageLive<'body, 'tcx>>;\n+    type FlowState = FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>;\n \n     fn body(&self) -> &'body Body<'tcx> {\n         self.body\n@@ -657,7 +666,7 @@ impl<'body, 'tcx, 's> DataflowResultsConsumer<'body, 'tcx>\n \n impl<'body, 'tcx, 's> StorageConflictVisitor<'body, 'tcx, 's> {\n     fn apply_state(&mut self,\n-                   flow_state: &FlowAtLocationOwned<'tcx, MaybeStorageLive<'body, 'tcx>>,\n+                   flow_state: &FlowAtLocation<'tcx, MaybeStorageLive<'body, 'tcx>>,\n                    loc: Location) {\n         // Ignore unreachable blocks.\n         match self.body.basic_blocks()[loc.block].terminator().kind {"}]}