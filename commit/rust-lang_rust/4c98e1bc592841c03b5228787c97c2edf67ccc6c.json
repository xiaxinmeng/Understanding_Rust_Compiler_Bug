{"sha": "4c98e1bc592841c03b5228787c97c2edf67ccc6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjOThlMWJjNTkyODQxYzAzYjUyMjg3ODdjOTdjMmVkZjY3Y2NjNmM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-01-14T11:13:45Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-01-17T21:06:44Z"}, "message": "Remove the lookahead buffer.", "tree": {"sha": "3617fb14bcda73f7179490b87160e2782798047f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3617fb14bcda73f7179490b87160e2782798047f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c98e1bc592841c03b5228787c97c2edf67ccc6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c98e1bc592841c03b5228787c97c2edf67ccc6c", "html_url": "https://github.com/rust-lang/rust/commit/4c98e1bc592841c03b5228787c97c2edf67ccc6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c98e1bc592841c03b5228787c97c2edf67ccc6c/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57c0ed097ce150fa1d684b5b3b5479a5dedd2b7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/57c0ed097ce150fa1d684b5b3b5479a5dedd2b7b", "html_url": "https://github.com/rust-lang/rust/commit/57c0ed097ce150fa1d684b5b3b5479a5dedd2b7b"}], "stats": {"total": 51, "additions": 14, "deletions": 37}, "files": [{"sha": "aa5331e4c7d78c6bc25891e1a52b35da70eeefb2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4c98e1bc592841c03b5228787c97c2edf67ccc6c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c98e1bc592841c03b5228787c97c2edf67ccc6c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4c98e1bc592841c03b5228787c97c2edf67ccc6c", "patch": "@@ -156,22 +156,6 @@ enum PrevTokenKind {\n     Other,\n }\n \n-// Simple circular buffer used for keeping few next tokens.\n-#[derive(Default)]\n-struct LookaheadBuffer {\n-    buffer: [TokenAndSpan; LOOKAHEAD_BUFFER_CAPACITY],\n-    start: usize,\n-    end: usize,\n-}\n-\n-const LOOKAHEAD_BUFFER_CAPACITY: usize = 8;\n-\n-impl LookaheadBuffer {\n-    fn len(&self) -> usize {\n-        (LOOKAHEAD_BUFFER_CAPACITY + self.end - self.start) % LOOKAHEAD_BUFFER_CAPACITY\n-    }\n-}\n-\n /* ident is handled by common.rs */\n \n pub struct Parser<'a> {\n@@ -184,7 +168,6 @@ pub struct Parser<'a> {\n     pub prev_span: Span,\n     /// the previous token kind\n     prev_token_kind: PrevTokenKind,\n-    lookahead_buffer: LookaheadBuffer,\n     pub restrictions: Restrictions,\n     pub quote_depth: usize, // not (yet) related to the quasiquoter\n     parsing_token_tree: bool,\n@@ -281,7 +264,6 @@ impl<'a> Parser<'a> {\n             span: syntax_pos::DUMMY_SP,\n             prev_span: syntax_pos::DUMMY_SP,\n             prev_token_kind: PrevTokenKind::Other,\n-            lookahead_buffer: Default::default(),\n             restrictions: Restrictions::empty(),\n             quote_depth: 0,\n             parsing_token_tree: false,\n@@ -875,14 +857,7 @@ impl<'a> Parser<'a> {\n             _ => PrevTokenKind::Other,\n         };\n \n-        let next = if self.lookahead_buffer.start == self.lookahead_buffer.end {\n-            self.next_tok()\n-        } else {\n-            // Avoid token copies with `replace`.\n-            let old_start = self.lookahead_buffer.start;\n-            self.lookahead_buffer.start = (old_start + 1) % LOOKAHEAD_BUFFER_CAPACITY;\n-            mem::replace(&mut self.lookahead_buffer.buffer[old_start], Default::default())\n-        };\n+        let next = self.next_tok();\n         self.span = next.sp;\n         self.token = next.tok;\n         self.expected_tokens.clear();\n@@ -917,18 +892,20 @@ impl<'a> Parser<'a> {\n         F: FnOnce(&token::Token) -> R,\n     {\n         if dist == 0 {\n-            f(&self.token)\n-        } else if dist < LOOKAHEAD_BUFFER_CAPACITY {\n-            while self.lookahead_buffer.len() < dist {\n-                self.lookahead_buffer.buffer[self.lookahead_buffer.end] = self.next_tok();\n-                self.lookahead_buffer.end =\n-                    (self.lookahead_buffer.end + 1) % LOOKAHEAD_BUFFER_CAPACITY;\n-            }\n-            let index = (self.lookahead_buffer.start + dist - 1) % LOOKAHEAD_BUFFER_CAPACITY;\n-            f(&self.lookahead_buffer.buffer[index].tok)\n-        } else {\n-            self.bug(\"lookahead distance is too large\");\n+            return f(&self.token);\n+        }\n+        let mut tok = token::Eof;\n+        if let Some(&(ref tts, mut i)) = self.tts.last() {\n+            i += dist - 1;\n+            if i < tts.len() {\n+                tok = match tts.get_tt(i) {\n+                    TokenTree::Token(_, tok) => tok,\n+                    TokenTree::Delimited(_, delimited) => token::OpenDelim(delimited.delim),\n+                    TokenTree::Sequence(..) => token::Dollar,\n+                };\n+            }\n         }\n+        f(&tok)\n     }\n     pub fn fatal(&self, m: &str) -> DiagnosticBuilder<'a> {\n         self.sess.span_diagnostic.struct_span_fatal(self.span, m)"}]}