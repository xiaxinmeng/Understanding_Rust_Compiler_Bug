{"sha": "49b2cdf47c983d5ea8a576346d08120f0e3af30a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5YjJjZGY0N2M5ODNkNWVhOGE1NzYzNDZkMDgxMjBmMGUzYWYzMGE=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2016-05-11T19:31:19Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2016-05-11T20:18:46Z"}, "message": "[MIR trans] Optimize trans for biased switches\n\nCurrently, all switches in MIR are exhausitive, meaning that we can have\na lot of arms that all go to the same basic block, the extreme case\nbeing an if-let expression which results in just 2 possible cases, be\nmight end up with hundreds of arms for large enums.\n\nTo improve this situation and give LLVM less code to chew on, we can\ndetect whether there's a pre-dominant target basic block in a switch\nand then promote this to be the default target, not translating the\ncorresponding arms at all.\n\nIn combination with #33544 this makes unoptimized MIR trans of\nnickel.rs as fast as using old trans and greatly improves the times for\noptimized builds, which are only 30-40% slower instead of ~300%.\n\ncc #33111", "tree": {"sha": "73ae95a59ee5eb635975a2f73059eec8f3ca27fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73ae95a59ee5eb635975a2f73059eec8f3ca27fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49b2cdf47c983d5ea8a576346d08120f0e3af30a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49b2cdf47c983d5ea8a576346d08120f0e3af30a", "html_url": "https://github.com/rust-lang/rust/commit/49b2cdf47c983d5ea8a576346d08120f0e3af30a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49b2cdf47c983d5ea8a576346d08120f0e3af30a/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0495417416c8e0687bc6a997507c403627f6568", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0495417416c8e0687bc6a997507c403627f6568", "html_url": "https://github.com/rust-lang/rust/commit/c0495417416c8e0687bc6a997507c403627f6568"}], "stats": {"total": 36, "additions": 26, "deletions": 10}, "files": [{"sha": "4e3386bc736775440d22bb3f1fd6d015dbe9c392", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/49b2cdf47c983d5ea8a576346d08120f0e3af30a/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49b2cdf47c983d5ea8a576346d08120f0e3af30a/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=49b2cdf47c983d5ea8a576346d08120f0e3af30a", "patch": "@@ -24,6 +24,7 @@ use meth;\n use type_of;\n use glue;\n use type_::Type;\n+use rustc_data_structures::fnv::FnvHashMap;\n \n use super::{MirContext, TempRef, drop};\n use super::constant::Const;\n@@ -95,17 +96,32 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     adt::trans_get_discr(bcx, &repr, discr_lvalue.llval, None, true)\n                 );\n \n-                // The else branch of the Switch can't be hit, so branch to an unreachable\n-                // instruction so LLVM knows that\n-                let unreachable_blk = self.unreachable_block();\n-                let switch = bcx.switch(discr, unreachable_blk.llbb, targets.len());\n+                let mut bb_hist = FnvHashMap();\n+                for target in targets {\n+                    *bb_hist.entry(target).or_insert(0) += 1;\n+                }\n+                let (default_bb, default_blk) = match bb_hist.iter().max_by_key(|&(_, c)| c) {\n+                    // If a single target basic blocks is predominant, promote that to be the\n+                    // default case for the switch instruction to reduce the size of the generated\n+                    // code. This is especially helpful in cases like an if-let on a huge enum.\n+                    // Note: This optimization is only valid for exhaustive matches.\n+                    Some((&&bb, &c)) if c > targets.len() / 2 => {\n+                        (Some(bb), self.blocks[bb.index()])\n+                    }\n+                    // We're generating an exhaustive switch, so the else branch\n+                    // can't be hit.  Branching to an unreachable instruction\n+                    // lets LLVM know this\n+                    _ => (None, self.unreachable_block())\n+                };\n+                let switch = bcx.switch(discr, default_blk.llbb, targets.len());\n                 assert_eq!(adt_def.variants.len(), targets.len());\n-                for (adt_variant, target) in adt_def.variants.iter().zip(targets) {\n-                    let llval = bcx.with_block(|bcx|\n-                        adt::trans_case(bcx, &repr, Disr::from(adt_variant.disr_val))\n-                    );\n-                    let llbb = self.llblock(*target);\n-                    build::AddCase(switch, llval, llbb)\n+                for (adt_variant, &target) in adt_def.variants.iter().zip(targets) {\n+                    if default_bb != Some(target) {\n+                        let llbb = self.llblock(target);\n+                        let llval = bcx.with_block(|bcx| adt::trans_case(\n+                                bcx, &repr, Disr::from(adt_variant.disr_val)));\n+                        build::AddCase(switch, llval, llbb)\n+                    }\n                 }\n             }\n "}]}