{"sha": "fe123231ad0efcf16f183975b9b28304d63363e7", "node_id": "C_kwDOAAsO6NoAKGZlMTIzMjMxYWQwZWZjZjE2ZjE4Mzk3NWI5YjI4MzA0ZDYzMzYzZTc", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-06-01T05:39:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-06-01T05:39:44Z"}, "message": "Rollup merge of #112128 - nnethercote:no-inlining-advance, r=wesleywiser\n\nDon't compute inlining status of mono items in advance.\n\nWe record inlining status for mono items in `MonoItems`, and then transfer it to `InliningMap`, for later use in\n`InliningMap::with_inlining_candidates`.\n\nBut we can just compute inlining status directly in `InliningMap::with_inlining_candidates`, because the mono item is right there. There's no need to compute it in advance.\n\nThis commit changes the code to do that, removing the need for `MonoItems` and `InliningMap::inlines`. This does result in more calls to `instantiation_mode` (one per static occurrence) but the performance effect is negligible.\n\nr? ``@wesleywiser``", "tree": {"sha": "454876ab95113d67b3396feeef2b55aa1172a988", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/454876ab95113d67b3396feeef2b55aa1172a988"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe123231ad0efcf16f183975b9b28304d63363e7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkeC8gCRBK7hj4Ov3rIwAApSYIABnYg5MZrmWigJHRmOKCfBlR\n5/gXdqk4zSUweaQzohBniiq3HyrK8LJn+Yi4m3it/g0DpxEctmtRZmwhAfOi7Dg5\nvrRnvlctVSVADk+0UPhLdJBzgUDHhzTe+wylkU066Oyq09HjY979fgi2yxHeUEMu\nPtGqo3ac4vncpoNmqwN0oa1JD2TN/B4EGap/U7RiLeF1z3H9moLwhQhq+5mFCKuU\n7/uH2zL02YgOH3opcNybGetqmFdgqLHrl4CGB2TtJzkExp4DuhTJrw0zYolq8teJ\n/sTXwc1WAE9YZDgEBCjuQJCl2nmInC+ZbN3Ir22Mslcst9RuxoE8wgtDDIvHTr0=\n=skhC\n-----END PGP SIGNATURE-----\n", "payload": "tree 454876ab95113d67b3396feeef2b55aa1172a988\nparent 02c4b4b2790cc778d235b020b5615e29805e5f43\nparent cc21d9aa522cf07148e154ce9aec5f5f7a67c86c\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1685597984 +0530\ncommitter GitHub <noreply@github.com> 1685597984 +0530\n\nRollup merge of #112128 - nnethercote:no-inlining-advance, r=wesleywiser\n\nDon't compute inlining status of mono items in advance.\n\nWe record inlining status for mono items in `MonoItems`, and then transfer it to `InliningMap`, for later use in\n`InliningMap::with_inlining_candidates`.\n\nBut we can just compute inlining status directly in `InliningMap::with_inlining_candidates`, because the mono item is right there. There's no need to compute it in advance.\n\nThis commit changes the code to do that, removing the need for `MonoItems` and `InliningMap::inlines`. This does result in more calls to `instantiation_mode` (one per static occurrence) but the performance effect is negligible.\n\nr? ``@wesleywiser``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe123231ad0efcf16f183975b9b28304d63363e7", "html_url": "https://github.com/rust-lang/rust/commit/fe123231ad0efcf16f183975b9b28304d63363e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe123231ad0efcf16f183975b9b28304d63363e7/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02c4b4b2790cc778d235b020b5615e29805e5f43", "url": "https://api.github.com/repos/rust-lang/rust/commits/02c4b4b2790cc778d235b020b5615e29805e5f43", "html_url": "https://github.com/rust-lang/rust/commit/02c4b4b2790cc778d235b020b5615e29805e5f43"}, {"sha": "cc21d9aa522cf07148e154ce9aec5f5f7a67c86c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc21d9aa522cf07148e154ce9aec5f5f7a67c86c", "html_url": "https://github.com/rust-lang/rust/commit/cc21d9aa522cf07148e154ce9aec5f5f7a67c86c"}], "stats": {"total": 83, "additions": 17, "deletions": 66}, "files": [{"sha": "09025c1ee3319fe2f07d1fde2a1cb208da233db5", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 13, "deletions": 63, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/fe123231ad0efcf16f183975b9b28304d63363e7/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe123231ad0efcf16f183975b9b28304d63363e7/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=fe123231ad0efcf16f183975b9b28304d63363e7", "patch": "@@ -179,7 +179,6 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n-use rustc_index::bit_set::GrowableBitSet;\n use rustc_middle::mir::interpret::{AllocId, ConstValue};\n use rustc_middle::mir::interpret::{ErrorHandled, GlobalAlloc, Scalar};\n use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n@@ -220,78 +219,29 @@ pub struct InliningMap<'tcx> {\n     // The range selects elements within the `targets` vecs.\n     index: FxHashMap<MonoItem<'tcx>, Range<usize>>,\n     targets: Vec<MonoItem<'tcx>>,\n-\n-    // Contains one bit per mono item in the `targets` field. That bit\n-    // is true if that mono item needs to be inlined into every CGU.\n-    inlines: GrowableBitSet<usize>,\n-}\n-\n-/// Struct to store mono items in each collecting and if they should\n-/// be inlined. We call `instantiation_mode` to get their inlining\n-/// status when inserting new elements, which avoids calling it in\n-/// `inlining_map.lock_mut()`. See the `collect_items_rec` implementation\n-/// below.\n-struct MonoItems<'tcx> {\n-    // If this is false, we do not need to compute whether items\n-    // will need to be inlined.\n-    compute_inlining: bool,\n-\n-    // The TyCtxt used to determine whether the a item should\n-    // be inlined.\n-    tcx: TyCtxt<'tcx>,\n-\n-    // The collected mono items. The bool field in each element\n-    // indicates whether this element should be inlined.\n-    items: Vec<(Spanned<MonoItem<'tcx>>, bool /*inlined*/)>,\n }\n \n-impl<'tcx> MonoItems<'tcx> {\n-    #[inline]\n-    fn push(&mut self, item: Spanned<MonoItem<'tcx>>) {\n-        self.extend([item]);\n-    }\n-\n-    #[inline]\n-    fn extend<T: IntoIterator<Item = Spanned<MonoItem<'tcx>>>>(&mut self, iter: T) {\n-        self.items.extend(iter.into_iter().map(|mono_item| {\n-            let inlined = if !self.compute_inlining {\n-                false\n-            } else {\n-                mono_item.node.instantiation_mode(self.tcx) == InstantiationMode::LocalCopy\n-            };\n-            (mono_item, inlined)\n-        }))\n-    }\n-}\n+type MonoItems<'tcx> = Vec<Spanned<MonoItem<'tcx>>>;\n \n impl<'tcx> InliningMap<'tcx> {\n     fn new() -> InliningMap<'tcx> {\n-        InliningMap {\n-            index: FxHashMap::default(),\n-            targets: Vec::new(),\n-            inlines: GrowableBitSet::with_capacity(1024),\n-        }\n+        InliningMap { index: FxHashMap::default(), targets: Vec::new() }\n     }\n \n     fn record_accesses<'a>(\n         &mut self,\n         source: MonoItem<'tcx>,\n-        new_targets: &'a [(Spanned<MonoItem<'tcx>>, bool)],\n+        new_targets: &'a [Spanned<MonoItem<'tcx>>],\n     ) where\n         'tcx: 'a,\n     {\n         let start_index = self.targets.len();\n         let new_items_count = new_targets.len();\n-        let new_items_count_total = new_items_count + self.targets.len();\n \n         self.targets.reserve(new_items_count);\n-        self.inlines.ensure(new_items_count_total);\n \n-        for (i, (Spanned { node: mono_item, .. }, inlined)) in new_targets.into_iter().enumerate() {\n+        for Spanned { node: mono_item, .. } in new_targets.into_iter() {\n             self.targets.push(*mono_item);\n-            if *inlined {\n-                self.inlines.insert(i + start_index);\n-            }\n         }\n \n         let end_index = self.targets.len();\n@@ -300,13 +250,14 @@ impl<'tcx> InliningMap<'tcx> {\n \n     /// Internally iterate over all items referenced by `source` which will be\n     /// made available for inlining.\n-    pub fn with_inlining_candidates<F>(&self, source: MonoItem<'tcx>, mut f: F)\n+    pub fn with_inlining_candidates<F>(&self, tcx: TyCtxt<'tcx>, source: MonoItem<'tcx>, mut f: F)\n     where\n         F: FnMut(MonoItem<'tcx>),\n     {\n         if let Some(range) = self.index.get(&source) {\n-            for (i, candidate) in self.targets[range.clone()].iter().enumerate() {\n-                if self.inlines.contains(range.start + i) {\n+            for candidate in self.targets[range.clone()].iter() {\n+                let is_inlined = candidate.instantiation_mode(tcx) == InstantiationMode::LocalCopy;\n+                if is_inlined {\n                     f(*candidate);\n                 }\n             }\n@@ -367,7 +318,7 @@ pub fn collect_crate_mono_items(\n #[instrument(skip(tcx, mode), level = \"debug\")]\n fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<'_>> {\n     debug!(\"collecting roots\");\n-    let mut roots = MonoItems { compute_inlining: false, tcx, items: Vec::new() };\n+    let mut roots = Vec::new();\n \n     {\n         let entry_fn = tcx.entry_fn(());\n@@ -393,9 +344,8 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n     // whose predicates hold. Luckily, items that aren't instantiable\n     // can't actually be used, so we can just skip codegenning them.\n     roots\n-        .items\n         .into_iter()\n-        .filter_map(|(Spanned { node: mono_item, .. }, _)| {\n+        .filter_map(|Spanned { node: mono_item, .. }| {\n             mono_item.is_instantiable(tcx).then_some(mono_item)\n         })\n         .collect()\n@@ -417,7 +367,7 @@ fn collect_items_rec<'tcx>(\n         return;\n     }\n \n-    let mut neighbors = MonoItems { compute_inlining: true, tcx, items: Vec::new() };\n+    let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n \n     //\n@@ -542,9 +492,9 @@ fn collect_items_rec<'tcx>(\n             formatted_item,\n         });\n     }\n-    inlining_map.lock_mut().record_accesses(starting_point.node, &neighbors.items);\n+    inlining_map.lock_mut().record_accesses(starting_point.node, &neighbors);\n \n-    for (neighbour, _) in neighbors.items {\n+    for neighbour in neighbors {\n         collect_items_rec(tcx, neighbour, visited, recursion_depths, recursion_limit, inlining_map);\n     }\n "}, {"sha": "0bacb58383dc09e6bf745f8b594f76792850ad5e", "filename": "compiler/rustc_monomorphize/src/partitioning.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe123231ad0efcf16f183975b9b28304d63363e7/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe123231ad0efcf16f183975b9b28304d63363e7/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs?ref=fe123231ad0efcf16f183975b9b28304d63363e7", "patch": "@@ -424,7 +424,7 @@ fn place_inlined_mono_items<'tcx>(\n         // Collect all items that need to be available in this codegen unit.\n         let mut reachable = FxHashSet::default();\n         for root in old_codegen_unit.items().keys() {\n-            follow_inlining(*root, cx.inlining_map, &mut reachable);\n+            follow_inlining(cx.tcx, *root, cx.inlining_map, &mut reachable);\n         }\n \n         let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n@@ -478,6 +478,7 @@ fn place_inlined_mono_items<'tcx>(\n     return mono_item_placements;\n \n     fn follow_inlining<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n         mono_item: MonoItem<'tcx>,\n         inlining_map: &InliningMap<'tcx>,\n         visited: &mut FxHashSet<MonoItem<'tcx>>,\n@@ -486,8 +487,8 @@ fn place_inlined_mono_items<'tcx>(\n             return;\n         }\n \n-        inlining_map.with_inlining_candidates(mono_item, |target| {\n-            follow_inlining(target, inlining_map, visited);\n+        inlining_map.with_inlining_candidates(tcx, mono_item, |target| {\n+            follow_inlining(tcx, target, inlining_map, visited);\n         });\n     }\n }"}]}