{"sha": "3e4f40ec5aee04c0e5386153644255b6beeba095", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNGY0MGVjNWFlZTA0YzBlNTM4NjE1MzY0NDI1NWI2YmVlYmEwOTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-19T08:42:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-19T08:42:05Z"}, "message": "auto merge of #8564 : alexcrichton/rust/ifmt+++, r=graydon\n\nSee discussion in #8489, but this selects option 3 by adding a `Default` trait to be implemented by various basic types.\r\n\r\nOnce this makes it into a snapshot I think it's about time to start overhauling all current use-cases of `fmt!` to move towards `ifmt!`. The goal is to replace `%X` with `{}` in 90% of situations, and this commit should enable that.", "tree": {"sha": "76c18bfe4ce322f612b63f103bdc89d99eab00c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76c18bfe4ce322f612b63f103bdc89d99eab00c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e4f40ec5aee04c0e5386153644255b6beeba095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e4f40ec5aee04c0e5386153644255b6beeba095", "html_url": "https://github.com/rust-lang/rust/commit/3e4f40ec5aee04c0e5386153644255b6beeba095", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e4f40ec5aee04c0e5386153644255b6beeba095/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c178b52fe594c6724d0cf9124665de7e627899a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c178b52fe594c6724d0cf9124665de7e627899a9", "html_url": "https://github.com/rust-lang/rust/commit/c178b52fe594c6724d0cf9124665de7e627899a9"}, {"sha": "22c7bbfd0c49330015e24adeb0f2c45ae669c29f", "url": "https://api.github.com/repos/rust-lang/rust/commits/22c7bbfd0c49330015e24adeb0f2c45ae669c29f", "html_url": "https://github.com/rust-lang/rust/commit/22c7bbfd0c49330015e24adeb0f2c45ae669c29f"}], "stats": {"total": 137, "additions": 105, "deletions": 32}, "files": [{"sha": "db8a17c0bd07099b52e702ef6a377e4f25ce6ef0", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3e4f40ec5aee04c0e5386153644255b6beeba095/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e4f40ec5aee04c0e5386153644255b6beeba095/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=3e4f40ec5aee04c0e5386153644255b6beeba095", "patch": "@@ -356,28 +356,46 @@ pub struct Argument<'self> {\n     priv value: &'self util::Void,\n }\n \n+/// When a format is not otherwise specified, types are formatted by ascribing\n+/// to this trait. There is not an explicit way of selecting this trait to be\n+/// used for formatting, it is only if no other format is specified.\n+#[allow(missing_doc)]\n+pub trait Default { fn fmt(&Self, &mut Formatter); }\n+\n+/// Format trait for the `b` character\n #[allow(missing_doc)]\n pub trait Bool { fn fmt(&Self, &mut Formatter); }\n+/// Format trait for the `c` character\n #[allow(missing_doc)]\n pub trait Char { fn fmt(&Self, &mut Formatter); }\n+/// Format trait for the `i` and `d` characters\n #[allow(missing_doc)]\n pub trait Signed { fn fmt(&Self, &mut Formatter); }\n+/// Format trait for the `u` character\n #[allow(missing_doc)]\n pub trait Unsigned { fn fmt(&Self, &mut Formatter); }\n+/// Format trait for the `o` character\n #[allow(missing_doc)]\n pub trait Octal { fn fmt(&Self, &mut Formatter); }\n+/// Format trait for the `b` character\n #[allow(missing_doc)]\n pub trait Binary { fn fmt(&Self, &mut Formatter); }\n+/// Format trait for the `x` character\n #[allow(missing_doc)]\n pub trait LowerHex { fn fmt(&Self, &mut Formatter); }\n+/// Format trait for the `X` character\n #[allow(missing_doc)]\n pub trait UpperHex { fn fmt(&Self, &mut Formatter); }\n+/// Format trait for the `s` character\n #[allow(missing_doc)]\n pub trait String { fn fmt(&Self, &mut Formatter); }\n+/// Format trait for the `?` character\n #[allow(missing_doc)]\n pub trait Poly { fn fmt(&Self, &mut Formatter); }\n+/// Format trait for the `p` character\n #[allow(missing_doc)]\n pub trait Pointer { fn fmt(&Self, &mut Formatter); }\n+/// Format trait for the `f` character\n #[allow(missing_doc)]\n pub trait Float { fn fmt(&Self, &mut Formatter); }\n \n@@ -726,9 +744,9 @@ impl Bool for bool {\n     }\n }\n \n-impl<'self> String for &'self str {\n-    fn fmt(s: & &'self str, f: &mut Formatter) {\n-        f.pad(*s);\n+impl<'self, T: str::Str> String for T {\n+    fn fmt(s: &T, f: &mut Formatter) {\n+        f.pad(s.as_slice());\n     }\n }\n \n@@ -855,5 +873,37 @@ impl<T> Pointer for *const T {\n     }\n }\n \n+// Implementation of Default for various core types\n+\n+macro_rules! delegate(($ty:ty to $other:ident) => {\n+    impl<'self> Default for $ty {\n+        fn fmt(me: &$ty, f: &mut Formatter) {\n+            $other::fmt(me, f)\n+        }\n+    }\n+})\n+delegate!(int to Signed)\n+delegate!( i8 to Signed)\n+delegate!(i16 to Signed)\n+delegate!(i32 to Signed)\n+delegate!(i64 to Signed)\n+delegate!(uint to Unsigned)\n+delegate!(  u8 to Unsigned)\n+delegate!( u16 to Unsigned)\n+delegate!( u32 to Unsigned)\n+delegate!( u64 to Unsigned)\n+delegate!(@str to String)\n+delegate!(~str to String)\n+delegate!(&'self str to String)\n+delegate!(bool to Bool)\n+delegate!(char to Char)\n+delegate!(float to Float)\n+delegate!(f32 to Float)\n+delegate!(f64 to Float)\n+\n+impl<T> Default for *const T {\n+    fn fmt(me: &*const T, f: &mut Formatter) { Pointer::fmt(me, f) }\n+}\n+\n // If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n // it's a lot easier than creating all of the rt::Piece structures here."}, {"sha": "6448896a489419c4ac601e6a9b3529c88feabaad", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e4f40ec5aee04c0e5386153644255b6beeba095/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e4f40ec5aee04c0e5386153644255b6beeba095/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=3e4f40ec5aee04c0e5386153644255b6beeba095", "patch": "@@ -339,7 +339,11 @@ impl<'self> Parser<'self> {\n             }\n         }\n         // Finally the actual format specifier\n-        spec.ty = self.word();\n+        if self.consume('?') {\n+            spec.ty = \"?\";\n+        } else {\n+            spec.ty = self.word();\n+        }\n         return spec;\n     }\n "}, {"sha": "35be77b95c5f9ae1b850218a627dc175d621098d", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3e4f40ec5aee04c0e5386153644255b6beeba095/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e4f40ec5aee04c0e5386153644255b6beeba095/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=3e4f40ec5aee04c0e5386153644255b6beeba095", "patch": "@@ -623,19 +623,16 @@ impl Context {\n \n     fn format_arg(&self, sp: span, arg: Either<uint, @str>,\n                   ident: ast::ident) -> @ast::expr {\n-        let mut ty = match arg {\n+        let ty = match arg {\n             Left(i) => self.arg_types[i].unwrap(),\n             Right(s) => *self.name_types.get(&s)\n         };\n-        // Default types to '?' if nothing else is specified.\n-        if ty == Unknown {\n-            ty = Known(@\"?\");\n-        }\n \n         let argptr = self.ecx.expr_addr_of(sp, self.ecx.expr_ident(sp, ident));\n-        match ty {\n+        let fmt_trait = match ty {\n+            Unknown => \"Default\",\n             Known(tyname) => {\n-                let fmt_trait = match tyname.as_slice() {\n+                match tyname.as_slice() {\n                     \"?\" => \"Poly\",\n                     \"b\" => \"Bool\",\n                     \"c\" => \"Char\",\n@@ -653,35 +650,35 @@ impl Context {\n                                                     `%s`\", tyname));\n                         \"Dummy\"\n                     }\n-                };\n-                let format_fn = self.ecx.path_global(sp, ~[\n-                        self.ecx.ident_of(\"std\"),\n-                        self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(fmt_trait),\n-                        self.ecx.ident_of(\"fmt\"),\n-                    ]);\n-                self.ecx.expr_call_global(sp, ~[\n-                        self.ecx.ident_of(\"std\"),\n-                        self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(\"argument\"),\n-                    ], ~[self.ecx.expr_path(format_fn), argptr])\n+                }\n             }\n             String => {\n-                self.ecx.expr_call_global(sp, ~[\n+                return self.ecx.expr_call_global(sp, ~[\n                         self.ecx.ident_of(\"std\"),\n                         self.ecx.ident_of(\"fmt\"),\n                         self.ecx.ident_of(\"argumentstr\"),\n                     ], ~[argptr])\n             }\n             Unsigned => {\n-                self.ecx.expr_call_global(sp, ~[\n+                return self.ecx.expr_call_global(sp, ~[\n                         self.ecx.ident_of(\"std\"),\n                         self.ecx.ident_of(\"fmt\"),\n                         self.ecx.ident_of(\"argumentuint\"),\n                     ], ~[argptr])\n             }\n-            Unknown => { fail!() }\n-        }\n+        };\n+\n+        let format_fn = self.ecx.path_global(sp, ~[\n+                self.ecx.ident_of(\"std\"),\n+                self.ecx.ident_of(\"fmt\"),\n+                self.ecx.ident_of(fmt_trait),\n+                self.ecx.ident_of(\"fmt\"),\n+            ]);\n+        self.ecx.expr_call_global(sp, ~[\n+                self.ecx.ident_of(\"std\"),\n+                self.ecx.ident_of(\"fmt\"),\n+                self.ecx.ident_of(\"argument\"),\n+            ], ~[self.ecx.expr_path(format_fn), argptr])\n     }\n }\n "}, {"sha": "cba28463f990687f1a1854c9c376d92463e768c0", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3e4f40ec5aee04c0e5386153644255b6beeba095/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e4f40ec5aee04c0e5386153644255b6beeba095/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=3e4f40ec5aee04c0e5386153644255b6beeba095", "patch": "@@ -25,16 +25,36 @@ pub fn main() {\n     macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a, $b.to_owned()) })\n \n     // Make sure there's a poly formatter that takes anything\n-    t!(ifmt!(\"{}\", 1), \"1\");\n-    t!(ifmt!(\"{}\", A), \"{}\");\n-    t!(ifmt!(\"{}\", ()), \"()\");\n-    t!(ifmt!(\"{}\", @(~1, \"foo\")), \"@(~1, \\\"foo\\\")\");\n+    t!(ifmt!(\"{:?}\", 1), \"1\");\n+    t!(ifmt!(\"{:?}\", A), \"{}\");\n+    t!(ifmt!(\"{:?}\", ()), \"()\");\n+    t!(ifmt!(\"{:?}\", @(~1, \"foo\")), \"@(~1, \\\"foo\\\")\");\n \n     // Various edge cases without formats\n     t!(ifmt!(\"\"), \"\");\n     t!(ifmt!(\"hello\"), \"hello\");\n     t!(ifmt!(\"hello \\\\{\"), \"hello {\");\n \n+    // default formatters should work\n+    t!(ifmt!(\"{}\", 1i), \"1\");\n+    t!(ifmt!(\"{}\", 1i8), \"1\");\n+    t!(ifmt!(\"{}\", 1i16), \"1\");\n+    t!(ifmt!(\"{}\", 1i32), \"1\");\n+    t!(ifmt!(\"{}\", 1i64), \"1\");\n+    t!(ifmt!(\"{}\", 1u), \"1\");\n+    t!(ifmt!(\"{}\", 1u8), \"1\");\n+    t!(ifmt!(\"{}\", 1u16), \"1\");\n+    t!(ifmt!(\"{}\", 1u32), \"1\");\n+    t!(ifmt!(\"{}\", 1u64), \"1\");\n+    t!(ifmt!(\"{}\", 1.0f), \"1\");\n+    t!(ifmt!(\"{}\", 1.0f32), \"1\");\n+    t!(ifmt!(\"{}\", 1.0f64), \"1\");\n+    t!(ifmt!(\"{}\", \"a\"), \"a\");\n+    t!(ifmt!(\"{}\", ~\"a\"), \"a\");\n+    t!(ifmt!(\"{}\", @\"a\"), \"a\");\n+    t!(ifmt!(\"{}\", false), \"false\");\n+    t!(ifmt!(\"{}\", 'a'), \"a\");\n+\n     // At least exercise all the formats\n     t!(ifmt!(\"{:b}\", true), \"true\");\n     t!(ifmt!(\"{:c}\", '\u2603'), \"\u2603\");\n@@ -45,6 +65,8 @@ pub fn main() {\n     t!(ifmt!(\"{:x}\", 10u), \"a\");\n     t!(ifmt!(\"{:X}\", 10u), \"A\");\n     t!(ifmt!(\"{:s}\", \"foo\"), \"foo\");\n+    t!(ifmt!(\"{:s}\", ~\"foo\"), \"foo\");\n+    t!(ifmt!(\"{:s}\", @\"foo\"), \"foo\");\n     t!(ifmt!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n     t!(ifmt!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n     t!(ifmt!(\"{:d}\", A), \"aloha\");\n@@ -54,7 +76,7 @@ pub fn main() {\n     t!(ifmt!(\"{foo} {bar}\", foo=0, bar=1), \"0 1\");\n     t!(ifmt!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n     t!(ifmt!(\"{} {0:s}\", \"a\"), \"a a\");\n-    t!(ifmt!(\"{} {0}\", \"a\"), \"\\\"a\\\" \\\"a\\\"\");\n+    t!(ifmt!(\"{} {0}\", \"a\"), \"a a\");\n \n     // Methods should probably work\n     t!(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 0u), \"c0\");"}]}