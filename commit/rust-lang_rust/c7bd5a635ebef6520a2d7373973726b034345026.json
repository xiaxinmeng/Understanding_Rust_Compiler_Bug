{"sha": "c7bd5a635ebef6520a2d7373973726b034345026", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3YmQ1YTYzNWViZWY2NTIwYTJkNzM3Mzk3MzcyNmIwMzQzNDUwMjY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2020-05-08T16:27:59Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2020-05-10T02:30:48Z"}, "message": "Fix disagreeement about CGU reuse and LTO\n\nThis commit fixes an issue where the codegen backend's selection of LTO\ndisagreed with what the codegen later thought was being done. Discovered\nin #72006 we have a longstanding issue where if `-Clinker-plugin-lto` in\noptimized mode is compiled incrementally it will always panic on the\nsecond compilation. The underlying issue turned out to be that the\nproduction of the original artifact determined that LTO should not be\ndone (because it's being postponed to the linker) but the CGU reuse\nselection thought that LTO was done so it was trying to load pre-LTO\nartifacts which were never generated.\n\nThe fix here is to ensure that the logic when generating code which\ndetermines what kind of LTO is being done is shared amongst the CGU\nreuse decision and the backend actually doing LTO. This means that\nthey'll both be in agreement about whether the previous compilation did\nindeed produce incremental pre-LTO artifacts.\n\nCloses #72006", "tree": {"sha": "fefe0381b69da795dccf90969861dc542c3e5478", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fefe0381b69da795dccf90969861dc542c3e5478"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7bd5a635ebef6520a2d7373973726b034345026", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7bd5a635ebef6520a2d7373973726b034345026", "html_url": "https://github.com/rust-lang/rust/commit/c7bd5a635ebef6520a2d7373973726b034345026", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7bd5a635ebef6520a2d7373973726b034345026/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a51e004e1bf7f9bba151dd9104a217c1ace6a0a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a51e004e1bf7f9bba151dd9104a217c1ace6a0a2", "html_url": "https://github.com/rust-lang/rust/commit/a51e004e1bf7f9bba151dd9104a217c1ace6a0a2"}], "stats": {"total": 106, "additions": 71, "deletions": 35}, "files": [{"sha": "e5bd18ed680de10cff46edf3da2f20dbd6a2bd50", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c7bd5a635ebef6520a2d7373973726b034345026/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bd5a635ebef6520a2d7373973726b034345026/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=c7bd5a635ebef6520a2d7373973726b034345026", "patch": "@@ -715,38 +715,34 @@ fn execute_work_item<B: ExtraBackendMethods>(\n }\n \n // Actual LTO type we end up choosing based on multiple factors.\n-enum ComputedLtoType {\n+pub enum ComputedLtoType {\n     No,\n     Thin,\n     Fat,\n }\n \n-fn execute_optimize_work_item<B: ExtraBackendMethods>(\n-    cgcx: &CodegenContext<B>,\n-    module: ModuleCodegen<B::Module>,\n-    module_config: &ModuleConfig,\n-) -> Result<WorkItemResult<B>, FatalError> {\n-    let diag_handler = cgcx.create_diag_handler();\n-\n-    unsafe {\n-        B::optimize(cgcx, &diag_handler, &module, module_config)?;\n+pub fn compute_per_cgu_lto_type(\n+    sess_lto: &Lto,\n+    opts: &config::Options,\n+    sess_crate_types: &[CrateType],\n+    module_kind: ModuleKind,\n+) -> ComputedLtoType {\n+    // Metadata modules never participate in LTO regardless of the lto\n+    // settings.\n+    if module_kind == ModuleKind::Metadata {\n+        return ComputedLtoType::No;\n     }\n \n-    // After we've done the initial round of optimizations we need to\n-    // decide whether to synchronously codegen this module or ship it\n-    // back to the coordinator thread for further LTO processing (which\n-    // has to wait for all the initial modules to be optimized).\n-\n     // If the linker does LTO, we don't have to do it. Note that we\n     // keep doing full LTO, if it is requested, as not to break the\n     // assumption that the output will be a single module.\n-    let linker_does_lto = cgcx.opts.cg.linker_plugin_lto.enabled();\n+    let linker_does_lto = opts.cg.linker_plugin_lto.enabled();\n \n     // When we're automatically doing ThinLTO for multi-codegen-unit\n     // builds we don't actually want to LTO the allocator modules if\n     // it shows up. This is due to various linker shenanigans that\n     // we'll encounter later.\n-    let is_allocator = module.kind == ModuleKind::Allocator;\n+    let is_allocator = module_kind == ModuleKind::Allocator;\n \n     // We ignore a request for full crate grath LTO if the cate type\n     // is only an rlib, as there is no full crate graph to process,\n@@ -756,20 +752,33 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n     // require LTO so the request for LTO is always unconditionally\n     // passed down to the backend, but we don't actually want to do\n     // anything about it yet until we've got a final product.\n-    let is_rlib = cgcx.crate_types.len() == 1 && cgcx.crate_types[0] == CrateType::Rlib;\n+    let is_rlib = sess_crate_types.len() == 1 && sess_crate_types[0] == CrateType::Rlib;\n \n-    // Metadata modules never participate in LTO regardless of the lto\n-    // settings.\n-    let lto_type = if module.kind == ModuleKind::Metadata {\n-        ComputedLtoType::No\n-    } else {\n-        match cgcx.lto {\n-            Lto::ThinLocal if !linker_does_lto && !is_allocator => ComputedLtoType::Thin,\n-            Lto::Thin if !linker_does_lto && !is_rlib => ComputedLtoType::Thin,\n-            Lto::Fat if !is_rlib => ComputedLtoType::Fat,\n-            _ => ComputedLtoType::No,\n-        }\n-    };\n+    match sess_lto {\n+        Lto::ThinLocal if !linker_does_lto && !is_allocator => ComputedLtoType::Thin,\n+        Lto::Thin if !linker_does_lto && !is_rlib => ComputedLtoType::Thin,\n+        Lto::Fat if !is_rlib => ComputedLtoType::Fat,\n+        _ => ComputedLtoType::No,\n+    }\n+}\n+\n+fn execute_optimize_work_item<B: ExtraBackendMethods>(\n+    cgcx: &CodegenContext<B>,\n+    module: ModuleCodegen<B::Module>,\n+    module_config: &ModuleConfig,\n+) -> Result<WorkItemResult<B>, FatalError> {\n+    let diag_handler = cgcx.create_diag_handler();\n+\n+    unsafe {\n+        B::optimize(cgcx, &diag_handler, &module, module_config)?;\n+    }\n+\n+    // After we've done the initial round of optimizations we need to\n+    // decide whether to synchronously codegen this module or ship it\n+    // back to the coordinator thread for further LTO processing (which\n+    // has to wait for all the initial modules to be optimized).\n+\n+    let lto_type = compute_per_cgu_lto_type(&cgcx.lto, &cgcx.opts, &cgcx.crate_types, module.kind);\n \n     // If we're doing some form of incremental LTO then we need to be sure to\n     // save our module to disk first."}, {"sha": "29398db6ff8a95b192db0fdfe797698b1ab91054", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c7bd5a635ebef6520a2d7373973726b034345026/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bd5a635ebef6520a2d7373973726b034345026/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=c7bd5a635ebef6520a2d7373973726b034345026", "patch": "@@ -14,8 +14,8 @@\n //!   int)` and `rec(x=int, y=int, z=int)` will have the same `llvm::Type`.\n \n use crate::back::write::{\n-    start_async_codegen, submit_codegened_module_to_llvm, submit_post_lto_module_to_llvm,\n-    submit_pre_lto_module_to_llvm, OngoingCodegen,\n+    compute_per_cgu_lto_type, start_async_codegen, submit_codegened_module_to_llvm,\n+    submit_post_lto_module_to_llvm, submit_pre_lto_module_to_llvm, ComputedLtoType, OngoingCodegen,\n };\n use crate::common::{IntPredicate, RealPredicate, TypeKind};\n use crate::meth;\n@@ -43,7 +43,7 @@ use rustc_middle::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n-use rustc_session::config::{self, EntryFnType, Lto};\n+use rustc_session::config::{self, EntryFnType};\n use rustc_session::Session;\n use rustc_span::Span;\n use rustc_symbol_mangling::test as symbol_names_test;\n@@ -941,8 +941,18 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n     );\n \n     if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n-        // We can re-use either the pre- or the post-thinlto state\n-        if tcx.sess.lto() != Lto::No { CguReuse::PreLto } else { CguReuse::PostLto }\n+        // We can re-use either the pre- or the post-thinlto state. If no LTO is\n+        // being performed then we can use post-LTO artifacts, otherwise we must\n+        // reuse pre-LTO artifacts\n+        match compute_per_cgu_lto_type(\n+            &tcx.sess.lto(),\n+            &tcx.sess.opts,\n+            &tcx.sess.crate_types.borrow(),\n+            ModuleKind::Regular,\n+        ) {\n+            ComputedLtoType::No => CguReuse::PostLto,\n+            _ => CguReuse::PreLto,\n+        }\n     } else {\n         CguReuse::No\n     }"}, {"sha": "0e8c1ebb9198a7ed87af4b29668b59c4f9b5e1e0", "filename": "src/test/incremental/lto-in-linker.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c7bd5a635ebef6520a2d7373973726b034345026/src%2Ftest%2Fincremental%2Flto-in-linker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bd5a635ebef6520a2d7373973726b034345026/src%2Ftest%2Fincremental%2Flto-in-linker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Flto-in-linker.rs?ref=c7bd5a635ebef6520a2d7373973726b034345026", "patch": "@@ -0,0 +1,9 @@\n+// revisions:cfail1 cfail2\n+// compile-flags: -Z query-dep-graph --crate-type rlib -C linker-plugin-lto -O\n+// no-prefer-dynamic\n+// build-pass\n+\n+#![feature(rustc_attrs)]\n+#![rustc_partition_reused(module = \"lto_in_linker\", cfg = \"cfail2\")]\n+\n+pub fn foo() {}"}, {"sha": "752fee5a0d5b6f959985898dd687f4b5371dc7c1", "filename": "src/test/incremental/rlib-lto.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7bd5a635ebef6520a2d7373973726b034345026/src%2Ftest%2Fincremental%2Frlib-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bd5a635ebef6520a2d7373973726b034345026/src%2Ftest%2Fincremental%2Frlib-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib-lto.rs?ref=c7bd5a635ebef6520a2d7373973726b034345026", "patch": "@@ -0,0 +1,8 @@\n+// revisions:cfail1 cfail2\n+// compile-flags: -Z query-dep-graph --crate-type rlib -C lto\n+// build-pass\n+\n+#![feature(rustc_attrs)]\n+#![rustc_partition_reused(module = \"rlib_lto\", cfg = \"cfail2\")]\n+\n+pub fn foo() {}"}]}