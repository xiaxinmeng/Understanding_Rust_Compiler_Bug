{"sha": "74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0YWRlZGE3OGE4MDdkNGU3ZTM1OThmYTBiM2RkNTQ3MGJiODlmYzI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-17T09:49:45Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-17T09:49:45Z"}, "message": "Rollup merge of #23400 - nrc:pub_use, r=eddyb\n\n r? @eddyb", "tree": {"sha": "2c6d0a4848fb5a1d573fbf65f5e2d6640f1b1552", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c6d0a4848fb5a1d573fbf65f5e2d6640f1b1552"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "html_url": "https://github.com/rust-lang/rust/commit/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd", "html_url": "https://github.com/rust-lang/rust/commit/285cb8e6d8e4802c3c36d6c00d9c3752c2cc13bd"}, {"sha": "1fd38c181a5cadb854dd8eb22d1ba1b7f009a12f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fd38c181a5cadb854dd8eb22d1ba1b7f009a12f", "html_url": "https://github.com/rust-lang/rust/commit/1fd38c181a5cadb854dd8eb22d1ba1b7f009a12f"}], "stats": {"total": 2280, "additions": 1177, "deletions": 1103}, "files": [{"sha": "3fae49bfc6d3ef23e166d125b9a8ea8f409ec2cc", "filename": "src/doc/reference.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -1961,16 +1961,18 @@ module through the rules above. It essentially allows public access into the\n re-exported item. For example, this program is valid:\n \n ```\n-pub use self::implementation as api;\n+pub use self::implementation::api;\n \n mod implementation {\n-    pub fn f() {}\n+    pub mod api {\n+        pub fn f() {}\n+    }\n }\n \n # fn main() {}\n ```\n \n-This means that any external crate referencing `implementation::f` would\n+This means that any external crate referencing `implementation::api::f` would\n receive a privacy violation, while the path `api::f` would be allowed.\n \n When re-exporting a private item, it can be thought of as allowing the \"privacy"}, {"sha": "e62300098f678bb6d26d8d80b2a2c8f06a40b5b7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -14,16 +14,17 @@\n //! any imports resolved.\n \n use {DefModifiers, PUBLIC, IMPORTABLE};\n-use ImportDirective;\n-use ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n-use ImportResolution;\n+use resolve_imports::ImportDirective;\n+use resolve_imports::ImportDirectiveSubclass::{self, SingleImport, GlobImport};\n+use resolve_imports::ImportResolution;\n use Module;\n use ModuleKind::*;\n use Namespace::{TypeNS, ValueNS};\n use NameBindings;\n+use {names_to_string, module_to_string};\n use ParentLink::{self, ModuleParentLink, BlockParentLink};\n use Resolver;\n-use Shadowable;\n+use resolve_imports::Shadowable;\n use TypeNsDef;\n \n use self::DuplicateCheckingMode::*;\n@@ -371,8 +372,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n             ItemExternCrate(_) => {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n-                for &crate_id in self.session.cstore\n-                                     .find_extern_mod_stmt_cnum(item.id).iter() {\n+                if let Some(crate_id) = self.session.cstore.find_extern_mod_stmt_cnum(item.id) {\n                     let def_id = DefId { krate: crate_id, node: 0 };\n                     self.external_exports.insert(def_id);\n                     let parent_link = ModuleParentLink(parent.downgrade(), name);\n@@ -382,7 +382,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                               false,\n                                                               true));\n                     debug!(\"(build reduced graph for item) found extern `{}`\",\n-                            self.module_to_string(&*external_module));\n+                            module_to_string(&*external_module));\n                     self.check_for_conflicts_between_external_crates(&**parent, name, sp);\n                     parent.external_module_children.borrow_mut()\n                           .insert(name, external_module.clone());\n@@ -400,7 +400,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                             Some(def_id),\n                                             NormalModuleKind,\n                                             false,\n-                                            item.vis == ast::Public,\n+                                            is_public,\n                                             sp);\n \n                 name_bindings.get_module()\n@@ -432,8 +432,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             // These items live in the type namespace.\n             ItemTy(..) => {\n                 let name_bindings =\n-                    self.add_child(name, parent, ForbidDuplicateTypesAndModules,\n-                                   sp);\n+                    self.add_child(name, parent, ForbidDuplicateTypesAndModules, sp);\n \n                 name_bindings.define_type(DefTy(local_def(item.id), false), sp,\n                                           modifiers);\n@@ -517,7 +516,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                             Some(local_def(item.id)),\n                                             TraitModuleKind,\n                                             false,\n-                                            item.vis == ast::Public,\n+                                            is_public,\n                                             sp);\n                 let module_parent = name_bindings.get_module();\n \n@@ -636,8 +635,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                            name: Name,\n                            new_parent: &Rc<Module>) {\n         debug!(\"(building reduced graph for \\\n-                external crate) building external def, priv {:?}\",\n-               vis);\n+                external crate) building external def {}, priv {:?}\",\n+               final_ident, vis);\n         let is_public = vis == ast::Public;\n         let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n         let is_exported = is_public && match new_parent.def_id.get() {\n@@ -667,7 +666,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n               Some(_) | None => {\n                 debug!(\"(building reduced graph for \\\n                         external crate) building module \\\n-                        {}\", final_ident);\n+                        {} {}\", final_ident, is_public);\n                 let parent_link = self.get_parent_link(new_parent, name);\n \n                 child_name_bindings.define_module(parent_link,\n@@ -838,7 +837,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     /// Builds the reduced graph rooted at the given external module.\n     fn populate_external_module(&mut self, module: &Rc<Module>) {\n         debug!(\"(populating external module) attempting to populate {}\",\n-               self.module_to_string(&**module));\n+               module_to_string(&**module));\n \n         let def_id = match module.def_id.get() {\n             None => {\n@@ -904,18 +903,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n         match subclass {\n             SingleImport(target, _) => {\n-                debug!(\"(building import directive) building import \\\n-                        directive: {}::{}\",\n-                       self.names_to_string(&module_.imports.borrow().last().unwrap().\n-                                                             module_path),\n+                debug!(\"(building import directive) building import directive: {}::{}\",\n+                       names_to_string(&module_.imports.borrow().last().unwrap().module_path),\n                        token::get_name(target));\n \n-                let mut import_resolutions = module_.import_resolutions\n-                                                    .borrow_mut();\n+                let mut import_resolutions = module_.import_resolutions.borrow_mut();\n                 match import_resolutions.get_mut(&target) {\n                     Some(resolution) => {\n-                        debug!(\"(building import directive) bumping \\\n-                                reference\");\n+                        debug!(\"(building import directive) bumping reference\");\n                         resolution.outstanding_references += 1;\n \n                         // the source of this name is different now"}, {"sha": "c586faae6e886dd32f5c398085c401904fe3fa41", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -24,7 +24,9 @@ register_diagnostics! {\n     E0258, // import conflicts with existing submodule\n     E0259, // an extern crate has already been imported into this module\n     E0260, // name conflicts with an external crate that has been imported into this module\n-    E0317 // user-defined types or type parameters cannot shadow the primitive types\n+    E0317, // user-defined types or type parameters cannot shadow the primitive types\n+    E0364, // item is private\n+    E0365  // item is private\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "67e9f71551a22ed57a556a2b24c201cefa4f0904", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 98, "deletions": 1043, "changes": 1141, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -38,7 +38,6 @@ use self::PatternBindingMode::*;\n use self::Namespace::*;\n use self::NamespaceResult::*;\n use self::NameDefinition::*;\n-use self::ImportDirectiveSubclass::*;\n use self::ResolveResult::*;\n use self::FallbackSuggestion::*;\n use self::TypeParameters::*;\n@@ -98,13 +97,18 @@ use std::mem::replace;\n use std::rc::{Rc, Weak};\n use std::usize;\n \n+use resolve_imports::{Target, ImportDirective, ImportResolution};\n+use resolve_imports::Shadowable;\n+\n+\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n pub mod diagnostics;\n \n mod check_unused;\n mod record_exports;\n mod build_reduced_graph;\n+mod resolve_imports;\n \n #[derive(Copy)]\n struct BindingInfo {\n@@ -253,13 +257,6 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n     }\n }\n \n-/// Contains data for specific types of import directives.\n-#[derive(Copy,Debug)]\n-enum ImportDirectiveSubclass {\n-    SingleImport(Name /* target */, Name /* source */),\n-    GlobImport\n-}\n-\n type ErrorMessage = Option<(Span, String)>;\n \n enum ResolveResult<T> {\n@@ -366,144 +363,6 @@ impl Rib {\n     }\n }\n \n-/// Whether an import can be shadowed by another import.\n-#[derive(Debug,PartialEq,Clone,Copy)]\n-enum Shadowable {\n-    Always,\n-    Never\n-}\n-\n-/// One import directive.\n-#[derive(Debug)]\n-struct ImportDirective {\n-    module_path: Vec<Name>,\n-    subclass: ImportDirectiveSubclass,\n-    span: Span,\n-    id: NodeId,\n-    is_public: bool, // see note in ImportResolution about how to use this\n-    shadowable: Shadowable,\n-}\n-\n-impl ImportDirective {\n-    fn new(module_path: Vec<Name> ,\n-           subclass: ImportDirectiveSubclass,\n-           span: Span,\n-           id: NodeId,\n-           is_public: bool,\n-           shadowable: Shadowable)\n-           -> ImportDirective {\n-        ImportDirective {\n-            module_path: module_path,\n-            subclass: subclass,\n-            span: span,\n-            id: id,\n-            is_public: is_public,\n-            shadowable: shadowable,\n-        }\n-    }\n-}\n-\n-/// The item that an import resolves to.\n-#[derive(Clone,Debug)]\n-struct Target {\n-    target_module: Rc<Module>,\n-    bindings: Rc<NameBindings>,\n-    shadowable: Shadowable,\n-}\n-\n-impl Target {\n-    fn new(target_module: Rc<Module>,\n-           bindings: Rc<NameBindings>,\n-           shadowable: Shadowable)\n-           -> Target {\n-        Target {\n-            target_module: target_module,\n-            bindings: bindings,\n-            shadowable: shadowable,\n-        }\n-    }\n-}\n-\n-/// An ImportResolution represents a particular `use` directive.\n-#[derive(Debug)]\n-struct ImportResolution {\n-    /// Whether this resolution came from a `use` or a `pub use`. Note that this\n-    /// should *not* be used whenever resolution is being performed, this is\n-    /// only looked at for glob imports statements currently. Privacy testing\n-    /// occurs during a later phase of compilation.\n-    is_public: bool,\n-\n-    // The number of outstanding references to this name. When this reaches\n-    // zero, outside modules can count on the targets being correct. Before\n-    // then, all bets are off; future imports could override this name.\n-    outstanding_references: uint,\n-\n-    /// The value that this `use` directive names, if there is one.\n-    value_target: Option<Target>,\n-    /// The source node of the `use` directive leading to the value target\n-    /// being non-none\n-    value_id: NodeId,\n-\n-    /// The type that this `use` directive names, if there is one.\n-    type_target: Option<Target>,\n-    /// The source node of the `use` directive leading to the type target\n-    /// being non-none\n-    type_id: NodeId,\n-}\n-\n-impl ImportResolution {\n-    fn new(id: NodeId, is_public: bool) -> ImportResolution {\n-        ImportResolution {\n-            type_id: id,\n-            value_id: id,\n-            outstanding_references: 0,\n-            value_target: None,\n-            type_target: None,\n-            is_public: is_public,\n-        }\n-    }\n-\n-    fn target_for_namespace(&self, namespace: Namespace)\n-                                -> Option<Target> {\n-        match namespace {\n-            TypeNS  => self.type_target.clone(),\n-            ValueNS => self.value_target.clone(),\n-        }\n-    }\n-\n-    fn id(&self, namespace: Namespace) -> NodeId {\n-        match namespace {\n-            TypeNS  => self.type_id,\n-            ValueNS => self.value_id,\n-        }\n-    }\n-\n-    fn shadowable(&self, namespace: Namespace) -> Shadowable {\n-        let target = self.target_for_namespace(namespace);\n-        if target.is_none() {\n-            return Shadowable::Always;\n-        }\n-\n-        target.unwrap().shadowable\n-    }\n-\n-    fn set_target_and_id(&mut self,\n-                         namespace: Namespace,\n-                         target: Option<Target>,\n-                         id: NodeId) {\n-        match namespace {\n-            TypeNS  => {\n-                self.type_target = target;\n-                self.type_id = id;\n-            }\n-            ValueNS => {\n-                self.value_target = target;\n-                self.value_id = id;\n-            }\n-        }\n-    }\n-}\n-\n /// The link from a module up to its nearest parent node.\n #[derive(Clone,Debug)]\n enum ParentLink {\n@@ -855,6 +714,19 @@ impl NameBindings {\n             None\n         }\n     }\n+\n+    fn is_public(&self, namespace: Namespace) -> bool {\n+        match namespace {\n+            TypeNS  => {\n+                let type_def = self.type_def.borrow();\n+                type_def.as_ref().unwrap().modifiers.contains(PUBLIC)\n+            }\n+            ValueNS => {\n+                let value_def = self.value_def.borrow();\n+                value_def.as_ref().unwrap().modifiers.contains(PUBLIC)\n+            }\n+        }\n+    }\n }\n \n /// Interns the names of the primitive types.\n@@ -963,7 +835,6 @@ enum FallbackChecks {\n     OnlyTraitAndStatics\n }\n \n-\n impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn new(session: &'a Session,\n            ast_map: &'a ast_map::Map<'tcx>,\n@@ -1023,151 +894,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    // Import resolution\n-    //\n-    // This is a fixed-point algorithm. We resolve imports until our efforts\n-    // are stymied by an unresolved import; then we bail out of the current\n-    // module and continue. We terminate successfully once no more imports\n-    // remain or unsuccessfully when no forward progress in resolving imports\n-    // is made.\n-\n-    /// Resolves all imports for the crate. This method performs the fixed-\n-    /// point iteration.\n-    fn resolve_imports(&mut self) {\n-        let mut i = 0;\n-        let mut prev_unresolved_imports = 0;\n-        loop {\n-            debug!(\"(resolving imports) iteration {}, {} imports left\",\n-                   i, self.unresolved_imports);\n-\n-            let module_root = self.graph_root.get_module();\n-            self.resolve_imports_for_module_subtree(module_root.clone());\n-\n-            if self.unresolved_imports == 0 {\n-                debug!(\"(resolving imports) success\");\n-                break;\n-            }\n-\n-            if self.unresolved_imports == prev_unresolved_imports {\n-                self.report_unresolved_imports(module_root);\n-                break;\n-            }\n-\n-            i += 1;\n-            prev_unresolved_imports = self.unresolved_imports;\n-        }\n-    }\n-\n-    /// Attempts to resolve imports for the given module and all of its\n-    /// submodules.\n-    fn resolve_imports_for_module_subtree(&mut self, module_: Rc<Module>) {\n-        debug!(\"(resolving imports for module subtree) resolving {}\",\n-               self.module_to_string(&*module_));\n-        let orig_module = replace(&mut self.current_module, module_.clone());\n-        self.resolve_imports_for_module(module_.clone());\n-        self.current_module = orig_module;\n-\n-        build_reduced_graph::populate_module_if_necessary(self, &module_);\n-        for (_, child_node) in &*module_.children.borrow() {\n-            match child_node.get_module_if_available() {\n-                None => {\n-                    // Nothing to do.\n-                }\n-                Some(child_module) => {\n-                    self.resolve_imports_for_module_subtree(child_module);\n-                }\n-            }\n-        }\n-\n-        for (_, child_module) in &*module_.anonymous_children.borrow() {\n-            self.resolve_imports_for_module_subtree(child_module.clone());\n-        }\n-    }\n-\n-    /// Attempts to resolve imports for the given module only.\n-    fn resolve_imports_for_module(&mut self, module: Rc<Module>) {\n-        if module.all_imports_resolved() {\n-            debug!(\"(resolving imports for module) all imports resolved for \\\n-                   {}\",\n-                   self.module_to_string(&*module));\n-            return;\n-        }\n-\n-        let imports = module.imports.borrow();\n-        let import_count = imports.len();\n-        while module.resolved_import_count.get() < import_count {\n-            let import_index = module.resolved_import_count.get();\n-            let import_directive = &(*imports)[import_index];\n-            match self.resolve_import_for_module(module.clone(),\n-                                                 import_directive) {\n-                Failed(err) => {\n-                    let (span, help) = match err {\n-                        Some((span, msg)) => (span, format!(\". {}\", msg)),\n-                        None => (import_directive.span, String::new())\n-                    };\n-                    let msg = format!(\"unresolved import `{}`{}\",\n-                                      self.import_path_to_string(\n-                                          &import_directive.module_path,\n-                                          import_directive.subclass),\n-                                      help);\n-                    self.resolve_error(span, &msg[..]);\n-                }\n-                Indeterminate => break, // Bail out. We'll come around next time.\n-                Success(()) => () // Good. Continue.\n-            }\n-\n-            module.resolved_import_count\n-                  .set(module.resolved_import_count.get() + 1);\n-        }\n-    }\n-\n-    fn names_to_string(&self, names: &[Name]) -> String {\n-        let mut first = true;\n-        let mut result = String::new();\n-        for name in names {\n-            if first {\n-                first = false\n-            } else {\n-                result.push_str(\"::\")\n-            }\n-            result.push_str(&token::get_name(*name));\n-        };\n-        result\n-    }\n-\n-    fn path_names_to_string(&self, path: &Path, depth: usize) -> String {\n-        let names: Vec<ast::Name> = path.segments[..path.segments.len()-depth]\n-                                        .iter()\n-                                        .map(|seg| seg.identifier.name)\n-                                        .collect();\n-        self.names_to_string(&names[..])\n-    }\n-\n-    fn import_directive_subclass_to_string(&mut self,\n-                                        subclass: ImportDirectiveSubclass)\n-                                        -> String {\n-        match subclass {\n-            SingleImport(_, source) => {\n-                token::get_name(source).to_string()\n-            }\n-            GlobImport => \"*\".to_string()\n-        }\n-    }\n-\n-    fn import_path_to_string(&mut self,\n-                          names: &[Name],\n-                          subclass: ImportDirectiveSubclass)\n-                          -> String {\n-        if names.is_empty() {\n-            self.import_directive_subclass_to_string(subclass)\n-        } else {\n-            (format!(\"{}::{}\",\n-                     self.names_to_string(names),\n-                     self.import_directive_subclass_to_string(\n-                         subclass))).to_string()\n-        }\n-    }\n-\n     #[inline]\n     fn record_import_use(&mut self, import_id: NodeId, name: Name) {\n         if !self.make_glob_map {\n@@ -1191,102 +917,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    /// Attempts to resolve the given import. The return value indicates\n-    /// failure if we're certain the name does not exist, indeterminate if we\n-    /// don't know whether the name exists at the moment due to other\n-    /// currently-unresolved imports, or success if we know the name exists.\n-    /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import_for_module(&mut self,\n-                                 module_: Rc<Module>,\n-                                 import_directive: &ImportDirective)\n-                                 -> ResolveResult<()> {\n-        let mut resolution_result = Failed(None);\n-        let module_path = &import_directive.module_path;\n-\n-        debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               self.names_to_string(&module_path[..]),\n-               self.module_to_string(&*module_));\n-\n-        // First, resolve the module path for the directive, if necessary.\n-        let container = if module_path.len() == 0 {\n-            // Use the crate root.\n-            Some((self.graph_root.get_module(), LastMod(AllPublic)))\n-        } else {\n-            match self.resolve_module_path(module_.clone(),\n-                                           &module_path[..],\n-                                           DontUseLexicalScope,\n-                                           import_directive.span,\n-                                           ImportSearch) {\n-                Failed(err) => {\n-                    resolution_result = Failed(err);\n-                    None\n-                },\n-                Indeterminate => {\n-                    resolution_result = Indeterminate;\n-                    None\n-                }\n-                Success(container) => Some(container),\n-            }\n-        };\n-\n-        match container {\n-            None => {}\n-            Some((containing_module, lp)) => {\n-                // We found the module that the target is contained\n-                // within. Attempt to resolve the import within it.\n-\n-                match import_directive.subclass {\n-                    SingleImport(target, source) => {\n-                        resolution_result =\n-                            self.resolve_single_import(&*module_,\n-                                                       containing_module,\n-                                                       target,\n-                                                       source,\n-                                                       import_directive,\n-                                                       lp);\n-                    }\n-                    GlobImport => {\n-                        resolution_result =\n-                            self.resolve_glob_import(&*module_,\n-                                                     containing_module,\n-                                                     import_directive,\n-                                                     lp);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Decrement the count of unresolved imports.\n-        match resolution_result {\n-            Success(()) => {\n-                assert!(self.unresolved_imports >= 1);\n-                self.unresolved_imports -= 1;\n-            }\n-            _ => {\n-                // Nothing to do here; just return the error.\n-            }\n-        }\n-\n-        // Decrement the count of unresolved globs if necessary. But only if\n-        // the resolution result is indeterminate -- otherwise we'll stop\n-        // processing imports here. (See the loop in\n-        // resolve_imports_for_module.)\n-\n-        if !resolution_result.indeterminate() {\n-            match import_directive.subclass {\n-                GlobImport => {\n-                    assert!(module_.glob_count.get() >= 1);\n-                    module_.glob_count.set(module_.glob_count.get() - 1);\n-                }\n-                SingleImport(..) => {\n-                    // Ignore.\n-                }\n-            }\n-        }\n-\n-        return resolution_result;\n-    }\n-\n     fn create_name_bindings_from_module(module: Rc<Module>) -> NameBindings {\n         NameBindings {\n             type_def: RefCell::new(Some(TypeNsDef {\n@@ -1299,604 +929,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n     }\n \n-    fn resolve_single_import(&mut self,\n-                             module_: &Module,\n-                             containing_module: Rc<Module>,\n-                             target: Name,\n-                             source: Name,\n-                             directive: &ImportDirective,\n-                             lp: LastPrivate)\n-                                 -> ResolveResult<()> {\n-        debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n-                `{}` id {}, last private {:?}\",\n-               token::get_name(target),\n-               self.module_to_string(&*containing_module),\n-               token::get_name(source),\n-               self.module_to_string(module_),\n-               directive.id,\n-               lp);\n-\n-        let lp = match lp {\n-            LastMod(lp) => lp,\n-            LastImport {..} => {\n-                self.session\n-                    .span_bug(directive.span,\n-                              \"not expecting Import here, must be LastMod\")\n-            }\n-        };\n-\n-        // We need to resolve both namespaces for this to succeed.\n-        //\n-\n-        let mut value_result = UnknownResult;\n-        let mut type_result = UnknownResult;\n-\n-        // Search for direct children of the containing module.\n-        build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n-\n-        match containing_module.children.borrow().get(&source) {\n-            None => {\n-                // Continue.\n-            }\n-            Some(ref child_name_bindings) => {\n-                if child_name_bindings.defined_in_namespace(ValueNS) {\n-                    debug!(\"(resolving single import) found value binding\");\n-                    value_result = BoundResult(containing_module.clone(),\n-                                               (*child_name_bindings).clone());\n-                }\n-                if child_name_bindings.defined_in_namespace(TypeNS) {\n-                    debug!(\"(resolving single import) found type binding\");\n-                    type_result = BoundResult(containing_module.clone(),\n-                                              (*child_name_bindings).clone());\n-                }\n-            }\n-        }\n-\n-        // Unless we managed to find a result in both namespaces (unlikely),\n-        // search imports as well.\n-        let mut value_used_reexport = false;\n-        let mut type_used_reexport = false;\n-        match (value_result.clone(), type_result.clone()) {\n-            (BoundResult(..), BoundResult(..)) => {} // Continue.\n-            _ => {\n-                // If there is an unresolved glob at this point in the\n-                // containing module, bail out. We don't know enough to be\n-                // able to resolve this import.\n-\n-                if containing_module.glob_count.get() > 0 {\n-                    debug!(\"(resolving single import) unresolved glob; \\\n-                            bailing out\");\n-                    return Indeterminate;\n-                }\n-\n-                // Now search the exported imports within the containing module.\n-                match containing_module.import_resolutions.borrow().get(&source) {\n-                    None => {\n-                        debug!(\"(resolving single import) no import\");\n-                        // The containing module definitely doesn't have an\n-                        // exported import with the name in question. We can\n-                        // therefore accurately report that the names are\n-                        // unbound.\n-\n-                        if value_result.is_unknown() {\n-                            value_result = UnboundResult;\n-                        }\n-                        if type_result.is_unknown() {\n-                            type_result = UnboundResult;\n-                        }\n-                    }\n-                    Some(import_resolution)\n-                            if import_resolution.outstanding_references == 0 => {\n-\n-                        fn get_binding(this: &mut Resolver,\n-                                       import_resolution: &ImportResolution,\n-                                       namespace: Namespace,\n-                                       source: &Name)\n-                                    -> NamespaceResult {\n-\n-                            // Import resolutions must be declared with \"pub\"\n-                            // in order to be exported.\n-                            if !import_resolution.is_public {\n-                                return UnboundResult;\n-                            }\n-\n-                            match import_resolution.\n-                                    target_for_namespace(namespace) {\n-                                None => {\n-                                    return UnboundResult;\n-                                }\n-                                Some(Target {\n-                                    target_module,\n-                                    bindings,\n-                                    shadowable: _\n-                                }) => {\n-                                    debug!(\"(resolving single import) found \\\n-                                            import in ns {:?}\", namespace);\n-                                    let id = import_resolution.id(namespace);\n-                                    // track used imports and extern crates as well\n-                                    this.used_imports.insert((id, namespace));\n-                                    this.record_import_use(id, *source);\n-                                    match target_module.def_id.get() {\n-                                        Some(DefId{krate: kid, ..}) => {\n-                                            this.used_crates.insert(kid);\n-                                        },\n-                                        _ => {}\n-                                    }\n-                                    return BoundResult(target_module, bindings);\n-                                }\n-                            }\n-                        }\n-\n-                        // The name is an import which has been fully\n-                        // resolved. We can, therefore, just follow it.\n-                        if value_result.is_unknown() {\n-                            value_result = get_binding(self,\n-                                                       import_resolution,\n-                                                       ValueNS,\n-                                                       &source);\n-                            value_used_reexport = import_resolution.is_public;\n-                        }\n-                        if type_result.is_unknown() {\n-                            type_result = get_binding(self,\n-                                                      import_resolution,\n-                                                      TypeNS,\n-                                                      &source);\n-                            type_used_reexport = import_resolution.is_public;\n-                        }\n-\n-                    }\n-                    Some(_) => {\n-                        // If containing_module is the same module whose import we are resolving\n-                        // and there it has an unresolved import with the same name as `source`,\n-                        // then the user is actually trying to import an item that is declared\n-                        // in the same scope\n-                        //\n-                        // e.g\n-                        // use self::submodule;\n-                        // pub mod submodule;\n-                        //\n-                        // In this case we continue as if we resolved the import and let the\n-                        // check_for_conflicts_between_imports_and_items call below handle\n-                        // the conflict\n-                        match (module_.def_id.get(),  containing_module.def_id.get()) {\n-                            (Some(id1), Some(id2)) if id1 == id2  => {\n-                                if value_result.is_unknown() {\n-                                    value_result = UnboundResult;\n-                                }\n-                                if type_result.is_unknown() {\n-                                    type_result = UnboundResult;\n-                                }\n-                            }\n-                            _ =>  {\n-                                // The import is unresolved. Bail out.\n-                                debug!(\"(resolving single import) unresolved import; \\\n-                                        bailing out\");\n-                                return Indeterminate;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        // If we didn't find a result in the type namespace, search the\n-        // external modules.\n-        let mut value_used_public = false;\n-        let mut type_used_public = false;\n-        match type_result {\n-            BoundResult(..) => {}\n-            _ => {\n-                match containing_module.external_module_children.borrow_mut()\n-                                       .get(&source).cloned() {\n-                    None => {} // Continue.\n-                    Some(module) => {\n-                        debug!(\"(resolving single import) found external \\\n-                                module\");\n-                        // track the module as used.\n-                        match module.def_id.get() {\n-                            Some(DefId{krate: kid, ..}) => { self.used_crates.insert(kid); },\n-                            _ => {}\n-                        }\n-                        let name_bindings =\n-                            Rc::new(Resolver::create_name_bindings_from_module(\n-                                module));\n-                        type_result = BoundResult(containing_module.clone(),\n-                                                  name_bindings);\n-                        type_used_public = true;\n-                    }\n-                }\n-            }\n-        }\n-\n-        // We've successfully resolved the import. Write the results in.\n-        let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let import_resolution = &mut (*import_resolutions)[target];\n-        {\n-            let mut check_and_write_import = |namespace, result: &_, used_public: &mut bool| {\n-                let namespace_name = match namespace {\n-                    TypeNS => \"type\",\n-                    ValueNS => \"value\",\n-                };\n-\n-                match *result {\n-                    BoundResult(ref target_module, ref name_bindings) => {\n-                        debug!(\"(resolving single import) found {:?} target: {:?}\",\n-                               namespace_name,\n-                               name_bindings.def_for_namespace(namespace));\n-                        self.check_for_conflicting_import(\n-                            &import_resolution.target_for_namespace(namespace),\n-                            directive.span,\n-                            target,\n-                            namespace);\n-\n-                        self.check_that_import_is_importable(\n-                            &**name_bindings,\n-                            directive.span,\n-                            target,\n-                            namespace);\n-\n-                        let target = Some(Target::new(target_module.clone(),\n-                                                      name_bindings.clone(),\n-                                                      directive.shadowable));\n-                        import_resolution.set_target_and_id(namespace, target, directive.id);\n-                        import_resolution.is_public = directive.is_public;\n-                        *used_public = name_bindings.defined_in_public_namespace(namespace);\n-                    }\n-                    UnboundResult => { /* Continue. */ }\n-                    UnknownResult => {\n-                        panic!(\"{:?} result should be known at this point\", namespace_name);\n-                    }\n-                }\n-            };\n-            check_and_write_import(ValueNS, &value_result, &mut value_used_public);\n-            check_and_write_import(TypeNS, &type_result, &mut type_used_public);\n-        }\n-\n-        self.check_for_conflicts_between_imports_and_items(\n-            module_,\n-            import_resolution,\n-            directive.span,\n-            target);\n-\n-        if value_result.is_unbound() && type_result.is_unbound() {\n-            let msg = format!(\"There is no `{}` in `{}`\",\n-                              token::get_name(source),\n-                              self.module_to_string(&*containing_module));\n-            return Failed(Some((directive.span, msg)));\n-        }\n-        let value_used_public = value_used_reexport || value_used_public;\n-        let type_used_public = type_used_reexport || type_used_public;\n-\n-        assert!(import_resolution.outstanding_references >= 1);\n-        import_resolution.outstanding_references -= 1;\n-\n-        // record what this import resolves to for later uses in documentation,\n-        // this may resolve to either a value or a type, but for documentation\n-        // purposes it's good enough to just favor one over the other.\n-        let value_def_and_priv = import_resolution.value_target.as_ref().map(|target| {\n-            let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n-            (def, if value_used_public { lp } else { DependsOn(def.def_id()) })\n-        });\n-        let type_def_and_priv = import_resolution.type_target.as_ref().map(|target| {\n-            let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n-            (def, if type_used_public { lp } else { DependsOn(def.def_id()) })\n-        });\n-\n-        let import_lp = LastImport {\n-            value_priv: value_def_and_priv.map(|(_, p)| p),\n-            value_used: Used,\n-            type_priv: type_def_and_priv.map(|(_, p)| p),\n-            type_used: Used\n-        };\n-\n-        if let Some((def, _)) = value_def_and_priv {\n-            self.def_map.borrow_mut().insert(directive.id, PathResolution {\n-                base_def: def,\n-                last_private: import_lp,\n-                depth: 0\n-            });\n-        }\n-        if let Some((def, _)) = type_def_and_priv {\n-            self.def_map.borrow_mut().insert(directive.id, PathResolution {\n-                base_def: def,\n-                last_private: import_lp,\n-                depth: 0\n-            });\n-        }\n-\n-        debug!(\"(resolving single import) successfully resolved import\");\n-        return Success(());\n-    }\n-\n-    // Resolves a glob import. Note that this function cannot fail; it either\n-    // succeeds or bails out (as importing * from an empty module or a module\n-    // that exports nothing is valid). containing_module is the module we are\n-    // actually importing, i.e., `foo` in `use foo::*`.\n-    fn resolve_glob_import(&mut self,\n-                           module_: &Module,\n-                           containing_module: Rc<Module>,\n-                           import_directive: &ImportDirective,\n-                           lp: LastPrivate)\n-                           -> ResolveResult<()> {\n-        let id = import_directive.id;\n-        let is_public = import_directive.is_public;\n-\n-        // This function works in a highly imperative manner; it eagerly adds\n-        // everything it can to the list of import resolutions of the module\n-        // node.\n-        debug!(\"(resolving glob import) resolving glob import {}\", id);\n-\n-        // We must bail out if the node has unresolved imports of any kind\n-        // (including globs).\n-        if !(*containing_module).all_imports_resolved() {\n-            debug!(\"(resolving glob import) target module has unresolved \\\n-                    imports; bailing out\");\n-            return Indeterminate;\n-        }\n-\n-        assert_eq!(containing_module.glob_count.get(), 0);\n-\n-        // Add all resolved imports from the containing module.\n-        let import_resolutions = containing_module.import_resolutions.borrow();\n-        for (ident, target_import_resolution) in &*import_resolutions {\n-            debug!(\"(resolving glob import) writing module resolution \\\n-                    {} into `{}`\",\n-                   token::get_name(*ident),\n-                   self.module_to_string(module_));\n-\n-            if !target_import_resolution.is_public {\n-                debug!(\"(resolving glob import) nevermind, just kidding\");\n-                continue\n-            }\n-\n-            // Here we merge two import resolutions.\n-            let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-            match import_resolutions.get_mut(ident) {\n-                Some(dest_import_resolution) => {\n-                    // Merge the two import resolutions at a finer-grained\n-                    // level.\n-\n-                    match target_import_resolution.value_target {\n-                        None => {\n-                            // Continue.\n-                        }\n-                        Some(ref value_target) => {\n-                            self.check_for_conflicting_import(&dest_import_resolution.value_target,\n-                                                              import_directive.span,\n-                                                              *ident,\n-                                                              ValueNS);\n-                            dest_import_resolution.value_target = Some(value_target.clone());\n-                        }\n-                    }\n-                    match target_import_resolution.type_target {\n-                        None => {\n-                            // Continue.\n-                        }\n-                        Some(ref type_target) => {\n-                            self.check_for_conflicting_import(&dest_import_resolution.type_target,\n-                                                              import_directive.span,\n-                                                              *ident,\n-                                                              TypeNS);\n-                            dest_import_resolution.type_target = Some(type_target.clone());\n-                        }\n-                    }\n-                    dest_import_resolution.is_public = is_public;\n-                    continue;\n-                }\n-                None => {}\n-            }\n-\n-            // Simple: just copy the old import resolution.\n-            let mut new_import_resolution = ImportResolution::new(id, is_public);\n-            new_import_resolution.value_target =\n-                target_import_resolution.value_target.clone();\n-            new_import_resolution.type_target =\n-                target_import_resolution.type_target.clone();\n-\n-            import_resolutions.insert(*ident, new_import_resolution);\n-        }\n-\n-        // Add all children from the containing module.\n-        build_reduced_graph::populate_module_if_necessary(self, &containing_module);\n-\n-        for (&name, name_bindings) in &*containing_module.children.borrow() {\n-            self.merge_import_resolution(module_,\n-                                         containing_module.clone(),\n-                                         import_directive,\n-                                         name,\n-                                         name_bindings.clone());\n-\n-        }\n-\n-        // Add external module children from the containing module.\n-        for (&name, module) in &*containing_module.external_module_children.borrow() {\n-            let name_bindings =\n-                Rc::new(Resolver::create_name_bindings_from_module(module.clone()));\n-            self.merge_import_resolution(module_,\n-                                         containing_module.clone(),\n-                                         import_directive,\n-                                         name,\n-                                         name_bindings);\n-        }\n-\n-        // Record the destination of this import\n-        if let Some(did) = containing_module.def_id.get() {\n-            self.def_map.borrow_mut().insert(id, PathResolution {\n-                base_def: DefMod(did),\n-                last_private: lp,\n-                depth: 0\n-            });\n-        }\n-\n-        debug!(\"(resolving glob import) successfully resolved import\");\n-        return Success(());\n-    }\n-\n-    fn merge_import_resolution(&mut self,\n-                               module_: &Module,\n-                               containing_module: Rc<Module>,\n-                               import_directive: &ImportDirective,\n-                               name: Name,\n-                               name_bindings: Rc<NameBindings>) {\n-        let id = import_directive.id;\n-        let is_public = import_directive.is_public;\n-\n-        let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-        let dest_import_resolution = import_resolutions.entry(name).get().unwrap_or_else(\n-            |vacant_entry| {\n-                // Create a new import resolution from this child.\n-                vacant_entry.insert(ImportResolution::new(id, is_public))\n-            });\n-\n-        debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n-               to `{}`\",\n-               &token::get_name(name),\n-               self.module_to_string(&*containing_module),\n-               self.module_to_string(module_));\n-\n-        // Merge the child item into the import resolution.\n-        {\n-            let mut merge_child_item = |namespace| {\n-                if name_bindings.defined_in_namespace_with(namespace, IMPORTABLE | PUBLIC) {\n-                    let namespace_name = match namespace {\n-                        TypeNS => \"type\",\n-                        ValueNS => \"value\",\n-                    };\n-                    debug!(\"(resolving glob import) ... for {} target\", namespace_name);\n-                    if dest_import_resolution.shadowable(namespace) == Shadowable::Never {\n-                        let msg = format!(\"a {} named `{}` has already been imported \\\n-                                           in this module\",\n-                                          namespace_name,\n-                                          &token::get_name(name));\n-                        span_err!(self.session, import_directive.span, E0251, \"{}\", msg);\n-                    } else {\n-                        let target = Target::new(containing_module.clone(),\n-                                                 name_bindings.clone(),\n-                                                 import_directive.shadowable);\n-                        dest_import_resolution.set_target_and_id(namespace,\n-                                                                 Some(target),\n-                                                                 id);\n-                    }\n-                }\n-            };\n-            merge_child_item(ValueNS);\n-            merge_child_item(TypeNS);\n-        }\n-\n-        dest_import_resolution.is_public = is_public;\n-\n-        self.check_for_conflicts_between_imports_and_items(\n-            module_,\n-            dest_import_resolution,\n-            import_directive.span,\n-            name);\n-    }\n-\n-    /// Checks that imported names and items don't have the same name.\n-    fn check_for_conflicting_import(&mut self,\n-                                    target: &Option<Target>,\n-                                    import_span: Span,\n-                                    name: Name,\n-                                    namespace: Namespace) {\n-        debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n-               &token::get_name(name),\n-               target.is_some());\n-\n-        match *target {\n-            Some(ref target) if target.shadowable != Shadowable::Always => {\n-                let msg = format!(\"a {} named `{}` has already been imported \\\n-                                   in this module\",\n-                                  match namespace {\n-                                    TypeNS => \"type\",\n-                                    ValueNS => \"value\",\n-                                  },\n-                                  &token::get_name(name));\n-                span_err!(self.session, import_span, E0252, \"{}\", &msg[..]);\n-            }\n-            Some(_) | None => {}\n-        }\n-    }\n-\n-    /// Checks that an import is actually importable\n-    fn check_that_import_is_importable(&mut self,\n-                                       name_bindings: &NameBindings,\n-                                       import_span: Span,\n-                                       name: Name,\n-                                       namespace: Namespace) {\n-        if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n-            let msg = format!(\"`{}` is not directly importable\",\n-                              token::get_name(name));\n-            span_err!(self.session, import_span, E0253, \"{}\", &msg[..]);\n-        }\n-    }\n-\n-    /// Checks that imported names and items don't have the same name.\n-    fn check_for_conflicts_between_imports_and_items(&mut self,\n-                                                     module: &Module,\n-                                                     import_resolution:\n-                                                     &ImportResolution,\n-                                                     import_span: Span,\n-                                                     name: Name) {\n-        // First, check for conflicts between imports and `extern crate`s.\n-        if module.external_module_children\n-                 .borrow()\n-                 .contains_key(&name) {\n-            match import_resolution.type_target {\n-                Some(ref target) if target.shadowable != Shadowable::Always => {\n-                    let msg = format!(\"import `{0}` conflicts with imported \\\n-                                       crate in this module \\\n-                                       (maybe you meant `use {0}::*`?)\",\n-                                      &token::get_name(name));\n-                    span_err!(self.session, import_span, E0254, \"{}\", &msg[..]);\n-                }\n-                Some(_) | None => {}\n-            }\n-        }\n-\n-        // Check for item conflicts.\n-        let children = module.children.borrow();\n-        let name_bindings = match children.get(&name) {\n-            None => {\n-                // There can't be any conflicts.\n-                return\n-            }\n-            Some(ref name_bindings) => (*name_bindings).clone(),\n-        };\n-\n-        match import_resolution.value_target {\n-            Some(ref target) if target.shadowable != Shadowable::Always => {\n-                if let Some(ref value) = *name_bindings.value_def.borrow() {\n-                    span_err!(self.session, import_span, E0255,\n-                              \"import `{}` conflicts with value in this module\",\n-                              &token::get_name(name));\n-                    if let Some(span) = value.value_span {\n-                        self.session.span_note(span, \"conflicting value here\");\n-                    }\n-                }\n-            }\n-            Some(_) | None => {}\n-        }\n-\n-        match import_resolution.type_target {\n-            Some(ref target) if target.shadowable != Shadowable::Always => {\n-                if let Some(ref ty) = *name_bindings.type_def.borrow() {\n-                    let (what, note) = if ty.module_def.is_some() {\n-                        (\"existing submodule\", \"note conflicting module here\")\n-                    } else {\n-                        (\"type in this module\", \"note conflicting type here\")\n-                    };\n-                    span_err!(self.session, import_span, E0256,\n-                              \"import `{}` conflicts with {}\",\n-                              &token::get_name(name), what);\n-                    if let Some(span) = ty.type_span {\n-                        self.session.span_note(span, note);\n-                    }\n-                }\n-            }\n-            Some(_) | None => {}\n-        }\n-    }\n-\n     /// Checks that the names of external crates don't collide with other\n     /// external crates.\n     fn check_for_conflicts_between_external_crates(&self,\n@@ -1964,18 +996,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               false) {\n                 Failed(None) => {\n                     let segment_name = token::get_name(name);\n-                    let module_name = self.module_to_string(&*search_module);\n+                    let module_name = module_to_string(&*search_module);\n                     let mut span = span;\n                     let msg = if \"???\" == &module_name[..] {\n                         span.hi = span.lo + Pos::from_usize(segment_name.len());\n \n                         match search_parent_externals(name,\n                                                      &self.current_module) {\n                             Some(module) => {\n-                                let path_str = self.names_to_string(module_path);\n-                                let target_mod_str = self.module_to_string(&*module);\n+                                let path_str = names_to_string(module_path);\n+                                let target_mod_str = module_to_string(&*module);\n                                 let current_mod_str =\n-                                    self.module_to_string(&*self.current_module);\n+                                    module_to_string(&*self.current_module);\n \n                                 let prefix = if target_mod_str == current_mod_str {\n                                     \"self::\".to_string()\n@@ -2066,8 +1098,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         assert!(module_path_len > 0);\n \n         debug!(\"(resolving module path for import) processing `{}` rooted at `{}`\",\n-               self.names_to_string(module_path),\n-               self.module_to_string(&*module_));\n+               names_to_string(module_path),\n+               module_to_string(&*module_));\n \n         // Resolve the module prefix, if any.\n         let module_prefix_result = self.resolve_module_prefix(module_.clone(),\n@@ -2078,7 +1110,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let last_private;\n         match module_prefix_result {\n             Failed(None) => {\n-                let mpath = self.names_to_string(module_path);\n+                let mpath = names_to_string(module_path);\n                 let mpath = &mpath[..];\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n@@ -2161,7 +1193,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 namespace {:?} in `{}`\",\n                token::get_name(name),\n                namespace,\n-               self.module_to_string(&*module_));\n+               module_to_string(&*module_));\n \n         // The current module node is handled specially. First, check for\n         // its immediate children.\n@@ -2398,7 +1430,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 break\n             }\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n-                   self.module_to_string(&*containing_module));\n+                   module_to_string(&*containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n                 None => return Failed(None),\n                 Some(new_module) => {\n@@ -2409,7 +1441,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         debug!(\"(resolving module prefix) finished resolving prefix at {}\",\n-               self.module_to_string(&*containing_module));\n+               module_to_string(&*containing_module));\n \n         return Success(PrefixFound(containing_module, i));\n     }\n@@ -2429,7 +1461,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n                &token::get_name(name),\n-               self.module_to_string(&*module_));\n+               module_to_string(&*module_));\n \n         // First, check the direct children of the module.\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n@@ -2583,15 +1615,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n                                token::get_name(name),\n-                               self.module_to_string(&*orig_module));\n+                               module_to_string(&*orig_module));\n                     }\n                     Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             None => {\n                                 debug!(\"!!! (with scope) didn't find module \\\n                                         for `{}` in `{}`\",\n                                        token::get_name(name),\n-                                       self.module_to_string(&*orig_module));\n+                                       module_to_string(&*orig_module));\n                             }\n                             Some(module_) => {\n                                 self.current_module = module_;\n@@ -2970,7 +2002,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } else {\n                 self.resolve_error(trait_path.span,\n                     &format!(\"`{}` is not a trait\",\n-                             self.path_names_to_string(trait_path, path_depth)));\n+                             path_names_to_string(trait_path, path_depth)));\n \n                 // If it's a typedef, give a note\n                 if let DefTy(..) = path_res.base_def {\n@@ -2981,7 +2013,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         } else {\n             let msg = format!(\"use of undeclared trait name `{}`\",\n-                              self.path_names_to_string(trait_path, path_depth));\n+                              path_names_to_string(trait_path, path_depth));\n             self.resolve_error(trait_path.span, &msg);\n             Err(())\n         }\n@@ -3097,7 +2129,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n         if let Some((did, ref trait_ref)) = self.current_trait_ref {\n             if !self.trait_item_map.contains_key(&(name, did)) {\n-                let path_str = self.path_names_to_string(&trait_ref.path, 0);\n+                let path_str = path_names_to_string(&trait_ref.path, 0);\n                 self.resolve_error(span,\n                                     &format!(\"method `{}` is not a member of trait `{}`\",\n                                             token::get_name(name),\n@@ -3279,7 +2311,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `{}` \\\n                                 (id {}) = {:?}\",\n-                               self.path_names_to_string(path, 0),\n+                               path_names_to_string(path, 0),\n                                ty.id, def);\n                         self.record_def(ty.id, def);\n                     }\n@@ -3294,7 +2326,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         };\n \n                         let msg = format!(\"use of undeclared {} `{}`\", kind,\n-                                          self.path_names_to_string(path, 0));\n+                                          path_names_to_string(path, 0));\n                         self.resolve_error(ty.span, &msg[..]);\n                     }\n                 }\n@@ -3465,7 +2497,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             debug!(\"(resolving pattern) didn't find struct \\\n                                     def: {:?}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n-                                              self.path_names_to_string(path, 0));\n+                                              path_names_to_string(path, 0));\n                             self.resolve_error(path.span, &msg[..]);\n                         }\n                     }\n@@ -3718,7 +2750,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared type or module `{}`\",\n-                                          self.names_to_string(&module_path));\n+                                          names_to_string(&module_path));\n                         (span, msg)\n                     }\n                 };\n@@ -3778,7 +2810,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `::{}`\",\n-                                          self.names_to_string(&module_path[..]));\n+                                          names_to_string(&module_path[..]));\n                         (span, msg)\n                     }\n                 };\n@@ -3998,7 +3030,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if let Some(binding) = module.children.borrow().get(&name) {\n                 if let Some(DefMethod(did, _)) = binding.def_for_namespace(ValueNS) {\n                     if is_static_method(self, did) {\n-                        return StaticMethod(self.path_names_to_string(&path, 0))\n+                        return StaticMethod(path_names_to_string(&path, 0))\n                     }\n                     if self.current_trait_ref.is_some() {\n                         return TraitItem;\n@@ -4013,7 +3045,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if let Some((trait_did, ref trait_ref)) = self.current_trait_ref {\n             if let Some(&did) = self.trait_item_map.get(&(name, trait_did)) {\n                 if is_static_method(self, did) {\n-                    return TraitMethod(self.path_names_to_string(&trait_ref.path, 0));\n+                    return TraitMethod(path_names_to_string(&trait_ref.path, 0));\n                 } else {\n                     return TraitItem;\n                 }\n@@ -4105,7 +3137,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Some(path_res) = resolution {\n                     // Check if struct variant\n                     if let DefVariant(_, _, true) = path_res.base_def {\n-                        let path_name = self.path_names_to_string(path, 0);\n+                        let path_name = path_names_to_string(path, 0);\n                         self.resolve_error(expr.span,\n                                 &format!(\"`{}` is a struct variant name, but \\\n                                           this expression \\\n@@ -4123,7 +3155,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     } else {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `{}`\",\n-                               self.path_names_to_string(path, 0));\n+                               path_names_to_string(path, 0));\n \n                         // Partial resolutions will need the set of traits in scope,\n                         // so they can be completed during typeck.\n@@ -4140,7 +3172,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // (The pattern matching def_tys where the id is in self.structs\n                     // matches on regular structs while excluding tuple- and enum-like\n                     // structs, which wouldn't result in this error.)\n-                    let path_name = self.path_names_to_string(path, 0);\n+                    let path_name = path_names_to_string(path, 0);\n                     let type_res = self.with_no_errors(|this| {\n                         this.resolve_path(expr.id, path, 0, TypeNS, false)\n                     });\n@@ -4227,7 +3259,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         debug!(\"(resolving expression) didn't find struct def\",);\n                         let msg = format!(\"`{}` does not name a structure\",\n-                                          self.path_names_to_string(path, 0));\n+                                          path_names_to_string(path, 0));\n                         self.resolve_error(path.span, &msg[..]);\n                     }\n                 }\n@@ -4417,36 +3449,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     // hit.\n     //\n \n-    /// A somewhat inefficient routine to obtain the name of a module.\n-    fn module_to_string(&self, module: &Module) -> String {\n-        let mut names = Vec::new();\n-\n-        fn collect_mod(names: &mut Vec<ast::Name>, module: &Module) {\n-            match module.parent_link {\n-                NoParentLink => {}\n-                ModuleParentLink(ref module, name) => {\n-                    names.push(name);\n-                    collect_mod(names, &*module.upgrade().unwrap());\n-                }\n-                BlockParentLink(ref module, _) => {\n-                    // danger, shouldn't be ident?\n-                    names.push(special_idents::opaque.name);\n-                    collect_mod(names, &*module.upgrade().unwrap());\n-                }\n-            }\n-        }\n-        collect_mod(&mut names, module);\n-\n-        if names.len() == 0 {\n-            return \"???\".to_string();\n-        }\n-        self.names_to_string(&names.into_iter().rev()\n-                                  .collect::<Vec<ast::Name>>())\n-    }\n-\n     #[allow(dead_code)]   // useful for debugging\n     fn dump_module(&mut self, module_: Rc<Module>) {\n-        debug!(\"Dump of module `{}`:\", self.module_to_string(&*module_));\n+        debug!(\"Dump of module `{}`:\", module_to_string(&*module_));\n \n         debug!(\"Children:\");\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n@@ -4480,6 +3485,56 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n }\n \n+\n+fn names_to_string(names: &[Name]) -> String {\n+    let mut first = true;\n+    let mut result = String::new();\n+    for name in names {\n+        if first {\n+            first = false\n+        } else {\n+            result.push_str(\"::\")\n+        }\n+        result.push_str(&token::get_name(*name));\n+    };\n+    result\n+}\n+\n+fn path_names_to_string(path: &Path, depth: usize) -> String {\n+    let names: Vec<ast::Name> = path.segments[..path.segments.len()-depth]\n+                                    .iter()\n+                                    .map(|seg| seg.identifier.name)\n+                                    .collect();\n+    names_to_string(&names[..])\n+}\n+\n+/// A somewhat inefficient routine to obtain the name of a module.\n+fn module_to_string(module: &Module) -> String {\n+    let mut names = Vec::new();\n+\n+    fn collect_mod(names: &mut Vec<ast::Name>, module: &Module) {\n+        match module.parent_link {\n+            NoParentLink => {}\n+            ModuleParentLink(ref module, name) => {\n+                names.push(name);\n+                collect_mod(names, &*module.upgrade().unwrap());\n+            }\n+            BlockParentLink(ref module, _) => {\n+                // danger, shouldn't be ident?\n+                names.push(special_idents::opaque.name);\n+                collect_mod(names, &*module.upgrade().unwrap());\n+            }\n+        }\n+    }\n+    collect_mod(&mut names, module);\n+\n+    if names.len() == 0 {\n+        return \"???\".to_string();\n+    }\n+    names_to_string(&names.into_iter().rev().collect::<Vec<ast::Name>>())\n+}\n+\n+\n pub struct CrateMap {\n     pub def_map: DefMap,\n     pub freevars: RefCell<FreevarMap>,\n@@ -4507,7 +3562,7 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n     build_reduced_graph::build_reduced_graph(&mut resolver, krate);\n     session.abort_if_errors();\n \n-    resolver.resolve_imports();\n+    resolve_imports::resolve_imports(&mut resolver);\n     session.abort_if_errors();\n \n     record_exports::record(&mut resolver);"}, {"sha": "e953b6398f9c08e6eab61bfc34e807b28c92e740", "filename": "src/librustc_resolve/record_exports.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Flibrustc_resolve%2Frecord_exports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Flibrustc_resolve%2Frecord_exports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Frecord_exports.rs?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -22,6 +22,7 @@ use {Module, NameBindings, Resolver};\n use Namespace::{self, TypeNS, ValueNS};\n \n use build_reduced_graph;\n+use module_to_string;\n \n use rustc::middle::def::Export;\n use syntax::ast;\n@@ -60,19 +61,19 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n                 // OK. Continue.\n                 debug!(\"(recording exports for module subtree) recording \\\n                         exports for local module `{}`\",\n-                       self.module_to_string(&*module_));\n+                       module_to_string(&*module_));\n             }\n             None => {\n                 // Record exports for the root module.\n                 debug!(\"(recording exports for module subtree) recording \\\n                         exports for root module `{}`\",\n-                       self.module_to_string(&*module_));\n+                       module_to_string(&*module_));\n             }\n             Some(_) => {\n                 // Bail out.\n                 debug!(\"(recording exports for module subtree) not recording \\\n                         exports for `{}`\",\n-                       self.module_to_string(&*module_));\n+                       module_to_string(&*module_));\n                 return;\n             }\n         }\n@@ -133,13 +134,13 @@ impl<'a, 'b, 'tcx> ExportRecorder<'a, 'b, 'tcx> {\n     fn add_exports_for_module(&mut self,\n                               exports: &mut Vec<Export>,\n                               module_: &Module) {\n-        for (name, importresolution) in &*module_.import_resolutions.borrow() {\n-            if !importresolution.is_public {\n+        for (name, import_resolution) in &*module_.import_resolutions.borrow() {\n+            if !import_resolution.is_public {\n                 continue\n             }\n             let xs = [TypeNS, ValueNS];\n             for &ns in &xs {\n-                match importresolution.target_for_namespace(ns) {\n+                match import_resolution.target_for_namespace(ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe export '{}'\",\n                                token::get_name(*name));"}, {"sha": "737ec71cab3da09273b69f94d3653d37674e91eb", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "added", "additions": 1021, "deletions": 0, "changes": 1021, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -0,0 +1,1021 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self::ImportDirectiveSubclass::*;\n+\n+use {PUBLIC, IMPORTABLE};\n+use Module;\n+use Namespace::{self, TypeNS, ValueNS};\n+use NameBindings;\n+use NamespaceResult::{BoundResult, UnboundResult, UnknownResult};\n+use NamespaceResult;\n+use NameSearchType;\n+use ResolveResult;\n+use Resolver;\n+use UseLexicalScopeFlag;\n+use {names_to_string, module_to_string};\n+\n+use build_reduced_graph;\n+\n+use rustc::middle::def::*;\n+use rustc::middle::privacy::*;\n+\n+use syntax::ast::{DefId, NodeId, Name};\n+use syntax::attr::AttrMetaMethods;\n+use syntax::parse::token;\n+use syntax::codemap::Span;\n+\n+use std::mem::replace;\n+use std::rc::Rc;\n+\n+\n+/// Contains data for specific types of import directives.\n+#[derive(Copy,Debug)]\n+pub enum ImportDirectiveSubclass {\n+    SingleImport(Name /* target */, Name /* source */),\n+    GlobImport\n+}\n+\n+/// Whether an import can be shadowed by another import.\n+#[derive(Debug,PartialEq,Clone,Copy)]\n+pub enum Shadowable {\n+    Always,\n+    Never\n+}\n+\n+/// One import directive.\n+#[derive(Debug)]\n+pub struct ImportDirective {\n+    pub module_path: Vec<Name>,\n+    pub subclass: ImportDirectiveSubclass,\n+    pub span: Span,\n+    pub id: NodeId,\n+    pub is_public: bool, // see note in ImportResolution about how to use this\n+    pub shadowable: Shadowable,\n+}\n+\n+impl ImportDirective {\n+    pub fn new(module_path: Vec<Name> ,\n+           subclass: ImportDirectiveSubclass,\n+           span: Span,\n+           id: NodeId,\n+           is_public: bool,\n+           shadowable: Shadowable)\n+           -> ImportDirective {\n+        ImportDirective {\n+            module_path: module_path,\n+            subclass: subclass,\n+            span: span,\n+            id: id,\n+            is_public: is_public,\n+            shadowable: shadowable,\n+        }\n+    }\n+}\n+\n+/// The item that an import resolves to.\n+#[derive(Clone,Debug)]\n+pub struct Target {\n+    pub target_module: Rc<Module>,\n+    pub bindings: Rc<NameBindings>,\n+    pub shadowable: Shadowable,\n+}\n+\n+impl Target {\n+    pub fn new(target_module: Rc<Module>,\n+           bindings: Rc<NameBindings>,\n+           shadowable: Shadowable)\n+           -> Target {\n+        Target {\n+            target_module: target_module,\n+            bindings: bindings,\n+            shadowable: shadowable,\n+        }\n+    }\n+}\n+\n+/// An ImportResolution represents a particular `use` directive.\n+#[derive(Debug)]\n+pub struct ImportResolution {\n+    /// Whether this resolution came from a `use` or a `pub use`. Note that this\n+    /// should *not* be used whenever resolution is being performed. Privacy\n+    /// testing occurs during a later phase of compilation.\n+    pub is_public: bool,\n+\n+    // The number of outstanding references to this name. When this reaches\n+    // zero, outside modules can count on the targets being correct. Before\n+    // then, all bets are off; future imports could override this name.\n+    // Note that this is usually either 0 or 1 - shadowing is forbidden the only\n+    // way outstanding_references is > 1 in a legal program is if the name is\n+    // used in both namespaces.\n+    pub outstanding_references: uint,\n+\n+    /// The value that this `use` directive names, if there is one.\n+    pub value_target: Option<Target>,\n+    /// The source node of the `use` directive leading to the value target\n+    /// being non-none\n+    pub value_id: NodeId,\n+\n+    /// The type that this `use` directive names, if there is one.\n+    pub type_target: Option<Target>,\n+    /// The source node of the `use` directive leading to the type target\n+    /// being non-none\n+    pub type_id: NodeId,\n+}\n+\n+impl ImportResolution {\n+    pub fn new(id: NodeId, is_public: bool) -> ImportResolution {\n+        ImportResolution {\n+            type_id: id,\n+            value_id: id,\n+            outstanding_references: 0,\n+            value_target: None,\n+            type_target: None,\n+            is_public: is_public,\n+        }\n+    }\n+\n+    pub fn target_for_namespace(&self, namespace: Namespace)\n+                                -> Option<Target> {\n+        match namespace {\n+            TypeNS  => self.type_target.clone(),\n+            ValueNS => self.value_target.clone(),\n+        }\n+    }\n+\n+    pub fn id(&self, namespace: Namespace) -> NodeId {\n+        match namespace {\n+            TypeNS  => self.type_id,\n+            ValueNS => self.value_id,\n+        }\n+    }\n+\n+    pub fn shadowable(&self, namespace: Namespace) -> Shadowable {\n+        let target = self.target_for_namespace(namespace);\n+        if target.is_none() {\n+            return Shadowable::Always;\n+        }\n+\n+        target.unwrap().shadowable\n+    }\n+\n+    pub fn set_target_and_id(&mut self,\n+                         namespace: Namespace,\n+                         target: Option<Target>,\n+                         id: NodeId) {\n+        match namespace {\n+            TypeNS  => {\n+                self.type_target = target;\n+                self.type_id = id;\n+            }\n+            ValueNS => {\n+                self.value_target = target;\n+                self.value_id = id;\n+            }\n+        }\n+    }\n+}\n+\n+\n+struct ImportResolver<'a, 'b:'a, 'tcx:'b> {\n+    resolver: &'a mut Resolver<'b, 'tcx>\n+}\n+\n+impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n+    // Import resolution\n+    //\n+    // This is a fixed-point algorithm. We resolve imports until our efforts\n+    // are stymied by an unresolved import; then we bail out of the current\n+    // module and continue. We terminate successfully once no more imports\n+    // remain or unsuccessfully when no forward progress in resolving imports\n+    // is made.\n+\n+    /// Resolves all imports for the crate. This method performs the fixed-\n+    /// point iteration.\n+    fn resolve_imports(&mut self) {\n+        let mut i = 0;\n+        let mut prev_unresolved_imports = 0;\n+        loop {\n+            debug!(\"(resolving imports) iteration {}, {} imports left\",\n+                   i, self.resolver.unresolved_imports);\n+\n+            let module_root = self.resolver.graph_root.get_module();\n+            self.resolve_imports_for_module_subtree(module_root.clone());\n+\n+            if self.resolver.unresolved_imports == 0 {\n+                debug!(\"(resolving imports) success\");\n+                break;\n+            }\n+\n+            if self.resolver.unresolved_imports == prev_unresolved_imports {\n+                self.resolver.report_unresolved_imports(module_root);\n+                break;\n+            }\n+\n+            i += 1;\n+            prev_unresolved_imports = self.resolver.unresolved_imports;\n+        }\n+    }\n+\n+    /// Attempts to resolve imports for the given module and all of its\n+    /// submodules.\n+    fn resolve_imports_for_module_subtree(&mut self, module_: Rc<Module>) {\n+        debug!(\"(resolving imports for module subtree) resolving {}\",\n+               module_to_string(&*module_));\n+        let orig_module = replace(&mut self.resolver.current_module, module_.clone());\n+        self.resolve_imports_for_module(module_.clone());\n+        self.resolver.current_module = orig_module;\n+\n+        build_reduced_graph::populate_module_if_necessary(self.resolver, &module_);\n+        for (_, child_node) in &*module_.children.borrow() {\n+            match child_node.get_module_if_available() {\n+                None => {\n+                    // Nothing to do.\n+                }\n+                Some(child_module) => {\n+                    self.resolve_imports_for_module_subtree(child_module);\n+                }\n+            }\n+        }\n+\n+        for (_, child_module) in &*module_.anonymous_children.borrow() {\n+            self.resolve_imports_for_module_subtree(child_module.clone());\n+        }\n+    }\n+\n+    /// Attempts to resolve imports for the given module only.\n+    fn resolve_imports_for_module(&mut self, module: Rc<Module>) {\n+        if module.all_imports_resolved() {\n+            debug!(\"(resolving imports for module) all imports resolved for \\\n+                   {}\",\n+                   module_to_string(&*module));\n+            return;\n+        }\n+\n+        let imports = module.imports.borrow();\n+        let import_count = imports.len();\n+        while module.resolved_import_count.get() < import_count {\n+            let import_index = module.resolved_import_count.get();\n+            let import_directive = &(*imports)[import_index];\n+            match self.resolve_import_for_module(module.clone(),\n+                                                 import_directive) {\n+                ResolveResult::Failed(err) => {\n+                    let (span, help) = match err {\n+                        Some((span, msg)) => (span, format!(\". {}\", msg)),\n+                        None => (import_directive.span, String::new())\n+                    };\n+                    let msg = format!(\"unresolved import `{}`{}\",\n+                                      import_path_to_string(\n+                                          &import_directive.module_path,\n+                                          import_directive.subclass),\n+                                      help);\n+                    self.resolver.resolve_error(span, &msg[..]);\n+                }\n+                ResolveResult::Indeterminate => break, // Bail out. We'll come around next time.\n+                ResolveResult::Success(()) => () // Good. Continue.\n+            }\n+\n+            module.resolved_import_count\n+                  .set(module.resolved_import_count.get() + 1);\n+        }\n+    }\n+\n+    /// Attempts to resolve the given import. The return value indicates\n+    /// failure if we're certain the name does not exist, indeterminate if we\n+    /// don't know whether the name exists at the moment due to other\n+    /// currently-unresolved imports, or success if we know the name exists.\n+    /// If successful, the resolved bindings are written into the module.\n+    fn resolve_import_for_module(&mut self,\n+                                 module_: Rc<Module>,\n+                                 import_directive: &ImportDirective)\n+                                 -> ResolveResult<()> {\n+        let mut resolution_result = ResolveResult::Failed(None);\n+        let module_path = &import_directive.module_path;\n+\n+        debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n+               names_to_string(&module_path[..]),\n+               module_to_string(&*module_));\n+\n+        // First, resolve the module path for the directive, if necessary.\n+        let container = if module_path.len() == 0 {\n+            // Use the crate root.\n+            Some((self.resolver.graph_root.get_module(), LastMod(AllPublic)))\n+        } else {\n+            match self.resolver.resolve_module_path(module_.clone(),\n+                                                    &module_path[..],\n+                                                    UseLexicalScopeFlag::DontUseLexicalScope,\n+                                                    import_directive.span,\n+                                                    NameSearchType::ImportSearch) {\n+                ResolveResult::Failed(err) => {\n+                    resolution_result = ResolveResult::Failed(err);\n+                    None\n+                },\n+                ResolveResult::Indeterminate => {\n+                    resolution_result = ResolveResult::Indeterminate;\n+                    None\n+                }\n+                ResolveResult::Success(container) => Some(container),\n+            }\n+        };\n+\n+        match container {\n+            None => {}\n+            Some((containing_module, lp)) => {\n+                // We found the module that the target is contained\n+                // within. Attempt to resolve the import within it.\n+\n+                match import_directive.subclass {\n+                    SingleImport(target, source) => {\n+                        resolution_result =\n+                            self.resolve_single_import(&module_,\n+                                                       containing_module,\n+                                                       target,\n+                                                       source,\n+                                                       import_directive,\n+                                                       lp);\n+                    }\n+                    GlobImport => {\n+                        resolution_result =\n+                            self.resolve_glob_import(&module_,\n+                                                     containing_module,\n+                                                     import_directive,\n+                                                     lp);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Decrement the count of unresolved imports.\n+        match resolution_result {\n+            ResolveResult::Success(()) => {\n+                assert!(self.resolver.unresolved_imports >= 1);\n+                self.resolver.unresolved_imports -= 1;\n+            }\n+            _ => {\n+                // Nothing to do here; just return the error.\n+            }\n+        }\n+\n+        // Decrement the count of unresolved globs if necessary. But only if\n+        // the resolution result is indeterminate -- otherwise we'll stop\n+        // processing imports here. (See the loop in\n+        // resolve_imports_for_module).\n+\n+        if !resolution_result.indeterminate() {\n+            match import_directive.subclass {\n+                GlobImport => {\n+                    assert!(module_.glob_count.get() >= 1);\n+                    module_.glob_count.set(module_.glob_count.get() - 1);\n+                }\n+                SingleImport(..) => {\n+                    // Ignore.\n+                }\n+            }\n+        }\n+\n+        return resolution_result;\n+    }\n+\n+    fn resolve_single_import(&mut self,\n+                             module_: &Module,\n+                             target_module: Rc<Module>,\n+                             target: Name,\n+                             source: Name,\n+                             directive: &ImportDirective,\n+                             lp: LastPrivate)\n+                             -> ResolveResult<()> {\n+        debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n+                `{}` id {}, last private {:?}\",\n+               token::get_name(target),\n+               module_to_string(&*target_module),\n+               token::get_name(source),\n+               module_to_string(module_),\n+               directive.id,\n+               lp);\n+\n+        let lp = match lp {\n+            LastMod(lp) => lp,\n+            LastImport {..} => {\n+                self.resolver.session\n+                    .span_bug(directive.span,\n+                              \"not expecting Import here, must be LastMod\")\n+            }\n+        };\n+\n+        // We need to resolve both namespaces for this to succeed.\n+        //\n+\n+        let mut value_result = UnknownResult;\n+        let mut type_result = UnknownResult;\n+\n+        // Search for direct children of the containing module.\n+        build_reduced_graph::populate_module_if_necessary(self.resolver, &target_module);\n+\n+        match target_module.children.borrow().get(&source) {\n+            None => {\n+                // Continue.\n+            }\n+            Some(ref child_name_bindings) => {\n+                // pub_err makes sure we don't give the same error twice.\n+                let mut pub_err = false;\n+                if child_name_bindings.defined_in_namespace(ValueNS) {\n+                    debug!(\"(resolving single import) found value binding\");\n+                    value_result = BoundResult(target_module.clone(),\n+                                               (*child_name_bindings).clone());\n+                    if directive.is_public && !child_name_bindings.is_public(ValueNS) {\n+                        let msg = format!(\"`{}` is private\", token::get_name(source));\n+                        span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg);\n+                        pub_err = true;\n+                    }\n+                }\n+                if child_name_bindings.defined_in_namespace(TypeNS) {\n+                    debug!(\"(resolving single import) found type binding\");\n+                    type_result = BoundResult(target_module.clone(),\n+                                              (*child_name_bindings).clone());\n+                    if !pub_err && directive.is_public && !child_name_bindings.is_public(TypeNS) {\n+                        let msg = format!(\"`{}` is private\", token::get_name(source));\n+                        span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Unless we managed to find a result in both namespaces (unlikely),\n+        // search imports as well.\n+        let mut value_used_reexport = false;\n+        let mut type_used_reexport = false;\n+        match (value_result.clone(), type_result.clone()) {\n+            (BoundResult(..), BoundResult(..)) => {} // Continue.\n+            _ => {\n+                // If there is an unresolved glob at this point in the\n+                // containing module, bail out. We don't know enough to be\n+                // able to resolve this import.\n+\n+                if target_module.glob_count.get() > 0 {\n+                    debug!(\"(resolving single import) unresolved glob; \\\n+                            bailing out\");\n+                    return ResolveResult::Indeterminate;\n+                }\n+\n+                // Now search the exported imports within the containing module.\n+                match target_module.import_resolutions.borrow().get(&source) {\n+                    None => {\n+                        debug!(\"(resolving single import) no import\");\n+                        // The containing module definitely doesn't have an\n+                        // exported import with the name in question. We can\n+                        // therefore accurately report that the names are\n+                        // unbound.\n+\n+                        if value_result.is_unknown() {\n+                            value_result = UnboundResult;\n+                        }\n+                        if type_result.is_unknown() {\n+                            type_result = UnboundResult;\n+                        }\n+                    }\n+                    Some(import_resolution)\n+                            if import_resolution.outstanding_references == 0 => {\n+\n+                        fn get_binding(this: &mut Resolver,\n+                                       import_resolution: &ImportResolution,\n+                                       namespace: Namespace,\n+                                       source: &Name)\n+                                    -> NamespaceResult {\n+\n+                            // Import resolutions must be declared with \"pub\"\n+                            // in order to be exported.\n+                            if !import_resolution.is_public {\n+                                return UnboundResult;\n+                            }\n+\n+                            match import_resolution.target_for_namespace(namespace) {\n+                                None => {\n+                                    return UnboundResult;\n+                                }\n+                                Some(Target {\n+                                    target_module,\n+                                    bindings,\n+                                    shadowable: _\n+                                }) => {\n+                                    debug!(\"(resolving single import) found \\\n+                                            import in ns {:?}\", namespace);\n+                                    let id = import_resolution.id(namespace);\n+                                    // track used imports and extern crates as well\n+                                    this.used_imports.insert((id, namespace));\n+                                    this.record_import_use(id, *source);\n+                                    match target_module.def_id.get() {\n+                                        Some(DefId{krate: kid, ..}) => {\n+                                            this.used_crates.insert(kid);\n+                                        },\n+                                        _ => {}\n+                                    }\n+                                    return BoundResult(target_module, bindings);\n+                                }\n+                            }\n+                        }\n+\n+                        // The name is an import which has been fully\n+                        // resolved. We can, therefore, just follow it.\n+                        if value_result.is_unknown() {\n+                            value_result = get_binding(self.resolver,\n+                                                       import_resolution,\n+                                                       ValueNS,\n+                                                       &source);\n+                            value_used_reexport = import_resolution.is_public;\n+                        }\n+                        if type_result.is_unknown() {\n+                            type_result = get_binding(self.resolver,\n+                                                      import_resolution,\n+                                                      TypeNS,\n+                                                      &source);\n+                            type_used_reexport = import_resolution.is_public;\n+                        }\n+\n+                    }\n+                    Some(_) => {\n+                        // If target_module is the same module whose import we are resolving\n+                        // and there it has an unresolved import with the same name as `source`,\n+                        // then the user is actually trying to import an item that is declared\n+                        // in the same scope\n+                        //\n+                        // e.g\n+                        // use self::submodule;\n+                        // pub mod submodule;\n+                        //\n+                        // In this case we continue as if we resolved the import and let the\n+                        // check_for_conflicts_between_imports_and_items call below handle\n+                        // the conflict\n+                        match (module_.def_id.get(),  target_module.def_id.get()) {\n+                            (Some(id1), Some(id2)) if id1 == id2  => {\n+                                if value_result.is_unknown() {\n+                                    value_result = UnboundResult;\n+                                }\n+                                if type_result.is_unknown() {\n+                                    type_result = UnboundResult;\n+                                }\n+                            }\n+                            _ =>  {\n+                                // The import is unresolved. Bail out.\n+                                debug!(\"(resolving single import) unresolved import; \\\n+                                        bailing out\");\n+                                return ResolveResult::Indeterminate;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut value_used_public = false;\n+        let mut type_used_public = false;\n+\n+        // If we didn't find a result in the type namespace, search the\n+        // external modules.\n+        match type_result {\n+            BoundResult(..) => {}\n+            _ => {\n+                match target_module.external_module_children.borrow_mut().get(&source).cloned() {\n+                    None => {} // Continue.\n+                    Some(module) => {\n+                        debug!(\"(resolving single import) found external module\");\n+                        // track the module as used.\n+                        match module.def_id.get() {\n+                            Some(DefId{krate: kid, ..}) => {\n+                                self.resolver.used_crates.insert(kid);\n+                            }\n+                            _ => {}\n+                        }\n+                        let name_bindings =\n+                            Rc::new(Resolver::create_name_bindings_from_module(module));\n+                        type_result = BoundResult(target_module.clone(), name_bindings);\n+                        type_used_public = true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // We've successfully resolved the import. Write the results in.\n+        let mut import_resolutions = module_.import_resolutions.borrow_mut();\n+        let import_resolution = &mut (*import_resolutions)[target];\n+\n+        {\n+            let mut check_and_write_import = |namespace, result: &_, used_public: &mut bool| {\n+                let namespace_name = match namespace {\n+                    TypeNS => \"type\",\n+                    ValueNS => \"value\",\n+                };\n+\n+                match *result {\n+                    BoundResult(ref target_module, ref name_bindings) => {\n+                        debug!(\"(resolving single import) found {:?} target: {:?}\",\n+                               namespace_name,\n+                               name_bindings.def_for_namespace(namespace));\n+                        self.check_for_conflicting_import(\n+                            &import_resolution.target_for_namespace(namespace),\n+                            directive.span,\n+                            target,\n+                            namespace);\n+\n+                        self.check_that_import_is_importable(\n+                            &**name_bindings,\n+                            directive.span,\n+                            target,\n+                            namespace);\n+\n+                        let target = Some(Target::new(target_module.clone(),\n+                                                      name_bindings.clone(),\n+                                                      directive.shadowable));\n+                        import_resolution.set_target_and_id(namespace, target, directive.id);\n+                        import_resolution.is_public = directive.is_public;\n+                        *used_public = name_bindings.defined_in_public_namespace(namespace);\n+                    }\n+                    UnboundResult => { /* Continue. */ }\n+                    UnknownResult => {\n+                        panic!(\"{:?} result should be known at this point\", namespace_name);\n+                    }\n+                }\n+            };\n+            check_and_write_import(ValueNS, &value_result, &mut value_used_public);\n+            check_and_write_import(TypeNS, &type_result, &mut type_used_public);\n+        }\n+\n+        self.check_for_conflicts_between_imports_and_items(\n+            module_,\n+            import_resolution,\n+            directive.span,\n+            target);\n+\n+        if value_result.is_unbound() && type_result.is_unbound() {\n+            let msg = format!(\"There is no `{}` in `{}`\",\n+                              token::get_name(source),\n+                              module_to_string(&target_module));\n+            return ResolveResult::Failed(Some((directive.span, msg)));\n+        }\n+        let value_used_public = value_used_reexport || value_used_public;\n+        let type_used_public = type_used_reexport || type_used_public;\n+\n+        assert!(import_resolution.outstanding_references >= 1);\n+        import_resolution.outstanding_references -= 1;\n+\n+        // Record what this import resolves to for later uses in documentation,\n+        // this may resolve to either a value or a type, but for documentation\n+        // purposes it's good enough to just favor one over the other.\n+        let value_def_and_priv = import_resolution.value_target.as_ref().map(|target| {\n+            let def = target.bindings.def_for_namespace(ValueNS).unwrap();\n+            (def, if value_used_public { lp } else { DependsOn(def.def_id()) })\n+        });\n+        let type_def_and_priv = import_resolution.type_target.as_ref().map(|target| {\n+            let def = target.bindings.def_for_namespace(TypeNS).unwrap();\n+            (def, if type_used_public { lp } else { DependsOn(def.def_id()) })\n+        });\n+\n+        let import_lp = LastImport {\n+            value_priv: value_def_and_priv.map(|(_, p)| p),\n+            value_used: Used,\n+            type_priv: type_def_and_priv.map(|(_, p)| p),\n+            type_used: Used\n+        };\n+\n+        if let Some((def, _)) = value_def_and_priv {\n+            self.resolver.def_map.borrow_mut().insert(directive.id, PathResolution {\n+                base_def: def,\n+                last_private: import_lp,\n+                depth: 0\n+            });\n+        }\n+        if let Some((def, _)) = type_def_and_priv {\n+            self.resolver.def_map.borrow_mut().insert(directive.id, PathResolution {\n+                base_def: def,\n+                last_private: import_lp,\n+                depth: 0\n+            });\n+        }\n+\n+        debug!(\"(resolving single import) successfully resolved import\");\n+        return ResolveResult::Success(());\n+    }\n+\n+    // Resolves a glob import. Note that this function cannot fail; it either\n+    // succeeds or bails out (as importing * from an empty module or a module\n+    // that exports nothing is valid). target_module is the module we are\n+    // actually importing, i.e., `foo` in `use foo::*`.\n+    fn resolve_glob_import(&mut self,\n+                           module_: &Module,\n+                           target_module: Rc<Module>,\n+                           import_directive: &ImportDirective,\n+                           lp: LastPrivate)\n+                           -> ResolveResult<()> {\n+        let id = import_directive.id;\n+        let is_public = import_directive.is_public;\n+\n+        // This function works in a highly imperative manner; it eagerly adds\n+        // everything it can to the list of import resolutions of the module\n+        // node.\n+        debug!(\"(resolving glob import) resolving glob import {}\", id);\n+\n+        // We must bail out if the node has unresolved imports of any kind\n+        // (including globs).\n+        if !(*target_module).all_imports_resolved() {\n+            debug!(\"(resolving glob import) target module has unresolved \\\n+                    imports; bailing out\");\n+            return ResolveResult::Indeterminate;\n+        }\n+\n+        assert_eq!(target_module.glob_count.get(), 0);\n+\n+        // Add all resolved imports from the containing module.\n+        let import_resolutions = target_module.import_resolutions.borrow();\n+        for (ident, target_import_resolution) in &*import_resolutions {\n+            debug!(\"(resolving glob import) writing module resolution \\\n+                    {} into `{}`\",\n+                   token::get_name(*ident),\n+                   module_to_string(module_));\n+\n+            if !target_import_resolution.is_public {\n+                debug!(\"(resolving glob import) nevermind, just kidding\");\n+                continue\n+            }\n+\n+            // Here we merge two import resolutions.\n+            let mut import_resolutions = module_.import_resolutions.borrow_mut();\n+            match import_resolutions.get_mut(ident) {\n+                Some(dest_import_resolution) => {\n+                    // Merge the two import resolutions at a finer-grained\n+                    // level.\n+\n+                    match target_import_resolution.value_target {\n+                        None => {\n+                            // Continue.\n+                        }\n+                        Some(ref value_target) => {\n+                            self.check_for_conflicting_import(&dest_import_resolution.value_target,\n+                                                              import_directive.span,\n+                                                              *ident,\n+                                                              ValueNS);\n+                            dest_import_resolution.value_target = Some(value_target.clone());\n+                        }\n+                    }\n+                    match target_import_resolution.type_target {\n+                        None => {\n+                            // Continue.\n+                        }\n+                        Some(ref type_target) => {\n+                            self.check_for_conflicting_import(&dest_import_resolution.type_target,\n+                                                              import_directive.span,\n+                                                              *ident,\n+                                                              TypeNS);\n+                            dest_import_resolution.type_target = Some(type_target.clone());\n+                        }\n+                    }\n+                    dest_import_resolution.is_public = is_public;\n+                    continue;\n+                }\n+                None => {}\n+            }\n+\n+            // Simple: just copy the old import resolution.\n+            let mut new_import_resolution = ImportResolution::new(id, is_public);\n+            new_import_resolution.value_target =\n+                target_import_resolution.value_target.clone();\n+            new_import_resolution.type_target =\n+                target_import_resolution.type_target.clone();\n+\n+            import_resolutions.insert(*ident, new_import_resolution);\n+        }\n+\n+        // Add all children from the containing module.\n+        build_reduced_graph::populate_module_if_necessary(self.resolver, &target_module);\n+\n+        for (&name, name_bindings) in &*target_module.children.borrow() {\n+            self.merge_import_resolution(module_,\n+                                         target_module.clone(),\n+                                         import_directive,\n+                                         name,\n+                                         name_bindings.clone());\n+\n+        }\n+\n+        // Add external module children from the containing module.\n+        for (&name, module) in &*target_module.external_module_children.borrow() {\n+            let name_bindings =\n+                Rc::new(Resolver::create_name_bindings_from_module(module.clone()));\n+            self.merge_import_resolution(module_,\n+                                         target_module.clone(),\n+                                         import_directive,\n+                                         name,\n+                                         name_bindings);\n+        }\n+\n+        // Record the destination of this import\n+        if let Some(did) = target_module.def_id.get() {\n+            self.resolver.def_map.borrow_mut().insert(id, PathResolution {\n+                base_def: DefMod(did),\n+                last_private: lp,\n+                depth: 0\n+            });\n+        }\n+\n+        debug!(\"(resolving glob import) successfully resolved import\");\n+        return ResolveResult::Success(());\n+    }\n+\n+    fn merge_import_resolution(&mut self,\n+                               module_: &Module,\n+                               containing_module: Rc<Module>,\n+                               import_directive: &ImportDirective,\n+                               name: Name,\n+                               name_bindings: Rc<NameBindings>) {\n+        let id = import_directive.id;\n+        let is_public = import_directive.is_public;\n+\n+        let mut import_resolutions = module_.import_resolutions.borrow_mut();\n+        let dest_import_resolution = import_resolutions.entry(name).get().unwrap_or_else(\n+            |vacant_entry| {\n+                // Create a new import resolution from this child.\n+                vacant_entry.insert(ImportResolution::new(id, is_public))\n+            });\n+\n+        debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n+               to `{}`\",\n+               &token::get_name(name),\n+               module_to_string(&*containing_module),\n+               module_to_string(module_));\n+\n+        // Merge the child item into the import resolution.\n+        {\n+            let mut merge_child_item = |namespace| {\n+                if name_bindings.defined_in_namespace_with(namespace, IMPORTABLE | PUBLIC) {\n+                    let namespace_name = match namespace {\n+                        TypeNS => \"type\",\n+                        ValueNS => \"value\",\n+                    };\n+                    debug!(\"(resolving glob import) ... for {} target\", namespace_name);\n+                    if dest_import_resolution.shadowable(namespace) == Shadowable::Never {\n+                        let msg = format!(\"a {} named `{}` has already been imported \\\n+                                           in this module\",\n+                                          namespace_name,\n+                                          &token::get_name(name));\n+                        span_err!(self.resolver.session, import_directive.span, E0251, \"{}\", msg);\n+                    } else {\n+                        let target = Target::new(containing_module.clone(),\n+                                                 name_bindings.clone(),\n+                                                 import_directive.shadowable);\n+                        dest_import_resolution.set_target_and_id(namespace,\n+                                                                 Some(target),\n+                                                                 id);\n+                    }\n+                }\n+            };\n+            merge_child_item(ValueNS);\n+            merge_child_item(TypeNS);\n+        }\n+\n+        dest_import_resolution.is_public = is_public;\n+\n+        self.check_for_conflicts_between_imports_and_items(\n+            module_,\n+            dest_import_resolution,\n+            import_directive.span,\n+            name);\n+    }\n+\n+    /// Checks that imported names and items don't have the same name.\n+    fn check_for_conflicting_import(&mut self,\n+                                    target: &Option<Target>,\n+                                    import_span: Span,\n+                                    name: Name,\n+                                    namespace: Namespace) {\n+        debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n+               &token::get_name(name),\n+               target.is_some());\n+\n+        match *target {\n+            Some(ref target) if target.shadowable != Shadowable::Always => {\n+                let msg = format!(\"a {} named `{}` has already been imported \\\n+                                   in this module\",\n+                                  match namespace {\n+                                    TypeNS => \"type\",\n+                                    ValueNS => \"value\",\n+                                  },\n+                                  &token::get_name(name));\n+                span_err!(self.resolver.session, import_span, E0252, \"{}\", &msg[..]);\n+            }\n+            Some(_) | None => {}\n+        }\n+    }\n+\n+    /// Checks that an import is actually importable\n+    fn check_that_import_is_importable(&mut self,\n+                                       name_bindings: &NameBindings,\n+                                       import_span: Span,\n+                                       name: Name,\n+                                       namespace: Namespace) {\n+        if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n+            let msg = format!(\"`{}` is not directly importable\",\n+                              token::get_name(name));\n+            span_err!(self.resolver.session, import_span, E0253, \"{}\", &msg[..]);\n+        }\n+    }\n+\n+    /// Checks that imported names and items don't have the same name.\n+    fn check_for_conflicts_between_imports_and_items(&mut self,\n+                                                     module: &Module,\n+                                                     import_resolution:\n+                                                     &ImportResolution,\n+                                                     import_span: Span,\n+                                                     name: Name) {\n+        // First, check for conflicts between imports and `extern crate`s.\n+        if module.external_module_children\n+                 .borrow()\n+                 .contains_key(&name) {\n+            match import_resolution.type_target {\n+                Some(ref target) if target.shadowable != Shadowable::Always => {\n+                    let msg = format!(\"import `{0}` conflicts with imported \\\n+                                       crate in this module \\\n+                                       (maybe you meant `use {0}::*`?)\",\n+                                      &token::get_name(name));\n+                    span_err!(self.resolver.session, import_span, E0254, \"{}\", &msg[..]);\n+                }\n+                Some(_) | None => {}\n+            }\n+        }\n+\n+        // Check for item conflicts.\n+        let children = module.children.borrow();\n+        let name_bindings = match children.get(&name) {\n+            None => {\n+                // There can't be any conflicts.\n+                return\n+            }\n+            Some(ref name_bindings) => (*name_bindings).clone(),\n+        };\n+\n+        match import_resolution.value_target {\n+            Some(ref target) if target.shadowable != Shadowable::Always => {\n+                if let Some(ref value) = *name_bindings.value_def.borrow() {\n+                    span_err!(self.resolver.session, import_span, E0255,\n+                              \"import `{}` conflicts with value in this module\",\n+                              &token::get_name(name));\n+                    if let Some(span) = value.value_span {\n+                        self.resolver.session.span_note(span, \"conflicting value here\");\n+                    }\n+                }\n+            }\n+            Some(_) | None => {}\n+        }\n+\n+        match import_resolution.type_target {\n+            Some(ref target) if target.shadowable != Shadowable::Always => {\n+                if let Some(ref ty) = *name_bindings.type_def.borrow() {\n+                    let (what, note) = if ty.module_def.is_some() {\n+                        (\"existing submodule\", \"note conflicting module here\")\n+                    } else {\n+                        (\"type in this module\", \"note conflicting type here\")\n+                    };\n+                    span_err!(self.resolver.session, import_span, E0256,\n+                              \"import `{}` conflicts with {}\",\n+                              &token::get_name(name), what);\n+                    if let Some(span) = ty.type_span {\n+                        self.resolver.session.span_note(span, note);\n+                    }\n+                }\n+            }\n+            Some(_) | None => {}\n+        }\n+    }\n+}\n+\n+fn import_path_to_string(names: &[Name],\n+                         subclass: ImportDirectiveSubclass)\n+                         -> String {\n+    if names.is_empty() {\n+        import_directive_subclass_to_string(subclass)\n+    } else {\n+        (format!(\"{}::{}\",\n+                 names_to_string(names),\n+                 import_directive_subclass_to_string(subclass))).to_string()\n+    }\n+}\n+\n+fn import_directive_subclass_to_string(subclass: ImportDirectiveSubclass) -> String {\n+    match subclass {\n+        SingleImport(_, source) => {\n+            token::get_name(source).to_string()\n+        }\n+        GlobImport => \"*\".to_string()\n+    }\n+}\n+\n+pub fn resolve_imports(resolver: &mut Resolver) {\n+    let mut import_resolver = ImportResolver {\n+        resolver: resolver,\n+    };\n+    import_resolver.resolve_imports();\n+}"}, {"sha": "2a47a696b1cf2ad8745b1c92d9667973a5ed96f7", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -121,13 +121,11 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         debug!(\"current path: {}\",\n                ast_util::path_name_i(&self.cx.path));\n \n-        if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n+        let i = if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n             match i.node {\n                 ast::ItemFn(_, ast::Unsafety::Unsafe, _, _, _) => {\n                     let diag = self.cx.span_diagnostic;\n-                    diag.span_fatal(i.span,\n-                                    \"unsafe functions cannot be used for \\\n-                                     tests\");\n+                    diag.span_fatal(i.span, \"unsafe functions cannot be used for tests\");\n                 }\n                 _ => {\n                     debug!(\"this is a test function\");\n@@ -142,9 +140,19 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                     self.tests.push(i.ident);\n                     // debug!(\"have {} test/bench functions\",\n                     //        cx.testfns.len());\n+\n+                    // Make all tests public so we can call them from outside\n+                    // the module (note that the tests are re-exported and must\n+                    // be made public themselves to avoid privacy errors).\n+                    i.map(|mut i| {\n+                        i.vis = ast::Public;\n+                        i\n+                    })\n                 }\n             }\n-        }\n+        } else {\n+            i\n+        };\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things"}, {"sha": "e60dbb290b079a6091c645a453b6889c0e19af6e", "filename": "src/test/auxiliary/privacy_reexport.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Fauxiliary%2Fprivacy_reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Fauxiliary%2Fprivacy_reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprivacy_reexport.rs?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -10,6 +10,6 @@\n \n pub use foo as bar;\n \n-mod foo {\n+pub mod foo {\n     pub fn frob() {}\n }"}, {"sha": "13ee3f163616e8ccf207d9f283bed3fbebd30a4b", "filename": "src/test/compile-fail/lint-dead-code-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -19,7 +19,7 @@ extern crate libc;\n \n pub use extern_foo as x;\n extern {\n-    fn extern_foo();\n+    pub fn extern_foo();\n }\n \n struct Foo; //~ ERROR: struct is never used"}, {"sha": "67dccb4c93e1ac0e6bb4fb6ed89610f2fe7a6923", "filename": "src/test/compile-fail/privacy1.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -27,10 +27,6 @@ mod bar {\n \n     // can't publicly re-export private items\n     pub use self::baz::{foo, bar};\n-    //~^ ERROR: function `bar` is private\n-\n-    pub use self::private::ppriv;\n-    //~^ ERROR: function `ppriv` is private\n \n     pub struct A;\n     impl A {\n@@ -61,10 +57,8 @@ mod bar {\n             fn bar2(&self) {}\n         }\n \n-        // both of these are re-exported by `bar`, but only one should be\n-        // validly re-exported\n         pub fn foo() {}\n-        fn bar() {}\n+        pub fn bar() {}\n     }\n \n     extern {\n@@ -92,10 +86,6 @@ mod bar {\n         pub fn gpub() {}\n         fn gpriv() {}\n     }\n-\n-    mod private {\n-        fn ppriv() {}\n-    }\n }\n \n pub fn gpub() {}\n@@ -142,13 +132,13 @@ mod foo {\n \n         ::bar::baz::foo(); //~ ERROR: function `foo` is inaccessible\n                            //~^ NOTE: module `baz` is private\n-        ::bar::baz::bar(); //~ ERROR: function `bar` is private\n+        ::bar::baz::bar(); //~ ERROR: function `bar` is inaccessible\n     }\n \n     fn test2() {\n         use bar::baz::{foo, bar};\n         //~^ ERROR: function `foo` is inaccessible\n-        //~^^ ERROR: function `bar` is private\n+        //~^^ ERROR: function `bar` is inaccessible\n         foo();\n         bar();\n     }"}, {"sha": "d074095dbdedd796e2c1d781c31250415100ae43", "filename": "src/test/run-pass/issue-16597.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Frun-pass%2Fissue-16597.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Frun-pass%2Fissue-16597.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16597.rs?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -15,5 +15,5 @@ mod test {\n     use super::*;\n \n     #[test]\n-    fn test(){}\n+    pub fn test(){}\n }"}, {"sha": "c297998b6493a08575bb65b5f8c4392735dab09a", "filename": "src/test/run-pass/issue-20823.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Frun-pass%2Fissue-20823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Frun-pass%2Fissue-20823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20823.rs?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -14,4 +14,4 @@\n #![deny(unstable)]\n \n #[test]\n-fn foo() {}\n+pub fn foo() {}"}, {"sha": "88bbba44bbe14a30135f5ad793287eabfa5814ee", "filename": "src/test/run-pass/issue-5950.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Frun-pass%2Fissue-5950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Frun-pass%2Fissue-5950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5950.rs?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -11,6 +11,6 @@\n \n pub use local as local_alias;\n \n-mod local { }\n+pub mod local { }\n \n pub fn main() {}"}, {"sha": "f7985efbc310fbdbcafc414e10c3442e60d8ea6e", "filename": "src/test/run-pass/test-fn-signature-verification-for-explicit-return-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Frun-pass%2Ftest-fn-signature-verification-for-explicit-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Frun-pass%2Ftest-fn-signature-verification-for-explicit-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-fn-signature-verification-for-explicit-return-type.rs?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -13,8 +13,8 @@\n extern crate test;\n \n #[bench]\n-fn bench_explicit_return_type(_: &mut ::test::Bencher) -> () {}\n+pub fn bench_explicit_return_type(_: &mut ::test::Bencher) -> () {}\n \n #[test]\n-fn test_explicit_return_type() -> () {}\n+pub fn test_explicit_return_type() -> () {}\n "}, {"sha": "94d20f703a0fc33217176bd01cc065aab3730592", "filename": "src/test/run-pass/test-should-fail-good-message.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Frun-pass%2Ftest-should-fail-good-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74adeda78a807d4e7e3598fa0b3dd5470bb89fc2/src%2Ftest%2Frun-pass%2Ftest-should-fail-good-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-should-fail-good-message.rs?ref=74adeda78a807d4e7e3598fa0b3dd5470bb89fc2", "patch": "@@ -13,13 +13,13 @@\n \n #[test]\n #[should_panic(expected = \"foo\")]\n-fn test_foo() {\n+pub fn test_foo() {\n     panic!(\"foo bar\")\n }\n \n #[test]\n #[should_panic(expected = \"foo\")]\n-fn test_foo_dynamic() {\n+pub fn test_foo_dynamic() {\n     panic!(\"{} bar\", \"foo\")\n }\n "}]}