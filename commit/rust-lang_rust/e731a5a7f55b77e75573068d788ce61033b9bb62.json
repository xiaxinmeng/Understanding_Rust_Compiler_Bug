{"sha": "e731a5a7f55b77e75573068d788ce61033b9bb62", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MzFhNWE3ZjU1Yjc3ZTc1NTczMDY4ZDc4OGNlNjEwMzNiOWJiNjI=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-11-03T06:27:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-03T06:27:05Z"}, "message": "Rollup merge of #78400 - GuillaumeGomez:fix-unindent, r=jyn514\n\nFix unindent in doc comments\n\nFixes #70732\n\nr? ``@jyn514``", "tree": {"sha": "53ea1ea8a9bf39b304569094dbc0619e64db388a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53ea1ea8a9bf39b304569094dbc0619e64db388a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e731a5a7f55b77e75573068d788ce61033b9bb62", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfoPg6CRBK7hj4Ov3rIwAAdHIIAH9MDfMdmHQuEAbwg8gqZR+c\ncE6yKpiIfjSRHO9DPSszjeXAx7ZgmW1+sQmo6Ke4D2lOj+9ecEzAfA1R7FbUbaGO\nqqvW98AAcw0uoz6BqNc4DneVjjzfGSl05ww/XgaZ4VOOyp/K29tLSvbhMKaSV4JO\nzTX1viqtnK1ZUiXyK+qHhTcTAQ6qkfijbs+5X/LDfB836iDI6R32aQjq0kNkKNm5\ntWg+cxx5Gc9K7GUiXtSEg+wyVaMrndTSylbuIsRYH78LSmTGwtVyP+91JzS9H/Jm\n8b1PpIr9i/9O50Ekqxp+rezcVVJCNp/E/D8l1FOge/tBcPyWjCrbj9IDHG2HZVg=\n=Gz0E\n-----END PGP SIGNATURE-----\n", "payload": "tree 53ea1ea8a9bf39b304569094dbc0619e64db388a\nparent 0716724a0b29269ba3b79abb65f1f0505e5bb0ec\nparent 87f28978c532547df7e8d746ad98f863a202bab0\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1604384825 +0900\ncommitter GitHub <noreply@github.com> 1604384825 +0900\n\nRollup merge of #78400 - GuillaumeGomez:fix-unindent, r=jyn514\n\nFix unindent in doc comments\n\nFixes #70732\n\nr? ``@jyn514``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e731a5a7f55b77e75573068d788ce61033b9bb62", "html_url": "https://github.com/rust-lang/rust/commit/e731a5a7f55b77e75573068d788ce61033b9bb62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e731a5a7f55b77e75573068d788ce61033b9bb62/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0716724a0b29269ba3b79abb65f1f0505e5bb0ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/0716724a0b29269ba3b79abb65f1f0505e5bb0ec", "html_url": "https://github.com/rust-lang/rust/commit/0716724a0b29269ba3b79abb65f1f0505e5bb0ec"}, {"sha": "87f28978c532547df7e8d746ad98f863a202bab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/87f28978c532547df7e8d746ad98f863a202bab0", "html_url": "https://github.com/rust-lang/rust/commit/87f28978c532547df7e8d746ad98f863a202bab0"}], "stats": {"total": 255, "additions": 163, "deletions": 92}, "files": [{"sha": "51c380f438cc95230b0d84655e6842ac23f818d8", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 70, "deletions": 55, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/e731a5a7f55b77e75573068d788ce61033b9bb62/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e731a5a7f55b77e75573068d788ce61033b9bb62/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=e731a5a7f55b77e75573068d788ce61033b9bb62", "patch": "@@ -1,7 +1,6 @@\n use std::cmp;\n-use std::string::String;\n \n-use crate::clean::{self, DocFragment, Item};\n+use crate::clean::{self, DocFragment, DocFragmentKind, Item};\n use crate::core::DocContext;\n use crate::fold::{self, DocFolder};\n use crate::passes::Pass;\n@@ -35,65 +34,81 @@ impl clean::Attributes {\n }\n \n fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n-    for fragment in docs {\n-        fragment.doc = unindent(&fragment.doc);\n-    }\n-}\n-\n-fn unindent(s: &str) -> String {\n-    let lines = s.lines().collect::<Vec<&str>>();\n-    let mut saw_first_line = false;\n-    let mut saw_second_line = false;\n-    let min_indent = lines.iter().fold(usize::MAX, |min_indent, line| {\n-        // After we see the first non-whitespace line, look at\n-        // the line we have. If it is not whitespace, and therefore\n-        // part of the first paragraph, then ignore the indentation\n-        // level of the first line\n-        let ignore_previous_indents =\n-            saw_first_line && !saw_second_line && !line.chars().all(|c| c.is_whitespace());\n+    // `add` is used in case the most common sugared doc syntax is used (\"/// \"). The other\n+    // fragments kind's lines are never starting with a whitespace unless they are using some\n+    // markdown formatting requiring it. Therefore, if the doc block have a mix between the two,\n+    // we need to take into account the fact that the minimum indent minus one (to take this\n+    // whitespace into account).\n+    //\n+    // For example:\n+    //\n+    // /// hello!\n+    // #[doc = \"another\"]\n+    //\n+    // In this case, you want \"hello! another\" and not \"hello!  another\".\n+    let add = if docs.windows(2).any(|arr| arr[0].kind != arr[1].kind)\n+        && docs.iter().any(|d| d.kind == DocFragmentKind::SugaredDoc)\n+    {\n+        // In case we have a mix of sugared doc comments and \"raw\" ones, we want the sugared one to\n+        // \"decide\" how much the minimum indent will be.\n+        1\n+    } else {\n+        0\n+    };\n \n-        let min_indent = if ignore_previous_indents { usize::MAX } else { min_indent };\n+    // `min_indent` is used to know how much whitespaces from the start of each lines must be\n+    // removed. Example:\n+    //\n+    // ///     hello!\n+    // #[doc = \"another\"]\n+    //\n+    // In here, the `min_indent` is 1 (because non-sugared fragment are always counted with minimum\n+    // 1 whitespace), meaning that \"hello!\" will be considered a codeblock because it starts with 4\n+    // (5 - 1) whitespaces.\n+    let min_indent = match docs\n+        .iter()\n+        .map(|fragment| {\n+            fragment.doc.lines().fold(usize::MAX, |min_indent, line| {\n+                if line.chars().all(|c| c.is_whitespace()) {\n+                    min_indent\n+                } else {\n+                    // Compare against either space or tab, ignoring whether they are\n+                    // mixed or not.\n+                    let whitespace = line.chars().take_while(|c| *c == ' ' || *c == '\\t').count();\n+                    cmp::min(min_indent, whitespace)\n+                        + if fragment.kind == DocFragmentKind::SugaredDoc { 0 } else { add }\n+                }\n+            })\n+        })\n+        .min()\n+    {\n+        Some(x) => x,\n+        None => return,\n+    };\n \n-        if saw_first_line {\n-            saw_second_line = true;\n+    for fragment in docs {\n+        if fragment.doc.lines().count() == 0 {\n+            continue;\n         }\n \n-        if line.chars().all(|c| c.is_whitespace()) {\n-            min_indent\n+        let min_indent = if fragment.kind != DocFragmentKind::SugaredDoc && min_indent > 0 {\n+            min_indent - add\n         } else {\n-            saw_first_line = true;\n-            let mut whitespace = 0;\n-            line.chars().all(|char| {\n-                // Compare against either space or tab, ignoring whether they\n-                // are mixed or not\n-                if char == ' ' || char == '\\t' {\n-                    whitespace += 1;\n-                    true\n+            min_indent\n+        };\n+\n+        fragment.doc = fragment\n+            .doc\n+            .lines()\n+            .map(|line| {\n+                if line.chars().all(|c| c.is_whitespace()) {\n+                    line.to_string()\n                 } else {\n-                    false\n+                    assert!(line.len() >= min_indent);\n+                    line[min_indent..].to_string()\n                 }\n-            });\n-            cmp::min(min_indent, whitespace)\n-        }\n-    });\n-\n-    if !lines.is_empty() {\n-        let mut unindented = vec![lines[0].trim_start().to_string()];\n-        unindented.extend_from_slice(\n-            &lines[1..]\n-                .iter()\n-                .map(|&line| {\n-                    if line.chars().all(|c| c.is_whitespace()) {\n-                        line.to_string()\n-                    } else {\n-                        assert!(line.len() >= min_indent);\n-                        line[min_indent..].to_string()\n-                    }\n-                })\n-                .collect::<Vec<_>>(),\n-        );\n-        unindented.join(\"\\n\")\n-    } else {\n-        s.to_string()\n+            })\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n     }\n }"}, {"sha": "9dec71f7683aa757a6ae901842e3809ff3549060", "filename": "src/librustdoc/passes/unindent_comments/tests.rs", "status": "modified", "additions": 28, "deletions": 37, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e731a5a7f55b77e75573068d788ce61033b9bb62/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e731a5a7f55b77e75573068d788ce61033b9bb62/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs?ref=e731a5a7f55b77e75573068d788ce61033b9bb62", "patch": "@@ -1,72 +1,63 @@\n use super::*;\n+use rustc_span::source_map::DUMMY_SP;\n+\n+fn create_doc_fragment(s: &str) -> Vec<DocFragment> {\n+    vec![DocFragment {\n+        line: 0,\n+        span: DUMMY_SP,\n+        parent_module: None,\n+        doc: s.to_string(),\n+        kind: DocFragmentKind::SugaredDoc,\n+    }]\n+}\n+\n+#[track_caller]\n+fn run_test(input: &str, expected: &str) {\n+    let mut s = create_doc_fragment(input);\n+    unindent_fragments(&mut s);\n+    assert_eq!(s[0].doc, expected);\n+}\n \n #[test]\n fn should_unindent() {\n-    let s = \"    line1\\n    line2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\nline2\");\n+    run_test(\"    line1\\n    line2\", \"line1\\nline2\");\n }\n \n #[test]\n fn should_unindent_multiple_paragraphs() {\n-    let s = \"    line1\\n\\n    line2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\n\\nline2\");\n+    run_test(\"    line1\\n\\n    line2\", \"line1\\n\\nline2\");\n }\n \n #[test]\n fn should_leave_multiple_indent_levels() {\n     // Line 2 is indented another level beyond the\n     // base indentation and should be preserved\n-    let s = \"    line1\\n\\n        line2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\n\\n    line2\");\n+    run_test(\"    line1\\n\\n        line2\", \"line1\\n\\n    line2\");\n }\n \n #[test]\n fn should_ignore_first_line_indent() {\n-    // The first line of the first paragraph may not be indented as\n-    // far due to the way the doc string was written:\n-    //\n-    // #[doc = \"Start way over here\n-    //          and continue here\"]\n-    let s = \"line1\\n    line2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\nline2\");\n+    run_test(\"line1\\n    line2\", \"line1\\n    line2\");\n }\n \n #[test]\n fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n-    let s = \"line1\\n\\n    line2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\n\\n    line2\");\n+    run_test(\"line1\\n\\n    line2\", \"line1\\n\\n    line2\");\n }\n \n #[test]\n fn should_unindent_tabs() {\n-    let s = \"\\tline1\\n\\tline2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\nline2\");\n+    run_test(\"\\tline1\\n\\tline2\", \"line1\\nline2\");\n }\n \n #[test]\n fn should_trim_mixed_indentation() {\n-    let s = \"\\t    line1\\n\\t    line2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\nline2\");\n-\n-    let s = \"    \\tline1\\n    \\tline2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1\\nline2\");\n+    run_test(\"\\t    line1\\n\\t    line2\", \"line1\\nline2\");\n+    run_test(\"    \\tline1\\n    \\tline2\", \"line1\\nline2\");\n }\n \n #[test]\n fn should_not_trim() {\n-    let s = \"\\t    line1  \\n\\t    line2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1  \\nline2\");\n-\n-    let s = \"    \\tline1  \\n    \\tline2\".to_string();\n-    let r = unindent(&s);\n-    assert_eq!(r, \"line1  \\nline2\");\n+    run_test(\"\\t    line1  \\n\\t    line2\", \"line1  \\nline2\");\n+    run_test(\"    \\tline1  \\n    \\tline2\", \"line1  \\nline2\");\n }"}, {"sha": "8e4e7a25af8d7cf877218f00f43b835b5f360038", "filename": "src/test/rustdoc/unindent.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e731a5a7f55b77e75573068d788ce61033b9bb62/src%2Ftest%2Frustdoc%2Funindent.md", "raw_url": "https://github.com/rust-lang/rust/raw/e731a5a7f55b77e75573068d788ce61033b9bb62/src%2Ftest%2Frustdoc%2Funindent.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Funindent.md?ref=e731a5a7f55b77e75573068d788ce61033b9bb62", "patch": "@@ -0,0 +1 @@\n+Just some text."}, {"sha": "d10e1ec89c59ea19f85bbe9869fe446407e6c434", "filename": "src/test/rustdoc/unindent.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e731a5a7f55b77e75573068d788ce61033b9bb62/src%2Ftest%2Frustdoc%2Funindent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e731a5a7f55b77e75573068d788ce61033b9bb62/src%2Ftest%2Frustdoc%2Funindent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Funindent.rs?ref=e731a5a7f55b77e75573068d788ce61033b9bb62", "patch": "@@ -0,0 +1,64 @@\n+#![feature(external_doc)]\n+\n+#![crate_name = \"foo\"]\n+\n+// @has foo/struct.Example.html\n+// @matches - '//pre[@class=\"rust rust-example-rendered\"]' \\\n+//     '(?m)let example = Example::new\\(\\)\\n    \\.first\\(\\)\\n    \\.second\\(\\)\\n    \\.build\\(\\);\\Z'\n+/// ```rust\n+/// let example = Example::new()\n+///     .first()\n+#[cfg_attr(not(feature = \"one\"), doc = \"    .second()\")]\n+///     .build();\n+/// ```\n+pub struct Example;\n+\n+// @has foo/struct.F.html\n+// @matches - '//pre[@class=\"rust rust-example-rendered\"]' \\\n+//     '(?m)let example = Example::new\\(\\)\\n    \\.first\\(\\)\\n    \\.another\\(\\)\\n    \\.build\\(\\);\\Z'\n+///```rust\n+///let example = Example::new()\n+///    .first()\n+#[cfg_attr(not(feature = \"one\"), doc = \"    .another()\")]\n+///    .build();\n+/// ```\n+pub struct F;\n+\n+// @has foo/struct.G.html\n+// @matches - '//pre[@class=\"rust rust-example-rendered\"]' \\\n+//     '(?m)let example = Example::new\\(\\)\\n\\.first\\(\\)\\n    \\.another\\(\\)\\n\\.build\\(\\);\\Z'\n+///```rust\n+///let example = Example::new()\n+///.first()\n+#[cfg_attr(not(feature = \"one\"), doc = \"    .another()\")]\n+///.build();\n+///```\n+pub struct G;\n+\n+// @has foo/struct.H.html\n+// @has - '//div[@class=\"docblock\"]/p' 'no whitespace lol'\n+///no whitespace\n+#[doc = \" lol\"]\n+pub struct H;\n+\n+// @has foo/struct.I.html\n+// @matches - '//pre[@class=\"rust rust-example-rendered\"]' '(?m)4 whitespaces!\\Z'\n+///     4 whitespaces!\n+#[doc = \"something\"]\n+pub struct I;\n+\n+// @has foo/struct.J.html\n+// @matches - '//div[@class=\"docblock\"]/p' '(?m)a\\nno whitespace\\nJust some text.\\Z'\n+///a\n+///no whitespace\n+#[doc(include = \"unindent.md\")]\n+pub struct J;\n+\n+// @has foo/struct.K.html\n+// @matches - '//pre[@class=\"rust rust-example-rendered\"]' '(?m)4 whitespaces!\\Z'\n+///a\n+///\n+///    4 whitespaces!\n+///\n+#[doc(include = \"unindent.md\")]\n+pub struct K;"}]}