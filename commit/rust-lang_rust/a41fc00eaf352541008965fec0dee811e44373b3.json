{"sha": "a41fc00eaf352541008965fec0dee811e44373b3", "node_id": "C_kwDOAAsO6NoAKGE0MWZjMDBlYWYzNTI1NDEwMDg5NjVmZWMwZGVlODExZTQ0MzczYjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-13T20:34:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-13T20:34:12Z"}, "message": "Auto merge of #110295 - matthiaskrgr:rollup-xas29a1, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #109036 (Fix diff option conflict in UI test)\n - #110193 (Check for body owner fallibly in error reporting)\n - #110233 (Make rust-intrinsic ABI unwindable)\n - #110259 (Added diagnostic for pin! macro in addition to Box::pin if Unpin isn't implemented)\n - #110265 (Automatically update the LLVM submodule for musl target (and other places))\n - #110277 (dead-code-lint: de-dup multiple unused assoc functions)\n - #110283 (Only emit alignment checks if we have a panic_impl)\n - #110291 (Implement `Copy` for `LocationDetail`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7f07073f579a4c53caa285bcec3052b56c4b194b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f07073f579a4c53caa285bcec3052b56c4b194b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a41fc00eaf352541008965fec0dee811e44373b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a41fc00eaf352541008965fec0dee811e44373b3", "html_url": "https://github.com/rust-lang/rust/commit/a41fc00eaf352541008965fec0dee811e44373b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a41fc00eaf352541008965fec0dee811e44373b3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4dae0dac76436ada630b519f5fbf0b373bc5974", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4dae0dac76436ada630b519f5fbf0b373bc5974", "html_url": "https://github.com/rust-lang/rust/commit/e4dae0dac76436ada630b519f5fbf0b373bc5974"}, {"sha": "46c630167218cf4477913892152e5a86ca73d2c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/46c630167218cf4477913892152e5a86ca73d2c4", "html_url": "https://github.com/rust-lang/rust/commit/46c630167218cf4477913892152e5a86ca73d2c4"}], "stats": {"total": 683, "additions": 580, "deletions": 103}, "files": [{"sha": "3701eb93ec834ae870fb5f00f83aa650cbf8644f", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -77,7 +77,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         line: u32,\n         col: u32,\n     ) -> MPlaceTy<'tcx, M::Provenance> {\n-        let loc_details = &self.tcx.sess.opts.unstable_opts.location_detail;\n+        let loc_details = self.tcx.sess.opts.unstable_opts.location_detail;\n         // This can fail if rustc runs out of memory right here. Trying to emit an error would be\n         // pointless, since that would require allocating more memory than these short strings.\n         let file = if loc_details.file {"}, {"sha": "195d951f9f366af83a45f198e182d692ab289829", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -1226,10 +1226,11 @@ pub fn fn_can_unwind(tcx: TyCtxt<'_>, fn_def_id: Option<DefId>, abi: SpecAbi) ->\n         | AvrNonBlockingInterrupt\n         | CCmseNonSecureCall\n         | Wasm\n-        | RustIntrinsic\n         | PlatformIntrinsic\n         | Unadjusted => false,\n-        Rust | RustCall | RustCold => tcx.sess.panic_strategy() == PanicStrategy::Unwind,\n+        Rust | RustCall | RustCold | RustIntrinsic => {\n+            tcx.sess.panic_strategy() == PanicStrategy::Unwind\n+        }\n     }\n }\n "}, {"sha": "c76dc56065c32763399a471bba06c48745e58b00", "filename": "compiler/rustc_mir_transform/src/check_alignment.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -1,5 +1,6 @@\n use crate::MirPass;\n use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::*;\n use rustc_middle::mir::{\n@@ -17,6 +18,12 @@ impl<'tcx> MirPass<'tcx> for CheckAlignment {\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        // This pass emits new panics. If for whatever reason we do not have a panic\n+        // implementation, running this pass may cause otherwise-valid code to not compile.\n+        if tcx.lang_items().get(LangItem::PanicImpl).is_none() {\n+            return;\n+        }\n+\n         let basic_blocks = body.basic_blocks.as_mut();\n         let local_decls = &mut body.local_decls;\n "}, {"sha": "5cfe691df17a14882baf66f212694bc0e112207f", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -700,6 +700,13 @@ impl<'tcx> DeadVisitor<'tcx> {\n             .collect();\n \n         let descr = tcx.def_descr(first_id.to_def_id());\n+        // `impl` blocks are \"batched\" and (unlike other batching) might\n+        // contain different kinds of associated items.\n+        let descr = if dead_codes.iter().any(|did| tcx.def_descr(did.to_def_id()) != descr) {\n+            \"associated item\"\n+        } else {\n+            descr\n+        };\n         let num = dead_codes.len();\n         let multiple = num > 6;\n         let name_list = names.into();\n@@ -712,12 +719,12 @@ impl<'tcx> DeadVisitor<'tcx> {\n \n         let parent_info = if let Some(parent_item) = parent_item {\n             let parent_descr = tcx.def_descr(parent_item.to_def_id());\n-            Some(ParentInfo {\n-                num,\n-                descr,\n-                parent_descr,\n-                span: tcx.def_ident_span(parent_item).unwrap(),\n-            })\n+            let span = if let DefKind::Impl { .. } = tcx.def_kind(parent_item) {\n+                tcx.def_span(parent_item)\n+            } else {\n+                tcx.def_ident_span(parent_item).unwrap()\n+            };\n+            Some(ParentInfo { num, descr, parent_descr, span })\n         } else {\n             None\n         };\n@@ -800,16 +807,7 @@ impl<'tcx> DeadVisitor<'tcx> {\n     }\n \n     fn check_definition(&mut self, def_id: LocalDefId) {\n-        if self.live_symbols.contains(&def_id) {\n-            return;\n-        }\n-        if has_allow_dead_code_or_lang_attr(self.tcx, def_id) {\n-            return;\n-        }\n-        let Some(name) = self.tcx.opt_item_name(def_id.to_def_id()) else {\n-            return\n-        };\n-        if name.as_str().starts_with('_') {\n+        if self.is_live_code(def_id) {\n             return;\n         }\n         match self.tcx.def_kind(def_id) {\n@@ -827,6 +825,18 @@ impl<'tcx> DeadVisitor<'tcx> {\n             _ => {}\n         }\n     }\n+\n+    fn is_live_code(&self, def_id: LocalDefId) -> bool {\n+        // if we cannot get a name for the item, then we just assume that it is\n+        // live. I mean, we can't really emit a lint.\n+        let Some(name) = self.tcx.opt_item_name(def_id.to_def_id()) else {\n+            return true;\n+        };\n+\n+        self.live_symbols.contains(&def_id)\n+            || has_allow_dead_code_or_lang_attr(self.tcx, def_id)\n+            || name.as_str().starts_with('_')\n+    }\n }\n \n fn check_mod_deathness(tcx: TyCtxt<'_>, module: LocalDefId) {\n@@ -836,6 +846,22 @@ fn check_mod_deathness(tcx: TyCtxt<'_>, module: LocalDefId) {\n     let module_items = tcx.hir_module_items(module);\n \n     for item in module_items.items() {\n+        if let hir::ItemKind::Impl(impl_item) = tcx.hir().item(item).kind {\n+            let mut dead_items = Vec::new();\n+            for item in impl_item.items {\n+                let did = item.id.owner_id.def_id;\n+                if !visitor.is_live_code(did) {\n+                    dead_items.push(did)\n+                }\n+            }\n+            visitor.warn_multiple_dead_codes(\n+                &dead_items,\n+                \"used\",\n+                Some(item.owner_id.def_id),\n+                false,\n+            );\n+        }\n+\n         if !live_symbols.contains(&item.owner_id.def_id) {\n             let parent = tcx.local_parent(item.owner_id.def_id);\n             if parent != module && !live_symbols.contains(&parent) {\n@@ -900,10 +926,6 @@ fn check_mod_deathness(tcx: TyCtxt<'_>, module: LocalDefId) {\n         }\n     }\n \n-    for impl_item in module_items.impl_items() {\n-        visitor.check_definition(impl_item.owner_id.def_id);\n-    }\n-\n     for foreign_item in module_items.foreign_items() {\n         visitor.check_definition(foreign_item.owner_id.def_id);\n     }"}, {"sha": "79eb31bb1050e18dde6b355bd64cef3751fe1b3a", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -222,7 +222,7 @@ impl LinkerPluginLto {\n }\n \n /// The different settings that can be enabled via the `-Z location-detail` flag.\n-#[derive(Clone, PartialEq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Hash, Debug)]\n pub struct LocationDetail {\n     pub file: bool,\n     pub line: bool,"}, {"sha": "0ef6579664a61c09b982e6753509c45303f859c4", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -2396,8 +2396,8 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n \n                 if let Some(ty::subst::GenericArgKind::Type(_)) = subst.map(|subst| subst.unpack())\n+                    && let Some(body_id) = self.tcx.hir().maybe_body_owned_by(obligation.cause.body_id)\n                 {\n-                    let body_id = self.tcx.hir().body_owned_by(obligation.cause.body_id);\n                     let mut expr_finder = FindExprBySpan::new(span);\n                     expr_finder.visit_expr(&self.tcx.hir().body(body_id).value);\n "}, {"sha": "c4f554c8c6bf99c57d2dfeeee6636975e37911a8", "filename": "library/core/src/ffi/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -615,12 +615,15 @@ impl<'f> Drop for VaListImpl<'f> {\n extern \"rust-intrinsic\" {\n     /// Destroy the arglist `ap` after initialization with `va_start` or\n     /// `va_copy`.\n+    #[rustc_nounwind]\n     fn va_end(ap: &mut VaListImpl<'_>);\n \n     /// Copies the current location of arglist `src` to the arglist `dst`.\n+    #[rustc_nounwind]\n     fn va_copy<'f>(dest: *mut VaListImpl<'f>, src: &VaListImpl<'f>);\n \n     /// Loads an argument of type `T` from the `va_list` `ap` and increment the\n     /// argument `ap` points to.\n+    #[rustc_nounwind]\n     fn va_arg<T: sealed_trait::VaArgSafe>(ap: &mut VaListImpl<'_>) -> T;\n }"}, {"sha": "a7c100e1b23ed6d87fd8c0bf00e48bf0c6a966c3", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 231, "deletions": 1, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -84,104 +84,119 @@ extern \"rust-intrinsic\" {\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Relaxed`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_relaxed_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_relaxed_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_relaxed_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acquire_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acquire_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acquire_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_release_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_release_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Release`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_release_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acqrel_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acqrel_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acqrel_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_seqcst_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_seqcst_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_seqcst_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Stores a value if the current value is the same as the `old` value.\n@@ -190,411 +205,477 @@ extern \"rust-intrinsic\" {\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Relaxed`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_relaxed_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_relaxed_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_relaxed_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acquire_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acquire_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acquire_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_release_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_release_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Release`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_release_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acqrel_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acqrel_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acqrel_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_seqcst_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_seqcst_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_seqcst_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::load`].\n+    #[rustc_nounwind]\n     pub fn atomic_load_seqcst<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::load`].\n+    #[rustc_nounwind]\n     pub fn atomic_load_acquire<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::load`].\n+    #[rustc_nounwind]\n     pub fn atomic_load_relaxed<T: Copy>(src: *const T) -> T;\n+    #[rustc_nounwind]\n     pub fn atomic_load_unordered<T: Copy>(src: *const T) -> T;\n \n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::store`].\n+    #[rustc_nounwind]\n     pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::store`].\n+    #[rustc_nounwind]\n     pub fn atomic_store_release<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::store`].\n+    #[rustc_nounwind]\n     pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n+    #[rustc_nounwind]\n     pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n \n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n@@ -607,93 +688,108 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_seqcst();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_acquire();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_release();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::AcqRel`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_acqrel();\n \n     /// A compiler-only memory barrier.\n@@ -706,6 +802,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_seqcst();\n     /// A compiler-only memory barrier.\n     ///\n@@ -717,6 +814,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_acquire();\n     /// A compiler-only memory barrier.\n     ///\n@@ -728,6 +826,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_release();\n     /// A compiler-only memory barrier.\n     ///\n@@ -739,6 +838,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::AcqRel`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_acqrel();\n \n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n@@ -750,6 +850,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n@@ -760,6 +861,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n@@ -770,6 +872,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n@@ -780,6 +883,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_write_instruction<T>(data: *const T, locality: i32);\n \n     /// Magic intrinsic that derives its meaning from attributes\n@@ -792,6 +896,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This intrinsic should not be used outside of the compiler.\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn rustc_peek<T>(_: T) -> T;\n \n     /// Aborts the execution of the process.\n@@ -810,6 +915,7 @@ extern \"rust-intrinsic\" {\n     /// process will probably terminate with a signal like `SIGABRT`, `SIGILL`, `SIGTRAP`, `SIGSEGV` or\n     /// `SIGBUS`.  The precise behaviour is not guaranteed and not stable.\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn abort() -> !;\n \n     /// Informs the optimizer that this point in the code is not reachable,\n@@ -821,6 +927,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is [`core::hint::unreachable_unchecked`].\n     #[rustc_const_stable(feature = \"const_unreachable_unchecked\", since = \"1.57.0\")]\n+    #[rustc_nounwind]\n     pub fn unreachable() -> !;\n \n     /// Informs the optimizer that a condition is always true.\n@@ -834,6 +941,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_assume\", issue = \"76972\")]\n+    #[rustc_nounwind]\n     pub fn assume(b: bool);\n \n     /// Hints to the compiler that branch condition is likely to be true.\n@@ -849,6 +957,7 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn likely(b: bool) -> bool;\n \n     /// Hints to the compiler that branch condition is likely to be false.\n@@ -864,11 +973,13 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn unlikely(b: bool) -> bool;\n \n     /// Executes a breakpoint trap, for inspection by a debugger.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn breakpoint();\n \n     /// The size of a type in bytes.\n@@ -884,6 +995,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::mem::size_of`].\n     #[rustc_const_stable(feature = \"const_size_of\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn size_of<T>() -> usize;\n \n     /// The minimum alignment of a type.\n@@ -896,23 +1008,27 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::mem::align_of`].\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn min_align_of<T>() -> usize;\n     /// The preferred alignment of a type.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     /// It's \"tracking issue\" is [#91971](https://github.com/rust-lang/rust/issues/91971).\n     #[rustc_const_unstable(feature = \"const_pref_align_of\", issue = \"91971\")]\n+    #[rustc_nounwind]\n     pub fn pref_align_of<T>() -> usize;\n \n     /// The size of the referenced value in bytes.\n     ///\n     /// The stabilized version of this intrinsic is [`mem::size_of_val`].\n     #[rustc_const_unstable(feature = \"const_size_of_val\", issue = \"46571\")]\n+    #[rustc_nounwind]\n     pub fn size_of_val<T: ?Sized>(_: *const T) -> usize;\n     /// The required alignment of the referenced value.\n     ///\n     /// The stabilized version of this intrinsic is [`core::mem::align_of_val`].\n     #[rustc_const_unstable(feature = \"const_align_of_val\", issue = \"46571\")]\n+    #[rustc_nounwind]\n     pub fn min_align_of_val<T: ?Sized>(_: *const T) -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n@@ -925,6 +1041,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::any::type_name`].\n     #[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n@@ -939,6 +1056,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::any::TypeId::of`].\n     #[rustc_const_unstable(feature = \"const_type_id\", issue = \"77125\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n@@ -947,6 +1065,7 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_stable(feature = \"const_assert_type\", since = \"1.59.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn assert_inhabited<T>();\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` does not permit\n@@ -955,13 +1074,15 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_assert_type2\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn assert_zero_valid<T>();\n \n     /// A guard for `std::mem::uninitialized`. This will statically either panic, or do nothing.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_assert_type2\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn assert_mem_uninitialized_valid<T>();\n \n     /// Gets a reference to a static `Location` indicating where it was called.\n@@ -974,6 +1095,7 @@ extern \"rust-intrinsic\" {\n     /// Consider using [`core::panic::Location::caller`] instead.\n     #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"76156\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n \n     /// Moves a value out of scope without running drop glue.\n@@ -987,6 +1109,7 @@ extern \"rust-intrinsic\" {\n     /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_intrinsic_forget\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn forget<T: ?Sized>(_: T);\n \n     /// Reinterprets the bits of a value of one type as another type.\n@@ -1250,6 +1373,7 @@ extern \"rust-intrinsic\" {\n     #[rustc_allowed_through_unstable_modules]\n     #[rustc_const_stable(feature = \"const_transmute\", since = \"1.56.0\")]\n     #[rustc_diagnostic_item = \"transmute\"]\n+    #[rustc_nounwind]\n     pub fn transmute<Src, Dst>(src: Src) -> Dst;\n \n     /// Returns `true` if the actual type given as `T` requires drop\n@@ -1267,6 +1391,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`mem::needs_drop`](crate::mem::needs_drop).\n     #[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn needs_drop<T: ?Sized>() -> bool;\n \n     /// Calculates the offset from a pointer.\n@@ -1284,6 +1409,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`pointer::offset`].\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n+    #[rustc_nounwind]\n     pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Calculates the offset from a pointer, potentially wrapping.\n@@ -1301,6 +1427,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`pointer::wrapping_offset`].\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n+    #[rustc_nounwind]\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Masks out bits of the pointer according to a mask.\n@@ -1312,6 +1439,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Consider using [`pointer::mask`] instead.\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ptr_mask<T>(ptr: *const T, mask: usize) -> *const T;\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n@@ -1322,6 +1450,7 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count * size_of::<T>()` and an alignment of\n@@ -1331,6 +1460,7 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count * size_of::<T>()` and an alignment of\n@@ -1340,158 +1470,187 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Performs a volatile load from the `src` pointer.\n     ///\n     /// The stabilized version of this intrinsic is [`core::ptr::read_volatile`].\n+    #[rustc_nounwind]\n     pub fn volatile_load<T>(src: *const T) -> T;\n     /// Performs a volatile store to the `dst` pointer.\n     ///\n     /// The stabilized version of this intrinsic is [`core::ptr::write_volatile`].\n+    #[rustc_nounwind]\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n     /// Performs a volatile load from the `src` pointer\n     /// The pointer is not required to be aligned.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n     /// Performs a volatile store to the `dst` pointer.\n     /// The pointer is not required to be aligned.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n \n     /// Returns the square root of an `f32`\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::sqrt`](../../std/primitive.f32.html#method.sqrt)\n+    #[rustc_nounwind]\n     pub fn sqrtf32(x: f32) -> f32;\n     /// Returns the square root of an `f64`\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::sqrt`](../../std/primitive.f64.html#method.sqrt)\n+    #[rustc_nounwind]\n     pub fn sqrtf64(x: f64) -> f64;\n \n     /// Raises an `f32` to an integer power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::powi`](../../std/primitive.f32.html#method.powi)\n+    #[rustc_nounwind]\n     pub fn powif32(a: f32, x: i32) -> f32;\n     /// Raises an `f64` to an integer power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::powi`](../../std/primitive.f64.html#method.powi)\n+    #[rustc_nounwind]\n     pub fn powif64(a: f64, x: i32) -> f64;\n \n     /// Returns the sine of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::sin`](../../std/primitive.f32.html#method.sin)\n+    #[rustc_nounwind]\n     pub fn sinf32(x: f32) -> f32;\n     /// Returns the sine of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::sin`](../../std/primitive.f64.html#method.sin)\n+    #[rustc_nounwind]\n     pub fn sinf64(x: f64) -> f64;\n \n     /// Returns the cosine of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::cos`](../../std/primitive.f32.html#method.cos)\n+    #[rustc_nounwind]\n     pub fn cosf32(x: f32) -> f32;\n     /// Returns the cosine of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::cos`](../../std/primitive.f64.html#method.cos)\n+    #[rustc_nounwind]\n     pub fn cosf64(x: f64) -> f64;\n \n     /// Raises an `f32` to an `f32` power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::powf`](../../std/primitive.f32.html#method.powf)\n+    #[rustc_nounwind]\n     pub fn powf32(a: f32, x: f32) -> f32;\n     /// Raises an `f64` to an `f64` power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::powf`](../../std/primitive.f64.html#method.powf)\n+    #[rustc_nounwind]\n     pub fn powf64(a: f64, x: f64) -> f64;\n \n     /// Returns the exponential of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::exp`](../../std/primitive.f32.html#method.exp)\n+    #[rustc_nounwind]\n     pub fn expf32(x: f32) -> f32;\n     /// Returns the exponential of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::exp`](../../std/primitive.f64.html#method.exp)\n+    #[rustc_nounwind]\n     pub fn expf64(x: f64) -> f64;\n \n     /// Returns 2 raised to the power of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::exp2`](../../std/primitive.f32.html#method.exp2)\n+    #[rustc_nounwind]\n     pub fn exp2f32(x: f32) -> f32;\n     /// Returns 2 raised to the power of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::exp2`](../../std/primitive.f64.html#method.exp2)\n+    #[rustc_nounwind]\n     pub fn exp2f64(x: f64) -> f64;\n \n     /// Returns the natural logarithm of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::ln`](../../std/primitive.f32.html#method.ln)\n+    #[rustc_nounwind]\n     pub fn logf32(x: f32) -> f32;\n     /// Returns the natural logarithm of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::ln`](../../std/primitive.f64.html#method.ln)\n+    #[rustc_nounwind]\n     pub fn logf64(x: f64) -> f64;\n \n     /// Returns the base 10 logarithm of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::log10`](../../std/primitive.f32.html#method.log10)\n+    #[rustc_nounwind]\n     pub fn log10f32(x: f32) -> f32;\n     /// Returns the base 10 logarithm of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::log10`](../../std/primitive.f64.html#method.log10)\n+    #[rustc_nounwind]\n     pub fn log10f64(x: f64) -> f64;\n \n     /// Returns the base 2 logarithm of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::log2`](../../std/primitive.f32.html#method.log2)\n+    #[rustc_nounwind]\n     pub fn log2f32(x: f32) -> f32;\n     /// Returns the base 2 logarithm of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::log2`](../../std/primitive.f64.html#method.log2)\n+    #[rustc_nounwind]\n     pub fn log2f64(x: f64) -> f64;\n \n     /// Returns `a * b + c` for `f32` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::mul_add`](../../std/primitive.f32.html#method.mul_add)\n+    #[rustc_nounwind]\n     pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;\n     /// Returns `a * b + c` for `f64` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::mul_add`](../../std/primitive.f64.html#method.mul_add)\n+    #[rustc_nounwind]\n     pub fn fmaf64(a: f64, b: f64, c: f64) -> f64;\n \n     /// Returns the absolute value of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::abs`](../../std/primitive.f32.html#method.abs)\n+    #[rustc_nounwind]\n     pub fn fabsf32(x: f32) -> f32;\n     /// Returns the absolute value of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::abs`](../../std/primitive.f64.html#method.abs)\n+    #[rustc_nounwind]\n     pub fn fabsf64(x: f64) -> f64;\n \n     /// Returns the minimum of two `f32` values.\n@@ -1504,6 +1663,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f32::min`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn minnumf32(x: f32, y: f32) -> f32;\n     /// Returns the minimum of two `f64` values.\n     ///\n@@ -1515,6 +1675,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f64::min`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn minnumf64(x: f64, y: f64) -> f64;\n     /// Returns the maximum of two `f32` values.\n     ///\n@@ -1526,6 +1687,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f32::max`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn maxnumf32(x: f32, y: f32) -> f32;\n     /// Returns the maximum of two `f64` values.\n     ///\n@@ -1537,132 +1699,155 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f64::max`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn maxnumf64(x: f64, y: f64) -> f64;\n \n     /// Copies the sign from `y` to `x` for `f32` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::copysign`](../../std/primitive.f32.html#method.copysign)\n+    #[rustc_nounwind]\n     pub fn copysignf32(x: f32, y: f32) -> f32;\n     /// Copies the sign from `y` to `x` for `f64` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::copysign`](../../std/primitive.f64.html#method.copysign)\n+    #[rustc_nounwind]\n     pub fn copysignf64(x: f64, y: f64) -> f64;\n \n     /// Returns the largest integer less than or equal to an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::floor`](../../std/primitive.f32.html#method.floor)\n+    #[rustc_nounwind]\n     pub fn floorf32(x: f32) -> f32;\n     /// Returns the largest integer less than or equal to an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::floor`](../../std/primitive.f64.html#method.floor)\n+    #[rustc_nounwind]\n     pub fn floorf64(x: f64) -> f64;\n \n     /// Returns the smallest integer greater than or equal to an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::ceil`](../../std/primitive.f32.html#method.ceil)\n+    #[rustc_nounwind]\n     pub fn ceilf32(x: f32) -> f32;\n     /// Returns the smallest integer greater than or equal to an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::ceil`](../../std/primitive.f64.html#method.ceil)\n+    #[rustc_nounwind]\n     pub fn ceilf64(x: f64) -> f64;\n \n     /// Returns the integer part of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::trunc`](../../std/primitive.f32.html#method.trunc)\n+    #[rustc_nounwind]\n     pub fn truncf32(x: f32) -> f32;\n     /// Returns the integer part of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::trunc`](../../std/primitive.f64.html#method.trunc)\n+    #[rustc_nounwind]\n     pub fn truncf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. May raise an inexact floating-point exception\n     /// if the argument is not an integer.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::round_ties_even`](../../std/primitive.f32.html#method.round_ties_even)\n+    #[rustc_nounwind]\n     pub fn rintf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`. May raise an inexact floating-point exception\n     /// if the argument is not an integer.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::round_ties_even`](../../std/primitive.f64.html#method.round_ties_even)\n+    #[rustc_nounwind]\n     pub fn rintf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn nearbyintf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn nearbyintf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. Rounds half-way cases away from zero.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::round`](../../std/primitive.f32.html#method.round)\n+    #[rustc_nounwind]\n     pub fn roundf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`. Rounds half-way cases away from zero.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::round`](../../std/primitive.f64.html#method.round)\n+    #[rustc_nounwind]\n     pub fn roundf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. Rounds half-way cases to the number\n     /// with an even least significant digit.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[cfg(not(bootstrap))]\n+    #[rustc_nounwind]\n     pub fn roundevenf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`. Rounds half-way cases to the number\n     /// with an even least significant digit.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[cfg(not(bootstrap))]\n+    #[rustc_nounwind]\n     pub fn roundevenf64(x: f64) -> f64;\n \n     /// Float addition that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fadd_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float subtraction that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fsub_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float multiplication that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fmul_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float division that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fdiv_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float remainder that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn frem_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n     /// (<https://github.com/rust-lang/rust/issues/10184>)\n     ///\n     /// Stabilized as [`f32::to_int_unchecked`] and [`f64::to_int_unchecked`].\n+    #[rustc_nounwind]\n     pub fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n \n     /// Returns the number of bits set in an integer type `T`\n@@ -1677,6 +1862,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::count_ones`]\n     #[rustc_const_stable(feature = \"const_ctpop\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ctpop<T: Copy>(x: T) -> T;\n \n     /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n@@ -1715,6 +1901,7 @@ extern \"rust-intrinsic\" {\n     /// ```\n     #[rustc_const_stable(feature = \"const_ctlz\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ctlz<T: Copy>(x: T) -> T;\n \n     /// Like `ctlz`, but extra-unsafe as it returns `undef` when\n@@ -1734,6 +1921,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_leading, 3);\n     /// ```\n     #[rustc_const_stable(feature = \"constctlz\", since = \"1.50.0\")]\n+    #[rustc_nounwind]\n     pub fn ctlz_nonzero<T: Copy>(x: T) -> T;\n \n     /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n@@ -1772,6 +1960,7 @@ extern \"rust-intrinsic\" {\n     /// ```\n     #[rustc_const_stable(feature = \"const_cttz\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn cttz<T: Copy>(x: T) -> T;\n \n     /// Like `cttz`, but extra-unsafe as it returns `undef` when\n@@ -1791,6 +1980,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_trailing, 3);\n     /// ```\n     #[rustc_const_stable(feature = \"const_cttz_nonzero\", since = \"1.53.0\")]\n+    #[rustc_nounwind]\n     pub fn cttz_nonzero<T: Copy>(x: T) -> T;\n \n     /// Reverses the bytes in an integer type `T`.\n@@ -1805,6 +1995,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::swap_bytes`]\n     #[rustc_const_stable(feature = \"const_bswap\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn bswap<T: Copy>(x: T) -> T;\n \n     /// Reverses the bits in an integer type `T`.\n@@ -1819,6 +2010,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::reverse_bits`]\n     #[rustc_const_stable(feature = \"const_bitreverse\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn bitreverse<T: Copy>(x: T) -> T;\n \n     /// Performs checked integer addition.\n@@ -1833,6 +2025,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::overflowing_add`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn add_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer subtraction\n@@ -1847,6 +2040,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::overflowing_sub`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn sub_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer multiplication\n@@ -1861,13 +2055,15 @@ extern \"rust-intrinsic\" {\n     /// [`u32::overflowing_mul`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn mul_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs an exact division, resulting in undefined behavior where\n     /// `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_exact_div\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn exact_div<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked division, resulting in undefined behavior\n@@ -1877,6 +2073,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_div` method. For example,\n     /// [`u32::checked_div`]\n     #[rustc_const_stable(feature = \"const_int_unchecked_div\", since = \"1.52.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior when `y == 0` or `x == T::MIN && y == -1`\n@@ -1885,6 +2082,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_rem` method. For example,\n     /// [`u32::checked_rem`]\n     #[rustc_const_stable(feature = \"const_int_unchecked_rem\", since = \"1.52.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_rem<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked left shift, resulting in undefined behavior when\n@@ -1894,6 +2092,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_shl` method. For example,\n     /// [`u32::checked_shl`]\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_shl<T: Copy>(x: T, y: T) -> T;\n     /// Performs an unchecked right shift, resulting in undefined behavior when\n     /// `y < 0` or `y >= N`, where N is the width of T in bits.\n@@ -1902,27 +2101,31 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_shr` method. For example,\n     /// [`u32::checked_shr`]\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_shr<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked addition, resulting in\n     /// undefined behavior when `x + y > T::MAX` or `x + y < T::MIN`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_add<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked subtraction, resulting in\n     /// undefined behavior when `x - y > T::MAX` or `x - y < T::MIN`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_sub<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked multiplication, resulting in\n     /// undefined behavior when `x * y > T::MAX` or `x * y < T::MIN`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_mul<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate left.\n@@ -1937,6 +2140,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::rotate_left`]\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn rotate_left<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate right.\n@@ -1951,6 +2155,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::rotate_right`]\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn rotate_right<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n@@ -1965,6 +2170,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::wrapping_add`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn wrapping_add<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n@@ -1978,6 +2184,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::wrapping_sub`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn wrapping_sub<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n@@ -1991,6 +2198,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::wrapping_mul`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn wrapping_mul<T: Copy>(a: T, b: T) -> T;\n \n     /// Computes `a + b`, saturating at numeric bounds.\n@@ -2005,6 +2213,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::saturating_add`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn saturating_add<T: Copy>(a: T, b: T) -> T;\n     /// Computes `a - b`, saturating at numeric bounds.\n     ///\n@@ -2018,6 +2227,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::saturating_sub`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn saturating_sub<T: Copy>(a: T, b: T) -> T;\n \n     /// This is an implementation detail of [`crate::ptr::read`] and should\n@@ -2028,6 +2238,7 @@ extern \"rust-intrinsic\" {\n     /// trivially obeys runtime-MIR rules about derefs in operands.\n     #[cfg(not(bootstrap))]\n     #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+    #[rustc_nounwind]\n     pub fn read_via_copy<T>(p: *const T) -> T;\n \n     /// Returns the value of the discriminant for the variant in 'v';\n@@ -2041,6 +2252,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::mem::discriminant`].\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n \n     /// Returns the number of variants of the type `T` cast to a `usize`;\n@@ -2054,6 +2266,7 @@ extern \"rust-intrinsic\" {\n     /// The to-be-stabilized version of this intrinsic is [`mem::variant_count`].\n     #[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn variant_count<T>() -> usize;\n \n     /// Rust's \"try catch\" construct which invokes the function pointer `try_fn`\n@@ -2063,18 +2276,24 @@ extern \"rust-intrinsic\" {\n     /// takes the data pointer and a pointer to the target-specific exception\n     /// object that was caught. For more information see the compiler's\n     /// source as well as std's catch implementation.\n+    ///\n+    /// `catch_fn` must not unwind.\n+    #[rustc_nounwind]\n     pub fn r#try(try_fn: fn(*mut u8), data: *mut u8, catch_fn: fn(*mut u8, *mut u8)) -> i32;\n \n     /// Emits a `!nontemporal` store according to LLVM (see their docs).\n     /// Probably will never become stable.\n+    #[rustc_nounwind]\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n \n     /// See documentation of `<*const T>::offset_from` for details.\n     #[rustc_const_stable(feature = \"const_ptr_offset_from\", since = \"1.65.0\")]\n+    #[rustc_nounwind]\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n     /// See documentation of `<*const T>::sub_ptr` for details.\n     #[rustc_const_unstable(feature = \"const_ptr_sub_ptr\", issue = \"95892\")]\n+    #[rustc_nounwind]\n     pub fn ptr_offset_from_unsigned<T>(ptr: *const T, base: *const T) -> usize;\n \n     /// See documentation of `<*const T>::guaranteed_eq` for details.\n@@ -2088,6 +2307,7 @@ extern \"rust-intrinsic\" {\n     /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ptr_guaranteed_cmp<T>(ptr: *const T, other: *const T) -> u8;\n \n     /// Allocates a block of memory at compile time.\n@@ -2099,6 +2319,7 @@ extern \"rust-intrinsic\" {\n     ///    - At compile time, a compile error occurs if this constraint is violated.\n     ///    - At runtime, it is not checked.\n     #[rustc_const_unstable(feature = \"const_heap\", issue = \"79597\")]\n+    #[rustc_nounwind]\n     pub fn const_allocate(size: usize, align: usize) -> *mut u8;\n \n     /// Deallocates a memory which allocated by `intrinsics::const_allocate` at compile time.\n@@ -2112,6 +2333,7 @@ extern \"rust-intrinsic\" {\n     /// - If the `ptr` is created in an another const, this intrinsic doesn't deallocate it.\n     /// - If the `ptr` is pointing to a local variable, this intrinsic doesn't deallocate it.\n     #[rustc_const_unstable(feature = \"const_heap\", issue = \"79597\")]\n+    #[rustc_nounwind]\n     pub fn const_deallocate(ptr: *mut u8, size: usize, align: usize);\n \n     /// Determines whether the raw bytes of the two values are equal.\n@@ -2136,21 +2358,25 @@ extern \"rust-intrinsic\" {\n     /// (The implementation is allowed to branch on the results of comparisons,\n     /// which is UB if any of their inputs are `undef`.)\n     #[rustc_const_unstable(feature = \"const_intrinsic_raw_eq\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn raw_eq<T>(a: &T, b: &T) -> bool;\n \n     /// See documentation of [`std::hint::black_box`] for details.\n     ///\n     /// [`std::hint::black_box`]: crate::hint::black_box\n     #[rustc_const_unstable(feature = \"const_black_box\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn black_box<T>(dummy: T) -> T;\n \n     /// `ptr` must point to a vtable.\n     /// The intrinsic will return the size stored in that vtable.\n+    #[rustc_nounwind]\n     pub fn vtable_size(ptr: *const ()) -> usize;\n \n     /// `ptr` must point to a vtable.\n     /// The intrinsic will return the alignment stored in that vtable.\n+    #[rustc_nounwind]\n     pub fn vtable_align(ptr: *const ()) -> usize;\n \n     /// Selects which function to call depending on the context.\n@@ -2215,10 +2441,11 @@ extern \"rust-intrinsic\" {\n         G: FnOnce<ARG, Output = RET>,\n         F: FnOnce<ARG, Output = RET>;\n \n-    #[cfg(not(bootstrap))]\n     /// This method creates a pointer to any `Some` value. If the argument is\n     /// `None`, an invalid within-bounds pointer (that is still acceptable for\n     /// constructing an empty slice) is returned.\n+    #[cfg(not(bootstrap))]\n+    #[rustc_nounwind]\n     pub fn option_payload_ptr<T>(arg: *const Option<T>) -> *const T;\n }\n \n@@ -2392,6 +2619,7 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n+        #[rustc_nounwind]\n         pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n@@ -2482,6 +2710,7 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n+        #[rustc_nounwind]\n         fn copy<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n@@ -2554,6 +2783,7 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n+        #[rustc_nounwind]\n         fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n     }\n "}, {"sha": "3cd4f5104ce71ce5bdbdfedbe2b158d4410b2bbf", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -823,7 +823,7 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// [`pin` module]: crate::pin\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n #[rustc_on_unimplemented(\n-    note = \"consider using `Box::pin`\",\n+    note = \"consider using the `pin!` macro\\nconsider using `Box::pin` if you need to access the pinned value outside of the current scope\",\n     message = \"`{Self}` cannot be unpinned\"\n )]\n #[lang = \"unpin\"]"}, {"sha": "818f1a919d0d5f2c3602dd7ccd7217680370a708", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -1371,6 +1371,7 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n     // as `intrinsics::copy_nonoverlapping` is a wrapper function.\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n+        #[rustc_nounwind]\n         fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n "}, {"sha": "a46a29cbad6081400329485378ea87808bbc2512", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -498,6 +498,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     // This function cannot be marked as `unsafe` because `intrinsics::r#try`\n     // expects normal function pointers.\n     #[inline]\n+    #[rustc_nounwind] // `intrinsic::r#try` requires catch fn to be nounwind\n     fn do_catch<F: FnOnce() -> R, R>(data: *mut u8, payload: *mut u8) {\n         // SAFETY: this is the responsibility of the caller, see above.\n         //"}, {"sha": "94e71b89b5c86bed8324536c7baca427734670dd", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -895,6 +895,8 @@ impl Step for Src {\n \n     /// Creates the `rust-src` installer component\n     fn run(self, builder: &Builder<'_>) -> GeneratedTarball {\n+        builder.update_submodule(&Path::new(\"src/llvm-project\"));\n+\n         let tarball = Tarball::new_targetless(builder, \"rust-src\");\n \n         // A lot of tools expect the rust-src component to be entirely in this directory, so if you"}, {"sha": "a893c3a47c9fd2453dbcc7fc4557188c11d35c70", "filename": "src/bootstrap/llvm.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/src%2Fbootstrap%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/src%2Fbootstrap%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fllvm.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -1087,6 +1087,8 @@ impl Step for CrtBeginEnd {\n \n     /// Build crtbegin.o/crtend.o for musl target.\n     fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        builder.update_submodule(&Path::new(\"src/llvm-project\"));\n+\n         let out_dir = builder.native_dir(self.target).join(\"crt\");\n \n         if builder.config.dry_run() {\n@@ -1153,6 +1155,8 @@ impl Step for Libunwind {\n \n     /// Build linunwind.a\n     fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        builder.update_submodule(&Path::new(\"src/llvm-project\"));\n+\n         if builder.config.dry_run() {\n             return PathBuf::new();\n         }"}, {"sha": "f50c0eb4788970b4e46b8270ab0bd8bdb065b394", "filename": "tests/mir-opt/issue_104451_unwindable_intrinsics.main.AbortUnwindingCalls.after.mir", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Fissue_104451_unwindable_intrinsics.main.AbortUnwindingCalls.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Fissue_104451_unwindable_intrinsics.main.AbortUnwindingCalls.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_104451_unwindable_intrinsics.main.AbortUnwindingCalls.after.mir?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -0,0 +1,25 @@\n+// MIR for `main` after AbortUnwindingCalls\n+\n+fn main() -> () {\n+    let mut _0: ();                      // return place in scope 0 at $DIR/issue_104451_unwindable_intrinsics.rs:+0:11: +0:11\n+    let mut _1: !;                       // in scope 0 at $DIR/issue_104451_unwindable_intrinsics.rs:+2:9: +2:62\n+    let mut _2: ();                      // in scope 0 at $DIR/issue_104451_unwindable_intrinsics.rs:+2:45: +2:47\n+    scope 1 {\n+    }\n+\n+    bb0: {\n+        StorageLive(_1);                 // scope 1 at $DIR/issue_104451_unwindable_intrinsics.rs:+2:9: +2:62\n+        StorageLive(_2);                 // scope 1 at $DIR/issue_104451_unwindable_intrinsics.rs:+2:45: +2:47\n+        _2 = ();                         // scope 1 at $DIR/issue_104451_unwindable_intrinsics.rs:+2:45: +2:47\n+        _1 = const_eval_select::<(), fn() -> ! {ow_ct}, fn() -> ! {ow_ct}, !>(move _2, ow_ct, ow_ct); // scope 1 at $DIR/issue_104451_unwindable_intrinsics.rs:+2:9: +2:62\n+                                         // mir::Constant\n+                                         // + span: $DIR/issue_104451_unwindable_intrinsics.rs:8:9: 8:44\n+                                         // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn((), fn() -> ! {ow_ct}, fn() -> ! {ow_ct}) -> ! {const_eval_select::<(), fn() -> ! {ow_ct}, fn() -> ! {ow_ct}, !>}, val: Value(<ZST>) }\n+                                         // mir::Constant\n+                                         // + span: $DIR/issue_104451_unwindable_intrinsics.rs:8:49: 8:54\n+                                         // + literal: Const { ty: fn() -> ! {ow_ct}, val: Value(<ZST>) }\n+                                         // mir::Constant\n+                                         // + span: $DIR/issue_104451_unwindable_intrinsics.rs:8:56: 8:61\n+                                         // + literal: Const { ty: fn() -> ! {ow_ct}, val: Value(<ZST>) }\n+    }\n+}"}, {"sha": "9babd4aaed512c9ba4fa837a2500bc31abd1693c", "filename": "tests/mir-opt/issue_104451_unwindable_intrinsics.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Fissue_104451_unwindable_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Fissue_104451_unwindable_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_104451_unwindable_intrinsics.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -0,0 +1,14 @@\n+// Check that `UnwindAction::Unreachable` is not generated for unwindable intrinsics.\n+// ignore-wasm32 compiled with panic=abort by default\n+#![feature(core_intrinsics)]\n+\n+// EMIT_MIR issue_104451_unwindable_intrinsics.main.AbortUnwindingCalls.after.mir\n+fn main() {\n+    unsafe {\n+        core::intrinsics::const_eval_select((), ow_ct, ow_ct)\n+    }\n+}\n+\n+const fn ow_ct() -> ! {\n+    panic!();\n+}"}, {"sha": "e95c3f9bcc707ca1e7a03b05182754e1c1c0469b", "filename": "tests/mir-opt/lower_intrinsics.assume.LowerIntrinsics.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Flower_intrinsics.assume.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Flower_intrinsics.assume.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.assume.LowerIntrinsics.diff?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -11,7 +11,7 @@\n           StorageLive(_1);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:38\n -         _1 = std::intrinsics::assume(const true) -> [return: bb1, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:38\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:105:9: 105:32\n+-                                          // + span: $DIR/lower_intrinsics.rs:106:9: 106:32\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(bool) {std::intrinsics::assume}, val: Value(<ZST>) }\n +         assume(const true);              // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:38\n +         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:9: +2:38"}, {"sha": "a54e9a9320ee18967df8fb4e212b65d178593dba", "filename": "tests/mir-opt/lower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Flower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Flower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.f_copy_nonoverlapping.LowerIntrinsics.diff?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -49,7 +49,7 @@\n           StorageDead(_9);                 // scope 3 at $DIR/lower_intrinsics.rs:+4:90: +4:91\n -         _3 = copy_nonoverlapping::<i32>(move _4, move _8, const 0_usize) -> [return: bb1, unwind unreachable]; // scope 3 at $DIR/lower_intrinsics.rs:+4:9: +4:95\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:98:9: 98:28\n+-                                          // + span: $DIR/lower_intrinsics.rs:99:9: 99:28\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const i32, *mut i32, usize) {copy_nonoverlapping::<i32>}, val: Value(<ZST>) }\n +         copy_nonoverlapping(dst = move _8, src = move _4, count = const 0_usize); // scope 3 at $DIR/lower_intrinsics.rs:+4:9: +4:95\n +         goto -> bb1;                     // scope 3 at $DIR/lower_intrinsics.rs:+4:9: +4:95"}, {"sha": "cc5079af7f45d6263f4885dfa3e86198a206cc6c", "filename": "tests/mir-opt/lower_intrinsics.option_payload.LowerIntrinsics.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -24,7 +24,7 @@\n           _4 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+2:55: +2:56\n -         _3 = option_payload_ptr::<usize>(move _4) -> [return: bb1, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:132:18: 132:54\n+-                                          // + span: $DIR/lower_intrinsics.rs:133:18: 133:54\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<usize>) -> *const usize {option_payload_ptr::<usize>}, val: Value(<ZST>) }\n +         _3 = &raw const (((*_4) as Some).0: usize); // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n +         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n@@ -37,7 +37,7 @@\n           _6 = &raw const (*_2);           // scope 2 at $DIR/lower_intrinsics.rs:+3:55: +3:56\n -         _5 = option_payload_ptr::<String>(move _6) -> [return: bb2, unwind unreachable]; // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:133:18: 133:54\n+-                                          // + span: $DIR/lower_intrinsics.rs:134:18: 134:54\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<String>) -> *const String {option_payload_ptr::<String>}, val: Value(<ZST>) }\n +         _5 = &raw const (((*_6) as Some).0: std::string::String); // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n +         goto -> bb2;                     // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57"}, {"sha": "5805df48f544f4c3d2f5ab5753f0c8db5e287608", "filename": "tests/mir-opt/lower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_primitive.LowerIntrinsics.diff?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -13,7 +13,7 @@\n           _2 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n -         _0 = read_via_copy::<i32>(move _2) -> [return: bb1, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:118:14: 118:45\n+-                                          // + span: $DIR/lower_intrinsics.rs:119:14: 119:45\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const i32) -> i32 {read_via_copy::<i32>}, val: Value(<ZST>) }\n +         _0 = (*_2);                      // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n +         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48"}, {"sha": "95b2ec49d8076bef26930caf0b3cb8ab0a1669d3", "filename": "tests/mir-opt/lower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.read_via_copy_uninhabited.LowerIntrinsics.diff?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -13,7 +13,7 @@\n           _2 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+1:46: +1:47\n -         _0 = read_via_copy::<Never>(move _2) -> unwind unreachable; // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:123:14: 123:45\n+-                                          // + span: $DIR/lower_intrinsics.rs:124:14: 124:45\n -                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Never) -> Never {read_via_copy::<Never>}, val: Value(<ZST>) }\n +         unreachable;                     // scope 1 at $DIR/lower_intrinsics.rs:+1:14: +1:48\n       }"}, {"sha": "33fef930ad34b11c6d98d276d413b8be88579bc4", "filename": "tests/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -1,7 +1,7 @@\n // unit-test: LowerIntrinsics\n // ignore-wasm32 compiled with panic=abort by default\n \n-#![feature(core_intrinsics, intrinsics)]\n+#![feature(core_intrinsics, intrinsics, rustc_attrs)]\n #![crate_type = \"lib\"]\n \n // EMIT_MIR lower_intrinsics.wrapping.LowerIntrinsics.diff\n@@ -87,6 +87,7 @@ pub fn discriminant<T>(t: T) {\n \n extern \"rust-intrinsic\" {\n     // Cannot use `std::intrinsics::copy_nonoverlapping` as that is a wrapper function\n+    #[rustc_nounwind]\n     fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n }\n "}, {"sha": "9cf4fbb88f3899a84cf319e137b224de3a472ca4", "filename": "tests/mir-opt/lower_intrinsics.with_overflow.LowerIntrinsics.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.with_overflow.LowerIntrinsics.diff?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -32,7 +32,7 @@\n           _5 = _2;                         // scope 0 at $DIR/lower_intrinsics.rs:+1:53: +1:54\n -         _3 = add_with_overflow::<i32>(move _4, move _5) -> [return: bb1, unwind unreachable]; // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:111:14: 111:49\n+-                                          // + span: $DIR/lower_intrinsics.rs:112:14: 112:49\n -                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {add_with_overflow::<i32>}, val: Value(<ZST>) }\n +         _3 = CheckedAdd(move _4, move _5); // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n +         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:55\n@@ -48,7 +48,7 @@\n           _8 = _2;                         // scope 1 at $DIR/lower_intrinsics.rs:+2:53: +2:54\n -         _6 = sub_with_overflow::<i32>(move _7, move _8) -> [return: bb2, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:112:14: 112:49\n+-                                          // + span: $DIR/lower_intrinsics.rs:113:14: 113:49\n -                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {sub_with_overflow::<i32>}, val: Value(<ZST>) }\n +         _6 = CheckedSub(move _7, move _8); // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n +         goto -> bb2;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:55\n@@ -64,7 +64,7 @@\n           _11 = _2;                        // scope 2 at $DIR/lower_intrinsics.rs:+3:53: +3:54\n -         _9 = mul_with_overflow::<i32>(move _10, move _11) -> [return: bb3, unwind unreachable]; // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55\n -                                          // mir::Constant\n--                                          // + span: $DIR/lower_intrinsics.rs:113:14: 113:49\n+-                                          // + span: $DIR/lower_intrinsics.rs:114:14: 114:49\n -                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> (i32, bool) {mul_with_overflow::<i32>}, val: Value(<ZST>) }\n +         _9 = CheckedMul(move _10, move _11); // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55\n +         goto -> bb3;                     // scope 2 at $DIR/lower_intrinsics.rs:+3:14: +3:55"}, {"sha": "76f233ab445d00dd0184e98ed740a59c47b88af8", "filename": "tests/run-make/rustdoc-verify-output-files/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Frun-make%2Frustdoc-verify-output-files%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Frun-make%2Frustdoc-verify-output-files%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Frustdoc-verify-output-files%2FMakefile?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -14,7 +14,7 @@ all:\n \t$(RUSTDOC) src/lib.rs --crate-name foobar --crate-type lib --out-dir $(OUTPUT_DIR)\n \n \t# Check if everything exactly same\n-\t$(DIFF) -r -q $(OUTPUT_DIR) $(TMP_OUTPUT_DIR)\n+\t$(DIFF) -r $(OUTPUT_DIR) $(TMP_OUTPUT_DIR)\n \n \t# Generate json doc on the same output\n \t$(RUSTDOC) src/lib.rs --crate-name foobar --crate-type lib --out-dir $(OUTPUT_DIR) -Z unstable-options --output-format json\n@@ -29,4 +29,4 @@ all:\n \t$(RUSTDOC) src/lib.rs --crate-name foobar --crate-type lib --out-dir $(OUTPUT_DIR) -Z unstable-options --output-format json\n \n \t# Check if all docs(including both json and html formats) are still the same after multiple compilations\n-\t$(DIFF) -r -q $(OUTPUT_DIR) $(TMP_OUTPUT_DIR)\n+\t$(DIFF) -r $(OUTPUT_DIR) $(TMP_OUTPUT_DIR)"}, {"sha": "7e485a314c5407e258fa2374fbc5d07a4953f8d5", "filename": "tests/ui/associated-consts/associated-const-dead-code.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fassociated-consts%2Fassociated-const-dead-code.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fassociated-consts%2Fassociated-const-dead-code.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-consts%2Fassociated-const-dead-code.stderr?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -1,6 +1,8 @@\n error: associated constant `BAR` is never used\n   --> $DIR/associated-const-dead-code.rs:6:11\n    |\n+LL | impl MyFoo {\n+   | ---------- associated constant in this implementation\n LL |     const BAR: u32 = 1;\n    |           ^^^\n    |"}, {"sha": "61126faf899261e731d3328a3492e731d7ce4e6a", "filename": "tests/ui/async-await/pin-needed-to-poll-2.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fasync-await%2Fpin-needed-to-poll-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fasync-await%2Fpin-needed-to-poll-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fasync-await%2Fpin-needed-to-poll-2.stderr?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -6,7 +6,8 @@ LL |         Pin::new(&mut self.sleep).poll(cx)\n    |         |\n    |         required by a bound introduced by this call\n    |\n-   = note: consider using `Box::pin`\n+   = note: consider using the `pin!` macro\n+           consider using `Box::pin` if you need to access the pinned value outside of the current scope\n note: required because it appears within the type `Sleep`\n   --> $DIR/pin-needed-to-poll-2.rs:8:8\n    |"}, {"sha": "7376116b3380a1e025a82245d09dff9082658a42", "filename": "tests/ui/generator/static-not-unpin.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fgenerator%2Fstatic-not-unpin.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fgenerator%2Fstatic-not-unpin.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgenerator%2Fstatic-not-unpin.stderr?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -6,7 +6,8 @@ LL |     assert_unpin(generator);\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = note: consider using `Box::pin`\n+   = note: consider using the `pin!` macro\n+           consider using `Box::pin` if you need to access the pinned value outside of the current scope\n note: required by a bound in `assert_unpin`\n   --> $DIR/static-not-unpin.rs:7:20\n    |"}, {"sha": "d75a8e2dd41a87468c8f6dd68d00560dd7a1342b", "filename": "tests/ui/lint/dead-code/issue-85255.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Flint%2Fdead-code%2Fissue-85255.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Flint%2Fdead-code%2Fissue-85255.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fdead-code%2Fissue-85255.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -11,8 +11,8 @@ struct Foo {\n struct Bar;\n \n impl Bar {\n-    fn a(&self) -> i32 { 5 } //~ WARNING: method `a` is never used\n-    pub fn b(&self) -> i32 { 6 } //~ WARNING: method `b` is never used\n+    fn a(&self) -> i32 { 5 } //~ WARNING: methods `a` and `b` are never used [dead_code]\n+    pub fn b(&self) -> i32 { 6 }\n }\n \n pub(crate) struct Foo1 {\n@@ -23,8 +23,8 @@ pub(crate) struct Foo1 {\n pub(crate) struct Bar1;\n \n impl Bar1 {\n-    fn a(&self) -> i32 { 5 } //~ WARNING: method `a` is never used\n-    pub fn b(&self) -> i32 { 6 } //~ WARNING: method `b` is never used\n+    fn a(&self) -> i32 { 5 } //~ WARNING: methods `a` and `b` are never used [dead_code]\n+    pub fn b(&self) -> i32 { 6 }\n }\n \n pub(crate) struct Foo2 {\n@@ -35,8 +35,8 @@ pub(crate) struct Foo2 {\n pub(crate) struct Bar2;\n \n impl Bar2 {\n-    fn a(&self) -> i32 { 5 } //~ WARNING: method `a` is never used\n-    pub fn b(&self) -> i32 { 6 } //~ WARNING: method `b` is never used\n+    fn a(&self) -> i32 { 5 } //~ WARNING: methods `a` and `b` are never used [dead_code]\n+    pub fn b(&self) -> i32 { 6 }\n }\n \n "}, {"sha": "d981085a4fa5daca83e7be2845334e7b0ec5f72d", "filename": "tests/ui/lint/dead-code/issue-85255.stderr", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Flint%2Fdead-code%2Fissue-85255.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Flint%2Fdead-code%2Fissue-85255.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fdead-code%2Fissue-85255.stderr?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -14,6 +14,16 @@ note: the lint level is defined here\n LL | #![warn(dead_code)]\n    |         ^^^^^^^^^\n \n+warning: methods `a` and `b` are never used\n+  --> $DIR/issue-85255.rs:14:8\n+   |\n+LL | impl Bar {\n+   | -------- methods in this implementation\n+LL |     fn a(&self) -> i32 { 5 }\n+   |        ^\n+LL |     pub fn b(&self) -> i32 { 6 }\n+   |            ^\n+\n warning: fields `a` and `b` are never read\n   --> $DIR/issue-85255.rs:19:5\n    |\n@@ -24,6 +34,16 @@ LL |     a: i32,\n LL |     pub b: i32,\n    |         ^\n \n+warning: methods `a` and `b` are never used\n+  --> $DIR/issue-85255.rs:26:8\n+   |\n+LL | impl Bar1 {\n+   | --------- methods in this implementation\n+LL |     fn a(&self) -> i32 { 5 }\n+   |        ^\n+LL |     pub fn b(&self) -> i32 { 6 }\n+   |            ^\n+\n warning: fields `a` and `b` are never read\n   --> $DIR/issue-85255.rs:31:5\n    |\n@@ -34,41 +54,15 @@ LL |     a: i32,\n LL |     pub b: i32,\n    |         ^\n \n-warning: method `a` is never used\n-  --> $DIR/issue-85255.rs:14:8\n-   |\n-LL |     fn a(&self) -> i32 { 5 }\n-   |        ^\n-\n-warning: method `b` is never used\n-  --> $DIR/issue-85255.rs:15:12\n-   |\n-LL |     pub fn b(&self) -> i32 { 6 }\n-   |            ^\n-\n-warning: method `a` is never used\n-  --> $DIR/issue-85255.rs:26:8\n-   |\n-LL |     fn a(&self) -> i32 { 5 }\n-   |        ^\n-\n-warning: method `b` is never used\n-  --> $DIR/issue-85255.rs:27:12\n-   |\n-LL |     pub fn b(&self) -> i32 { 6 }\n-   |            ^\n-\n-warning: method `a` is never used\n+warning: methods `a` and `b` are never used\n   --> $DIR/issue-85255.rs:38:8\n    |\n+LL | impl Bar2 {\n+   | --------- methods in this implementation\n LL |     fn a(&self) -> i32 { 5 }\n    |        ^\n-\n-warning: method `b` is never used\n-  --> $DIR/issue-85255.rs:39:12\n-   |\n LL |     pub fn b(&self) -> i32 { 6 }\n    |            ^\n \n-warning: 9 warnings emitted\n+warning: 6 warnings emitted\n "}, {"sha": "5c68cf0e18b67011e4821b5c455cb561aa8a3651", "filename": "tests/ui/lint/dead-code/lint-dead-code-3.stderr", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fdead-code%2Flint-dead-code-3.stderr?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -10,6 +10,14 @@ note: the lint level is defined here\n LL | #![deny(dead_code)]\n    |         ^^^^^^^^^\n \n+error: method `foo` is never used\n+  --> $DIR/lint-dead-code-3.rs:16:8\n+   |\n+LL | impl Foo {\n+   | -------- method in this implementation\n+LL |     fn foo(&self) {\n+   |        ^^^\n+\n error: function `bar` is never used\n   --> $DIR/lint-dead-code-3.rs:21:4\n    |\n@@ -34,12 +42,6 @@ error: function `blah` is never used\n LL |         fn blah() {}\n    |            ^^^^\n \n-error: method `foo` is never used\n-  --> $DIR/lint-dead-code-3.rs:16:8\n-   |\n-LL |     fn foo(&self) {\n-   |        ^^^\n-\n error: function `free` is never used\n   --> $DIR/lint-dead-code-3.rs:62:8\n    |"}, {"sha": "5b2b76b76ecd4ef78406f538c1ff05bb34a21d79", "filename": "tests/ui/lint/dead-code/lint-dead-code-6.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Flint%2Fdead-code%2Flint-dead-code-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Flint%2Fdead-code%2Flint-dead-code-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fdead-code%2Flint-dead-code-6.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -2,17 +2,16 @@\n \n struct UnusedStruct; //~ ERROR struct `UnusedStruct` is never constructed\n impl UnusedStruct {\n-    fn unused_impl_fn_1() { //~ ERROR associated function `unused_impl_fn_1` is never used\n+    fn unused_impl_fn_1() {\n+        //~^ ERROR associated functions `unused_impl_fn_1`, `unused_impl_fn_2`, and `unused_impl_fn_3` are never used [dead_code]\n         println!(\"blah\");\n     }\n \n-    fn unused_impl_fn_2(var: i32) { //~ ERROR associated function `unused_impl_fn_2` is never used\n+    fn unused_impl_fn_2(var: i32) {\n         println!(\"foo {}\", var);\n     }\n \n-    fn unused_impl_fn_3( //~ ERROR associated function `unused_impl_fn_3` is never used\n-        var: i32,\n-    ) {\n+    fn unused_impl_fn_3(var: i32) {\n         println!(\"bar {}\", var);\n     }\n }"}, {"sha": "ce41100866ad9430cec5771fe764a9a516dd750f", "filename": "tests/ui/lint/dead-code/lint-dead-code-6.stderr", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Flint%2Fdead-code%2Flint-dead-code-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Flint%2Fdead-code%2Flint-dead-code-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fdead-code%2Flint-dead-code-6.stderr?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -10,23 +10,19 @@ note: the lint level is defined here\n LL | #![deny(dead_code)]\n    |         ^^^^^^^^^\n \n-error: associated function `unused_impl_fn_1` is never used\n+error: associated functions `unused_impl_fn_1`, `unused_impl_fn_2`, and `unused_impl_fn_3` are never used\n   --> $DIR/lint-dead-code-6.rs:5:8\n    |\n+LL | impl UnusedStruct {\n+   | ----------------- associated functions in this implementation\n LL |     fn unused_impl_fn_1() {\n    |        ^^^^^^^^^^^^^^^^\n-\n-error: associated function `unused_impl_fn_2` is never used\n-  --> $DIR/lint-dead-code-6.rs:9:8\n-   |\n+...\n LL |     fn unused_impl_fn_2(var: i32) {\n    |        ^^^^^^^^^^^^^^^^\n-\n-error: associated function `unused_impl_fn_3` is never used\n-  --> $DIR/lint-dead-code-6.rs:13:8\n-   |\n-LL |     fn unused_impl_fn_3(\n+...\n+LL |     fn unused_impl_fn_3(var: i32) {\n    |        ^^^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "b111f4b9463c70ad4d6acd964d0ec33ddd96a5c2", "filename": "tests/ui/lint/dead-code/unused-assoc-fns.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Flint%2Fdead-code%2Funused-assoc-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Flint%2Fdead-code%2Funused-assoc-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fdead-code%2Funused-assoc-fns.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -0,0 +1,35 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+#![deny(unused)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn one() {}\n+    //~^ ERROR associated items `one`, `two`, `CONSTANT`, `Type`, and `three` are never used [dead_code]\n+\n+    fn two(&self) {}\n+\n+    // seperation between items\n+    // ...\n+    // ...\n+\n+    fn used() {}\n+\n+    const CONSTANT: usize = 5;\n+\n+    // more seperation\n+    // ...\n+    // ...\n+\n+    type Type = usize;\n+\n+    fn three(&self) {\n+        Foo::one();\n+        // ...\n+    }\n+}\n+\n+fn main() {\n+    Foo::used();\n+}"}, {"sha": "6344a70ea3aee9ccccfe9c9cde40dbc8eeb51a9e", "filename": "tests/ui/lint/dead-code/unused-assoc-fns.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Flint%2Fdead-code%2Funused-assoc-fns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Flint%2Fdead-code%2Funused-assoc-fns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fdead-code%2Funused-assoc-fns.stderr?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -0,0 +1,29 @@\n+error: associated items `one`, `two`, `CONSTANT`, `Type`, and `three` are never used\n+  --> $DIR/unused-assoc-fns.rs:8:8\n+   |\n+LL | impl Foo {\n+   | -------- associated items in this implementation\n+LL |     fn one() {}\n+   |        ^^^\n+...\n+LL |     fn two(&self) {}\n+   |        ^^^\n+...\n+LL |     const CONSTANT: usize = 5;\n+   |           ^^^^^^^^\n+...\n+LL |     type Type = usize;\n+   |          ^^^^\n+LL |\n+LL |     fn three(&self) {\n+   |        ^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused-assoc-fns.rs:3:9\n+   |\n+LL | #![deny(unused)]\n+   |         ^^^^^^\n+   = note: `#[deny(dead_code)]` implied by `#[deny(unused)]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "04f410b77a3b079fe687303ad84dd657c474ab73", "filename": "tests/ui/mir/checks_without_panic_impl.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fmir%2Fchecks_without_panic_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fmir%2Fchecks_without_panic_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Fchecks_without_panic_impl.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -0,0 +1,17 @@\n+// Ensures that the alignment check we insert for raw pointer dereferences\n+// does not prevent crates without a panic_impl from compiling.\n+// See rust-lang/rust#109996\n+\n+// build-pass\n+// compile-flags: -Cdebug-assertions=yes\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(lang_items)]\n+#![feature(no_core)]\n+#![no_core]\n+\n+#[lang = \"sized\"]\n+trait Foo {}\n+\n+pub unsafe fn foo(x: *const i32) -> &'static i32 { unsafe { &*x } }"}, {"sha": "0232d4c8db694b8b32a1a6b9ca2d65ba5a497405", "filename": "tests/ui/suggestions/expected-boxed-future-isnt-pinned.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -50,7 +50,8 @@ LL |     Pin::new(x)\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = note: consider using `Box::pin`\n+   = note: consider using the `pin!` macro\n+           consider using `Box::pin` if you need to access the pinned value outside of the current scope\n note: required by a bound in `Pin::<P>::new`\n   --> $SRC_DIR/core/src/pin.rs:LL:COL\n \n@@ -62,7 +63,8 @@ LL |     Pin::new(Box::new(x))\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = note: consider using `Box::pin`\n+   = note: consider using the `pin!` macro\n+           consider using `Box::pin` if you need to access the pinned value outside of the current scope\n note: required by a bound in `Pin::<P>::new`\n   --> $SRC_DIR/core/src/pin.rs:LL:COL\n "}, {"sha": "4de9da89c9bc67d90dce692008270ad2a4e11ebe", "filename": "tests/ui/suggestions/issue-84973-blacklist.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fsuggestions%2Fissue-84973-blacklist.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fsuggestions%2Fissue-84973-blacklist.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fissue-84973-blacklist.stderr?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -39,7 +39,8 @@ LL |     f_unpin(static || { yield; });\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = note: consider using `Box::pin`\n+   = note: consider using the `pin!` macro\n+           consider using `Box::pin` if you need to access the pinned value outside of the current scope\n note: required by a bound in `f_unpin`\n   --> $DIR/issue-84973-blacklist.rs:8:15\n    |"}, {"sha": "f5b96215925b71d95eb2a20d264a5f0219bbefa3", "filename": "tests/ui/suggestions/suggest-pin-macro.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fsuggestions%2Fsuggest-pin-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fsuggestions%2Fsuggest-pin-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-pin-macro.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -0,0 +1,23 @@\n+use std::pin::Pin;\n+use std::marker::PhantomPinned;\n+\n+#[derive(Debug)]\n+struct Test {\n+    _marker: PhantomPinned,\n+}\n+impl Test {\n+    fn new() -> Self {\n+        Test {\n+            _marker: PhantomPinned, // This makes our type `!Unpin`\n+        }\n+    }\n+}\n+\n+fn dummy(_: &mut Test) {}\n+\n+pub fn main() {\n+    let mut test1 = Test::new();\n+    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };\n+\n+    dummy(test1.get_mut()); //~ ERROR E0277\n+}"}, {"sha": "1220cf650cc3e585e5bd6c6b189b62ab3c2f9506", "filename": "tests/ui/suggestions/suggest-pin-macro.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fsuggestions%2Fsuggest-pin-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fsuggestions%2Fsuggest-pin-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-pin-macro.stderr?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: `PhantomPinned` cannot be unpinned\n+  --> $DIR/suggest-pin-macro.rs:22:17\n+   |\n+LL |     dummy(test1.get_mut());\n+   |                 ^^^^^^^ within `Test`, the trait `Unpin` is not implemented for `PhantomPinned`\n+   |\n+   = note: consider using the `pin!` macro\n+           consider using `Box::pin` if you need to access the pinned value outside of the current scope\n+note: required because it appears within the type `Test`\n+  --> $DIR/suggest-pin-macro.rs:5:8\n+   |\n+LL | struct Test {\n+   |        ^^^^\n+note: required by a bound in `Pin::<&'a mut T>::get_mut`\n+  --> $SRC_DIR/core/src/pin.rs:LL:COL\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8586f522291b7af93f75a4064de7b3fca124e514", "filename": "tests/ui/typeck/issue-90164.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Ftypeck%2Fissue-90164.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Ftypeck%2Fissue-90164.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-90164.stderr?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -6,7 +6,8 @@ LL |     copy(r, w);\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = note: consider using `Box::pin`\n+   = note: consider using the `pin!` macro\n+           consider using `Box::pin` if you need to access the pinned value outside of the current scope\n note: required by a bound in `copy`\n   --> $DIR/issue-90164.rs:1:12\n    |"}, {"sha": "43a8ce72ff1bca0d1f8516551bb055e52cbe4fdd", "filename": "tests/ui/wf/issue-110157.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fwf%2Fissue-110157.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fwf%2Fissue-110157.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwf%2Fissue-110157.rs?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -0,0 +1,12 @@\n+struct NeedsDropTypes<'tcx, F>(std::marker::PhantomData<&'tcx F>);\n+\n+impl<'tcx, F, I> Iterator for NeedsDropTypes<'tcx, F>\n+//~^ ERROR type annotations needed\n+where\n+    F: Fn(&Missing) -> Result<I, ()>,\n+    //~^ ERROR cannot find type `Missing` in this scope\n+    I: Iterator<Item = Missing>,\n+    //~^ ERROR cannot find type `Missing` in this scope\n+{}\n+\n+fn main() {}"}, {"sha": "91d801e9470ee7956b819f58f0c3f0ade922984f", "filename": "tests/ui/wf/issue-110157.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fwf%2Fissue-110157.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a41fc00eaf352541008965fec0dee811e44373b3/tests%2Fui%2Fwf%2Fissue-110157.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwf%2Fissue-110157.stderr?ref=a41fc00eaf352541008965fec0dee811e44373b3", "patch": "@@ -0,0 +1,32 @@\n+error[E0412]: cannot find type `Missing` in this scope\n+  --> $DIR/issue-110157.rs:6:12\n+   |\n+LL |     F: Fn(&Missing) -> Result<I, ()>,\n+   |            ^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `Missing` in this scope\n+  --> $DIR/issue-110157.rs:8:24\n+   |\n+LL |     I: Iterator<Item = Missing>,\n+   |                        ^^^^^^^ not found in this scope\n+\n+error[E0283]: type annotations needed\n+  --> $DIR/issue-110157.rs:3:31\n+   |\n+LL | impl<'tcx, F, I> Iterator for NeedsDropTypes<'tcx, F>\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for type parameter `I`\n+   |\n+   = note: cannot satisfy `_: Iterator`\n+note: required for `NeedsDropTypes<'tcx, F>` to implement `Iterator`\n+  --> $DIR/issue-110157.rs:3:18\n+   |\n+LL | impl<'tcx, F, I> Iterator for NeedsDropTypes<'tcx, F>\n+   |                  ^^^^^^^^     ^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     I: Iterator<Item = Missing>,\n+   |        ------------------------ unsatisfied trait bound introduced here\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0283, E0412.\n+For more information about an error, try `rustc --explain E0283`."}]}