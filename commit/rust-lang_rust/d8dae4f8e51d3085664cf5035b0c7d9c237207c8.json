{"sha": "d8dae4f8e51d3085664cf5035b0c7d9c237207c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ZGFlNGY4ZTUxZDMwODU2NjRjZjUwMzViMGM3ZDljMjM3MjA3Yzg=", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-08-16T19:53:40Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-09-10T20:28:11Z"}, "message": "Perform type inference in range pattern", "tree": {"sha": "1c92e5dce4d185c63c7715c46712b963635c44f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c92e5dce4d185c63c7715c46712b963635c44f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8dae4f8e51d3085664cf5035b0c7d9c237207c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8dae4f8e51d3085664cf5035b0c7d9c237207c8", "html_url": "https://github.com/rust-lang/rust/commit/d8dae4f8e51d3085664cf5035b0c7d9c237207c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8dae4f8e51d3085664cf5035b0c7d9c237207c8/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "497ee321af3b8496eaccd7af7b437f18bab81abf", "url": "https://api.github.com/repos/rust-lang/rust/commits/497ee321af3b8496eaccd7af7b437f18bab81abf", "html_url": "https://github.com/rust-lang/rust/commit/497ee321af3b8496eaccd7af7b437f18bab81abf"}], "stats": {"total": 72, "additions": 44, "deletions": 28}, "files": [{"sha": "45b630f35ccc554cfc11ea5fb174d8a8a5e82209", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d8dae4f8e51d3085664cf5035b0c7d9c237207c8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dae4f8e51d3085664cf5035b0c7d9c237207c8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=d8dae4f8e51d3085664cf5035b0c7d9c237207c8", "patch": "@@ -448,16 +448,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let calc_side = |opt_expr: Option<&'tcx hir::Expr<'tcx>>| match opt_expr {\n-            None => (None, None),\n+            None => None,\n             Some(expr) => {\n                 let ty = self.check_expr(expr);\n-                // Check that the end-point is of numeric or char type.\n-                let fail = !(ty.is_numeric() || ty.is_char() || ty.references_error());\n-                (Some(ty), Some((fail, ty, expr.span)))\n+                // Check that the end-point is possibly of numeric or char type.\n+                // The early check here is not for correctness, but rather better\n+                // diagnostics (e.g. when `&str` is being matched, `expected` will\n+                // be peeled to `str` while ty here is still `&str`, if we don't\n+                // err ealy here, a rather confusing unification error will be\n+                // emitted instead).\n+                let fail =\n+                    !(ty.is_numeric() || ty.is_char() || ty.is_ty_var() || ty.references_error());\n+                Some((fail, ty, expr.span))\n             }\n         };\n-        let (lhs_ty, lhs) = calc_side(lhs);\n-        let (rhs_ty, rhs) = calc_side(rhs);\n+        let mut lhs = calc_side(lhs);\n+        let mut rhs = calc_side(rhs);\n \n         if let (Some((true, ..)), _) | (_, Some((true, ..))) = (lhs, rhs) {\n             // There exists a side that didn't meet our criteria that the end-point\n@@ -466,25 +472,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return self.tcx.ty_error();\n         }\n \n-        // Now that we know the types can be unified we find the unified type\n-        // and use it to type the entire expression.\n-        let common_type = self.resolve_vars_if_possible(lhs_ty.or(rhs_ty).unwrap_or(expected));\n-\n+        // Unify each side with `expected`.\n         // Subtyping doesn't matter here, as the value is some kind of scalar.\n-        let demand_eqtype = |x, y| {\n-            if let Some((_, x_ty, x_span)) = x {\n+        let demand_eqtype = |x: &mut _, y| {\n+            if let Some((ref mut fail, x_ty, x_span)) = *x {\n                 if let Some(mut err) = self.demand_eqtype_pat_diag(x_span, expected, x_ty, ti) {\n                     if let Some((_, y_ty, y_span)) = y {\n                         self.endpoint_has_type(&mut err, y_span, y_ty);\n                     }\n                     err.emit();\n+                    *fail = true;\n                 };\n             }\n         };\n-        demand_eqtype(lhs, rhs);\n-        demand_eqtype(rhs, lhs);\n+        demand_eqtype(&mut lhs, rhs);\n+        demand_eqtype(&mut rhs, lhs);\n+\n+        if let (Some((true, ..)), _) | (_, Some((true, ..))) = (lhs, rhs) {\n+            return self.tcx.ty_error();\n+        }\n \n-        common_type\n+        // Find the unified type and check if it's of numeric or char type again.\n+        // This check is needed if both sides are inference variables.\n+        // We require types to be resolved here so that we emit inference failure\n+        // rather than \"_ is not a char or numeric\".\n+        let ty = self.structurally_resolved_type(span, expected);\n+        if !(ty.is_numeric() || ty.is_char() || ty.references_error()) {\n+            if let Some((ref mut fail, _, _)) = lhs {\n+                *fail = true;\n+            }\n+            if let Some((ref mut fail, _, _)) = rhs {\n+                *fail = true;\n+            }\n+            self.emit_err_pat_range(span, lhs, rhs);\n+            return self.tcx.ty_error();\n+        }\n+        ty\n     }\n \n     fn endpoint_has_type(&self, err: &mut DiagnosticBuilder<'_>, span: Span, ty: Ty<'_>) {\n@@ -511,10 +534,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             E0029,\n             \"only `char` and numeric types are allowed in range patterns\"\n         );\n-        let msg = |ty| format!(\"this is of type `{}` but it should be `char` or numeric\", ty);\n+        let msg = |ty| {\n+            let ty = self.resolve_vars_if_possible(ty);\n+            format!(\"this is of type `{}` but it should be `char` or numeric\", ty)\n+        };\n         let mut one_side_err = |first_span, first_ty, second: Option<(bool, Ty<'tcx>, Span)>| {\n             err.span_label(first_span, &msg(first_ty));\n             if let Some((_, ty, sp)) = second {\n+                let ty = self.resolve_vars_if_possible(ty);\n                 self.endpoint_has_type(&mut err, sp, ty);\n             }\n         };"}, {"sha": "7ef541cb58528d39a5eae25eb1199632f1a9d5a4", "filename": "src/test/ui/pattern/patkind-litrange-no-expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8dae4f8e51d3085664cf5035b0c7d9c237207c8/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8dae4f8e51d3085664cf5035b0c7d9c237207c8/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.rs?ref=d8dae4f8e51d3085664cf5035b0c7d9c237207c8", "patch": "@@ -19,7 +19,6 @@ enum_number!(Change {\n     Neg = -1,\n     Arith = 1 + 1, //~ ERROR arbitrary expressions aren't allowed in patterns\n                    //~| ERROR arbitrary expressions aren't allowed in patterns\n-                   //~| ERROR only `char` and numeric types are allowed in range patterns\n });\n \n fn main() {}"}, {"sha": "eb1ee7e45673d6856d2ea08af2f40e82638fa7e7", "filename": "src/test/ui/pattern/patkind-litrange-no-expr.stderr", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8dae4f8e51d3085664cf5035b0c7d9c237207c8/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d8dae4f8e51d3085664cf5035b0c7d9c237207c8/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpatkind-litrange-no-expr.stderr?ref=d8dae4f8e51d3085664cf5035b0c7d9c237207c8", "patch": "@@ -10,15 +10,5 @@ error: arbitrary expressions aren't allowed in patterns\n LL |     Arith = 1 + 1,\n    |             ^^^^^\n \n-error[E0029]: only `char` and numeric types are allowed in range patterns\n-  --> $DIR/patkind-litrange-no-expr.rs:20:13\n-   |\n-LL |                 $( $value ..= 42 => Some($name::$variant), )* // PatKind::Range\n-   |                               -- this is of type `{integer}`\n-...\n-LL |     Arith = 1 + 1,\n-   |             ^^^^^ this is of type `_` but it should be `char` or numeric\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0029`."}]}