{"sha": "de01a29fbee586a13f10ee928df7c15c5a170587", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMDFhMjlmYmVlNTg2YTEzZjEwZWU5MjhkZjdjMTVjNWExNzA1ODc=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-01-17T05:46:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-17T05:46:37Z"}, "message": "Rollup merge of #68195 - estebank:impl-trait-2000, r=Centril\n\nAccount for common `impl Trait`/`dyn Trait` return type errors\n\n- When all return paths have the same type, suggest `impl Trait`.\n- When all return paths implement the expected `trait`, suggest `Box<dyn Trait>` and mention using an `enum`.\n- When multiple different types are returned and `impl Trait` is expected, extend the explanation.\n- When return type is `impl Trait` and the return paths do not implement `Trait`, point at the returned values.\n- Split `src/librustc/traits/error_reporting.rs` into multiple files to keep size under control.\n\nFix #68110, cc #66523.", "tree": {"sha": "5df2f8765a42cd59c9d6244b56d7d18b56d8d77f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5df2f8765a42cd59c9d6244b56d7d18b56d8d77f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de01a29fbee586a13f10ee928df7c15c5a170587", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeIUo+CRBK7hj4Ov3rIwAAdHIIABMEJysNpadG/SovCvxFyhe2\n8vDC5aA+Ausg7smMVs8DM2dpRJk5+fC3GrNwY8Vn6Q2Unif4LdluAcKe3QDS8l6r\nhn71JdT472MvT75uYhNVQTIS1i4ldecwzUwbcEW/6FsNZEMCTCWJOCjZZU1+o+nw\nQ3r0zbYN0aR+KYctzprXPc7OHN0R0Tanf5yUKU19B1F3rwibyBguOa/paDroTIIr\nkhj5eaRR41IsEmZfvMUJO9WgUUzTM5j5CpWwo/g6jBb4U7xK5fmuQCeNDqOCpbtM\nUdFmxaV994EciyEnv5k0CbTJ4En7FULaFXNBLOLAnv0kB/QG6YOEPEUIZwDEKnQ=\n=m2dO\n-----END PGP SIGNATURE-----\n", "payload": "tree 5df2f8765a42cd59c9d6244b56d7d18b56d8d77f\nparent ecf42a3d624b859bcfeffc1c454ebd964eac0422\nparent 029a9c625371e756d93024efd3deb7636a90f8f8\nauthor Dylan DPC <dylan.dpc@gmail.com> 1579239997 +0530\ncommitter GitHub <noreply@github.com> 1579239997 +0530\n\nRollup merge of #68195 - estebank:impl-trait-2000, r=Centril\n\nAccount for common `impl Trait`/`dyn Trait` return type errors\n\n- When all return paths have the same type, suggest `impl Trait`.\n- When all return paths implement the expected `trait`, suggest `Box<dyn Trait>` and mention using an `enum`.\n- When multiple different types are returned and `impl Trait` is expected, extend the explanation.\n- When return type is `impl Trait` and the return paths do not implement `Trait`, point at the returned values.\n- Split `src/librustc/traits/error_reporting.rs` into multiple files to keep size under control.\n\nFix #68110, cc #66523.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de01a29fbee586a13f10ee928df7c15c5a170587", "html_url": "https://github.com/rust-lang/rust/commit/de01a29fbee586a13f10ee928df7c15c5a170587", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de01a29fbee586a13f10ee928df7c15c5a170587/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecf42a3d624b859bcfeffc1c454ebd964eac0422", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecf42a3d624b859bcfeffc1c454ebd964eac0422", "html_url": "https://github.com/rust-lang/rust/commit/ecf42a3d624b859bcfeffc1c454ebd964eac0422"}, {"sha": "029a9c625371e756d93024efd3deb7636a90f8f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/029a9c625371e756d93024efd3deb7636a90f8f8", "html_url": "https://github.com/rust-lang/rust/commit/029a9c625371e756d93024efd3deb7636a90f8f8"}], "stats": {"total": 7094, "additions": 4067, "deletions": 3027}, "files": [{"sha": "7f151af7abe502faf39c976fa86e289146864e73", "filename": "src/librustc/traits/error_reporting.rs", "status": "removed", "additions": 0, "deletions": 2991, "changes": 2991, "blob_url": "https://github.com/rust-lang/rust/blob/ecf42a3d624b859bcfeffc1c454ebd964eac0422/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecf42a3d624b859bcfeffc1c454ebd964eac0422/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ecf42a3d624b859bcfeffc1c454ebd964eac0422"}, {"sha": "db3173989ac605e114159989fa5665110fc972c2", "filename": "src/librustc/traits/error_reporting/mod.rs", "status": "added", "additions": 1412, "deletions": 0, "changes": 1412, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -0,0 +1,1412 @@\n+pub mod on_unimplemented;\n+pub mod suggestions;\n+\n+use super::{\n+    ConstEvalFailure, EvaluationResult, FulfillmentError, FulfillmentErrorCode,\n+    MismatchedProjectionTypes, ObjectSafetyViolation, Obligation, ObligationCause,\n+    ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote,\n+    OutputTypeParameterMismatch, Overflow, PredicateObligation, SelectionContext, SelectionError,\n+    TraitNotObjectSafe,\n+};\n+\n+use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n+use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::infer::{self, InferCtxt};\n+use crate::mir::interpret::ErrorHandled;\n+use crate::session::DiagnosticMessageId;\n+use crate::traits::object_safety_violations;\n+use crate::ty::error::ExpectedFound;\n+use crate::ty::fast_reject;\n+use crate::ty::fold::TypeFolder;\n+use crate::ty::SubtypePredicate;\n+use crate::ty::{self, AdtKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_span::source_map::SourceMap;\n+use rustc_span::{ExpnKind, Span, DUMMY_SP};\n+use std::fmt;\n+use syntax::ast;\n+\n+use rustc_error_codes::*;\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    pub fn report_fulfillment_errors(\n+        &self,\n+        errors: &[FulfillmentError<'tcx>],\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    ) {\n+        #[derive(Debug)]\n+        struct ErrorDescriptor<'tcx> {\n+            predicate: ty::Predicate<'tcx>,\n+            index: Option<usize>, // None if this is an old error\n+        }\n+\n+        let mut error_map: FxHashMap<_, Vec<_>> = self\n+            .reported_trait_errors\n+            .borrow()\n+            .iter()\n+            .map(|(&span, predicates)| {\n+                (\n+                    span,\n+                    predicates\n+                        .iter()\n+                        .map(|predicate| ErrorDescriptor {\n+                            predicate: predicate.clone(),\n+                            index: None,\n+                        })\n+                        .collect(),\n+                )\n+            })\n+            .collect();\n+\n+        for (index, error) in errors.iter().enumerate() {\n+            // We want to ignore desugarings here: spans are equivalent even\n+            // if one is the result of a desugaring and the other is not.\n+            let mut span = error.obligation.cause.span;\n+            let expn_data = span.ctxt().outer_expn_data();\n+            if let ExpnKind::Desugaring(_) = expn_data.kind {\n+                span = expn_data.call_site;\n+            }\n+\n+            error_map.entry(span).or_default().push(ErrorDescriptor {\n+                predicate: error.obligation.predicate.clone(),\n+                index: Some(index),\n+            });\n+\n+            self.reported_trait_errors\n+                .borrow_mut()\n+                .entry(span)\n+                .or_default()\n+                .push(error.obligation.predicate.clone());\n+        }\n+\n+        // We do this in 2 passes because we want to display errors in order, though\n+        // maybe it *is* better to sort errors by span or something.\n+        let mut is_suppressed = vec![false; errors.len()];\n+        for (_, error_set) in error_map.iter() {\n+            // We want to suppress \"duplicate\" errors with the same span.\n+            for error in error_set {\n+                if let Some(index) = error.index {\n+                    // Suppress errors that are either:\n+                    // 1) strictly implied by another error.\n+                    // 2) implied by an error with a smaller index.\n+                    for error2 in error_set {\n+                        if error2.index.map_or(false, |index2| is_suppressed[index2]) {\n+                            // Avoid errors being suppressed by already-suppressed\n+                            // errors, to prevent all errors from being suppressed\n+                            // at once.\n+                            continue;\n+                        }\n+\n+                        if self.error_implies(&error2.predicate, &error.predicate)\n+                            && !(error2.index >= error.index\n+                                && self.error_implies(&error.predicate, &error2.predicate))\n+                        {\n+                            info!(\"skipping {:?} (implied by {:?})\", error, error2);\n+                            is_suppressed[index] = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (error, suppressed) in errors.iter().zip(is_suppressed) {\n+            if !suppressed {\n+                self.report_fulfillment_error(error, body_id, fallback_has_occurred);\n+            }\n+        }\n+    }\n+\n+    // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n+    // `error` occurring implies that `cond` occurs.\n+    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool {\n+        if cond == error {\n+            return true;\n+        }\n+\n+        let (cond, error) = match (cond, error) {\n+            (&ty::Predicate::Trait(..), &ty::Predicate::Trait(ref error)) => (cond, error),\n+            _ => {\n+                // FIXME: make this work in other cases too.\n+                return false;\n+            }\n+        };\n+\n+        for implication in super::elaborate_predicates(self.tcx, vec![cond.clone()]) {\n+            if let ty::Predicate::Trait(implication) = implication {\n+                let error = error.to_poly_trait_ref();\n+                let implication = implication.to_poly_trait_ref();\n+                // FIXME: I'm just not taking associated types at all here.\n+                // Eventually I'll need to implement param-env-aware\n+                // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n+                let param_env = ty::ParamEnv::empty();\n+                if self.can_sub(param_env, error, implication).is_ok() {\n+                    debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    fn report_fulfillment_error(\n+        &self,\n+        error: &FulfillmentError<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    ) {\n+        debug!(\"report_fulfillment_error({:?})\", error);\n+        match error.code {\n+            FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n+                self.report_selection_error(\n+                    &error.obligation,\n+                    selection_error,\n+                    fallback_has_occurred,\n+                    error.points_at_arg_span,\n+                );\n+            }\n+            FulfillmentErrorCode::CodeProjectionError(ref e) => {\n+                self.report_projection_error(&error.obligation, e);\n+            }\n+            FulfillmentErrorCode::CodeAmbiguity => {\n+                self.maybe_report_ambiguity(&error.obligation, body_id);\n+            }\n+            FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n+                self.report_mismatched_types(\n+                    &error.obligation.cause,\n+                    expected_found.expected,\n+                    expected_found.found,\n+                    err.clone(),\n+                )\n+                .emit();\n+            }\n+        }\n+    }\n+\n+    fn report_projection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &MismatchedProjectionTypes<'tcx>,\n+    ) {\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+\n+        if predicate.references_error() {\n+            return;\n+        }\n+\n+        self.probe(|_| {\n+            let err_buf;\n+            let mut err = &error.err;\n+            let mut values = None;\n+\n+            // try to find the mismatched types to report the error with.\n+            //\n+            // this can fail if the problem was higher-ranked, in which\n+            // cause I have no idea for a good error message.\n+            if let ty::Predicate::Projection(ref data) = predicate {\n+                let mut selcx = SelectionContext::new(self);\n+                let (data, _) = self.replace_bound_vars_with_fresh_vars(\n+                    obligation.cause.span,\n+                    infer::LateBoundRegionConversionTime::HigherRankedType,\n+                    data,\n+                );\n+                let mut obligations = vec![];\n+                let normalized_ty = super::normalize_projection_type(\n+                    &mut selcx,\n+                    obligation.param_env,\n+                    data.projection_ty,\n+                    obligation.cause.clone(),\n+                    0,\n+                    &mut obligations,\n+                );\n+\n+                debug!(\n+                    \"report_projection_error obligation.cause={:?} obligation.param_env={:?}\",\n+                    obligation.cause, obligation.param_env\n+                );\n+\n+                debug!(\n+                    \"report_projection_error normalized_ty={:?} data.ty={:?}\",\n+                    normalized_ty, data.ty\n+                );\n+\n+                let is_normalized_ty_expected = match &obligation.cause.code {\n+                    ObligationCauseCode::ItemObligation(_)\n+                    | ObligationCauseCode::BindingObligation(_, _)\n+                    | ObligationCauseCode::ObjectCastObligation(_) => false,\n+                    _ => true,\n+                };\n+\n+                if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n+                    is_normalized_ty_expected,\n+                    normalized_ty,\n+                    data.ty,\n+                ) {\n+                    values = Some(infer::ValuePairs::Types(ExpectedFound::new(\n+                        is_normalized_ty_expected,\n+                        normalized_ty,\n+                        data.ty,\n+                    )));\n+\n+                    err_buf = error;\n+                    err = &err_buf;\n+                }\n+            }\n+\n+            let msg = format!(\"type mismatch resolving `{}`\", predicate);\n+            let error_id = (DiagnosticMessageId::ErrorId(271), Some(obligation.cause.span), msg);\n+            let fresh = self.tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n+            if fresh {\n+                let mut diag = struct_span_err!(\n+                    self.tcx.sess,\n+                    obligation.cause.span,\n+                    E0271,\n+                    \"type mismatch resolving `{}`\",\n+                    predicate\n+                );\n+                self.note_type_err(&mut diag, &obligation.cause, None, values, err);\n+                self.note_obligation_cause(&mut diag, obligation);\n+                diag.emit();\n+            }\n+        });\n+    }\n+\n+    fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+        /// returns the fuzzy category of a given type, or None\n+        /// if the type can be equated to any type.\n+        fn type_category(t: Ty<'_>) -> Option<u32> {\n+            match t.kind {\n+                ty::Bool => Some(0),\n+                ty::Char => Some(1),\n+                ty::Str => Some(2),\n+                ty::Int(..) | ty::Uint(..) | ty::Infer(ty::IntVar(..)) => Some(3),\n+                ty::Float(..) | ty::Infer(ty::FloatVar(..)) => Some(4),\n+                ty::Ref(..) | ty::RawPtr(..) => Some(5),\n+                ty::Array(..) | ty::Slice(..) => Some(6),\n+                ty::FnDef(..) | ty::FnPtr(..) => Some(7),\n+                ty::Dynamic(..) => Some(8),\n+                ty::Closure(..) => Some(9),\n+                ty::Tuple(..) => Some(10),\n+                ty::Projection(..) => Some(11),\n+                ty::Param(..) => Some(12),\n+                ty::Opaque(..) => Some(13),\n+                ty::Never => Some(14),\n+                ty::Adt(adt, ..) => match adt.adt_kind() {\n+                    AdtKind::Struct => Some(15),\n+                    AdtKind::Union => Some(16),\n+                    AdtKind::Enum => Some(17),\n+                },\n+                ty::Generator(..) => Some(18),\n+                ty::Foreign(..) => Some(19),\n+                ty::GeneratorWitness(..) => Some(20),\n+                ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => None,\n+                ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n+            }\n+        }\n+\n+        match (type_category(a), type_category(b)) {\n+            (Some(cat_a), Some(cat_b)) => match (&a.kind, &b.kind) {\n+                (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => def_a == def_b,\n+                _ => cat_a == cat_b,\n+            },\n+            // infer and error can be equated to all types\n+            _ => true,\n+        }\n+    }\n+\n+    fn describe_generator(&self, body_id: hir::BodyId) -> Option<&'static str> {\n+        self.tcx.hir().body(body_id).generator_kind.map(|gen_kind| match gen_kind {\n+            hir::GeneratorKind::Gen => \"a generator\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) => \"an async block\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn) => \"an async function\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure) => \"an async closure\",\n+        })\n+    }\n+\n+    fn find_similar_impl_candidates(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Vec<ty::TraitRef<'tcx>> {\n+        let simp = fast_reject::simplify_type(self.tcx, trait_ref.skip_binder().self_ty(), true);\n+        let all_impls = self.tcx.all_impls(trait_ref.def_id());\n+\n+        match simp {\n+            Some(simp) => all_impls\n+                .iter()\n+                .filter_map(|&def_id| {\n+                    let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+                    let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n+                    if let Some(imp_simp) = imp_simp {\n+                        if simp != imp_simp {\n+                            return None;\n+                        }\n+                    }\n+\n+                    Some(imp)\n+                })\n+                .collect(),\n+            None => {\n+                all_impls.iter().map(|&def_id| self.tcx.impl_trait_ref(def_id).unwrap()).collect()\n+            }\n+        }\n+    }\n+\n+    fn report_similar_impl_candidates(\n+        &self,\n+        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n+        if impl_candidates.is_empty() {\n+            return;\n+        }\n+\n+        let len = impl_candidates.len();\n+        let end = if impl_candidates.len() <= 5 { impl_candidates.len() } else { 4 };\n+\n+        let normalize = |candidate| {\n+            self.tcx.infer_ctxt().enter(|ref infcx| {\n+                let normalized = infcx\n+                    .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+                    .normalize(candidate)\n+                    .ok();\n+                match normalized {\n+                    Some(normalized) => format!(\"\\n  {:?}\", normalized.value),\n+                    None => format!(\"\\n  {:?}\", candidate),\n+                }\n+            })\n+        };\n+\n+        // Sort impl candidates so that ordering is consistent for UI tests.\n+        let mut normalized_impl_candidates =\n+            impl_candidates.iter().map(normalize).collect::<Vec<String>>();\n+\n+        // Sort before taking the `..end` range,\n+        // because the ordering of `impl_candidates` may not be deterministic:\n+        // https://github.com/rust-lang/rust/pull/57475#issuecomment-455519507\n+        normalized_impl_candidates.sort();\n+\n+        err.help(&format!(\n+            \"the following implementations were found:{}{}\",\n+            normalized_impl_candidates[..end].join(\"\"),\n+            if len > 5 { format!(\"\\nand {} others\", len - 4) } else { String::new() }\n+        ));\n+    }\n+\n+    /// Reports that an overflow has occurred and halts compilation. We\n+    /// halt compilation unconditionally because it is important that\n+    /// overflows never be masked -- they basically represent computations\n+    /// whose result could not be truly determined and thus we can't say\n+    /// if the program type checks or not -- and they are unusual\n+    /// occurrences in any case.\n+    pub fn report_overflow_error<T>(\n+        &self,\n+        obligation: &Obligation<'tcx, T>,\n+        suggest_increasing_limit: bool,\n+    ) -> !\n+    where\n+        T: fmt::Display + TypeFoldable<'tcx>,\n+    {\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            obligation.cause.span,\n+            E0275,\n+            \"overflow evaluating the requirement `{}`\",\n+            predicate\n+        );\n+\n+        if suggest_increasing_limit {\n+            self.suggest_new_overflow_limit(&mut err);\n+        }\n+\n+        self.note_obligation_cause_code(\n+            &mut err,\n+            &obligation.predicate,\n+            &obligation.cause.code,\n+            &mut vec![],\n+        );\n+\n+        err.emit();\n+        self.tcx.sess.abort_if_errors();\n+        bug!();\n+    }\n+\n+    /// Reports that a cycle was detected which led to overflow and halts\n+    /// compilation. This is equivalent to `report_overflow_error` except\n+    /// that we can give a more helpful error message (and, in particular,\n+    /// we do not suggest increasing the overflow limit, which is not\n+    /// going to help).\n+    pub fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n+        let cycle = self.resolve_vars_if_possible(&cycle.to_owned());\n+        assert!(cycle.len() > 0);\n+\n+        debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n+\n+        self.report_overflow_error(&cycle[0], false);\n+    }\n+\n+    pub fn report_extra_impl_obligation(\n+        &self,\n+        error_span: Span,\n+        item_name: ast::Name,\n+        _impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+        requirement: &dyn fmt::Display,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        let msg = \"impl has stricter requirements than trait\";\n+        let sp = self.tcx.sess.source_map().def_span(error_span);\n+\n+        let mut err = struct_span_err!(self.tcx.sess, sp, E0276, \"{}\", msg);\n+\n+        if let Some(trait_item_span) = self.tcx.hir().span_if_local(trait_item_def_id) {\n+            let span = self.tcx.sess.source_map().def_span(trait_item_span);\n+            err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n+        }\n+\n+        err.span_label(sp, format!(\"impl has extra requirement {}\", requirement));\n+\n+        err\n+    }\n+\n+    /// Gets the parent trait chain start\n+    fn get_parent_trait_ref(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+    ) -> Option<(String, Option<Span>)> {\n+        match code {\n+            &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                match self.get_parent_trait_ref(&data.parent_code) {\n+                    Some(t) => Some(t),\n+                    None => {\n+                        let ty = parent_trait_ref.skip_binder().self_ty();\n+                        let span =\n+                            TyCategory::from_ty(ty).map(|(_, def_id)| self.tcx.def_span(def_id));\n+                        Some((ty.to_string(), span))\n+                    }\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn report_selection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &SelectionError<'tcx>,\n+        fallback_has_occurred: bool,\n+        points_at_arg: bool,\n+    ) {\n+        let tcx = self.tcx;\n+        let span = obligation.cause.span;\n+\n+        let mut err = match *error {\n+            SelectionError::Unimplemented => {\n+                if let ObligationCauseCode::CompareImplMethodObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                }\n+                | ObligationCauseCode::CompareImplTypeObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                } = obligation.cause.code\n+                {\n+                    self.report_extra_impl_obligation(\n+                        span,\n+                        item_name,\n+                        impl_item_def_id,\n+                        trait_item_def_id,\n+                        &format!(\"`{}`\", obligation.predicate),\n+                    )\n+                    .emit();\n+                    return;\n+                }\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(ref trait_predicate) => {\n+                        let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n+\n+                        if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n+                            return;\n+                        }\n+                        let trait_ref = trait_predicate.to_poly_trait_ref();\n+                        let (post_message, pre_message, type_def) = self\n+                            .get_parent_trait_ref(&obligation.cause.code)\n+                            .map(|(t, s)| {\n+                                (\n+                                    format!(\" in `{}`\", t),\n+                                    format!(\"within `{}`, \", t),\n+                                    s.map(|s| (format!(\"within this `{}`\", t), s)),\n+                                )\n+                            })\n+                            .unwrap_or_default();\n+\n+                        let OnUnimplementedNote { message, label, note, enclosing_scope } =\n+                            self.on_unimplemented_note(trait_ref, obligation);\n+                        let have_alt_message = message.is_some() || label.is_some();\n+                        let is_try = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_to_snippet(span)\n+                            .map(|s| &s == \"?\")\n+                            .unwrap_or(false);\n+                        let is_from = format!(\"{}\", trait_ref.print_only_trait_path())\n+                            .starts_with(\"std::convert::From<\");\n+                        let (message, note) = if is_try && is_from {\n+                            (\n+                                Some(format!(\n+                                    \"`?` couldn't convert the error to `{}`\",\n+                                    trait_ref.self_ty(),\n+                                )),\n+                                Some(\n+                                    \"the question mark operation (`?`) implicitly performs a \\\n+                                     conversion on the error value using the `From` trait\"\n+                                        .to_owned(),\n+                                ),\n+                            )\n+                        } else {\n+                            (message, note)\n+                        };\n+\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0277,\n+                            \"{}\",\n+                            message.unwrap_or_else(|| format!(\n+                                \"the trait bound `{}` is not satisfied{}\",\n+                                trait_ref.to_predicate(),\n+                                post_message,\n+                            ))\n+                        );\n+\n+                        let explanation =\n+                            if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n+                                \"consider using `()`, or a `Result`\".to_owned()\n+                            } else {\n+                                format!(\n+                                    \"{}the trait `{}` is not implemented for `{}`\",\n+                                    pre_message,\n+                                    trait_ref.print_only_trait_path(),\n+                                    trait_ref.self_ty(),\n+                                )\n+                            };\n+\n+                        if self.suggest_add_reference_to_arg(\n+                            &obligation,\n+                            &mut err,\n+                            &trait_ref,\n+                            points_at_arg,\n+                            have_alt_message,\n+                        ) {\n+                            self.note_obligation_cause(&mut err, obligation);\n+                            err.emit();\n+                            return;\n+                        }\n+                        if let Some(ref s) = label {\n+                            // If it has a custom `#[rustc_on_unimplemented]`\n+                            // error message, let's display it as the label!\n+                            err.span_label(span, s.as_str());\n+                            err.help(&explanation);\n+                        } else {\n+                            err.span_label(span, explanation);\n+                        }\n+                        if let Some((msg, span)) = type_def {\n+                            err.span_label(span, &msg);\n+                        }\n+                        if let Some(ref s) = note {\n+                            // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n+                            err.note(s.as_str());\n+                        }\n+                        if let Some(ref s) = enclosing_scope {\n+                            let enclosing_scope_span = tcx.def_span(\n+                                tcx.hir()\n+                                    .opt_local_def_id(obligation.cause.body_id)\n+                                    .unwrap_or_else(|| {\n+                                        tcx.hir().body_owner_def_id(hir::BodyId {\n+                                            hir_id: obligation.cause.body_id,\n+                                        })\n+                                    }),\n+                            );\n+\n+                            err.span_label(enclosing_scope_span, s.as_str());\n+                        }\n+\n+                        self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n+                        self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n+                        self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n+                        self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n+                        self.note_version_mismatch(&mut err, &trait_ref);\n+                        if self.suggest_impl_trait(&mut err, span, &obligation, &trait_ref) {\n+                            err.emit();\n+                            return;\n+                        }\n+\n+                        // Try to report a help message\n+                        if !trait_ref.has_infer_types()\n+                            && self.predicate_can_apply(obligation.param_env, trait_ref)\n+                        {\n+                            // If a where-clause may be useful, remind the\n+                            // user that they can add it.\n+                            //\n+                            // don't display an on-unimplemented note, as\n+                            // these notes will often be of the form\n+                            //     \"the type `T` can't be frobnicated\"\n+                            // which is somewhat confusing.\n+                            self.suggest_restricting_param_bound(\n+                                &mut err,\n+                                &trait_ref,\n+                                obligation.cause.body_id,\n+                            );\n+                        } else {\n+                            if !have_alt_message {\n+                                // Can't show anything else useful, try to find similar impls.\n+                                let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n+                                self.report_similar_impl_candidates(impl_candidates, &mut err);\n+                            }\n+                            self.suggest_change_mut(\n+                                &obligation,\n+                                &mut err,\n+                                &trait_ref,\n+                                points_at_arg,\n+                            );\n+                        }\n+\n+                        // If this error is due to `!: Trait` not implemented but `(): Trait` is\n+                        // implemented, and fallback has occurred, then it could be due to a\n+                        // variable that used to fallback to `()` now falling back to `!`. Issue a\n+                        // note informing about the change in behaviour.\n+                        if trait_predicate.skip_binder().self_ty().is_never()\n+                            && fallback_has_occurred\n+                        {\n+                            let predicate = trait_predicate.map_bound(|mut trait_pred| {\n+                                trait_pred.trait_ref.substs = self.tcx.mk_substs_trait(\n+                                    self.tcx.mk_unit(),\n+                                    &trait_pred.trait_ref.substs[1..],\n+                                );\n+                                trait_pred\n+                            });\n+                            let unit_obligation = Obligation {\n+                                predicate: ty::Predicate::Trait(predicate),\n+                                ..obligation.clone()\n+                            };\n+                            if self.predicate_may_hold(&unit_obligation) {\n+                                err.note(\n+                                    \"the trait is implemented for `()`. \\\n+                                         Possibly this error has been caused by changes to \\\n+                                         Rust's type-inference algorithm \\\n+                                         (see: https://github.com/rust-lang/rust/issues/48950 \\\n+                                         for more info). Consider whether you meant to use the \\\n+                                         type `()` here instead.\",\n+                                );\n+                            }\n+                        }\n+\n+                        err\n+                    }\n+\n+                    ty::Predicate::Subtype(ref predicate) => {\n+                        // Errors for Subtype predicates show up as\n+                        // `FulfillmentErrorCode::CodeSubtypeError`,\n+                        // not selection error.\n+                        span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n+                    }\n+\n+                    ty::Predicate::RegionOutlives(ref predicate) => {\n+                        let predicate = self.resolve_vars_if_possible(predicate);\n+                        let err = self\n+                            .region_outlives_predicate(&obligation.cause, &predicate)\n+                            .err()\n+                            .unwrap();\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0279,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate,\n+                            err,\n+                        )\n+                    }\n+\n+                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0280,\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate\n+                        )\n+                    }\n+\n+                    ty::Predicate::ObjectSafe(trait_def_id) => {\n+                        let violations = object_safety_violations(self.tcx, trait_def_id);\n+                        report_object_safety_error(self.tcx, span, trait_def_id, violations)\n+                    }\n+\n+                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                        let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n+                        let closure_span = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n+                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            closure_span,\n+                            E0525,\n+                            \"expected a closure that implements the `{}` trait, \\\n+                             but this closure only implements `{}`\",\n+                            kind,\n+                            found_kind\n+                        );\n+\n+                        err.span_label(\n+                            closure_span,\n+                            format!(\"this closure implements `{}`, not `{}`\", found_kind, kind),\n+                        );\n+                        err.span_label(\n+                            obligation.cause.span,\n+                            format!(\"the requirement to implement `{}` derives from here\", kind),\n+                        );\n+\n+                        // Additional context information explaining why the closure only implements\n+                        // a particular trait.\n+                        if let Some(tables) = self.in_progress_tables {\n+                            let tables = tables.borrow();\n+                            match (found_kind, tables.closure_kind_origins().get(hir_id)) {\n+                                (ty::ClosureKind::FnOnce, Some((span, name))) => {\n+                                    err.span_label(\n+                                        *span,\n+                                        format!(\n+                                            \"closure is `FnOnce` because it moves the \\\n+                                         variable `{}` out of its environment\",\n+                                            name\n+                                        ),\n+                                    );\n+                                }\n+                                (ty::ClosureKind::FnMut, Some((span, name))) => {\n+                                    err.span_label(\n+                                        *span,\n+                                        format!(\n+                                            \"closure is `FnMut` because it mutates the \\\n+                                         variable `{}` here\",\n+                                            name\n+                                        ),\n+                                    );\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+\n+                        err.emit();\n+                        return;\n+                    }\n+\n+                    ty::Predicate::WellFormed(ty) => {\n+                        if !self.tcx.sess.opts.debugging_opts.chalk {\n+                            // WF predicates cannot themselves make\n+                            // errors. They can only block due to\n+                            // ambiguity; otherwise, they always\n+                            // degenerate into other obligations\n+                            // (which may fail).\n+                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                        } else {\n+                            // FIXME: we'll need a better message which takes into account\n+                            // which bounds actually failed to hold.\n+                            self.tcx.sess.struct_span_err(\n+                                span,\n+                                &format!(\"the type `{}` is not well-formed (chalk)\", ty),\n+                            )\n+                        }\n+                    }\n+\n+                    ty::Predicate::ConstEvaluatable(..) => {\n+                        // Errors for `ConstEvaluatable` predicates show up as\n+                        // `SelectionError::ConstEvalFailure`,\n+                        // not `Unimplemented`.\n+                        span_bug!(\n+                            span,\n+                            \"const-evaluatable requirement gave wrong error: `{:?}`\",\n+                            obligation\n+                        )\n+                    }\n+                }\n+            }\n+\n+            OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n+                let found_trait_ref = self.resolve_vars_if_possible(&*found_trait_ref);\n+                let expected_trait_ref = self.resolve_vars_if_possible(&*expected_trait_ref);\n+\n+                if expected_trait_ref.self_ty().references_error() {\n+                    return;\n+                }\n+\n+                let found_trait_ty = found_trait_ref.self_ty();\n+\n+                let found_did = match found_trait_ty.kind {\n+                    ty::Closure(did, _) | ty::Foreign(did) | ty::FnDef(did, _) => Some(did),\n+                    ty::Adt(def, _) => Some(def.did),\n+                    _ => None,\n+                };\n+\n+                let found_span = found_did\n+                    .and_then(|did| self.tcx.hir().span_if_local(did))\n+                    .map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n+\n+                if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n+                    // We check closures twice, with obligations flowing in different directions,\n+                    // but we want to complain about them only once.\n+                    return;\n+                }\n+\n+                self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n+\n+                let found = match found_trait_ref.skip_binder().substs.type_at(1).kind {\n+                    ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n+                    _ => vec![ArgKind::empty()],\n+                };\n+\n+                let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n+                let expected = match expected_ty.kind {\n+                    ty::Tuple(ref tys) => tys\n+                        .iter()\n+                        .map(|t| ArgKind::from_expected_ty(t.expect_ty(), Some(span)))\n+                        .collect(),\n+                    _ => vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())],\n+                };\n+\n+                if found.len() == expected.len() {\n+                    self.report_closure_arg_mismatch(\n+                        span,\n+                        found_span,\n+                        found_trait_ref,\n+                        expected_trait_ref,\n+                    )\n+                } else {\n+                    let (closure_span, found) = found_did\n+                        .and_then(|did| self.tcx.hir().get_if_local(did))\n+                        .map(|node| {\n+                            let (found_span, found) = self.get_fn_like_arguments(node);\n+                            (Some(found_span), found)\n+                        })\n+                        .unwrap_or((found_span, found));\n+\n+                    self.report_arg_count_mismatch(\n+                        span,\n+                        closure_span,\n+                        expected,\n+                        found,\n+                        found_trait_ty.is_closure(),\n+                    )\n+                }\n+            }\n+\n+            TraitNotObjectSafe(did) => {\n+                let violations = object_safety_violations(self.tcx, did);\n+                report_object_safety_error(self.tcx, span, did, violations)\n+            }\n+\n+            // already reported in the query\n+            ConstEvalFailure(err) => {\n+                if let ErrorHandled::TooGeneric = err {\n+                    // Silence this error, as it can be produced during intermediate steps\n+                    // when a constant is not yet able to be evaluated (but will be later).\n+                    return;\n+                }\n+                self.tcx.sess.delay_span_bug(\n+                    span,\n+                    &format!(\"constant in type had an ignored error: {:?}\", err),\n+                );\n+                return;\n+            }\n+\n+            Overflow => {\n+                bug!(\"overflow should be handled before the `report_selection_error` path\");\n+            }\n+        };\n+\n+        self.note_obligation_cause(&mut err, obligation);\n+        self.point_at_returns_when_relevant(&mut err, &obligation);\n+\n+        err.emit();\n+    }\n+\n+    /// If the `Self` type of the unsatisfied trait `trait_ref` implements a trait\n+    /// with the same path as `trait_ref`, a help message about\n+    /// a probable version mismatch is added to `err`\n+    fn note_version_mismatch(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+    ) {\n+        let get_trait_impl = |trait_def_id| {\n+            let mut trait_impl = None;\n+            self.tcx.for_each_relevant_impl(trait_def_id, trait_ref.self_ty(), |impl_def_id| {\n+                if trait_impl.is_none() {\n+                    trait_impl = Some(impl_def_id);\n+                }\n+            });\n+            trait_impl\n+        };\n+        let required_trait_path = self.tcx.def_path_str(trait_ref.def_id());\n+        let all_traits = self.tcx.all_traits(LOCAL_CRATE);\n+        let traits_with_same_path: std::collections::BTreeSet<_> = all_traits\n+            .iter()\n+            .filter(|trait_def_id| **trait_def_id != trait_ref.def_id())\n+            .filter(|trait_def_id| self.tcx.def_path_str(**trait_def_id) == required_trait_path)\n+            .collect();\n+        for trait_with_same_path in traits_with_same_path {\n+            if let Some(impl_def_id) = get_trait_impl(*trait_with_same_path) {\n+                let impl_span = self.tcx.def_span(impl_def_id);\n+                err.span_help(impl_span, \"trait impl with same name found\");\n+                let trait_crate = self.tcx.crate_name(trait_with_same_path.krate);\n+                let crate_msg = format!(\n+                    \"perhaps two different versions of crate `{}` are being used?\",\n+                    trait_crate\n+                );\n+                err.note(&crate_msg);\n+            }\n+        }\n+    }\n+\n+    fn mk_obligation_for_def_id(\n+        &self,\n+        def_id: DefId,\n+        output_ty: Ty<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> PredicateObligation<'tcx> {\n+        let new_trait_ref =\n+            ty::TraitRef { def_id, substs: self.tcx.mk_substs_trait(output_ty, &[]) };\n+        Obligation::new(cause, param_env, new_trait_ref.to_predicate())\n+    }\n+}\n+\n+pub fn recursive_type_with_infinite_size_error(\n+    tcx: TyCtxt<'tcx>,\n+    type_def_id: DefId,\n+) -> DiagnosticBuilder<'tcx> {\n+    assert!(type_def_id.is_local());\n+    let span = tcx.hir().span_if_local(type_def_id).unwrap();\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0072,\n+        \"recursive type `{}` has infinite size\",\n+        tcx.def_path_str(type_def_id)\n+    );\n+    err.span_label(span, \"recursive type has infinite size\");\n+    err.help(&format!(\n+        \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+                           at some point to make `{}` representable\",\n+        tcx.def_path_str(type_def_id)\n+    ));\n+    err\n+}\n+\n+pub fn report_object_safety_error(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    trait_def_id: DefId,\n+    violations: Vec<ObjectSafetyViolation>,\n+) -> DiagnosticBuilder<'tcx> {\n+    let trait_str = tcx.def_path_str(trait_def_id);\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0038,\n+        \"the trait `{}` cannot be made into an object\",\n+        trait_str\n+    );\n+    err.span_label(span, format!(\"the trait `{}` cannot be made into an object\", trait_str));\n+\n+    let mut reported_violations = FxHashSet::default();\n+    for violation in violations {\n+        if reported_violations.insert(violation.clone()) {\n+            match violation.span() {\n+                Some(span) => err.span_label(span, violation.error_msg()),\n+                None => err.note(&violation.error_msg()),\n+            };\n+        }\n+    }\n+\n+    if tcx.sess.trait_methods_not_found.borrow().contains(&span) {\n+        // Avoid emitting error caused by non-existing method (#58734)\n+        err.cancel();\n+    }\n+\n+    err\n+}\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    fn maybe_report_ambiguity(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+    ) {\n+        // Unable to successfully determine, probably means\n+        // insufficient type information, but could mean\n+        // ambiguous impls. The latter *ought* to be a\n+        // coherence violation, so we don't report it here.\n+\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+        let span = obligation.cause.span;\n+\n+        debug!(\n+            \"maybe_report_ambiguity(predicate={:?}, obligation={:?} body_id={:?}, code={:?})\",\n+            predicate, obligation, body_id, obligation.cause.code,\n+        );\n+\n+        // Ambiguity errors are often caused as fallout from earlier\n+        // errors. So just ignore them if this infcx is tainted.\n+        if self.is_tainted_by_errors() {\n+            return;\n+        }\n+\n+        let mut err = match predicate {\n+            ty::Predicate::Trait(ref data) => {\n+                let trait_ref = data.to_poly_trait_ref();\n+                let self_ty = trait_ref.self_ty();\n+                debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n+\n+                if predicate.references_error() {\n+                    return;\n+                }\n+                // Typically, this ambiguity should only happen if\n+                // there are unresolved type inference variables\n+                // (otherwise it would suggest a coherence\n+                // failure). But given #21974 that is not necessarily\n+                // the case -- we can have multiple where clauses that\n+                // are only distinguished by a region, which results\n+                // in an ambiguity even when all types are fully\n+                // known, since we don't dispatch based on region\n+                // relationships.\n+\n+                // This is kind of a hack: it frequently happens that some earlier\n+                // error prevents types from being fully inferred, and then we get\n+                // a bunch of uninteresting errors saying something like \"<generic\n+                // #0> doesn't implement Sized\".  It may even be true that we\n+                // could just skip over all checks where the self-ty is an\n+                // inference variable, but I was afraid that there might be an\n+                // inference variable created, registered as an obligation, and\n+                // then never forced by writeback, and hence by skipping here we'd\n+                // be ignoring the fact that we don't KNOW the type works\n+                // out. Though even that would probably be harmless, given that\n+                // we're only talking about builtin traits, which are known to be\n+                // inhabited. We used to check for `self.tcx.sess.has_errors()` to\n+                // avoid inundating the user with unnecessary errors, but we now\n+                // check upstream for type errors and dont add the obligations to\n+                // begin with in those cases.\n+                if self\n+                    .tcx\n+                    .lang_items()\n+                    .sized_trait()\n+                    .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n+                {\n+                    self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0282).emit();\n+                    return;\n+                }\n+                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0283);\n+                err.note(&format!(\"cannot resolve `{}`\", predicate));\n+                if let ObligationCauseCode::ItemObligation(def_id) = obligation.cause.code {\n+                    self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n+                } else if let (\n+                    Ok(ref snippet),\n+                    ObligationCauseCode::BindingObligation(ref def_id, _),\n+                ) =\n+                    (self.tcx.sess.source_map().span_to_snippet(span), &obligation.cause.code)\n+                {\n+                    let generics = self.tcx.generics_of(*def_id);\n+                    if !generics.params.is_empty() && !snippet.ends_with('>') {\n+                        // FIXME: To avoid spurious suggestions in functions where type arguments\n+                        // where already supplied, we check the snippet to make sure it doesn't\n+                        // end with a turbofish. Ideally we would have access to a `PathSegment`\n+                        // instead. Otherwise we would produce the following output:\n+                        //\n+                        // error[E0283]: type annotations needed\n+                        //   --> $DIR/issue-54954.rs:3:24\n+                        //    |\n+                        // LL | const ARR_LEN: usize = Tt::const_val::<[i8; 123]>();\n+                        //    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+                        //    |                        |\n+                        //    |                        cannot infer type\n+                        //    |                        help: consider specifying the type argument\n+                        //    |                        in the function call:\n+                        //    |                        `Tt::const_val::<[i8; 123]>::<T>`\n+                        // ...\n+                        // LL |     const fn const_val<T: Sized>() -> usize {\n+                        //    |              --------- - required by this bound in `Tt::const_val`\n+                        //    |\n+                        //    = note: cannot resolve `_: Tt`\n+\n+                        err.span_suggestion(\n+                            span,\n+                            &format!(\n+                                \"consider specifying the type argument{} in the function call\",\n+                                if generics.params.len() > 1 { \"s\" } else { \"\" },\n+                            ),\n+                            format!(\n+                                \"{}::<{}>\",\n+                                snippet,\n+                                generics\n+                                    .params\n+                                    .iter()\n+                                    .map(|p| p.name.to_string())\n+                                    .collect::<Vec<String>>()\n+                                    .join(\", \")\n+                            ),\n+                            Applicability::HasPlaceholders,\n+                        );\n+                    }\n+                }\n+                err\n+            }\n+\n+            ty::Predicate::WellFormed(ty) => {\n+                // Same hacky approach as above to avoid deluging user\n+                // with error messages.\n+                if ty.references_error() || self.tcx.sess.has_errors() {\n+                    return;\n+                }\n+                self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n+            }\n+\n+            ty::Predicate::Subtype(ref data) => {\n+                if data.references_error() || self.tcx.sess.has_errors() {\n+                    // no need to overload user in such cases\n+                    return;\n+                }\n+                let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n+                // both must be type variables, or the other would've been instantiated\n+                assert!(a.is_ty_var() && b.is_ty_var());\n+                self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n+            }\n+            ty::Predicate::Projection(ref data) => {\n+                let trait_ref = data.to_poly_trait_ref(self.tcx);\n+                let self_ty = trait_ref.self_ty();\n+                if predicate.references_error() {\n+                    return;\n+                }\n+                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0284);\n+                err.note(&format!(\"cannot resolve `{}`\", predicate));\n+                err\n+            }\n+\n+            _ => {\n+                if self.tcx.sess.has_errors() {\n+                    return;\n+                }\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0284,\n+                    \"type annotations needed: cannot resolve `{}`\",\n+                    predicate,\n+                );\n+                err.span_label(span, &format!(\"cannot resolve `{}`\", predicate));\n+                err\n+            }\n+        };\n+        self.note_obligation_cause(&mut err, obligation);\n+        err.emit();\n+    }\n+\n+    /// Returns `true` if the trait predicate may apply for *some* assignment\n+    /// to the type parameters.\n+    fn predicate_can_apply(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        pred: ty::PolyTraitRef<'tcx>,\n+    ) -> bool {\n+        struct ParamToVarFolder<'a, 'tcx> {\n+            infcx: &'a InferCtxt<'a, 'tcx>,\n+            var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n+        }\n+\n+        impl<'a, 'tcx> TypeFolder<'tcx> for ParamToVarFolder<'a, 'tcx> {\n+            fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+                self.infcx.tcx\n+            }\n+\n+            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+                if let ty::Param(ty::ParamTy { name, .. }) = ty.kind {\n+                    let infcx = self.infcx;\n+                    self.var_map.entry(ty).or_insert_with(|| {\n+                        infcx.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeParameterDefinition(name, None),\n+                            span: DUMMY_SP,\n+                        })\n+                    })\n+                } else {\n+                    ty.super_fold_with(self)\n+                }\n+            }\n+        }\n+\n+        self.probe(|_| {\n+            let mut selcx = SelectionContext::new(self);\n+\n+            let cleaned_pred =\n+                pred.fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() });\n+\n+            let cleaned_pred = super::project::normalize(\n+                &mut selcx,\n+                param_env,\n+                ObligationCause::dummy(),\n+                &cleaned_pred,\n+            )\n+            .value;\n+\n+            let obligation =\n+                Obligation::new(ObligationCause::dummy(), param_env, cleaned_pred.to_predicate());\n+\n+            self.predicate_may_hold(&obligation)\n+        })\n+    }\n+\n+    fn note_obligation_cause(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) {\n+        // First, attempt to add note to this error with an async-await-specific\n+        // message, and fall back to regular note otherwise.\n+        if !self.maybe_note_obligation_cause_for_async_await(err, obligation) {\n+            self.note_obligation_cause_code(\n+                err,\n+                &obligation.predicate,\n+                &obligation.cause.code,\n+                &mut vec![],\n+            );\n+        }\n+    }\n+\n+    fn is_recursive_obligation(\n+        &self,\n+        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        cause_code: &ObligationCauseCode<'tcx>,\n+    ) -> bool {\n+        if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n+            let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+\n+            if obligated_types.iter().any(|ot| ot == &parent_trait_ref.skip_binder().self_ty()) {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+}\n+\n+/// Summarizes information\n+#[derive(Clone)]\n+pub enum ArgKind {\n+    /// An argument of non-tuple type. Parameters are (name, ty)\n+    Arg(String, String),\n+\n+    /// An argument of tuple type. For a \"found\" argument, the span is\n+    /// the locationo in the source of the pattern. For a \"expected\"\n+    /// argument, it will be None. The vector is a list of (name, ty)\n+    /// strings for the components of the tuple.\n+    Tuple(Option<Span>, Vec<(String, String)>),\n+}\n+\n+impl ArgKind {\n+    fn empty() -> ArgKind {\n+        ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n+    }\n+\n+    /// Creates an `ArgKind` from the expected type of an\n+    /// argument. It has no name (`_`) and an optional source span.\n+    pub fn from_expected_ty(t: Ty<'_>, span: Option<Span>) -> ArgKind {\n+        match t.kind {\n+            ty::Tuple(ref tys) => ArgKind::Tuple(\n+                span,\n+                tys.iter().map(|ty| (\"_\".to_owned(), ty.to_string())).collect::<Vec<_>>(),\n+            ),\n+            _ => ArgKind::Arg(\"_\".to_owned(), t.to_string()),\n+        }\n+    }\n+}\n+\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_param(\n+    generics: &hir::Generics<'_>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+    source_map: &SourceMap,\n+    span: Span,\n+) -> bool {\n+    let restrict_msg = \"consider further restricting this bound\";\n+    if let Some(param) =\n+        generics.params.iter().filter(|p| p.name.ident().as_str() == param_name).next()\n+    {\n+        if param_name.starts_with(\"impl \") {\n+            // `impl Trait` in argument:\n+            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n+            err.span_suggestion(\n+                param.span,\n+                restrict_msg,\n+                // `impl CurrentTrait + MissingTrait`\n+                format!(\"{} + {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if generics.where_clause.predicates.is_empty() && param.bounds.is_empty() {\n+            // If there are no bounds whatsoever, suggest adding a constraint\n+            // to the type parameter:\n+            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            err.span_suggestion(\n+                param.span,\n+                \"consider restricting this bound\",\n+                format!(\"{}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if !generics.where_clause.predicates.is_empty() {\n+            // There is a `where` clause, so suggest expanding it:\n+            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n+            err.span_suggestion(\n+                generics.where_clause.span().unwrap().shrink_to_hi(),\n+                &format!(\"consider further restricting type parameter `{}`\", param_name),\n+                format!(\", {}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            // If there is no `where` clause lean towards constraining to the\n+            // type parameter:\n+            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+            let sp = param.span.with_hi(span.hi());\n+            let span = source_map.span_through_char(sp, ':');\n+            if sp != param.span && sp != span {\n+                // Only suggest if we have high certainty that the span\n+                // covers the colon in `foo<T: Trait>`.\n+                err.span_suggestion(\n+                    span,\n+                    restrict_msg,\n+                    format!(\"{}: {} + \", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_label(\n+                    param.span,\n+                    &format!(\"consider adding a `where {}: {}` bound\", param_name, constraint),\n+                );\n+            }\n+        }\n+        return true;\n+    }\n+    false\n+}"}, {"sha": "9f3fc91548b218e4c5378f0a31ec8fe559396172", "filename": "src/librustc/traits/error_reporting/on_unimplemented.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -0,0 +1,199 @@\n+use super::{\n+    ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote, PredicateObligation,\n+};\n+use crate::infer::InferCtxt;\n+use crate::ty::subst::Subst;\n+use crate::ty::{self, GenericParamDefKind};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::symbol::sym;\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    fn impl_similar_to(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> Option<DefId> {\n+        let tcx = self.tcx;\n+        let param_env = obligation.param_env;\n+        let trait_ref = tcx.erase_late_bound_regions(&trait_ref);\n+        let trait_self_ty = trait_ref.self_ty();\n+\n+        let mut self_match_impls = vec![];\n+        let mut fuzzy_match_impls = vec![];\n+\n+        self.tcx.for_each_relevant_impl(trait_ref.def_id, trait_self_ty, |def_id| {\n+            let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n+            let impl_trait_ref = tcx.impl_trait_ref(def_id).unwrap().subst(tcx, impl_substs);\n+\n+            let impl_self_ty = impl_trait_ref.self_ty();\n+\n+            if let Ok(..) = self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n+                self_match_impls.push(def_id);\n+\n+                if trait_ref\n+                    .substs\n+                    .types()\n+                    .skip(1)\n+                    .zip(impl_trait_ref.substs.types().skip(1))\n+                    .all(|(u, v)| self.fuzzy_match_tys(u, v))\n+                {\n+                    fuzzy_match_impls.push(def_id);\n+                }\n+            }\n+        });\n+\n+        let impl_def_id = if self_match_impls.len() == 1 {\n+            self_match_impls[0]\n+        } else if fuzzy_match_impls.len() == 1 {\n+            fuzzy_match_impls[0]\n+        } else {\n+            return None;\n+        };\n+\n+        tcx.has_attr(impl_def_id, sym::rustc_on_unimplemented).then_some(impl_def_id)\n+    }\n+\n+    /// Used to set on_unimplemented's `ItemContext`\n+    /// to be the enclosing (async) block/function/closure\n+    fn describe_enclosure(&self, hir_id: hir::HirId) -> Option<&'static str> {\n+        let hir = &self.tcx.hir();\n+        let node = hir.find(hir_id)?;\n+        if let hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, _, body_id), .. }) = &node {\n+            self.describe_generator(*body_id).or_else(|| {\n+                Some(if let hir::FnHeader { asyncness: hir::IsAsync::Async, .. } = sig.header {\n+                    \"an async function\"\n+                } else {\n+                    \"a function\"\n+                })\n+            })\n+        } else if let hir::Node::Expr(hir::Expr {\n+            kind: hir::ExprKind::Closure(_is_move, _, body_id, _, gen_movability),\n+            ..\n+        }) = &node\n+        {\n+            self.describe_generator(*body_id).or_else(|| {\n+                Some(if gen_movability.is_some() { \"an async closure\" } else { \"a closure\" })\n+            })\n+        } else if let hir::Node::Expr(hir::Expr { .. }) = &node {\n+            let parent_hid = hir.get_parent_node(hir_id);\n+            if parent_hid != hir_id {\n+                return self.describe_enclosure(parent_hid);\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    crate fn on_unimplemented_note(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> OnUnimplementedNote {\n+        let def_id =\n+            self.impl_similar_to(trait_ref, obligation).unwrap_or_else(|| trait_ref.def_id());\n+        let trait_ref = *trait_ref.skip_binder();\n+\n+        let mut flags = vec![];\n+        flags.push((\n+            sym::item_context,\n+            self.describe_enclosure(obligation.cause.body_id).map(|s| s.to_owned()),\n+        ));\n+\n+        match obligation.cause.code {\n+            ObligationCauseCode::BuiltinDerivedObligation(..)\n+            | ObligationCauseCode::ImplDerivedObligation(..) => {}\n+            _ => {\n+                // this is a \"direct\", user-specified, rather than derived,\n+                // obligation.\n+                flags.push((sym::direct, None));\n+            }\n+        }\n+\n+        if let ObligationCauseCode::ItemObligation(item) = obligation.cause.code {\n+            // FIXME: maybe also have some way of handling methods\n+            // from other traits? That would require name resolution,\n+            // which we might want to be some sort of hygienic.\n+            //\n+            // Currently I'm leaving it for what I need for `try`.\n+            if self.tcx.trait_of_item(item) == Some(trait_ref.def_id) {\n+                let method = self.tcx.item_name(item);\n+                flags.push((sym::from_method, None));\n+                flags.push((sym::from_method, Some(method.to_string())));\n+            }\n+        }\n+        if let Some((t, _)) = self.get_parent_trait_ref(&obligation.cause.code) {\n+            flags.push((sym::parent_trait, Some(t)));\n+        }\n+\n+        if let Some(k) = obligation.cause.span.desugaring_kind() {\n+            flags.push((sym::from_desugaring, None));\n+            flags.push((sym::from_desugaring, Some(format!(\"{:?}\", k))));\n+        }\n+        let generics = self.tcx.generics_of(def_id);\n+        let self_ty = trait_ref.self_ty();\n+        // This is also included through the generics list as `Self`,\n+        // but the parser won't allow you to use it\n+        flags.push((sym::_Self, Some(self_ty.to_string())));\n+        if let Some(def) = self_ty.ty_adt_def() {\n+            // We also want to be able to select self's original\n+            // signature with no type arguments resolved\n+            flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n+        }\n+\n+        for param in generics.params.iter() {\n+            let value = match param.kind {\n+                GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n+                    trait_ref.substs[param.index as usize].to_string()\n+                }\n+                GenericParamDefKind::Lifetime => continue,\n+            };\n+            let name = param.name;\n+            flags.push((name, Some(value)));\n+        }\n+\n+        if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n+            flags.push((sym::crate_local, None));\n+        }\n+\n+        // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n+        if self_ty.is_integral() {\n+            flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n+        }\n+\n+        if let ty::Array(aty, len) = self_ty.kind {\n+            flags.push((sym::_Self, Some(\"[]\".to_owned())));\n+            flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n+            if let Some(def) = aty.ty_adt_def() {\n+                // We also want to be able to select the array's type's original\n+                // signature with no type arguments resolved\n+                flags.push((\n+                    sym::_Self,\n+                    Some(format!(\"[{}]\", self.tcx.type_of(def.did).to_string())),\n+                ));\n+                let tcx = self.tcx;\n+                if let Some(len) = len.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n+                    flags.push((\n+                        sym::_Self,\n+                        Some(format!(\"[{}; {}]\", self.tcx.type_of(def.did).to_string(), len)),\n+                    ));\n+                } else {\n+                    flags.push((\n+                        sym::_Self,\n+                        Some(format!(\"[{}; _]\", self.tcx.type_of(def.did).to_string())),\n+                    ));\n+                }\n+            }\n+        }\n+\n+        if let Ok(Some(command)) =\n+            OnUnimplementedDirective::of_item(self.tcx, trait_ref.def_id, def_id)\n+        {\n+            command.evaluate(self.tcx, trait_ref, &flags[..])\n+        } else {\n+            OnUnimplementedNote::default()\n+        }\n+    }\n+}"}, {"sha": "bf6891214ace1637dbb5539135984f15e3266e19", "filename": "src/librustc/traits/error_reporting/suggestions.rs", "status": "added", "additions": 1718, "deletions": 0, "changes": 1718, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -0,0 +1,1718 @@\n+use super::{\n+    ArgKind, EvaluationResult, Obligation, ObligationCause, ObligationCauseCode,\n+    PredicateObligation,\n+};\n+\n+use crate::infer::InferCtxt;\n+use crate::traits::object_safety::object_safety_violations;\n+use crate::ty::TypeckTables;\n+use crate::ty::{self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+\n+use rustc_errors::{\n+    error_code, pluralize, struct_span_err, Applicability, DiagnosticBuilder, Style,\n+};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::Node;\n+use rustc_span::source_map::SourceMap;\n+use rustc_span::symbol::{kw, sym};\n+use rustc_span::{MultiSpan, Span, DUMMY_SP};\n+use std::fmt;\n+\n+use rustc_error_codes::*;\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    crate fn suggest_restricting_param_bound(\n+        &self,\n+        mut err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::PolyTraitRef<'_>,\n+        body_id: hir::HirId,\n+    ) {\n+        let self_ty = trait_ref.self_ty();\n+        let (param_ty, projection) = match &self_ty.kind {\n+            ty::Param(_) => (true, None),\n+            ty::Projection(projection) => (false, Some(projection)),\n+            _ => return,\n+        };\n+\n+        let suggest_restriction =\n+            |generics: &hir::Generics<'_>, msg, err: &mut DiagnosticBuilder<'_>| {\n+                let span = generics.where_clause.span_for_predicates_or_empty_place();\n+                if !span.from_expansion() && span.desugaring_kind().is_none() {\n+                    err.span_suggestion(\n+                        generics.where_clause.span_for_predicates_or_empty_place().shrink_to_hi(),\n+                        &format!(\"consider further restricting {}\", msg),\n+                        format!(\n+                            \"{} {} \",\n+                            if !generics.where_clause.predicates.is_empty() {\n+                                \",\"\n+                            } else {\n+                                \" where\"\n+                            },\n+                            trait_ref.to_predicate(),\n+                        ),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            };\n+\n+        // FIXME: Add check for trait bound that is already present, particularly `?Sized` so we\n+        //        don't suggest `T: Sized + ?Sized`.\n+        let mut hir_id = body_id;\n+        while let Some(node) = self.tcx.hir().find(hir_id) {\n+            match node {\n+                hir::Node::TraitItem(hir::TraitItem {\n+                    generics,\n+                    kind: hir::TraitItemKind::Method(..),\n+                    ..\n+                }) if param_ty && self_ty == self.tcx.types.self_param => {\n+                    // Restricting `Self` for a single method.\n+                    suggest_restriction(&generics, \"`Self`\", err);\n+                    return;\n+                }\n+\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, generics, _), .. })\n+                | hir::Node::TraitItem(hir::TraitItem {\n+                    generics,\n+                    kind: hir::TraitItemKind::Method(..),\n+                    ..\n+                })\n+                | hir::Node::ImplItem(hir::ImplItem {\n+                    generics,\n+                    kind: hir::ImplItemKind::Method(..),\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, generics, _, _),\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Impl(_, _, _, generics, ..),\n+                    ..\n+                }) if projection.is_some() => {\n+                    // Missing associated type bound.\n+                    suggest_restriction(&generics, \"the associated type\", err);\n+                    return;\n+                }\n+\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Struct(_, generics),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Enum(_, generics), span, ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Union(_, generics),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, generics, ..),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Impl(_, _, _, generics, ..),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Fn(_, generics, _),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::TyAlias(_, generics),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::TraitAlias(generics, _),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::OpaqueTy(hir::OpaqueTy { generics, .. }),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::TraitItem(hir::TraitItem { generics, span, .. })\n+                | hir::Node::ImplItem(hir::ImplItem { generics, span, .. })\n+                    if param_ty =>\n+                {\n+                    // Missing generic type parameter bound.\n+                    let param_name = self_ty.to_string();\n+                    let constraint = trait_ref.print_only_trait_path().to_string();\n+                    if suggest_constraining_type_param(\n+                        generics,\n+                        &mut err,\n+                        &param_name,\n+                        &constraint,\n+                        self.tcx.sess.source_map(),\n+                        *span,\n+                    ) {\n+                        return;\n+                    }\n+                }\n+\n+                hir::Node::Crate => return,\n+\n+                _ => {}\n+            }\n+\n+            hir_id = self.tcx.hir().get_parent_item(hir_id);\n+        }\n+    }\n+\n+    /// When encountering an assignment of an unsized trait, like `let x = \"\"[..];`, provide a\n+    /// suggestion to borrow the initializer in order to use have a slice instead.\n+    crate fn suggest_borrow_on_unsized_slice(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+    ) {\n+        if let &ObligationCauseCode::VariableType(hir_id) = code {\n+            let parent_node = self.tcx.hir().get_parent_node(hir_id);\n+            if let Some(Node::Local(ref local)) = self.tcx.hir().find(parent_node) {\n+                if let Some(ref expr) = local.init {\n+                    if let hir::ExprKind::Index(_, _) = expr.kind {\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n+                            err.span_suggestion(\n+                                expr.span,\n+                                \"consider borrowing here\",\n+                                format!(\"&{}\", snippet),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Given a closure's `DefId`, return the given name of the closure.\n+    ///\n+    /// This doesn't account for reassignments, but it's only used for suggestions.\n+    crate fn get_closure_name(\n+        &self,\n+        def_id: DefId,\n+        err: &mut DiagnosticBuilder<'_>,\n+        msg: &str,\n+    ) -> Option<String> {\n+        let get_name =\n+            |err: &mut DiagnosticBuilder<'_>, kind: &hir::PatKind<'_>| -> Option<String> {\n+                // Get the local name of this closure. This can be inaccurate because\n+                // of the possibility of reassignment, but this should be good enough.\n+                match &kind {\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => {\n+                        Some(format!(\"{}\", name))\n+                    }\n+                    _ => {\n+                        err.note(&msg);\n+                        None\n+                    }\n+                }\n+            };\n+\n+        let hir = self.tcx.hir();\n+        let hir_id = hir.as_local_hir_id(def_id)?;\n+        let parent_node = hir.get_parent_node(hir_id);\n+        match hir.find(parent_node) {\n+            Some(hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(local), .. })) => {\n+                get_name(err, &local.pat.kind)\n+            }\n+            // Different to previous arm because one is `&hir::Local` and the other\n+            // is `P<hir::Local>`.\n+            Some(hir::Node::Local(local)) => get_name(err, &local.pat.kind),\n+            _ => return None,\n+        }\n+    }\n+\n+    /// We tried to apply the bound to an `fn` or closure. Check whether calling it would\n+    /// evaluate to a type that *would* satisfy the trait binding. If it would, suggest calling\n+    /// it: `bar(foo)` \u2192 `bar(foo())`. This case is *very* likely to be hit if `foo` is `async`.\n+    crate fn suggest_fn_call(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+    ) {\n+        let self_ty = trait_ref.self_ty();\n+        let (def_id, output_ty, callable) = match self_ty.kind {\n+            ty::Closure(def_id, substs) => {\n+                (def_id, self.closure_sig(def_id, substs).output(), \"closure\")\n+            }\n+            ty::FnDef(def_id, _) => (def_id, self_ty.fn_sig(self.tcx).output(), \"function\"),\n+            _ => return,\n+        };\n+        let msg = format!(\"use parentheses to call the {}\", callable);\n+\n+        let obligation = self.mk_obligation_for_def_id(\n+            trait_ref.def_id(),\n+            output_ty.skip_binder(),\n+            obligation.cause.clone(),\n+            obligation.param_env,\n+        );\n+\n+        match self.evaluate_obligation(&obligation) {\n+            Ok(EvaluationResult::EvaluatedToOk)\n+            | Ok(EvaluationResult::EvaluatedToOkModuloRegions)\n+            | Ok(EvaluationResult::EvaluatedToAmbig) => {}\n+            _ => return,\n+        }\n+        let hir = self.tcx.hir();\n+        // Get the name of the callable and the arguments to be used in the suggestion.\n+        let snippet = match hir.get_if_local(def_id) {\n+            Some(hir::Node::Expr(hir::Expr {\n+                kind: hir::ExprKind::Closure(_, decl, _, span, ..),\n+                ..\n+            })) => {\n+                err.span_label(*span, \"consider calling this closure\");\n+                let name = match self.get_closure_name(def_id, err, &msg) {\n+                    Some(name) => name,\n+                    None => return,\n+                };\n+                let args = decl.inputs.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n+                format!(\"{}({})\", name, args)\n+            }\n+            Some(hir::Node::Item(hir::Item {\n+                ident,\n+                kind: hir::ItemKind::Fn(.., body_id),\n+                ..\n+            })) => {\n+                err.span_label(ident.span, \"consider calling this function\");\n+                let body = hir.body(*body_id);\n+                let args = body\n+                    .params\n+                    .iter()\n+                    .map(|arg| match &arg.pat.kind {\n+                        hir::PatKind::Binding(_, _, ident, None)\n+                        // FIXME: provide a better suggestion when encountering `SelfLower`, it\n+                        // should suggest a method call.\n+                        if ident.name != kw::SelfLower => ident.to_string(),\n+                        _ => \"_\".to_string(),\n+                    })\n+                    .collect::<Vec<_>>()\n+                    .join(\", \");\n+                format!(\"{}({})\", ident, args)\n+            }\n+            _ => return,\n+        };\n+        if points_at_arg {\n+            // When the obligation error has been ensured to have been caused by\n+            // an argument, the `obligation.cause.span` points at the expression\n+            // of the argument, so we can provide a suggestion. This is signaled\n+            // by `points_at_arg`. Otherwise, we give a more general note.\n+            err.span_suggestion(\n+                obligation.cause.span,\n+                &msg,\n+                snippet,\n+                Applicability::HasPlaceholders,\n+            );\n+        } else {\n+            err.help(&format!(\"{}: `{}`\", msg, snippet));\n+        }\n+    }\n+\n+    crate fn suggest_add_reference_to_arg(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+        has_custom_message: bool,\n+    ) -> bool {\n+        if !points_at_arg {\n+            return false;\n+        }\n+\n+        let span = obligation.cause.span;\n+        let param_env = obligation.param_env;\n+        let trait_ref = trait_ref.skip_binder();\n+\n+        if let ObligationCauseCode::ImplDerivedObligation(obligation) = &obligation.cause.code {\n+            // Try to apply the original trait binding obligation by borrowing.\n+            let self_ty = trait_ref.self_ty();\n+            let found = self_ty.to_string();\n+            let new_self_ty = self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, self_ty);\n+            let substs = self.tcx.mk_substs_trait(new_self_ty, &[]);\n+            let new_trait_ref = ty::TraitRef::new(obligation.parent_trait_ref.def_id(), substs);\n+            let new_obligation =\n+                Obligation::new(ObligationCause::dummy(), param_env, new_trait_ref.to_predicate());\n+            if self.predicate_must_hold_modulo_regions(&new_obligation) {\n+                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                    // We have a very specific type of error, where just borrowing this argument\n+                    // might solve the problem. In cases like this, the important part is the\n+                    // original type obligation, not the last one that failed, which is arbitrary.\n+                    // Because of this, we modify the error to refer to the original obligation and\n+                    // return early in the caller.\n+                    let msg = format!(\n+                        \"the trait bound `{}: {}` is not satisfied\",\n+                        found,\n+                        obligation.parent_trait_ref.skip_binder().print_only_trait_path(),\n+                    );\n+                    if has_custom_message {\n+                        err.note(&msg);\n+                    } else {\n+                        err.message = vec![(msg, Style::NoStyle)];\n+                    }\n+                    if snippet.starts_with('&') {\n+                        // This is already a literal borrow and the obligation is failing\n+                        // somewhere else in the obligation chain. Do not suggest non-sense.\n+                        return false;\n+                    }\n+                    err.span_label(\n+                        span,\n+                        &format!(\n+                            \"expected an implementor of trait `{}`\",\n+                            obligation.parent_trait_ref.skip_binder().print_only_trait_path(),\n+                        ),\n+                    );\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider borrowing here\",\n+                        format!(\"&{}\", snippet),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,\n+    /// suggest removing these references until we reach a type that implements the trait.\n+    crate fn suggest_remove_reference(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) {\n+        let trait_ref = trait_ref.skip_binder();\n+        let span = obligation.cause.span;\n+\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+            let refs_number =\n+                snippet.chars().filter(|c| !c.is_whitespace()).take_while(|c| *c == '&').count();\n+            if let Some('\\'') =\n+                snippet.chars().filter(|c| !c.is_whitespace()).skip(refs_number).next()\n+            {\n+                // Do not suggest removal of borrow from type arguments.\n+                return;\n+            }\n+\n+            let mut trait_type = trait_ref.self_ty();\n+\n+            for refs_remaining in 0..refs_number {\n+                if let ty::Ref(_, t_type, _) = trait_type.kind {\n+                    trait_type = t_type;\n+\n+                    let new_obligation = self.mk_obligation_for_def_id(\n+                        trait_ref.def_id,\n+                        trait_type,\n+                        ObligationCause::dummy(),\n+                        obligation.param_env,\n+                    );\n+\n+                    if self.predicate_may_hold(&new_obligation) {\n+                        let sp = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n+\n+                        let remove_refs = refs_remaining + 1;\n+                        let format_str =\n+                            format!(\"consider removing {} leading `&`-references\", remove_refs);\n+\n+                        err.span_suggestion_short(\n+                            sp,\n+                            &format_str,\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        break;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Check if the trait bound is implemented for a different mutability and note it in the\n+    /// final error.\n+    crate fn suggest_change_mut(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+    ) {\n+        let span = obligation.cause.span;\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+            let refs_number =\n+                snippet.chars().filter(|c| !c.is_whitespace()).take_while(|c| *c == '&').count();\n+            if let Some('\\'') =\n+                snippet.chars().filter(|c| !c.is_whitespace()).skip(refs_number).next()\n+            {\n+                // Do not suggest removal of borrow from type arguments.\n+                return;\n+            }\n+            let trait_ref = self.resolve_vars_if_possible(trait_ref);\n+            if trait_ref.has_infer_types() {\n+                // Do not ICE while trying to find if a reborrow would succeed on a trait with\n+                // unresolved bindings.\n+                return;\n+            }\n+\n+            if let ty::Ref(region, t_type, mutability) = trait_ref.skip_binder().self_ty().kind {\n+                let trait_type = match mutability {\n+                    hir::Mutability::Mut => self.tcx.mk_imm_ref(region, t_type),\n+                    hir::Mutability::Not => self.tcx.mk_mut_ref(region, t_type),\n+                };\n+\n+                let new_obligation = self.mk_obligation_for_def_id(\n+                    trait_ref.skip_binder().def_id,\n+                    trait_type,\n+                    ObligationCause::dummy(),\n+                    obligation.param_env,\n+                );\n+\n+                if self.evaluate_obligation_no_overflow(&new_obligation).must_apply_modulo_regions()\n+                {\n+                    let sp = self\n+                        .tcx\n+                        .sess\n+                        .source_map()\n+                        .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n+                    if points_at_arg && mutability == hir::Mutability::Not && refs_number > 0 {\n+                        err.span_suggestion(\n+                            sp,\n+                            \"consider changing this borrow's mutability\",\n+                            \"&mut \".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        err.note(&format!(\n+                            \"`{}` is implemented for `{:?}`, but not for `{:?}`\",\n+                            trait_ref.print_only_trait_path(),\n+                            trait_type,\n+                            trait_ref.skip_binder().self_ty(),\n+                        ));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    crate fn suggest_semicolon_removal(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        span: Span,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) {\n+        let hir = self.tcx.hir();\n+        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n+        let node = hir.find(parent_node);\n+        if let Some(hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(sig, _, body_id), ..\n+        })) = node\n+        {\n+            let body = hir.body(*body_id);\n+            if let hir::ExprKind::Block(blk, _) = &body.value.kind {\n+                if sig.decl.output.span().overlaps(span)\n+                    && blk.expr.is_none()\n+                    && \"()\" == &trait_ref.self_ty().to_string()\n+                {\n+                    // FIXME(estebank): When encountering a method with a trait\n+                    // bound not satisfied in the return type with a body that has\n+                    // no return, suggest removal of semicolon on last statement.\n+                    // Once that is added, close #54771.\n+                    if let Some(ref stmt) = blk.stmts.last() {\n+                        let sp = self.tcx.sess.source_map().end_point(stmt.span);\n+                        err.span_label(sp, \"consider removing this semicolon\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// If all conditions are met to identify a returned `dyn Trait`, suggest using `impl Trait` if\n+    /// applicable and signal that the error has been expanded appropriately and needs to be\n+    /// emitted.\n+    crate fn suggest_impl_trait(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        span: Span,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) -> bool {\n+        match obligation.cause.code.peel_derives() {\n+            // Only suggest `impl Trait` if the return type is unsized because it is `dyn Trait`.\n+            ObligationCauseCode::SizedReturnType => {}\n+            _ => return false,\n+        }\n+\n+        let hir = self.tcx.hir();\n+        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n+        let node = hir.find(parent_node);\n+        let (sig, body_id) = if let Some(hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(sig, _, body_id),\n+            ..\n+        })) = node\n+        {\n+            (sig, body_id)\n+        } else {\n+            return false;\n+        };\n+        let body = hir.body(*body_id);\n+        let trait_ref = self.resolve_vars_if_possible(trait_ref);\n+        let ty = trait_ref.skip_binder().self_ty();\n+        let is_object_safe = match ty.kind {\n+            ty::Dynamic(predicates, _) => {\n+                // If the `dyn Trait` is not object safe, do not suggest `Box<dyn Trait>`.\n+                predicates\n+                    .principal_def_id()\n+                    .map_or(true, |def_id| object_safety_violations(self.tcx, def_id).is_empty())\n+            }\n+            // We only want to suggest `impl Trait` to `dyn Trait`s.\n+            // For example, `fn foo() -> str` needs to be filtered out.\n+            _ => return false,\n+        };\n+\n+        let ret_ty = if let hir::FunctionRetTy::Return(ret_ty) = sig.decl.output {\n+            ret_ty\n+        } else {\n+            return false;\n+        };\n+\n+        // Use `TypeVisitor` instead of the output type directly to find the span of `ty` for\n+        // cases like `fn foo() -> (dyn Trait, i32) {}`.\n+        // Recursively look for `TraitObject` types and if there's only one, use that span to\n+        // suggest `impl Trait`.\n+\n+        // Visit to make sure there's a single `return` type to suggest `impl Trait`,\n+        // otherwise suggest using `Box<dyn Trait>` or an enum.\n+        let mut visitor = ReturnsVisitor(vec![]);\n+        visitor.visit_body(&body);\n+\n+        let tables = self.in_progress_tables.map(|t| t.borrow()).unwrap();\n+\n+        let mut ret_types = visitor.0.iter().filter_map(|expr| tables.node_type_opt(expr.hir_id));\n+        let (last_ty, all_returns_have_same_type) =\n+            ret_types.clone().fold((None, true), |(last_ty, mut same), returned_ty| {\n+                same &= last_ty.map_or(true, |ty| ty == returned_ty);\n+                (Some(returned_ty), same)\n+            });\n+        let all_returns_conform_to_trait =\n+            if let Some(ty_ret_ty) = tables.node_type_opt(ret_ty.hir_id) {\n+                match ty_ret_ty.kind {\n+                    ty::Dynamic(predicates, _) => {\n+                        let cause = ObligationCause::misc(ret_ty.span, ret_ty.hir_id);\n+                        let param_env = ty::ParamEnv::empty();\n+                        ret_types.all(|returned_ty| {\n+                            predicates.iter().all(|predicate| {\n+                                let pred = predicate.with_self_ty(self.tcx, returned_ty);\n+                                let obl = Obligation::new(cause.clone(), param_env, pred);\n+                                self.predicate_may_hold(&obl)\n+                            })\n+                        })\n+                    }\n+                    _ => true,\n+                }\n+            } else {\n+                true\n+            };\n+\n+        let (snippet, last_ty) =\n+            if let (true, hir::TyKind::TraitObject(..), Ok(snippet), true, Some(last_ty)) = (\n+                // Verify that we're dealing with a return `dyn Trait`\n+                ret_ty.span.overlaps(span),\n+                &ret_ty.kind,\n+                self.tcx.sess.source_map().span_to_snippet(ret_ty.span),\n+                // If any of the return types does not conform to the trait, then we can't\n+                // suggest `impl Trait` nor trait objects, it is a type mismatch error.\n+                all_returns_conform_to_trait,\n+                last_ty,\n+            ) {\n+                (snippet, last_ty)\n+            } else {\n+                return false;\n+            };\n+        err.code(error_code!(E0746));\n+        err.set_primary_message(\"return type cannot have an unboxed trait object\");\n+        err.children.clear();\n+        let impl_trait_msg = \"for information on `impl Trait`, see \\\n+            <https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+            #returning-types-that-implement-traits>\";\n+        let trait_obj_msg = \"for information on trait objects, see \\\n+            <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n+            #using-trait-objects-that-allow-for-values-of-different-types>\";\n+        let has_dyn = snippet.split_whitespace().next().map_or(false, |s| s == \"dyn\");\n+        let trait_obj = if has_dyn { &snippet[4..] } else { &snippet[..] };\n+        if all_returns_have_same_type {\n+            // Suggest `-> impl Trait`.\n+            err.span_suggestion(\n+                ret_ty.span,\n+                &format!(\n+                    \"return `impl {1}` instead, as all return paths are of type `{}`, \\\n+                        which implements `{1}`\",\n+                    last_ty, trait_obj,\n+                ),\n+                format!(\"impl {}\", trait_obj),\n+                Applicability::MachineApplicable,\n+            );\n+            err.note(impl_trait_msg);\n+        } else {\n+            if is_object_safe {\n+                // Suggest `-> Box<dyn Trait>` and `Box::new(returned_value)`.\n+                // Get all the return values and collect their span and suggestion.\n+                let mut suggestions = visitor\n+                    .0\n+                    .iter()\n+                    .map(|expr| {\n+                        (\n+                            expr.span,\n+                            format!(\n+                                \"Box::new({})\",\n+                                self.tcx.sess.source_map().span_to_snippet(expr.span).unwrap()\n+                            ),\n+                        )\n+                    })\n+                    .collect::<Vec<_>>();\n+                // Add the suggestion for the return type.\n+                suggestions.push((\n+                    ret_ty.span,\n+                    format!(\"Box<{}{}>\", if has_dyn { \"\" } else { \"dyn \" }, snippet),\n+                ));\n+                err.multipart_suggestion(\n+                    \"return a boxed trait object instead\",\n+                    suggestions,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            } else {\n+                // This is currently not possible to trigger because E0038 takes precedence, but\n+                // leave it in for completeness in case anything changes in an earlier stage.\n+                err.note(&format!(\n+                    \"if trait `{}` was object safe, you could return a trait object\",\n+                    trait_obj,\n+                ));\n+            }\n+            err.note(trait_obj_msg);\n+            err.note(&format!(\n+                \"if all the returned values were of the same type you could use \\\n+                    `impl {}` as the return type\",\n+                trait_obj,\n+            ));\n+            err.note(impl_trait_msg);\n+            err.note(\"you can create a new `enum` with a variant for each returned type\");\n+        }\n+        true\n+    }\n+\n+    crate fn point_at_returns_when_relevant(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) {\n+        match obligation.cause.code.peel_derives() {\n+            ObligationCauseCode::SizedReturnType => {}\n+            _ => return,\n+        }\n+\n+        let hir = self.tcx.hir();\n+        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n+        let node = hir.find(parent_node);\n+        if let Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body_id), .. })) =\n+            node\n+        {\n+            let body = hir.body(*body_id);\n+            // Point at all the `return`s in the function as they have failed trait bounds.\n+            let mut visitor = ReturnsVisitor(vec![]);\n+            visitor.visit_body(&body);\n+            let tables = self.in_progress_tables.map(|t| t.borrow()).unwrap();\n+            for expr in &visitor.0 {\n+                if let Some(returned_ty) = tables.node_type_opt(expr.hir_id) {\n+                    let ty = self.resolve_vars_if_possible(&returned_ty);\n+                    err.span_label(expr.span, &format!(\"this returned value is of type `{}`\", ty));\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Given some node representing a fn-like thing in the HIR map,\n+    /// returns a span and `ArgKind` information that describes the\n+    /// arguments it expects. This can be supplied to\n+    /// `report_arg_count_mismatch`.\n+    pub fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>) {\n+        match node {\n+            Node::Expr(&hir::Expr {\n+                kind: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n+                ..\n+            }) => (\n+                self.tcx.sess.source_map().def_span(span),\n+                self.tcx\n+                    .hir()\n+                    .body(id)\n+                    .params\n+                    .iter()\n+                    .map(|arg| {\n+                        if let hir::Pat { kind: hir::PatKind::Tuple(ref args, _), span, .. } =\n+                            *arg.pat\n+                        {\n+                            ArgKind::Tuple(\n+                                Some(span),\n+                                args.iter()\n+                                    .map(|pat| {\n+                                        let snippet = self\n+                                            .tcx\n+                                            .sess\n+                                            .source_map()\n+                                            .span_to_snippet(pat.span)\n+                                            .unwrap();\n+                                        (snippet, \"_\".to_owned())\n+                                    })\n+                                    .collect::<Vec<_>>(),\n+                            )\n+                        } else {\n+                            let name =\n+                                self.tcx.sess.source_map().span_to_snippet(arg.pat.span).unwrap();\n+                            ArgKind::Arg(name, \"_\".to_owned())\n+                        }\n+                    })\n+                    .collect::<Vec<ArgKind>>(),\n+            ),\n+            Node::Item(&hir::Item { span, kind: hir::ItemKind::Fn(ref sig, ..), .. })\n+            | Node::ImplItem(&hir::ImplItem {\n+                span,\n+                kind: hir::ImplItemKind::Method(ref sig, _),\n+                ..\n+            })\n+            | Node::TraitItem(&hir::TraitItem {\n+                span,\n+                kind: hir::TraitItemKind::Method(ref sig, _),\n+                ..\n+            }) => (\n+                self.tcx.sess.source_map().def_span(span),\n+                sig.decl\n+                    .inputs\n+                    .iter()\n+                    .map(|arg| match arg.clone().kind {\n+                        hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n+                            Some(arg.span),\n+                            vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()],\n+                        ),\n+                        _ => ArgKind::empty(),\n+                    })\n+                    .collect::<Vec<ArgKind>>(),\n+            ),\n+            Node::Ctor(ref variant_data) => {\n+                let span = variant_data\n+                    .ctor_hir_id()\n+                    .map(|hir_id| self.tcx.hir().span(hir_id))\n+                    .unwrap_or(DUMMY_SP);\n+                let span = self.tcx.sess.source_map().def_span(span);\n+\n+                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n+            }\n+            _ => panic!(\"non-FnLike node found: {:?}\", node),\n+        }\n+    }\n+\n+    /// Reports an error when the number of arguments needed by a\n+    /// trait match doesn't match the number that the expression\n+    /// provides.\n+    pub fn report_arg_count_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_args: Vec<ArgKind>,\n+        found_args: Vec<ArgKind>,\n+        is_closure: bool,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        let kind = if is_closure { \"closure\" } else { \"function\" };\n+\n+        let args_str = |arguments: &[ArgKind], other: &[ArgKind]| {\n+            let arg_length = arguments.len();\n+            let distinct = match &other[..] {\n+                &[ArgKind::Tuple(..)] => true,\n+                _ => false,\n+            };\n+            match (arg_length, arguments.get(0)) {\n+                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n+                    format!(\"a single {}-tuple as argument\", fields.len())\n+                }\n+                _ => format!(\n+                    \"{} {}argument{}\",\n+                    arg_length,\n+                    if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n+                    pluralize!(arg_length)\n+                ),\n+            }\n+        };\n+\n+        let expected_str = args_str(&expected_args, &found_args);\n+        let found_str = args_str(&found_args, &expected_args);\n+\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0593,\n+            \"{} is expected to take {}, but it takes {}\",\n+            kind,\n+            expected_str,\n+            found_str,\n+        );\n+\n+        err.span_label(span, format!(\"expected {} that takes {}\", kind, expected_str));\n+\n+        if let Some(found_span) = found_span {\n+            err.span_label(found_span, format!(\"takes {}\", found_str));\n+\n+            // move |_| { ... }\n+            // ^^^^^^^^-- def_span\n+            //\n+            // move |_| { ... }\n+            // ^^^^^-- prefix\n+            let prefix_span = self.tcx.sess.source_map().span_until_non_whitespace(found_span);\n+            // move |_| { ... }\n+            //      ^^^-- pipe_span\n+            let pipe_span =\n+                if let Some(span) = found_span.trim_start(prefix_span) { span } else { found_span };\n+\n+            // Suggest to take and ignore the arguments with expected_args_length `_`s if\n+            // found arguments is empty (assume the user just wants to ignore args in this case).\n+            // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n+            if found_args.is_empty() && is_closure {\n+                let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n+                err.span_suggestion(\n+                    pipe_span,\n+                    &format!(\n+                        \"consider changing the closure to take and ignore the expected argument{}\",\n+                        if expected_args.len() < 2 { \"\" } else { \"s\" }\n+                    ),\n+                    format!(\"|{}|\", underscores),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+\n+            if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n+                if fields.len() == expected_args.len() {\n+                    let sugg = fields\n+                        .iter()\n+                        .map(|(name, _)| name.to_owned())\n+                        .collect::<Vec<String>>()\n+                        .join(\", \");\n+                    err.span_suggestion(\n+                        found_span,\n+                        \"change the closure to take multiple arguments instead of a single tuple\",\n+                        format!(\"|{}|\", sugg),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n+                if fields.len() == found_args.len() && is_closure {\n+                    let sugg = format!(\n+                        \"|({}){}|\",\n+                        found_args\n+                            .iter()\n+                            .map(|arg| match arg {\n+                                ArgKind::Arg(name, _) => name.to_owned(),\n+                                _ => \"_\".to_owned(),\n+                            })\n+                            .collect::<Vec<String>>()\n+                            .join(\", \"),\n+                        // add type annotations if available\n+                        if found_args.iter().any(|arg| match arg {\n+                            ArgKind::Arg(_, ty) => ty != \"_\",\n+                            _ => false,\n+                        }) {\n+                            format!(\n+                                \": ({})\",\n+                                fields\n+                                    .iter()\n+                                    .map(|(_, ty)| ty.to_owned())\n+                                    .collect::<Vec<String>>()\n+                                    .join(\", \")\n+                            )\n+                        } else {\n+                            String::new()\n+                        },\n+                    );\n+                    err.span_suggestion(\n+                        found_span,\n+                        \"change the closure to accept a tuple instead of individual arguments\",\n+                        sugg,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+\n+        err\n+    }\n+\n+    crate fn report_closure_arg_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_ref: ty::PolyTraitRef<'tcx>,\n+        found: ty::PolyTraitRef<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        crate fn build_fn_sig_string<'tcx>(\n+            tcx: TyCtxt<'tcx>,\n+            trait_ref: &ty::TraitRef<'tcx>,\n+        ) -> String {\n+            let inputs = trait_ref.substs.type_at(1);\n+            let sig = if let ty::Tuple(inputs) = inputs.kind {\n+                tcx.mk_fn_sig(\n+                    inputs.iter().map(|k| k.expect_ty()),\n+                    tcx.mk_ty_infer(ty::TyVar(ty::TyVid { index: 0 })),\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    ::rustc_target::spec::abi::Abi::Rust,\n+                )\n+            } else {\n+                tcx.mk_fn_sig(\n+                    ::std::iter::once(inputs),\n+                    tcx.mk_ty_infer(ty::TyVar(ty::TyVid { index: 0 })),\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    ::rustc_target::spec::abi::Abi::Rust,\n+                )\n+            };\n+            ty::Binder::bind(sig).to_string()\n+        }\n+\n+        let argument_is_closure = expected_ref.skip_binder().substs.type_at(0).is_closure();\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0631,\n+            \"type mismatch in {} arguments\",\n+            if argument_is_closure { \"closure\" } else { \"function\" }\n+        );\n+\n+        let found_str = format!(\n+            \"expected signature of `{}`\",\n+            build_fn_sig_string(self.tcx, found.skip_binder())\n+        );\n+        err.span_label(span, found_str);\n+\n+        let found_span = found_span.unwrap_or(span);\n+        let expected_str = format!(\n+            \"found signature of `{}`\",\n+            build_fn_sig_string(self.tcx, expected_ref.skip_binder())\n+        );\n+        err.span_label(found_span, expected_str);\n+\n+        err\n+    }\n+}\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    crate fn suggest_fully_qualified_path(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        def_id: DefId,\n+        span: Span,\n+        trait_ref: DefId,\n+    ) {\n+        if let Some(assoc_item) = self.tcx.opt_associated_item(def_id) {\n+            if let ty::AssocKind::Const | ty::AssocKind::Type = assoc_item.kind {\n+                err.note(&format!(\n+                    \"{}s cannot be accessed directly on a `trait`, they can only be \\\n+                        accessed through a specific `impl`\",\n+                    assoc_item.kind.suggestion_descr(),\n+                ));\n+                err.span_suggestion(\n+                    span,\n+                    \"use the fully qualified path to an implementation\",\n+                    format!(\"<Type as {}>::{}\", self.tcx.def_path_str(trait_ref), assoc_item.ident),\n+                    Applicability::HasPlaceholders,\n+                );\n+            }\n+        }\n+    }\n+\n+    /// Adds an async-await specific note to the diagnostic when the future does not implement\n+    /// an auto trait because of a captured type.\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// note: future does not implement `Qux` as this value is used across an await\n+    ///   --> $DIR/issue-64130-3-other.rs:17:5\n+    ///    |\n+    /// LL |     let x = Foo;\n+    ///    |         - has type `Foo`\n+    /// LL |     baz().await;\n+    ///    |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n+    /// LL | }\n+    ///    | - `x` is later dropped here\n+    /// ```\n+    ///\n+    /// When the diagnostic does not implement `Send` or `Sync` specifically, then the diagnostic\n+    /// is \"replaced\" with a different message and a more specific error.\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// error: future cannot be sent between threads safely\n+    ///   --> $DIR/issue-64130-2-send.rs:21:5\n+    ///    |\n+    /// LL | fn is_send<T: Send>(t: T) { }\n+    ///    |    -------    ---- required by this bound in `is_send`\n+    /// ...\n+    /// LL |     is_send(bar());\n+    ///    |     ^^^^^^^ future returned by `bar` is not send\n+    ///    |\n+    ///    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not\n+    ///            implemented for `Foo`\n+    /// note: future is not send as this value is used across an await\n+    ///   --> $DIR/issue-64130-2-send.rs:15:5\n+    ///    |\n+    /// LL |     let x = Foo;\n+    ///    |         - has type `Foo`\n+    /// LL |     baz().await;\n+    ///    |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n+    /// LL | }\n+    ///    | - `x` is later dropped here\n+    /// ```\n+    ///\n+    /// Returns `true` if an async-await specific note was added to the diagnostic.\n+    crate fn maybe_note_obligation_cause_for_async_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool {\n+        debug!(\n+            \"maybe_note_obligation_cause_for_async_await: obligation.predicate={:?} \\\n+                obligation.cause.span={:?}\",\n+            obligation.predicate, obligation.cause.span\n+        );\n+        let source_map = self.tcx.sess.source_map();\n+\n+        // Attempt to detect an async-await error by looking at the obligation causes, looking\n+        // for a generator to be present.\n+        //\n+        // When a future does not implement a trait because of a captured type in one of the\n+        // generators somewhere in the call stack, then the result is a chain of obligations.\n+        //\n+        // Given a `async fn` A that calls a `async fn` B which captures a non-send type and that\n+        // future is passed as an argument to a function C which requires a `Send` type, then the\n+        // chain looks something like this:\n+        //\n+        // - `BuiltinDerivedObligation` with a generator witness (B)\n+        // - `BuiltinDerivedObligation` with a generator (B)\n+        // - `BuiltinDerivedObligation` with `std::future::GenFuture` (B)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (B)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (B)\n+        // - `BuiltinDerivedObligation` with a generator witness (A)\n+        // - `BuiltinDerivedObligation` with a generator (A)\n+        // - `BuiltinDerivedObligation` with `std::future::GenFuture` (A)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (A)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (A)\n+        // - `BindingObligation` with `impl_send (Send requirement)\n+        //\n+        // The first obligation in the chain is the most useful and has the generator that captured\n+        // the type. The last generator has information about where the bound was introduced. At\n+        // least one generator should be present for this diagnostic to be modified.\n+        let (mut trait_ref, mut target_ty) = match obligation.predicate {\n+            ty::Predicate::Trait(p) => {\n+                (Some(p.skip_binder().trait_ref), Some(p.skip_binder().self_ty()))\n+            }\n+            _ => (None, None),\n+        };\n+        let mut generator = None;\n+        let mut last_generator = None;\n+        let mut next_code = Some(&obligation.cause.code);\n+        while let Some(code) = next_code {\n+            debug!(\"maybe_note_obligation_cause_for_async_await: code={:?}\", code);\n+            match code {\n+                ObligationCauseCode::BuiltinDerivedObligation(derived_obligation)\n+                | ObligationCauseCode::ImplDerivedObligation(derived_obligation) => {\n+                    let ty = derived_obligation.parent_trait_ref.self_ty();\n+                    debug!(\n+                        \"maybe_note_obligation_cause_for_async_await: \\\n+                            parent_trait_ref={:?} self_ty.kind={:?}\",\n+                        derived_obligation.parent_trait_ref, ty.kind\n+                    );\n+\n+                    match ty.kind {\n+                        ty::Generator(did, ..) => {\n+                            generator = generator.or(Some(did));\n+                            last_generator = Some(did);\n+                        }\n+                        ty::GeneratorWitness(..) => {}\n+                        _ if generator.is_none() => {\n+                            trait_ref = Some(*derived_obligation.parent_trait_ref.skip_binder());\n+                            target_ty = Some(ty);\n+                        }\n+                        _ => {}\n+                    }\n+\n+                    next_code = Some(derived_obligation.parent_code.as_ref());\n+                }\n+                _ => break,\n+            }\n+        }\n+\n+        // Only continue if a generator was found.\n+        debug!(\n+            \"maybe_note_obligation_cause_for_async_await: generator={:?} trait_ref={:?} \\\n+                target_ty={:?}\",\n+            generator, trait_ref, target_ty\n+        );\n+        let (generator_did, trait_ref, target_ty) = match (generator, trait_ref, target_ty) {\n+            (Some(generator_did), Some(trait_ref), Some(target_ty)) => {\n+                (generator_did, trait_ref, target_ty)\n+            }\n+            _ => return false,\n+        };\n+\n+        let span = self.tcx.def_span(generator_did);\n+\n+        // Do not ICE on closure typeck (#66868).\n+        if self.tcx.hir().as_local_hir_id(generator_did).is_none() {\n+            return false;\n+        }\n+\n+        // Get the tables from the infcx if the generator is the function we are\n+        // currently type-checking; otherwise, get them by performing a query.\n+        // This is needed to avoid cycles.\n+        let in_progress_tables = self.in_progress_tables.map(|t| t.borrow());\n+        let generator_did_root = self.tcx.closure_base_def_id(generator_did);\n+        debug!(\n+            \"maybe_note_obligation_cause_for_async_await: generator_did={:?} \\\n+             generator_did_root={:?} in_progress_tables.local_id_root={:?} span={:?}\",\n+            generator_did,\n+            generator_did_root,\n+            in_progress_tables.as_ref().map(|t| t.local_id_root),\n+            span\n+        );\n+        let query_tables;\n+        let tables: &TypeckTables<'tcx> = match &in_progress_tables {\n+            Some(t) if t.local_id_root == Some(generator_did_root) => t,\n+            _ => {\n+                query_tables = self.tcx.typeck_tables_of(generator_did);\n+                &query_tables\n+            }\n+        };\n+\n+        // Look for a type inside the generator interior that matches the target type to get\n+        // a span.\n+        let target_ty_erased = self.tcx.erase_regions(&target_ty);\n+        let target_span = tables\n+            .generator_interior_types\n+            .iter()\n+            .find(|ty::GeneratorInteriorTypeCause { ty, .. }| {\n+                // Careful: the regions for types that appear in the\n+                // generator interior are not generally known, so we\n+                // want to erase them when comparing (and anyway,\n+                // `Send` and other bounds are generally unaffected by\n+                // the choice of region).  When erasing regions, we\n+                // also have to erase late-bound regions. This is\n+                // because the types that appear in the generator\n+                // interior generally contain \"bound regions\" to\n+                // represent regions that are part of the suspended\n+                // generator frame. Bound regions are preserved by\n+                // `erase_regions` and so we must also call\n+                // `erase_late_bound_regions`.\n+                let ty_erased = self.tcx.erase_late_bound_regions(&ty::Binder::bind(*ty));\n+                let ty_erased = self.tcx.erase_regions(&ty_erased);\n+                let eq = ty::TyS::same_type(ty_erased, target_ty_erased);\n+                debug!(\n+                    \"maybe_note_obligation_cause_for_async_await: ty_erased={:?} \\\n+                        target_ty_erased={:?} eq={:?}\",\n+                    ty_erased, target_ty_erased, eq\n+                );\n+                eq\n+            })\n+            .map(|ty::GeneratorInteriorTypeCause { span, scope_span, expr, .. }| {\n+                (span, source_map.span_to_snippet(*span), scope_span, expr)\n+            });\n+\n+        debug!(\n+            \"maybe_note_obligation_cause_for_async_await: target_ty={:?} \\\n+                generator_interior_types={:?} target_span={:?}\",\n+            target_ty, tables.generator_interior_types, target_span\n+        );\n+        if let Some((target_span, Ok(snippet), scope_span, expr)) = target_span {\n+            self.note_obligation_cause_for_async_await(\n+                err,\n+                *target_span,\n+                scope_span,\n+                *expr,\n+                snippet,\n+                generator_did,\n+                last_generator,\n+                trait_ref,\n+                target_ty,\n+                tables,\n+                obligation,\n+                next_code,\n+            );\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Unconditionally adds the diagnostic note described in\n+    /// `maybe_note_obligation_cause_for_async_await`'s documentation comment.\n+    crate fn note_obligation_cause_for_async_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        target_span: Span,\n+        scope_span: &Option<Span>,\n+        expr: Option<hir::HirId>,\n+        snippet: String,\n+        first_generator: DefId,\n+        last_generator: Option<DefId>,\n+        trait_ref: ty::TraitRef<'_>,\n+        target_ty: Ty<'tcx>,\n+        tables: &ty::TypeckTables<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+        next_code: Option<&ObligationCauseCode<'tcx>>,\n+    ) {\n+        let source_map = self.tcx.sess.source_map();\n+\n+        let is_async_fn = self\n+            .tcx\n+            .parent(first_generator)\n+            .map(|parent_did| self.tcx.asyncness(parent_did))\n+            .map(|parent_asyncness| parent_asyncness == hir::IsAsync::Async)\n+            .unwrap_or(false);\n+        let is_async_move = self\n+            .tcx\n+            .hir()\n+            .as_local_hir_id(first_generator)\n+            .and_then(|hir_id| self.tcx.hir().maybe_body_owned_by(hir_id))\n+            .map(|body_id| self.tcx.hir().body(body_id))\n+            .and_then(|body| body.generator_kind())\n+            .map(|generator_kind| match generator_kind {\n+                hir::GeneratorKind::Async(..) => true,\n+                _ => false,\n+            })\n+            .unwrap_or(false);\n+        let await_or_yield = if is_async_fn || is_async_move { \"await\" } else { \"yield\" };\n+\n+        // Special case the primary error message when send or sync is the trait that was\n+        // not implemented.\n+        let is_send = self.tcx.is_diagnostic_item(sym::send_trait, trait_ref.def_id);\n+        let is_sync = self.tcx.is_diagnostic_item(sym::sync_trait, trait_ref.def_id);\n+        let hir = self.tcx.hir();\n+        let trait_explanation = if is_send || is_sync {\n+            let (trait_name, trait_verb) =\n+                if is_send { (\"`Send`\", \"sent\") } else { (\"`Sync`\", \"shared\") };\n+\n+            err.clear_code();\n+            err.set_primary_message(format!(\n+                \"future cannot be {} between threads safely\",\n+                trait_verb\n+            ));\n+\n+            let original_span = err.span.primary_span().unwrap();\n+            let mut span = MultiSpan::from_span(original_span);\n+\n+            let message = if let Some(name) = last_generator\n+                .and_then(|generator_did| self.tcx.parent(generator_did))\n+                .and_then(|parent_did| hir.as_local_hir_id(parent_did))\n+                .and_then(|parent_hir_id| hir.opt_name(parent_hir_id))\n+            {\n+                format!(\"future returned by `{}` is not {}\", name, trait_name)\n+            } else {\n+                format!(\"future is not {}\", trait_name)\n+            };\n+\n+            span.push_span_label(original_span, message);\n+            err.set_span(span);\n+\n+            format!(\"is not {}\", trait_name)\n+        } else {\n+            format!(\"does not implement `{}`\", trait_ref.print_only_trait_path())\n+        };\n+\n+        // Look at the last interior type to get a span for the `.await`.\n+        let await_span = tables.generator_interior_types.iter().map(|t| t.span).last().unwrap();\n+        let mut span = MultiSpan::from_span(await_span);\n+        span.push_span_label(\n+            await_span,\n+            format!(\"{} occurs here, with `{}` maybe used later\", await_or_yield, snippet),\n+        );\n+\n+        span.push_span_label(target_span, format!(\"has type `{}`\", target_ty));\n+\n+        // If available, use the scope span to annotate the drop location.\n+        if let Some(scope_span) = scope_span {\n+            span.push_span_label(\n+                source_map.end_point(*scope_span),\n+                format!(\"`{}` is later dropped here\", snippet),\n+            );\n+        }\n+\n+        err.span_note(\n+            span,\n+            &format!(\n+                \"future {} as this value is used across an {}\",\n+                trait_explanation, await_or_yield,\n+            ),\n+        );\n+\n+        if let Some(expr_id) = expr {\n+            let expr = hir.expect_expr(expr_id);\n+            let is_ref = tables.expr_adjustments(expr).iter().any(|adj| adj.is_region_borrow());\n+            let parent = hir.get_parent_node(expr_id);\n+            if let Some(hir::Node::Expr(e)) = hir.find(parent) {\n+                let method_span = hir.span(parent);\n+                if tables.is_method_call(e) && is_ref {\n+                    err.span_help(\n+                        method_span,\n+                        \"consider moving this method call into a `let` \\\n+                        binding to create a shorter lived borrow\",\n+                    );\n+                }\n+            }\n+        }\n+\n+        // Add a note for the item obligation that remains - normally a note pointing to the\n+        // bound that introduced the obligation (e.g. `T: Send`).\n+        debug!(\"note_obligation_cause_for_async_await: next_code={:?}\", next_code);\n+        self.note_obligation_cause_code(\n+            err,\n+            &obligation.predicate,\n+            next_code.unwrap(),\n+            &mut Vec::new(),\n+        );\n+    }\n+\n+    crate fn note_obligation_cause_code<T>(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        predicate: &T,\n+        cause_code: &ObligationCauseCode<'tcx>,\n+        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+    ) where\n+        T: fmt::Display,\n+    {\n+        let tcx = self.tcx;\n+        match *cause_code {\n+            ObligationCauseCode::ExprAssignable\n+            | ObligationCauseCode::MatchExpressionArm { .. }\n+            | ObligationCauseCode::Pattern { .. }\n+            | ObligationCauseCode::IfExpression { .. }\n+            | ObligationCauseCode::IfExpressionWithNoElse\n+            | ObligationCauseCode::MainFunctionType\n+            | ObligationCauseCode::StartFunctionType\n+            | ObligationCauseCode::IntrinsicType\n+            | ObligationCauseCode::MethodReceiver\n+            | ObligationCauseCode::ReturnNoExpression\n+            | ObligationCauseCode::MiscObligation => {}\n+            ObligationCauseCode::SliceOrArrayElem => {\n+                err.note(\"slice and array elements must have `Sized` type\");\n+            }\n+            ObligationCauseCode::TupleElem => {\n+                err.note(\"only the last element of a tuple may have a dynamically sized type\");\n+            }\n+            ObligationCauseCode::ProjectionWf(data) => {\n+                err.note(&format!(\"required so that the projection `{}` is well-formed\", data,));\n+            }\n+            ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n+                err.note(&format!(\n+                    \"required so that reference `{}` does not outlive its referent\",\n+                    ref_ty,\n+                ));\n+            }\n+            ObligationCauseCode::ObjectTypeBound(object_ty, region) => {\n+                err.note(&format!(\n+                    \"required so that the lifetime bound of `{}` for `{}` is satisfied\",\n+                    region, object_ty,\n+                ));\n+            }\n+            ObligationCauseCode::ItemObligation(item_def_id) => {\n+                let item_name = tcx.def_path_str(item_def_id);\n+                let msg = format!(\"required by `{}`\", item_name);\n+\n+                if let Some(sp) = tcx.hir().span_if_local(item_def_id) {\n+                    let sp = tcx.sess.source_map().def_span(sp);\n+                    err.span_label(sp, &msg);\n+                } else {\n+                    err.note(&msg);\n+                }\n+            }\n+            ObligationCauseCode::BindingObligation(item_def_id, span) => {\n+                let item_name = tcx.def_path_str(item_def_id);\n+                let msg = format!(\"required by this bound in `{}`\", item_name);\n+                if let Some(ident) = tcx.opt_item_name(item_def_id) {\n+                    err.span_label(ident.span, \"\");\n+                }\n+                if span != DUMMY_SP {\n+                    err.span_label(span, &msg);\n+                } else {\n+                    err.note(&msg);\n+                }\n+            }\n+            ObligationCauseCode::ObjectCastObligation(object_ty) => {\n+                err.note(&format!(\n+                    \"required for the cast to the object type `{}`\",\n+                    self.ty_to_string(object_ty)\n+                ));\n+            }\n+            ObligationCauseCode::Coercion { source: _, target } => {\n+                err.note(&format!(\"required by cast to type `{}`\", self.ty_to_string(target)));\n+            }\n+            ObligationCauseCode::RepeatVec(suggest_const_in_array_repeat_expressions) => {\n+                err.note(\n+                    \"the `Copy` trait is required because the repeated element will be copied\",\n+                );\n+                if suggest_const_in_array_repeat_expressions {\n+                    err.note(\n+                        \"this array initializer can be evaluated at compile-time, for more \\\n+                         information, see issue \\\n+                         https://github.com/rust-lang/rust/issues/49147\",\n+                    );\n+                    if tcx.sess.opts.unstable_features.is_nightly_build() {\n+                        err.help(\n+                            \"add `#![feature(const_in_array_repeat_expressions)]` to the \\\n+                             crate attributes to enable\",\n+                        );\n+                    }\n+                }\n+            }\n+            ObligationCauseCode::VariableType(_) => {\n+                err.note(\"all local variables must have a statically known size\");\n+                if !self.tcx.features().unsized_locals {\n+                    err.help(\"unsized locals are gated as an unstable feature\");\n+                }\n+            }\n+            ObligationCauseCode::SizedArgumentType => {\n+                err.note(\"all function arguments must have a statically known size\");\n+                if !self.tcx.features().unsized_locals {\n+                    err.help(\"unsized locals are gated as an unstable feature\");\n+                }\n+            }\n+            ObligationCauseCode::SizedReturnType => {\n+                err.note(\"the return type of a function must have a statically known size\");\n+            }\n+            ObligationCauseCode::SizedYieldType => {\n+                err.note(\"the yield type of a generator must have a statically known size\");\n+            }\n+            ObligationCauseCode::AssignmentLhsSized => {\n+                err.note(\"the left-hand-side of an assignment must have a statically known size\");\n+            }\n+            ObligationCauseCode::TupleInitializerSized => {\n+                err.note(\"tuples must have a statically known size to be initialized\");\n+            }\n+            ObligationCauseCode::StructInitializerSized => {\n+                err.note(\"structs must have a statically known size to be initialized\");\n+            }\n+            ObligationCauseCode::FieldSized { adt_kind: ref item, last } => match *item {\n+                AdtKind::Struct => {\n+                    if last {\n+                        err.note(\n+                            \"the last field of a packed struct may only have a \\\n+                             dynamically sized type if it does not need drop to be run\",\n+                        );\n+                    } else {\n+                        err.note(\n+                            \"only the last field of a struct may have a dynamically sized type\",\n+                        );\n+                    }\n+                }\n+                AdtKind::Union => {\n+                    err.note(\"no field of a union may have a dynamically sized type\");\n+                }\n+                AdtKind::Enum => {\n+                    err.note(\"no field of an enum variant may have a dynamically sized type\");\n+                }\n+            },\n+            ObligationCauseCode::ConstSized => {\n+                err.note(\"constant expressions must have a statically known size\");\n+            }\n+            ObligationCauseCode::ConstPatternStructural => {\n+                err.note(\"constants used for pattern-matching must derive `PartialEq` and `Eq`\");\n+            }\n+            ObligationCauseCode::SharedStatic => {\n+                err.note(\"shared static variables must have a type that implements `Sync`\");\n+            }\n+            ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                let ty = parent_trait_ref.skip_binder().self_ty();\n+                err.note(&format!(\"required because it appears within the type `{}`\", ty));\n+                obligated_types.push(ty);\n+\n+                let parent_predicate = parent_trait_ref.to_predicate();\n+                if !self.is_recursive_obligation(obligated_types, &data.parent_code) {\n+                    self.note_obligation_cause_code(\n+                        err,\n+                        &parent_predicate,\n+                        &data.parent_code,\n+                        obligated_types,\n+                    );\n+                }\n+            }\n+            ObligationCauseCode::ImplDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                err.note(&format!(\n+                    \"required because of the requirements on the impl of `{}` for `{}`\",\n+                    parent_trait_ref.print_only_trait_path(),\n+                    parent_trait_ref.skip_binder().self_ty()\n+                ));\n+                let parent_predicate = parent_trait_ref.to_predicate();\n+                self.note_obligation_cause_code(\n+                    err,\n+                    &parent_predicate,\n+                    &data.parent_code,\n+                    obligated_types,\n+                );\n+            }\n+            ObligationCauseCode::CompareImplMethodObligation { .. } => {\n+                err.note(&format!(\n+                    \"the requirement `{}` appears on the impl method \\\n+                     but not on the corresponding trait method\",\n+                    predicate\n+                ));\n+            }\n+            ObligationCauseCode::CompareImplTypeObligation { .. } => {\n+                err.note(&format!(\n+                    \"the requirement `{}` appears on the associated impl type \\\n+                     but not on the corresponding associated trait type\",\n+                    predicate\n+                ));\n+            }\n+            ObligationCauseCode::ReturnType\n+            | ObligationCauseCode::ReturnValue(_)\n+            | ObligationCauseCode::BlockTailExpression(_) => (),\n+            ObligationCauseCode::TrivialBound => {\n+                err.help(\"see issue #48214\");\n+                if tcx.sess.opts.unstable_features.is_nightly_build() {\n+                    err.help(\"add `#![feature(trivial_bounds)]` to the crate attributes to enable\");\n+                }\n+            }\n+            ObligationCauseCode::AssocTypeBound(ref data) => {\n+                err.span_label(data.original, \"associated type defined here\");\n+                if let Some(sp) = data.impl_span {\n+                    err.span_label(sp, \"in this `impl` item\");\n+                }\n+                for sp in &data.bounds {\n+                    err.span_label(*sp, \"restricted in this bound\");\n+                }\n+            }\n+        }\n+    }\n+\n+    crate fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>) {\n+        let current_limit = self.tcx.sess.recursion_limit.get();\n+        let suggested_limit = current_limit * 2;\n+        err.help(&format!(\n+            \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+            suggested_limit\n+        ));\n+    }\n+}\n+\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_param(\n+    generics: &hir::Generics<'_>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+    source_map: &SourceMap,\n+    span: Span,\n+) -> bool {\n+    let restrict_msg = \"consider further restricting this bound\";\n+    if let Some(param) =\n+        generics.params.iter().filter(|p| p.name.ident().as_str() == param_name).next()\n+    {\n+        if param_name.starts_with(\"impl \") {\n+            // `impl Trait` in argument:\n+            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n+            err.span_suggestion(\n+                param.span,\n+                restrict_msg,\n+                // `impl CurrentTrait + MissingTrait`\n+                format!(\"{} + {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if generics.where_clause.predicates.is_empty() && param.bounds.is_empty() {\n+            // If there are no bounds whatsoever, suggest adding a constraint\n+            // to the type parameter:\n+            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            err.span_suggestion(\n+                param.span,\n+                \"consider restricting this bound\",\n+                format!(\"{}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if !generics.where_clause.predicates.is_empty() {\n+            // There is a `where` clause, so suggest expanding it:\n+            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n+            err.span_suggestion(\n+                generics.where_clause.span().unwrap().shrink_to_hi(),\n+                &format!(\"consider further restricting type parameter `{}`\", param_name),\n+                format!(\", {}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            // If there is no `where` clause lean towards constraining to the\n+            // type parameter:\n+            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+            let sp = param.span.with_hi(span.hi());\n+            let span = source_map.span_through_char(sp, ':');\n+            if sp != param.span && sp != span {\n+                // Only suggest if we have high certainty that the span\n+                // covers the colon in `foo<T: Trait>`.\n+                err.span_suggestion(\n+                    span,\n+                    restrict_msg,\n+                    format!(\"{}: {} + \", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_label(\n+                    param.span,\n+                    &format!(\"consider adding a `where {}: {}` bound\", param_name, constraint),\n+                );\n+            }\n+        }\n+        return true;\n+    }\n+    false\n+}\n+\n+/// Collect all the returned expressions within the input expression.\n+/// Used to point at the return spans when we want to suggest some change to them.\n+struct ReturnsVisitor<'v>(Vec<&'v hir::Expr<'v>>);\n+\n+impl<'v> Visitor<'v> for ReturnsVisitor<'v> {\n+    type Map = rustc::hir::map::Map<'v>;\n+\n+    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<'_, Self::Map> {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+        if let hir::ExprKind::Ret(Some(ex)) = ex.kind {\n+            self.0.push(ex);\n+        }\n+        hir::intravisit::walk_expr(self, ex);\n+    }\n+\n+    fn visit_body(&mut self, body: &'v hir::Body<'v>) {\n+        if body.generator_kind().is_none() {\n+            if let hir::ExprKind::Block(block, None) = body.value.kind {\n+                if let Some(expr) = block.expr {\n+                    self.0.push(expr);\n+                }\n+            }\n+        }\n+        hir::intravisit::walk_body(self, body);\n+    }\n+}"}, {"sha": "2e5da2b038254f7ab45131821d959b34b13d29c0", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -155,8 +155,8 @@ pub struct ObligationCause<'tcx> {\n     pub code: ObligationCauseCode<'tcx>,\n }\n \n-impl<'tcx> ObligationCause<'tcx> {\n-    pub fn span(&self, tcx: TyCtxt<'tcx>) -> Span {\n+impl ObligationCause<'_> {\n+    pub fn span(&self, tcx: TyCtxt<'_>) -> Span {\n         match self.code {\n             ObligationCauseCode::CompareImplMethodObligation { .. }\n             | ObligationCauseCode::MainFunctionType\n@@ -1171,6 +1171,17 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n+impl ObligationCauseCode<'_> {\n+    // Return the base obligation, ignoring derived obligations.\n+    pub fn peel_derives(&self) -> &Self {\n+        let mut base_cause = self;\n+        while let BuiltinDerivedObligation(cause) | ImplDerivedObligation(cause) = base_cause {\n+            base_cause = &cause.parent_code;\n+        }\n+        base_cause\n+    }\n+}\n+\n impl<'tcx, N> Vtable<'tcx, N> {\n     pub fn nested_obligations(self) -> Vec<N> {\n         match self {"}, {"sha": "217ca0ca3f6f51d38e464b578ddadaaf16593370", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -244,9 +244,9 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(ref inner, ..) => {\n                 if let Some(principal) = inner.principal() {\n-                    format!(\"trait `{}`\", tcx.def_path_str(principal.def_id())).into()\n+                    format!(\"trait object `dyn {}`\", tcx.def_path_str(principal.def_id())).into()\n                 } else {\n-                    \"trait\".into()\n+                    \"trait object\".into()\n                 }\n             }\n             ty::Closure(..) => \"closure\".into(),"}, {"sha": "180ccb15977dd5126b2b9617f75efbedb166fe1f", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -414,6 +414,7 @@ E0742: include_str!(\"./error_codes/E0742.md\"),\n E0743: include_str!(\"./error_codes/E0743.md\"),\n E0744: include_str!(\"./error_codes/E0744.md\"),\n E0745: include_str!(\"./error_codes/E0745.md\"),\n+E0746: include_str!(\"./error_codes/E0746.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "16b2722f0eac2b47519db7523443dc15c2eb87f0", "filename": "src/librustc_error_codes/error_codes/E0746.md", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -0,0 +1,138 @@\n+Return types cannot be `dyn Trait`s as they must be `Sized`.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0277\n+# // FIXME: after E0746 is in beta, change the above\n+trait T {\n+    fn bar(&self);\n+}\n+struct S(usize);\n+impl T for S {\n+    fn bar(&self) {}\n+}\n+\n+// Having the trait `T` as return type is invalid because\n+// unboxed trait objects do not have a statically known size:\n+fn foo() -> dyn T {\n+    S(42)\n+}\n+```\n+\n+To avoid the error there are a couple of options.\n+\n+If there is a single type involved, you can use [`impl Trait`]:\n+\n+```\n+# trait T {\n+#     fn bar(&self);\n+# }\n+# struct S(usize);\n+# impl T for S {\n+#     fn bar(&self) {}\n+# }\n+// The compiler will select `S(usize)` as the materialized return type of this\n+// function, but callers will only know that the return type implements `T`.\n+fn foo() -> impl T {\n+    S(42)\n+}\n+```\n+\n+If there are multiple types involved, the only way you care to interact with\n+them is through the trait's interface, and having to rely on dynamic dispatch\n+is acceptable, then you can use [trait objects] with `Box`, or other container\n+types like `Rc` or `Arc`:\n+\n+```\n+# trait T {\n+#     fn bar(&self);\n+# }\n+# struct S(usize);\n+# impl T for S {\n+#     fn bar(&self) {}\n+# }\n+struct O(&'static str);\n+impl T for O {\n+    fn bar(&self) {}\n+}\n+\n+// This now returns a \"trait object\" and callers are only be able to access\n+// associated items from `T`.\n+fn foo(x: bool) -> Box<dyn T> {\n+    if x {\n+        Box::new(S(42))\n+    } else {\n+        Box::new(O(\"val\"))\n+    }\n+}\n+```\n+\n+Finally, if you wish to still be able to access the original type, you can\n+create a new `enum` with a variant for each type:\n+\n+```\n+# trait T {\n+#     fn bar(&self);\n+# }\n+# struct S(usize);\n+# impl T for S {\n+#     fn bar(&self) {}\n+# }\n+# struct O(&'static str);\n+# impl T for O {\n+#     fn bar(&self) {}\n+# }\n+enum E {\n+    S(S),\n+    O(O),\n+}\n+\n+// The caller can access the original types directly, but it needs to match on\n+// the returned `enum E`.\n+fn foo(x: bool) -> E {\n+    if x {\n+        E::S(S(42))\n+    } else {\n+        E::O(O(\"val\"))\n+    }\n+}\n+```\n+\n+You can even implement the `trait` on the returned `enum` so the callers\n+*don't* have to match on the returned value to invoke the associated items:\n+\n+```\n+# trait T {\n+#     fn bar(&self);\n+# }\n+# struct S(usize);\n+# impl T for S {\n+#     fn bar(&self) {}\n+# }\n+# struct O(&'static str);\n+# impl T for O {\n+#     fn bar(&self) {}\n+# }\n+# enum E {\n+#     S(S),\n+#     O(O),\n+# }\n+impl T for E {\n+    fn bar(&self) {\n+        match self {\n+            E::S(s) => s.bar(),\n+            E::O(o) => o.bar(),\n+        }\n+    }\n+}\n+```\n+\n+If you decide to use trait objects, be aware that these rely on\n+[dynamic dispatch], which has performance implications, as the compiler needs\n+to emit code that will figure out which method to call *at runtime* instead of\n+during compilation. Using trait objects we are trading flexibility for\n+performance.\n+\n+[`impl Trait`]: https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits\n+[trait objects]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n+[dynamic dispatch]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch"}, {"sha": "5c1d600c837c4b07692683b522e6cf3bc5acd0eb", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -377,6 +377,13 @@ pub enum GenericBound<'hir> {\n }\n \n impl GenericBound<'_> {\n+    pub fn trait_def_id(&self) -> Option<DefId> {\n+        match self {\n+            GenericBound::Trait(data, _) => Some(data.trait_ref.trait_def_id()),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn span(&self) -> Span {\n         match self {\n             &GenericBound::Trait(ref t, ..) => t.span,"}, {"sha": "a32fbff7bfe2df233b19dffc9c691a88395687ac", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 99, "deletions": 10, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -50,10 +50,12 @@\n //! sort of a minor point so I've opted to leave it for later -- after all,\n //! we may want to adjust precisely when coercions occur.\n \n+use crate::astconv::AstConv;\n use crate::check::{FnCtxt, Needs};\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::infer::{Coercion, InferOk, InferResult};\n use rustc::session::parse::feature_err;\n+use rustc::traits::object_safety_violations;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -67,8 +69,8 @@ use rustc_error_codes::*;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_span;\n use rustc_span::symbol::sym;\n+use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n@@ -1222,6 +1224,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 };\n \n                 let mut err;\n+                let mut unsized_return = false;\n                 match cause.code {\n                     ObligationCauseCode::ReturnNoExpression => {\n                         err = struct_span_err!(\n@@ -1243,6 +1246,9 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                             parent_id,\n                             expression.map(|expr| (expr, blk_id)),\n                         );\n+                        if !fcx.tcx.features().unsized_locals {\n+                            unsized_return = self.is_return_ty_unsized(fcx, blk_id);\n+                        }\n                     }\n                     ObligationCauseCode::ReturnValue(id) => {\n                         err = self.report_return_mismatched_types(\n@@ -1254,6 +1260,10 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                             id,\n                             None,\n                         );\n+                        if !fcx.tcx.features().unsized_locals {\n+                            let id = fcx.tcx.hir().get_parent_node(id);\n+                            unsized_return = self.is_return_ty_unsized(fcx, id);\n+                        }\n                     }\n                     _ => {\n                         err = fcx.report_mismatched_types(cause, expected, found, coercion_error);\n@@ -1282,7 +1292,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     .filter(|e| fcx.is_assign_to_bool(e, self.expected_ty()))\n                     .is_some();\n \n-                err.emit_unless(assign_to_bool);\n+                err.emit_unless(assign_to_bool || unsized_return);\n \n                 self.final_ty = Some(fcx.tcx.types.err);\n             }\n@@ -1302,7 +1312,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         let mut err = fcx.report_mismatched_types(cause, expected, found, ty_err);\n \n         let mut pointing_at_return_type = false;\n-        let mut return_sp = None;\n+        let mut fn_output = None;\n \n         // Verify that this is a tail expression of a function, otherwise the\n         // label pointing out the cause for the type coercion will be wrong\n@@ -1339,19 +1349,98 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 );\n             }\n             if !pointing_at_return_type {\n-                return_sp = Some(fn_decl.output.span()); // `impl Trait` return type\n+                fn_output = Some(&fn_decl.output); // `impl Trait` return type\n             }\n         }\n-        if let (Some(sp), Some(return_sp)) = (fcx.ret_coercion_span.borrow().as_ref(), return_sp) {\n-            err.span_label(return_sp, \"expected because this return type...\");\n-            err.span_label( *sp, format!(\n-                \"...is found to be `{}` here\",\n-                fcx.resolve_vars_with_obligations(expected),\n-            ));\n+        if let (Some(sp), Some(fn_output)) = (fcx.ret_coercion_span.borrow().as_ref(), fn_output) {\n+            self.add_impl_trait_explanation(&mut err, fcx, expected, *sp, fn_output);\n         }\n         err\n     }\n \n+    fn add_impl_trait_explanation<'a>(\n+        &self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        expected: Ty<'tcx>,\n+        sp: Span,\n+        fn_output: &hir::FunctionRetTy<'_>,\n+    ) {\n+        let return_sp = fn_output.span();\n+        err.span_label(return_sp, \"expected because this return type...\");\n+        err.span_label(\n+            sp,\n+            format!(\"...is found to be `{}` here\", fcx.resolve_vars_with_obligations(expected)),\n+        );\n+        let impl_trait_msg = \"for information on `impl Trait`, see \\\n+                <https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                #returning-types-that-implement-traits>\";\n+        let trait_obj_msg = \"for information on trait objects, see \\\n+                <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n+                #using-trait-objects-that-allow-for-values-of-different-types>\";\n+        err.note(\"to return `impl Trait`, all returned values must be of the same type\");\n+        err.note(impl_trait_msg);\n+        let snippet = fcx\n+            .tcx\n+            .sess\n+            .source_map()\n+            .span_to_snippet(return_sp)\n+            .unwrap_or_else(|_| \"dyn Trait\".to_string());\n+        let mut snippet_iter = snippet.split_whitespace();\n+        let has_impl = snippet_iter.next().map_or(false, |s| s == \"impl\");\n+        // Only suggest `Box<dyn Trait>` if `Trait` in `impl Trait` is object safe.\n+        let mut is_object_safe = false;\n+        if let hir::FunctionRetTy::Return(ty) = fn_output {\n+            // Get the return type.\n+            if let hir::TyKind::Def(..) = ty.kind {\n+                let ty = AstConv::ast_ty_to_ty(fcx, ty);\n+                // Get the `impl Trait`'s `DefId`.\n+                if let ty::Opaque(def_id, _) = ty.kind {\n+                    let hir_id = fcx.tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n+                    // get the `Trait`'s `DefId`.\n+                    if let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) =\n+                        fcx.tcx.hir().expect_item(hir_id).kind\n+                    {\n+                        // Are of this `impl Trait`'s traits object safe?\n+                        is_object_safe = bounds.iter().all(|bound| {\n+                            bound.trait_def_id().map_or(false, |def_id| {\n+                                object_safety_violations(fcx.tcx, def_id).is_empty()\n+                            })\n+                        })\n+                    }\n+                }\n+            }\n+        };\n+        if has_impl {\n+            if is_object_safe {\n+                err.help(&format!(\n+                    \"you can instead return a boxed trait object using `Box<dyn {}>`\",\n+                    &snippet[5..]\n+                ));\n+            } else {\n+                err.help(&format!(\n+                    \"if the trait `{}` were object safe, you could return a boxed trait object\",\n+                    &snippet[5..]\n+                ));\n+            }\n+            err.note(trait_obj_msg);\n+        }\n+        err.help(\"alternatively, create a new `enum` with a variant for each returned type\");\n+    }\n+\n+    fn is_return_ty_unsized(&self, fcx: &FnCtxt<'a, 'tcx>, blk_id: hir::HirId) -> bool {\n+        if let Some((fn_decl, _)) = fcx.get_fn_decl(blk_id) {\n+            if let hir::FunctionRetTy::Return(ty) = fn_decl.output {\n+                let ty = AstConv::ast_ty_to_ty(fcx, ty);\n+                if let ty::Dynamic(..) = ty.kind {\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n     pub fn complete<'a>(self, fcx: &FnCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         if let Some(final_ty) = self.final_ty {\n             final_ty"}, {"sha": "f59dbc263840077dbb02bb71b9717ec71494230f", "filename": "src/test/ui/async-await/issue-64130-4-async-move.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -1,8 +1,17 @@\n error: future cannot be sent between threads safely\n   --> $DIR/issue-64130-4-async-move.rs:15:17\n    |\n-LL | pub fn foo() -> impl Future + Send {\n-   |                 ^^^^^^^^^^^^^^^^^^ future returned by `foo` is not `Send`\n+LL |   pub fn foo() -> impl Future + Send {\n+   |                   ^^^^^^^^^^^^^^^^^^ future returned by `foo` is not `Send`\n+...\n+LL | /     async move {\n+LL | |         match client.status() {\n+LL | |             200 => {\n+LL | |                 let _x = get().await;\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____- this returned value is of type `impl std::future::Future`\n    |\n    = help: the trait `std::marker::Sync` is not implemented for `(dyn std::any::Any + std::marker::Send + 'static)`\n note: future is not `Send` as this value is used across an await"}, {"sha": "44e5c6a99f7278afa26185f706b35b6134521964", "filename": "src/test/ui/coercion/coerce-expect-unsized-ascribed.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-expect-unsized-ascribed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-expect-unsized-ascribed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-expect-unsized-ascribed.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -29,7 +29,7 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-expect-unsized-ascribed.rs:13:13\n    |\n LL |     let _ = box { |x| (x as u8) }: Box<dyn Fn(i32) -> _>;\n-   |             ^^^^^^^^^^^^^^^^^^^^^ expected trait `std::ops::Fn`, found closure\n+   |             ^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn std::ops::Fn`, found closure\n    |\n    = note: expected struct `std::boxed::Box<dyn std::ops::Fn(i32) -> u8>`\n               found struct `std::boxed::Box<[closure@$DIR/coerce-expect-unsized-ascribed.rs:13:19: 13:32]>`\n@@ -38,7 +38,7 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-expect-unsized-ascribed.rs:14:13\n    |\n LL |     let _ = box if true { false } else { true }: Box<dyn Debug>;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait `std::fmt::Debug`, found `bool`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn std::fmt::Debug`, found `bool`\n    |\n    = note: expected struct `std::boxed::Box<dyn std::fmt::Debug>`\n               found struct `std::boxed::Box<bool>`\n@@ -47,7 +47,7 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-expect-unsized-ascribed.rs:15:13\n    |\n LL |     let _ = box match true { true => 'a', false => 'b' }: Box<dyn Debug>;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait `std::fmt::Debug`, found `char`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn std::fmt::Debug`, found `char`\n    |\n    = note: expected struct `std::boxed::Box<dyn std::fmt::Debug>`\n               found struct `std::boxed::Box<char>`\n@@ -83,7 +83,7 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-expect-unsized-ascribed.rs:21:13\n    |\n LL |     let _ = &{ |x| (x as u8) }: &dyn Fn(i32) -> _;\n-   |             ^^^^^^^^^^^^^^^^^^ expected trait `std::ops::Fn`, found closure\n+   |             ^^^^^^^^^^^^^^^^^^ expected trait object `dyn std::ops::Fn`, found closure\n    |\n    = note: expected reference `&dyn std::ops::Fn(i32) -> u8`\n               found reference `&[closure@$DIR/coerce-expect-unsized-ascribed.rs:21:16: 21:29]`\n@@ -92,7 +92,7 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-expect-unsized-ascribed.rs:22:13\n    |\n LL |     let _ = &if true { false } else { true }: &dyn Debug;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait `std::fmt::Debug`, found `bool`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn std::fmt::Debug`, found `bool`\n    |\n    = note: expected reference `&dyn std::fmt::Debug`\n               found reference `&bool`\n@@ -101,7 +101,7 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-expect-unsized-ascribed.rs:23:13\n    |\n LL |     let _ = &match true { true => 'a', false => 'b' }: &dyn Debug;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait `std::fmt::Debug`, found `char`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn std::fmt::Debug`, found `char`\n    |\n    = note: expected reference `&dyn std::fmt::Debug`\n               found reference `&char`\n@@ -119,7 +119,7 @@ error[E0308]: mismatched types\n   --> $DIR/coerce-expect-unsized-ascribed.rs:26:13\n    |\n LL |     let _ = Box::new(|x| (x as u8)): Box<dyn Fn(i32) -> _>;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ expected trait `std::ops::Fn`, found closure\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ expected trait object `dyn std::ops::Fn`, found closure\n    |\n    = note: expected struct `std::boxed::Box<dyn std::ops::Fn(i32) -> _>`\n               found struct `std::boxed::Box<[closure@$DIR/coerce-expect-unsized-ascribed.rs:26:22: 26:35]>`"}, {"sha": "6e5afcdb8bb68ce650dbba5ccee012f483c950f7", "filename": "src/test/ui/const-generics/array-impls/alloc-traits-no-impls-length-33.stderr", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-traits-no-impls-length-33.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-traits-no-impls-length-33.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-traits-no-impls-length-33.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -3,6 +3,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_vec_partial_eq_array<A, B>() -> impl PartialEq<[B; 33]>\n    |                                           ^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[B; 33]`\n+...\n+LL |     Vec::<A>::new()\n+   |     --------------- this returned value is of type `std::vec::Vec<A>`\n    |\n    = note: required because of the requirements on the impl of `std::cmp::PartialEq<[B; 33]>` for `std::vec::Vec<A>`\n    = note: the return type of a function must have a statically known size\n@@ -12,6 +15,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_vec_partial_eq_ref_array<'a, A, B>() -> impl PartialEq<&'a [B; 33]>\n    |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[B; 33]`\n+...\n+LL |     Vec::<A>::new()\n+   |     --------------- this returned value is of type `std::vec::Vec<A>`\n    |\n    = note: required because of the requirements on the impl of `std::cmp::PartialEq<&'a [B; 33]>` for `std::vec::Vec<A>`\n    = note: the return type of a function must have a statically known size\n@@ -21,6 +27,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_vecdeque_partial_eq_array<A, B>() -> impl PartialEq<[B; 33]>\n    |                                                ^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[B; 33]`\n+...\n+LL |     VecDeque::<A>::new()\n+   |     -------------------- this returned value is of type `std::collections::VecDeque<A>`\n    |\n    = note: required because of the requirements on the impl of `std::cmp::PartialEq<[B; 33]>` for `std::collections::VecDeque<A>`\n    = note: the return type of a function must have a statically known size\n@@ -30,6 +39,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_vecdeque_partial_eq_ref_array<'a, A, B>() -> impl PartialEq<&'a [B; 33]>\n    |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[B; 33]`\n+...\n+LL |     VecDeque::<A>::new()\n+   |     -------------------- this returned value is of type `std::collections::VecDeque<A>`\n    |\n    = note: required because of the requirements on the impl of `std::cmp::PartialEq<&'a [B; 33]>` for `std::collections::VecDeque<A>`\n    = note: the return type of a function must have a statically known size\n@@ -39,6 +51,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_vecdeque_partial_eq_ref_mut_array<'a, A, B>() -> impl PartialEq<&'a mut [B; 33]>\n    |                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[B; 33]`\n+...\n+LL |     VecDeque::<A>::new()\n+   |     -------------------- this returned value is of type `std::collections::VecDeque<A>`\n    |\n    = note: required because of the requirements on the impl of `std::cmp::PartialEq<&'a mut [B; 33]>` for `std::collections::VecDeque<A>`\n    = note: the return type of a function must have a statically known size"}, {"sha": "4869f48363447db0fc0bbbb4aecc566a91860d86", "filename": "src/test/ui/const-generics/array-impls/into-iter-no-impls-length-33.stderr", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Finto-iter-no-impls-length-33.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -11,6 +11,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_iterator() -> impl Iterator<Item = i32> {\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+LL |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ------------------------- this returned value is of type `std::array::IntoIter<i32, 33usize>`\n    |\n    = note: required because of the requirements on the impl of `std::iter::Iterator` for `std::array::IntoIter<i32, 33usize>`\n    = note: the return type of a function must have a statically known size\n@@ -28,6 +31,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_double_ended_iterator() -> impl DoubleEndedIterator {\n    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+LL |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ------------------------- this returned value is of type `std::array::IntoIter<i32, 33usize>`\n    |\n    = note: required because of the requirements on the impl of `std::iter::DoubleEndedIterator` for `std::array::IntoIter<i32, 33usize>`\n    = note: the return type of a function must have a statically known size\n@@ -45,6 +51,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_exact_size_iterator() -> impl ExactSizeIterator {\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+LL |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ------------------------- this returned value is of type `std::array::IntoIter<i32, 33usize>`\n    |\n    = note: required because of the requirements on the impl of `std::iter::ExactSizeIterator` for `std::array::IntoIter<i32, 33usize>`\n    = note: the return type of a function must have a statically known size\n@@ -62,6 +71,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_fused_iterator() -> impl FusedIterator {\n    |                               ^^^^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+LL |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ------------------------- this returned value is of type `std::array::IntoIter<i32, 33usize>`\n    |\n    = note: required because of the requirements on the impl of `std::iter::FusedIterator` for `std::array::IntoIter<i32, 33usize>`\n    = note: the return type of a function must have a statically known size\n@@ -79,6 +91,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_trusted_len() -> impl TrustedLen {\n    |                            ^^^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+LL |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ------------------------- this returned value is of type `std::array::IntoIter<i32, 33usize>`\n    |\n    = note: required because of the requirements on the impl of `std::iter::TrustedLen` for `std::array::IntoIter<i32, 33usize>`\n    = note: the return type of a function must have a statically known size\n@@ -96,6 +111,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_clone() -> impl Clone {\n    |                      ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+LL |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ------------------------- this returned value is of type `std::array::IntoIter<i32, 33usize>`\n    |\n    = note: required because of the requirements on the impl of `std::clone::Clone` for `std::array::IntoIter<i32, 33usize>`\n    = note: the return type of a function must have a statically known size\n@@ -113,6 +131,9 @@ error[E0277]: arrays only have std trait implementations for lengths 0..=32\n    |\n LL | pub fn no_debug() -> impl Debug {\n    |                      ^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[i32; 33]`\n+LL |\n+LL |     IntoIter::new([0i32; 33])\n+   |     ------------------------- this returned value is of type `std::array::IntoIter<i32, 33usize>`\n    |\n    = note: required because of the requirements on the impl of `std::fmt::Debug` for `std::array::IntoIter<i32, 33usize>`\n    = note: the return type of a function must have a statically known size"}, {"sha": "34e7cad935aebafe29533ad710a429872f05fb11", "filename": "src/test/ui/destructure-trait-ref.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fdestructure-trait-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fdestructure-trait-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructure-trait-ref.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -33,12 +33,10 @@ fn main() {\n     //~^ ERROR mismatched types\n     //~| expected trait object `dyn T`\n     //~| found reference `&_`\n-    //~| expected trait `T`, found reference\n     let &&&x = &(&1isize as &dyn T);\n     //~^ ERROR mismatched types\n     //~| expected trait object `dyn T`\n     //~| found reference `&_`\n-    //~| expected trait `T`, found reference\n     let box box x = box 1isize as Box<dyn T>;\n     //~^ ERROR mismatched types\n     //~| expected trait object `dyn T`"}, {"sha": "f99bf2ffdc9d45dc85d7915d7776762ed0a5e6f2", "filename": "src/test/ui/destructure-trait-ref.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -22,31 +22,31 @@ error[E0308]: mismatched types\n LL |     let &&x = &1isize as &dyn T;\n    |          ^^\n    |          |\n-   |          expected trait `T`, found reference\n+   |          expected trait object `dyn T`, found reference\n    |          help: you can probably remove the explicit borrow: `x`\n    |\n    = note: expected trait object `dyn T`\n                  found reference `&_`\n \n error[E0308]: mismatched types\n-  --> $DIR/destructure-trait-ref.rs:37:11\n+  --> $DIR/destructure-trait-ref.rs:36:11\n    |\n LL |     let &&&x = &(&1isize as &dyn T);\n    |           ^^\n    |           |\n-   |           expected trait `T`, found reference\n+   |           expected trait object `dyn T`, found reference\n    |           help: you can probably remove the explicit borrow: `x`\n    |\n    = note: expected trait object `dyn T`\n                  found reference `&_`\n \n error[E0308]: mismatched types\n-  --> $DIR/destructure-trait-ref.rs:42:13\n+  --> $DIR/destructure-trait-ref.rs:40:13\n    |\n LL |     let box box x = box 1isize as Box<dyn T>;\n    |             ^^^^^   ------------------------ this expression has type `std::boxed::Box<dyn T>`\n    |             |\n-   |             expected trait `T`, found struct `std::boxed::Box`\n+   |             expected trait object `dyn T`, found struct `std::boxed::Box`\n    |\n    = note: expected trait object `dyn T`\n                     found struct `std::boxed::Box<_>`"}, {"sha": "d05b3937c998ccfaec6541d8347cda5ce09a0fa7", "filename": "src/test/ui/dst/dst-bad-assign-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign-3.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -32,7 +32,7 @@ pub fn main() {\n     let z: Box<dyn ToBar> = Box::new(Bar1 {f: 36});\n     f5.2 = Bar1 {f: 36};\n     //~^ ERROR mismatched types\n-    //~| expected trait `ToBar`, found struct `Bar1`\n+    //~| expected trait object `dyn ToBar`, found struct `Bar1`\n     //~| expected trait object `dyn ToBar`\n     //~| found struct `Bar1`\n     //~| ERROR the size for values of type"}, {"sha": "0b6f9df2d83ee367656f58eef7faa62cea479631", "filename": "src/test/ui/dst/dst-bad-assign-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign-3.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/dst-bad-assign-3.rs:33:12\n    |\n LL |     f5.2 = Bar1 {f: 36};\n-   |            ^^^^^^^^^^^^ expected trait `ToBar`, found struct `Bar1`\n+   |            ^^^^^^^^^^^^ expected trait object `dyn ToBar`, found struct `Bar1`\n    |\n    = note: expected trait object `dyn ToBar`\n                     found struct `Bar1`"}, {"sha": "496e01ae005326748fd9f162e8642ed0ff1b1d4c", "filename": "src/test/ui/dst/dst-bad-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -34,7 +34,7 @@ pub fn main() {\n     let z: Box<dyn ToBar> = Box::new(Bar1 {f: 36});\n     f5.ptr = Bar1 {f: 36};\n     //~^ ERROR mismatched types\n-    //~| expected trait `ToBar`, found struct `Bar1`\n+    //~| expected trait object `dyn ToBar`, found struct `Bar1`\n     //~| expected trait object `dyn ToBar`\n     //~| found struct `Bar1`\n     //~| ERROR the size for values of type"}, {"sha": "434c460759fb4c4192d54e31d09e7add449e9db2", "filename": "src/test/ui/dst/dst-bad-assign.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdst%2Fdst-bad-assign.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/dst-bad-assign.rs:35:14\n    |\n LL |     f5.ptr = Bar1 {f: 36};\n-   |              ^^^^^^^^^^^^ expected trait `ToBar`, found struct `Bar1`\n+   |              ^^^^^^^^^^^^ expected trait object `dyn ToBar`, found struct `Bar1`\n    |\n    = note: expected trait object `dyn ToBar`\n                     found struct `Bar1`"}, {"sha": "ca8319aa020dceea3f35a462540de4f30b896ec1", "filename": "src/test/ui/error-codes/E0746.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Ferror-codes%2FE0746.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Ferror-codes%2FE0746.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0746.fixed?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+struct Struct;\n+trait Trait {}\n+impl Trait for Struct {}\n+impl Trait for u32 {}\n+\n+fn foo() -> impl Trait { Struct }\n+//~^ ERROR E0746\n+\n+fn bar() -> impl Trait { //~ ERROR E0746\n+    if true {\n+        return 0;\n+    }\n+    42\n+}\n+\n+fn main() {}"}, {"sha": "bf5ba8fff562a81ef091917b380e301f5255cac2", "filename": "src/test/ui/error-codes/E0746.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Ferror-codes%2FE0746.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Ferror-codes%2FE0746.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0746.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+struct Struct;\n+trait Trait {}\n+impl Trait for Struct {}\n+impl Trait for u32 {}\n+\n+fn foo() -> dyn Trait { Struct }\n+//~^ ERROR E0746\n+\n+fn bar() -> dyn Trait { //~ ERROR E0746\n+    if true {\n+        return 0;\n+    }\n+    42\n+}\n+\n+fn main() {}"}, {"sha": "e7a8fd304cabee33798925753507c153e2a49965", "filename": "src/test/ui/error-codes/E0746.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Ferror-codes%2FE0746.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Ferror-codes%2FE0746.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0746.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -0,0 +1,27 @@\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/E0746.rs:8:13\n+   |\n+LL | fn foo() -> dyn Trait { Struct }\n+   |             ^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: return `impl Trait` instead, as all return paths are of type `Struct`, which implements `Trait`\n+   |\n+LL | fn foo() -> impl Trait { Struct }\n+   |             ^^^^^^^^^^\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/E0746.rs:11:13\n+   |\n+LL | fn bar() -> dyn Trait {\n+   |             ^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: return `impl Trait` instead, as all return paths are of type `{integer}`, which implements `Trait`\n+   |\n+LL | fn bar() -> impl Trait {\n+   |             ^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0746`."}, {"sha": "ca2350ff7577f113e0da014c6e12ed49b7a595e8", "filename": "src/test/ui/generic-associated-types/impl_bounds.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fimpl_bounds.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -38,7 +38,7 @@ LL |     type C where Self: Copy = String;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n    |\n    = note: required because of the requirements on the impl of `std::marker::Copy` for `Fooy<T>`\n-   = note: the requirement `Fooy<T>: std::marker::Copy` appears on the associated impl typebut not on the corresponding associated trait type\n+   = note: the requirement `Fooy<T>: std::marker::Copy` appears on the associated impl type but not on the corresponding associated trait type\n \n error: aborting due to 3 previous errors\n "}, {"sha": "b70a51dc82511d649f1e07ddf65811affa8ec938", "filename": "src/test/ui/impl-trait/dyn-trait-return-should-be-impl-trait.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -0,0 +1,34 @@\n+#![allow(bare_trait_objects)]\n+struct Struct;\n+trait Trait {}\n+impl Trait for Struct {}\n+impl Trait for u32 {}\n+\n+fn fuz() -> (usize, Trait) { (42, Struct) }\n+//~^ ERROR E0277\n+//~| ERROR E0308\n+fn bar() -> (usize, dyn Trait) { (42, Struct) }\n+//~^ ERROR E0277\n+//~| ERROR E0308\n+fn bap() -> Trait { Struct }\n+//~^ ERROR E0746\n+fn ban() -> dyn Trait { Struct }\n+//~^ ERROR E0746\n+fn bak() -> dyn Trait { unimplemented!() } //~ ERROR E0277\n+// Suggest using `Box<dyn Trait>`\n+fn bal() -> dyn Trait { //~ ERROR E0746\n+    if true {\n+        return Struct;\n+    }\n+    42\n+}\n+\n+// Suggest using `impl Trait`\n+fn bat() -> dyn Trait { //~ ERROR E0746\n+    if true {\n+        return 0;\n+    }\n+    42\n+}\n+\n+fn main() {}"}, {"sha": "977a7ef0e024464c30d9b037bc9c7b6170c16009", "filename": "src/test/ui/impl-trait/dyn-trait-return-should-be-impl-trait.stderr", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -0,0 +1,113 @@\n+error[E0308]: mismatched types\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:7:35\n+   |\n+LL | fn fuz() -> (usize, Trait) { (42, Struct) }\n+   |                                   ^^^^^^ expected trait object `dyn Trait`, found struct `Struct`\n+   |\n+   = note: expected trait object `(dyn Trait + 'static)`\n+                    found struct `Struct`\n+\n+error[E0277]: the size for values of type `(dyn Trait + 'static)` cannot be known at compilation time\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:7:13\n+   |\n+LL | fn fuz() -> (usize, Trait) { (42, Struct) }\n+   |             ^^^^^^^^^^^^^^   ------------ this returned value is of type `(usize, (dyn Trait + 'static))`\n+   |             |\n+   |             doesn't have a size known at compile-time\n+   |\n+   = help: within `(usize, (dyn Trait + 'static))`, the trait `std::marker::Sized` is not implemented for `(dyn Trait + 'static)`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: required because it appears within the type `(usize, (dyn Trait + 'static))`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:10:39\n+   |\n+LL | fn bar() -> (usize, dyn Trait) { (42, Struct) }\n+   |                                       ^^^^^^ expected trait object `dyn Trait`, found struct `Struct`\n+   |\n+   = note: expected trait object `(dyn Trait + 'static)`\n+                    found struct `Struct`\n+\n+error[E0277]: the size for values of type `(dyn Trait + 'static)` cannot be known at compilation time\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:10:13\n+   |\n+LL | fn bar() -> (usize, dyn Trait) { (42, Struct) }\n+   |             ^^^^^^^^^^^^^^^^^^   ------------ this returned value is of type `(usize, (dyn Trait + 'static))`\n+   |             |\n+   |             doesn't have a size known at compile-time\n+   |\n+   = help: within `(usize, (dyn Trait + 'static))`, the trait `std::marker::Sized` is not implemented for `(dyn Trait + 'static)`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: required because it appears within the type `(usize, (dyn Trait + 'static))`\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:13:13\n+   |\n+LL | fn bap() -> Trait { Struct }\n+   |             ^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: return `impl Trait` instead, as all return paths are of type `Struct`, which implements `Trait`\n+   |\n+LL | fn bap() -> impl Trait { Struct }\n+   |             ^^^^^^^^^^\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:15:13\n+   |\n+LL | fn ban() -> dyn Trait { Struct }\n+   |             ^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: return `impl Trait` instead, as all return paths are of type `Struct`, which implements `Trait`\n+   |\n+LL | fn ban() -> impl Trait { Struct }\n+   |             ^^^^^^^^^^\n+\n+error[E0277]: the size for values of type `(dyn Trait + 'static)` cannot be known at compilation time\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:17:13\n+   |\n+LL | fn bak() -> dyn Trait { unimplemented!() }\n+   |             ^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `(dyn Trait + 'static)`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: the return type of a function must have a statically known size\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:19:13\n+   |\n+LL | fn bal() -> dyn Trait {\n+   |             ^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = note: if all the returned values were of the same type you could use `impl Trait` as the return type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: you can create a new `enum` with a variant for each returned type\n+help: return a boxed trait object instead\n+   |\n+LL | fn bal() -> Box<dyn Trait> {\n+LL |     if true {\n+LL |         return Box::new(Struct);\n+LL |     }\n+LL |     Box::new(42)\n+   |\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/dyn-trait-return-should-be-impl-trait.rs:27:13\n+   |\n+LL | fn bat() -> dyn Trait {\n+   |             ^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: return `impl Trait` instead, as all return paths are of type `{integer}`, which implements `Trait`\n+   |\n+LL | fn bat() -> impl Trait {\n+   |             ^^^^^^^^^^\n+\n+error: aborting due to 9 previous errors\n+\n+Some errors have detailed explanations: E0277, E0308, E0746.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "9178358b60a9c140a8f19870d3ac1f5225898865", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -9,6 +9,12 @@ LL |         return 1_i32;\n LL |     }\n LL |     0_u32\n    |     ^^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: if the trait `Foo` were object safe, you could return a boxed trait object\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0277]: cannot add `impl Foo` to `u32`\n   --> $DIR/equality.rs:24:11"}, {"sha": "ab3086c78b3a1a9139a5960b01510b2f5bee0ef4", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-dyn-trait.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -0,0 +1,35 @@\n+#![allow(bare_trait_objects)]\n+trait NotObjectSafe {\n+    fn foo() -> Self;\n+}\n+\n+struct A;\n+struct B;\n+\n+impl NotObjectSafe for A {\n+    fn foo() -> Self {\n+        A\n+    }\n+}\n+\n+impl NotObjectSafe for B {\n+    fn foo() -> Self {\n+        B\n+    }\n+}\n+\n+fn car() -> dyn NotObjectSafe { //~ ERROR the trait `NotObjectSafe` cannot be made into an object\n+    if true {\n+        return A;\n+    }\n+    B\n+}\n+\n+fn cat() -> Box<dyn NotObjectSafe> { //~ ERROR the trait `NotObjectSafe` cannot be made into an\n+    if true {\n+        return Box::new(A);\n+    }\n+    Box::new(B)\n+}\n+\n+fn main() {}"}, {"sha": "0c8d267c13434b0628fd29c7e114b0bdfbc36849", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-dyn-trait.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-dyn-trait.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -0,0 +1,21 @@\n+error[E0038]: the trait `NotObjectSafe` cannot be made into an object\n+  --> $DIR/object-unsafe-trait-in-return-position-dyn-trait.rs:21:1\n+   |\n+LL |     fn foo() -> Self;\n+   |        --- associated function `foo` has no `self` parameter\n+...\n+LL | fn car() -> dyn NotObjectSafe {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `NotObjectSafe` cannot be made into an object\n+\n+error[E0038]: the trait `NotObjectSafe` cannot be made into an object\n+  --> $DIR/object-unsafe-trait-in-return-position-dyn-trait.rs:28:1\n+   |\n+LL |     fn foo() -> Self;\n+   |        --- associated function `foo` has no `self` parameter\n+...\n+LL | fn cat() -> Box<dyn NotObjectSafe> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `NotObjectSafe` cannot be made into an object\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "503515013b9ab2579a8d7053b0d9b559d56107c5", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-impl-trait.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.rs?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -0,0 +1,46 @@\n+trait NotObjectSafe {\n+    fn foo() -> Self;\n+}\n+\n+trait ObjectSafe {\n+    fn bar(&self);\n+}\n+\n+struct A;\n+struct B;\n+\n+impl NotObjectSafe for A {\n+    fn foo() -> Self {\n+        A\n+    }\n+}\n+\n+impl NotObjectSafe for B {\n+    fn foo() -> Self {\n+        B\n+    }\n+}\n+\n+impl ObjectSafe for A {\n+    fn bar(&self) {}\n+}\n+\n+impl ObjectSafe for B {\n+    fn bar(&self) {}\n+}\n+\n+fn can() -> impl NotObjectSafe {\n+    if true {\n+        return A;\n+    }\n+    B //~ ERROR mismatched types\n+}\n+\n+fn cat() -> impl ObjectSafe {\n+    if true {\n+        return A;\n+    }\n+    B //~ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "dd4260fbe4f911b0cfc15f57e73b7958833146d0", "filename": "src/test/ui/impl-trait/object-unsafe-trait-in-return-position-impl-trait.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fobject-unsafe-trait-in-return-position-impl-trait.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -0,0 +1,39 @@\n+error[E0308]: mismatched types\n+  --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:36:5\n+   |\n+LL | fn can() -> impl NotObjectSafe {\n+   |             ------------------ expected because this return type...\n+LL |     if true {\n+LL |         return A;\n+   |                - ...is found to be `A` here\n+LL |     }\n+LL |     B\n+   |     ^ expected struct `A`, found struct `B`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: if the trait `NotObjectSafe` were object safe, you could return a boxed trait object\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n+\n+error[E0308]: mismatched types\n+  --> $DIR/object-unsafe-trait-in-return-position-impl-trait.rs:43:5\n+   |\n+LL | fn cat() -> impl ObjectSafe {\n+   |             --------------- expected because this return type...\n+LL |     if true {\n+LL |         return A;\n+   |                - ...is found to be `A` here\n+LL |     }\n+LL |     B\n+   |     ^ expected struct `A`, found struct `B`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a boxed trait object using `Box<dyn ObjectSafe>`\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e0c196e518ba34b16df02161d597ad84f1b7461e", "filename": "src/test/ui/issues/issue-58344.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58344.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -3,6 +3,9 @@ error[E0277]: the trait bound `impl Trait<<u32 as std::ops::Add>::Output>: Trait\n    |\n LL | ) -> Either<impl Trait<<u32 as Add<u32>>::Output>, impl Trait<<u32 as Add<u32>>::Output>> {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<u32>` is not implemented for `impl Trait<<u32 as std::ops::Add>::Output>`\n+...\n+LL |     add_generic(value, 1u32)\n+   |     ------------------------ this returned value is of type `Either<impl Trait<<u32 as std::ops::Add>::Output>, impl Trait<<u32 as std::ops::Add>::Output>>`\n    |\n    = note: the return type of a function must have a statically known size\n \n@@ -11,6 +14,9 @@ error[E0277]: the trait bound `impl Trait<<u32 as std::ops::Add>::Output>: Trait\n    |\n LL | ) -> Either<impl Trait<<u32 as Add<u32>>::Output>, impl Trait<<u32 as Add<u32>>::Output>> {\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<u32>` is not implemented for `impl Trait<<u32 as std::ops::Add>::Output>`\n+...\n+LL |     add_generic(value, 1u32)\n+   |     ------------------------ this returned value is of type `Either<impl Trait<<u32 as std::ops::Add>::Output>, impl Trait<<u32 as std::ops::Add>::Output>>`\n    |\n    = note: the return type of a function must have a statically known size\n "}, {"sha": "d886ecc11d17b6abb726ae9ace156011e29c69f1", "filename": "src/test/ui/issues/issue-5883.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5883.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -14,6 +14,9 @@ error[E0277]: the size for values of type `(dyn A + 'static)` cannot be known at\n    |\n LL |     -> Struct {\n    |        ^^^^^^ doesn't have a size known at compile-time\n+LL |\n+LL |     Struct { r: r }\n+   |     --------------- this returned value is of type `Struct`\n    |\n    = help: within `Struct`, the trait `std::marker::Sized` is not implemented for `(dyn A + 'static)`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>"}, {"sha": "e43fb6d0edfb9e730892d6cb0a3eef0fb090b8d2", "filename": "src/test/ui/lifetimes/lifetime-elision-return-type-trait.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-elision-return-type-trait.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -3,6 +3,9 @@ error[E0277]: the trait bound `std::result::Result<(), _>: Future` is not satisf\n    |\n LL | fn foo() -> impl Future<Item=(), Error=Box<dyn Error>> {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Future` is not implemented for `std::result::Result<(), _>`\n+LL |\n+LL |     Ok(())\n+   |     ------ this returned value is of type `std::result::Result<(), _>`\n    |\n    = note: the return type of a function must have a statically known size\n "}, {"sha": "77288f1badac5e572484c0b817e360f6c953d9c3", "filename": "src/test/ui/never_type/feature-gate-never_type_fallback.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Ffeature-gate-never_type_fallback.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -3,8 +3,12 @@ error[E0277]: the trait bound `(): T` is not satisfied\n    |\n LL | fn should_ret_unit() -> impl T {\n    |                         ^^^^^^ the trait `T` is not implemented for `()`\n+LL |\n+LL |     panic!()\n+   |     -------- this returned value is of type `()`\n    |\n    = note: the return type of a function must have a statically known size\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "b663cccbeef0f192da5e7d6b530a45f3bd974925", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -9,6 +9,12 @@ LL |         return 0i32;\n LL |     }\n LL |     1u32\n    |     ^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:13:16\n@@ -21,6 +27,12 @@ LL |         return 0i32;\n LL |     } else {\n LL |         return 1u32;\n    |                ^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:22:9\n@@ -33,6 +45,12 @@ LL |         return 0i32;\n LL |     } else {\n LL |         1u32\n    |         ^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:31:9\n@@ -57,6 +75,12 @@ LL |         0 => return 0i32,\n    |                     ---- ...is found to be `i32` here\n LL |         _ => 1u32,\n    |              ^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:45:5\n@@ -71,6 +95,12 @@ LL | |         1 => 1u32,\n LL | |         _ => 2u32,\n LL | |     }\n    | |_____^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:59:13\n@@ -83,6 +113,12 @@ LL |             return 0i32;\n ...\n LL |             1u32\n    |             ^^^^ expected `i32`, found `u32`\n+   |\n+   = note: to return `impl Trait`, all returned values must be of the same type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = help: you can instead return a boxed trait object using `Box<dyn std::fmt::Display>`\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = help: alternatively, create a new `enum` with a variant for each returned type\n \n error: aborting due to 7 previous errors\n "}, {"sha": "9e8414f9c15febcbefaf8bc19d018a87e3ea50a6", "filename": "src/test/ui/type-alias-impl-trait/generic_underconstrained2.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_underconstrained2.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -18,6 +18,8 @@ LL | type Underconstrained<T: std::fmt::Debug> = impl 'static;\n ...\n LL | fn underconstrained<U>(_: U) -> Underconstrained<U> {\n    |                     - help: consider restricting this bound: `U: std::fmt::Debug`\n+LL |     5u32\n+   |     ---- this returned value is of type `u32`\n    |\n    = help: the trait `std::fmt::Debug` is not implemented for `U`\n    = note: the return type of a function must have a statically known size\n@@ -30,6 +32,8 @@ LL | type Underconstrained2<T: std::fmt::Debug> = impl 'static;\n ...\n LL | fn underconstrained2<U, V>(_: U, _: V) -> Underconstrained2<V> {\n    |                         - help: consider restricting this bound: `V: std::fmt::Debug`\n+LL |     5u32\n+   |     ---- this returned value is of type `u32`\n    |\n    = help: the trait `std::fmt::Debug` is not implemented for `V`\n    = note: the return type of a function must have a statically known size"}, {"sha": "a656b20c23ec3a6f249367ea3560836f650b7d70", "filename": "src/test/ui/typeck/issue-57673-ice-on-deref-of-boxed-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Ftypeck%2Fissue-57673-ice-on-deref-of-boxed-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de01a29fbee586a13f10ee928df7c15c5a170587/src%2Ftest%2Fui%2Ftypeck%2Fissue-57673-ice-on-deref-of-boxed-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-57673-ice-on-deref-of-boxed-trait.stderr?ref=de01a29fbee586a13f10ee928df7c15c5a170587", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | fn ice(x: Box<dyn Iterator<Item=()>>) {\n    |                                       - possibly return type missing here?\n LL |     *x\n-   |     ^^ expected `()`, found trait `std::iter::Iterator`\n+   |     ^^ expected `()`, found trait object `dyn std::iter::Iterator`\n    |\n    = note: expected unit type `()`\n            found trait object `(dyn std::iter::Iterator<Item = ()> + 'static)`"}]}