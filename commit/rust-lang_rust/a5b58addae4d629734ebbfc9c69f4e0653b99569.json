{"sha": "a5b58addae4d629734ebbfc9c69f4e0653b99569", "node_id": "C_kwDOAAsO6NoAKGE1YjU4YWRkYWU0ZDYyOTczNGViYmZjOWM2OWY0ZTA2NTNiOTk1Njk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-14T02:39:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-14T02:39:51Z"}, "message": "Auto merge of #101307 - jyn514:simplify-storage, r=cjgillot\n\nSimplify caching and storage for queries\n\nI highly recommend reviewing commit-by-commit; each individual commit is quite small but it can be hard to see looking at the overall diff that the behavior is the same. Each commit depends on the previous.\n\nr? `@cjgillot`", "tree": {"sha": "e37ff624b1601fd747dc878ec10b9bf8521a1cc6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e37ff624b1601fd747dc878ec10b9bf8521a1cc6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5b58addae4d629734ebbfc9c69f4e0653b99569", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5b58addae4d629734ebbfc9c69f4e0653b99569", "html_url": "https://github.com/rust-lang/rust/commit/a5b58addae4d629734ebbfc9c69f4e0653b99569", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5b58addae4d629734ebbfc9c69f4e0653b99569/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88a192257ce110e7fb1732aa2b65e481f811db7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/88a192257ce110e7fb1732aa2b65e481f811db7a", "html_url": "https://github.com/rust-lang/rust/commit/88a192257ce110e7fb1732aa2b65e481f811db7a"}, {"sha": "0a9d7dbca23bb05fab13c1dc75a87cdb2bf69ff5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a9d7dbca23bb05fab13c1dc75a87cdb2bf69ff5", "html_url": "https://github.com/rust-lang/rust/commit/0a9d7dbca23bb05fab13c1dc75a87cdb2bf69ff5"}], "stats": {"total": 260, "additions": 107, "deletions": 153}, "files": [{"sha": "742ae964f5c70999eb6284b1960a995b85fc3021", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 26, "deletions": 79, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a5b58addae4d629734ebbfc9c69f4e0653b99569/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b58addae4d629734ebbfc9c69f4e0653b99569/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=a5b58addae4d629734ebbfc9c69f4e0653b99569", "patch": "@@ -86,14 +86,11 @@ struct QueryModifiers {\n     desc: (Option<Ident>, Punctuated<Expr, Token![,]>),\n \n     /// Use this type for the in-memory cache.\n-    storage: Option<Type>,\n+    arena_cache: Option<Ident>,\n \n     /// Cache the query to disk if the `Block` returns true.\n     cache: Option<(Option<Pat>, Block)>,\n \n-    /// Custom code to load the query from disk.\n-    load_cached: Option<(Ident, Ident, Block)>,\n-\n     /// A cycle error for this query aborting the compilation with a fatal error.\n     fatal_cycle: Option<Ident>,\n \n@@ -120,8 +117,7 @@ struct QueryModifiers {\n }\n \n fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n-    let mut load_cached = None;\n-    let mut storage = None;\n+    let mut arena_cache = None;\n     let mut cache = None;\n     let mut desc = None;\n     let mut fatal_cycle = None;\n@@ -173,21 +169,8 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n             };\n             let block = input.parse()?;\n             try_insert!(cache = (args, block));\n-        } else if modifier == \"load_cached\" {\n-            // Parse a load_cached modifier like:\n-            // `load_cached(tcx, id) { tcx.on_disk_cache.try_load_query_result(tcx, id) }`\n-            let args;\n-            parenthesized!(args in input);\n-            let tcx = args.parse()?;\n-            args.parse::<Token![,]>()?;\n-            let id = args.parse()?;\n-            let block = input.parse()?;\n-            try_insert!(load_cached = (tcx, id, block));\n-        } else if modifier == \"storage\" {\n-            let args;\n-            parenthesized!(args in input);\n-            let ty = args.parse()?;\n-            try_insert!(storage = ty);\n+        } else if modifier == \"arena_cache\" {\n+            try_insert!(arena_cache = modifier);\n         } else if modifier == \"fatal_cycle\" {\n             try_insert!(fatal_cycle = modifier);\n         } else if modifier == \"cycle_delay_bug\" {\n@@ -212,8 +195,7 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n         return Err(input.error(\"no description provided\"));\n     };\n     Ok(QueryModifiers {\n-        load_cached,\n-        storage,\n+        arena_cache,\n         cache,\n         desc,\n         fatal_cycle,\n@@ -262,20 +244,6 @@ fn add_query_description_impl(query: &Query, impls: &mut proc_macro2::TokenStrea\n \n     // Find out if we should cache the query on disk\n     let cache = if let Some((args, expr)) = modifiers.cache.as_ref() {\n-        let try_load_from_disk = if let Some((tcx, id, block)) = modifiers.load_cached.as_ref() {\n-            // Use custom code to load the query from disk\n-            quote! {\n-                const TRY_LOAD_FROM_DISK: Option<fn(QueryCtxt<'tcx>, SerializedDepNodeIndex) -> Option<Self::Value>>\n-                    = Some(|#tcx, #id| { #block });\n-            }\n-        } else {\n-            // Use the default code to load the query from disk\n-            quote! {\n-                const TRY_LOAD_FROM_DISK: Option<fn(QueryCtxt<'tcx>, SerializedDepNodeIndex) -> Option<Self::Value>>\n-                    = Some(|tcx, id| tcx.on_disk_cache().as_ref()?.try_load_query_result(*tcx, id));\n-            }\n-        };\n-\n         let tcx = args.as_ref().map(|t| quote! { #t }).unwrap_or_else(|| quote! { _ });\n         // expr is a `Block`, meaning that `{ #expr }` gets expanded\n         // to `{ { stmts... } }`, which triggers the `unused_braces` lint.\n@@ -285,20 +253,13 @@ fn add_query_description_impl(query: &Query, impls: &mut proc_macro2::TokenStrea\n             fn cache_on_disk(#tcx: TyCtxt<'tcx>, #key: &Self::Key) -> bool {\n                 #expr\n             }\n-\n-            #try_load_from_disk\n         }\n     } else {\n-        if modifiers.load_cached.is_some() {\n-            panic!(\"load_cached modifier on query `{}` without a cache modifier\", name);\n-        }\n         quote! {\n             #[inline]\n             fn cache_on_disk(_: TyCtxt<'tcx>, _: &Self::Key) -> bool {\n                 false\n             }\n-\n-            const TRY_LOAD_FROM_DISK: Option<fn(QueryCtxt<'tcx>, SerializedDepNodeIndex) -> Option<Self::Value>> = None;\n         }\n     };\n \n@@ -347,42 +308,28 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n \n         let mut attributes = Vec::new();\n \n-        // Pass on the fatal_cycle modifier\n-        if let Some(fatal_cycle) = &modifiers.fatal_cycle {\n-            attributes.push(quote! { (#fatal_cycle) });\n-        };\n-        // Pass on the storage modifier\n-        if let Some(ref ty) = modifiers.storage {\n-            let span = ty.span();\n-            attributes.push(quote_spanned! {span=> (storage #ty) });\n-        };\n-        // Pass on the cycle_delay_bug modifier\n-        if let Some(cycle_delay_bug) = &modifiers.cycle_delay_bug {\n-            attributes.push(quote! { (#cycle_delay_bug) });\n-        };\n-        // Pass on the no_hash modifier\n-        if let Some(no_hash) = &modifiers.no_hash {\n-            attributes.push(quote! { (#no_hash) });\n-        };\n-        // Pass on the anon modifier\n-        if let Some(anon) = &modifiers.anon {\n-            attributes.push(quote! { (#anon) });\n-        };\n-        // Pass on the eval_always modifier\n-        if let Some(eval_always) = &modifiers.eval_always {\n-            attributes.push(quote! { (#eval_always) });\n-        };\n-        // Pass on the depth_limit modifier\n-        if let Some(depth_limit) = &modifiers.depth_limit {\n-            attributes.push(quote! { (#depth_limit) });\n-        };\n-        // Pass on the separate_provide_extern modifier\n-        if let Some(separate_provide_extern) = &modifiers.separate_provide_extern {\n-            attributes.push(quote! { (#separate_provide_extern) });\n+        macro_rules! passthrough {\n+            ( $( $modifier:ident ),+ $(,)? ) => {\n+                $( if let Some($modifier) = &modifiers.$modifier {\n+                    attributes.push(quote! { (#$modifier) });\n+                }; )+\n+            }\n         }\n-        // Pass on the remap_env_constness modifier\n-        if let Some(remap_env_constness) = &modifiers.remap_env_constness {\n-            attributes.push(quote! { (#remap_env_constness) });\n+\n+        passthrough!(\n+            fatal_cycle,\n+            arena_cache,\n+            cycle_delay_bug,\n+            no_hash,\n+            anon,\n+            eval_always,\n+            depth_limit,\n+            separate_provide_extern,\n+            remap_env_constness,\n+        );\n+\n+        if modifiers.cache.is_some() {\n+            attributes.push(quote! { (cache) });\n         }\n \n         // This uses the span of the query definition for the commas,"}, {"sha": "9cb19583121ecc574633bcc39a3022e6a38b0710", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 49, "deletions": 56, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/a5b58addae4d629734ebbfc9c69f4e0653b99569/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b58addae4d629734ebbfc9c69f4e0653b99569/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=a5b58addae4d629734ebbfc9c69f4e0653b99569", "patch": "@@ -47,14 +47,14 @@ rustc_queries! {\n     /// To avoid this fate, do not call `tcx.hir().krate()`; instead,\n     /// prefer wrappers like `tcx.visit_all_items_in_krate()`.\n     query hir_crate(key: ()) -> Crate<'tcx> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"get the crate HIR\" }\n     }\n \n     /// All items in the crate.\n     query hir_crate_items(_: ()) -> rustc_middle::hir::ModuleItems {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"get HIR crate items\" }\n     }\n@@ -64,7 +64,7 @@ rustc_queries! {\n     /// This can be conveniently accessed by `tcx.hir().visit_item_likes_in_module`.\n     /// Avoid calling this query directly.\n     query hir_module_items(key: LocalDefId) -> rustc_middle::hir::ModuleItems {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"HIR module items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n     }\n@@ -196,7 +196,7 @@ rustc_queries! {\n     /// associated generics.\n     query generics_of(key: DefId) -> ty::Generics {\n         desc { |tcx| \"computing generics of `{}`\", tcx.def_path_str(key) }\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n@@ -268,13 +268,13 @@ rustc_queries! {\n     }\n \n     query native_libraries(_: CrateNum) -> Vec<NativeLib> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"looking up the native libraries of a linked crate\" }\n         separate_provide_extern\n     }\n \n     query lint_levels(_: ()) -> LintLevelMap {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"computing the lint levels for items in this crate\" }\n     }\n@@ -307,15 +307,15 @@ rustc_queries! {\n     /// Create a THIR tree for debugging.\n     query thir_tree(key: ty::WithOptConstParam<LocalDefId>) -> String {\n         no_hash\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"constructing THIR tree for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n     }\n \n     /// Set of all the `DefId`s in this crate that have MIR associated with\n     /// them. This includes all the body owners, but also things like struct\n     /// constructors.\n     query mir_keys(_: ()) -> rustc_data_structures::fx::FxIndexSet<LocalDefId> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"getting a list of all mir_keys\" }\n     }\n \n@@ -422,7 +422,7 @@ rustc_queries! {\n     query symbols_for_closure_captures(\n         key: (LocalDefId, LocalDefId)\n     ) -> Vec<rustc_span::Symbol> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc {\n             |tcx| \"symbols for captures of closure `{}` in `{}`\",\n             tcx.def_path_str(key.1.to_def_id()),\n@@ -442,7 +442,7 @@ rustc_queries! {\n     /// MIR pass (assuming the -Cinstrument-coverage option is enabled).\n     query coverageinfo(key: ty::InstanceDef<'tcx>) -> mir::CoverageInfo {\n         desc { |tcx| \"retrieving coverage info from MIR for `{}`\", tcx.def_path_str(key.def_id()) }\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n     }\n \n     /// Returns the `CodeRegions` for a function that has instrumented coverage, in case the\n@@ -452,7 +452,7 @@ rustc_queries! {\n             |tcx| \"retrieving the covered `CodeRegion`s, if instrumented, for `{}`\",\n             tcx.def_path_str(key)\n         }\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         cache_on_disk_if { key.is_local() }\n     }\n \n@@ -490,7 +490,7 @@ rustc_queries! {\n     }\n \n     query wasm_import_module_map(_: CrateNum) -> FxHashMap<DefId, String> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"wasm import module map\" }\n     }\n \n@@ -566,7 +566,7 @@ rustc_queries! {\n \n     query trait_def(key: DefId) -> ty::TraitDef {\n         desc { |tcx| \"computing trait definition for `{}`\", tcx.def_path_str(key) }\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n@@ -644,7 +644,7 @@ rustc_queries! {\n \n     /// Gets a map with the variance of every item; use `item_variance` instead.\n     query crate_variances(_: ()) -> ty::CrateVariancesMap<'tcx> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"computing the variances for items in this crate\" }\n     }\n \n@@ -657,7 +657,7 @@ rustc_queries! {\n \n     /// Maps from thee `DefId` of a type to its (inferred) outlives.\n     query inferred_outlives_crate(_: ()) -> ty::CratePredicatesMap<'tcx> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"computing the inferred outlives predicates for items in this crate\" }\n     }\n \n@@ -671,14 +671,14 @@ rustc_queries! {\n     /// Maps from a trait item to the trait item \"descriptor\".\n     query associated_item(key: DefId) -> ty::AssocItem {\n         desc { |tcx| \"computing associated item data for `{}`\", tcx.def_path_str(key) }\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n \n     /// Collects the associated items defined on a trait or impl.\n     query associated_items(key: DefId) -> ty::AssocItems<'tcx> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n     }\n \n@@ -704,7 +704,7 @@ rustc_queries! {\n     /// The map returned for `tcx.impl_item_implementor_ids(impl_id)` would be\n     ///`{ trait_f: impl_f, trait_g: impl_g }`\n     query impl_item_implementor_ids(impl_id: DefId) -> FxHashMap<DefId, DefId> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"comparing impl items against trait for {}\", tcx.def_path_str(impl_id) }\n     }\n \n@@ -837,7 +837,7 @@ rustc_queries! {\n         FxHashSet<LocalDefId>,\n         FxHashMap<LocalDefId, Vec<(DefId, DefId)>>\n     ) {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"find live symbols in crate\" }\n     }\n \n@@ -883,13 +883,6 @@ rustc_queries! {\n     query diagnostic_only_typeck(key: LocalDefId) -> &'tcx ty::TypeckResults<'tcx> {\n         desc { |tcx| \"type-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n-        load_cached(tcx, id) {\n-            let typeck_results: Option<ty::TypeckResults<'tcx>> = tcx\n-                .on_disk_cache().as_ref()\n-                .and_then(|c| c.try_load_query_result(*tcx, id));\n-\n-            typeck_results.map(|x| &*tcx.arena.alloc(x))\n-        }\n     }\n \n     query used_trait_imports(key: LocalDefId) -> &'tcx FxHashSet<LocalDefId> {\n@@ -921,7 +914,7 @@ rustc_queries! {\n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence.\n     query crate_inherent_impls(k: ()) -> CrateInherentImpls {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"all inherent impls defined in crate\" }\n     }\n \n@@ -1054,7 +1047,7 @@ rustc_queries! {\n     }\n \n     query reachable_set(_: ()) -> FxHashSet<LocalDefId> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"reachability\" }\n     }\n \n@@ -1066,7 +1059,7 @@ rustc_queries! {\n \n     /// Generates a MIR body for the shim.\n     query mir_shims(key: ty::InstanceDef<'tcx>) -> mir::Body<'tcx> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n     }\n \n@@ -1140,7 +1133,7 @@ rustc_queries! {\n \n     query codegen_fn_attrs(def_id: DefId) -> CodegenFnAttrs {\n         desc { |tcx| \"computing codegen attributes of `{}`\", tcx.def_path_str(def_id) }\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         cache_on_disk_if { def_id.is_local() }\n         separate_provide_extern\n     }\n@@ -1157,7 +1150,7 @@ rustc_queries! {\n     /// Gets the rendered value of the specified constant or associated constant.\n     /// Used by rustdoc.\n     query rendered_const(def_id: DefId) -> String {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"rendering constant initializer of `{}`\", tcx.def_path_str(def_id) }\n         cache_on_disk_if { def_id.is_local() }\n         separate_provide_extern\n@@ -1216,12 +1209,12 @@ rustc_queries! {\n \n     /// Given a trait `trait_id`, return all known `impl` blocks.\n     query trait_impls_of(trait_id: DefId) -> ty::trait_def::TraitImpls {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(trait_id) }\n     }\n \n     query specialization_graph_of(trait_id: DefId) -> specialization_graph::Graph {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"building specialization graph of trait `{}`\", tcx.def_path_str(trait_id) }\n         cache_on_disk_if { true }\n     }\n@@ -1348,7 +1341,7 @@ rustc_queries! {\n     }\n \n     query dependency_formats(_: ()) -> Lrc<crate::middle::dependency_format::Dependencies> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"get the linkage format of all dependencies\" }\n     }\n \n@@ -1441,7 +1434,7 @@ rustc_queries! {\n     // like the compiler-generated `main` function and so on.\n     query reachable_non_generics(_: CrateNum)\n         -> DefIdMap<SymbolExportInfo> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"looking up the exported symbols of a crate\" }\n         separate_provide_extern\n     }\n@@ -1464,7 +1457,7 @@ rustc_queries! {\n     /// `upstream_monomorphizations_for`, `upstream_drop_glue_for`, or, even\n     /// better, `Instance::upstream_monomorphization()`.\n     query upstream_monomorphizations(_: ()) -> DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"collecting available upstream monomorphizations\" }\n     }\n \n@@ -1478,7 +1471,7 @@ rustc_queries! {\n     query upstream_monomorphizations_for(def_id: DefId)\n         -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>>\n     {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx|\n             \"collecting available upstream monomorphizations for `{}`\",\n             tcx.def_path_str(def_id),\n@@ -1506,7 +1499,7 @@ rustc_queries! {\n     }\n \n     query foreign_modules(_: CrateNum) -> FxHashMap<DefId, ForeignModule> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"looking up the foreign modules of a linked crate\" }\n         separate_provide_extern\n     }\n@@ -1532,13 +1525,13 @@ rustc_queries! {\n         separate_provide_extern\n     }\n     query extra_filename(_: CrateNum) -> String {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"looking up the extra filename for a crate\" }\n         separate_provide_extern\n     }\n     query crate_extern_paths(_: CrateNum) -> Vec<PathBuf> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"looking up the paths for extern crates\" }\n         separate_provide_extern\n@@ -1580,14 +1573,14 @@ rustc_queries! {\n     /// the same lifetimes and is responsible for diagnostics.\n     /// See `rustc_resolve::late::lifetimes for details.\n     query resolve_lifetimes_trait_definition(_: LocalDefId) -> ResolveLifetimes {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"resolving lifetimes for a trait definition\" }\n     }\n     /// Does lifetime resolution on items. Importantly, we can't resolve\n     /// lifetimes directly on things like trait methods, because of trait params.\n     /// See `rustc_resolve::late::lifetimes for details.\n     query resolve_lifetimes(_: LocalDefId) -> ResolveLifetimes {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"resolving lifetimes\" }\n     }\n     query named_region_map(_: LocalDefId) ->\n@@ -1657,15 +1650,15 @@ rustc_queries! {\n     }\n \n     query lib_features(_: ()) -> LibFeatures {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"calculating the lib features map\" }\n     }\n     query defined_lib_features(_: CrateNum) -> &'tcx [(Symbol, Option<Symbol>)] {\n         desc { \"calculating the lib features defined in a crate\" }\n         separate_provide_extern\n     }\n     query stability_implications(_: CrateNum) -> FxHashMap<Symbol, Symbol> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"calculating the implications between `#[unstable]` features defined in a crate\" }\n         separate_provide_extern\n     }\n@@ -1676,14 +1669,14 @@ rustc_queries! {\n     }\n     /// Returns the lang items defined in another crate by loading it from metadata.\n     query get_lang_items(_: ()) -> LanguageItems {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"calculating the lang items map\" }\n     }\n \n     /// Returns all diagnostic items defined in all crates.\n     query all_diagnostic_items(_: ()) -> rustc_hir::diagnostic_items::DiagnosticItems {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"calculating the diagnostic items map\" }\n     }\n@@ -1696,7 +1689,7 @@ rustc_queries! {\n \n     /// Returns the diagnostic items defined in a crate.\n     query diagnostic_items(_: CrateNum) -> rustc_hir::diagnostic_items::DiagnosticItems {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"calculating the diagnostic items map in a crate\" }\n         separate_provide_extern\n     }\n@@ -1706,11 +1699,11 @@ rustc_queries! {\n         separate_provide_extern\n     }\n     query visible_parent_map(_: ()) -> DefIdMap<DefId> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"calculating the visible parent map\" }\n     }\n     query trimmed_def_paths(_: ()) -> FxHashMap<DefId, Symbol> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"calculating trimmed def paths\" }\n     }\n     query missing_extern_crate_item(_: CrateNum) -> bool {\n@@ -1719,14 +1712,14 @@ rustc_queries! {\n         separate_provide_extern\n     }\n     query used_crate_source(_: CrateNum) -> Lrc<CrateSource> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"looking at the source for a crate\" }\n         separate_provide_extern\n     }\n     /// Returns the debugger visualizers defined for this crate.\n     query debugger_visualizers(_: CrateNum) -> Vec<rustc_span::DebuggerVisualizerFile> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"looking up the debugger visualizers for this crate\" }\n         separate_provide_extern\n     }\n@@ -1760,7 +1753,7 @@ rustc_queries! {\n     }\n \n     query stability_index(_: ()) -> stability::Index {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"calculating the stability index for the local crate\" }\n     }\n@@ -2001,7 +1994,7 @@ rustc_queries! {\n     }\n \n     query supported_target_features(_: CrateNum) -> FxHashMap<String, Option<Symbol>> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"looking up supported target features\" }\n     }\n@@ -2071,7 +2064,7 @@ rustc_queries! {\n     /// all of the cases that the normal `ty::Ty`-based wfcheck does. This is fine,\n     /// because the `ty::Ty`-based wfcheck is always run.\n     query diagnostic_hir_wf_check(key: (ty::Predicate<'tcx>, traits::WellFormedLoc)) -> Option<traits::ObligationCause<'tcx>> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         no_hash\n         desc { \"performing HIR wf-checking for predicate {:?} at item {:?}\", key.0, key.1 }\n@@ -2081,13 +2074,13 @@ rustc_queries! {\n     /// The list of backend features computed from CLI flags (`-Ctarget-cpu`, `-Ctarget-feature`,\n     /// `--target` and similar).\n     query global_backend_features(_: ()) -> Vec<String> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"computing the backend features for CLI flags\" }\n     }\n \n     query generator_diagnostic_data(key: DefId) -> Option<GeneratorDiagnosticData<'tcx>> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"looking up generator diagnostic data of `{}`\", tcx.def_path_str(key) }\n         separate_provide_extern\n     }"}, {"sha": "a300a8df23d286117fe067cadee360696d3af92c", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5b58addae4d629734ebbfc9c69f4e0653b99569/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b58addae4d629734ebbfc9c69f4e0653b99569/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=a5b58addae4d629734ebbfc9c69f4e0653b99569", "patch": "@@ -121,8 +121,8 @@ macro_rules! query_storage {\n     ([][$K:ty, $V:ty]) => {\n         <DefaultCacheSelector as CacheSelector<$K, $V>>::Cache\n     };\n-    ([(storage $ty:ty) $($rest:tt)*][$K:ty, $V:ty]) => {\n-        <$ty as CacheSelector<$K, $V>>::Cache\n+    ([(arena_cache) $($rest:tt)*][$K:ty, $V:ty]) => {\n+        <ArenaCacheSelector<'tcx> as CacheSelector<$K, $V>>::Cache\n     };\n     ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n         query_storage!([$($modifiers)*][$($args)*])"}, {"sha": "c87d26b3950a10e23f4c5b79ae8acd75a46e2b54", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5b58addae4d629734ebbfc9c69f4e0653b99569/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b58addae4d629734ebbfc9c69f4e0653b99569/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=a5b58addae4d629734ebbfc9c69f4e0653b99569", "patch": "@@ -17,7 +17,7 @@ extern crate rustc_middle;\n \n use rustc_data_structures::sync::AtomicU64;\n use rustc_middle::arena::Arena;\n-use rustc_middle::dep_graph::{self, DepKindStruct, SerializedDepNodeIndex};\n+use rustc_middle::dep_graph::{self, DepKindStruct};\n use rustc_middle::ty::query::{query_keys, query_storage, query_stored, query_values};\n use rustc_middle::ty::query::{ExternProviders, Providers, QueryEngine};\n use rustc_middle::ty::{self, TyCtxt};"}, {"sha": "6fb3c69b1f47e50c700e6b4fd0aa7061ffa8a70b", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a5b58addae4d629734ebbfc9c69f4e0653b99569/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b58addae4d629734ebbfc9c69f4e0653b99569/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=a5b58addae4d629734ebbfc9c69f4e0653b99569", "patch": "@@ -3,6 +3,7 @@\n //! manage the caches, and so forth.\n \n use crate::keys::Key;\n+use crate::on_disk_cache::CacheDecoder;\n use crate::{on_disk_cache, Queries};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{AtomicU64, Lock};\n@@ -19,6 +20,7 @@ use rustc_query_system::query::{\n     QuerySideEffects, QueryStackFrame,\n };\n use rustc_query_system::Value;\n+use rustc_serialize::Decodable;\n use std::any::Any;\n use std::num::NonZeroU64;\n use thin_vec::ThinVec;\n@@ -253,6 +255,18 @@ macro_rules! get_provider {\n     };\n }\n \n+macro_rules! should_ever_cache_on_disk {\n+    ([]) => {{\n+        None\n+    }};\n+    ([(cache) $($rest:tt)*]) => {{\n+        Some($crate::plumbing::try_load_from_disk::<Self::Value>)\n+    }};\n+    ([$other:tt $($modifiers:tt)*]) => {\n+        should_ever_cache_on_disk!([$($modifiers)*])\n+    };\n+}\n+\n pub(crate) fn create_query_frame<\n     'tcx,\n     K: Copy + Key + for<'a> HashStable<StableHashingContext<'a>>,\n@@ -313,6 +327,16 @@ where\n     }\n }\n \n+pub(crate) fn try_load_from_disk<'tcx, V>(\n+    tcx: QueryCtxt<'tcx>,\n+    id: SerializedDepNodeIndex,\n+) -> Option<V>\n+where\n+    V: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n+{\n+    tcx.on_disk_cache().as_ref()?.try_load_query_result(*tcx, id)\n+}\n+\n fn force_from_dep_node<'tcx, Q>(tcx: TyCtxt<'tcx>, dep_node: DepNode) -> bool\n where\n     Q: QueryDescription<QueryCtxt<'tcx>>,\n@@ -418,8 +442,7 @@ macro_rules! define_queries {\n                     hash_result: hash_result!([$($modifiers)*]),\n                     handle_cycle_error: handle_cycle_error!([$($modifiers)*]),\n                     compute,\n-                    cache_on_disk,\n-                    try_load_from_disk: Self::TRY_LOAD_FROM_DISK,\n+                    try_load_from_disk: if cache_on_disk { should_ever_cache_on_disk!([$($modifiers)*]) } else { None },\n                 }\n             }\n "}, {"sha": "c4549cc9eb411dc1a408feb14960569f583c69dc", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a5b58addae4d629734ebbfc9c69f4e0653b99569/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b58addae4d629734ebbfc9c69f4e0653b99569/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=a5b58addae4d629734ebbfc9c69f4e0653b99569", "patch": "@@ -25,11 +25,11 @@ pub struct QueryVTable<CTX: QueryContext, K, V> {\n     pub dep_kind: CTX::DepKind,\n     pub eval_always: bool,\n     pub depth_limit: bool,\n-    pub cache_on_disk: bool,\n \n     pub compute: fn(CTX::DepContext, K) -> V,\n     pub hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n     pub handle_cycle_error: HandleCycleError,\n+    // NOTE: this is also `None` if `cache_on_disk()` returns false, not just if it's unsupported by the query\n     pub try_load_from_disk: Option<fn(CTX, SerializedDepNodeIndex) -> Option<V>>,\n }\n \n@@ -44,18 +44,9 @@ impl<CTX: QueryContext, K, V> QueryVTable<CTX, K, V> {\n     pub(crate) fn compute(&self, tcx: CTX::DepContext, key: K) -> V {\n         (self.compute)(tcx, key)\n     }\n-\n-    pub(crate) fn try_load_from_disk(&self, tcx: CTX, index: SerializedDepNodeIndex) -> Option<V> {\n-        self.try_load_from_disk\n-            .expect(\"QueryDescription::load_from_disk() called for an unsupported query.\")(\n-            tcx, index,\n-        )\n-    }\n }\n \n pub trait QueryDescription<CTX: QueryContext>: QueryConfig {\n-    const TRY_LOAD_FROM_DISK: Option<fn(CTX, SerializedDepNodeIndex) -> Option<Self::Value>>;\n-\n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n     fn describe(tcx: CTX, key: Self::Key) -> String;"}, {"sha": "8179a674afaecb9bc18e1d66e8f162724dd10ee3", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5b58addae4d629734ebbfc9c69f4e0653b99569/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b58addae4d629734ebbfc9c69f4e0653b99569/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=a5b58addae4d629734ebbfc9c69f4e0653b99569", "patch": "@@ -488,14 +488,14 @@ where\n \n     // First we try to load the result from the on-disk cache.\n     // Some things are never cached on disk.\n-    if query.cache_on_disk {\n+    if let Some(try_load_from_disk) = query.try_load_from_disk {\n         let prof_timer = tcx.dep_context().profiler().incr_cache_loading();\n \n         // The call to `with_query_deserialization` enforces that no new `DepNodes`\n         // are created during deserialization. See the docs of that method for more\n         // details.\n-        let result = dep_graph\n-            .with_query_deserialization(|| query.try_load_from_disk(tcx, prev_dep_node_index));\n+        let result =\n+            dep_graph.with_query_deserialization(|| try_load_from_disk(tcx, prev_dep_node_index));\n \n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n "}]}