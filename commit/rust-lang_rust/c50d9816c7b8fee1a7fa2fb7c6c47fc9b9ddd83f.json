{"sha": "c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MGQ5ODE2YzdiOGZlZTFhN2ZhMmZiN2M2YzQ3ZmM5YjlkZGQ4M2Y=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-06-26T01:00:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-26T01:00:07Z"}, "message": "Rollup merge of #73418 - doctorn:variants-intrinsic, r=kennytm\n\nAdd unstable `core::mem::variant_count` intrinsic\n\nAdds a new `const fn` intrinsic which can be used to determine the number of variants in an `enum`.\n\nI've shown this to a couple of people and they invariably ask 'why on earth?', but there's actually a very neat use case:\n\nAt the moment, if you want to create an opaque array type that's indexed by an `enum` with one element for each variant, you either have to hard-code the number of variants, add a `LENGTH` variant or use a `Vec`, none of which are suitable in general (number of variants could change; pattern matching `LENGTH` becomes frustrating; might not have `alloc`). By including this intrinsic, it becomes possible to write the following:\n\n```rust\n#[derive(Copy, Clone)]\nenum OpaqueIndex {\n    A = 0,\n    B,\n    C,\n}\n\nstruct OpaqueVec<T>(Box<[T; std::mem::num_variants::<OpaqueIndex>()]>);\n\nimpl<T> std::ops::Index<OpaqueIndex> for OpaqueVec<T> {\n    type Output = T;\n\n    fn index(&self, idx: OpaqueIndex) -> &Self::Output {\n        &self.0[idx as usize]\n    }\n}\n```\n\n(We even have a use cases for this in `rustc` and I plan to use it to re-implement the lang-items table.)", "tree": {"sha": "ea0ef58a17b46f3a5cbe679c4de3276990336d12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea0ef58a17b46f3a5cbe679c4de3276990336d12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe9UiXCRBK7hj4Ov3rIwAAdHIIAH80Nzpz4qNe/4dGVd30KYBt\nFMLraMxamUOTF6HCDmMCHHXZJX0S9Viq352m2nh3wNmd3YkbbLk/c6lTwHt2o39e\nJxIhzSt2PoIK1g8bWnBLg9sZ6V1gbS1CTGHErF66PcUzAQtF0/1rDId4kAMqtVI4\nWfhkHC2JeyGq+DjJMAnFm6+AT4ywuAtisPJddAWmXhO0EPZ3WbD7Wfusy/4xkp88\njuFYpQ3Y8L/8p/OCz13okGrzHJvbfc7xftIPA0OQSkcGb8vTbdJq9PGfhW8yh7gG\nTReOnzaQeacTo6ymlBv6CC7AnI3GBsFcUVvZloD96q6kJMOZD0M7xbHwoLwEAnk=\n=SjRr\n-----END PGP SIGNATURE-----\n", "payload": "tree ea0ef58a17b46f3a5cbe679c4de3276990336d12\nparent 23c9ac6b730f4e71b47f8714420f2609537b7114\nparent 493199626baf8a0a8f6d3a19a089165d18b3f1fb\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593133207 -0700\ncommitter GitHub <noreply@github.com> 1593133207 -0700\n\nRollup merge of #73418 - doctorn:variants-intrinsic, r=kennytm\n\nAdd unstable `core::mem::variant_count` intrinsic\n\nAdds a new `const fn` intrinsic which can be used to determine the number of variants in an `enum`.\n\nI've shown this to a couple of people and they invariably ask 'why on earth?', but there's actually a very neat use case:\n\nAt the moment, if you want to create an opaque array type that's indexed by an `enum` with one element for each variant, you either have to hard-code the number of variants, add a `LENGTH` variant or use a `Vec`, none of which are suitable in general (number of variants could change; pattern matching `LENGTH` becomes frustrating; might not have `alloc`). By including this intrinsic, it becomes possible to write the following:\n\n```rust\n#[derive(Copy, Clone)]\nenum OpaqueIndex {\n    A = 0,\n    B,\n    C,\n}\n\nstruct OpaqueVec<T>(Box<[T; std::mem::num_variants::<OpaqueIndex>()]>);\n\nimpl<T> std::ops::Index<OpaqueIndex> for OpaqueVec<T> {\n    type Output = T;\n\n    fn index(&self, idx: OpaqueIndex) -> &Self::Output {\n        &self.0[idx as usize]\n    }\n}\n```\n\n(We even have a use cases for this in `rustc` and I plan to use it to re-implement the lang-items table.)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f", "html_url": "https://github.com/rust-lang/rust/commit/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23c9ac6b730f4e71b47f8714420f2609537b7114", "url": "https://api.github.com/repos/rust-lang/rust/commits/23c9ac6b730f4e71b47f8714420f2609537b7114", "html_url": "https://github.com/rust-lang/rust/commit/23c9ac6b730f4e71b47f8714420f2609537b7114"}, {"sha": "493199626baf8a0a8f6d3a19a089165d18b3f1fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/493199626baf8a0a8f6d3a19a089165d18b3f1fb", "html_url": "https://github.com/rust-lang/rust/commit/493199626baf8a0a8f6d3a19a089165d18b3f1fb"}], "stats": {"total": 116, "additions": 111, "deletions": 5}, "files": [{"sha": "5d09018759191806f8d157385aa68763a4cd94ca", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f", "patch": "@@ -1917,6 +1917,15 @@ extern \"rust-intrinsic\" {\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n     pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n \n+    /// Returns the number of variants of the type `T` cast to a `usize`;\n+    /// if `T` has no variants, returns 0. Uninhabited variants will be counted.\n+    ///\n+    /// The to-be-stabilized version of this intrinsic is\n+    /// [`std::mem::variant_count`](../../std/mem/fn.variant_count.html)\n+    #[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n+    #[cfg(not(bootstrap))]\n+    pub fn variant_count<T>() -> usize;\n+\n     /// Rust's \"try catch\" construct which invokes the function pointer `try_fn`\n     /// with the data pointer `data`.\n     ///\n@@ -1960,6 +1969,12 @@ extern \"rust-intrinsic\" {\n     pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool;\n }\n \n+#[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n+#[cfg(bootstrap)]\n+pub const fn variant_count<T>() -> usize {\n+    0\n+}\n+\n // Some functions are defined here because they accidentally got made\n // available in this module on stable. See <https://github.com/rust-lang/rust/issues/15702>.\n // (`transmute` also falls into this category, but it cannot be wrapped due to the"}, {"sha": "2b26e5303a89cee5d67838452fb04d3cd3444b04", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f", "patch": "@@ -124,6 +124,7 @@\n #![feature(unsized_locals)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n+#![feature(variant_count)]\n #![feature(doc_alias)]\n #![feature(mmx_target_feature)]\n #![feature(tbm_target_feature)]"}, {"sha": "1bd7ae3a34ebbcf9f6eb876aab3374ab065d08b9", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f", "patch": "@@ -999,3 +999,33 @@ impl<T> fmt::Debug for Discriminant<T> {\n pub const fn discriminant<T>(v: &T) -> Discriminant<T> {\n     Discriminant(intrinsics::discriminant_value(v))\n }\n+\n+/// Returns the number of variants in the enum type `T`.\n+///\n+/// If `T` is not an enum, calling this function will not result in undefined behavior, but the\n+/// return value is unspecified. Equally, if `T` is an enum with more variants than `usize::MAX`\n+/// the return value is unspecified. Uninhabited variants will be counted.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![feature(never_type)]\n+/// # #![feature(variant_count)]\n+///\n+/// use std::mem;\n+///\n+/// enum Void {}\n+/// enum Foo { A(&'static str), B(i32), C(i32) }\n+///\n+/// assert_eq!(mem::variant_count::<Void>(), 0);\n+/// assert_eq!(mem::variant_count::<Foo>(), 3);\n+///\n+/// assert_eq!(mem::variant_count::<Option<!>>(), 2);\n+/// assert_eq!(mem::variant_count::<Result<!, !>>(), 2);\n+/// ```\n+#[inline(always)]\n+#[unstable(feature = \"variant_count\", issue = \"73662\")]\n+#[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n+pub const fn variant_count<T>() -> usize {\n+    intrinsics::variant_count::<T>()\n+}"}, {"sha": "130c0cf1877c667c02a0258961eb1b6bb1e63e82", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f", "patch": "@@ -206,7 +206,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n             }\n             \"size_of\" | \"pref_align_of\" | \"min_align_of\" | \"needs_drop\" | \"type_id\"\n-            | \"type_name\" => {\n+            | \"type_name\" | \"variant_count\" => {\n                 let value = self\n                     .tcx\n                     .const_eval_instance(ty::ParamEnv::reveal_all(), instance, None)"}, {"sha": "88ba28dab82e18081ea8ce1756a62b212081916b", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f", "patch": "@@ -69,6 +69,13 @@ crate fn eval_nullary_intrinsic<'tcx>(\n             ConstValue::from_machine_usize(n, &tcx)\n         }\n         sym::type_id => ConstValue::from_u64(tcx.type_id_hash(tp_ty)),\n+        sym::variant_count => {\n+            if let ty::Adt(ref adt, _) = tp_ty.kind {\n+                ConstValue::from_machine_usize(adt.variants.len() as u64, &tcx)\n+            } else {\n+                ConstValue::from_machine_usize(0u64, &tcx)\n+            }\n+        }\n         other => bug!(\"`{}` is not a zero arg intrinsic\", other),\n     })\n }\n@@ -109,10 +116,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | sym::needs_drop\n             | sym::size_of\n             | sym::type_id\n-            | sym::type_name => {\n+            | sym::type_name\n+            | sym::variant_count => {\n                 let gid = GlobalId { instance, promoted: None };\n                 let ty = match intrinsic_name {\n-                    sym::min_align_of | sym::pref_align_of | sym::size_of => self.tcx.types.usize,\n+                    sym::min_align_of | sym::pref_align_of | sym::size_of | sym::variant_count => {\n+                        self.tcx.types.usize\n+                    }\n                     sym::needs_drop => self.tcx.types.bool,\n                     sym::type_id => self.tcx.types.u64,\n                     sym::type_name => self.tcx.mk_static_str(),"}, {"sha": "857734037afe7c588dfa6b07d30be60234b94852", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f", "patch": "@@ -832,6 +832,7 @@ symbols! {\n         v1,\n         val,\n         var,\n+        variant_count,\n         vec,\n         Vec,\n         version,"}, {"sha": "1c0b22ca7370bd5da2bdad633619a2abe85058c4", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f", "patch": "@@ -75,7 +75,7 @@ pub fn intrinsic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n         | \"saturating_sub\" | \"rotate_left\" | \"rotate_right\" | \"ctpop\" | \"ctlz\" | \"cttz\"\n         | \"bswap\" | \"bitreverse\" | \"discriminant_value\" | \"type_id\" | \"likely\" | \"unlikely\"\n         | \"ptr_guaranteed_eq\" | \"ptr_guaranteed_ne\" | \"minnumf32\" | \"minnumf64\" | \"maxnumf32\"\n-        | \"maxnumf64\" | \"type_name\" => hir::Unsafety::Normal,\n+        | \"maxnumf64\" | \"type_name\" | \"variant_count\" => hir::Unsafety::Normal,\n         _ => hir::Unsafety::Unsafe,\n     }\n }\n@@ -137,7 +137,9 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n         let unsafety = intrinsic_operation_unsafety(&name[..]);\n         let (n_tps, inputs, output) = match &name[..] {\n             \"breakpoint\" => (0, Vec::new(), tcx.mk_unit()),\n-            \"size_of\" | \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), tcx.types.usize),\n+            \"size_of\" | \"pref_align_of\" | \"min_align_of\" | \"variant_count\" => {\n+                (1, Vec::new(), tcx.types.usize)\n+            }\n             \"size_of_val\" | \"min_align_of_val\" => {\n                 (1, vec![tcx.mk_imm_ptr(param(0))], tcx.types.usize)\n             }"}, {"sha": "455419d2c7f1d4a1b7e55a758a2967e2ab641986", "filename": "src/test/ui/consts/const-variant-count.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Ftest%2Fui%2Fconsts%2Fconst-variant-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f/src%2Ftest%2Fui%2Fconsts%2Fconst-variant-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-variant-count.rs?ref=c50d9816c7b8fee1a7fa2fb7c6c47fc9b9ddd83f", "patch": "@@ -0,0 +1,47 @@\n+// run-pass\n+#![allow(dead_code)]\n+#![feature(variant_count)]\n+#![feature(never_type)]\n+\n+use std::mem::variant_count;\n+\n+enum Void {}\n+\n+enum Foo {\n+    A,\n+    B,\n+    C,\n+}\n+\n+enum Bar {\n+    A,\n+    B,\n+    C,\n+    D(usize),\n+    E { field_1: usize, field_2: Foo },\n+}\n+\n+struct Baz {\n+    a: u32,\n+    b: *const u8,\n+}\n+\n+const TEST_VOID: usize = variant_count::<Void>();\n+const TEST_FOO: usize = variant_count::<Foo>();\n+const TEST_BAR: usize = variant_count::<Bar>();\n+\n+const NO_ICE_STRUCT: usize = variant_count::<Baz>();\n+const NO_ICE_BOOL: usize = variant_count::<bool>();\n+const NO_ICE_PRIM: usize = variant_count::<*const u8>();\n+\n+fn main() {\n+    assert_eq!(TEST_VOID, 0);\n+    assert_eq!(TEST_FOO, 3);\n+    assert_eq!(TEST_BAR, 5);\n+    assert_eq!(variant_count::<Void>(), 0);\n+    assert_eq!(variant_count::<Foo>(), 3);\n+    assert_eq!(variant_count::<Bar>(), 5);\n+    assert_eq!(variant_count::<Option<char>>(), 2);\n+    assert_eq!(variant_count::<Option<!>>(), 2);\n+    assert_eq!(variant_count::<Result<!, !>>(), 2);\n+}"}]}