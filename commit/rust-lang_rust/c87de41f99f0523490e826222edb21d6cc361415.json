{"sha": "c87de41f99f0523490e826222edb21d6cc361415", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4N2RlNDFmOTlmMDUyMzQ5MGU4MjYyMjJlZGIyMWQ2Y2MzNjE0MTU=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-09T10:21:33Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-27T19:47:12Z"}, "message": "Remove remaining uses of \"cmt\"", "tree": {"sha": "bc2aaf2d304cc73ec99c77a760b9a35ccdbf2981", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc2aaf2d304cc73ec99c77a760b9a35ccdbf2981"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c87de41f99f0523490e826222edb21d6cc361415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c87de41f99f0523490e826222edb21d6cc361415", "html_url": "https://github.com/rust-lang/rust/commit/c87de41f99f0523490e826222edb21d6cc361415", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c87de41f99f0523490e826222edb21d6cc361415/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d53e437442b44b5c530c45cf9fdfd595ad715b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d53e437442b44b5c530c45cf9fdfd595ad715b1", "html_url": "https://github.com/rust-lang/rust/commit/1d53e437442b44b5c530c45cf9fdfd595ad715b1"}], "stats": {"total": 100, "additions": 51, "deletions": 49}, "files": [{"sha": "5ad381ef6b2727391634993ce7e18d5ccb6afc9f", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c87de41f99f0523490e826222edb21d6cc361415/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c87de41f99f0523490e826222edb21d6cc361415/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c87de41f99f0523490e826222edb21d6cc361415", "patch": "@@ -21,15 +21,15 @@ use syntax_pos::Span;\n /// This trait defines the callbacks you can expect to receive when\n /// employing the ExprUseVisitor.\n pub trait Delegate<'tcx> {\n-    // The value found at `cmt` is either copied or moved, depending\n+    // The value found at `place` is either copied or moved, depending\n     // on mode.\n-    fn consume(&mut self, cmt: &mc::Place<'tcx>, mode: ConsumeMode);\n+    fn consume(&mut self, place: &mc::Place<'tcx>, mode: ConsumeMode);\n \n-    // The value found at `cmt` is being borrowed with kind `bk`.\n-    fn borrow(&mut self, cmt: &mc::Place<'tcx>, bk: ty::BorrowKind);\n+    // The value found at `place` is being borrowed with kind `bk`.\n+    fn borrow(&mut self, place: &mc::Place<'tcx>, bk: ty::BorrowKind);\n \n-    // The path at `cmt` is being assigned to.\n-    fn mutate(&mut self, assignee_cmt: &mc::Place<'tcx>);\n+    // The path at `place` is being assigned to.\n+    fn mutate(&mut self, assignee_place: &mc::Place<'tcx>);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -163,22 +163,22 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     pub fn consume_expr(&mut self, expr: &hir::Expr) {\n         debug!(\"consume_expr(expr={:?})\", expr);\n \n-        let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate_consume(&cmt);\n+        let place = return_if_err!(self.mc.cat_expr(expr));\n+        self.delegate_consume(&place);\n         self.walk_expr(expr);\n     }\n \n     fn mutate_expr(&mut self, expr: &hir::Expr) {\n-        let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.mutate(&cmt);\n+        let place = return_if_err!(self.mc.cat_expr(expr));\n+        self.delegate.mutate(&place);\n         self.walk_expr(expr);\n     }\n \n     fn borrow_expr(&mut self, expr: &hir::Expr, bk: ty::BorrowKind) {\n         debug!(\"borrow_expr(expr={:?}, bk={:?})\", expr, bk);\n \n-        let cmt = return_if_err!(self.mc.cat_expr(expr));\n-        self.delegate.borrow(&cmt, bk);\n+        let place = return_if_err!(self.mc.cat_expr(expr));\n+        self.delegate.borrow(&place, bk);\n \n         self.walk_expr(expr)\n     }\n@@ -230,12 +230,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Match(ref discr, ref arms, _) => {\n-                let discr_cmt = return_if_err!(self.mc.cat_expr(&discr));\n+                let discr_place = return_if_err!(self.mc.cat_expr(&discr));\n                 self.borrow_expr(&discr, ty::ImmBorrow);\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms {\n-                    self.walk_arm(&discr_cmt, arm);\n+                    self.walk_arm(&discr_place, arm);\n                 }\n             }\n \n@@ -381,8 +381,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             // \"assigns\", which is handled by\n             // `walk_pat`:\n             self.walk_expr(&expr);\n-            let init_cmt = return_if_err!(self.mc.cat_expr(&expr));\n-            self.walk_irrefutable_pat(&init_cmt, &local.pat);\n+            let init_place = return_if_err!(self.mc.cat_expr(&expr));\n+            self.walk_irrefutable_pat(&init_place, &local.pat);\n         }\n     }\n \n@@ -457,15 +457,15 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     // process.\n     fn walk_adjustment(&mut self, expr: &hir::Expr) {\n         let adjustments = self.mc.tables.expr_adjustments(expr);\n-        let mut cmt = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n+        let mut place = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n         for adjustment in adjustments {\n             debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n             match adjustment.kind {\n                 adjustment::Adjust::NeverToAny |\n                 adjustment::Adjust::Pointer(_)  => {\n                     // Creating a closure/fn-pointer or unsizing consumes\n                     // the input and stores it into the resulting rvalue.\n-                    self.delegate_consume(&cmt);\n+                    self.delegate_consume(&place);\n                 }\n \n                 adjustment::Adjust::Deref(None) => {}\n@@ -477,41 +477,41 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 // this is an autoref of `x`.\n                 adjustment::Adjust::Deref(Some(ref deref)) => {\n                     let bk = ty::BorrowKind::from_mutbl(deref.mutbl);\n-                    self.delegate.borrow(&cmt, bk);\n+                    self.delegate.borrow(&place, bk);\n                 }\n \n                 adjustment::Adjust::Borrow(ref autoref) => {\n-                    self.walk_autoref(expr, &cmt, autoref);\n+                    self.walk_autoref(expr, &place, autoref);\n                 }\n             }\n-            cmt = return_if_err!(self.mc.cat_expr_adjusted(expr, cmt, &adjustment));\n+            place = return_if_err!(self.mc.cat_expr_adjusted(expr, place, &adjustment));\n         }\n     }\n \n     /// Walks the autoref `autoref` applied to the autoderef'd\n-    /// `expr`. `cmt_base` is the mem-categorized form of `expr`\n+    /// `expr`. `base_place` is the mem-categorized form of `expr`\n     /// after all relevant autoderefs have occurred.\n     fn walk_autoref(&mut self,\n                     expr: &hir::Expr,\n-                    cmt_base: &mc::Place<'tcx>,\n+                    base_place: &mc::Place<'tcx>,\n                     autoref: &adjustment::AutoBorrow<'tcx>) {\n-        debug!(\"walk_autoref(expr.hir_id={} cmt_base={:?} autoref={:?})\",\n+        debug!(\"walk_autoref(expr.hir_id={} base_place={:?} autoref={:?})\",\n                expr.hir_id,\n-               cmt_base,\n+               base_place,\n                autoref);\n \n         match *autoref {\n             adjustment::AutoBorrow::Ref(_, m) => {\n-                self.delegate.borrow(cmt_base, ty::BorrowKind::from_mutbl(m.into()));\n+                self.delegate.borrow(base_place, ty::BorrowKind::from_mutbl(m.into()));\n             }\n \n             adjustment::AutoBorrow::RawPtr(m) => {\n-                debug!(\"walk_autoref: expr.hir_id={} cmt_base={:?}\",\n+                debug!(\"walk_autoref: expr.hir_id={} base_place={:?}\",\n                        expr.hir_id,\n-                       cmt_base);\n+                       base_place);\n \n \n-                self.delegate.borrow(cmt_base, ty::BorrowKind::from_mutbl(m));\n+                self.delegate.borrow(base_place, ty::BorrowKind::from_mutbl(m));\n             }\n         }\n     }\n@@ -556,8 +556,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     // Each match binding is effectively an assignment to the\n                     // binding being produced.\n                     let def = Res::Local(canonical_id);\n-                    if let Ok(ref binding_cmt) = mc.cat_res(pat.hir_id, pat.span, pat_ty, def) {\n-                        delegate.mutate(binding_cmt);\n+                    if let Ok(ref binding_place) = mc.cat_res(pat.hir_id, pat.span, pat_ty, def) {\n+                        delegate.mutate(binding_place);\n                     }\n \n                     // It is also a borrow or copy/move of the value being matched.\n@@ -590,16 +590,18 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     closure_expr_id: closure_def_id.to_local(),\n                 };\n                 let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n-                let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.hir_id,\n-                                                                   fn_decl_span,\n-                                                                   var_id));\n+                let captured_place = return_if_err!(self.cat_captured_var(\n+                    closure_expr.hir_id,\n+                    fn_decl_span,\n+                    var_id,\n+                ));\n                 match upvar_capture {\n                     ty::UpvarCapture::ByValue => {\n-                        let mode = copy_or_move(&self.mc, &cmt_var);\n-                        self.delegate.consume(&cmt_var, mode);\n+                        let mode = copy_or_move(&self.mc, &captured_place);\n+                        self.delegate.consume(&captured_place, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                        self.delegate.borrow(&cmt_var, upvar_borrow.kind);\n+                        self.delegate.borrow(&captured_place, upvar_borrow.kind);\n                     }\n                 }\n             }\n@@ -611,7 +613,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         closure_span: Span,\n                         var_id: hir::HirId)\n                         -> mc::McResult<mc::Place<'tcx>> {\n-        // Create the cmt for the variable being borrowed, from the\n+        // Create the place for the variable being borrowed, from the\n         // perspective of the creator (parent) of the closure.\n         let var_ty = self.mc.node_ty(var_id)?;\n         self.mc.cat_res(closure_hir_id, closure_span, var_ty, Res::Local(var_id))"}, {"sha": "9b0a12234a7ef0af3f6785054768f888adfdd9a7", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c87de41f99f0523490e826222edb21d6cc361415/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c87de41f99f0523490e826222edb21d6cc361415/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c87de41f99f0523490e826222edb21d6cc361415", "patch": "@@ -529,16 +529,16 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             mutbl,\n         });\n \n-        let base_cmt = self.cat_rvalue(expr.hir_id, expr.span, ref_ty);\n-        self.cat_deref(expr, base_cmt)\n+        let base = self.cat_rvalue(expr.hir_id, expr.span, ref_ty);\n+        self.cat_deref(expr, base)\n     }\n \n     fn cat_deref(\n         &self,\n         node: &impl HirNode,\n         base_place: Place<'tcx>,\n     ) -> McResult<Place<'tcx>> {\n-        debug!(\"cat_deref: base_cmt={:?}\", base_place);\n+        debug!(\"cat_deref: base_place={:?}\", base_place);\n \n         let base_ty = base_place.ty;\n         let deref_ty = match base_ty.builtin_deref(true) {\n@@ -598,7 +598,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // `&&Some(x,)` `place_foo`\n         //  `&Some(x,)` `deref { place_foo}`\n         //   `Some(x,)` `deref { deref { place_foo }}`\n-        //        (x,)` `field0 { deref { deref { place_foo }}}` <- resulting cmt\n+        //        (x,)` `field0 { deref { deref { place_foo }}}` <- resulting place\n         //\n         // The above example has no adjustments. If the code were instead the (after adjustments,\n         // equivalent) version\n@@ -625,14 +625,14 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         let place = place; // lose mutability\n         debug!(\"cat_pattern: applied adjustment derefs to get place={:?}\", place);\n \n-        // Invoke the callback, but only now, after the `cmt` has adjusted.\n+        // Invoke the callback, but only now, after the `place` has adjusted.\n         //\n         // To see that this makes sense, consider `match &Some(3) { Some(x) => { ... }}`. In that\n-        // case, the initial `cmt` will be that for `&Some(3)` and the pattern is `Some(x)`. We\n+        // case, the initial `place` will be that for `&Some(3)` and the pattern is `Some(x)`. We\n         // don't want to call `op` with these incompatible values. As written, what happens instead\n-        // is that `op` is called with the adjusted cmt (that for `*&Some(3)`) and the pattern\n+        // is that `op` is called with the adjusted place (that for `*&Some(3)`) and the pattern\n         // `Some(x)` (which matches). Recursing once more, `*&Some(3)` and the pattern `Some(x)`\n-        // result in the cmt `Downcast<Some>(*&Some(3)).0` associated to `x` and invoke `op` with\n+        // result in the place `Downcast<Some>(*&Some(3)).0` associated to `x` and invoke `op` with\n         // that (where the `ref` on `x` is implied).\n         op(&place, pat);\n \n@@ -651,8 +651,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 // S { f1: p1, ..., fN: pN }\n                 for fp in field_pats {\n                     let field_ty = self.pat_ty_adjusted(&fp.pat)?;\n-                    let cmt_field = self.cat_projection(pat, place.clone(), field_ty);\n-                    self.cat_pattern_(cmt_field, &fp.pat, op)?;\n+                    let field_place = self.cat_projection(pat, place.clone(), field_ty);\n+                    self.cat_pattern_(field_place, &fp.pat, op)?;\n                 }\n             }\n "}, {"sha": "daaa21202ac21be2e0872075b6366a0c6b15c52f", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c87de41f99f0523490e826222edb21d6cc361415/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c87de41f99f0523490e826222edb21d6cc361415/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=c87de41f99f0523490e826222edb21d6cc361415", "patch": "@@ -341,7 +341,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         self.adjust_upvar_captures.insert(upvar_id, ty::UpvarCapture::ByValue);\n     }\n \n-    /// Indicates that `cmt` is being directly mutated (e.g., assigned\n+    /// Indicates that `place` is being directly mutated (e.g., assigned\n     /// to). If the place is based on a by-ref upvar, this implies that\n     /// the upvar must be borrowed using an `&mut` borrow.\n     fn adjust_upvar_borrow_kind_for_mut(&mut self, place: &mc::Place<'tcx>) {"}]}