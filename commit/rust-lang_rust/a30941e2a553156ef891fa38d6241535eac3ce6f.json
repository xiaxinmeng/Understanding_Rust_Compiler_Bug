{"sha": "a30941e2a553156ef891fa38d6241535eac3ce6f", "node_id": "C_kwDOAAsO6NoAKGEzMDk0MWUyYTU1MzE1NmVmODkxZmEzOGQ2MjQxNTM1ZWFjM2NlNmY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-14T11:57:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-14T11:57:16Z"}, "message": "Merge #10517\n\n10517: Show cargo check failures to the user r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/10515\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "894589570166d2bd064f3f6d13809de5b8215690", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/894589570166d2bd064f3f6d13809de5b8215690"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a30941e2a553156ef891fa38d6241535eac3ce6f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhaBscCRBK7hj4Ov3rIwAAHa8IADilecUv+tPRPVxNfoIRczZd\noNd/k6Wg/kBVQSFa1wNjmq/T/gEgSohnnQAUgBXHH7USzKivKH6CSnNZnkBjPAdl\nvqcVvxryZ/+yAJjNxySpDJIGUVrt+RzJNXoN9mkXN/WexVraM2vXDQoJ+wLOfesi\noY/5hLX+Ttipkrl0IDoE23mKnbcH2BMG2rJkqUFzB0FQF2ri/dmQ72OU83meZa8N\nZ/dAcTXZGAJShLDZx4t0eamN0XYNfvytMf7nZdTJl6Zd8nmFZEne5UDGiB3i9271\n4oinJpPw3gW3sBQjtgHdEpTee17he5jskGHRaCtbMS191G+OXAlGR2a/IhQ/54c=\n=0AF5\n-----END PGP SIGNATURE-----\n", "payload": "tree 894589570166d2bd064f3f6d13809de5b8215690\nparent 8619058d3da8b1cc40dd1eb18e5643577b6a9492\nparent 168f9adaf581a0f317881dcc8ad28c195f479191\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1634212636 +0000\ncommitter GitHub <noreply@github.com> 1634212636 +0000\n\nMerge #10517\n\n10517: Show cargo check failures to the user r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/10515\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a30941e2a553156ef891fa38d6241535eac3ce6f", "html_url": "https://github.com/rust-lang/rust/commit/a30941e2a553156ef891fa38d6241535eac3ce6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a30941e2a553156ef891fa38d6241535eac3ce6f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8619058d3da8b1cc40dd1eb18e5643577b6a9492", "url": "https://api.github.com/repos/rust-lang/rust/commits/8619058d3da8b1cc40dd1eb18e5643577b6a9492", "html_url": "https://github.com/rust-lang/rust/commit/8619058d3da8b1cc40dd1eb18e5643577b6a9492"}, {"sha": "168f9adaf581a0f317881dcc8ad28c195f479191", "url": "https://api.github.com/repos/rust-lang/rust/commits/168f9adaf581a0f317881dcc8ad28c195f479191", "html_url": "https://github.com/rust-lang/rust/commit/168f9adaf581a0f317881dcc8ad28c195f479191"}], "stats": {"total": 133, "additions": 62, "deletions": 71}, "files": [{"sha": "34996280cafe7425536c0bab1d043d3ab370fdc4", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 57, "deletions": 70, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/a30941e2a553156ef891fa38d6241535eac3ce6f/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30941e2a553156ef891fa38d6241535eac3ce6f/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=a30941e2a553156ef891fa38d6241535eac3ce6f", "patch": "@@ -2,17 +2,12 @@\n //! another compatible command (f.x. clippy) in a background thread and provide\n //! LSP diagnostics based on the output of the command.\n \n-use std::{\n-    fmt,\n-    io::{self, BufRead, BufReader},\n-    process::{self, Command, Stdio},\n-    time::Duration,\n-};\n+use std::{fmt, io, process::Command, time::Duration};\n \n use crossbeam_channel::{never, select, unbounded, Receiver, Sender};\n use paths::AbsPathBuf;\n use serde::Deserialize;\n-use stdx::JodChild;\n+use stdx::process::streaming_output;\n \n pub use cargo_metadata::diagnostic::{\n     Applicability, Diagnostic, DiagnosticCode, DiagnosticLevel, DiagnosticSpan,\n@@ -162,13 +157,10 @@ impl FlycheckActor {\n \n                     self.cancel_check_process();\n \n-                    let mut command = self.check_command();\n+                    let command = self.check_command();\n                     tracing::info!(\"restart flycheck {:?}\", command);\n-                    command.stdout(Stdio::piped()).stderr(Stdio::null()).stdin(Stdio::null());\n-                    if let Ok(child) = command.spawn().map(JodChild) {\n-                        self.cargo_handle = Some(CargoHandle::spawn(child));\n-                        self.progress(Progress::DidStart);\n-                    }\n+                    self.cargo_handle = Some(CargoHandle::spawn(command));\n+                    self.progress(Progress::DidStart);\n                 }\n                 Event::CheckEvent(None) => {\n                     // Watcher finished, replace it with a never channel to\n@@ -258,53 +250,36 @@ impl FlycheckActor {\n }\n \n struct CargoHandle {\n-    child: JodChild,\n-    #[allow(unused)]\n-    thread: jod_thread::JoinHandle<bool>,\n+    thread: jod_thread::JoinHandle<io::Result<()>>,\n     receiver: Receiver<CargoMessage>,\n }\n \n impl CargoHandle {\n-    fn spawn(mut child: JodChild) -> CargoHandle {\n-        let child_stdout = child.stdout.take().unwrap();\n+    fn spawn(command: Command) -> CargoHandle {\n         let (sender, receiver) = unbounded();\n-        let actor = CargoActor::new(child_stdout, sender);\n+        let actor = CargoActor::new(sender);\n         let thread = jod_thread::Builder::new()\n             .name(\"CargoHandle\".to_owned())\n-            .spawn(move || actor.run())\n+            .spawn(move || actor.run(command))\n             .expect(\"failed to spawn thread\");\n-        CargoHandle { child, thread, receiver }\n+        CargoHandle { thread, receiver }\n     }\n-    fn join(mut self) -> io::Result<()> {\n-        // It is okay to ignore the result, as it only errors if the process is already dead\n-        let _ = self.child.kill();\n-        let exit_status = self.child.wait()?;\n-        let read_at_least_one_message = self.thread.join();\n-        if !exit_status.success() && !read_at_least_one_message {\n-            // FIXME: Read the stderr to display the reason, see `read2()` reference in PR comment:\n-            // https://github.com/rust-analyzer/rust-analyzer/pull/3632#discussion_r395605298\n-            return Err(io::Error::new(\n-                io::ErrorKind::Other,\n-                format!(\n-                    \"Cargo watcher failed, the command produced no valid metadata (exit code: {:?})\",\n-                    exit_status\n-                ),\n-            ));\n-        }\n-        Ok(())\n+\n+    fn join(self) -> io::Result<()> {\n+        self.thread.join()\n     }\n }\n \n struct CargoActor {\n-    child_stdout: process::ChildStdout,\n     sender: Sender<CargoMessage>,\n }\n \n impl CargoActor {\n-    fn new(child_stdout: process::ChildStdout, sender: Sender<CargoMessage>) -> CargoActor {\n-        CargoActor { child_stdout, sender }\n+    fn new(sender: Sender<CargoMessage>) -> CargoActor {\n+        CargoActor { sender }\n     }\n-    fn run(self) -> bool {\n+\n+    fn run(self, command: Command) -> io::Result<()> {\n         // We manually read a line at a time, instead of using serde's\n         // stream deserializers, because the deserializer cannot recover\n         // from an error, resulting in it getting stuck, because we try to\n@@ -313,41 +288,53 @@ impl CargoActor {\n         // Because cargo only outputs one JSON object per line, we can\n         // simply skip a line if it doesn't parse, which just ignores any\n         // erroneus output.\n-        let stdout = BufReader::new(self.child_stdout);\n-        let mut read_at_least_one_message = false;\n-        for message in stdout.lines() {\n-            let message = match message {\n-                Ok(message) => message,\n-                Err(err) => {\n-                    tracing::error!(\"Invalid json from cargo check, ignoring ({})\", err);\n-                    continue;\n-                }\n-            };\n \n-            read_at_least_one_message = true;\n+        let mut error = String::new();\n+        let mut read_at_least_one_message = false;\n+        let output = streaming_output(\n+            command,\n+            &mut |line| {\n+                read_at_least_one_message = true;\n \n-            // Try to deserialize a message from Cargo or Rustc.\n-            let mut deserializer = serde_json::Deserializer::from_str(&message);\n-            deserializer.disable_recursion_limit();\n-            if let Ok(message) = JsonMessage::deserialize(&mut deserializer) {\n-                match message {\n-                    // Skip certain kinds of messages to only spend time on what's useful\n-                    JsonMessage::Cargo(message) => match message {\n-                        cargo_metadata::Message::CompilerArtifact(artifact) if !artifact.fresh => {\n-                            self.sender.send(CargoMessage::CompilerArtifact(artifact)).unwrap();\n+                // Try to deserialize a message from Cargo or Rustc.\n+                let mut deserializer = serde_json::Deserializer::from_str(&line);\n+                deserializer.disable_recursion_limit();\n+                if let Ok(message) = JsonMessage::deserialize(&mut deserializer) {\n+                    match message {\n+                        // Skip certain kinds of messages to only spend time on what's useful\n+                        JsonMessage::Cargo(message) => match message {\n+                            cargo_metadata::Message::CompilerArtifact(artifact)\n+                                if !artifact.fresh =>\n+                            {\n+                                self.sender.send(CargoMessage::CompilerArtifact(artifact)).unwrap();\n+                            }\n+                            cargo_metadata::Message::CompilerMessage(msg) => {\n+                                self.sender.send(CargoMessage::Diagnostic(msg.message)).unwrap();\n+                            }\n+                            _ => (),\n+                        },\n+                        JsonMessage::Rustc(message) => {\n+                            self.sender.send(CargoMessage::Diagnostic(message)).unwrap();\n                         }\n-                        cargo_metadata::Message::CompilerMessage(msg) => {\n-                            self.sender.send(CargoMessage::Diagnostic(msg.message)).unwrap();\n-                        }\n-                        _ => (),\n-                    },\n-                    JsonMessage::Rustc(message) => {\n-                        self.sender.send(CargoMessage::Diagnostic(message)).unwrap();\n                     }\n                 }\n+            },\n+            &mut |line| {\n+                error.push_str(line);\n+                error.push('\\n');\n+            },\n+        );\n+        match output {\n+            Ok(_) if read_at_least_one_message => Ok(()),\n+            Ok(output) if output.status.success() => {\n+                Err(io::Error::new(io::ErrorKind::Other, format!(\n+                    \"Cargo watcher failed, the command produced no valid metadata (exit code: {:?})\",\n+                    output.status\n+                )))\n             }\n+            Ok(_) => Err(io::Error::new(io::ErrorKind::Other, error)),\n+            Err(e) => Err(e),\n         }\n-        read_at_least_one_message\n     }\n }\n "}, {"sha": "9e1bac854d5e146bfdd8aac8f77a81236cd14a8a", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a30941e2a553156ef891fa38d6241535eac3ce6f/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30941e2a553156ef891fa38d6241535eac3ce6f/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=a30941e2a553156ef891fa38d6241535eac3ce6f", "patch": "@@ -394,7 +394,10 @@ impl GlobalState {\n                                 flycheck::Progress::DidCancel => (Progress::End, None),\n                                 flycheck::Progress::DidFinish(result) => {\n                                     if let Err(err) = result {\n-                                        tracing::error!(\"cargo check failed: {}\", err)\n+                                        self.show_message(\n+                                            lsp_types::MessageType::Error,\n+                                            format!(\"cargo check failed: {}\", err),\n+                                        );\n                                     }\n                                     (Progress::End, None)\n                                 }"}, {"sha": "b26b71c9de99a7a0138724b9994035e95a626a39", "filename": "crates/stdx/src/process.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a30941e2a553156ef891fa38d6241535eac3ce6f/crates%2Fstdx%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a30941e2a553156ef891fa38d6241535eac3ce6f/crates%2Fstdx%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Fprocess.rs?ref=a30941e2a553156ef891fa38d6241535eac3ce6f", "patch": "@@ -49,6 +49,7 @@ pub fn streaming_output(\n                 }\n             }\n         })?;\n+        let _ = child.kill();\n         child.wait()?\n     };\n "}]}