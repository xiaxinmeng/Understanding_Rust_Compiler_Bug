{"sha": "16b9f67bf3bed2313eb53a3d37e5d4def1d88838", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2YjlmNjdiZjNiZWQyMzEzZWI1M2EzZDM3ZTVkNGRlZjFkODg4Mzg=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-11-12T18:43:06Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-11-19T00:30:05Z"}, "message": "Error handling guide", "tree": {"sha": "ec5020a34581a0de69c40e0454211812a79d7540", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec5020a34581a0de69c40e0454211812a79d7540"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16b9f67bf3bed2313eb53a3d37e5d4def1d88838", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16b9f67bf3bed2313eb53a3d37e5d4def1d88838", "html_url": "https://github.com/rust-lang/rust/commit/16b9f67bf3bed2313eb53a3d37e5d4def1d88838", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16b9f67bf3bed2313eb53a3d37e5d4def1d88838/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e6d97aab2dac7cb35afa70436a82d30280921a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e6d97aab2dac7cb35afa70436a82d30280921a3", "html_url": "https://github.com/rust-lang/rust/commit/0e6d97aab2dac7cb35afa70436a82d30280921a3"}], "stats": {"total": 271, "additions": 225, "deletions": 46}, "files": [{"sha": "427ca4ba1a1635888d48a82be236d9dc27d91e79", "filename": "src/doc/guide-error-handling.md", "status": "modified", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/16b9f67bf3bed2313eb53a3d37e5d4def1d88838/src%2Fdoc%2Fguide-error-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/16b9f67bf3bed2313eb53a3d37e5d4def1d88838/src%2Fdoc%2Fguide-error-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-error-handling.md?ref=16b9f67bf3bed2313eb53a3d37e5d4def1d88838", "patch": "@@ -1,2 +1,227 @@\n % Error Handling in Rust\n \n+> The best-laid plans of mice and men\n+> Often go awry\n+> \n+> \"Tae a Moose\", Robert Burns\n+\n+Sometimes, things just go wrong. It's important to have a plan for when the\n+inevitable happens. Rust has rich support for handling errors that may (let's\n+be honest: will) occur in your programs.\n+\n+There are two main kinds of errors that can occur in your programs: failures,\n+and panics. Let's talk about the difference between the two, and then discuss\n+how to handle each. Then, we'll discuss upgrading failures to panics.\n+\n+# Failure vs. Panic\n+\n+Rust uses two terms to differentiate between two forms of error: failure, and\n+panic. A **failure** is an error that can be recovered from in some way. A\n+**panic** is an error that cannot be recovered from.\n+\n+What do we mean by 'recover'? Well, in most cases, the possibility of an error\n+is expected. For example, consider the `from_str` function:\n+\n+```{rust,ignore}\n+from_str(\"5\");\n+```\n+\n+This function takes a string argument and converts it into another type. But\n+because it's a string, you can't be sure that the conversion actually works.\n+For example, what should this convert to?\n+\n+```{rust,ignore}\n+from_str(\"hello5world\");\n+```\n+\n+This won't work. So we know that this function will only work properly for some\n+inputs. It's expected behavior. We call this kind of error 'failure.'\n+\n+On the other hand, sometimes, there are errors that are unexpected, or which\n+we cannot recover from. A classic example is an `assert!`:\n+\n+```{rust,ignore}\n+assert!(x == 5);\n+```\n+\n+We use `assert!` to declare that something is true. If it's not true, something\n+is very wrong. Wrong enough that we can't continue with things in the current\n+state. Another example is using the `unreachable!()` macro\n+\n+```{rust,ignore}\n+enum Event {\n+    NewRelease,\n+}\n+\n+fn probability(_: &Event) -> f64 {\n+    // real implementation would be more complex, of course\n+    0.95\n+}\n+\n+fn descriptive_probability(event: Event) -> &'static str {\n+    match probability(&event) {\n+        1.00          => \"certain\",\n+        0.00          => \"impossible\",\n+        0.00 ... 0.25 => \"very unlikely\",\n+        0.25 ... 0.50 => \"unlikely\",\n+        0.50 ... 0.75 => \"likely\",\n+        0.75 ... 1.00  => \"very likely\",\n+    }\n+}\n+\n+fn main() {\n+    std::io::println(descriptive_probability(NewRelease));\n+}\n+```\n+\n+This will give us an error:\n+\n+```{notrust,ignore}\n+error: non-exhaustive patterns: `_` not covered [E0004]\n+```\n+\n+While we know that we've covered all possible cases, Rust can't tell. It\n+doesn't know that probability is between 0.0 and 1.0. So we add another case:\n+\n+```rust\n+enum Event {\n+    NewRelease,\n+}\n+\n+fn probability(_: &Event) -> f64 {\n+    // real implementation would be more complex, of course\n+    0.95\n+}\n+\n+fn descriptive_probability(event: Event) -> &'static str {\n+    match probability(&event) {\n+        1.00          => \"certain\",\n+        0.00          => \"impossible\",\n+        0.00 ... 0.25 => \"very unlikely\",\n+        0.25 ... 0.50 => \"unlikely\",\n+        0.50 ... 0.75 => \"likely\",\n+        0.75 ... 1.00  => \"very likely\",\n+        _ => unreachable!()\n+    }\n+}\n+\n+fn main() {\n+    std::io::println(descriptive_probability(NewRelease));\n+}\n+```\n+\n+We shouldn't ever hit the `_` case, so we use the `unreachable!()` macro to\n+indicate this. `unreachable!()` gives a different kind of error than `Result`.\n+Rust calls these sorts of errors 'panics.'\n+\n+# Handling errors with `Option` and `Result`\n+\n+The simplest way to indicate that a function may fail is to use the `Option<T>`\n+type. Remember our `from_str()` example? Here's its type signature:\n+\n+```{rust,ignore}\n+pub fn from_str<A: FromStr>(s: &str) -> Option<A>\n+```\n+\n+`from_str()` returns an `Option<A>`. If the conversion succeeds, it will return\n+`Some(value)`, and if it fails, it will return `None`.\n+\n+This is appropriate for the simplest of cases, but doesn't give us a lot of\n+information in the failure case. What if we wanted to know _why_ the conversion\n+failed? For this, we can use the `Result<T, E>` type. It looks like this:\n+\n+```rust\n+enum Result<T, E> {\n+   Ok(T),\n+   Err(E)\n+}\n+```\n+\n+This enum is provided by Rust itself, so you don't need to define it to use it\n+in your code. The `Ok(T)` variant represents a success, and the `Err(E)` variant\n+represents a failure. Returning a `Result` instead of an `Option` is recommended\n+for all but the most trivial of situations.\n+\n+Here's an example of using `Result`:\n+\n+```rust\n+#[deriving(Show)]\n+enum Version { Version1, Version2 }\n+\n+#[deriving(Show)]\n+enum ParseError { InvalidHeaderLength, InvalidVersion }\n+\n+\n+fn parse_version(header: &[u8]) -> Result<Version, ParseError> {\n+    if header.len() < 1 {\n+        return Err(InvalidHeaderLength);\n+    }\n+    match header[0] {\n+        1 => Ok(Version1),\n+        2 => Ok(Version2),\n+        _ => Err(InvalidVersion)\n+    }\n+}\n+\n+let version = parse_version(&[1, 2, 3, 4]);\n+match version {\n+    Ok(v) => {\n+        println!(\"working with version: {}\", v);\n+    }\n+    Err(e) => {\n+        println!(\"error parsing header: {}\", e);\n+    }\n+}\n+```\n+\n+This function makes use of an enum, `ParseError`, to enumerate the various\n+errors that can occur.\n+\n+# Non-recoverable errors with `panic!`\n+\n+In the case of an error that is unexpected and not recoverable, the `panic!`\n+macro will induce a panic. This will crash the current task, and give an error:\n+\n+```{rust,ignore}\n+panic!(\"boom\");\n+```\n+\n+gives\n+\n+```{notrust,ignore}\n+task '<main>' panicked at 'boom', hello.rs:2\n+```\n+\n+when you run it.\n+\n+Because these kinds of situations are relatively rare, use panics sparingly.\n+\n+# Upgrading failures to panics\n+\n+In certain circumstances, even though a function may fail, we may want to treat\n+it as a panic instead. For example, `io::stdin().read_line()` returns an\n+`IoResult<String>`, a form of `Result`, when there is an error reading the\n+line. This allows us to handle and possibly recover from this sort of error.\n+\n+If we don't want to handle this error, and would rather just abort the program,\n+we can use the `unwrap()` method:\n+\n+```{rust,ignore}\n+io::stdin().read_line().unwrap();\n+```\n+\n+`unwrap()` will `panic!` if the `Option` is `None`. This basically says \"Give\n+me the value, and if something goes wrong, just crash.\" This is less reliable\n+than matching the error and attempting to recover, but is also significantly\n+shorter. Sometimes, just crashing is appropriate.\n+\n+There's another way of doing this that's a bit nicer than `unwrap()`:\n+\n+```{rust,ignore}\n+let input = io::stdin().read_line()\n+                       .ok()\n+                       .expect(\"Failed to read line\");\n+```\n+`ok()` converts the `IoResult` into an `Option`, and `expect()` does the same\n+thing as `unwrap()`, but takes a message. This message is passed along to the\n+underlying `panic!`, providing a better error message if the code errors."}, {"sha": "e2f739457970f5227c95400fa7ed5987c628af1a", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/16b9f67bf3bed2313eb53a3d37e5d4def1d88838/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b9f67bf3bed2313eb53a3d37e5d4def1d88838/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=16b9f67bf3bed2313eb53a3d37e5d4def1d88838", "patch": "@@ -227,52 +227,6 @@\n //! ```\n //!\n //! `try!` is imported by the prelude, and is available everywhere.\n-//!\n-//! # `Result` and `Option`\n-//!\n-//! The `Result` and [`Option`](../option/index.html) types are\n-//! similar and complementary: they are often employed to indicate a\n-//! lack of a return value; and they are trivially converted between\n-//! each other, so `Result`s are often handled by first converting to\n-//! `Option` with the [`ok`](type.Result.html#method.ok) and\n-//! [`err`](type.Result.html#method.ok) methods.\n-//!\n-//! Whereas `Option` only indicates the lack of a value, `Result` is\n-//! specifically for error reporting, and carries with it an error\n-//! value.  Sometimes `Option` is used for indicating errors, but this\n-//! is only for simple cases and is generally discouraged. Even when\n-//! there is no useful error value to return, prefer `Result<T, ()>`.\n-//!\n-//! Converting to an `Option` with `ok()` to handle an error:\n-//!\n-//! ```\n-//! use std::io::Timer;\n-//! let mut t = Timer::new().ok().expect(\"failed to create timer!\");\n-//! ```\n-//!\n-//! # `Result` vs. `panic!`\n-//!\n-//! `Result` is for recoverable errors; `panic!` is for unrecoverable\n-//! errors. Callers should always be able to avoid panics if they\n-//! take the proper precautions, for example, calling `is_some()`\n-//! on an `Option` type before calling `unwrap`.\n-//!\n-//! The suitability of `panic!` as an error handling mechanism is\n-//! limited by Rust's lack of any way to \"catch\" and resume execution\n-//! from a thrown exception. Therefore using panics for error\n-//! handling requires encapsulating code that may panic in a task.\n-//! Calling the `panic!` macro, or invoking `panic!` indirectly should be\n-//! avoided as an error reporting strategy. Panics is only for\n-//! unrecoverable errors and a panicking task is typically the sign of\n-//! a bug.\n-//!\n-//! A module that instead returns `Results` is alerting the caller\n-//! that failure is possible, and providing precise control over how\n-//! it is handled.\n-//!\n-//! Furthermore, panics may not be recoverable at all, depending on\n-//! the context. The caller of `panic!` should assume that execution\n-//! will not resume after the panic, that a panic is catastrophic.\n \n #![stable]\n "}]}