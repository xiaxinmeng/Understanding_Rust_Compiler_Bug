{"sha": "f6a6d2fef6c090806e961acb89817be8329f8208", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2YTZkMmZlZjZjMDkwODA2ZTk2MWFjYjg5ODE3YmU4MzI5ZjgyMDg=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-08-01T18:07:12Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-09-05T02:51:29Z"}, "message": "Add slice::array_chunks_mut", "tree": {"sha": "8ce01f73d4b845a9e186526d571a01192f5826ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ce01f73d4b845a9e186526d571a01192f5826ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6a6d2fef6c090806e961acb89817be8329f8208", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6a6d2fef6c090806e961acb89817be8329f8208", "html_url": "https://github.com/rust-lang/rust/commit/f6a6d2fef6c090806e961acb89817be8329f8208", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6a6d2fef6c090806e961acb89817be8329f8208/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70c5f6efc445963bbfa5dd53f81c245741eac8cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/70c5f6efc445963bbfa5dd53f81c245741eac8cb", "html_url": "https://github.com/rust-lang/rust/commit/70c5f6efc445963bbfa5dd53f81c245741eac8cb"}], "stats": {"total": 151, "additions": 146, "deletions": 5}, "files": [{"sha": "18ff50b8dbd418c416ac5b3be2130091ea02548d", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 146, "deletions": 5, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/f6a6d2fef6c090806e961acb89817be8329f8208/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a6d2fef6c090806e961acb89817be8329f8208/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=f6a6d2fef6c090806e961acb89817be8329f8208", "patch": "@@ -997,9 +997,9 @@ impl<T> [T] {\n     /// Returns an iterator over `N` elements of the slice at a time, starting at the\n     /// beginning of the slice.\n     ///\n-    /// The chunks are slices and do not overlap. If `N` does not divide the length of the\n-    /// slice, then the last up to `N-1` elements will be omitted and can be retrieved\n-    /// from the `remainder` function of the iterator.\n+    /// The chunks are array references and do not overlap. If `N` does not divide the\n+    /// length of the slice, then the last up to `N-1` elements will be omitted and can be\n+    /// retrieved from the `remainder` function of the iterator.\n     ///\n     /// This method is the const generic equivalent of [`chunks_exact`].\n     ///\n@@ -1033,6 +1033,51 @@ impl<T> [T] {\n         ArrayChunks { iter: array_slice.iter(), rem: snd }\n     }\n \n+    /// Returns an iterator over `N` elements of the slice at a time, starting at the\n+    /// beginning of the slice.\n+    ///\n+    /// The chunks are mutable array references and do not overlap. If `N` does not divide\n+    /// the length of the slice, then the last up to `N-1` elements will be omitted and\n+    /// can be retrieved from the `into_remainder` function of the iterator.\n+    ///\n+    /// This method is the const generic equivalent of [`chunks_exact_mut`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `N` is 0. This check will most probably get changed to a compile time\n+    /// error before this method gets stabilized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(array_chunks)]\n+    /// let v = &mut [0, 0, 0, 0, 0];\n+    /// let mut count = 1;\n+    ///\n+    /// for chunk in v.array_chunks_mut() {\n+    ///     *chunk = [count; 2];\n+    ///     count += 1;\n+    /// }\n+    /// assert_eq!(v, &[1, 1, 2, 2, 0]);\n+    /// ```\n+    ///\n+    /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n+    #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+    #[inline]\n+    pub fn array_chunks_mut<const N: usize>(&mut self) -> ArrayChunksMut<'_, T, N> {\n+        assert_ne!(N, 0);\n+        let len = self.len() / N;\n+        let (fst_ptr, snd) = {\n+            // Scope the first slice into a pointer to avoid aliasing the new slice below.\n+            let (fst, snd) = self.split_at_mut(len * N);\n+            (fst.as_mut_ptr(), snd)\n+        };\n+        // SAFETY: We cast a slice of `len * N` elements into\n+        // a slice of `len` many `N` elements chunks.\n+        let array_slice: &mut [[T; N]] = unsafe { from_raw_parts_mut(fst_ptr.cast(), len) };\n+        ArrayChunksMut { iter: array_slice.iter_mut(), rem: snd }\n+    }\n+\n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n     /// of the slice.\n     ///\n@@ -5826,7 +5871,7 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n /// time), starting at the beginning of the slice.\n ///\n /// When the slice len is not evenly divided by the chunk size, the last\n-/// up to `chunk_size-1` elements will be omitted but can be retrieved from\n+/// up to `N-1` elements will be omitted but can be retrieved from\n /// the [`remainder`] function from the iterator.\n ///\n /// This struct is created by the [`array_chunks`] method on [slices].\n@@ -5843,7 +5888,7 @@ pub struct ArrayChunks<'a, T: 'a, const N: usize> {\n \n impl<'a, T, const N: usize> ArrayChunks<'a, T, N> {\n     /// Returns the remainder of the original slice that is not going to be\n-    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// returned by the iterator. The returned slice has at most `N-1`\n     /// elements.\n     #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n     pub fn remainder(&self) -> &'a [T] {\n@@ -5929,6 +5974,102 @@ unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunks<'a, T, N>\n     }\n }\n \n+/// An iterator over a slice in (non-overlapping) mutable chunks (`N` elements\n+/// at a time), starting at the beginning of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last\n+/// up to `N-1` elements will be omitted but can be retrieved from\n+/// the [`into_remainder`] function from the iterator.\n+///\n+/// This struct is created by the [`array_chunks_mut`] method on [slices].\n+///\n+/// [`array_chunks_mut`]: ../../std/primitive.slice.html#method.array_chunks_mut\n+/// [`into_remainder`]: ../../std/slice/struct.ArrayChunksMut.html#method.into_remainder\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+pub struct ArrayChunksMut<'a, T: 'a, const N: usize> {\n+    iter: IterMut<'a, [T; N]>,\n+    rem: &'a mut [T],\n+}\n+\n+impl<'a, T, const N: usize> ArrayChunksMut<'a, T, N> {\n+    /// Returns the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `N-1`\n+    /// elements.\n+    #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+    pub fn into_remainder(self) -> &'a mut [T] {\n+        self.rem\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<'a, T, const N: usize> Iterator for ArrayChunksMut<'a, T, N> {\n+    type Item = &'a mut [T; N];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T; N]> {\n+        self.iter.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.iter.nth(n)\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        self.iter.last()\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<'a, T, const N: usize> DoubleEndedIterator for ArrayChunksMut<'a, T, N> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T; N]> {\n+        self.iter.next_back()\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        self.iter.nth_back(n)\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> ExactSizeIterator for ArrayChunksMut<'_, T, N> {\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T, const N: usize> TrustedLen for ArrayChunksMut<'_, T, N> {}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> FusedIterator for ArrayChunksMut<'_, T, N> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunksMut<'a, T, N> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T; N] {\n+        unsafe { self.iter.get_unchecked(i) }\n+    }\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n /// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n /// time), starting at the end of the slice.\n ///"}]}