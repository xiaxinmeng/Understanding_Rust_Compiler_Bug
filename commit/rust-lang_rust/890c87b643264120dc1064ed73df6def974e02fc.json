{"sha": "890c87b643264120dc1064ed73df6def974e02fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5MGM4N2I2NDMyNjQxMjBkYzEwNjRlZDczZGY2ZGVmOTc0ZTAyZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-31T01:16:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-31T01:16:17Z"}, "message": "Auto merge of #44186 - alexcrichton:rollup, r=alexcrichton\n\nRollup of 8 pull requests\n\n- Successful merges: #44044, #44089, #44116, #44125, #44154, #44157, #44160, #44172\n- Failed merges: #44162", "tree": {"sha": "f47e5a797f4d2993b32b1490ff1b1cb0af297976", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f47e5a797f4d2993b32b1490ff1b1cb0af297976"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/890c87b643264120dc1064ed73df6def974e02fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/890c87b643264120dc1064ed73df6def974e02fc", "html_url": "https://github.com/rust-lang/rust/commit/890c87b643264120dc1064ed73df6def974e02fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/890c87b643264120dc1064ed73df6def974e02fc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7eeac1b81446c6327f1827ef334eca2db7fe28f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7eeac1b81446c6327f1827ef334eca2db7fe28f7", "html_url": "https://github.com/rust-lang/rust/commit/7eeac1b81446c6327f1827ef334eca2db7fe28f7"}, {"sha": "b9fea42b7aac3c3236dbff06244685e9ec102eb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9fea42b7aac3c3236dbff06244685e9ec102eb3", "html_url": "https://github.com/rust-lang/rust/commit/b9fea42b7aac3c3236dbff06244685e9ec102eb3"}], "stats": {"total": 897, "additions": 691, "deletions": 206}, "files": [{"sha": "3161e2f97580887a24aed476385f5ef9d5844dfb", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -1038,6 +1038,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"proc_macro\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rustc_errors 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "7a559a7bec86662dbdd3aa06850e8ffa24e7b862", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -2,7 +2,7 @@\n \n The tracking issue for this feature is: [#43122]\n \n-[#34511]: https://github.com/rust-lang/rust/issues/43122\n+[#43122]: https://github.com/rust-lang/rust/issues/43122\n \n ------------------------\n "}, {"sha": "dae4475257a02988aafad92413e0eeb97f02c21d", "filename": "src/doc/unstable-book/src/library-features/splice.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -18,7 +18,6 @@ let mut s = String::from(\"\u03b1 is alpha, \u03b2 is beta\");\n let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n \n // Replace the range up until the \u03b2 from the string\n-let t: String = s.splice(..beta_offset, \"\u0391 is capital alpha; \").collect();\n-assert_eq!(t, \"\u03b1 is alpha, \");\n+s.splice(..beta_offset, \"\u0391 is capital alpha; \");\n assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n ```\n\\ No newline at end of file"}, {"sha": "43ebaa4fbdb3f17a0024a61c81abdf2b1bc4ae6b", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// Creates a `Vec` containing the arguments.\n+/// Creates a [`Vec`] containing the arguments.\n ///\n /// `vec!` allows `Vec`s to be defined with the same syntax as array expressions.\n /// There are two forms of this macro:\n ///\n-/// - Create a `Vec` containing a given list of elements:\n+/// - Create a [`Vec`] containing a given list of elements:\n ///\n /// ```\n /// let v = vec![1, 2, 3];\n@@ -22,22 +22,25 @@\n /// assert_eq!(v[2], 3);\n /// ```\n ///\n-/// - Create a `Vec` from a given element and size:\n+/// - Create a [`Vec`] from a given element and size:\n ///\n /// ```\n /// let v = vec![1; 3];\n /// assert_eq!(v, [1, 1, 1]);\n /// ```\n ///\n /// Note that unlike array expressions this syntax supports all elements\n-/// which implement `Clone` and the number of elements doesn't have to be\n+/// which implement [`Clone`] and the number of elements doesn't have to be\n /// a constant.\n ///\n-/// This will use `clone()` to duplicate an expression, so one should be careful\n+/// This will use `clone` to duplicate an expression, so one should be careful\n /// using this with types having a nonstandard `Clone` implementation. For\n /// example, `vec![Rc::new(1); 5]` will create a vector of five references\n /// to the same boxed integer value, not five references pointing to independently\n /// boxed integers.\n+///\n+/// [`Vec`]: ../std/vec/struct.Vec.html\n+/// [`Clone`]: ../std/clone/trait.Clone.html\n #[cfg(not(test))]\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -67,10 +70,22 @@ macro_rules! vec {\n     ($($x:expr,)*) => (vec![$($x),*])\n }\n \n-/// Use the syntax described in `std::fmt` to create a value of type `String`.\n-/// See [`std::fmt`][fmt] for more information.\n+/// Creates a `String` using interpolation of runtime expressions.\n+///\n+/// The first argument `format!` recieves is a format string.  This must be a string\n+/// literal.  The power of the formatting string is in the `{}`s contained.\n+///\n+/// Additional parameters passed to `format!` replace the `{}`s within the\n+/// formatting string in the order given unless named or positional parameters\n+/// are used, see [`std::fmt`][fmt] for more information.\n+///\n+/// A common use for `format!` is concatenation and interpolation of strings.\n+/// The same convention is used with [`print!`] and [`write!`] macros,\n+/// depending on the intended destination of the string.\n ///\n /// [fmt]: ../std/fmt/index.html\n+/// [`print!`]: ../std/macro.print.html\n+/// [`write!`]: ../std/macro.write.html\n ///\n /// # Panics\n ///"}, {"sha": "ddb23b2ef37bf0898d72db4e213d96b4fa70e5a5", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 19, "deletions": 90, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -1392,19 +1392,19 @@ impl String {\n     }\n \n     /// Creates a splicing iterator that removes the specified range in the string,\n-    /// replaces with the given string, and yields the removed chars.\n-    /// The given string doesn\u2019t need to be the same length as the range.\n+    /// and replaces it with the given string.\n+    /// The given string doesn't need to be the same length as the range.\n     ///\n-    /// Note: The element range is removed when the [`Splice`] is dropped,\n-    /// even if the iterator is not consumed until the end.\n+    /// Note: Unlike [`Vec::splice`], the replacement happens eagerly, and this\n+    /// method does not return the removed chars.\n     ///\n     /// # Panics\n     ///\n     /// Panics if the starting point or end point do not lie on a [`char`]\n     /// boundary, or if they're out of bounds.\n     ///\n     /// [`char`]: ../../std/primitive.char.html\n-    /// [`Splice`]: ../../std/string/struct.Splice.html\n+    /// [`Vec::splice`]: ../../std/vec/struct.Vec.html#method.splice\n     ///\n     /// # Examples\n     ///\n@@ -1416,45 +1416,32 @@ impl String {\n     /// let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n     ///\n     /// // Replace the range up until the \u03b2 from the string\n-    /// let t: String = s.splice(..beta_offset, \"\u0391 is capital alpha; \").collect();\n-    /// assert_eq!(t, \"\u03b1 is alpha, \");\n+    /// s.splice(..beta_offset, \"\u0391 is capital alpha; \");\n     /// assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n     /// ```\n     #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-    pub fn splice<'a, 'b, R>(&'a mut self, range: R, replace_with: &'b str) -> Splice<'a, 'b>\n+    pub fn splice<R>(&mut self, range: R, replace_with: &str)\n         where R: RangeArgument<usize>\n     {\n         // Memory safety\n         //\n         // The String version of Splice does not have the memory safety issues\n         // of the vector version. The data is just plain bytes.\n-        // Because the range removal happens in Drop, if the Splice iterator is leaked,\n-        // the removal will not happen.\n-        let len = self.len();\n-        let start = match range.start() {\n-             Included(&n) => n,\n-             Excluded(&n) => n + 1,\n-             Unbounded => 0,\n+\n+        match range.start() {\n+             Included(&n) => assert!(self.is_char_boundary(n)),\n+             Excluded(&n) => assert!(self.is_char_boundary(n + 1)),\n+             Unbounded => {},\n         };\n-        let end = match range.end() {\n-             Included(&n) => n + 1,\n-             Excluded(&n) => n,\n-             Unbounded => len,\n+        match range.end() {\n+             Included(&n) => assert!(self.is_char_boundary(n + 1)),\n+             Excluded(&n) => assert!(self.is_char_boundary(n)),\n+             Unbounded => {},\n         };\n \n-        // Take out two simultaneous borrows. The &mut String won't be accessed\n-        // until iteration is over, in Drop.\n-        let self_ptr = self as *mut _;\n-        // slicing does the appropriate bounds checks\n-        let chars_iter = self[start..end].chars();\n-\n-        Splice {\n-            start,\n-            end,\n-            iter: chars_iter,\n-            string: self_ptr,\n-            replace_with,\n-        }\n+        unsafe {\n+            self.as_mut_vec()\n+        }.splice(range, replace_with.bytes());\n     }\n \n     /// Converts this `String` into a [`Box`]`<`[`str`]`>`.\n@@ -2241,61 +2228,3 @@ impl<'a> DoubleEndedIterator for Drain<'a> {\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a> FusedIterator for Drain<'a> {}\n-\n-/// A splicing iterator for `String`.\n-///\n-/// This struct is created by the [`splice()`] method on [`String`]. See its\n-/// documentation for more.\n-///\n-/// [`splice()`]: struct.String.html#method.splice\n-/// [`String`]: struct.String.html\n-#[derive(Debug)]\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-pub struct Splice<'a, 'b> {\n-    /// Will be used as &'a mut String in the destructor\n-    string: *mut String,\n-    /// Start of part to remove\n-    start: usize,\n-    /// End of part to remove\n-    end: usize,\n-    /// Current remaining range to remove\n-    iter: Chars<'a>,\n-    replace_with: &'b str,\n-}\n-\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-unsafe impl<'a, 'b> Sync for Splice<'a, 'b> {}\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-unsafe impl<'a, 'b> Send for Splice<'a, 'b> {}\n-\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-impl<'a, 'b> Drop for Splice<'a, 'b> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let vec = (*self.string).as_mut_vec();\n-            vec.splice(self.start..self.end, self.replace_with.bytes());\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-impl<'a, 'b> Iterator for Splice<'a, 'b> {\n-    type Item = char;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<char> {\n-        self.iter.next()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n-impl<'a, 'b> DoubleEndedIterator for Splice<'a, 'b> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<char> {\n-        self.iter.next_back()\n-    }\n-}"}, {"sha": "6aba18ddf49ffe072f63a3641fa91140070d3f47", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -442,9 +442,8 @@ fn test_drain() {\n #[test]\n fn test_splice() {\n     let mut s = \"Hello, world!\".to_owned();\n-    let t: String = s.splice(7..12, \"\u4e16\u754c\").collect();\n+    s.splice(7..12, \"\u4e16\u754c\");\n     assert_eq!(s, \"Hello, \u4e16\u754c!\");\n-    assert_eq!(t, \"world\");\n }\n \n #[test]\n@@ -457,12 +456,10 @@ fn test_splice_char_boundary() {\n #[test]\n fn test_splice_inclusive_range() {\n     let mut v = String::from(\"12345\");\n-    let t: String = v.splice(2...3, \"789\").collect();\n+    v.splice(2...3, \"789\");\n     assert_eq!(v, \"127895\");\n-    assert_eq!(t, \"34\");\n-    let t2: String = v.splice(1...2, \"A\").collect();\n+    v.splice(1...2, \"A\");\n     assert_eq!(v, \"1A895\");\n-    assert_eq!(t2, \"27\");\n }\n \n #[test]\n@@ -482,24 +479,15 @@ fn test_splice_inclusive_out_of_bounds() {\n #[test]\n fn test_splice_empty() {\n     let mut s = String::from(\"12345\");\n-    let t: String = s.splice(1..2, \"\").collect();\n+    s.splice(1..2, \"\");\n     assert_eq!(s, \"1345\");\n-    assert_eq!(t, \"2\");\n }\n \n #[test]\n fn test_splice_unbounded() {\n     let mut s = String::from(\"12345\");\n-    let t: String = s.splice(.., \"\").collect();\n+    s.splice(.., \"\");\n     assert_eq!(s, \"\");\n-    assert_eq!(t, \"12345\");\n-}\n-\n-#[test]\n-fn test_splice_forget() {\n-    let mut s = String::from(\"12345\");\n-    ::std::mem::forget(s.splice(2..4, \"789\"));\n-    assert_eq!(s, \"12345\");\n }\n \n #[test]"}, {"sha": "6e652c8b898230a383384f6d14e03bb99f53c9f4", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -62,11 +62,13 @@ macro_rules! panic {\n /// # Custom Messages\n ///\n /// This macro has a second form, where a custom panic message can\n-/// be provided with or without arguments for formatting.\n+/// be provided with or without arguments for formatting.  See [`std::fmt`]\n+/// for syntax for this form.\n ///\n /// [`panic!`]: macro.panic.html\n /// [`debug_assert!`]: macro.debug_assert.html\n-/// [testing]: ../book/first-edition/testing.html\n+/// [testing]: ../book/second-edition/ch11-01-writing-tests.html#checking-results-with-the-assert-macro\n+/// [`std::fmt`]: ../std/fmt/index.html\n ///\n /// # Examples\n ///\n@@ -252,13 +254,15 @@ macro_rules! debug_assert {\n /// On panic, this macro will print the values of the expressions with their\n /// debug representations.\n ///\n-/// Unlike `assert_eq!`, `debug_assert_eq!` statements are only enabled in non\n+/// Unlike [`assert_eq!`], `debug_assert_eq!` statements are only enabled in non\n /// optimized builds by default. An optimized build will omit all\n /// `debug_assert_eq!` statements unless `-C debug-assertions` is passed to the\n /// compiler. This makes `debug_assert_eq!` useful for checks that are too\n /// expensive to be present in a release build but may be helpful during\n /// development.\n ///\n+/// [`assert_eq!`]: ../std/macro.assert_eq.html\n+///\n /// # Examples\n ///\n /// ```\n@@ -277,13 +281,15 @@ macro_rules! debug_assert_eq {\n /// On panic, this macro will print the values of the expressions with their\n /// debug representations.\n ///\n-/// Unlike `assert_ne!`, `debug_assert_ne!` statements are only enabled in non\n+/// Unlike [`assert_ne!`], `debug_assert_ne!` statements are only enabled in non\n /// optimized builds by default. An optimized build will omit all\n /// `debug_assert_ne!` statements unless `-C debug-assertions` is passed to the\n /// compiler. This makes `debug_assert_ne!` useful for checks that are too\n /// expensive to be present in a release build but may be helpful during\n /// development.\n ///\n+/// [`assert_ne!`]: ../std/macro.assert_ne.html\n+///\n /// # Examples\n ///\n /// ```\n@@ -300,10 +306,9 @@ macro_rules! debug_assert_ne {\n /// Helper macro for reducing boilerplate code for matching `Result` together\n /// with converting downstream errors.\n ///\n-/// Prefer using `?` syntax to `try!`. `?` is built in to the language and is\n-/// more succinct than `try!`. It is the standard method for error propagation.\n+/// The `?` operator was added to replace `try!` and should be used instead.\n ///\n-/// `try!` matches the given `Result`. In case of the `Ok` variant, the\n+/// `try!` matches the given [`Result`]. In case of the `Ok` variant, the\n /// expression has the value of the wrapped value.\n ///\n /// In case of the `Err` variant, it retrieves the inner error. `try!` then\n@@ -312,7 +317,9 @@ macro_rules! debug_assert_ne {\n /// error is then immediately returned.\n ///\n /// Because of the early return, `try!` can only be used in functions that\n-/// return `Result`.\n+/// return [`Result`].\n+///\n+/// [`Result`]: ../std/result/enum.Result.html\n ///\n /// # Examples\n ///\n@@ -331,20 +338,26 @@ macro_rules! debug_assert_ne {\n ///     }\n /// }\n ///\n+/// // The prefered method of quick returning Errors\n+/// fn write_to_file_question() -> Result<(), MyError> {\n+///     let mut file = File::create(\"my_best_friends.txt\")?;\n+///     Ok(())\n+/// }\n+///\n+/// // The previous method of quick returning Errors\n /// fn write_to_file_using_try() -> Result<(), MyError> {\n ///     let mut file = try!(File::create(\"my_best_friends.txt\"));\n ///     try!(file.write_all(b\"This is a list of my best friends.\"));\n-///     println!(\"I wrote to the file\");\n ///     Ok(())\n /// }\n+///\n /// // This is equivalent to:\n /// fn write_to_file_using_match() -> Result<(), MyError> {\n ///     let mut file = try!(File::create(\"my_best_friends.txt\"));\n ///     match file.write_all(b\"This is a list of my best friends.\") {\n ///         Ok(v) => v,\n ///         Err(e) => return Err(From::from(e)),\n ///     }\n-///     println!(\"I wrote to the file\");\n ///     Ok(())\n /// }\n /// ```\n@@ -365,7 +378,7 @@ macro_rules! try {\n /// formatted according to the specified format string and the result will be passed to the writer.\n /// The writer may be any value with a `write_fmt` method; generally this comes from an\n /// implementation of either the [`std::fmt::Write`] or the [`std::io::Write`] trait. The macro\n-/// returns whatever the 'write_fmt' method returns; commonly a [`std::fmt::Result`], or an\n+/// returns whatever the `write_fmt` method returns; commonly a [`std::fmt::Result`], or an\n /// [`io::Result`].\n ///\n /// See [`std::fmt`] for more information on the format string syntax.\n@@ -470,10 +483,20 @@ macro_rules! writeln {\n /// * Loops that dynamically terminate.\n /// * Iterators that dynamically terminate.\n ///\n+/// If the determination that the code is unreachable proves incorrect, the\n+/// program immediately terminates with a [`panic!`].  The function [`unreachable`],\n+/// which belongs to the [`std::intrinsics`] module, informs the compilier to\n+/// optimize the code out of the release version entirely.\n+///\n+/// [`panic!`]:  ../std/macro.panic.html\n+/// [`unreachable`]: ../std/intrinsics/fn.unreachable.html\n+/// [`std::intrinsics`]: ../std/intrinsics/index.html\n+///\n /// # Panics\n ///\n-/// This will always [panic!](macro.panic.html)\n+/// This will always [`panic!`]\n ///\n+/// [`panic!`]: ../std/macro.panic.html\n /// # Examples\n ///\n /// Match arms:\n@@ -516,13 +539,18 @@ macro_rules! unreachable {\n     });\n }\n \n-/// A standardized placeholder for marking unfinished code. It panics with the\n-/// message `\"not yet implemented\"` when executed.\n+/// A standardized placeholder for marking unfinished code.\n+///\n+/// It panics with the message `\"not yet implemented\"` when executed.\n ///\n /// This can be useful if you are prototyping and are just looking to have your\n /// code typecheck, or if you're implementing a trait that requires multiple\n /// methods, and you're only planning on using one of them.\n ///\n+/// # Panics\n+///\n+/// This macro always panics.\n+///\n /// # Examples\n ///\n /// Here's an example of some in-progress code. We have a trait `Foo`:"}, {"sha": "04a5e75c99dc92afab490c38fcbbeac9b4bc8104", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -1 +1 @@\n-Subproject commit 2a5b50b7f7f539a0fd201331d6c1e0534aa332f5\n+Subproject commit 04a5e75c99dc92afab490c38fcbbeac9b4bc8104"}, {"sha": "cfd83e348a8e2e62e2a229f3616578f29f186b31", "filename": "src/libproc_macro/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibproc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibproc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2FCargo.toml?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -10,3 +10,4 @@ crate-type = [\"dylib\"]\n [dependencies]\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "c39aec896e6b4d4c091a582e8342febb64ded67a", "filename": "src/libproc_macro/diagnostic.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fdiagnostic.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -0,0 +1,134 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use Span;\n+\n+use rustc_errors as rustc;\n+\n+/// An enum representing a diagnostic level.\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[derive(Copy, Clone, Debug)]\n+pub enum Level {\n+    /// An error.\n+    Error,\n+    /// A warning.\n+    Warning,\n+    /// A note.\n+    Note,\n+    /// A help message.\n+    Help,\n+    #[doc(hidden)]\n+    __Nonexhaustive,\n+}\n+\n+/// A structure representing a diagnostic message and associated children\n+/// messages.\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+#[derive(Clone, Debug)]\n+pub struct Diagnostic {\n+    level: Level,\n+    message: String,\n+    span: Option<Span>,\n+    children: Vec<Diagnostic>\n+}\n+\n+macro_rules! diagnostic_child_methods {\n+    ($spanned:ident, $regular:ident, $level:expr) => (\n+        /// Add a new child diagnostic message to `self` with the level\n+        /// identified by this methods name with the given `span` and `message`.\n+        #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+        pub fn $spanned<T: Into<String>>(mut self, span: Span, message: T) -> Diagnostic {\n+            self.children.push(Diagnostic::spanned(span, $level, message));\n+            self\n+        }\n+\n+        /// Add a new child diagnostic message to `self` with the level\n+        /// identified by this method's name with the given `message`.\n+        #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+        pub fn $regular<T: Into<String>>(mut self, message: T) -> Diagnostic {\n+            self.children.push(Diagnostic::new($level, message));\n+            self\n+        }\n+    )\n+}\n+\n+impl Diagnostic {\n+    /// Create a new diagnostic with the given `level` and `message`.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n+        Diagnostic {\n+            level: level,\n+            message: message.into(),\n+            span: None,\n+            children: vec![]\n+        }\n+    }\n+\n+    /// Create a new diagnostic with the given `level` and `message` pointing to\n+    /// the given `span`.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn spanned<T: Into<String>>(span: Span, level: Level, message: T) -> Diagnostic {\n+        Diagnostic {\n+            level: level,\n+            message: message.into(),\n+            span: Some(span),\n+            children: vec![]\n+        }\n+    }\n+\n+    diagnostic_child_methods!(span_error, error, Level::Error);\n+    diagnostic_child_methods!(span_warning, warning, Level::Warning);\n+    diagnostic_child_methods!(span_note, note, Level::Note);\n+    diagnostic_child_methods!(span_help, help, Level::Help);\n+\n+    /// Returns the diagnostic `level` for `self`.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn level(&self) -> Level {\n+        self.level\n+    }\n+\n+    /// Emit the diagnostic.\n+    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+    pub fn emit(self) {\n+        ::__internal::with_sess(move |(sess, _)| {\n+            let handler = &sess.span_diagnostic;\n+            let level = __internal::level_to_internal_level(self.level);\n+            let mut diag = rustc::DiagnosticBuilder::new(handler, level, &*self.message);\n+\n+            if let Some(span) = self.span {\n+                diag.set_span(span.0);\n+            }\n+\n+            for child in self.children {\n+                let span = child.span.map(|s| s.0);\n+                let level = __internal::level_to_internal_level(child.level);\n+                diag.sub(level, &*child.message, span);\n+            }\n+\n+            diag.emit();\n+        });\n+    }\n+}\n+\n+#[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n+#[doc(hidden)]\n+pub mod __internal {\n+    use super::{Level, rustc};\n+\n+    pub fn level_to_internal_level(level: Level) -> rustc::Level {\n+        match level {\n+            Level::Error => rustc::Level::Error,\n+            Level::Warning => rustc::Level::Warning,\n+            Level::Note => rustc::Level::Note,\n+            Level::Help => rustc::Level::Help,\n+            Level::__Nonexhaustive => unreachable!(\"Level::__Nonexhaustive\")\n+        }\n+    }\n+}"}, {"sha": "e403e2a00c9e3bdc020b7d7ff65462fbb62401dc", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -42,6 +42,12 @@\n #[macro_use]\n extern crate syntax;\n extern crate syntax_pos;\n+extern crate rustc_errors;\n+\n+mod diagnostic;\n+\n+#[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+pub use diagnostic::{Diagnostic, Level};\n \n use std::{ascii, fmt, iter};\n use std::str::FromStr;\n@@ -188,12 +194,28 @@ pub fn quote_span(span: Span) -> TokenStream {\n     TokenStream(quote::Quote::quote(&span.0))\n }\n \n+macro_rules! diagnostic_method {\n+    ($name:ident, $level:expr) => (\n+        /// Create a new `Diagnostic` with the given `message` at the span\n+        /// `self`.\n+        #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n+        pub fn $name<T: Into<String>>(self, message: T) -> Diagnostic {\n+            Diagnostic::spanned(self, $level, message)\n+        }\n+    )\n+}\n+\n impl Span {\n     /// The span of the invocation of the current procedural macro.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn call_site() -> Span {\n         ::__internal::with_sess(|(_, mark)| Span(mark.expn_info().unwrap().call_site))\n     }\n+\n+    diagnostic_method!(error, Level::Error);\n+    diagnostic_method!(warning, Level::Warning);\n+    diagnostic_method!(note, Level::Note);\n+    diagnostic_method!(help, Level::Help);\n }\n \n /// A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`)."}, {"sha": "ea827fb3139a86a21dede30a567cb030dbd79903", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -62,6 +62,7 @@\n \n use hir::def_id::{CrateNum, DefId};\n use hir::map::DefPathHash;\n+use hir::HirId;\n \n use ich::Fingerprint;\n use ty::{TyCtxt, Instance, InstanceDef};\n@@ -527,6 +528,9 @@ define_dep_nodes!( <'tcx>\n     [] HasGlobalAllocator(DefId),\n     [] ExternCrate(DefId),\n     [] LintLevels,\n+    [] Specializes { impl1: DefId, impl2: DefId },\n+    [] InScopeTraits(HirId),\n+    [] ModuleExports(HirId),\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "9c841022fcb8225df851b314d6473c3f702d393c", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -205,13 +205,15 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::N\n                 // corresponding entry in the `trait_map` we need to hash that.\n                 // Make sure we don't ignore too much by checking that there is\n                 // no entry in a debug_assert!().\n-                debug_assert!(hcx.tcx.trait_map.get(self).is_none());\n+                let hir_id = hcx.tcx.hir.node_to_hir_id(*self);\n+                debug_assert!(hcx.tcx.in_scope_traits(hir_id).is_none());\n             }\n             NodeIdHashingMode::HashDefPath => {\n                 hcx.tcx.hir.definitions().node_to_hir_id(*self).hash_stable(hcx, hasher);\n             }\n             NodeIdHashingMode::HashTraitsInScope => {\n-                if let Some(traits) = hcx.tcx.trait_map.get(self) {\n+                let hir_id = hcx.tcx.hir.node_to_hir_id(*self);\n+                if let Some(traits) = hcx.tcx.in_scope_traits(hir_id) {\n                     // The ordering of the candidates is not fixed. So we hash\n                     // the def-ids and then sort them and hash the collection.\n                     let mut candidates: AccumulateVec<[_; 8]> ="}, {"sha": "019f0a709116c7622167bad613d6dca6ac164a40", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -38,7 +38,7 @@ pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal};\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n-pub use self::specialize::{OverlapError, specialization_graph, specializes, translate_substs};\n+pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::{SpecializesCache, find_associated_item};\n pub use self::util::elaborate_predicates;\n pub use self::util::supertraits;\n@@ -831,6 +831,7 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n     *providers = ty::maps::Providers {\n         is_object_safe: object_safety::is_object_safe_provider,\n         specialization_graph_of: specialize::specialization_graph_provider,\n+        specializes: specialize::specializes,\n         ..*providers\n     };\n }\n@@ -839,6 +840,7 @@ pub fn provide_extern(providers: &mut ty::maps::Providers) {\n     *providers = ty::maps::Providers {\n         is_object_safe: object_safety::is_object_safe_provider,\n         specialization_graph_of: specialize::specialization_graph_provider,\n+        specializes: specialize::specializes,\n         ..*providers\n     };\n }"}, {"sha": "726e5d83428ca0807d0281b1e6aa3128d0c803fe", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -36,7 +36,6 @@ use infer;\n use infer::{InferCtxt, InferOk, TypeFreshener};\n use ty::subst::{Kind, Subst, Substs};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n-use traits;\n use ty::fast_reject;\n use ty::relate::TypeRelation;\n use middle::lang_items;\n@@ -1865,7 +1864,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 if other.evaluation == EvaluatedToOk {\n                     if let ImplCandidate(victim_def) = victim.candidate {\n                         let tcx = self.tcx().global_tcx();\n-                        return traits::specializes(tcx, other_def, victim_def) ||\n+                        return tcx.specializes((other_def, victim_def)) ||\n                             tcx.impls_are_allowed_to_overlap(other_def, victim_def);\n                     }\n                 }"}, {"sha": "2dd6ca4b5a92853964c67d81921b0178f2ef920d", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -150,15 +150,12 @@ pub fn find_associated_item<'a, 'tcx>(\n /// Specialization is determined by the sets of types to which the impls apply;\n /// impl1 specializes impl2 if it applies to a subset of the types impl2 applies\n /// to.\n-pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             impl1_def_id: DefId,\n-                             impl2_def_id: DefId) -> bool {\n+pub(super) fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                    (impl1_def_id, impl2_def_id): (DefId, DefId))\n+    -> bool\n+{\n     debug!(\"specializes({:?}, {:?})\", impl1_def_id, impl2_def_id);\n \n-    if let Some(r) = tcx.specializes_cache.borrow().check(impl1_def_id, impl2_def_id) {\n-        return r;\n-    }\n-\n     // The feature gate should prevent introducing new specializations, but not\n     // taking advantage of upstream ones.\n     if !tcx.sess.features.borrow().specialization &&\n@@ -188,7 +185,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n \n     // Create a infcx, taking the predicates of impl1 as assumptions:\n-    let result = tcx.infer_ctxt().enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         // Normalize the trait reference. The WF rules ought to ensure\n         // that this always succeeds.\n         let impl1_trait_ref =\n@@ -204,10 +201,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Attempt to prove that impl2 applies, given all of the above.\n         fulfill_implication(&infcx, penv, impl1_trait_ref, impl2_def_id).is_ok()\n-    });\n-\n-    tcx.specializes_cache.borrow_mut().insert(impl1_def_id, impl2_def_id, result);\n-    result\n+    })\n }\n \n /// Attempt to fulfill all obligations of `target_impl` after unification with"}, {"sha": "5242accceabb3418d3f9b11746861c8a4604de23", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{OverlapError, specializes};\n+use super::OverlapError;\n \n use hir::def_id::DefId;\n use traits;\n@@ -118,8 +118,8 @@ impl<'a, 'gcx, 'tcx> Children {\n                         return Ok((false, false));\n                     }\n \n-                    let le = specializes(tcx, impl_def_id, possible_sibling);\n-                    let ge = specializes(tcx, possible_sibling, impl_def_id);\n+                    let le = tcx.specializes((impl_def_id, possible_sibling));\n+                    let ge = tcx.specializes((possible_sibling, impl_def_id));\n \n                     if le == ge {\n                         // overlap, but no specialization; error out"}, {"sha": "14d47d5d195e3f400a53d9b50cee6aa2324a012d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -14,8 +14,8 @@ use dep_graph::DepGraph;\n use errors::DiagnosticBuilder;\n use session::Session;\n use middle;\n-use hir::{TraitMap};\n-use hir::def::{Def, ExportMap};\n+use hir::{TraitCandidate, HirId};\n+use hir::def::{Def, Export};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::DefPathHash;\n@@ -808,8 +808,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub sess: &'tcx Session,\n \n-    pub specializes_cache: RefCell<traits::SpecializesCache>,\n-\n     pub trans_trait_caches: traits::trans::TransTraitCaches<'tcx>,\n \n     pub dep_graph: DepGraph,\n@@ -819,10 +817,10 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n-    pub trait_map: TraitMap,\n+    trait_map: FxHashMap<HirId, Rc<Vec<TraitCandidate>>>,\n \n     /// Export map produced by name resolution.\n-    pub export_map: ExportMap,\n+    export_map: FxHashMap<HirId, Rc<Vec<Export>>>,\n \n     pub named_region_map: resolve_lifetime::NamedRegionMap,\n \n@@ -1072,14 +1070,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         tls::enter_global(GlobalCtxt {\n             sess: s,\n             trans_trait_caches: traits::trans::TransTraitCaches::new(dep_graph.clone()),\n-            specializes_cache: RefCell::new(traits::SpecializesCache::new()),\n             global_arenas: arenas,\n             global_interners: interners,\n             dep_graph: dep_graph.clone(),\n             types: common_types,\n             named_region_map,\n-            trait_map: resolutions.trait_map,\n-            export_map: resolutions.export_map,\n+            trait_map: resolutions.trait_map.into_iter().map(|(k, v)| {\n+                (hir.node_to_hir_id(k), Rc::new(v))\n+            }).collect(),\n+            export_map: resolutions.export_map.into_iter().map(|(k, v)| {\n+                (hir.node_to_hir_id(k), Rc::new(v))\n+            }).collect(),\n             hir,\n             def_path_hash_to_def_id,\n             maps: maps::Maps::new(providers),\n@@ -1997,3 +1998,20 @@ impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n         Ok(f(&iter.collect::<Result<AccumulateVec<[_; 8]>, _>>()?))\n     }\n }\n+\n+fn in_scope_traits<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: HirId)\n+    -> Option<Rc<Vec<TraitCandidate>>>\n+{\n+    tcx.gcx.trait_map.get(&id).cloned()\n+}\n+\n+fn module_exports<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: HirId)\n+    -> Option<Rc<Vec<Export>>>\n+{\n+    tcx.gcx.export_map.get(&id).cloned()\n+}\n+\n+pub fn provide(providers: &mut ty::maps::Providers) {\n+    providers.in_scope_traits = in_scope_traits;\n+    providers.module_exports = module_exports;\n+}"}, {"sha": "da81bfbb0dc4f21643d0cd99356d1f9270108d73", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -11,8 +11,8 @@\n use dep_graph::{DepConstructor, DepNode, DepNodeIndex};\n use errors::{Diagnostic, DiagnosticBuilder};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use hir::def::Def;\n-use hir;\n+use hir::def::{Def, Export};\n+use hir::{self, TraitCandidate, HirId};\n use lint;\n use middle::const_val;\n use middle::cstore::{ExternCrate, LinkagePreference};\n@@ -80,6 +80,15 @@ impl Key for CrateNum {\n     }\n }\n \n+impl Key for HirId {\n+    fn map_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _tcx: TyCtxt) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl Key for DefId {\n     fn map_crate(&self) -> CrateNum {\n         self.krate\n@@ -540,6 +549,24 @@ impl<'tcx> QueryDescription for queries::lint_levels<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::specializes<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: (DefId, DefId)) -> String {\n+        format!(\"computing whether impls specialize one another\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::in_scope_traits<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: HirId) -> String {\n+        format!(\"fetching the traits in scope at a particular ast node\")\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::module_exports<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: HirId) -> String {\n+        format!(\"fetching the exported items for a module\")\n+    }\n+}\n+\n // If enabled, send a message to the profile-queries thread\n macro_rules! profq_msg {\n     ($tcx:expr, $msg:expr) => {\n@@ -1108,6 +1135,10 @@ define_maps! { <'tcx>\n     [] extern_crate: ExternCrate(DefId) -> Rc<Option<ExternCrate>>,\n \n     [] lint_levels: lint_levels(CrateNum) -> Rc<lint::LintLevelMap>,\n+\n+    [] specializes: specializes_node((DefId, DefId)) -> bool,\n+    [] in_scope_traits: InScopeTraits(HirId) -> Option<Rc<Vec<TraitCandidate>>>,\n+    [] module_exports: ModuleExports(HirId) -> Option<Rc<Vec<Export>>>,\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n@@ -1183,3 +1214,7 @@ fn layout_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'\n fn lint_levels<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::LintLevels\n }\n+\n+fn specializes_node<'tcx>((a, b): (DefId, DefId)) -> DepConstructor<'tcx> {\n+    DepConstructor::Specializes { impl1: a, impl2: b }\n+}"}, {"sha": "ca735599a0da64c4f8641723541540772994a3b3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -2517,6 +2517,7 @@ fn param_env<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n pub fn provide(providers: &mut ty::maps::Providers) {\n     util::provide(providers);\n+    context::provide(providers);\n     *providers = ty::maps::Providers {\n         associated_item,\n         associated_item_def_ids,"}, {"sha": "9aae188f9ecdfdf4b7644ed5c0f3a78ca01d241b", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -288,7 +288,7 @@ impl Diagnostic {\n \n     /// Convenience function for internal use, clients should use one of the\n     /// public methods above.\n-    fn sub(&mut self,\n+    pub(crate) fn sub(&mut self,\n            level: Level,\n            message: &str,\n            span: MultiSpan,"}, {"sha": "2cd433bfe3aeef5c2cbd45766d790718de4c56c3", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -110,6 +110,19 @@ impl<'a> DiagnosticBuilder<'a> {\n         // }\n     }\n \n+    /// Convenience function for internal use, clients should use one of the\n+    /// span_* methods instead.\n+    pub fn sub<S: Into<MultiSpan>>(\n+        &mut self,\n+        level: Level,\n+        message: &str,\n+        span: Option<S>,\n+    ) -> &mut Self {\n+        let span = span.map(|s| s.into()).unwrap_or(MultiSpan::new());\n+        self.diagnostic.sub(level, message, span, None);\n+        self\n+    }\n+\n     /// Delay emission of this diagnostic as a bug.\n     ///\n     /// This can be useful in contexts where an error indicates a bug but"}, {"sha": "62aa86995d0aff6d43e422426acdfc0b6f74bc05", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -548,12 +548,13 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                                                                  &hir::Visibility)>)\n                            -> Entry<'tcx> {\n         let tcx = self.tcx;\n+        let hir_id = tcx.hir.node_to_hir_id(id);\n         let def_id = tcx.hir.local_def_id(id);\n         debug!(\"IsolatedEncoder::encode_info_for_mod({:?})\", def_id);\n \n         let data = ModData {\n-            reexports: match tcx.export_map.get(&id) {\n-                Some(exports) if *vis == hir::Public => {\n+            reexports: match tcx.module_exports(hir_id) {\n+                Some(ref exports) if *vis == hir::Public => {\n                     self.lazy_seq_from_slice(exports.as_slice())\n                 }\n                 _ => LazySeq::empty(),"}, {"sha": "8dc078984193b7008f7f582e272cdec5c65103c4", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -325,8 +325,9 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n         if self.prev_level.is_some() {\n-            if let Some(exports) = self.tcx.export_map.get(&id) {\n-                for export in exports {\n+            let hir_id = self.tcx.hir.node_to_hir_id(id);\n+            if let Some(exports) = self.tcx.module_exports(hir_id) {\n+                for export in exports.iter() {\n                     if let Some(node_id) = self.tcx.hir.as_local_node_id(export.def.def_id()) {\n                         self.update(node_id, Some(AccessLevel::Exported));\n                     }"}, {"sha": "9531c8baa0bc158df27abb984cfdda6f0c1c07ea", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -402,7 +402,8 @@ impl<'a> Resolver<'a> {\n         let ast::Path { ref segments, span } = *path;\n         let path: Vec<_> = segments.iter().map(|seg| respan(seg.span, seg.identifier)).collect();\n         let invocation = self.invocations[&scope];\n-        self.current_module = invocation.module.get();\n+        let module = invocation.module.get();\n+        self.current_module = if module.is_trait() { module.parent.unwrap() } else { module };\n \n         if path.len() > 1 {\n             if !self.use_extern_macros && self.gated_errors.insert(span) {"}, {"sha": "ba74c902f55e0fa403f167759c816f61ed6ab860", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -639,10 +639,14 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn assemble_extension_candidates_for_traits_in_scope(&mut self,\n                                                          expr_id: ast::NodeId)\n                                                          -> Result<(), MethodError<'tcx>> {\n+        if expr_id == ast::DUMMY_NODE_ID {\n+            return Ok(())\n+        }\n         let mut duplicates = FxHashSet();\n-        let opt_applicable_traits = self.tcx.trait_map.get(&expr_id);\n+        let expr_hir_id = self.tcx.hir.node_to_hir_id(expr_id);\n+        let opt_applicable_traits = self.tcx.in_scope_traits(expr_hir_id);\n         if let Some(applicable_traits) = opt_applicable_traits {\n-            for trait_candidate in applicable_traits {\n+            for trait_candidate in applicable_traits.iter() {\n                 let trait_did = trait_candidate.def_id;\n                 if duplicates.insert(trait_did) {\n                     let import_id = trait_candidate.import_id;"}, {"sha": "1f33cd7765164460d5e53692db597bb27e61d7e3", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -199,8 +199,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             self.visit_item(item, None, &mut om);\n         }\n         self.inside_public_path = orig_inside_public_path;\n-        if let Some(exports) = self.cx.tcx.export_map.get(&id) {\n-            for export in exports {\n+        let hir_id = self.cx.tcx.hir.node_to_hir_id(id);\n+        if let Some(exports) = self.cx.tcx.module_exports(hir_id) {\n+            for export in exports.iter() {\n                 if let Def::Macro(def_id, ..) = export.def {\n                     if def_id.krate == LOCAL_CRATE || self.reexported_macros.contains(&def_id) {\n                         continue // These are `krate.exported_macros`, handled in `self.visit()`."}, {"sha": "0330ff5950b01774087f36d375de139c888085a9", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 101, "deletions": 21, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -26,13 +26,33 @@ macro_rules! __rust_unstable_column {\n \n /// The entry point for panic of Rust threads.\n ///\n+/// This allows a program to to terminate immediately and provide feedback\n+/// to the caller of the program. `panic!` should be used when a program reaches\n+/// an unrecoverable problem.\n+///\n+/// This macro is the perfect way to assert conditions in example code and in\n+/// tests.  `panic!` is closely tied with the `unwrap` method of both [`Option`]\n+/// and [`Result`][runwrap] enums.  Both implementations call `panic!` when they are set\n+/// to None or Err variants.\n+///\n /// This macro is used to inject panic into a Rust thread, causing the thread to\n /// panic entirely. Each thread's panic can be reaped as the `Box<Any>` type,\n /// and the single-argument form of the `panic!` macro will be the value which\n /// is transmitted.\n ///\n+/// [`Result`] enum is often a better solution for recovering from errors than\n+/// using the `panic!` macro.  This macro should be used to avoid proceeding using\n+/// incorrect values, such as from external sources.  Detailed information about\n+/// error handling is found in the [book].\n+///\n /// The multi-argument form of this macro panics with a string and has the\n-/// `format!` syntax for building a string.\n+/// [`format!`] syntax for building a string.\n+///\n+/// [runwrap]: ../std/result/enum.Result.html#method.unwrap\n+/// [`Option`]: ../std/option/enum.Option.html#method.unwrap\n+/// [`Result`]: ../std/result/enum.Result.html\n+/// [`format!`]: ../std/macro.format.html\n+/// [book]: ../book/second-edition/ch09-01-unrecoverable-errors-with-panic.html\n ///\n /// # Current implementation\n ///\n@@ -78,15 +98,19 @@ macro_rules! panic {\n \n /// Macro for printing to the standard output.\n ///\n-/// Equivalent to the `println!` macro except that a newline is not printed at\n+/// Equivalent to the [`println!`] macro except that a newline is not printed at\n /// the end of the message.\n ///\n /// Note that stdout is frequently line-buffered by default so it may be\n-/// necessary to use `io::stdout().flush()` to ensure the output is emitted\n+/// necessary to use [`io::stdout().flush()`][flush] to ensure the output is emitted\n /// immediately.\n ///\n /// Use `print!` only for the primary output of your program.  Use\n-/// `eprint!` instead to print error and progress messages.\n+/// [`eprint!`] instead to print error and progress messages.\n+///\n+/// [`println!`]: ../std/macro.println.html\n+/// [flush]: ../std/io/trait.Write.html#tymethod.flush\n+/// [`eprint!`]: ../std/macro.eprint.html\n ///\n /// # Panics\n ///\n@@ -118,16 +142,20 @@ macro_rules! print {\n     ($($arg:tt)*) => ($crate::io::_print(format_args!($($arg)*)));\n }\n \n-/// Macro for printing to the standard output, with a newline. On all\n-/// platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n+/// Macro for printing to the standard output, with a newline.\n+///\n+/// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n /// (no additional CARRIAGE RETURN (`\\r`/`U+000D`).\n ///\n-/// Use the `format!` syntax to write data to the standard output.\n-/// See `std::fmt` for more information.\n+/// Use the [`format!`] syntax to write data to the standard output.\n+/// See [`std::fmt`] for more information.\n ///\n /// Use `println!` only for the primary output of your program.  Use\n-/// `eprintln!` instead to print error and progress messages.\n+/// [`eprintln!`] instead to print error and progress messages.\n ///\n+/// [`format!`]: ../std/macro.format.html\n+/// [`std::fmt`]: ../std/fmt/index.html\n+/// [`eprintln!`]: ../std/macro.eprint.html\n /// # Panics\n ///\n /// Panics if writing to `io::stdout` fails.\n@@ -149,16 +177,25 @@ macro_rules! println {\n \n /// Macro for printing to the standard error.\n ///\n-/// Equivalent to the `print!` macro, except that output goes to\n-/// `io::stderr` instead of `io::stdout`.  See `print!` for\n+/// Equivalent to the [`print!`] macro, except that output goes to\n+/// [`io::stderr`] instead of `io::stdout`.  See [`print!`] for\n /// example usage.\n ///\n /// Use `eprint!` only for error and progress messages.  Use `print!`\n /// instead for the primary output of your program.\n ///\n+/// [`io::stderr`]: ../std/io/struct.Stderr.html\n+/// [`print!`]: ../std/macro.print.html\n+///\n /// # Panics\n ///\n /// Panics if writing to `io::stderr` fails.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// eprint!(\"Error: Could not complete task\");\n+/// ```\n #[macro_export]\n #[stable(feature = \"eprint\", since = \"1.19.0\")]\n #[allow_internal_unstable]\n@@ -168,16 +205,25 @@ macro_rules! eprint {\n \n /// Macro for printing to the standard error, with a newline.\n ///\n-/// Equivalent to the `println!` macro, except that output goes to\n-/// `io::stderr` instead of `io::stdout`.  See `println!` for\n+/// Equivalent to the [`println!`] macro, except that output goes to\n+/// [`io::stderr`] instead of `io::stdout`.  See [`println!`] for\n /// example usage.\n ///\n /// Use `eprintln!` only for error and progress messages.  Use `println!`\n /// instead for the primary output of your program.\n ///\n+/// [`io::stderr`]: ../std/io/struct.Stderr.html\n+/// [`println!`]: ../std/macro.println.html\n+///\n /// # Panics\n ///\n /// Panics if writing to `io::stderr` fails.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// eprintln!(\"Error: Could not complete task\");\n+/// ```\n #[macro_export]\n #[stable(feature = \"eprint\", since = \"1.19.0\")]\n macro_rules! eprintln {\n@@ -267,13 +313,23 @@ pub mod builtin {\n \n     /// The core macro for formatted string creation & output.\n     ///\n+    /// This macro functions by taking a formatting string literal containing\n+    /// `{}` for each additional argument passed.  `format_args!` prepares the\n+    /// additional parameters to ensure the output can be interpreted as a string\n+    /// and canonicalizes the arguments into a single type.  Any value that implements\n+    /// the [`Display`] trait can be passed to `format_args!`, as can any\n+    /// [`Debug`] implementation be passed to a `{:?}` within the formatting string.\n+    ///\n     /// This macro produces a value of type [`fmt::Arguments`]. This value can be\n-    /// passed to the functions in [`std::fmt`] for performing useful functions.\n+    /// passed to the macros within [`std::fmt`] for performing useful redirection.\n     /// All other formatting macros ([`format!`], [`write!`], [`println!`], etc) are\n-    /// proxied through this one.\n+    /// proxied through this one.  `format_args!`, unlike its derived macros, avoids\n+    /// heap allocations.\n     ///\n     /// For more information, see the documentation in [`std::fmt`].\n     ///\n+    /// [`Display`]: ../std/fmt/trait.Display.html\n+    /// [`Debug`]: ../std/fmt/trait.Debug.html\n     /// [`fmt::Arguments`]: ../std/fmt/struct.Arguments.html\n     /// [`std::fmt`]: ../std/fmt/index.html\n     /// [`format!`]: ../std/macro.format.html\n@@ -301,9 +357,11 @@ pub mod builtin {\n     /// compile time, yielding an expression of type `&'static str`.\n     ///\n     /// If the environment variable is not defined, then a compilation error\n-    /// will be emitted.  To not emit a compile error, use the `option_env!`\n+    /// will be emitted.  To not emit a compile error, use the [`option_env!`]\n     /// macro instead.\n     ///\n+    /// [`option_env!`]: ../std/macro.option_env.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -319,11 +377,14 @@ pub mod builtin {\n     /// If the named environment variable is present at compile time, this will\n     /// expand into an expression of type `Option<&'static str>` whose value is\n     /// `Some` of the value of the environment variable. If the environment\n-    /// variable is not present, then this will expand to `None`.\n+    /// variable is not present, then this will expand to `None`.  See\n+    /// [`Option<T>`][option] for more information on this type.\n     ///\n     /// A compile time error is never emitted when using this macro regardless\n     /// of whether the environment variable is present or not.\n     ///\n+    /// [option]: ../std/option/enum.Option.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -385,10 +446,16 @@ pub mod builtin {\n \n     /// A macro which expands to the line number on which it was invoked.\n     ///\n+    /// With [`column!`] and [`file!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n     /// The expanded expression has type `u32`, and the returned line is not\n     /// the invocation of the `line!()` macro itself, but rather the first macro\n     /// invocation leading up to the invocation of the `line!()` macro.\n     ///\n+    /// [`column!`]: macro.column.html\n+    /// [`file!`]: macro.file.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -401,9 +468,15 @@ pub mod builtin {\n \n     /// A macro which expands to the column number on which it was invoked.\n     ///\n+    /// With [`line!`] and [`file!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n     /// The expanded expression has type `u32`, and the returned column is not\n-    /// the invocation of the `column!()` macro itself, but rather the first macro\n-    /// invocation leading up to the invocation of the `column!()` macro.\n+    /// the invocation of the `column!` macro itself, but rather the first macro\n+    /// invocation leading up to the invocation of the `column!` macro.\n+    ///\n+    /// [`line!`]: macro.line.html\n+    /// [`file!`]: macro.file.html\n     ///\n     /// # Examples\n     ///\n@@ -417,11 +490,18 @@ pub mod builtin {\n \n     /// A macro which expands to the file name from which it was invoked.\n     ///\n+    /// With [`line!`] and [`column!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n+    ///\n     /// The expanded expression has type `&'static str`, and the returned file\n-    /// is not the invocation of the `file!()` macro itself, but rather the\n-    /// first macro invocation leading up to the invocation of the `file!()`\n+    /// is not the invocation of the `file!` macro itself, but rather the\n+    /// first macro invocation leading up to the invocation of the `file!`\n     /// macro.\n     ///\n+    /// [`line!`]: macro.line.html\n+    /// [`column!`]: macro.column.html\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "fe0427d4e5f9c0c86325450db4dc344e04e059c1", "filename": "src/libstd/os/raw.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -14,8 +14,7 @@\n \n use fmt;\n \n-#[cfg(any(target_os = \"emscripten\",\n-          all(target_os = \"linux\", any(target_arch = \"aarch64\",\n+#[cfg(any(all(target_os = \"linux\", any(target_arch = \"aarch64\",\n                                        target_arch = \"arm\",\n                                        target_arch = \"powerpc\",\n                                        target_arch = \"powerpc64\",\n@@ -24,8 +23,7 @@ use fmt;\n                                          target_arch = \"arm\")),\n           all(target_os = \"fuchsia\", target_arch = \"aarch64\")))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n-#[cfg(not(any(target_os = \"emscripten\",\n-              all(target_os = \"linux\", any(target_arch = \"aarch64\",\n+#[cfg(not(any(all(target_os = \"linux\", any(target_arch = \"aarch64\",\n                                            target_arch = \"arm\",\n                                            target_arch = \"powerpc\",\n                                            target_arch = \"powerpc64\","}, {"sha": "f50b093acc8482c068bdcd768463c1a61cfe83d2", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -71,13 +71,21 @@ impl FileDesc {\n         #[cfg(target_os = \"android\")]\n         use super::android::cvt_pread64;\n \n-        #[cfg(not(target_os = \"android\"))]\n+        #[cfg(target_os = \"emscripten\")]\n         unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: usize, offset: i64)\n             -> io::Result<isize>\n         {\n-            #[cfg(any(target_os = \"linux\", target_os = \"emscripten\"))]\n             use libc::pread64;\n-            #[cfg(not(any(target_os = \"linux\", target_os = \"emscripten\")))]\n+            cvt(pread64(fd, buf, count, offset as i32))\n+        }\n+\n+        #[cfg(not(any(target_os = \"android\", target_os = \"emscripten\")))]\n+        unsafe fn cvt_pread64(fd: c_int, buf: *mut c_void, count: usize, offset: i64)\n+            -> io::Result<isize>\n+        {\n+            #[cfg(target_os = \"linux\")]\n+            use libc::pread64;\n+            #[cfg(not(target_os = \"linux\"))]\n             use libc::pread as pread64;\n             cvt(pread64(fd, buf, count, offset))\n         }\n@@ -104,13 +112,21 @@ impl FileDesc {\n         #[cfg(target_os = \"android\")]\n         use super::android::cvt_pwrite64;\n \n-        #[cfg(not(target_os = \"android\"))]\n+        #[cfg(target_os = \"emscripten\")]\n+        unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: usize, offset: i64)\n+            -> io::Result<isize>\n+        {\n+            use libc::pwrite64;\n+            cvt(pwrite64(fd, buf, count, offset as i32))\n+        }\n+\n+        #[cfg(not(any(target_os = \"android\", target_os = \"emscripten\")))]\n         unsafe fn cvt_pwrite64(fd: c_int, buf: *const c_void, count: usize, offset: i64)\n             -> io::Result<isize>\n         {\n-            #[cfg(any(target_os = \"linux\", target_os = \"emscripten\"))]\n+            #[cfg(target_os = \"linux\")]\n             use libc::pwrite64;\n-            #[cfg(not(any(target_os = \"linux\", target_os = \"emscripten\")))]\n+            #[cfg(not(target_os = \"linux\"))]\n             use libc::pwrite as pwrite64;\n             cvt(pwrite64(fd, buf, count, offset))\n         }"}, {"sha": "f94af4913324ff7e7b68c26230f712d640f799fa", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -514,6 +514,8 @@ impl File {\n             SeekFrom::End(off) => (libc::SEEK_END, off),\n             SeekFrom::Current(off) => (libc::SEEK_CUR, off),\n         };\n+        #[cfg(target_os = \"emscripten\")]\n+        let pos = pos as i32;\n         let n = cvt(unsafe { lseek64(self.0.raw(), pos, whence) })?;\n         Ok(n as u64)\n     }"}, {"sha": "ae24021fb6c3a55ffd164def3156b96bc9721bd0", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -10,7 +10,6 @@\n \n use io::{self, Error, ErrorKind};\n use libc::{self, c_int, gid_t, pid_t, uid_t};\n-use mem;\n use ptr;\n \n use sys::cvt;\n@@ -184,7 +183,9 @@ impl Command {\n         }\n \n         // NaCl has no signal support.\n-        if cfg!(not(any(target_os = \"nacl\", target_os = \"emscripten\"))) {\n+        #[cfg(not(any(target_os = \"nacl\", target_os = \"emscripten\")))]\n+        {\n+            use mem;\n             // Reset signal handling so the child process starts in a\n             // standardized state. libstd ignores SIGPIPE, and signal-handling\n             // libraries often set a mask. Child processes inherit ignored"}, {"sha": "8ba38875eff5bd8448fbde42830e6cba65481c81", "filename": "src/test/run-pass-fulldeps/proc-macro/attr-on-trait.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fattr-on-trait.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:attr-on-trait.rs\n+\n+#![feature(proc_macro)]\n+\n+extern crate attr_on_trait;\n+\n+trait Foo {\n+    #[attr_on_trait::foo]\n+    fn foo() {}\n+}\n+\n+impl Foo for i32 {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    3i32.foo();\n+}"}, {"sha": "8e9770340276be0495b44b6478a6a0eaf944a93f", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/attr-on-trait.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fattr-on-trait.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_attribute]\n+pub fn foo(attr: TokenStream, item: TokenStream) -> TokenStream {\n+    drop(attr);\n+    assert_eq!(item.to_string(), \"fn foo() { }\");\n+    \"fn foo(&self);\".parse().unwrap()\n+}"}, {"sha": "6fca32fece1d4e0f1bfb6fdc81d30dc592602c5d", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/three-equals.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fthree-equals.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{TokenStream, TokenNode, Span, Diagnostic};\n+\n+fn parse(input: TokenStream) -> Result<(), Diagnostic> {\n+    let mut count = 0;\n+    let mut last_span = Span::default();\n+    for tree in input {\n+        let span = tree.span;\n+        if count >= 3 {\n+            return Err(span.error(format!(\"expected EOF, found `{}`.\", tree))\n+                           .span_note(last_span, \"last good input was here\")\n+                           .help(\"input must be: `===`\"))\n+        }\n+\n+        if let TokenNode::Op('=', _) = tree.kind {\n+            count += 1;\n+        } else {\n+            return Err(span.error(format!(\"expected `=`, found `{}`.\", tree)));\n+        }\n+\n+        last_span = span;\n+    }\n+\n+    if count < 3 {\n+        return Err(Span::default()\n+                       .error(format!(\"found {} equal signs, need exactly 3\", count))\n+                       .help(\"input must be: `===`\"))\n+    }\n+\n+    Ok(())\n+}\n+\n+#[proc_macro]\n+pub fn three_equals(input: TokenStream) -> TokenStream {\n+    if let Err(diag) = parse(input) {\n+        diag.emit();\n+        return TokenStream::empty();\n+    }\n+\n+    \"3\".parse().unwrap()\n+}"}, {"sha": "016e05c51f5079abf9614a496e269cc7190b038d", "filename": "src/test/ui-fulldeps/proc-macro/three-equals.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fthree-equals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fthree-equals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fthree-equals.rs?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:three-equals.rs\n+// ignore-stage1\n+\n+#![feature(proc_macro)]\n+\n+extern crate three_equals;\n+\n+use three_equals::three_equals;\n+\n+fn main() {\n+    // This one is okay.\n+    three_equals!(===);\n+\n+    // Need exactly three equals.\n+    three_equals!(==);\n+\n+    // Need exactly three equals.\n+    three_equals!(=====);\n+\n+    // Only equals accepted.\n+    three_equals!(abc);\n+\n+    // Only equals accepted.\n+    three_equals!(!!);\n+\n+    // Only three characters expected.\n+    three_equals!(===a);\n+}"}, {"sha": "1afe0be28000987ad5c1b6dcc15810f461579aa4", "filename": "src/test/ui-fulldeps/proc-macro/three-equals.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/890c87b643264120dc1064ed73df6def974e02fc/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fthree-equals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/890c87b643264120dc1064ed73df6def974e02fc/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fthree-equals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fthree-equals.stderr?ref=890c87b643264120dc1064ed73df6def974e02fc", "patch": "@@ -0,0 +1,48 @@\n+error: found 2 equal signs, need exactly 3\n+  --> $DIR/three-equals.rs:25:5\n+   |\n+25 |     three_equals!(==);\n+   |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: input must be: `===`\n+\n+error: expected EOF, found `=`.\n+  --> $DIR/three-equals.rs:28:21\n+   |\n+28 |     three_equals!(=====);\n+   |                     ^^\n+   |\n+note: last good input was here\n+  --> $DIR/three-equals.rs:28:21\n+   |\n+28 |     three_equals!(=====);\n+   |                     ^^\n+   = help: input must be: `===`\n+\n+error: expected `=`, found `abc`.\n+  --> $DIR/three-equals.rs:31:19\n+   |\n+31 |     three_equals!(abc);\n+   |                   ^^^\n+\n+error: expected `=`, found `!`.\n+  --> $DIR/three-equals.rs:34:19\n+   |\n+34 |     three_equals!(!!);\n+   |                   ^\n+\n+error: expected EOF, found `a`.\n+  --> $DIR/three-equals.rs:37:22\n+   |\n+37 |     three_equals!(===a);\n+   |                      ^\n+   |\n+note: last good input was here\n+  --> $DIR/three-equals.rs:37:21\n+   |\n+37 |     three_equals!(===a);\n+   |                     ^\n+   = help: input must be: `===`\n+\n+error: aborting due to 5 previous errors\n+"}]}