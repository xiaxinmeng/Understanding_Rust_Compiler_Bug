{"sha": "eff15b49f311f4c71afd48ea31fd9510c5f93e07", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmZjE1YjQ5ZjMxMWY0YzcxYWZkNDhlYTMxZmQ5NTEwYzVmOTNlMDc=", "commit": {"author": {"name": "Inokentiy Babushkin", "email": "twk@twki.de", "date": "2018-04-12T09:58:34Z"}, "committer": {"name": "Inokentiy Babushkin", "email": "twk@twki.de", "date": "2018-04-26T20:17:56Z"}, "message": "Reformatted source for auto trait machinery.", "tree": {"sha": "9aa60e25780b266fc8e6155d97d789729fc3db1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9aa60e25780b266fc8e6155d97d789729fc3db1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eff15b49f311f4c71afd48ea31fd9510c5f93e07", "comment_count": 0, "verification": {"verified": false, "reason": "unverified_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXezFNCHL3+3lgSPSfvyOxSJN6OwFAlriM/QACgkQfvyOxSJN\n6OwGrQ/+NjehUYswrBGD5Tvw/AYJBAxsGZVGO4hZZHhHZaGhibz0vHSCNOISP7PT\nkhSiSuGwv3+n5gzD32Gotm/dPpsmPq6XHMD6JFiKVdcbqkTol8woEJmjStYx37Uq\nr36N1FnvFFa6uEQfsjB0O91dolYxRbJkDY6sjqnFMvEl8sDgwB/pabqQsvpyiRT2\nYEEwgPND9AmNX7GK4UmECxfEFP1ST7d7ZS8rjbqmJF9c8SrBrMbaXjo2h2EHDOn7\nVQP4CaNoLn0sJ1EnaECqXJwXlSIyW+PSCxrJ8ewXXABWOvcC5Hc4imt67Wroejdi\nMMomEkoxDlWl+EPMfp+nrHe88jmIZImbRASfBim2fCkmTsR0XsN7VHYwGUJuV5hk\nZTgecTK2EDYrVRlcV4dvri2I8G2mDxbE2gaDIylSOdNTuqdKEuY/3IiseGK8U9CY\nhmrmMbzPI2vHSuwn6lda860IrVKwvZeukDyoQP+LelKXTSw7bchgLZrLfKTyqae0\nVPgcJ7TpAEhkC7SRUwFOhMnU/RYeIiMqr5eK7RQ+B4oe2HkACOtfEsW9j2fUtyVl\nAo9mG9bIu1cQKMzNeWVltIoEI4fH98LqS84xNtt9Cki1FHnJ7KekUdiRePFUl26k\nSf2lWkHynSrfOieS5dcWGyTJDPjdVOBirR7+U0QeGkLvHTwDzTM=\n=V/pm\n-----END PGP SIGNATURE-----", "payload": "tree 9aa60e25780b266fc8e6155d97d789729fc3db1b\nparent 309e4035aa65e37c37bf2763029df9bcff81da87\nauthor Inokentiy Babushkin <twk@twki.de> 1523527114 +0200\ncommitter Inokentiy Babushkin <twk@twki.de> 1524773876 +0200\n\nReformatted source for auto trait machinery.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eff15b49f311f4c71afd48ea31fd9510c5f93e07", "html_url": "https://github.com/rust-lang/rust/commit/eff15b49f311f4c71afd48ea31fd9510c5f93e07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eff15b49f311f4c71afd48ea31fd9510c5f93e07/comments", "author": {"login": "ibabushkin", "id": 10811417, "node_id": "MDQ6VXNlcjEwODExNDE3", "avatar_url": "https://avatars.githubusercontent.com/u/10811417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibabushkin", "html_url": "https://github.com/ibabushkin", "followers_url": "https://api.github.com/users/ibabushkin/followers", "following_url": "https://api.github.com/users/ibabushkin/following{/other_user}", "gists_url": "https://api.github.com/users/ibabushkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibabushkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibabushkin/subscriptions", "organizations_url": "https://api.github.com/users/ibabushkin/orgs", "repos_url": "https://api.github.com/users/ibabushkin/repos", "events_url": "https://api.github.com/users/ibabushkin/events{/privacy}", "received_events_url": "https://api.github.com/users/ibabushkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibabushkin", "id": 10811417, "node_id": "MDQ6VXNlcjEwODExNDE3", "avatar_url": "https://avatars.githubusercontent.com/u/10811417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibabushkin", "html_url": "https://github.com/ibabushkin", "followers_url": "https://api.github.com/users/ibabushkin/followers", "following_url": "https://api.github.com/users/ibabushkin/following{/other_user}", "gists_url": "https://api.github.com/users/ibabushkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibabushkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibabushkin/subscriptions", "organizations_url": "https://api.github.com/users/ibabushkin/orgs", "repos_url": "https://api.github.com/users/ibabushkin/repos", "events_url": "https://api.github.com/users/ibabushkin/events{/privacy}", "received_events_url": "https://api.github.com/users/ibabushkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "309e4035aa65e37c37bf2763029df9bcff81da87", "url": "https://api.github.com/repos/rust-lang/rust/commits/309e4035aa65e37c37bf2763029df9bcff81da87", "html_url": "https://github.com/rust-lang/rust/commit/309e4035aa65e37c37bf2763029df9bcff81da87"}], "stats": {"total": 381, "additions": 193, "deletions": 188}, "files": [{"sha": "a4beb6fab123aa11e221ba96afccdb3a30daa82e", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 193, "deletions": 188, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/eff15b49f311f4c71afd48ea31fd9510c5f93e07/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff15b49f311f4c71afd48ea31fd9510c5f93e07/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=eff15b49f311f4c71afd48ea31fd9510c5f93e07", "patch": "@@ -10,16 +10,16 @@\n \n use super::*;\n \n-use std::collections::VecDeque;\n use std::collections::hash_map::Entry;\n+use std::collections::VecDeque;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n \n-use infer::{InferCtxt, RegionObligation};\n use infer::region_constraints::{Constraint, RegionConstraintData};\n+use infer::{InferCtxt, RegionObligation};\n \n-use ty::{Region, RegionVid};\n use ty::fold::TypeFolder;\n+use ty::{Region, RegionVid};\n \n // FIXME(twk): this is obviously not nice to duplicate like that\n #[derive(Eq, PartialEq, Hash, Copy, Clone, Debug)]\n@@ -43,8 +43,7 @@ pub enum AutoTraitResult<A> {\n impl<A> AutoTraitResult<A> {\n     fn is_auto(&self) -> bool {\n         match *self {\n-            AutoTraitResult::PositiveImpl(_) |\n-            AutoTraitResult::NegativeImpl => true,\n+            AutoTraitResult::PositiveImpl(_) | AutoTraitResult::NegativeImpl => true,\n             _ => false,\n         }\n     }\n@@ -69,14 +68,13 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     /// Determine whether an auto trait is implemented for a type, and if this is the case if\n     /// non-trivial bounds need to be fulfilled, invoke a callback to compute a value representing\n     /// these in a fashion suitable for the caller.\n-    pub fn find_auto_trait_generics<A>(&self,\n-                                       did: DefId,\n-                                       trait_did: DefId,\n-                                       generics: &ty::Generics,\n-                                       auto_trait_callback:\n-                                           impl for<'i> Fn(&InferCtxt<'_, 'tcx, 'i>,\n-                                                           AutoTraitInfo<'i>) -> A)\n-                                       -> AutoTraitResult<A> {\n+    pub fn find_auto_trait_generics<A>(\n+        &self,\n+        did: DefId,\n+        trait_did: DefId,\n+        generics: &ty::Generics,\n+        auto_trait_callback: impl for<'i> Fn(&InferCtxt<'_, 'tcx, 'i>, AutoTraitInfo<'i>) -> A,\n+    ) -> AutoTraitResult<A> {\n         let tcx = self.tcx;\n         let ty = self.tcx.type_of(did);\n \n@@ -89,33 +87,32 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n         let trait_pred = ty::Binder::bind(trait_ref);\n \n-        let bail_out = tcx.infer_ctxt()\n-            .enter(|infcx| {\n-                let mut selcx = SelectionContext::with_negative(&infcx, true);\n-                let result =\n-                    selcx.select(&Obligation::new(ObligationCause::dummy(),\n-                                                  orig_params,\n-                                                  trait_pred.to_poly_trait_predicate()));\n-                match result {\n-                    Ok(Some(Vtable::VtableImpl(_))) => {\n-                        debug!(\"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): \\\n+        let bail_out = tcx.infer_ctxt().enter(|infcx| {\n+            let mut selcx = SelectionContext::with_negative(&infcx, true);\n+            let result = selcx.select(&Obligation::new(\n+                ObligationCause::dummy(),\n+                orig_params,\n+                trait_pred.to_poly_trait_predicate(),\n+            ));\n+            match result {\n+                Ok(Some(Vtable::VtableImpl(_))) => {\n+                    debug!(\n+                        \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): \\\n                          manual impl found, bailing out\",\n-                               did,\n-                               trait_did,\n-                               generics);\n-                        return true;\n-                    }\n-                    _ => return false,\n-                };\n-            });\n+                        did, trait_did, generics\n+                    );\n+                    return true;\n+                }\n+                _ => return false,\n+            };\n+        });\n \n         // If an explicit impl exists, it always takes priority over an auto impl\n         if bail_out {\n             return AutoTraitResult::ExplicitImpl;\n         }\n \n-        return tcx.infer_ctxt()\n-                   .enter(|mut infcx| {\n+        return tcx.infer_ctxt().enter(|mut infcx| {\n             let mut fresh_preds = FxHashSet();\n \n             // Due to the way projections are handled by SelectionContext, we need to run\n@@ -151,59 +148,60 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             // traits::project will see that 'T: SomeTrait' is in our ParamEnv, allowing\n             // SelectionContext to return it back to us.\n \n-            let (new_env, user_env) =\n-                match self.evaluate_predicates(&mut infcx,\n-                                               did,\n-                                               trait_did,\n-                                               ty,\n-                                               orig_params.clone(),\n-                                               orig_params,\n-                                               &mut fresh_preds,\n-                                               false) {\n-                    Some(e) => e,\n-                    None => return AutoTraitResult::NegativeImpl,\n-                };\n-\n-            let (full_env, full_user_env) = self.evaluate_predicates(&mut infcx,\n-                                                                     did,\n-                                                                     trait_did,\n-                                                                     ty,\n-                                                                     new_env.clone(),\n-                                                                     user_env,\n-                                                                     &mut fresh_preds,\n-                                                                     true)\n-                .unwrap_or_else(|| {\n-                                    panic!(\"Failed to fully process: {:?} {:?} {:?}\",\n-                                           ty,\n-                                           trait_did,\n-                                           orig_params)\n-                                });\n-\n-            debug!(\"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): fulfilling \\\n+            let (new_env, user_env) = match self.evaluate_predicates(\n+                &mut infcx,\n+                did,\n+                trait_did,\n+                ty,\n+                orig_params.clone(),\n+                orig_params,\n+                &mut fresh_preds,\n+                false,\n+            ) {\n+                Some(e) => e,\n+                None => return AutoTraitResult::NegativeImpl,\n+            };\n+\n+            let (full_env, full_user_env) = self.evaluate_predicates(\n+                &mut infcx,\n+                did,\n+                trait_did,\n+                ty,\n+                new_env.clone(),\n+                user_env,\n+                &mut fresh_preds,\n+                true,\n+            ).unwrap_or_else(|| {\n+                panic!(\n+                    \"Failed to fully process: {:?} {:?} {:?}\",\n+                    ty, trait_did, orig_params\n+                )\n+            });\n+\n+            debug!(\n+                \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): fulfilling \\\n                  with {:?}\",\n-                   did,\n-                   trait_did,\n-                   generics,\n-                   full_env);\n+                did, trait_did, generics, full_env\n+            );\n             infcx.clear_caches();\n \n             // At this point, we already have all of the bounds we need. FulfillmentContext is used\n             // to store all of the necessary region/lifetime bounds in the InferContext, as well as\n             // an additional sanity check.\n             let mut fulfill = FulfillmentContext::new();\n-            fulfill.register_bound(&infcx,\n-                                   full_env,\n-                                   ty,\n-                                   trait_did,\n-                                   ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID));\n-            fulfill\n-                .select_all_or_error(&infcx)\n-                .unwrap_or_else(|e| {\n-                                    panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\",\n-                                           trait_did,\n-                                           ty,\n-                                           e)\n-                                });\n+            fulfill.register_bound(\n+                &infcx,\n+                full_env,\n+                ty,\n+                trait_did,\n+                ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID),\n+            );\n+            fulfill.select_all_or_error(&infcx).unwrap_or_else(|e| {\n+                panic!(\n+                    \"Unable to fulfill trait {:?} for '{:?}': {:?}\",\n+                    trait_did, ty, e\n+                )\n+            });\n \n             let names_map: FxHashMap<String, String> = generics\n                 .regions\n@@ -281,28 +279,29 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     // the final synthesized generics: we don't want our generated docs page to contain something\n     // like 'T: Copy + Clone', as that's redundant. Therefore, we keep track of a separate\n     // 'user_env', which only holds the predicates that will actually be displayed to the user.\n-    pub fn evaluate_predicates<'b, 'gcx, 'c>(&self,\n-                                             infcx: &InferCtxt<'b, 'tcx, 'c>,\n-                                             ty_did: DefId,\n-                                             trait_did: DefId,\n-                                             ty: ty::Ty<'c>,\n-                                             param_env: ty::ParamEnv<'c>,\n-                                             user_env: ty::ParamEnv<'c>,\n-                                             fresh_preds: &mut FxHashSet<ty::Predicate<'c>>,\n-                                             only_projections: bool)\n-                                             -> Option<(ty::ParamEnv<'c>, ty::ParamEnv<'c>)> {\n+    pub fn evaluate_predicates<'b, 'gcx, 'c>(\n+        &self,\n+        infcx: &InferCtxt<'b, 'tcx, 'c>,\n+        ty_did: DefId,\n+        trait_did: DefId,\n+        ty: ty::Ty<'c>,\n+        param_env: ty::ParamEnv<'c>,\n+        user_env: ty::ParamEnv<'c>,\n+        fresh_preds: &mut FxHashSet<ty::Predicate<'c>>,\n+        only_projections: bool,\n+    ) -> Option<(ty::ParamEnv<'c>, ty::ParamEnv<'c>)> {\n         let tcx = infcx.tcx;\n \n         let mut select = SelectionContext::new(&infcx);\n \n         let mut already_visited = FxHashSet();\n         let mut predicates = VecDeque::new();\n         predicates.push_back(ty::Binder::bind(ty::TraitPredicate {\n-                                                  trait_ref: ty::TraitRef {\n-                                                      def_id: trait_did,\n-                                                      substs: infcx.tcx.mk_substs_trait(ty, &[]),\n-                                                  },\n-                                              }));\n+            trait_ref: ty::TraitRef {\n+                def_id: trait_did,\n+                substs: infcx.tcx.mk_substs_trait(ty, &[]),\n+            },\n+        }));\n \n         let mut computed_preds: FxHashSet<_> = param_env.caller_bounds.iter().cloned().collect();\n         let mut user_computed_preds: FxHashSet<_> =\n@@ -324,13 +323,15 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 &Ok(Some(ref vtable)) => {\n                     let obligations = vtable.clone().nested_obligations().into_iter();\n \n-                    if !self.evaluate_nested_obligations(ty,\n-                                                         obligations,\n-                                                         &mut user_computed_preds,\n-                                                         fresh_preds,\n-                                                         &mut predicates,\n-                                                         &mut select,\n-                                                         only_projections) {\n+                    if !self.evaluate_nested_obligations(\n+                        ty,\n+                        obligations,\n+                        &mut user_computed_preds,\n+                        fresh_preds,\n+                        &mut predicates,\n+                        &mut select,\n+                        only_projections,\n+                    ) {\n                         return None;\n                     }\n                 }\n@@ -341,11 +342,13 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                         user_computed_preds.insert(ty::Predicate::Trait(pred.clone()));\n                         predicates.push_back(pred);\n                     } else {\n-                        debug!(\"evaluate_nested_obligations: Unimplemented found, bailing: \\\n+                        debug!(\n+                            \"evaluate_nested_obligations: Unimplemented found, bailing: \\\n                              {:?} {:?} {:?}\",\n-                               ty,\n-                               pred,\n-                               pred.skip_binder().trait_ref.substs);\n+                            ty,\n+                            pred,\n+                            pred.skip_binder().trait_ref.substs\n+                        );\n                         return None;\n                     }\n                 }\n@@ -358,14 +361,15 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             new_env = ty::ParamEnv::new(tcx.mk_predicates(normalized_preds), param_env.reveal);\n         }\n \n-        let final_user_env = ty::ParamEnv::new(tcx.mk_predicates(user_computed_preds.into_iter()),\n-                                               user_env.reveal);\n-        debug!(\"evaluate_nested_obligations(ty_did={:?}, trait_did={:?}): succeeded with '{:?}' \\\n+        let final_user_env = ty::ParamEnv::new(\n+            tcx.mk_predicates(user_computed_preds.into_iter()),\n+            user_env.reveal,\n+        );\n+        debug!(\n+            \"evaluate_nested_obligations(ty_did={:?}, trait_did={:?}): succeeded with '{:?}' \\\n              '{:?}'\",\n-               ty_did,\n-               trait_did,\n-               new_env,\n-               final_user_env);\n+            ty_did, trait_did, new_env, final_user_env\n+        );\n \n         return Some((new_env, final_user_env));\n     }\n@@ -380,23 +384,20 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     pub fn get_lifetime(&self, region: Region, names_map: &FxHashMap<String, String>) -> String {\n         self.region_name(region)\n             .map(|name| {\n-                names_map\n-                    .get(&name)\n-                    .unwrap_or_else(|| {\n-                                        panic!(\"Missing lifetime with name {:?} for {:?}\",\n-                                               name,\n-                                               region)\n-                                    })\n+                names_map.get(&name).unwrap_or_else(|| {\n+                    panic!(\"Missing lifetime with name {:?} for {:?}\", name, region)\n+                })\n             })\n             .unwrap_or(&\"'static\".to_string())\n             .clone()\n     }\n \n     // This is very similar to handle_lifetimes. However, instead of matching ty::Region's\n     // to each other, we match ty::RegionVid's to ty::Region's\n-    pub fn map_vid_to_region<'cx>(&self,\n-                                  regions: &RegionConstraintData<'cx>)\n-                                  -> FxHashMap<ty::RegionVid, ty::Region<'cx>> {\n+    pub fn map_vid_to_region<'cx>(\n+        &self,\n+        regions: &RegionConstraintData<'cx>,\n+    ) -> FxHashMap<ty::RegionVid, ty::Region<'cx>> {\n         let mut vid_map: FxHashMap<RegionTarget<'cx>, RegionDeps<'cx>> = FxHashMap();\n         let mut finished_map = FxHashMap();\n \n@@ -499,34 +500,36 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         }\n \n         return match substs.type_at(0).sty {\n-                   ty::TyParam(_) => true,\n-                   ty::TyProjection(p) => self.is_of_param(p.substs),\n-                   _ => false,\n-               };\n+            ty::TyParam(_) => true,\n+            ty::TyProjection(p) => self.is_of_param(p.substs),\n+            _ => false,\n+        };\n     }\n \n-    pub fn evaluate_nested_obligations<'b,\n-                                       'c,\n-                                       'd,\n-                                       'cx,\n-                                       T: Iterator<Item = Obligation<'cx, ty::Predicate<'cx>>>>\n-        (&self,\n-         ty: ty::Ty,\n-         nested: T,\n-         computed_preds: &'b mut FxHashSet<ty::Predicate<'cx>>,\n-         fresh_preds: &'b mut FxHashSet<ty::Predicate<'cx>>,\n-         predicates: &'b mut VecDeque<ty::PolyTraitPredicate<'cx>>,\n-         select: &mut SelectionContext<'c, 'd, 'cx>,\n-         only_projections: bool)\n-         -> bool {\n+    pub fn evaluate_nested_obligations<\n+        'b,\n+        'c,\n+        'd,\n+        'cx,\n+        T: Iterator<Item = Obligation<'cx, ty::Predicate<'cx>>>,\n+    >(\n+        &self,\n+        ty: ty::Ty,\n+        nested: T,\n+        computed_preds: &'b mut FxHashSet<ty::Predicate<'cx>>,\n+        fresh_preds: &'b mut FxHashSet<ty::Predicate<'cx>>,\n+        predicates: &'b mut VecDeque<ty::PolyTraitPredicate<'cx>>,\n+        select: &mut SelectionContext<'c, 'd, 'cx>,\n+        only_projections: bool,\n+    ) -> bool {\n         let dummy_cause = ObligationCause::misc(DUMMY_SP, ast::DUMMY_NODE_ID);\n \n-        for (obligation, predicate) in\n-            nested\n-                .filter(|o| o.recursion_depth == 1)\n-                .map(|o| (o.clone(), o.predicate.clone())) {\n-            let is_new_pred = fresh_preds\n-                .insert(self.clean_pred(select.infcx(), predicate.clone()));\n+        for (obligation, predicate) in nested\n+            .filter(|o| o.recursion_depth == 1)\n+            .map(|o| (o.clone(), o.predicate.clone()))\n+        {\n+            let is_new_pred =\n+                fresh_preds.insert(self.clean_pred(select.infcx(), predicate.clone()));\n \n             match &predicate {\n                 &ty::Predicate::Trait(ref p) => {\n@@ -545,20 +548,23 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     } else {\n                         match poly_project_and_unify_type(select, &obligation.with(p.clone())) {\n                             Err(e) => {\n-                                debug!(\"evaluate_nested_obligations: Unable to unify predicate \\\n+                                debug!(\n+                                    \"evaluate_nested_obligations: Unable to unify predicate \\\n                                      '{:?}' '{:?}', bailing out\",\n-                                       ty,\n-                                       e);\n+                                    ty, e\n+                                );\n                                 return false;\n                             }\n                             Ok(Some(v)) => {\n-                                if !self.evaluate_nested_obligations(ty,\n-                                                                     v.clone().iter().cloned(),\n-                                                                     computed_preds,\n-                                                                     fresh_preds,\n-                                                                     predicates,\n-                                                                     select,\n-                                                                     only_projections) {\n+                                if !self.evaluate_nested_obligations(\n+                                    ty,\n+                                    v.clone().iter().cloned(),\n+                                    computed_preds,\n+                                    fresh_preds,\n+                                    predicates,\n+                                    select,\n+                                    only_projections,\n+                                ) {\n                                     return false;\n                                 }\n                             }\n@@ -570,37 +576,36 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 }\n                 &ty::Predicate::RegionOutlives(ref binder) => {\n                     if let Err(_) = select\n-                           .infcx()\n-                           .region_outlives_predicate(&dummy_cause, binder) {\n+                        .infcx()\n+                        .region_outlives_predicate(&dummy_cause, binder)\n+                    {\n                         return false;\n                     }\n                 }\n                 &ty::Predicate::TypeOutlives(ref binder) => {\n-                    match (binder.no_late_bound_regions(),\n-                           binder.map_bound_ref(|pred| pred.0).no_late_bound_regions()) {\n+                    match (\n+                        binder.no_late_bound_regions(),\n+                        binder.map_bound_ref(|pred| pred.0).no_late_bound_regions(),\n+                    ) {\n                         (None, Some(t_a)) => {\n-                            select\n-                                .infcx()\n-                                .register_region_obligation(ast::DUMMY_NODE_ID,\n-                                                            RegionObligation {\n-                                                                sup_type: t_a,\n-                                                                sub_region: select\n-                                                                    .infcx()\n-                                                                    .tcx\n-                                                                    .types\n-                                                                    .re_static,\n-                                                                cause: dummy_cause.clone(),\n-                                                            });\n+                            select.infcx().register_region_obligation(\n+                                ast::DUMMY_NODE_ID,\n+                                RegionObligation {\n+                                    sup_type: t_a,\n+                                    sub_region: select.infcx().tcx.types.re_static,\n+                                    cause: dummy_cause.clone(),\n+                                },\n+                            );\n                         }\n                         (Some(ty::OutlivesPredicate(t_a, r_b)), _) => {\n-                            select\n-                                .infcx()\n-                                .register_region_obligation(ast::DUMMY_NODE_ID,\n-                                                            RegionObligation {\n-                                                                sup_type: t_a,\n-                                                                sub_region: r_b,\n-                                                                cause: dummy_cause.clone(),\n-                                                            });\n+                            select.infcx().register_region_obligation(\n+                                ast::DUMMY_NODE_ID,\n+                                RegionObligation {\n+                                    sup_type: t_a,\n+                                    sub_region: r_b,\n+                                    cause: dummy_cause.clone(),\n+                                },\n+                            );\n                         }\n                         _ => {}\n                     };\n@@ -611,10 +616,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         return true;\n     }\n \n-    pub fn clean_pred<'c, 'd, 'cx>(&self,\n-                                   infcx: &InferCtxt<'c, 'd, 'cx>,\n-                                   p: ty::Predicate<'cx>)\n-                                   -> ty::Predicate<'cx> {\n+    pub fn clean_pred<'c, 'd, 'cx>(\n+        &self,\n+        infcx: &InferCtxt<'c, 'd, 'cx>,\n+        p: ty::Predicate<'cx>,\n+    ) -> ty::Predicate<'cx> {\n         infcx.freshen(p)\n     }\n }\n@@ -632,9 +638,8 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         (match r {\n-                 &ty::ReVar(vid) => self.vid_to_region.get(&vid).cloned(),\n-                 _ => None,\n-             })\n-            .unwrap_or_else(|| r.super_fold_with(self))\n+            &ty::ReVar(vid) => self.vid_to_region.get(&vid).cloned(),\n+            _ => None,\n+        }).unwrap_or_else(|| r.super_fold_with(self))\n     }\n }"}]}