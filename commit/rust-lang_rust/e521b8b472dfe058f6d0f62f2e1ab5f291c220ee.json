{"sha": "e521b8b472dfe058f6d0f62f2e1ab5f291c220ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1MjFiOGI0NzJkZmUwNThmNmQwZjYyZjJlMWFiNWYyOTFjMjIwZWU=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-03T19:15:06Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-12T20:52:47Z"}, "message": "Actually deprecate the Heap type", "tree": {"sha": "b7bd74b0b572fc7143fd783a6e912b4d1ebbf1cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7bd74b0b572fc7143fd783a6e912b4d1ebbf1cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee", "html_url": "https://github.com/rust-lang/rust/commit/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88ebd2d752831860d8824849cf6f5ae656a2c3eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/88ebd2d752831860d8824849cf6f5ae656a2c3eb", "html_url": "https://github.com/rust-lang/rust/commit/88ebd2d752831860d8824849cf6f5ae656a2c3eb"}], "stats": {"total": 93, "additions": 47, "deletions": 46}, "files": [{"sha": "12ee7701903085fe75eff053b062bcaabb8d43df", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=e521b8b472dfe058f6d0f62f2e1ab5f291c220ee", "patch": "@@ -81,8 +81,12 @@ pub struct Global;\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[rustc_deprecated(since = \"1.27.0\", reason = \"type renamed to `Global`\")]\n-pub use self::Global as Heap;\n+pub type Heap = Global;\n \n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+#[rustc_deprecated(since = \"1.27.0\", reason = \"type renamed to `Global`\")]\n+#[allow(non_upper_case_globals)]\n+pub const Heap: Global = Global;\n \n unsafe impl Alloc for Global {\n     #[inline]\n@@ -268,7 +272,7 @@ mod tests {\n     extern crate test;\n     use self::test::Bencher;\n     use boxed::Box;\n-    use heap::{Global, Alloc, Layout};\n+    use alloc::{Global, Alloc, Layout};\n \n     #[test]\n     fn allocate_zeroed() {"}, {"sha": "d63ed24aa4f698cce6ba954eefddb23d6fe9a17d", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=e521b8b472dfe058f6d0f62f2e1ab5f291c220ee", "patch": "@@ -21,7 +21,6 @@ use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n use core::fmt;\n use core::cmp::Ordering;\n-use core::heap::{Alloc, Layout};\n use core::intrinsics::abort;\n use core::mem::{self, align_of_val, size_of_val, uninitialized};\n use core::ops::Deref;\n@@ -32,7 +31,7 @@ use core::hash::{Hash, Hasher};\n use core::{isize, usize};\n use core::convert::From;\n \n-use heap::{Heap, box_free};\n+use alloc::{Global, Alloc, Layout, box_free};\n use boxed::Box;\n use string::String;\n use vec::Vec;\n@@ -521,7 +520,7 @@ impl<T: ?Sized> Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            Heap.dealloc(ptr as *mut u8, Layout::for_value(&*ptr))\n+            Global.dealloc(ptr as *mut u8, Layout::for_value(&*ptr))\n         }\n     }\n \n@@ -555,8 +554,8 @@ impl<T: ?Sized> Arc<T> {\n \n         let layout = Layout::for_value(&*fake_ptr);\n \n-        let mem = Heap.alloc(layout)\n-            .unwrap_or_else(|e| Heap.oom(e));\n+        let mem = Global.alloc(layout)\n+            .unwrap_or_else(|e| Global.oom(e));\n \n         // Initialize the real ArcInner\n         let inner = set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>;\n@@ -640,7 +639,7 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Heap.dealloc(self.mem, self.layout.clone());\n+                    Global.dealloc(self.mem, self.layout.clone());\n                 }\n             }\n         }\n@@ -1161,7 +1160,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n             unsafe {\n-                Heap.dealloc(ptr as *mut u8, Layout::for_value(&*ptr))\n+                Global.dealloc(ptr as *mut u8, Layout::for_value(&*ptr))\n             }\n         }\n     }"}, {"sha": "8e23228bd28fe0cd8455f4f0b9a1c3379a7d4a88", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=e521b8b472dfe058f6d0f62f2e1ab5f291c220ee", "patch": "@@ -41,14 +41,13 @@\n // - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n //   This implies that even an empty internal node has at least one edge.\n \n-use core::heap::{Alloc, Layout};\n use core::marker::PhantomData;\n use core::mem;\n use core::ptr::{self, Unique, NonNull};\n use core::slice;\n \n+use alloc::{Global, Alloc, Layout};\n use boxed::Box;\n-use heap::Heap;\n \n const B: usize = 6;\n pub const MIN_LEN: usize = B - 1;\n@@ -250,7 +249,7 @@ impl<K, V> Root<K, V> {\n         self.as_mut().as_leaf_mut().parent = ptr::null();\n \n         unsafe {\n-            Heap.dealloc(top, Layout::new::<InternalNode<K, V>>());\n+            Global.dealloc(top, Layout::new::<InternalNode<K, V>>());\n         }\n     }\n }\n@@ -436,7 +435,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n     > {\n         let ptr = self.as_leaf() as *const LeafNode<K, V> as *const u8 as *mut u8;\n         let ret = self.ascend().ok();\n-        Heap.dealloc(ptr, Layout::new::<LeafNode<K, V>>());\n+        Global.dealloc(ptr, Layout::new::<LeafNode<K, V>>());\n         ret\n     }\n }\n@@ -457,7 +456,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n     > {\n         let ptr = self.as_internal() as *const InternalNode<K, V> as *const u8 as *mut u8;\n         let ret = self.ascend().ok();\n-        Heap.dealloc(ptr, Layout::new::<InternalNode<K, V>>());\n+        Global.dealloc(ptr, Layout::new::<InternalNode<K, V>>());\n         ret\n     }\n }\n@@ -1239,12 +1238,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                     ).correct_parent_link();\n                 }\n \n-                Heap.dealloc(\n+                Global.dealloc(\n                     right_node.node.as_ptr() as *mut u8,\n                     Layout::new::<InternalNode<K, V>>(),\n                 );\n             } else {\n-                Heap.dealloc(\n+                Global.dealloc(\n                     right_node.node.as_ptr() as *mut u8,\n                     Layout::new::<LeafNode<K, V>>(),\n                 );"}, {"sha": "51f39dc6cc748cf52dd0cbb0c066fc2da9cc1d06", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=e521b8b472dfe058f6d0f62f2e1ab5f291c220ee", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use alloc::{Alloc, Layout, Global};\n use core::cmp;\n-use core::heap::{Alloc, Layout};\n use core::mem;\n use core::ops::Drop;\n use core::ptr::{self, Unique};\n use core::slice;\n-use heap::Heap;\n use super::boxed::Box;\n use super::allocator::CollectionAllocErr;\n use super::allocator::CollectionAllocErr::*;\n@@ -47,7 +46,7 @@ use super::allocator::CollectionAllocErr::*;\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n #[allow(missing_debug_implementations)]\n-pub struct RawVec<T, A: Alloc = Heap> {\n+pub struct RawVec<T, A: Alloc = Global> {\n     ptr: Unique<T>,\n     cap: usize,\n     a: A,\n@@ -114,14 +113,14 @@ impl<T, A: Alloc> RawVec<T, A> {\n     }\n }\n \n-impl<T> RawVec<T, Heap> {\n+impl<T> RawVec<T, Global> {\n     /// Creates the biggest possible RawVec (on the system heap)\n     /// without allocating. If T has positive size, then this makes a\n     /// RawVec with capacity 0. If T has 0 size, then it makes a\n     /// RawVec with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n     pub fn new() -> Self {\n-        Self::new_in(Heap)\n+        Self::new_in(Global)\n     }\n \n     /// Creates a RawVec (on the system heap) with exactly the\n@@ -141,13 +140,13 @@ impl<T> RawVec<T, Heap> {\n     /// Aborts on OOM\n     #[inline]\n     pub fn with_capacity(cap: usize) -> Self {\n-        RawVec::allocate_in(cap, false, Heap)\n+        RawVec::allocate_in(cap, false, Global)\n     }\n \n     /// Like `with_capacity` but guarantees the buffer is zeroed.\n     #[inline]\n     pub fn with_capacity_zeroed(cap: usize) -> Self {\n-        RawVec::allocate_in(cap, true, Heap)\n+        RawVec::allocate_in(cap, true, Global)\n     }\n }\n \n@@ -168,7 +167,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     }\n }\n \n-impl<T> RawVec<T, Heap> {\n+impl<T> RawVec<T, Global> {\n     /// Reconstitutes a RawVec from a pointer, capacity.\n     ///\n     /// # Undefined Behavior\n@@ -180,7 +179,7 @@ impl<T> RawVec<T, Heap> {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n             cap,\n-            a: Heap,\n+            a: Global,\n         }\n     }\n \n@@ -678,7 +677,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     }\n }\n \n-impl<T> RawVec<T, Heap> {\n+impl<T> RawVec<T, Global> {\n     /// Converts the entire buffer into `Box<[T]>`.\n     ///\n     /// While it is not *strictly* Undefined Behavior to call\n@@ -763,13 +762,13 @@ mod tests {\n                 if size > self.fuel {\n                     return Err(AllocErr::Unsupported { details: \"fuel exhausted\" });\n                 }\n-                match Heap.alloc(layout) {\n+                match Global.alloc(layout) {\n                     ok @ Ok(_) => { self.fuel -= size; ok }\n                     err @ Err(_) => err,\n                 }\n             }\n             unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-                Heap.dealloc(ptr, layout)\n+                Global.dealloc(ptr, layout)\n             }\n         }\n "}, {"sha": "c134b181158f54ddb7825b943017001b358f4540", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=e521b8b472dfe058f6d0f62f2e1ab5f291c220ee", "patch": "@@ -250,7 +250,6 @@ use core::cell::Cell;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::heap::{Alloc, Layout};\n use core::intrinsics::abort;\n use core::marker;\n use core::marker::{Unsize, PhantomData};\n@@ -260,7 +259,7 @@ use core::ops::CoerceUnsized;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n \n-use heap::{Heap, box_free};\n+use alloc::{Global, Alloc, Layout, box_free};\n use string::String;\n use vec::Vec;\n \n@@ -668,8 +667,8 @@ impl<T: ?Sized> Rc<T> {\n \n         let layout = Layout::for_value(&*fake_ptr);\n \n-        let mem = Heap.alloc(layout)\n-            .unwrap_or_else(|e| Heap.oom(e));\n+        let mem = Global.alloc(layout)\n+            .unwrap_or_else(|e| Global.oom(e));\n \n         // Initialize the real RcBox\n         let inner = set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>;\n@@ -752,7 +751,7 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Heap.dealloc(self.mem, self.layout.clone());\n+                    Global.dealloc(self.mem, self.layout.clone());\n                 }\n             }\n         }\n@@ -847,7 +846,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n                 self.dec_weak();\n \n                 if self.weak() == 0 {\n-                    Heap.dealloc(ptr as *mut u8, Layout::for_value(&*ptr));\n+                    Global.dealloc(ptr as *mut u8, Layout::for_value(&*ptr));\n                 }\n             }\n         }\n@@ -1273,7 +1272,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n             // the weak count starts at 1, and will only go to zero if all\n             // the strong pointers have disappeared.\n             if self.weak() == 0 {\n-                Heap.dealloc(ptr as *mut u8, Layout::for_value(&*ptr));\n+                Global.dealloc(ptr as *mut u8, Layout::for_value(&*ptr));\n             }\n         }\n     }"}, {"sha": "328131e2fef7a4c8337b86210d8c96addf433e0f", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=e521b8b472dfe058f6d0f62f2e1ab5f291c220ee", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use alloc_system::System;\n-use std::heap::{Heap, Alloc, Layout};\n+use std::alloc::{Global, Alloc, Layout};\n \n /// https://github.com/rust-lang/rust/issues/45955\n ///\n@@ -22,7 +22,7 @@ fn alloc_system_overaligned_request() {\n \n #[test]\n fn std_heap_overaligned_request() {\n-    check_overalign_requests(Heap)\n+    check_overalign_requests(Global)\n }\n \n fn check_overalign_requests<T: Alloc>(mut allocator: T) {"}, {"sha": "eb0c960732d3c2a29ba9b8bfd3ab677f52e7df15", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=e521b8b472dfe058f6d0f62f2e1ab5f291c220ee", "patch": "@@ -12,7 +12,8 @@\n \n #![unstable(issue = \"32838\", feature = \"allocator_api\")]\n \n-#[doc(inline)] pub use alloc_crate::alloc::Heap;\n+#[doc(inline)] #[allow(deprecated)] pub use alloc_crate::alloc::Heap;\n+#[doc(inline)] pub use alloc_crate::alloc::Global;\n #[doc(inline)] pub use alloc_system::System;\n #[doc(inline)] pub use core::alloc::*;\n "}, {"sha": "c4ef9e62577cde915a9562719cb816d50d31ec43", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=e521b8b472dfe058f6d0f62f2e1ab5f291c220ee", "patch": "@@ -11,13 +11,13 @@\n use self::Entry::*;\n use self::VacantEntryState::*;\n \n+use alloc::{Global, Alloc, CollectionAllocErr};\n use cell::Cell;\n use borrow::Borrow;\n use cmp::max;\n use fmt::{self, Debug};\n #[allow(deprecated)]\n use hash::{Hash, Hasher, BuildHasher, SipHasher13};\n-use heap::{Heap, Alloc, CollectionAllocErr};\n use iter::{FromIterator, FusedIterator};\n use mem::{self, replace};\n use ops::{Deref, Index};\n@@ -784,7 +784,7 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn reserve(&mut self, additional: usize) {\n         match self.try_reserve(additional) {\n             Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n-            Err(CollectionAllocErr::AllocErr(e)) => Heap.oom(e),\n+            Err(CollectionAllocErr::AllocErr(e)) => Global.oom(e),\n             Ok(()) => { /* yay */ }\n          }\n     }"}, {"sha": "10bab5df8b543455f916d5b0d03b346d52d8e374", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e521b8b472dfe058f6d0f62f2e1ab5f291c220ee/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=e521b8b472dfe058f6d0f62f2e1ab5f291c220ee", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use alloc::{Global, Alloc, Layout, CollectionAllocErr};\n use cmp;\n use hash::{BuildHasher, Hash, Hasher};\n-use heap::{Heap, Alloc, Layout, CollectionAllocErr};\n use marker;\n use mem::{align_of, size_of, needs_drop};\n use mem;\n@@ -754,7 +754,7 @@ impl<K, V> RawTable<K, V> {\n             return Err(CollectionAllocErr::CapacityOverflow);\n         }\n \n-        let buffer = Heap.alloc(Layout::from_size_align(size, alignment)\n+        let buffer = Global.alloc(Layout::from_size_align(size, alignment)\n             .ok_or(CollectionAllocErr::CapacityOverflow)?)?;\n \n         let hashes = buffer as *mut HashUint;\n@@ -772,7 +772,7 @@ impl<K, V> RawTable<K, V> {\n     unsafe fn new_uninitialized(capacity: usize) -> RawTable<K, V> {\n         match Self::try_new_uninitialized(capacity) {\n             Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n-            Err(CollectionAllocErr::AllocErr(e)) => Heap.oom(e),\n+            Err(CollectionAllocErr::AllocErr(e)) => Global.oom(e),\n             Ok(table) => { table }\n         }\n     }\n@@ -811,7 +811,7 @@ impl<K, V> RawTable<K, V> {\n     pub fn new(capacity: usize) -> RawTable<K, V> {\n         match Self::try_new(capacity) {\n             Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n-            Err(CollectionAllocErr::AllocErr(e)) => Heap.oom(e),\n+            Err(CollectionAllocErr::AllocErr(e)) => Global.oom(e),\n             Ok(table) => { table }\n         }\n     }\n@@ -1185,8 +1185,8 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n         debug_assert!(!oflo, \"should be impossible\");\n \n         unsafe {\n-            Heap.dealloc(self.hashes.ptr() as *mut u8,\n-                         Layout::from_size_align(size, align).unwrap());\n+            Global.dealloc(self.hashes.ptr() as *mut u8,\n+                           Layout::from_size_align(size, align).unwrap());\n             // Remember how everything was allocated out of one buffer\n             // during initialization? We only need one call to free here.\n         }"}]}