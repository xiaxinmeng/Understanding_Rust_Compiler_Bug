{"sha": "0f118f6a6c8fda5101f956243c716632a56f5188", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMTE4ZjZhNmM4ZmRhNTEwMWY5NTYyNDNjNzE2NjMyYTU2ZjUxODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-23T12:21:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-23T12:21:27Z"}, "message": "Auto merge of #59096 - ljedrz:HirIdify_AccessLevel, r=Zoxc\n\nmiddle: replace NodeId with HirId in AccessLevels\n\nPushing the limits of HirIdification (#57578).\n\nReplaces `NodeId` with `HirId` in `middle::privacy::AccessLevels`. Actually this time I was more successful and cracked it; I probably tried to HirIdify too much at once when I attempted it last time ^^.\n\nr? @Zoxc", "tree": {"sha": "5a8b5d3191ac26cf7ca1c093943d0235d76903af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a8b5d3191ac26cf7ca1c093943d0235d76903af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f118f6a6c8fda5101f956243c716632a56f5188", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f118f6a6c8fda5101f956243c716632a56f5188", "html_url": "https://github.com/rust-lang/rust/commit/0f118f6a6c8fda5101f956243c716632a56f5188", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f118f6a6c8fda5101f956243c716632a56f5188/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d51a437e28ab2cebbee9d54c3dbfe06e59f242d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1", "html_url": "https://github.com/rust-lang/rust/commit/d51a437e28ab2cebbee9d54c3dbfe06e59f242d1"}, {"sha": "856b081eb2ae3264da07434debd55d734fba7eb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/856b081eb2ae3264da07434debd55d734fba7eb4", "html_url": "https://github.com/rust-lang/rust/commit/856b081eb2ae3264da07434debd55d734fba7eb4"}], "stats": {"total": 107, "additions": 55, "deletions": 52}, "files": [{"sha": "ccec4bd1432695c81bc47569036d1e3536fbbfbb", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0f118f6a6c8fda5101f956243c716632a56f5188", "patch": "@@ -414,7 +414,7 @@ fn create_and_seed_worklist<'a, 'tcx>(\n ) -> (Vec<hir::HirId>, FxHashMap<hir::HirId, hir::HirId>) {\n     let worklist = access_levels.map.iter().filter_map(|(&id, level)| {\n         if level >= &privacy::AccessLevel::Reachable {\n-            Some(tcx.hir().node_to_hir_id(id))\n+            Some(id)\n         } else {\n             None\n         }"}, {"sha": "787ff8d48c1192822583fac52ca409ed2190ee83", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=0f118f6a6c8fda5101f956243c716632a56f5188", "patch": "@@ -2,11 +2,11 @@\n //! outside their scopes. This pass will also generate a set of exported items\n //! which are available for use externally when compiled as a library.\n \n+use crate::hir::HirId;\n use crate::util::nodemap::{DefIdSet, FxHashMap};\n \n use std::hash::Hash;\n use std::fmt;\n-use syntax::ast::NodeId;\n use rustc_macros::HashStable;\n \n // Accessibility levels, sorted in ascending order\n@@ -27,7 +27,7 @@ pub enum AccessLevel {\n \n // Accessibility levels for reachable HIR nodes\n #[derive(Clone)]\n-pub struct AccessLevels<Id = NodeId> {\n+pub struct AccessLevels<Id = HirId> {\n     pub map: FxHashMap<Id, AccessLevel>\n }\n "}, {"sha": "a7294dbf07c000a1c92ddeb51dce5e31f2a57bac", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=0f118f6a6c8fda5101f956243c716632a56f5188", "patch": "@@ -354,8 +354,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n \n         // We need only trait impls here, not inherent impls, and only non-exported ones\n         if let hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n-            let node_id = self.tcx.hir().hir_to_node_id(item.hir_id);\n-            if !self.access_levels.is_reachable(node_id) {\n+            if !self.access_levels.is_reachable(item.hir_id) {\n                 self.worklist.extend(impl_item_refs.iter().map(|ii_ref| ii_ref.id.hir_id));\n \n                 let trait_def_id = match trait_ref.path.def {\n@@ -415,7 +414,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n     reachable_context.worklist.extend(\n-        access_levels.map.iter().map(|(id, _)| tcx.hir().node_to_hir_id(*id)));\n+        access_levels.map.iter().map(|(id, _)| *id));\n     for item in tcx.lang_items().items().iter() {\n         if let Some(did) = *item {\n             if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {"}, {"sha": "72c90b258608df8c997a49ed70afdb1b544fa1eb", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=0f118f6a6c8fda5101f956243c716632a56f5188", "patch": "@@ -320,7 +320,7 @@ impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n         let stab = self.tcx.stability().local_stability(hir_id);\n         let is_error = !self.tcx.sess.opts.test &&\n                         stab.is_none() &&\n-                        self.access_levels.is_reachable(self.tcx.hir().hir_to_node_id(hir_id));\n+                        self.access_levels.is_reachable(hir_id);\n         if is_error {\n             self.tcx.sess.span_err(\n                 span,"}, {"sha": "8153653e48b255809dda9f383709c7e20b699680", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=0f118f6a6c8fda5101f956243c716632a56f5188", "patch": "@@ -380,8 +380,7 @@ impl MissingDoc {\n         // It's an option so the crate root can also use this function (it doesn't\n         // have a NodeId).\n         if let Some(id) = id {\n-            let node_id = cx.tcx.hir().hir_to_node_id(id);\n-            if !cx.access_levels.is_exported(node_id) {\n+            if !cx.access_levels.is_exported(id) {\n                 return;\n             }\n         }\n@@ -557,8 +556,7 @@ impl LintPass for MissingCopyImplementations {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n-        let node_id = cx.tcx.hir().hir_to_node_id(item.hir_id);\n-        if !cx.access_levels.is_reachable(node_id) {\n+        if !cx.access_levels.is_reachable(item.hir_id) {\n             return;\n         }\n         let (def, ty) = match item.node {\n@@ -629,8 +627,7 @@ impl LintPass for MissingDebugImplementations {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n-        let node_id = cx.tcx.hir().hir_to_node_id(item.hir_id);\n-        if !cx.access_levels.is_reachable(node_id) {\n+        if !cx.access_levels.is_reachable(item.hir_id) {\n             return;\n         }\n \n@@ -1169,9 +1166,8 @@ impl UnreachablePub {\n     fn perform_lint(&self, cx: &LateContext<'_, '_>, what: &str, id: hir::HirId,\n                     vis: &hir::Visibility, span: Span, exportable: bool) {\n         let mut applicability = Applicability::MachineApplicable;\n-        let node_id = cx.tcx.hir().hir_to_node_id(id);\n         match vis.node {\n-            hir::VisibilityKind::Public if !cx.access_levels.is_reachable(node_id) => {\n+            hir::VisibilityKind::Public if !cx.access_levels.is_reachable(id) => {\n                 if span.ctxt().outer().expn_info().is_some() {\n                     applicability = Applicability::MaybeIncorrect;\n                 }"}, {"sha": "19b5fa1bfbe57c33569417f519ba7cf0da264a3f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=0f118f6a6c8fda5101f956243c716632a56f5188", "patch": "@@ -379,8 +379,8 @@ impl VisibilityLike for Option<AccessLevel> {\n     // (which require reaching the `DefId`s in them).\n     const SHALLOW: bool = true;\n     fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self {\n-        cmp::min(if let Some(node_id) = find.tcx.hir().as_local_node_id(def_id) {\n-            find.access_levels.map.get(&node_id).cloned()\n+        cmp::min(if let Some(hir_id) = find.tcx.hir().as_local_hir_id(def_id) {\n+            find.access_levels.map.get(&hir_id).cloned()\n         } else {\n             Self::MAX\n         }, find.min)\n@@ -410,17 +410,15 @@ struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n \n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn get(&self, id: hir::HirId) -> Option<AccessLevel> {\n-        let node_id = self.tcx.hir().hir_to_node_id(id);\n-        self.access_levels.map.get(&node_id).cloned()\n+        self.access_levels.map.get(&id).cloned()\n     }\n \n     // Updates node level and returns the updated level.\n     fn update(&mut self, id: hir::HirId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n         let old_level = self.get(id);\n         // Accessibility levels can only grow.\n         if level > old_level {\n-            let node_id = self.tcx.hir().hir_to_node_id(id);\n-            self.access_levels.map.insert(node_id, level.unwrap());\n+            self.access_levels.map.insert(id, level.unwrap());\n             self.changed = true;\n             level\n         } else {\n@@ -1197,8 +1195,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn trait_is_public(&self, trait_id: hir::HirId) -> bool {\n         // FIXME: this would preferably be using `exported_items`, but all\n         // traits are exported currently (see `EmbargoVisitor.exported_trait`).\n-        let node_id = self.tcx.hir().hir_to_node_id(trait_id);\n-        self.access_levels.is_public(node_id)\n+        self.access_levels.is_public(trait_id)\n     }\n \n     fn check_generic_bound(&mut self, bound: &hir::GenericBound) {\n@@ -1210,8 +1207,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn item_is_public(&self, id: &hir::HirId, vis: &hir::Visibility) -> bool {\n-        let node_id = self.tcx.hir().hir_to_node_id(*id);\n-        self.access_levels.is_reachable(node_id) || vis.node.is_pub()\n+        self.access_levels.is_reachable(*id) || vis.node.is_pub()\n     }\n }\n \n@@ -1325,8 +1321,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                          hir::ImplItemKind::Const(..) |\n                                          hir::ImplItemKind::Method(..) => {\n                                              self.access_levels.is_reachable(\n-                                                self.tcx.hir().hir_to_node_id(\n-                                                    impl_item_ref.id.hir_id))\n+                                                impl_item_ref.id.hir_id)\n                                          }\n                                          hir::ImplItemKind::Existential(..) |\n                                          hir::ImplItemKind::Type(_) => false,\n@@ -1455,8 +1450,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n-        let node_id = self.tcx.hir().hir_to_node_id(item.hir_id);\n-        if self.access_levels.is_reachable(node_id) {\n+        if self.access_levels.is_reachable(item.hir_id) {\n             intravisit::walk_foreign_item(self, item)\n         }\n     }\n@@ -1474,8 +1468,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        let node_id = self.tcx.hir().hir_to_node_id(v.node.data.hir_id());\n-        if self.access_levels.is_reachable(node_id) {\n+        if self.access_levels.is_reachable(v.node.data.hir_id()) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;"}, {"sha": "76fd8b22f745262621eaaa11389ead0cf18c0bbb", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=0f118f6a6c8fda5101f956243c716632a56f5188", "patch": "@@ -58,17 +58,19 @@ macro_rules! down_cast_data {\n }\n \n macro_rules! access_from {\n-    ($save_ctxt:expr, $vis:expr, $id:expr) => {\n+    ($save_ctxt:expr, $item:expr, $id:expr) => {\n         Access {\n-            public: $vis.node.is_pub(),\n+            public: $item.vis.node.is_pub(),\n             reachable: $save_ctxt.access_levels.is_reachable($id),\n         }\n     };\n+}\n \n-    ($save_ctxt:expr, $item:expr) => {\n+macro_rules! access_from_vis {\n+    ($save_ctxt:expr, $vis:expr, $id:expr) => {\n         Access {\n-            public: $item.vis.node.is_pub(),\n-            reachable: $save_ctxt.access_levels.is_reachable($item.id),\n+            public: $vis.node.is_pub(),\n+            reachable: $save_ctxt.access_levels.is_reachable($id),\n         }\n     };\n }\n@@ -303,7 +305,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n             method_data.value = sig_str;\n             method_data.sig = sig::method_signature(id, ident, generics, sig, &self.save_ctxt);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, vis, id), method_data);\n+            let hir_id = self.tcx.hir().node_to_hir_id(id);\n+            self.dumper.dump_def(&access_from_vis!(self.save_ctxt, vis, hir_id), method_data);\n         }\n \n         // walk arg and return types\n@@ -324,7 +327,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, field), field_data);\n+            let hir_id = self.tcx.hir().node_to_hir_id(field.id);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, field, hir_id), field_data);\n         }\n     }\n \n@@ -389,7 +393,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 |v| v.process_formals(&decl.inputs, &fn_data.qualname),\n             );\n             self.process_generic_params(ty_params, &fn_data.qualname, item.id);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item), fn_data);\n+            let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item, hir_id), fn_data);\n         }\n \n         for arg in &decl.inputs {\n@@ -409,10 +414,11 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         typ: &'l ast::Ty,\n         expr: &'l ast::Expr,\n     ) {\n+        let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n         self.nest_tables(item.id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item), var_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item, hir_id), var_data);\n             }\n             v.visit_ty(&typ);\n             v.visit_expr(expr);\n@@ -435,9 +441,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         if !self.span.filter_generated(ident.span) {\n             let sig = sig::assoc_const_signature(id, ident.name, typ, expr, &self.save_ctxt);\n             let span = self.span_from_span(ident.span);\n+            let hir_id = self.tcx.hir().node_to_hir_id(id);\n \n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, vis, id),\n+                &access_from_vis!(self.save_ctxt, vis, hir_id),\n                 Def {\n                     kind: DefKind::Const,\n                     id: id_from_node_id(id, &self.save_ctxt),\n@@ -512,8 +519,9 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n         if !self.span.filter_generated(item.ident.span) {\n             let span = self.span_from_span(item.ident.span);\n+            let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item),\n+                &access_from!(self.save_ctxt, item, hir_id),\n                 Def {\n                     kind,\n                     id: id_from_node_id(item.id, &self.save_ctxt),\n@@ -552,7 +560,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n-        let access = access_from!(self.save_ctxt, item);\n+        let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+        let access = access_from!(self.save_ctxt, item, hir_id);\n \n         for variant in &enum_definition.variants {\n             let name = variant.node.ident.name.to_string();\n@@ -701,8 +710,9 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 .iter()\n                 .map(|i| id_from_node_id(i.id, &self.save_ctxt))\n                 .collect();\n+            let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item),\n+                &access_from!(self.save_ctxt, item, hir_id),\n                 Def {\n                     kind: DefKind::Trait,\n                     id,\n@@ -760,7 +770,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     fn process_mod(&mut self, item: &ast::Item) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item), mod_data);\n+            let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item, hir_id), mod_data);\n         }\n     }\n \n@@ -1201,7 +1212,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n         // The access is calculated using the current tree ID, but with the root tree's visibility\n         // (since nested trees don't have their own visibility).\n-        let access = access_from!(self.save_ctxt, root_item.vis, id);\n+        let hir_id = self.tcx.hir().node_to_hir_id(id);\n+        let access = access_from!(self.save_ctxt, root_item, hir_id);\n \n         // The parent def id of a given use tree is always the enclosing item.\n         let parent = self.save_ctxt.tcx.hir().opt_local_def_id(id)\n@@ -1400,9 +1412,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n                     let id = id_from_node_id(item.id, &self.save_ctxt);\n+                    let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n \n                     self.dumper.dump_def(\n-                        &access_from!(self.save_ctxt, item),\n+                        &access_from!(self.save_ctxt, item, hir_id),\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1431,9 +1444,10 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n                     let id = id_from_node_id(item.id, &self.save_ctxt);\n+                    let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n \n                     self.dumper.dump_def(\n-                        &access_from!(self.save_ctxt, item),\n+                        &access_from!(self.save_ctxt, item, hir_id),\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1631,7 +1645,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n     }\n \n     fn visit_foreign_item(&mut self, item: &'l ast::ForeignItem) {\n-        let access = access_from!(self.save_ctxt, item);\n+        let hir_id = self.tcx.hir().node_to_hir_id(item.id);\n+        let access = access_from!(self.save_ctxt, item, hir_id);\n \n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {"}, {"sha": "46e76d60d7d726e44066cd8116452a3ad37cf8fb", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f118f6a6c8fda5101f956243c716632a56f5188/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0f118f6a6c8fda5101f956243c716632a56f5188", "patch": "@@ -469,11 +469,11 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             sess.abort_if_errors();\n \n             let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);\n-            // Convert from a NodeId set to a DefId set since we don't always have easy access\n-            // to the map from defid -> nodeid\n+            // Convert from a HirId set to a DefId set since we don't always have easy access\n+            // to the map from defid -> hirid\n             let access_levels = AccessLevels {\n                 map: access_levels.map.iter()\n-                                    .map(|(&k, &v)| (tcx.hir().local_def_id(k), v))\n+                                    .map(|(&k, &v)| (tcx.hir().local_def_id_from_hir_id(k), v))\n                                     .collect()\n             };\n "}]}