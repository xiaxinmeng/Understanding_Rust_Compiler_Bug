{"sha": "655effedf25e2039d283b839429bf2f42b7012a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NWVmZmVkZjI1ZTIwMzlkMjgzYjgzOTQyOWJmMmY0MmI3MDEyYTQ=", "commit": {"author": {"name": "Marcin Fatyga", "email": "marcinf@google.com", "date": "2016-11-01T14:26:22Z"}, "committer": {"name": "Marcin Fatyga", "email": "marcinf@google.com", "date": "2016-11-01T14:26:22Z"}, "message": "Merge branch 'master' of https://github.com/rust-lang/rust\n\nConflicts:\n\tsrc/libcoretest/lib.rs", "tree": {"sha": "34fd087d891556c70a14b26a90d1bdccd0a7ccb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34fd087d891556c70a14b26a90d1bdccd0a7ccb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/655effedf25e2039d283b839429bf2f42b7012a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/655effedf25e2039d283b839429bf2f42b7012a4", "html_url": "https://github.com/rust-lang/rust/commit/655effedf25e2039d283b839429bf2f42b7012a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/655effedf25e2039d283b839429bf2f42b7012a4/comments", "author": {"login": "rednum", "id": 754852, "node_id": "MDQ6VXNlcjc1NDg1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/754852?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rednum", "html_url": "https://github.com/rednum", "followers_url": "https://api.github.com/users/rednum/followers", "following_url": "https://api.github.com/users/rednum/following{/other_user}", "gists_url": "https://api.github.com/users/rednum/gists{/gist_id}", "starred_url": "https://api.github.com/users/rednum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rednum/subscriptions", "organizations_url": "https://api.github.com/users/rednum/orgs", "repos_url": "https://api.github.com/users/rednum/repos", "events_url": "https://api.github.com/users/rednum/events{/privacy}", "received_events_url": "https://api.github.com/users/rednum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rednum", "id": 754852, "node_id": "MDQ6VXNlcjc1NDg1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/754852?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rednum", "html_url": "https://github.com/rednum", "followers_url": "https://api.github.com/users/rednum/followers", "following_url": "https://api.github.com/users/rednum/following{/other_user}", "gists_url": "https://api.github.com/users/rednum/gists{/gist_id}", "starred_url": "https://api.github.com/users/rednum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rednum/subscriptions", "organizations_url": "https://api.github.com/users/rednum/orgs", "repos_url": "https://api.github.com/users/rednum/repos", "events_url": "https://api.github.com/users/rednum/events{/privacy}", "received_events_url": "https://api.github.com/users/rednum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e2822c5c28bb342e5862ba7cc0b90b865c68be1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e2822c5c28bb342e5862ba7cc0b90b865c68be1", "html_url": "https://github.com/rust-lang/rust/commit/4e2822c5c28bb342e5862ba7cc0b90b865c68be1"}, {"sha": "ac968c466451cb9aafd9e8598ddb396ed0e6fe31", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac968c466451cb9aafd9e8598ddb396ed0e6fe31", "html_url": "https://github.com/rust-lang/rust/commit/ac968c466451cb9aafd9e8598ddb396ed0e6fe31"}], "stats": {"total": 75200, "additions": 41435, "deletions": 33765}, "files": [{"sha": "b79c9703f44ef17d2c37c7e6869e22d55f6ed0a7", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -89,6 +89,7 @@ build.\n    $ pacman -S git \\\n                make \\\n                diffutils \\\n+               tar \\\n                mingw-w64-x86_64-python2 \\\n                mingw-w64-x86_64-cmake \\\n                mingw-w64-x86_64-gcc"}, {"sha": "e6f18f9f7ba557726f9078ac320e0577a92318ae", "filename": "RELEASES.md", "status": "modified", "additions": 257, "deletions": 1, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -1,3 +1,259 @@\n+Version 1.12.0 (2016-09-29)\n+===========================\n+\n+Highlights\n+----------\n+\n+* [`rustc` translates code to LLVM IR via its own \"middle\" IR (MIR)]\n+  (https://github.com/rust-lang/rust/pull/34096).\n+  This translation pass is far simpler than the previous AST->LLVM pass, and\n+  creates opportunities to perform new optimizations directly on the MIR. It\n+  was previously described [on the Rust blog]\n+  (https://blog.rust-lang.org/2016/04/19/MIR.html).\n+* [`rustc` presents a new, more readable error format, along with\n+  machine-readable JSON error output for use by IDEs]\n+  (https://github.com/rust-lang/rust/pull/35401).\n+  Most common editors supporting Rust have been updated to work with it. It was\n+  previously described [on the Rust blog]\n+  (https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html).\n+\n+Compiler\n+--------\n+\n+* [`rustc` translates code to LLVM IR via its own \"middle\" IR (MIR)]\n+  (https://github.com/rust-lang/rust/pull/34096).\n+  This translation pass is far simpler than the previous AST->LLVM pass, and\n+  creates opportunities to perform new optimizations directly on the MIR. It\n+  was previously described [on the Rust blog]\n+  (https://blog.rust-lang.org/2016/04/19/MIR.html).\n+* [Print the Rust target name, not the LLVM target name, with\n+  `--print target-list`]\n+  (https://github.com/rust-lang/rust/pull/35489)\n+* [The computation of `TypeId` is correct in some cases where it was previously\n+  producing inconsistent results]\n+  (https://github.com/rust-lang/rust/pull/35267)\n+* [The `mips-unknown-linux-gnu` target uses hardware floating point by default]\n+  (https://github.com/rust-lang/rust/pull/34910)\n+* [The `rustc` arguments, `--print target-cpus`, `--print target-features`,\n+  `--print relocation-models`, and `--print code-models` print the available\n+  options to the `-C target-cpu`, `-C target-feature`, `-C relocation-model` and\n+  `-C code-model` code generation arguments]\n+  (https://github.com/rust-lang/rust/pull/34845)\n+* [`rustc` supports three new MUSL targets on ARM: `arm-unknown-linux-musleabi`,\n+  `arm-unknown-linux-musleabihf`, and `armv7-unknown-linux-musleabihf`]\n+  (https://github.com/rust-lang/rust/pull/35060).\n+  These targets produce statically-linked binaries. There are no binary release\n+  builds yet though.\n+\n+Diagnostics\n+-----------\n+\n+* [`rustc` presents a new, more readable error format, along with\n+  machine-readable JSON error output for use by IDEs]\n+  (https://github.com/rust-lang/rust/pull/35401).\n+  Most common editors supporting Rust have been updated to work with it. It was\n+  previously described [on the Rust blog]\n+  (https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html).\n+* [In error descriptions, references are now described in plain English,\n+  instead of as \"&-ptr\"]\n+  (https://github.com/rust-lang/rust/pull/35611)\n+* [In error type descriptions, unknown numeric types are named `{integer}` or\n+  `{float}` instead of `_`]\n+  (https://github.com/rust-lang/rust/pull/35080)\n+* [`rustc` emits a clearer error when inner attributes follow a doc comment]\n+  (https://github.com/rust-lang/rust/pull/34676)\n+\n+Language\n+--------\n+\n+* [`macro_rules!` invocations can be made within `macro_rules!` invocations]\n+  (https://github.com/rust-lang/rust/pull/34925)\n+* [`macro_rules!` meta-variables are hygienic]\n+  (https://github.com/rust-lang/rust/pull/35453)\n+* [`macro_rules!` `tt` matchers can be reparsed correctly, making them much more\n+  useful]\n+  (https://github.com/rust-lang/rust/pull/34908)\n+* [`macro_rules!` `stmt` matchers correctly consume the entire contents when\n+  inside non-braces invocations]\n+  (https://github.com/rust-lang/rust/pull/34886)\n+* [Semicolons are properly required as statement delimeters inside\n+  `macro_rules!` invocations]\n+  (https://github.com/rust-lang/rust/pull/34660)\n+* [`cfg_attr` works on `path` attributes]\n+  (https://github.com/rust-lang/rust/pull/34546)\n+\n+Stabilized APIs\n+---------------\n+\n+* [`Cell::as_ptr`]\n+  (https://doc.rust-lang.org/std/cell/struct.Cell.html#method.as_ptr)\n+* [`RefCell::as_ptr`]\n+  (https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr)\n+* [`IpAddr::is_unspecified`]\n+  (https://doc.rust-lang.org/std/net/enum.IpAddr.html#method.is_unspecified)\n+* [`IpAddr::is_loopback`]\n+  (https://doc.rust-lang.org/std/net/enum.IpAddr.html#method.is_loopback)\n+* [`IpAddr::is_multicast`]\n+  (https://doc.rust-lang.org/std/net/enum.IpAddr.html#method.is_multicast)\n+* [`Ipv4Addr::is_unspecified`]\n+  (https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html#method.is_unspecified)\n+* [`Ipv6Addr::octets`]\n+  (https://doc.rust-lang.org/std/net/struct.Ipv6Addr.html#method.octets)\n+* [`LinkedList::contains`]\n+  (https://doc.rust-lang.org/std/collections/linked_list/struct.LinkedList.html#method.contains)\n+* [`VecDeque::contains`]\n+  (https://doc.rust-lang.org/std/collections/vec_deque/struct.VecDeque.html#method.contains)\n+* [`ExitStatusExt::from_raw`]\n+  (https://doc.rust-lang.org/std/os/unix/process/trait.ExitStatusExt.html#tymethod.from_raw).\n+  Both on Unix and Windows.\n+* [`Receiver::recv_timeout`]\n+  (https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv_timeout)\n+* [`RecvTimeoutError`]\n+  (https://doc.rust-lang.org/std/sync/mpsc/enum.RecvTimeoutError.html)\n+* [`BinaryHeap::peek_mut`]\n+  (https://doc.rust-lang.org/std/collections/binary_heap/struct.BinaryHeap.html#method.peek_mut)\n+* [`PeekMut`]\n+  (https://doc.rust-lang.org/std/collections/binary_heap/struct.PeekMut.html)\n+* [`iter::Product`]\n+  (https://doc.rust-lang.org/std/iter/trait.Product.html)\n+* [`iter::Sum`]\n+  (https://doc.rust-lang.org/std/iter/trait.Sum.html)\n+* [`OccupiedEntry::remove_entry`]\n+  (https://doc.rust-lang.org/std/collections/btree_map/struct.OccupiedEntry.html#method.remove_entry)\n+* [`VacantEntry::into_key`]\n+  (https://doc.rust-lang.org/std/collections/btree_map/struct.VacantEntry.html#method.into_key)\n+\n+Libraries\n+---------\n+\n+* [The `format!` macro and friends now allow a single argument to be formatted\n+  in multiple styles]\n+  (https://github.com/rust-lang/rust/pull/33642)\n+* [The lifetime bounds on `[T]::binary_search_by` and\n+  `[T]::binary_search_by_key` have been adjusted to be more flexible]\n+  (https://github.com/rust-lang/rust/pull/34762)\n+* [`Option` implements `From` for its contained type]\n+  (https://github.com/rust-lang/rust/pull/34828)\n+* [`Cell`, `RefCell` and `UnsafeCell` implement `From` for their contained type]\n+  (https://github.com/rust-lang/rust/pull/35392)\n+* [`RwLock` panics if the reader count overflows]\n+  (https://github.com/rust-lang/rust/pull/35378)\n+* [`vec_deque::Drain`, `hash_map::Drain` and `hash_set::Drain` are covariant]\n+  (https://github.com/rust-lang/rust/pull/35354)\n+* [`vec::Drain` and `binary_heap::Drain` are covariant]\n+  (https://github.com/rust-lang/rust/pull/34951)\n+* [`Cow<str>` implements `FromIterator` for `char`, `&str` and `String`]\n+  (https://github.com/rust-lang/rust/pull/35064)\n+* [Sockets on Linux are correctly closed in subprocesses via `SOCK_CLOEXEC`]\n+  (https://github.com/rust-lang/rust/pull/34946)\n+* [`hash_map::Entry`, `hash_map::VacantEntry` and `hash_map::OccupiedEntry`\n+  implement `Debug`]\n+  (https://github.com/rust-lang/rust/pull/34937)\n+* [`btree_map::Entry`, `btree_map::VacantEntry` and `btree_map::OccupiedEntry`\n+  implement `Debug`]\n+  (https://github.com/rust-lang/rust/pull/34885)\n+* [`String` implements `AddAssign`]\n+  (https://github.com/rust-lang/rust/pull/34890)\n+* [Variadic `extern fn` pointers implement the `Clone`, `PartialEq`, `Eq`,\n+  `PartialOrd`, `Ord`, `Hash`, `fmt::Pointer`, and `fmt::Debug` traits]\n+  (https://github.com/rust-lang/rust/pull/34879)\n+* [`FileType` implements `Debug`]\n+  (https://github.com/rust-lang/rust/pull/34757)\n+* [References to `Mutex` and `RwLock` are unwind-safe]\n+  (https://github.com/rust-lang/rust/pull/34756)\n+* [`mpsc::sync_channel` `Receiver`s return any available message before\n+  reporting a disconnect]\n+  (https://github.com/rust-lang/rust/pull/34731)\n+* [Unicode definitions have been updated to 9.0]\n+  (https://github.com/rust-lang/rust/pull/34599)\n+* [`env` iterators implement `DoubleEndedIterator`]\n+  (https://github.com/rust-lang/rust/pull/33312)\n+\n+Cargo\n+-----\n+\n+* [Support local mirrors of registries]\n+  (https://github.com/rust-lang/cargo/pull/2857)\n+* [Add support for command aliases]\n+  (https://github.com/rust-lang/cargo/pull/2679)\n+* [Allow `opt-level=\"s\"` / `opt-level=\"z\"` in profile overrides]\n+  (https://github.com/rust-lang/cargo/pull/3007)\n+* [Make `cargo doc --open --target` work as expected]\n+  (https://github.com/rust-lang/cargo/pull/2988)\n+* [Speed up noop registry updates]\n+  (https://github.com/rust-lang/cargo/pull/2974)\n+* [Update OpenSSL]\n+  (https://github.com/rust-lang/cargo/pull/2971)\n+* [Fix `--panic=abort` with plugins]\n+  (https://github.com/rust-lang/cargo/pull/2954)\n+* [Always pass `-C metadata` to the compiler]\n+  (https://github.com/rust-lang/cargo/pull/2946)\n+* [Fix depending on git repos with workspaces]\n+  (https://github.com/rust-lang/cargo/pull/2938)\n+* [Add a `--lib` flag to `cargo new`]\n+  (https://github.com/rust-lang/cargo/pull/2921)\n+* [Add `http.cainfo` for custom certs]\n+  (https://github.com/rust-lang/cargo/pull/2917)\n+* [Indicate the compilation profile after compiling]\n+  (https://github.com/rust-lang/cargo/pull/2909)\n+* [Allow enabling features for dependencies with `--features`]\n+  (https://github.com/rust-lang/cargo/pull/2876)\n+* [Add `--jobs` flag to `cargo package`]\n+  (https://github.com/rust-lang/cargo/pull/2867)\n+* [Add `--dry-run` to `cargo publish`]\n+  (https://github.com/rust-lang/cargo/pull/2849)\n+* [Add support for `RUSTDOCFLAGS`]\n+  (https://github.com/rust-lang/cargo/pull/2794)\n+\n+Performance\n+-----------\n+\n+* [`panic::catch_unwind` is more optimized]\n+  (https://github.com/rust-lang/rust/pull/35444)\n+* [`panic::catch_unwind` no longer accesses thread-local storage on entry]\n+  (https://github.com/rust-lang/rust/pull/34866)\n+\n+Tooling\n+-------\n+\n+* [Test binaries now support a `--test-threads` argument to specify the number\n+  of threads used to run tests, and which acts the same as the\n+  `RUST_TEST_THREADS` environment variable]\n+  (https://github.com/rust-lang/rust/pull/35414)  \n+* [The test runner now emits a warning when tests run over 60 seconds]\n+  (https://github.com/rust-lang/rust/pull/35405)\n+* [rustdoc: Fix methods in search results]\n+  (https://github.com/rust-lang/rust/pull/34752)\n+* [`rust-lldb` warns about unsupported versions of LLDB]\n+  (https://github.com/rust-lang/rust/pull/34646)\n+* [Rust releases now come with source packages that can be installed by rustup\n+  via `rustup component add rust-src`]\n+  (https://github.com/rust-lang/rust/pull/34366).\n+  The resulting source code can be used by tools and IDES, located in the\n+  sysroot under `lib/rustlib/src`.\n+\n+Misc\n+----\n+\n+* [The compiler can now be built against LLVM 3.9]\n+  (https://github.com/rust-lang/rust/pull/35594)\n+* Many minor improvements to the documentation.\n+* [The Rust exception handling \"personality\" routine is now written in Rust]\n+  (https://github.com/rust-lang/rust/pull/34832)\n+\n+Compatibility Notes\n+-------------------\n+\n+* [When printing Windows `OsStr`s, unpaired surrogate codepoints are escaped\n+  with the lowercase format instead of the uppercase]\n+  (https://github.com/rust-lang/rust/pull/35084)\n+* [When formatting strings, if \"precision\" is specified, the \"fill\",\n+  \"align\" and \"width\" specifiers are no longer ignored]\n+  (https://github.com/rust-lang/rust/pull/34544)\n+* [The `Debug` impl for strings no longer escapes all non-ASCII characters]\n+  (https://github.com/rust-lang/rust/pull/34485)\n+\n+\n Version 1.11.0 (2016-08-18)\n ===========================\n \n@@ -629,7 +885,7 @@ Cargo\n Performance\n -----------\n \n-* [The time complexity of comparing variables for equivalence during type \n+* [The time complexity of comparing variables for equivalence during type\n   unification is reduced from _O_(_n_!) to _O_(_n_)][1.9tu]. This leads\n   to major compilation time improvement in some scenarios.\n * [`ToString` is specialized for `str`, giving it the same performance"}, {"sha": "686c48abb30cd25846331f66ec1cc361c14c0114", "filename": "appveyor.yml", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -0,0 +1,110 @@\n+environment:\n+  matrix:\n+  # 32/64 bit MSVC\n+  - MSYS_BITS: 64\n+    TARGET: x86_64-pc-windows-msvc\n+    CHECK: check\n+    CONFIGURE_ARGS: --enable-llvm-assertions --enable-debug-assertions\n+  - MSYS_BITS: 32\n+    TARGET: i686-pc-windows-msvc\n+    CHECK: check\n+    CONFIGURE_ARGS: --enable-llvm-assertions --enable-debug-assertions\n+\n+  # MSVC rustbuild\n+  - MSYS_BITS: 64\n+    CONFIGURE_ARGS: --enable-rustbuild --enable-llvm-assertions --enable-debug-assertions\n+    TARGET: x86_64-pc-windows-msvc\n+    CHECK: check\n+\n+  # MSVC cargotest\n+  - MSYS_BITS: 64\n+    CONFIGURE_ARGS: --enable-rustbuild --enable-llvm-assertions --enable-debug-assertions\n+    TARGET: x86_64-pc-windows-msvc\n+    CHECK: check-cargotest\n+\n+  # 32/64-bit MinGW builds.\n+  #\n+  # The MinGW builds unfortunately have to both download a custom toolchain and\n+  # avoid the one installed by AppVeyor by default. Interestingly, though, for\n+  # different reasons!\n+  #\n+  # For 32-bit the installed gcc toolchain on AppVeyor uses the pthread\n+  # threading model. This is unfortunately not what we want, and if we compile\n+  # with it then there's lots of link errors in the standard library (undefined\n+  # references to pthread symbols).\n+  #\n+  # For 64-bit the installed gcc toolchain is currently 5.3.0 which\n+  # unfortunately segfaults on Windows with --enable-llvm-assertions (segfaults\n+  # in LLVM). See rust-lang/rust#28445 for more information, but to work around\n+  # this we go back in time to 4.9.2 specifically.\n+  #\n+  # Finally, note that the downloads below are all in the `rust-lang-ci` S3\n+  # bucket, but they cleraly didn't originate there! The downloads originally\n+  # came from the mingw-w64 SourceForge download site. Unfortunately\n+  # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n+  #\n+  # And as a final point of note, the 32-bit MinGW build using the makefiles do\n+  # *not* use debug assertions and llvm assertions. This is because they take\n+  # too long on appveyor and this is tested by rustbuild below.\n+  - MSYS_BITS: 32\n+    TARGET: i686-pc-windows-gnu\n+    CHECK: check\n+    MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n+    MINGW_ARCHIVE: i686-4.9.2-release-win32-dwarf-rt_v4-rev4.7z\n+    MINGW_DIR: mingw32\n+\n+  - MSYS_BITS: 32\n+    CONFIGURE_ARGS: --enable-rustbuild --enable-llvm-assertions --enable-debug-assertions\n+    TARGET: i686-pc-windows-gnu\n+    CHECK: check\n+    MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n+    MINGW_ARCHIVE: i686-4.9.2-release-win32-dwarf-rt_v4-rev4.7z\n+    MINGW_DIR: mingw32\n+\n+  - MSYS_BITS: 64\n+    CONFIGURE_ARGS: --enable-llvm-assertions --enable-debug-assertions\n+    TARGET: x86_64-pc-windows-gnu\n+    CHECK: check\n+    MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n+    MINGW_ARCHIVE: x86_64-4.9.2-release-win32-seh-rt_v4-rev4.7z\n+    MINGW_DIR: mingw64\n+\n+clone_depth: 1\n+build: false\n+\n+install:\n+  # If we need to download a custom MinGW, do so here and set the path\n+  # appropriately.\n+  #\n+  # Note that this *also* means that we're not using what is typically\n+  # /mingw32/bin/python2.7.exe, which is a \"correct\" python interpreter where\n+  # /usr/bin/python2.7.exe is not. To ensure we use the right interpreter we\n+  # move `C:\\Python27` ahead in PATH and then also make sure the `python2.7.exe`\n+  # file exists in there (which it doesn't by default).\n+  - if defined MINGW_URL appveyor DownloadFile %MINGW_URL%/%MINGW_ARCHIVE%\n+  - if defined MINGW_URL 7z x -y %MINGW_ARCHIVE% > nul\n+  - if defined MINGW_URL set PATH=C:\\Python27;%CD%\\%MINGW_DIR%\\bin;C:\\msys64\\usr\\bin;%PATH%\n+  - if defined MINGW_URL copy C:\\Python27\\python.exe C:\\Python27\\python2.7.exe\n+\n+  # Otherwise pull in the MinGW installed on appveyor\n+  - if NOT defined MINGW_URL set PATH=C:\\msys64\\mingw%MSYS_BITS%\\bin;C:\\msys64\\usr\\bin;%PATH%\n+\n+test_script:\n+  - sh ./configure\n+          %CONFIGURE_ARGS%\n+          --build=%TARGET%\n+  - bash -c \"make -j$(nproc)\"\n+  - bash -c \"make %CHECK% -j$(nproc)\"\n+\n+cache:\n+  - build/%TARGET%/llvm -> src/rustllvm/llvm-auto-clean-trigger\n+  - \"%TARGET%/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+\n+branches:\n+  only:\n+    - auto\n+\n+# init:\n+#   - ps: iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))\n+# on_finish:\n+#   - ps: $blockRdp = $true; iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))"}, {"sha": "2bc8c72e3ea1c00cbcfd73057ab342ace4b48d2f", "filename": "configure", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/configure", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -437,6 +437,10 @@ case $CFG_OSTYPE in\n         CFG_CPUTYPE=$(isainfo -n)\n         ;;\n \n+    Haiku)\n+        CFG_OSTYPE=unknown-haiku\n+        ;;\n+\n     MINGW*)\n         # msys' `uname` does not print gcc configuration, but prints msys\n         # configuration. so we cannot believe `uname -m`:\n@@ -532,6 +536,10 @@ case $CFG_CPUTYPE in\n         CFG_CPUTYPE=x86_64\n         ;;\n \n+    BePC)\n+        CFG_CPUTYPE=i686\n+        ;;\n+\n     *)\n         err \"unknown CPU type: $CFG_CPUTYPE\"\n esac\n@@ -628,6 +636,7 @@ opt_nosave optimize-llvm 1 \"build optimized LLVM\"\n opt_nosave llvm-assertions 0 \"build LLVM with assertions\"\n opt_nosave debug-assertions 0 \"build with debugging assertions\"\n opt_nosave debuginfo 0 \"build with debugger metadata\"\n+opt_nosave debuginfo-lines 0 \"build with line number debugger metadata\"\n opt_nosave debug-jemalloc 0 \"build jemalloc with --enable-debug --enable-fill\"\n \n valopt localstatedir \"/var/lib\" \"local state directory\"\n@@ -637,7 +646,6 @@ valopt datadir \"${CFG_PREFIX}/share\" \"install data\"\n valopt infodir \"${CFG_PREFIX}/share/info\" \"install additional info\"\n valopt llvm-root \"\" \"set LLVM root\"\n valopt python \"\" \"set path to python\"\n-valopt nodejs \"\" \"set path to nodejs\"\n valopt jemalloc-root \"\" \"set directory where libjemalloc_pic.a is located\"\n valopt build \"${DEFAULT_BUILD}\" \"GNUs ./configure syntax LLVM build triple\"\n valopt android-cross-path \"\" \"Android NDK standalone path (deprecated)\"\n@@ -646,7 +654,12 @@ valopt arm-linux-androideabi-ndk \"\" \"arm-linux-androideabi NDK standalone path\"\n valopt armv7-linux-androideabi-ndk \"\" \"armv7-linux-androideabi NDK standalone path\"\n valopt aarch64-linux-android-ndk \"\" \"aarch64-linux-android NDK standalone path\"\n valopt nacl-cross-path  \"\" \"NaCl SDK path (Pepper Canary is recommended). Must be absolute!\"\n-valopt musl-root \"/usr/local\" \"MUSL root installation directory\"\n+valopt musl-root \"/usr/local\" \"MUSL root installation directory (deprecated)\"\n+valopt musl-root-x86_64 \"/usr/local\" \"x86_64-unknown-linux-musl install directory\"\n+valopt musl-root-i686 \"/usr/local\" \"i686-unknown-linux-musl install directory\"\n+valopt musl-root-arm \"/usr/local\" \"arm-unknown-linux-musleabi install directory\"\n+valopt musl-root-armhf \"/usr/local\" \"arm-unknown-linux-musleabihf install directory\"\n+valopt musl-root-armv7 \"/usr/local\" \"armv7-unknown-linux-musleabihf install directory\"\n valopt extra-filename \"\" \"Additional data that is hashed and passed to the -C extra-filename flag\"\n \n if [ -e ${CFG_SRC_DIR}.git ]\n@@ -676,7 +689,7 @@ valopt_nosave local-rust-root \"/usr/local\" \"set prefix for local rust binary\"\n valopt_nosave host \"${CFG_BUILD}\" \"GNUs ./configure syntax LLVM host triples\"\n valopt_nosave target \"${CFG_HOST}\" \"GNUs ./configure syntax LLVM target triples\"\n valopt_nosave mandir \"${CFG_PREFIX}/share/man\" \"install man pages in PATH\"\n-valopt_nosave docdir \"${CFG_PREFIX}/share/doc/rust\" \"install man pages in PATH\"\n+valopt_nosave docdir \"${CFG_PREFIX}/share/doc/rust\" \"install documentation in PATH\"\n \n # On Windows this determines root of the subtree for target libraries.\n # Host runtime libs always go to 'bin'.\n@@ -709,8 +722,27 @@ case \"$CFG_RELEASE_CHANNEL\" in\n     nightly )\n \tmsg \"overriding settings for $CFG_RELEASE_CHANNEL\"\n \tCFG_ENABLE_LLVM_ASSERTIONS=1\n+\n+        # FIXME(#37364) shouldn't have to disable this on windows-gnu\n+        case \"$CFG_BUILD\" in\n+          *-pc-windows-gnu)\n+            ;;\n+          *)\n+\t    CFG_ENABLE_DEBUGINFO_LINES=1\n+            ;;\n+        esac\n+\t;;\n+    beta | stable)\n+\tmsg \"overriding settings for $CFG_RELEASE_CHANNEL\"\n+        case \"$CFG_BUILD\" in\n+          *-pc-windows-gnu)\n+            ;;\n+          *)\n+\t    CFG_ENABLE_DEBUGINFO_LINES=1\n+            ;;\n+        esac\n \t;;\n-    dev | beta | stable)\n+    dev)\n \t;;\n     *)\n         err \"release channel must be 'dev', 'nightly', 'beta' or 'stable'\"\n@@ -740,6 +772,7 @@ if [ -n \"$CFG_DISABLE_OPTIMIZE_LLVM\" ]; then putvar CFG_DISABLE_OPTIMIZE_LLVM; f\n if [ -n \"$CFG_ENABLE_LLVM_ASSERTIONS\" ]; then putvar CFG_ENABLE_LLVM_ASSERTIONS; fi\n if [ -n \"$CFG_ENABLE_DEBUG_ASSERTIONS\" ]; then putvar CFG_ENABLE_DEBUG_ASSERTIONS; fi\n if [ -n \"$CFG_ENABLE_DEBUGINFO\" ]; then putvar CFG_ENABLE_DEBUGINFO; fi\n+if [ -n \"$CFG_ENABLE_DEBUGINFO_LINES\" ]; then putvar CFG_ENABLE_DEBUGINFO_LINES; fi\n if [ -n \"$CFG_ENABLE_DEBUG_JEMALLOC\" ]; then putvar CFG_ENABLE_DEBUG_JEMALLOC; fi\n \n step_msg \"looking for build programs\"\n@@ -754,9 +787,6 @@ if [ $(echo $python_version | grep -c '^Python 2\\.7') -ne 1 ]; then\n     err \"Found $python_version, but Python 2.7 is required\"\n fi\n \n-# Checking for node, but not required\n-probe CFG_NODEJS nodejs node\n-\n # If we have no git directory then we are probably a tarball distribution\n # and shouldn't attempt to load submodules\n if [ ! -e ${CFG_SRC_DIR}.git ]\n@@ -1208,14 +1238,6 @@ do\n             fi\n             ;;\n \n-\n-        x86_64-*-musl | arm-*-musleabi)\n-            if [ ! -f $CFG_MUSL_ROOT/lib/libc.a ]\n-            then\n-                err \"musl libc $CFG_MUSL_ROOT/lib/libc.a not found\"\n-            fi\n-            ;;\n-\n         *-msvc)\n             # There are three builds of cmake on windows: MSVC, MinGW and Cygwin\n             # The Cygwin build does not have generators for Visual Studio, so\n@@ -1634,8 +1656,8 @@ do\n         (\"ccache gcc\")\n             LLVM_CXX_32=\"ccache\"\n             LLVM_CC_32=\"ccache\"\n-            LLVM_CXX_32_ARG1=\"clang++\"\n-            LLVM_CC_32_ARG1=\"clang\"\n+            LLVM_CXX_32_ARG1=\"g++\"\n+            LLVM_CC_32_ARG1=\"gcc\"\n \n             LLVM_CXX_64=\"ccache\"\n             LLVM_CC_64=\"ccache\"\n@@ -1760,7 +1782,7 @@ do\n         CMAKE_ARGS=\"$CMAKE_ARGS -DLLVM_ENABLE_ASSERTIONS=ON\"\n     fi\n \n-    CMAKE_ARGS=\"$CMAKE_ARGS -DLLVM_TARGETS_TO_BUILD='X86;ARM;AArch64;Mips;PowerPC;SystemZ'\"\n+    CMAKE_ARGS=\"$CMAKE_ARGS -DLLVM_TARGETS_TO_BUILD='X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend'\"\n     CMAKE_ARGS=\"$CMAKE_ARGS -G '$CFG_CMAKE_GENERATOR'\"\n     CMAKE_ARGS=\"$CMAKE_ARGS $CFG_LLVM_SRC_DIR\"\n "}, {"sha": "34aee77ae2107fbe45fcb960d74d2ffdd5c57bf1", "filename": "mk/cfg/aarch64-unknown-fuchsia.mk", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fcfg%2Faarch64-unknown-fuchsia.mk", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fcfg%2Faarch64-unknown-fuchsia.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-unknown-fuchsia.mk?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -0,0 +1 @@\n+# rustbuild-only target"}, {"sha": "cbacbff070e881c38fa1eb95fd365097bd3c06a3", "filename": "mk/cfg/i686-unknown-haiku.mk", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fcfg%2Fi686-unknown-haiku.mk", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fcfg%2Fi686-unknown-haiku.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-unknown-haiku.mk?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -0,0 +1,27 @@\n+# i686-unknown-haiku configuration\n+CROSS_PREFIX_i686-unknown-haiku=i586-pc-haiku-\n+CC_i686-unknown-haiku=$(CC)\n+CXX_i686-unknown-haiku=$(CXX)\n+CPP_i686-unknown-haiku=$(CPP)\n+AR_i686-unknown-haiku=$(AR)\n+CFG_LIB_NAME_i686-unknown-haiku=lib$(1).so\n+CFG_STATIC_LIB_NAME_i686-unknown-haiku=lib$(1).a\n+CFG_LIB_GLOB_i686-unknown-haiku=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_i686-unknown-haiku=lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_i686-unknown-haiku := -m32 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_i686-unknown-haiku := -Wall -Werror -g -fPIC -m32 $(CFLAGS)\n+CFG_GCCISH_CXXFLAGS_i686-unknown-haiku := -fno-rtti $(CXXFLAGS)\n+CFG_GCCISH_LINK_FLAGS_i686-unknown-haiku := -shared -fPIC -ldl -pthread  -lrt -g -m32\n+CFG_GCCISH_PRE_LIB_FLAGS_i686-unknown-haiku := -Wl,-whole-archive\n+CFG_GCCISH_POST_LIB_FLAGS_i686-unknown-haiku := -Wl,-no-whole-archive\n+CFG_DEF_SUFFIX_i686-unknown-haiku := .linux.def\n+CFG_LLC_FLAGS_i686-unknown-haiku :=\n+CFG_INSTALL_NAME_i686-unknown-haiku =\n+CFG_EXE_SUFFIX_i686-unknown-haiku =\n+CFG_WINDOWSY_i686-unknown-haiku :=\n+CFG_UNIXY_i686-unknown-haiku := 1\n+CFG_PATH_MUNGE_i686-unknown-haiku := true\n+CFG_LDPATH_i686-unknown-haiku :=\n+CFG_RUN_i686-unknown-haiku=$(2)\n+CFG_RUN_TARG_i686-unknown-haiku=$(call CFG_RUN_i686-unknown-haiku,,$(2))\n+CFG_GNU_TRIPLE_i686-unknown-haiku := i686-unknown-haiku"}, {"sha": "997bdfbf03ab191af0de9d40c8de297709a3e0b1", "filename": "mk/cfg/wasm32-unknown-emscripten.mk", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fcfg%2Fwasm32-unknown-emscripten.mk", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fcfg%2Fwasm32-unknown-emscripten.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fwasm32-unknown-emscripten.mk?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -0,0 +1,24 @@\n+# wasm32-unknown-emscripten configuration\n+CC_wasm32-unknown-emscripten=emcc\n+CXX_wasm32-unknown-emscripten=em++\n+CPP_wasm32-unknown-emscripten=$(CPP)\n+AR_wasm32-unknown-emscripten=emar\n+CFG_LIB_NAME_wasm32-unknown-emscripten=lib$(1).so\n+CFG_STATIC_LIB_NAME_wasm32-unknown-emscripten=lib$(1).a\n+CFG_LIB_GLOB_wasm32-unknown-emscripten=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_wasm32-unknown-emscripten=lib$(1)-*.dylib.dSYM\n+CFG_JEMALLOC_CFLAGS_wasm32-unknown-emscripten := -m32 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_wasm32-unknown-emscripten :=  -g -fPIC -m32 -s BINARYEN=1 $(CFLAGS)\n+CFG_GCCISH_CXXFLAGS_wasm32-unknown-emscripten := -fno-rtti -s BINARYEN=1 $(CXXFLAGS)\n+CFG_GCCISH_LINK_FLAGS_wasm32-unknown-emscripten := -shared -fPIC -ldl -pthread  -lrt -g -m32 -s BINARYEN=1\n+CFG_GCCISH_DEF_FLAG_wasm32-unknown-emscripten := -Wl,--export-dynamic,--dynamic-list=\n+CFG_LLC_FLAGS_wasm32-unknown-emscripten :=\n+CFG_INSTALL_NAME_wasm32-unknown-emscripten =\n+CFG_EXE_SUFFIX_wasm32-unknown-emscripten =\n+CFG_WINDOWSY_wasm32-unknown-emscripten :=\n+CFG_UNIXY_wasm32-unknown-emscripten := 1\n+CFG_LDPATH_wasm32-unknown-emscripten :=\n+CFG_RUN_wasm32-unknown-emscripten=$(2)\n+CFG_RUN_TARG_wasm32-unknown-emscripten=$(call CFG_RUN_wasm32-unknown-emscripten,,$(2))\n+CFG_GNU_TRIPLE_wasm32-unknown-emscripten := wasm32-unknown-emscripten\n+CFG_DISABLE_JEMALLOC_wasm32-unknown-emscripten := 1"}, {"sha": "34aee77ae2107fbe45fcb960d74d2ffdd5c57bf1", "filename": "mk/cfg/x86_64-unknown-fuchsia.mk", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fcfg%2Fx86_64-unknown-fuchsia.mk", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fcfg%2Fx86_64-unknown-fuchsia.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-fuchsia.mk?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -0,0 +1 @@\n+# rustbuild-only target"}, {"sha": "4c2d888be06fbb6a52eacad88eae1572c678a6e4", "filename": "mk/cfg/x86_64-unknown-haiku.mk", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fcfg%2Fx86_64-unknown-haiku.mk", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fcfg%2Fx86_64-unknown-haiku.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-unknown-haiku.mk?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -0,0 +1,27 @@\n+# x86_64-unknown-haiku configuration\n+CROSS_PREFIX_x86_64-unknown-haiku=x86_64-unknown-haiku-\n+CC_x86_64-unknown-haiku=$(CC)\n+CXX_x86_64-unknown-haiku=$(CXX)\n+CPP_x86_64-unknown-haiku=$(CPP)\n+AR_x86_64-unknown-haiku=$(AR)\n+CFG_LIB_NAME_x86_64-unknown-haiku=lib$(1).so\n+CFG_STATIC_LIB_NAME_x86_64-unknown-haiku=lib$(1).a\n+CFG_LIB_GLOB_x86_64-unknown-haiku=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_x86_64-unknown-haiku=lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_x86_64-unknown-haiku := -m64 $(CFLAGS)\n+CFG_GCCISH_CFLAGS_x86_64-unknown-haiku := -Wall -Werror -g -fPIC -m64 $(CFLAGS)\n+CFG_GCCISH_CXXFLAGS_x86_64-unknown-haiku := -fno-rtti $(CXXFLAGS)\n+CFG_GCCISH_LINK_FLAGS_x86_64-unknown-haiku := -shared -fPIC -ldl -pthread -lrt -g -m64\n+CFG_GCCISH_PRE_LIB_FLAGS_x86_64-unknown-haiku := -Wl,-whole-archive\n+CFG_GCCISH_POST_LIB_FLAGS_x86_64-unknown-haiku := -Wl,-no-whole-archive\n+CFG_DEF_SUFFIX_x86_64-unknown-haiku := .linux.def\n+CFG_LLC_FLAGS_x86_64-unknown-haiku :=\n+CFG_INSTALL_NAME_x86_64-unknown-haiku =\n+CFG_EXE_SUFFIX_x86_64-unknown-haiku =\n+CFG_WINDOWSY_x86_64-unknown-haiku :=\n+CFG_UNIXY_x86_64-unknown-haiku := 1\n+CFG_PATH_MUNGE_x86_64-unknown-haiku := true\n+CFG_LDPATH_x86_64-unknown-haiku :=\n+CFG_RUN_x86_64-unknown-haiku=$(2)\n+CFG_RUN_TARG_x86_64-unknown-haiku=$(call CFG_RUN_x86_64-unknown-haiku,,$(2))\n+CFG_GNU_TRIPLE_x86_64-unknown-haiku := x86_64-unknown-haiku"}, {"sha": "25192bfd27a440ef26e1c92bc5f8ab2ea4e2063a", "filename": "mk/crates.mk", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -59,9 +59,9 @@ RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n                 rustc_data_structures rustc_platform_intrinsics rustc_errors \\\n                 rustc_plugin rustc_metadata rustc_passes rustc_save_analysis \\\n-                rustc_const_eval rustc_const_math rustc_incremental rustc_macro\n-HOST_CRATES := syntax syntax_ext proc_macro syntax_pos $(RUSTC_CRATES) rustdoc fmt_macros \\\n-\t\tflate arena graphviz rbml log serialize\n+                rustc_const_eval rustc_const_math rustc_incremental proc_macro\n+HOST_CRATES := syntax syntax_ext proc_macro_tokens proc_macro_plugin syntax_pos $(RUSTC_CRATES) \\\n+\t\trustdoc fmt_macros flate arena graphviz log serialize\n TOOLS := compiletest rustdoc rustc rustbook error_index_generator\n \n DEPS_core :=\n@@ -96,21 +96,21 @@ DEPS_getopts := std\n DEPS_graphviz := std\n DEPS_log := std\n DEPS_num := std\n-DEPS_rbml := std log serialize\n DEPS_serialize := std log\n DEPS_term := std\n DEPS_test := std getopts term native:rust_test_helpers\n \n DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode rustc_errors syntax_pos\n-DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros rustc_macro\n-DEPS_proc_macro := syntax syntax_pos rustc_plugin log\n+DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros proc_macro\n DEPS_syntax_pos := serialize\n+DEPS_proc_macro_tokens := syntax syntax_pos log\n+DEPS_proc_macro_plugin := syntax syntax_pos rustc_plugin log proc_macro_tokens\n \n DEPS_rustc_const_math := std syntax log serialize\n DEPS_rustc_const_eval := rustc_const_math rustc syntax log serialize \\\n \t\t\t     rustc_back graphviz syntax_pos\n \n-DEPS_rustc := syntax fmt_macros flate arena serialize getopts rbml \\\n+DEPS_rustc := syntax fmt_macros flate arena serialize getopts \\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\\\n \t      rustc_const_math syntax_pos rustc_errors\n DEPS_rustc_back := std syntax flate log libc\n@@ -119,15 +119,15 @@ DEPS_rustc_data_structures := std log serialize libc\n DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_borrowck \\\n                      rustc_typeck rustc_mir rustc_resolve log syntax serialize rustc_llvm \\\n                      rustc_trans rustc_privacy rustc_lint rustc_plugin \\\n-                     rustc_metadata syntax_ext proc_macro \\\n+                     rustc_metadata syntax_ext proc_macro_plugin \\\n                      rustc_passes rustc_save_analysis rustc_const_eval \\\n-                     rustc_incremental syntax_pos rustc_errors rustc_macro\n+                     rustc_incremental syntax_pos rustc_errors proc_macro rustc_data_structures\n DEPS_rustc_errors := log libc serialize syntax_pos\n DEPS_rustc_lint := rustc log syntax syntax_pos rustc_const_eval\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n-DEPS_rustc_macro := std syntax\n-DEPS_rustc_metadata := rustc syntax syntax_pos rustc_errors rbml rustc_const_math \\\n-\t\t\trustc_macro syntax_ext\n+DEPS_proc_macro := std syntax\n+DEPS_rustc_metadata := rustc syntax syntax_pos rustc_errors rustc_const_math \\\n+\t\t\tproc_macro syntax_ext\n DEPS_rustc_passes := syntax syntax_pos rustc core rustc_const_eval rustc_errors\n DEPS_rustc_mir := rustc syntax syntax_pos rustc_const_math rustc_const_eval rustc_bitflags\n DEPS_rustc_resolve := arena rustc log syntax syntax_pos rustc_errors\n@@ -137,7 +137,7 @@ DEPS_rustc_privacy := rustc log syntax syntax_pos\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n                     log syntax serialize rustc_llvm rustc_platform_intrinsics \\\n                     rustc_const_math rustc_const_eval rustc_incremental rustc_errors syntax_pos\n-DEPS_rustc_incremental := rbml rustc syntax_pos serialize rustc_data_structures\n+DEPS_rustc_incremental := rustc syntax_pos serialize rustc_data_structures\n DEPS_rustc_save_analysis := rustc log syntax syntax_pos serialize\n DEPS_rustc_typeck := rustc syntax syntax_pos rustc_platform_intrinsics rustc_const_math \\\n                      rustc_const_eval rustc_errors"}, {"sha": "5a91f5fcaa48374c95341f52d7a5e3b41fa21a5f", "filename": "mk/llvm.mk", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fllvm.mk?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -36,22 +36,27 @@ endif\n # If CFG_LLVM_ROOT is defined then we don't build LLVM ourselves\n ifeq ($(CFG_LLVM_ROOT),)\n \n-LLVM_STAMP_$(1) = $$(CFG_LLVM_BUILD_DIR_$(1))/llvm-auto-clean-stamp\n+LLVM_STAMP_$(1) = $(S)src/rustllvm/llvm-auto-clean-trigger\n LLVM_DONE_$(1) = $$(CFG_LLVM_BUILD_DIR_$(1))/llvm-finished-building\n \n $$(LLVM_CONFIG_$(1)): $$(LLVM_DONE_$(1))\n \n-$$(LLVM_DONE_$(1)): $$(LLVM_DEPS_TARGET_$(1)) $$(LLVM_STAMP_$(1))\n-\t@$$(call E, cmake: llvm)\n ifneq ($$(CFG_NINJA),)\n-\t$$(Q)$$(CFG_NINJA) -C $$(CFG_LLVM_BUILD_DIR_$(1))\n+BUILD_LLVM_$(1) := $$(CFG_NINJA) -C $$(CFG_LLVM_BUILD_DIR_$(1))\n else ifeq ($$(findstring msvc,$(1)),msvc)\n-\t$$(Q)$$(CFG_CMAKE) --build $$(CFG_LLVM_BUILD_DIR_$(1)) \\\n-\t\t--config $$(LLVM_BUILD_CONFIG_MODE)\n+BUILD_LLVM_$(1) := $$(CFG_CMAKE) --build $$(CFG_LLVM_BUILD_DIR_$(1)) \\\n+\t\t\t--config $$(LLVM_BUILD_CONFIG_MODE)\n else\n-\t$$(Q)$$(MAKE) -C $$(CFG_LLVM_BUILD_DIR_$(1))\n+BUILD_LLVM_$(1) := $$(MAKE) -C $$(CFG_LLVM_BUILD_DIR_$(1))\n endif\n-\t$$(Q)touch $$@\n+\n+$$(LLVM_DONE_$(1)): $$(LLVM_DEPS_TARGET_$(1)) $$(LLVM_STAMP_$(1))\n+\t@$$(call E, cmake: llvm)\n+\t$$(Q)if ! cmp $$(LLVM_STAMP_$(1)) $$(LLVM_DONE_$(1)); then \\\n+\t\t$$(MAKE) clean-llvm$(1); \\\n+\t\t$$(BUILD_LLVM_$(1)); \\\n+\tfi\n+\t$$(Q)cp $$(LLVM_STAMP_$(1)) $$@\n \n ifneq ($$(CFG_NINJA),)\n clean-llvm$(1):\n@@ -75,17 +80,6 @@ endif\n \n $$(LLVM_AR_$(1)): $$(LLVM_CONFIG_$(1))\n \n-# This is used to independently force an LLVM clean rebuild\n-# when we changed something not otherwise captured by builtin\n-# dependencies. In these cases, commit a change that touches\n-# the stamp in the source dir.\n-$$(LLVM_STAMP_$(1)): $$(S)src/rustllvm/llvm-auto-clean-trigger\n-\t@$$(call E, make: cleaning llvm)\n-\t$$(Q)touch $$@.start_time\n-\t$$(Q)$$(MAKE) clean-llvm$(1)\n-\t@$$(call E, make: done cleaning llvm)\n-\ttouch -r $$@.start_time $$@ && rm $$@.start_time\n-\n ifeq ($$(CFG_ENABLE_LLVM_STATIC_STDCPP),1)\n LLVM_STDCPP_RUSTFLAGS_$(1) = -L \"$$(dir $$(shell $$(CC_$(1)) $$(CFG_GCCISH_CFLAGS_$(1)) \\\n \t\t\t\t\t-print-file-name=lib$(CFG_STDCPP_NAME).a))\""}, {"sha": "a5e37641220037d960e444742dc1e61a84f1344a", "filename": "mk/main.mk", "status": "modified", "additions": 21, "deletions": 28, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -13,7 +13,7 @@\n ######################################################################\n \n # The version number\n-CFG_RELEASE_NUM=1.13.0\n+CFG_RELEASE_NUM=1.14.0\n \n # An optional number to put after the label, e.g. '.2' -> '-beta.2'\n # NB Make sure it starts with a dot to conform to semver pre-release\n@@ -53,34 +53,16 @@ endif\n # versions in the same place\n CFG_FILENAME_EXTRA=$(shell printf '%s' $(CFG_RELEASE)$(CFG_EXTRA_FILENAME) | $(CFG_HASH_COMMAND))\n \n-# A magic value that allows the compiler to use unstable features during the\n-# bootstrap even when doing so would normally be an error because of feature\n-# staging or because the build turns on warnings-as-errors and unstable features\n-# default to warnings. The build has to match this key in an env var.\n-#\n-# This value is keyed off the release to ensure that all compilers for one\n-# particular release have the same bootstrap key. Note that this is\n-# intentionally not \"secure\" by any definition, this is largely just a deterrent\n-# from users enabling unstable features on the stable compiler.\n-CFG_BOOTSTRAP_KEY=$(CFG_FILENAME_EXTRA)\n-\n-# If local-rust is the same as the current version, then force a local-rebuild\n+# If local-rust is the same major.minor as the current version, then force a local-rebuild\n ifdef CFG_ENABLE_LOCAL_RUST\n-ifeq ($(CFG_RELEASE),\\\n-      $(shell $(S)src/etc/local_stage0.sh --print-rustc-release $(CFG_LOCAL_RUST_ROOT)))\n-    CFG_INFO := $(info cfg: auto-detected local-rebuild $(CFG_RELEASE))\n+SEMVER_PREFIX=$(shell echo $(CFG_RELEASE_NUM) | grep -E -o '^[[:digit:]]+\\.[[:digit:]]+')\n+LOCAL_RELEASE=$(shell $(S)src/etc/local_stage0.sh --print-rustc-release $(CFG_LOCAL_RUST_ROOT))\n+ifneq (,$(filter $(SEMVER_PREFIX).%,$(LOCAL_RELEASE)))\n+    CFG_INFO := $(info cfg: auto-detected local-rebuild using $(LOCAL_RELEASE))\n     CFG_ENABLE_LOCAL_REBUILD = 1\n endif\n endif\n \n-# The stage0 compiler needs to use the previous key recorded in src/stage0.txt,\n-# except for local-rebuild when it just uses the same current key.\n-ifdef CFG_ENABLE_LOCAL_REBUILD\n-CFG_BOOTSTRAP_KEY_STAGE0=$(CFG_BOOTSTRAP_KEY)\n-else\n-CFG_BOOTSTRAP_KEY_STAGE0=$(shell sed -ne 's/^rustc_key: //p' $(S)src/stage0.txt)\n-endif\n-\n # The name of the package to use for creating tarballs, installers etc.\n CFG_PACKAGE_NAME=rustc-$(CFG_PACKAGE_VERS)\n \n@@ -160,6 +142,9 @@ endif\n ifdef CFG_ENABLE_DEBUGINFO\n   $(info cfg: enabling debuginfo (CFG_ENABLE_DEBUGINFO))\n   CFG_RUSTC_FLAGS += -g\n+else ifdef CFG_ENABLE_DEBUGINFO_LINES\n+  $(info cfg: enabling line number debuginfo (CFG_ENABLE_DEBUGINFO_LINES))\n+  CFG_RUSTC_FLAGS += -Cdebuginfo=1\n endif\n \n ifdef SAVE_TEMPS\n@@ -300,7 +285,7 @@ endif\n # LLVM macros\n ######################################################################\n \n-LLVM_OPTIONAL_COMPONENTS=x86 arm aarch64 mips powerpc pnacl systemz\n+LLVM_OPTIONAL_COMPONENTS=x86 arm aarch64 mips powerpc pnacl systemz jsbackend\n LLVM_REQUIRED_COMPONENTS=ipo bitreader bitwriter linker asmparser mcjit \\\n                 interpreter instrumentation\n \n@@ -387,13 +372,16 @@ CFG_INFO := $(info cfg: disabling unstable features (CFG_DISABLE_UNSTABLE_FEATUR\n # Turn on feature-staging\n export CFG_DISABLE_UNSTABLE_FEATURES\n # Subvert unstable feature lints to do the self-build\n-export RUSTC_BOOTSTRAP_KEY:=$(CFG_BOOTSTRAP_KEY)\n+export RUSTC_BOOTSTRAP\n endif\n-export CFG_BOOTSTRAP_KEY\n ifdef CFG_MUSL_ROOT\n export CFG_MUSL_ROOT\n endif\n \n+# FIXME: Transitionary measure to bootstrap using the old bootstrap logic.\n+# Remove this once the bootstrap compiler uses the new login in Issue #36548.\n+export RUSTC_BOOTSTRAP_KEY=62b3e239\n+\n ######################################################################\n # Per-stage targets and runner\n ######################################################################\n@@ -512,10 +500,14 @@ ifeq ($$(OSTYPE_$(3)),apple-darwin)\n else\n ifeq ($$(CFG_WINDOWSY_$(3)),1)\n   LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3) := PATH\n+else\n+ifeq ($$(OSTYPE_$(3)),unknown-haiku)\n+  LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3) := LIBRARY_PATH\n else\n   LD_LIBRARY_PATH_ENV_NAME$(1)_T_$(2)_H_$(3) := LD_LIBRARY_PATH\n endif\n endif\n+endif\n \n LD_LIBRARY_PATH_ENV_HOSTDIR$(1)_T_$(2)_H_$(3) := \\\n     $$(CURDIR)/$$(HLIB$(1)_H_$(3)):$$(CFG_LLVM_INST_DIR_$(3))/lib\n@@ -633,7 +625,8 @@ ALL_TARGET_RULES = $(foreach target,$(CFG_TARGET), \\\n \t$(foreach host,$(CFG_HOST), \\\n  all-target-$(target)-host-$(host)))\n \n-all: $(ALL_TARGET_RULES) $(GENERATED) docs\n+all-no-docs: $(ALL_TARGET_RULES) $(GENERATED)\n+all: all-no-docs docs\n \n ######################################################################\n # Build system documentation"}, {"sha": "1b139909ab458587e6398629275c2245183fca77", "filename": "mk/target.mk", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -42,23 +42,6 @@ $(foreach host,$(CFG_HOST), \\\n    $(foreach crate,$(CRATES), \\\n     $(eval $(call RUST_CRATE_FULLDEPS,$(stage),$(target),$(host),$(crate)))))))\n \n-# $(1) stage\n-# $(2) target\n-# $(3) host\n-define DEFINE_BOOTSTRAP_KEY\n-BOOTSTRAP_KEY$(1)_T_$(2)_H_$(3) := $$(CFG_BOOTSTRAP_KEY)\n-ifeq ($(1),0)\n-ifeq ($(3),$$(CFG_BUILD))\n-BOOTSTRAP_KEY$(1)_T_$(2)_H_$(3) := $$(CFG_BOOTSTRAP_KEY_STAGE0)\n-endif\n-endif\n-endef\n-\n-$(foreach host,$(CFG_TARGET), \\\n- $(foreach target,$(CFG_TARGET), \\\n-  $(foreach stage,$(STAGES), \\\n-   $(eval $(call DEFINE_BOOTSTRAP_KEY,$(stage),$(target),$(host))))))\n-\n # RUST_TARGET_STAGE_N template: This defines how target artifacts are built\n # for all stage/target architecture combinations. This is one giant rule which\n # works as follows:\n@@ -83,8 +66,6 @@ $(foreach host,$(CFG_TARGET), \\\n define RUST_TARGET_STAGE_N\n \n $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): CFG_COMPILER_HOST_TRIPLE = $(2)\n-$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): \\\n-\texport RUSTC_BOOTSTRAP_KEY := $$(BOOTSTRAP_KEY$(1)_T_$(2)_H_$(3))\n $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4): \\\n \t\t$$(CRATEFILE_$(4)) \\\n \t\t$$(CRATE_FULLDEPS_$(1)_T_$(2)_H_$(3)_$(4)) \\\n@@ -132,8 +113,6 @@ endef\n # $(4) - name of the tool being built\n define TARGET_TOOL\n \n-$$(TBIN$(1)_T_$(2)_H_$(3))/$(4)$$(X_$(2)): \\\n-\texport RUSTC_BOOTSTRAP_KEY := $$(BOOTSTRAP_KEY$(1)_T_$(2)_H_$(3))\n $$(TBIN$(1)_T_$(2)_H_$(3))/$(4)$$(X_$(2)): \\\n \t\t$$(TOOL_SOURCE_$(4)) \\\n \t\t$$(TOOL_INPUTS_$(4)) \\"}, {"sha": "1957c989eb0d4807ed424d91f17ea988b30f716e", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -27,7 +27,7 @@ TEST_TARGET_CRATES = $(filter-out core rustc_unicode alloc_system libc \\\n \t\t\t\t  panic_abort,$(TARGET_CRATES)) \\\n \t\t\tcollectionstest coretest\n TEST_DOC_CRATES = $(DOC_CRATES) arena flate fmt_macros getopts graphviz \\\n-                log rand rbml serialize syntax term test\n+                log rand serialize syntax term test\n TEST_HOST_CRATES = $(filter-out rustc_typeck rustc_borrowck rustc_resolve \\\n \t\t   \t\trustc_trans rustc_lint,\\\n                      $(HOST_CRATES))\n@@ -632,6 +632,7 @@ endif\n # is a separate choice from whether to pass `-g` when building the\n # compiler and standard library themselves.\n CTEST_RUSTC_FLAGS := $$(subst -g,,$$(CTEST_RUSTC_FLAGS))\n+CTEST_RUSTC_FLAGS := $$(subst -Cdebuginfo=1,,$$(CTEST_RUSTC_FLAGS))\n ifdef CFG_ENABLE_DEBUGINFO_TESTS\n CTEST_RUSTC_FLAGS += -g\n endif"}, {"sha": "5826995cc3cfc65da9a24a5b2678359f9853ce15", "filename": "src/Cargo.lock", "status": "added", "additions": 765, "deletions": 0, "changes": 765, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -0,0 +1,765 @@\n+[root]\n+name = \"unwind\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+ \"libc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"alloc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"alloc_jemalloc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"build_helper 0.1.0\",\n+ \"core 0.0.0\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"alloc_system\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+ \"libc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"arena\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"bootstrap\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"build_helper 0.1.0\",\n+ \"cmake 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.38 (git+https://github.com/alexcrichton/gcc-rs)\",\n+ \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"md5 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"build_helper\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"cargotest\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"cmake\"\n+version = \"0.1.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"collections\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"alloc 0.0.0\",\n+ \"core 0.0.0\",\n+ \"rustc_unicode 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"compiler_builtins\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"compiletest\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serialize 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"core\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"env_logger\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"error_index_generator\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"filetime\"\n+version = \"0.1.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"flate\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"build_helper 0.1.0\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"fmt_macros\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"gcc\"\n+version = \"0.3.38\"\n+source = \"git+https://github.com/alexcrichton/gcc-rs#be620ac6d3ddb498cd0c700d5312c6a4c3c19597\"\n+\n+[[package]]\n+name = \"gcc\"\n+version = \"0.3.38\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"getopts\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"getopts\"\n+version = \"0.2.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"graphviz\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"idna\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-bidi 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-normalization 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"kernel32-sys\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"linkchecker\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"url 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"log\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"log\"\n+version = \"0.3.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"matches\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"md5\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"num_cpus\"\n+version = \"0.2.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"panic_abort\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+ \"libc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"panic_unwind\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"alloc 0.0.0\",\n+ \"core 0.0.0\",\n+ \"libc 0.0.0\",\n+ \"unwind 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"proc_macro\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"proc_macro_plugin\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"proc_macro_tokens 0.0.0\",\n+ \"rustc_plugin 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"proc_macro_tokens\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rand\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustbook\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"rustc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"flate 0.0.0\",\n+ \"fmt_macros 0.0.0\",\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_bitflags 0.0.0\",\n+ \"rustc_const_math 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc-main\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_back 0.0.0\",\n+ \"rustc_driver 0.0.0\",\n+ \"rustdoc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc-serialize\"\n+version = \"0.3.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"rustc_back\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_bitflags\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"rustc_borrowck\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_const_eval\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_const_math 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_const_math\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_data_structures\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"serialize 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_driver\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"flate 0.0.0\",\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"proc_macro_plugin 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_borrowck 0.0.0\",\n+ \"rustc_const_eval 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"rustc_incremental 0.0.0\",\n+ \"rustc_lint 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"rustc_metadata 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n+ \"rustc_passes 0.0.0\",\n+ \"rustc_plugin 0.0.0\",\n+ \"rustc_privacy 0.0.0\",\n+ \"rustc_resolve 0.0.0\",\n+ \"rustc_save_analysis 0.0.0\",\n+ \"rustc_trans 0.0.0\",\n+ \"rustc_typeck 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_ext 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_errors\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_incremental\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_lint\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_const_eval 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_llvm\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"build_helper 0.1.0\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_bitflags 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_metadata\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"flate 0.0.0\",\n+ \"log 0.0.0\",\n+ \"proc_macro 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_const_math 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_ext 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_mir\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_bitflags 0.0.0\",\n+ \"rustc_const_eval 0.0.0\",\n+ \"rustc_const_math 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_passes\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_const_eval 0.0.0\",\n+ \"rustc_const_math 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_platform_intrinsics\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"rustc_plugin\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_bitflags 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"rustc_metadata 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_privacy\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_resolve\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_save_analysis\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_trans\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"flate 0.0.0\",\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_const_eval 0.0.0\",\n+ \"rustc_const_math 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"rustc_incremental 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"rustc_platform_intrinsics 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_typeck\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"fmt_macros 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_const_eval 0.0.0\",\n+ \"rustc_const_math 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"rustc_platform_intrinsics 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_unicode\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustdoc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"build_helper 0.1.0\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_const_eval 0.0.0\",\n+ \"rustc_const_math 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_driver 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"rustc_lint 0.0.0\",\n+ \"rustc_metadata 0.0.0\",\n+ \"rustc_resolve 0.0.0\",\n+ \"rustc_trans 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"serialize\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"std\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"alloc 0.0.0\",\n+ \"alloc_jemalloc 0.0.0\",\n+ \"alloc_system 0.0.0\",\n+ \"build_helper 0.1.0\",\n+ \"collections 0.0.0\",\n+ \"compiler_builtins 0.0.0\",\n+ \"core 0.0.0\",\n+ \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.0.0\",\n+ \"panic_abort 0.0.0\",\n+ \"panic_unwind 0.0.0\",\n+ \"rand 0.0.0\",\n+ \"rustc_unicode 0.0.0\",\n+ \"unwind 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"std_shim\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+ \"std 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"syntax\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc_bitflags 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"syntax_ext\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"fmt_macros 0.0.0\",\n+ \"log 0.0.0\",\n+ \"proc_macro 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_pos 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"syntax_pos\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"serialize 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"term\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"test\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"getopts 0.0.0\",\n+ \"term 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"test_shim\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"test 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"tidy\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"toml\"\n+version = \"0.1.30\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"unicode-bidi\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"unicode-normalization\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"url\"\n+version = \"1.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"idna 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"winapi-build\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[metadata]\n+\"checksum cmake 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dfcf5bcece56ef953b8ea042509e9dcbdfe97820b7e20d86beb53df30ed94978\"\n+\"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n+\"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n+\"checksum gcc 0.3.38 (git+https://github.com/alexcrichton/gcc-rs)\" = \"<none>\"\n+\"checksum gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\" = \"553f11439bdefe755bf366b264820f1da70f3aaf3924e594b886beb9c831bcf5\"\n+\"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n+\"checksum idna 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1053236e00ce4f668aeca4a769a09b3bf5a682d802abd6f3cb39374f6b162c11\"\n+\"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n+\"checksum libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"044d1360593a78f5c8e5e710beccdc24ab71d1f01bc19a29bcacdba22e8475d8\"\n+\"checksum log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab83497bf8bf4ed2a74259c1c802351fcd67a65baa86394b6ba73c36f4838054\"\n+\"checksum matches 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bcc3ad8109fa4b522f9b0cd81440422781f564aaf8c195de6b9d6642177ad0dd\"\n+\"checksum md5 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a5539a8dee9b4ae308c9c406a379838b435a8f2c84cf9fedc6d5a576be9888db\"\n+\"checksum num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cee7e88156f3f9e19bdd598f8d6c9db7bf4078f99f8381f43a55b09648d1a6e3\"\n+\"checksum rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6159e4e6e559c81bd706afe9c8fd68f547d3e851ce12e76b1de7914bab61691b\"\n+\"checksum toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0590d72182e50e879c4da3b11c6488dae18fccb1ae0c7a3eda18e16795844796\"\n+\"checksum unicode-bidi 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c1f7ceb96afdfeedee42bade65a0d585a6a0106f681b6749c8ff4daa8df30b3f\"\n+\"checksum unicode-normalization 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"26643a2f83bac55f1976fb716c10234485f9202dcd65cfbdf9da49867b271172\"\n+\"checksum url 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9ba5a45db1d2e0effb7a1c00cc73ffc63a973da8c7d1fcd5b46f24285ade6c54\"\n+\"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n+\"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "dbd2f7743dc087c080d8f1a21dc48bc870a9108b", "filename": "src/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -0,0 +1,13 @@\n+[workspace]\n+members = [\n+  \"bootstrap\",\n+  \"rustc\",\n+  \"rustc/std_shim\",\n+  \"rustc/test_shim\",\n+  \"tools/cargotest\",\n+  \"tools/compiletest\",\n+  \"tools/error_index_generator\",\n+  \"tools/linkchecker\",\n+  \"tools/rustbook\",\n+  \"tools/tidy\",\n+]"}, {"sha": "36b94e4ebea32d4136abc26919eb7f89f4fe0d8d", "filename": "src/bootstrap/Cargo.lock", "status": "removed", "additions": 0, "deletions": 180, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/4e2822c5c28bb342e5862ba7cc0b90b865c68be1/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4e2822c5c28bb342e5862ba7cc0b90b865c68be1/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=4e2822c5c28bb342e5862ba7cc0b90b865c68be1", "patch": "@@ -1,180 +0,0 @@\n-[root]\n-name = \"bootstrap\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"build_helper 0.1.0\",\n- \"cmake 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"gcc 0.3.31 (git+https://github.com/alexcrichton/gcc-rs)\",\n- \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"md5 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num_cpus 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.1.73 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.1.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"aho-corasick\"\n-version = \"0.5.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"build_helper\"\n-version = \"0.1.0\"\n-\n-[[package]]\n-name = \"cmake\"\n-version = \"0.1.17\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"gcc 0.3.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"filetime\"\n-version = \"0.1.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"libc 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"gcc\"\n-version = \"0.3.31\"\n-source = \"git+https://github.com/alexcrichton/gcc-rs#b8e2400883f1a2749b323354dad372cdd1c838c7\"\n-\n-[[package]]\n-name = \"gcc\"\n-version = \"0.3.31\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"getopts\"\n-version = \"0.2.14\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"kernel32-sys\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"libc\"\n-version = \"0.2.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"md5\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"memchr\"\n-version = \"0.1.11\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"libc 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"num_cpus\"\n-version = \"0.2.11\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"libc 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"regex\"\n-version = \"0.1.73\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"aho-corasick 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"thread_local 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"regex-syntax\"\n-version = \"0.3.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"rustc-serialize\"\n-version = \"0.3.19\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"thread-id\"\n-version = \"2.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"thread_local\"\n-version = \"0.2.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"toml\"\n-version = \"0.1.28\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"utf8-ranges\"\n-version = \"0.1.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"winapi\"\n-version = \"0.2.6\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"winapi-build\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[metadata]\n-\"checksum aho-corasick 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2b3fb52b09c1710b961acb35390d514be82e4ac96a9969a8e38565a29b878dc9\"\n-\"checksum cmake 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dfcf5bcece56ef953b8ea042509e9dcbdfe97820b7e20d86beb53df30ed94978\"\n-\"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n-\"checksum gcc 0.3.31 (git+https://github.com/alexcrichton/gcc-rs)\" = \"<none>\"\n-\"checksum gcc 0.3.31 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cfe877476e53690ebb0ce7325d0bf43e198d9500291b54b3c65e518de5039b07\"\n-\"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n-\"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n-\"checksum libc 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"55f3730be7e803cf350d32061958171731c2395831fbd67a61083782808183e0\"\n-\"checksum md5 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a5539a8dee9b4ae308c9c406a379838b435a8f2c84cf9fedc6d5a576be9888db\"\n-\"checksum memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d8b629fb514376c675b98c1421e80b151d3817ac42d7c667717d282761418d20\"\n-\"checksum num_cpus 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"51fedae97a05f7353612fe017ab705a37e6db8f4d67c5c6fe739a9e70d6eed09\"\n-\"checksum regex 0.1.73 (registry+https://github.com/rust-lang/crates.io-index)\" = \"56b7ee9f764ecf412c6e2fff779bca4b22980517ae335a21aeaf4e32625a5df2\"\n-\"checksum regex-syntax 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"31040aad7470ad9d8c46302dcffba337bb4289ca5da2e3cd6e37b64109a85199\"\n-\"checksum rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6159e4e6e559c81bd706afe9c8fd68f547d3e851ce12e76b1de7914bab61691b\"\n-\"checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03\"\n-\"checksum thread_local 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"55dd963dbaeadc08aa7266bf7f91c3154a7805e32bb94b820b769d2ef3b4744d\"\n-\"checksum toml 0.1.28 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fcd27a04ca509aff336ba5eb2abc58d456f52c4ff64d9724d88acb85ead560b6\"\n-\"checksum utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a1ca13c08c41c9c3e04224ed9ff80461d97e121589ff27c753a16cb10830ae0f\"\n-\"checksum winapi 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4dfaaa8fbdaa618fa6914b59b2769d690dd7521920a18d84b42d254678dd5fd4\"\n-\"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\""}, {"sha": "c96690754387bad2db75660f9e36c3bd97754470", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -27,9 +27,10 @@ num_cpus = \"0.2\"\n toml = \"0.1\"\n getopts = \"0.2\"\n rustc-serialize = \"0.3\"\n-winapi = \"0.2\"\n-kernel32-sys = \"0.2\"\n gcc = { git = \"https://github.com/alexcrichton/gcc-rs\" }\n libc = \"0.2\"\n md5 = \"0.1\"\n-regex = \"0.1.73\"\n+\n+[target.'cfg(windows)'.dependencies]\n+winapi = \"0.2\"\n+kernel32-sys = \"0.2\""}, {"sha": "879eca60cc751e8430d8dd62a350d7bef78dc06a", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -36,8 +36,9 @@ fn main() {\n     let args = env::args_os().skip(1).collect::<Vec<_>>();\n     // Detect whether or not we're a build script depending on whether --target\n     // is passed (a bit janky...)\n-    let target = args.windows(2).find(|w| &*w[0] == \"--target\")\n-                                .and_then(|w| w[1].to_str());\n+    let target = args.windows(2)\n+        .find(|w| &*w[0] == \"--target\")\n+        .and_then(|w| w[1].to_str());\n     let version = args.iter().find(|w| &**w == \"-vV\");\n \n     // Build scripts always use the snapshot compiler which is guaranteed to be\n@@ -55,23 +56,24 @@ fn main() {\n     } else {\n         (\"RUSTC_REAL\", \"RUSTC_LIBDIR\")\n     };\n-    let stage = env::var(\"RUSTC_STAGE\").unwrap();\n+    let stage = env::var(\"RUSTC_STAGE\").expect(\"RUSTC_STAGE was not set\");\n \n-    let rustc = env::var_os(rustc).unwrap();\n-    let libdir = env::var_os(libdir).unwrap();\n+    let rustc = env::var_os(rustc).unwrap_or_else(|| panic!(\"{:?} was not set\", rustc));\n+    let libdir = env::var_os(libdir).unwrap_or_else(|| panic!(\"{:?} was not set\", libdir));\n     let mut dylib_path = bootstrap::util::dylib_path();\n     dylib_path.insert(0, PathBuf::from(libdir));\n \n     let mut cmd = Command::new(rustc);\n     cmd.args(&args)\n-       .arg(\"--cfg\").arg(format!(\"stage{}\", stage))\n-       .env(bootstrap::util::dylib_path_var(),\n-            env::join_paths(&dylib_path).unwrap());\n+        .arg(\"--cfg\")\n+        .arg(format!(\"stage{}\", stage))\n+        .env(bootstrap::util::dylib_path_var(),\n+             env::join_paths(&dylib_path).unwrap());\n \n     if let Some(target) = target {\n         // The stage0 compiler has a special sysroot distinct from what we\n         // actually downloaded, so we just always pass the `--sysroot` option.\n-        cmd.arg(\"--sysroot\").arg(env::var_os(\"RUSTC_SYSROOT\").unwrap());\n+        cmd.arg(\"--sysroot\").arg(env::var_os(\"RUSTC_SYSROOT\").expect(\"RUSTC_SYSROOT was not set\"));\n \n         // When we build Rust dylibs they're all intended for intermediate\n         // usage, so make sure we pass the -Cprefer-dynamic flag instead of\n@@ -101,21 +103,21 @@ fn main() {\n         // This... is a bit of a hack how we detect this. Ideally this\n         // information should be encoded in the crate I guess? Would likely\n         // require an RFC amendment to RFC 1513, however.\n-        let is_panic_abort = args.windows(2).any(|a| {\n-            &*a[0] == \"--crate-name\" && &*a[1] == \"panic_abort\"\n-        });\n-        // FIXME(stage0): remove this `stage != \"0\"` condition\n-        if is_panic_abort && stage != \"0\" {\n+        let is_panic_abort = args.windows(2)\n+            .any(|a| &*a[0] == \"--crate-name\" && &*a[1] == \"panic_abort\");\n+        if is_panic_abort {\n             cmd.arg(\"-C\").arg(\"panic=abort\");\n         }\n \n         // Set various options from config.toml to configure how we're building\n         // code.\n         if env::var(\"RUSTC_DEBUGINFO\") == Ok(\"true\".to_string()) {\n             cmd.arg(\"-g\");\n+        } else if env::var(\"RUSTC_DEBUGINFO_LINES\") == Ok(\"true\".to_string()) {\n+            cmd.arg(\"-Cdebuginfo=1\");\n         }\n         let debug_assertions = match env::var(\"RUSTC_DEBUG_ASSERTIONS\") {\n-            Ok(s) => if s == \"true\" {\"y\"} else {\"n\"},\n+            Ok(s) => if s == \"true\" { \"y\" } else { \"n\" },\n             Err(..) => \"n\",\n         };\n         cmd.arg(\"-C\").arg(format!(\"debug-assertions={}\", debug_assertions));"}, {"sha": "67358e540dad0c1419745658bb0548d9934ec2d8", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -20,21 +20,23 @@ use std::path::PathBuf;\n \n fn main() {\n     let args = env::args_os().skip(1).collect::<Vec<_>>();\n-    let rustdoc = env::var_os(\"RUSTDOC_REAL\").unwrap();\n-    let libdir = env::var_os(\"RUSTC_LIBDIR\").unwrap();\n+    let rustdoc = env::var_os(\"RUSTDOC_REAL\").expect(\"RUSTDOC_REAL was not set\");\n+    let libdir = env::var_os(\"RUSTC_LIBDIR\").expect(\"RUSTC_LIBDIR was not set\");\n+    let stage = env::var(\"RUSTC_STAGE\").expect(\"RUSTC_STAGE was not set\");\n \n     let mut dylib_path = bootstrap::util::dylib_path();\n     dylib_path.insert(0, PathBuf::from(libdir));\n \n     let mut cmd = Command::new(rustdoc);\n     cmd.args(&args)\n-       .arg(\"--cfg\").arg(format!(\"stage{}\", env::var(\"RUSTC_STAGE\").unwrap()))\n-       .arg(\"--cfg\").arg(\"dox\")\n-       .env(bootstrap::util::dylib_path_var(),\n-            env::join_paths(&dylib_path).unwrap());\n+        .arg(\"--cfg\")\n+        .arg(format!(\"stage{}\", stage))\n+        .arg(\"--cfg\")\n+        .arg(\"dox\")\n+        .env(bootstrap::util::dylib_path_var(),\n+             env::join_paths(&dylib_path).unwrap());\n     std::process::exit(match cmd.status() {\n         Ok(s) => s.code().unwrap_or(1),\n         Err(e) => panic!(\"\\n\\nfailed to run {:?}: {}\\n\\n\", cmd, e),\n     })\n }\n-"}, {"sha": "2c2260a8e60c76fc76cbeddeffd1dd5048b92cc0", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -131,7 +131,8 @@ def stage0_data(rust_root):\n def format_build_time(duration):\n     return str(datetime.timedelta(seconds=int(duration)))\n \n-class RustBuild:\n+\n+class RustBuild(object):\n     def download_stage0(self):\n         cache_dst = os.path.join(self.build_dir, \"cache\")\n         rustc_cache = os.path.join(cache_dst, self.stage0_rustc_date())\n@@ -142,7 +143,7 @@ def download_stage0(self):\n             os.makedirs(cargo_cache)\n \n         if self.rustc().startswith(self.bin_root()) and \\\n-           (not os.path.exists(self.rustc()) or self.rustc_out_of_date()):\n+                (not os.path.exists(self.rustc()) or self.rustc_out_of_date()):\n             if os.path.exists(self.bin_root()):\n                 shutil.rmtree(self.bin_root())\n             channel = self.stage0_rustc_channel()\n@@ -165,7 +166,7 @@ def download_stage0(self):\n                 f.write(self.stage0_rustc_date())\n \n         if self.cargo().startswith(self.bin_root()) and \\\n-           (not os.path.exists(self.cargo()) or self.cargo_out_of_date()):\n+                (not os.path.exists(self.cargo()) or self.cargo_out_of_date()):\n             channel = self.stage0_cargo_channel()\n             filename = \"cargo-{}-{}.tar.gz\".format(channel, self.build)\n             url = \"https://static.rust-lang.org/cargo-dist/\" + self.stage0_cargo_date()\n@@ -238,8 +239,8 @@ def rustc(self):\n \n     def get_string(self, line):\n         start = line.find('\"')\n-        end = start + 1 + line[start+1:].find('\"')\n-        return line[start+1:end]\n+        end = start + 1 + line[start + 1:].find('\"')\n+        return line[start + 1:end]\n \n     def exe_suffix(self):\n         if sys.platform == 'win32':\n@@ -269,15 +270,16 @@ def run(self, args, env):\n             sys.exit(ret)\n \n     def build_triple(self):\n+        default_encoding = sys.getdefaultencoding()\n         config = self.get_toml('build')\n         if config:\n             return config\n         config = self.get_mk('CFG_BUILD')\n         if config:\n             return config\n         try:\n-            ostype = subprocess.check_output(['uname', '-s']).strip()\n-            cputype = subprocess.check_output(['uname', '-m']).strip()\n+            ostype = subprocess.check_output(['uname', '-s']).strip().decode(default_encoding)\n+            cputype = subprocess.check_output(['uname', '-m']).strip().decode(default_encoding)\n         except (subprocess.CalledProcessError, WindowsError):\n             if sys.platform == 'win32':\n                 return 'x86_64-pc-windows-msvc'\n@@ -289,7 +291,8 @@ def build_triple(self):\n         # Darwin's `uname -s` lies and always returns i386. We have to use\n         # sysctl instead.\n         if ostype == 'Darwin' and cputype == 'i686':\n-            sysctl = subprocess.check_output(['sysctl', 'hw.optional.x86_64'])\n+            args = ['sysctl', 'hw.optional.x86_64']\n+            sysctl = subprocess.check_output(args).decode(default_encoding)\n             if ': 1' in sysctl:\n                 cputype = 'x86_64'\n "}, {"sha": "af76a49fed0455bbf5028b5a67b7da39cba445c2", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 113, "deletions": 33, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -13,19 +13,44 @@\n //! This file implements the various regression test suites that we execute on\n //! our CI.\n \n+use std::collections::{HashMap, HashSet};\n use std::env;\n-use std::fs::{self, File};\n-use std::io::prelude::*;\n+use std::fs;\n use std::path::{PathBuf, Path};\n use std::process::Command;\n \n use build_helper::output;\n+use rustc_serialize::json;\n \n use {Build, Compiler, Mode};\n use util::{self, dylib_path, dylib_path_var};\n \n const ADB_TEST_DIR: &'static str = \"/data/tmp\";\n \n+#[derive(RustcDecodable)]\n+struct Output {\n+    packages: Vec<Package>,\n+    resolve: Resolve,\n+}\n+\n+#[derive(RustcDecodable)]\n+struct Package {\n+    id: String,\n+    name: String,\n+    source: Option<String>,\n+}\n+\n+#[derive(RustcDecodable)]\n+struct Resolve {\n+    nodes: Vec<ResolveNode>,\n+}\n+\n+#[derive(RustcDecodable)]\n+struct ResolveNode {\n+    id: String,\n+    dependencies: Vec<String>,\n+}\n+\n /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n ///\n /// This tool in `src/tools` will verify the validity of all our links in the\n@@ -108,6 +133,10 @@ pub fn compiletest(build: &Build,\n     cmd.arg(\"--host\").arg(compiler.host);\n     cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(&build.config.build));\n \n+    if let Some(nodejs) = build.config.nodejs.as_ref() {\n+        cmd.arg(\"--nodejs\").arg(nodejs);\n+    }\n+\n     let mut flags = vec![\"-Crpath\".to_string()];\n     if build.config.rust_optimize_tests {\n         flags.push(\"-O\".to_string());\n@@ -185,7 +214,7 @@ pub fn compiletest(build: &Build,\n             }\n         }\n     }\n-    build.add_bootstrap_key(compiler, &mut cmd);\n+    build.add_bootstrap_key(&mut cmd);\n \n     cmd.arg(\"--adb-path\").arg(\"adb\");\n     cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n@@ -259,56 +288,74 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n /// It essentially is the driver for running `cargo test`.\n ///\n /// Currently this runs all tests for a DAG by passing a bunch of `-p foo`\n-/// arguments, and those arguments are discovered from `Cargo.lock`.\n+/// arguments, and those arguments are discovered from `cargo metadata`.\n pub fn krate(build: &Build,\n              compiler: &Compiler,\n              target: &str,\n              mode: Mode) {\n-    let (name, path, features) = match mode {\n-        Mode::Libstd => (\"libstd\", \"src/rustc/std_shim\", build.std_features()),\n-        Mode::Libtest => (\"libtest\", \"src/rustc/test_shim\", String::new()),\n-        Mode::Librustc => (\"librustc\", \"src/rustc\", build.rustc_features()),\n+    let (name, path, features, root) = match mode {\n+        Mode::Libstd => {\n+            (\"libstd\", \"src/rustc/std_shim\", build.std_features(), \"std_shim\")\n+        }\n+        Mode::Libtest => {\n+            (\"libtest\", \"src/rustc/test_shim\", String::new(), \"test_shim\")\n+        }\n+        Mode::Librustc => {\n+            (\"librustc\", \"src/rustc\", build.rustc_features(), \"rustc-main\")\n+        }\n         _ => panic!(\"can only test libraries\"),\n     };\n     println!(\"Testing {} stage{} ({} -> {})\", name, compiler.stage,\n              compiler.host, target);\n \n+    // Run `cargo metadata` to figure out what crates we're testing.\n+    //\n+    // Down below we're going to call `cargo test`, but to test the right set\n+    // of packages we're going to have to know what `-p` arguments to pass it\n+    // to know what crates to test. Here we run `cargo metadata` to learn about\n+    // the dependency graph and what `-p` arguments there are.\n+    let mut cargo = Command::new(&build.cargo);\n+    cargo.arg(\"metadata\")\n+         .arg(\"--manifest-path\").arg(build.src.join(path).join(\"Cargo.toml\"));\n+    let output = output(&mut cargo);\n+    let output: Output = json::decode(&output).unwrap();\n+    let id2pkg = output.packages.iter()\n+                        .map(|pkg| (&pkg.id, pkg))\n+                        .collect::<HashMap<_, _>>();\n+    let id2deps = output.resolve.nodes.iter()\n+                        .map(|node| (&node.id, &node.dependencies))\n+                        .collect::<HashMap<_, _>>();\n+\n     // Build up the base `cargo test` command.\n+    //\n+    // Pass in some standard flags then iterate over the graph we've discovered\n+    // in `cargo metadata` with the maps above and figure out what `-p`\n+    // arguments need to get passed.\n     let mut cargo = build.cargo(compiler, mode, target, \"test\");\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(path).join(\"Cargo.toml\"))\n          .arg(\"--features\").arg(features);\n \n-    // Generate a list of `-p` arguments to pass to the `cargo test` invocation\n-    // by crawling the corresponding Cargo.lock file.\n-    let lockfile = build.src.join(path).join(\"Cargo.lock\");\n-    let mut contents = String::new();\n-    t!(t!(File::open(&lockfile)).read_to_string(&mut contents));\n-    let mut lines = contents.lines();\n-    while let Some(line) = lines.next() {\n-        let prefix = \"name = \\\"\";\n-        if !line.starts_with(prefix) {\n+    let mut visited = HashSet::new();\n+    let root_pkg = output.packages.iter().find(|p| p.name == root).unwrap();\n+    let mut next = vec![&root_pkg.id];\n+    while let Some(id) = next.pop() {\n+        // Skip any packages with sources listed, as these come from crates.io\n+        // and we shouldn't be testing them.\n+        if id2pkg[id].source.is_some() {\n             continue\n         }\n-        lines.next(); // skip `version = ...`\n-\n-        // skip crates.io or otherwise non-path crates\n-        if let Some(line) = lines.next() {\n-            if line.starts_with(\"source\") {\n-                continue\n-            }\n-        }\n-\n-        let crate_name = &line[prefix.len()..line.len() - 1];\n-\n         // Right now jemalloc is our only target-specific crate in the sense\n         // that it's not present on all platforms. Custom skip it here for now,\n         // but if we add more this probably wants to get more generalized.\n-        if crate_name.contains(\"jemalloc\") {\n-            continue\n+        if !id.contains(\"jemalloc\") {\n+            cargo.arg(\"-p\").arg(&id2pkg[id].name);\n+        }\n+        for dep in id2deps[id] {\n+            if visited.insert(dep) {\n+                next.push(dep);\n+            }\n         }\n-\n-        cargo.arg(\"-p\").arg(crate_name);\n     }\n \n     // The tests are going to run with the *target* libraries, so we need to\n@@ -323,6 +370,9 @@ pub fn krate(build: &Build,\n     if target.contains(\"android\") {\n         build.run(cargo.arg(\"--no-run\"));\n         krate_android(build, compiler, target, mode);\n+    } else if target.contains(\"emscripten\") {\n+        build.run(cargo.arg(\"--no-run\"));\n+        krate_emscripten(build, compiler, target, mode);\n     } else {\n         cargo.args(&build.flags.args);\n         build.run(&mut cargo);\n@@ -371,6 +421,35 @@ fn krate_android(build: &Build,\n     }\n }\n \n+fn krate_emscripten(build: &Build,\n+                    compiler: &Compiler,\n+                    target: &str,\n+                    mode: Mode) {\n+     let mut tests = Vec::new();\n+     let out_dir = build.cargo_out(compiler, mode, target);\n+     find_tests(&out_dir, target, &mut tests);\n+     find_tests(&out_dir.join(\"deps\"), target, &mut tests);\n+\n+     for test in tests {\n+         let test_file_name = test.to_string_lossy().into_owned();\n+         println!(\"running {}\", test_file_name);\n+         let nodejs = build.config.nodejs.as_ref().expect(\"nodejs not configured\");\n+         let status = Command::new(nodejs)\n+             .arg(&test_file_name)\n+             .stderr(::std::process::Stdio::inherit())\n+             .status();\n+         match status {\n+             Ok(status) => {\n+                 if !status.success() {\n+                     panic!(\"some tests failed\");\n+                 }\n+             }\n+             Err(e) => panic!(format!(\"failed to execute command: {}\", e)),\n+         };\n+     }\n+ }\n+\n+\n fn find_tests(dir: &Path,\n               target: &str,\n               dst: &mut Vec<PathBuf>) {\n@@ -381,7 +460,8 @@ fn find_tests(dir: &Path,\n         }\n         let filename = e.file_name().into_string().unwrap();\n         if (target.contains(\"windows\") && filename.ends_with(\".exe\")) ||\n-           (!target.contains(\"windows\") && !filename.contains(\".\")) {\n+           (!target.contains(\"windows\") && !filename.contains(\".\")) ||\n+           (target.contains(\"emscripten\") && filename.contains(\".js\")){\n             dst.push(e.path());\n         }\n     }"}, {"sha": "ff8e4757bd1f140aceb274f70734a7b8309ca998", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -25,7 +25,7 @@ use std::process::Command;\n use build_helper::output;\n use filetime::FileTime;\n \n-use util::{exe, staticlib, libdir, mtime, is_dylib, copy};\n+use util::{exe, libdir, mtime, is_dylib, copy};\n use {Build, Compiler, Mode};\n \n /// Build the standard library.\n@@ -40,20 +40,6 @@ pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n     let libdir = build.sysroot_libdir(compiler, target);\n     let _ = fs::remove_dir_all(&libdir);\n     t!(fs::create_dir_all(&libdir));\n-    // FIXME(stage0) remove this `if` after the next snapshot\n-    // The stage0 compiler still passes the `-lcompiler-rt` flag to the linker but now `bootstrap`\n-    // never builds a `libcopmiler-rt.a`! We'll fill the hole by simply copying stage0's\n-    // `libcompiler-rt.a` to where the stage1's one is expected (though we could as well just use\n-    // an empty `.a` archive). Note that the symbols of that stage0 `libcompiler-rt.a` won't make\n-    // it to the final binary because now `libcore.rlib` also contains the symbols that\n-    // `libcompiler-rt.a` provides. Since that rlib appears first in the linker arguments, its\n-    // symbols are used instead of `libcompiler-rt.a`'s.\n-    if compiler.stage == 0 {\n-        let rtlib = &staticlib(\"compiler-rt\", target);\n-        let src = build.rustc.parent().unwrap().parent().unwrap().join(\"lib\").join(\"rustlib\")\n-            .join(target).join(\"lib\").join(rtlib);\n-        copy(&src, &libdir.join(rtlib));\n-    }\n \n     // Some platforms have startup objects that may be required to produce the\n     // libstd dynamic library, for example.\n@@ -104,16 +90,16 @@ pub fn std_link(build: &Build,\n     add_to_sysroot(&out_dir, &libdir);\n \n     if target.contains(\"musl\") && !target.contains(\"mips\") {\n-        copy_musl_third_party_objects(build, &libdir);\n+        copy_musl_third_party_objects(build, target, &libdir);\n     }\n }\n \n /// Copies the crt(1,i,n).o startup objects\n ///\n /// Only required for musl targets that statically link to libc\n-fn copy_musl_third_party_objects(build: &Build, into: &Path) {\n+fn copy_musl_third_party_objects(build: &Build, target: &str, into: &Path) {\n     for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-        copy(&build.config.musl_root.as_ref().unwrap().join(\"lib\").join(obj), &into.join(obj));\n+        copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n     }\n }\n \n@@ -133,7 +119,7 @@ fn build_startup_objects(build: &Build, target: &str, into: &Path) {\n     for file in t!(fs::read_dir(build.src.join(\"src/rtstartup\"))) {\n         let file = t!(file);\n         let mut cmd = Command::new(&compiler_path);\n-        build.add_bootstrap_key(&compiler, &mut cmd);\n+        build.add_bootstrap_key(&mut cmd);\n         build.run(cmd.arg(\"--target\").arg(target)\n                      .arg(\"--emit=obj\")\n                      .arg(\"--out-dir\").arg(into)\n@@ -199,7 +185,6 @@ pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n     cargo.env(\"CFG_RELEASE\", &build.release)\n          .env(\"CFG_RELEASE_CHANNEL\", &build.config.channel)\n          .env(\"CFG_VERSION\", &build.version)\n-         .env(\"CFG_BOOTSTRAP_KEY\", &build.bootstrap_key)\n          .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or(String::new()))\n          .env(\"CFG_LIBDIR_RELATIVE\", \"lib\");\n "}, {"sha": "8c0ad1ccf825fc8c8af12140963faa8f8c4c9b34", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -56,6 +56,7 @@ pub struct Config {\n     pub rust_codegen_units: u32,\n     pub rust_debug_assertions: bool,\n     pub rust_debuginfo: bool,\n+    pub rust_debuginfo_lines: bool,\n     pub rust_rpath: bool,\n     pub rustc_default_linker: Option<String>,\n     pub rustc_default_ar: Option<String>,\n@@ -79,6 +80,9 @@ pub struct Config {\n     // Fallback musl-root for all targets\n     pub musl_root: Option<PathBuf>,\n     pub prefix: Option<String>,\n+    pub docdir: Option<String>,\n+    pub libdir: Option<String>,\n+    pub mandir: Option<String>,\n     pub codegen_tests: bool,\n     pub nodejs: Option<PathBuf>,\n }\n@@ -117,6 +121,7 @@ struct Build {\n     rustc: Option<String>,\n     compiler_docs: Option<bool>,\n     docs: Option<bool>,\n+    submodules: Option<bool>,\n }\n \n /// TOML representation of how the LLVM build is configured.\n@@ -137,6 +142,7 @@ struct Rust {\n     codegen_units: Option<u32>,\n     debug_assertions: Option<bool>,\n     debuginfo: Option<bool>,\n+    debuginfo_lines: Option<bool>,\n     debug_jemalloc: Option<bool>,\n     use_jemalloc: Option<bool>,\n     backtrace: Option<bool>,\n@@ -158,6 +164,7 @@ struct TomlTarget {\n     cc: Option<String>,\n     cxx: Option<String>,\n     android_ndk: Option<String>,\n+    musl_root: Option<String>,\n }\n \n impl Config {\n@@ -221,6 +228,7 @@ impl Config {\n         config.cargo = build.cargo.map(PathBuf::from);\n         set(&mut config.compiler_docs, build.compiler_docs);\n         set(&mut config.docs, build.docs);\n+        set(&mut config.submodules, build.submodules);\n \n         if let Some(ref llvm) = toml.llvm {\n             set(&mut config.ccache, llvm.ccache);\n@@ -233,6 +241,7 @@ impl Config {\n         if let Some(ref rust) = toml.rust {\n             set(&mut config.rust_debug_assertions, rust.debug_assertions);\n             set(&mut config.rust_debuginfo, rust.debuginfo);\n+            set(&mut config.rust_debuginfo_lines, rust.debuginfo_lines);\n             set(&mut config.rust_optimize, rust.optimize);\n             set(&mut config.rust_optimize_tests, rust.optimize_tests);\n             set(&mut config.rust_debuginfo_tests, rust.debuginfo_tests);\n@@ -268,6 +277,7 @@ impl Config {\n                 }\n                 target.cxx = cfg.cxx.clone().map(PathBuf::from);\n                 target.cc = cfg.cc.clone().map(PathBuf::from);\n+                target.musl_root = cfg.musl_root.clone().map(PathBuf::from);\n \n                 config.target_config.insert(triple.clone(), target);\n             }\n@@ -322,6 +332,7 @@ impl Config {\n                 (\"OPTIMIZE\", self.rust_optimize),\n                 (\"DEBUG_ASSERTIONS\", self.rust_debug_assertions),\n                 (\"DEBUGINFO\", self.rust_debuginfo),\n+                (\"DEBUGINFO_LINES\", self.rust_debuginfo_lines),\n                 (\"JEMALLOC\", self.use_jemalloc),\n                 (\"DEBUG_JEMALLOC\", self.debug_jemalloc),\n                 (\"RPATH\", self.rust_rpath),\n@@ -345,6 +356,36 @@ impl Config {\n                 \"CFG_MUSL_ROOT\" if value.len() > 0 => {\n                     self.musl_root = Some(PathBuf::from(value));\n                 }\n+                \"CFG_MUSL_ROOT_X86_64\" if value.len() > 0 => {\n+                    let target = \"x86_64-unknown-linux-musl\".to_string();\n+                    let target = self.target_config.entry(target)\n+                                     .or_insert(Target::default());\n+                    target.musl_root = Some(PathBuf::from(value));\n+                }\n+                \"CFG_MUSL_ROOT_I686\" if value.len() > 0 => {\n+                    let target = \"i686-unknown-linux-musl\".to_string();\n+                    let target = self.target_config.entry(target)\n+                                     .or_insert(Target::default());\n+                    target.musl_root = Some(PathBuf::from(value));\n+                }\n+                \"CFG_MUSL_ROOT_ARM\" if value.len() > 0 => {\n+                    let target = \"arm-unknown-linux-musleabi\".to_string();\n+                    let target = self.target_config.entry(target)\n+                                     .or_insert(Target::default());\n+                    target.musl_root = Some(PathBuf::from(value));\n+                }\n+                \"CFG_MUSL_ROOT_ARMHF\" if value.len() > 0 => {\n+                    let target = \"arm-unknown-linux-musleabihf\".to_string();\n+                    let target = self.target_config.entry(target)\n+                                     .or_insert(Target::default());\n+                    target.musl_root = Some(PathBuf::from(value));\n+                }\n+                \"CFG_MUSL_ROOT_ARMV7\" if value.len() > 0 => {\n+                    let target = \"armv7-unknown-linux-musleabihf\".to_string();\n+                    let target = self.target_config.entry(target)\n+                                     .or_insert(Target::default());\n+                    target.musl_root = Some(PathBuf::from(value));\n+                }\n                 \"CFG_DEFAULT_AR\" if value.len() > 0 => {\n                     self.rustc_default_ar = Some(value.to_string());\n                 }\n@@ -357,6 +398,15 @@ impl Config {\n                 \"CFG_PREFIX\" => {\n                     self.prefix = Some(value.to_string());\n                 }\n+                \"CFG_DOCDIR\" => {\n+                    self.docdir = Some(value.to_string());\n+                }\n+                \"CFG_LIBDIR\" => {\n+                    self.libdir = Some(value.to_string());\n+                }\n+                \"CFG_MANDIR\" => {\n+                    self.mandir = Some(value.to_string());\n+                }\n                 \"CFG_LLVM_ROOT\" if value.len() > 0 => {\n                     let target = self.target_config.entry(self.build.clone())\n                                      .or_insert(Target::default());\n@@ -396,9 +446,6 @@ impl Config {\n                     self.rustc = Some(PathBuf::from(value).join(\"bin/rustc\"));\n                     self.cargo = Some(PathBuf::from(value).join(\"bin/cargo\"));\n                 }\n-                \"CFG_NODEJS\" if value.len() > 0 => {\n-                    self.nodejs = Some(PathBuf::from(value));\n-                }\n                 _ => {}\n             }\n         }"}, {"sha": "b4730c003d6461e6ac7d434157ff2cb74febb8fe", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -76,6 +76,9 @@\n # library and facade crates.\n #compiler-docs = false\n \n+# Indicate whether submodules are managed and updated automatically.\n+#submodules = true\n+\n # =============================================================================\n # Options for compiling Rust code itself\n # =============================================================================\n@@ -96,6 +99,9 @@\n # Whether or not debuginfo is emitted\n #debuginfo = false\n \n+# Whether or not line number debug information is emitted\n+#debuginfo-lines = false\n+\n # Whether or not jemalloc is built and enabled\n #use-jemalloc = true\n "}, {"sha": "8676f5cc4a1ed3ff82fe62d8f426c6530db8b9ee", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 26, "deletions": 45, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -25,9 +25,8 @@ use std::process::Command;\n \n use {Build, Compiler};\n use util::{cp_r, libdir, is_dylib, cp_filtered, copy};\n-use regex::{RegexSet, quote};\n \n-fn package_vers(build: &Build) -> &str {\n+pub fn package_vers(build: &Build) -> &str {\n     match &build.config.channel[..] {\n         \"stable\" => &build.release,\n         \"beta\" => \"beta\",\n@@ -40,7 +39,7 @@ fn distdir(build: &Build) -> PathBuf {\n     build.out.join(\"dist\")\n }\n \n-fn tmpdir(build: &Build) -> PathBuf {\n+pub fn tmpdir(build: &Build) -> PathBuf {\n     build.out.join(\"tmp/dist\")\n }\n \n@@ -315,49 +314,31 @@ pub fn rust_src(build: &Build) {\n         \"mk\"\n     ];\n \n-    // Exclude paths matching these wildcard expressions\n-    let excludes = [\n-        // exclude-vcs\n-        \"CVS\", \"RCS\", \"SCCS\", \".git\", \".gitignore\", \".gitmodules\", \".gitattributes\", \".cvsignore\",\n-        \".svn\", \".arch-ids\", \"{arch}\", \"=RELEASE-ID\", \"=meta-update\", \"=update\", \".bzr\",\n-        \".bzrignore\", \".bzrtags\", \".hg\", \".hgignore\", \".hgrags\", \"_darcs\",\n-        // extensions\n-        \"*~\", \"*.pyc\",\n-        // misc\n-        \"llvm/test/*/*.ll\",\n-        \"llvm/test/*/*.td\",\n-        \"llvm/test/*/*.s\",\n-        \"llvm/test/*/*/*.ll\",\n-        \"llvm/test/*/*/*.td\",\n-        \"llvm/test/*/*/*.s\"\n-    ];\n-\n-    // Construct a set of regexes for efficiently testing whether paths match one of the above\n-    // expressions.\n-    let regex_set = t!(RegexSet::new(\n-        // This converts a wildcard expression to a regex\n-        excludes.iter().map(|&s| {\n-            // Prefix ensures that matching starts on a path separator boundary\n-            r\"^(.*[\\\\/])?\".to_owned() + (\n-                // Escape the expression to produce a regex matching exactly that string\n-                &quote(s)\n-                // Replace slashes with a pattern matching either forward or backslash\n-                .replace(r\"/\", r\"[\\\\/]\")\n-                // Replace wildcards with a pattern matching a single path segment, ie. containing\n-                // no slashes.\n-                .replace(r\"\\*\", r\"[^\\\\/]*\")\n-            // Suffix anchors to the end of the path\n-            ) + \"$\"\n-        })\n-    ));\n-\n-    // Create a filter which skips files which match the regex set or contain invalid unicode\n     let filter_fn = move |path: &Path| {\n-        if let Some(path) = path.to_str() {\n-            !regex_set.is_match(path)\n-        } else {\n-            false\n+        let spath = match path.to_str() {\n+            Some(path) => path,\n+            None => return false,\n+        };\n+        if spath.ends_with(\"~\") || spath.ends_with(\".pyc\") {\n+            return false\n         }\n+        if spath.contains(\"llvm/test\") || spath.contains(\"llvm\\\\test\") {\n+            if spath.ends_with(\".ll\") ||\n+               spath.ends_with(\".td\") ||\n+               spath.ends_with(\".s\") {\n+                return false\n+            }\n+        }\n+\n+        let excludes = [\n+            \"CVS\", \"RCS\", \"SCCS\", \".git\", \".gitignore\", \".gitmodules\",\n+            \".gitattributes\", \".cvsignore\", \".svn\", \".arch-ids\", \"{arch}\",\n+            \"=RELEASE-ID\", \"=meta-update\", \"=update\", \".bzr\", \".bzrignore\",\n+            \".bzrtags\", \".hg\", \".hgignore\", \".hgrags\", \"_darcs\",\n+        ];\n+        !path.iter()\n+             .map(|s| s.to_str().unwrap())\n+             .any(|s| excludes.contains(&s))\n     };\n \n     // Copy the directories using our filter\n@@ -418,7 +399,7 @@ fn chmod(_path: &Path, _perms: u32) {}\n \n // We have to run a few shell scripts, which choke quite a bit on both `\\`\n // characters and on `C:\\` paths, so normalize both of them away.\n-fn sanitize_sh(path: &Path) -> String {\n+pub fn sanitize_sh(path: &Path) -> String {\n     let path = path.to_str().unwrap().replace(\"\\\\\", \"/\");\n     return change_drive(&path).unwrap_or(path);\n "}, {"sha": "9bc5a7c00abafca26975f7925b882f116c197846", "filename": "src/bootstrap/install.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of the install aspects of the compiler.\n+//!\n+//! This module is responsible for installing the standard library,\n+//! compiler, and documentation.\n+\n+use std::fs;\n+use std::borrow::Cow;\n+use std::path::Path;\n+use std::process::Command;\n+\n+use Build;\n+use dist::{package_vers, sanitize_sh, tmpdir};\n+\n+/// Installs everything.\n+pub fn install(build: &Build, stage: u32, host: &str) {\n+    let prefix = build.config.prefix.as_ref().clone().map(|x| Path::new(x))\n+        .unwrap_or(Path::new(\"/usr/local\"));\n+    let docdir = build.config.docdir.as_ref().clone().map(|x| Cow::Borrowed(Path::new(x)))\n+        .unwrap_or(Cow::Owned(prefix.join(\"share/doc/rust\")));\n+    let libdir = build.config.libdir.as_ref().clone().map(|x| Cow::Borrowed(Path::new(x)))\n+        .unwrap_or(Cow::Owned(prefix.join(\"lib\")));\n+    let mandir = build.config.mandir.as_ref().clone().map(|x| Cow::Borrowed(Path::new(x)))\n+        .unwrap_or(Cow::Owned(prefix.join(\"share/man\")));\n+    let empty_dir = build.out.join(\"tmp/empty_dir\");\n+    t!(fs::create_dir_all(&empty_dir));\n+    if build.config.docs {\n+        install_sh(&build, \"docs\", \"rust-docs\", stage, host, prefix,\n+                   &docdir, &libdir, &mandir, &empty_dir);\n+    }\n+    install_sh(&build, \"std\", \"rust-std\", stage, host, prefix,\n+               &docdir, &libdir, &mandir, &empty_dir);\n+    install_sh(&build, \"rustc\", \"rustc\", stage, host, prefix,\n+               &docdir, &libdir, &mandir, &empty_dir);\n+    t!(fs::remove_dir_all(&empty_dir));\n+}\n+\n+fn install_sh(build: &Build, package: &str, name: &str, stage: u32, host: &str,\n+              prefix: &Path, docdir: &Path, libdir: &Path, mandir: &Path, empty_dir: &Path) {\n+    println!(\"Install {} stage{} ({})\", package, stage, host);\n+    let package_name = format!(\"{}-{}-{}\", name, package_vers(build), host);\n+\n+    let mut cmd = Command::new(\"sh\");\n+    cmd.current_dir(empty_dir)\n+       .arg(sanitize_sh(&tmpdir(build).join(&package_name).join(\"install.sh\")))\n+       .arg(format!(\"--prefix={}\", sanitize_sh(prefix)))\n+       .arg(format!(\"--docdir={}\", sanitize_sh(docdir)))\n+       .arg(format!(\"--libdir={}\", sanitize_sh(libdir)))\n+       .arg(format!(\"--mandir={}\", sanitize_sh(mandir)))\n+       .arg(\"--disable-ldconfig\");\n+    build.run(&mut cmd);\n+}"}, {"sha": "7c5a0c7373f8861765353f9820812d339ea5cde8", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 47, "deletions": 30, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -26,7 +26,6 @@ extern crate md5;\n extern crate num_cpus;\n extern crate rustc_serialize;\n extern crate toml;\n-extern crate regex;\n \n use std::collections::HashMap;\n use std::env;\n@@ -62,6 +61,7 @@ mod config;\n mod dist;\n mod doc;\n mod flags;\n+mod install;\n mod native;\n mod sanity;\n mod step;\n@@ -220,14 +220,14 @@ impl Build {\n         sanity::check(self);\n         self.verbose(\"collecting channel variables\");\n         channel::collect(self);\n-        // If local-rust is the same as the current version, then force a local-rebuild\n+        // If local-rust is the same major.minor as the current version, then force a local-rebuild\n         let local_version_verbose = output(\n             Command::new(&self.rustc).arg(\"--version\").arg(\"--verbose\"));\n         let local_release = local_version_verbose\n             .lines().filter(|x| x.starts_with(\"release:\"))\n             .next().unwrap().trim_left_matches(\"release:\").trim();\n-        if local_release == self.release {\n-            self.verbose(&format!(\"auto-detected local-rebuild {}\", self.release));\n+        if local_release.split('.').take(2).eq(self.release.split('.').take(2)) {\n+            self.verbose(&format!(\"auto-detected local-rebuild {}\", local_release));\n             self.local_rebuild = true;\n         }\n         self.verbose(\"updating submodules\");\n@@ -243,7 +243,14 @@ impl Build {\n         // Almost all of these are simple one-liners that shell out to the\n         // corresponding functionality in the extra modules, where more\n         // documentation can be found.\n-        for target in step::all(self) {\n+        let steps = step::all(self);\n+\n+        self.verbose(\"bootstrap build plan:\");\n+        for step in &steps {\n+            self.verbose(&format!(\"{:?}\", step));\n+        }\n+\n+        for target in steps {\n             let doc_out = self.out.join(&target.target).join(\"doc\");\n             match target.src {\n                 Llvm { _dummy } => {\n@@ -446,6 +453,8 @@ impl Build {\n                 DistStd { compiler } => dist::std(self, &compiler, target.target),\n                 DistSrc { _dummy } => dist::rust_src(self),\n \n+                Install { stage } => install::install(self, stage, target.target),\n+\n                 DebuggerScripts { stage } => {\n                     let compiler = Compiler::new(stage, target.target);\n                     dist::debugger_scripts(self,\n@@ -550,12 +559,23 @@ impl Build {\n                 continue\n             }\n \n+            // `submodule.path` is the relative path to a submodule (from the repository root)\n+            // `submodule_path` is the path to a submodule from the cwd\n+\n+            // use `submodule.path` when e.g. executing a submodule specific command from the\n+            // repository root\n+            // use `submodule_path` when e.g. executing a normal git command for the submodule\n+            // (set via `current_dir`)\n+            let submodule_path = self.src.join(submodule.path);\n+\n             match submodule.state {\n                 State::MaybeDirty => {\n                     // drop staged changes\n-                    self.run(git().arg(\"-C\").arg(submodule.path).args(&[\"reset\", \"--hard\"]));\n+                    self.run(git().current_dir(&submodule_path)\n+                                  .args(&[\"reset\", \"--hard\"]));\n                     // drops unstaged changes\n-                    self.run(git().arg(\"-C\").arg(submodule.path).args(&[\"clean\", \"-fdx\"]));\n+                    self.run(git().current_dir(&submodule_path)\n+                                  .args(&[\"clean\", \"-fdx\"]));\n                 },\n                 State::NotInitialized => {\n                     self.run(git_submodule().arg(\"init\").arg(submodule.path));\n@@ -564,8 +584,10 @@ impl Build {\n                 State::OutOfSync => {\n                     // drops submodule commits that weren't reported to the (outer) git repository\n                     self.run(git_submodule().arg(\"update\").arg(submodule.path));\n-                    self.run(git().arg(\"-C\").arg(submodule.path).args(&[\"reset\", \"--hard\"]));\n-                    self.run(git().arg(\"-C\").arg(submodule.path).args(&[\"clean\", \"-fdx\"]));\n+                    self.run(git().current_dir(&submodule_path)\n+                                  .args(&[\"reset\", \"--hard\"]));\n+                    self.run(git().current_dir(&submodule_path)\n+                                  .args(&[\"clean\", \"-fdx\"]));\n                 },\n             }\n         }\n@@ -627,6 +649,7 @@ impl Build {\n              .env(\"RUSTC_REAL\", self.compiler_path(compiler))\n              .env(\"RUSTC_STAGE\", stage.to_string())\n              .env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n+             .env(\"RUSTC_DEBUGINFO_LINES\", self.config.rust_debuginfo_lines.to_string())\n              .env(\"RUSTC_CODEGEN_UNITS\",\n                   self.config.rust_codegen_units.to_string())\n              .env(\"RUSTC_DEBUG_ASSERTIONS\",\n@@ -640,7 +663,7 @@ impl Build {\n              .env(\"RUSTDOC_REAL\", self.rustdoc(compiler))\n              .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n \n-        self.add_bootstrap_key(compiler, &mut cargo);\n+        self.add_bootstrap_key(&mut cargo);\n \n         // Specify some various options for build scripts used throughout\n         // the build.\n@@ -652,12 +675,6 @@ impl Build {\n                  .env(format!(\"CFLAGS_{}\", target), self.cflags(target).join(\" \"));\n         }\n \n-        // If we're building for OSX, inform the compiler and the linker that\n-        // we want to build a compiler runnable on 10.7\n-        if target.contains(\"apple-darwin\") {\n-            cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", \"10.7\");\n-        }\n-\n         // Environment variables *required* needed throughout the build\n         //\n         // FIXME: should update code to not require this env var\n@@ -855,16 +872,11 @@ impl Build {\n     }\n \n     /// Adds the compiler's bootstrap key to the environment of `cmd`.\n-    fn add_bootstrap_key(&self, compiler: &Compiler, cmd: &mut Command) {\n-        // In stage0 we're using a previously released stable compiler, so we\n-        // use the stage0 bootstrap key. Otherwise we use our own build's\n-        // bootstrap key.\n-        let bootstrap_key = if compiler.is_snapshot(self) && !self.local_rebuild {\n-            &self.bootstrap_key_stage0\n-        } else {\n-            &self.bootstrap_key\n-        };\n-        cmd.env(\"RUSTC_BOOTSTRAP_KEY\", bootstrap_key);\n+    fn add_bootstrap_key(&self, cmd: &mut Command) {\n+        cmd.env(\"RUSTC_BOOTSTRAP\", \"\");\n+        // FIXME: Transitionary measure to bootstrap using the old bootstrap logic.\n+        // Remove this once the bootstrap compiler uses the new login in Issue #36548.\n+        cmd.env(\"RUSTC_BOOTSTRAP_KEY\", \"62b3e239\");\n     }\n \n     /// Returns the compiler's libdir where it stores the dynamic libraries that\n@@ -926,7 +938,6 @@ impl Build {\n         // LLVM/jemalloc/etc are all properly compiled.\n         if target.contains(\"apple-darwin\") {\n             base.push(\"-stdlib=libc++\".into());\n-            base.push(\"-mmacosx-version-min=10.7\".into());\n         }\n         // This is a hack, because newer binutils broke things on some vms/distros\n         // (i.e., linking against unknown relocs disabled by the following flag)\n@@ -950,7 +961,11 @@ impl Build {\n     /// Returns the path to the C++ compiler for the target specified, may panic\n     /// if no C++ compiler was configured for the target.\n     fn cxx(&self, target: &str) -> &Path {\n-        self.cxx[target].path()\n+        match self.cxx.get(target) {\n+            Some(p) => p.path(),\n+            None => panic!(\"\\n\\ntarget `{}` is not configured as a host,\n+                            only as a target\\n\\n\", target),\n+        }\n     }\n \n     /// Returns flags to pass to the compiler to generate code for `target`.\n@@ -963,15 +978,17 @@ impl Build {\n         // than an entry here.\n \n         let mut base = Vec::new();\n-        if target != self.config.build && !target.contains(\"msvc\") {\n+        if target != self.config.build && !target.contains(\"msvc\") &&\n+            !target.contains(\"emscripten\") {\n             base.push(format!(\"-Clinker={}\", self.cc(target).display()));\n         }\n         return base\n     }\n \n     /// Returns the \"musl root\" for this `target`, if defined\n     fn musl_root(&self, target: &str) -> Option<&Path> {\n-        self.config.target_config[target].musl_root.as_ref()\n+        self.config.target_config.get(target)\n+            .and_then(|t| t.musl_root.as_ref())\n             .or(self.config.musl_root.as_ref())\n             .map(|p| &**p)\n     }"}, {"sha": "0762ed98472bed39eccec15d144b318788088228", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -51,6 +51,12 @@ check-cargotest:\n \t$(Q)$(BOOTSTRAP) --step check-cargotest\n dist:\n \t$(Q)$(BOOTSTRAP) --step dist\n+install:\n+ifeq (root user, $(USER) $(patsubst %,user,$(SUDO_USER)))\n+\t$(Q)echo \"'sudo make install' is not supported currently.\"\n+else\n+\t$(Q)$(BOOTSTRAP) --step install\n+endif\n tidy:\n \t$(Q)$(BOOTSTRAP) --step check-tidy --stage 0\n "}, {"sha": "1b4e86fb30f254c8cb2dd914501c2f55b9e7f2dd", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -18,9 +18,10 @@\n //! LLVM and compiler-rt are essentially just wired up to everything else to\n //! ensure that they're always in place if needed.\n \n+use std::fs::{self, File};\n+use std::io::{Read, Write};\n use std::path::Path;\n use std::process::Command;\n-use std::fs::{self, File};\n \n use build_helper::output;\n use cmake;\n@@ -43,11 +44,17 @@ pub fn llvm(build: &Build, target: &str) {\n     // artifacts are missing) then we keep going, otherwise we bail out.\n     let dst = build.llvm_out(target);\n     let stamp = build.src.join(\"src/rustllvm/llvm-auto-clean-trigger\");\n+    let mut stamp_contents = String::new();\n+    t!(t!(File::open(&stamp)).read_to_string(&mut stamp_contents));\n     let done_stamp = dst.join(\"llvm-finished-building\");\n-    build.clear_if_dirty(&dst, &stamp);\n-    if fs::metadata(&done_stamp).is_ok() {\n-        return\n+    if done_stamp.exists() {\n+        let mut done_contents = String::new();\n+        t!(t!(File::open(&done_stamp)).read_to_string(&mut done_contents));\n+        if done_contents == stamp_contents {\n+            return\n+        }\n     }\n+    drop(fs::remove_dir_all(&dst));\n \n     println!(\"Building LLVM for {}\", target);\n \n@@ -65,15 +72,17 @@ pub fn llvm(build: &Build, target: &str) {\n        .out_dir(&dst)\n        .profile(if build.config.llvm_optimize {\"Release\"} else {\"Debug\"})\n        .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n-       .define(\"LLVM_TARGETS_TO_BUILD\", \"X86;ARM;AArch64;Mips;PowerPC;SystemZ\")\n+       .define(\"LLVM_TARGETS_TO_BUILD\", \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend\")\n        .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")\n        .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n        .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")\n        .define(\"LLVM_ENABLE_ZLIB\", \"OFF\")\n        .define(\"WITH_POLLY\", \"OFF\")\n        .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n        .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n-       .define(\"LLVM_PARALLEL_COMPILE_JOBS\", build.jobs().to_string());\n+       .define(\"LLVM_PARALLEL_COMPILE_JOBS\", build.jobs().to_string())\n+       .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n+       .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n     if target.starts_with(\"i686\") {\n         cfg.define(\"LLVM_BUILD_32_BITS\", \"ON\");\n@@ -86,9 +95,7 @@ pub fn llvm(build: &Build, target: &str) {\n         //        actually exists most of the time in normal installs of LLVM.\n         let host = build.llvm_out(&build.config.build).join(\"bin/llvm-tblgen\");\n         cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\")\n-           .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n-           .define(\"LLVM_TABLEGEN\", &host)\n-           .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n+           .define(\"LLVM_TABLEGEN\", &host);\n     }\n \n     // MSVC handles compiler business itself\n@@ -114,7 +121,7 @@ pub fn llvm(build: &Build, target: &str) {\n     //        tools and libs on all platforms.\n     cfg.build();\n \n-    t!(File::create(&done_stamp));\n+    t!(t!(File::create(&done_stamp)).write_all(stamp_contents.as_bytes()));\n }\n \n fn check_llvm_version(build: &Build, llvm_config: &Path) {"}, {"sha": "969cd70fd57eb43e027d41580601398bd097afce", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -40,17 +40,23 @@ pub fn check(build: &mut Build) {\n             panic!(\"PATH contains invalid character '\\\"'\");\n         }\n     }\n-    let mut need_cmd = |cmd: &OsStr| {\n-        if !checked.insert(cmd.to_owned()) {\n-            return\n-        }\n+    let have_cmd = |cmd: &OsStr| {\n         for path in env::split_paths(&path).map(|p| p.join(cmd)) {\n             if fs::metadata(&path).is_ok() ||\n                fs::metadata(path.with_extension(\"exe\")).is_ok() {\n-                return\n+                return Some(path);\n             }\n         }\n-        panic!(\"\\n\\ncouldn't find required command: {:?}\\n\\n\", cmd);\n+        return None;\n+    };\n+\n+    let mut need_cmd = |cmd: &OsStr| {\n+        if !checked.insert(cmd.to_owned()) {\n+            return\n+        }\n+        if have_cmd(cmd).is_none() {\n+            panic!(\"\\n\\ncouldn't find required command: {:?}\\n\\n\", cmd);\n+        }\n     };\n \n     // If we've got a git directory we're gona need git to update\n@@ -75,15 +81,27 @@ pub fn check(build: &mut Build) {\n \n     need_cmd(\"python\".as_ref());\n \n-    // If a manual nodejs was added to the config,\n-    // of if a nodejs install is detected through config, use it.\n+    // Look for the nodejs command, needed for emscripten testing\n+    if let Some(node) = have_cmd(\"node\".as_ref()) {\n+        build.config.nodejs = Some(node);\n+    } else if let Some(node) = have_cmd(\"nodejs\".as_ref()) {\n+        build.config.nodejs = Some(node);\n+    }\n+\n     if let Some(ref s) = build.config.nodejs {\n         need_cmd(s.as_ref());\n     }\n \n     // We're gonna build some custom C code here and there, host triples\n     // also build some C++ shims for LLVM so we need a C++ compiler.\n     for target in build.config.target.iter() {\n+        // On emscripten we don't actually need the C compiler to just\n+        // build the target artifacts, only for testing. For the sake\n+        // of easier bot configuration, just skip detection.\n+        if target.contains(\"emscripten\") {\n+            continue;\n+        }\n+\n         need_cmd(build.cc(target).as_ref());\n         if let Some(ar) = build.ar(target) {\n             need_cmd(ar.as_ref());\n@@ -93,22 +111,21 @@ pub fn check(build: &mut Build) {\n         need_cmd(build.cxx(host).as_ref());\n     }\n \n+    // The msvc hosts don't use jemalloc, turn it off globally to\n+    // avoid packaging the dummy liballoc_jemalloc on that platform.\n+    for host in build.config.host.iter() {\n+        if host.contains(\"msvc\") {\n+            build.config.use_jemalloc = false;\n+        }\n+    }\n+\n     // Externally configured LLVM requires FileCheck to exist\n     let filecheck = build.llvm_filecheck(&build.config.build);\n     if !filecheck.starts_with(&build.out) && !filecheck.exists() && build.config.codegen_tests {\n         panic!(\"filecheck executable {:?} does not exist\", filecheck);\n     }\n \n     for target in build.config.target.iter() {\n-        // Either can't build or don't want to run jemalloc on these targets\n-        if target.contains(\"rumprun\") ||\n-           target.contains(\"bitrig\") ||\n-           target.contains(\"openbsd\") ||\n-           target.contains(\"msvc\") ||\n-           target.contains(\"emscripten\") {\n-            build.config.use_jemalloc = false;\n-        }\n-\n         // Can't compile for iOS unless we're on OSX\n         if target.contains(\"apple-ios\") &&\n            !build.config.build.contains(\"apple-darwin\") {\n@@ -129,8 +146,8 @@ pub fn check(build: &mut Build) {\n                     }\n                 }\n                 None => {\n-                    panic!(\"when targeting MUSL either the build.musl-root \\\n-                            option or the target.$TARGET.musl-root one must \\\n+                    panic!(\"when targeting MUSL either the rust.musl-root \\\n+                            option or the target.$TARGET.musl-root option must \\\n                             be specified in config.toml\")\n                 }\n             }"}, {"sha": "3bf0f2119214786087662055e1af09a5f08717f9", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -140,6 +140,9 @@ macro_rules! targets {\n             (dist_std, DistStd { compiler: Compiler<'a> }),\n             (dist_src, DistSrc { _dummy: () }),\n \n+            // install target\n+            (install, Install { stage: u32 }),\n+\n             // Misc targets\n             (android_copy_libs, AndroidCopyLibs { compiler: Compiler<'a> }),\n         }\n@@ -171,6 +174,8 @@ targets!(define_source);\n /// into a topologically sorted list which when executed left-to-right will\n /// correctly sequence the entire build.\n pub fn all(build: &Build) -> Vec<Step> {\n+    build.verbose(\"inferred build steps:\");\n+\n     let mut ret = Vec::new();\n     let mut all = HashSet::new();\n     for target in top_level(build) {\n@@ -184,6 +189,7 @@ pub fn all(build: &Build) -> Vec<Step> {\n                 set: &mut HashSet<Step<'a>>) {\n         if set.insert(target.clone()) {\n             for dep in target.deps(build) {\n+                build.verbose(&format!(\"{:?}\\n  -> {:?}\", target, dep));\n                 fill(build, &dep, ret, set);\n             }\n             ret.push(target.clone());\n@@ -246,8 +252,7 @@ fn top_level(build: &Build) -> Vec<Step> {\n         }\n     }\n \n-    return targets\n-\n+    targets\n }\n \n fn add_steps<'a>(build: &'a Build,\n@@ -415,7 +420,6 @@ impl<'a> Step<'a> {\n                     self.check_crate_std(compiler),\n                     self.check_crate_test(compiler),\n                     self.check_debuginfo(compiler),\n-                    self.dist(stage),\n                 ];\n \n                 // If we're testing the build triple, then we know we can\n@@ -460,9 +464,12 @@ impl<'a> Step<'a> {\n                         // misc\n                         self.check_linkcheck(stage),\n                         self.check_tidy(stage),\n+\n+                        // can we make the distributables?\n+                        self.dist(stage),\n                     ]);\n                 }\n-                return base\n+                base\n             }\n             Source::CheckLinkcheck { stage } => {\n                 vec![self.tool_linkchecker(stage), self.doc(stage)]\n@@ -483,7 +490,6 @@ impl<'a> Step<'a> {\n             Source::CheckCodegenUnits { compiler } |\n             Source::CheckIncremental { compiler } |\n             Source::CheckUi { compiler } |\n-            Source::CheckRustdoc { compiler } |\n             Source::CheckPretty { compiler } |\n             Source::CheckCFail { compiler } |\n             Source::CheckRPassValgrind { compiler } |\n@@ -506,6 +512,7 @@ impl<'a> Step<'a> {\n                     self.debugger_scripts(compiler.stage),\n                 ]\n             }\n+            Source::CheckRustdoc { compiler } |\n             Source::CheckRPassFull { compiler } |\n             Source::CheckRFailFull { compiler } |\n             Source::CheckCFailFull { compiler } |\n@@ -517,7 +524,7 @@ impl<'a> Step<'a> {\n                      self.target(compiler.host).tool_compiletest(compiler.stage)]\n             }\n             Source::CheckDocs { compiler } => {\n-                vec![self.libstd(compiler)]\n+                vec![self.libtest(compiler)]\n             }\n             Source::CheckErrorIndex { compiler } => {\n                 vec![self.libstd(compiler),\n@@ -585,7 +592,11 @@ impl<'a> Step<'a> {\n                         base.push(target.dist_std(compiler));\n                     }\n                 }\n-                return base\n+                base\n+            }\n+\n+            Source::Install { stage } => {\n+                vec![self.dist(stage)]\n             }\n \n             Source::AndroidCopyLibs { compiler } => {"}, {"sha": "38844fb6c9ef0748c100a1756e72191b6c42d1e2", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -25,7 +25,9 @@ pub fn run_silent(cmd: &mut Command) {\n     };\n     if !status.success() {\n         fail(&format!(\"command did not execute successfully: {:?}\\n\\\n-                       expected success, got: {}\", cmd, status));\n+                       expected success, got: {}\",\n+                      cmd,\n+                      status));\n     }\n }\n \n@@ -65,7 +67,9 @@ pub fn output(cmd: &mut Command) -> String {\n     };\n     if !output.status.success() {\n         panic!(\"command did not execute successfully: {:?}\\n\\\n-                expected success, got: {}\", cmd, output.status);\n+                expected success, got: {}\",\n+               cmd,\n+               output.status);\n     }\n     String::from_utf8(output.stdout).unwrap()\n }"}, {"sha": "f03ba5a4e8bf16dcf42dd742a4ce255c36321356", "filename": "src/compiler-rt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiler-rt?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -1 +1 @@\n-Subproject commit 8598065bd965d9713bfafb6c1e766d63a7b17b89\n+Subproject commit f03ba5a4e8bf16dcf42dd742a4ce255c36321356"}, {"sha": "41d8345b720949a68339ad847b37c7e9ad2b57fa", "filename": "src/doc/book/concurrency.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fconcurrency.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -4,7 +4,7 @@ Concurrency and parallelism are incredibly important topics in computer\n science, and are also a hot topic in industry today. Computers are gaining more\n and more cores, yet many programmers aren't prepared to fully utilize them.\n \n-Rust's memory safety features also apply to its concurrency story too. Even\n+Rust's memory safety features also apply to its concurrency story. Even\n concurrent Rust programs must be memory safe, having no data races. Rust's type\n system is up to the task, and gives you powerful ways to reason about\n concurrent code at compile time.\n@@ -281,8 +281,8 @@ And... still gives us an error.\n ```\n \n `Arc<T>` by default has immutable contents. It allows the _sharing_ of data\n-between threads, but shared mutable data is unsafe and when threads are\n-involved can cause data races!\n+between threads, but shared mutable data is unsafe\u2014and when threads are\n+involved\u2014can cause data races!\n \n \n Usually when we wish to make something in an immutable position mutable, we use"}, {"sha": "e8f17a41cbeabf30c9b1862aa7daa281ff6a8d33", "filename": "src/doc/book/const-and-static.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fconst-and-static.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fconst-and-static.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fconst-and-static.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -1,4 +1,4 @@\n-% `const` and `static`\n+% const and static\n \n Rust has a way of defining constants with the `const` keyword:\n "}, {"sha": "cabe66f5b2282a8467f7151e95372ff6c607f825", "filename": "src/doc/book/deref-coercions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fderef-coercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fderef-coercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fderef-coercions.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -69,7 +69,7 @@ foo(&counted);\n All we\u2019ve done is wrap our `String` in an `Rc<T>`. But we can now pass the\n `Rc<String>` around anywhere we\u2019d have a `String`. The signature of `foo`\n didn\u2019t change, but works just as well with either type. This example has two\n-conversions: `Rc<String>` to `String` and then `String` to `&str`. Rust will do\n+conversions: `&Rc<String>` to `&String` and then `&String` to `&str`. Rust will do\n this as many times as possible until the types match.\n \n Another very common implementation provided by the standard library is:"}, {"sha": "5add2359282729d132f420aa3777f948994d21a6", "filename": "src/doc/book/getting-started.md", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgetting-started.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -166,12 +166,22 @@ you can find the Rust executables in a directory like\n `\"C:\\Program Files\\Rust stable GNU 1.x\\bin\"`.\n \n Rust does not do its own linking, and so you\u2019ll need to have a linker\n-installed. Doing so will depend on your specific system, consult its\n-documentation for more details.\n-\n-If not, there are a number of places where we can get help. The easiest is\n-[the #rust-beginners IRC channel on irc.mozilla.org][irc-beginners] and for\n-general discussion [the #rust IRC channel on irc.mozilla.org][irc], which we\n+installed. Doing so will depend on your specific system. For\n+Linux-based systems, Rust will attempt to call `cc` for linking. On\n+`windows-msvc` (Rust built on Windows with Microsoft Visual Studio),\n+this depends on having [Microsoft Visual C++ Build Tools][msvbt]\n+installed. These do not need to be in `%PATH%` as `rustc` will find\n+them automatically. In general, if you have your linker in a\n+non-traditional location you can call `rustc \n+linker=/path/to/cc`, where `/path/to/cc` should point to your linker path.\n+\n+[msvbt]: http://landinghub.visualstudio.com/visual-cpp-build-tools\n+\n+If you are still stuck, there are a number of places where we can get\n+help. The easiest is\n+[the #rust-beginners IRC channel on irc.mozilla.org][irc-beginners] \n+and for general discussion\n+[the #rust IRC channel on irc.mozilla.org][irc], which we \n can access through [Mibbit][mibbit]. Then we'll be chatting with other\n Rustaceans (a silly nickname we call ourselves) who can help us out. Other great\n resources include [the user\u2019s forum][users] and [Stack Overflow][stackoverflow].\n@@ -230,12 +240,13 @@ $ cd hello_world\n \n ## Writing and Running a Rust Program\n \n-Next, make a new source file and call it *main.rs*. Rust files always end\n-in a *.rs* extension. If you\u2019re using more than one word in your filename, use\n-an underscore to separate them; for example, you'd use *hello_world.rs* rather\n-than *helloworld.rs*.\n+We need to create a source file for our Rust program. Rust files always end\n+in a *.rs* extension. If you are using more than one word in your filename,\n+use an underscore to separate them; for example, you would use\n+*my_program.rs* rather than *myprogram.rs*.\n \n-Now open the *main.rs* file you just created, and type the following code:\n+Now, make a new file and call it *main.rs*. Open the file and type\n+the following code:\n \n ```rust\n fn main() {\n@@ -494,6 +505,9 @@ $ cargo run\n Hello, world!\n ```\n \n+The `run` command comes in handy when you need to rapidly iterate on a\n+project.\n+\n Notice that this example didn\u2019t re-build the project. Cargo figured out that\n the file hasn\u2019t changed, and so it just ran the binary. If you'd modified your\n source code, Cargo would have rebuilt the project before running it, and you"}, {"sha": "4e0e3728689417968fc87cdddcd035dc5dee9030", "filename": "src/doc/book/guessing-game.md", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fguessing-game.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -56,9 +56,7 @@ $ cargo build\n Excellent! Open up your `src/main.rs` again. We\u2019ll be writing all of\n our code in this file.\n \n-Before we move on, let me show you one more Cargo command: `run`. `cargo run`\n-is kind of like `cargo build`, but it also then runs the produced executable.\n-Try it out:\n+Remember the `run` command from last chapter? Try it out again here:\n \n ```bash\n $ cargo run\n@@ -67,9 +65,8 @@ $ cargo run\n Hello, world!\n ```\n \n-Great! The `run` command comes in handy when you need to rapidly iterate on a\n-project. Our game is such a project, we need to quickly test each\n-iteration before moving on to the next one.\n+Great! Our game is just the kind of project `run` is good for: we need\n+to quickly test each iteration before moving on to the next one.\n \n # Processing a Guess\n \n@@ -279,7 +276,7 @@ displaying the message.\n [expect]: ../std/result/enum.Result.html#method.expect\n [panic]: error-handling.html\n \n-If we leave off calling this method, our program will compile, but\n+If we do not call `expect()`, our program will compile, but\n we\u2019ll get a warning:\n \n ```bash"}, {"sha": "df1ee5a293c9d6b8e2638ff8c8394c2a6a286ed6", "filename": "src/doc/book/lifetimes.md", "status": "modified", "additions": 79, "deletions": 13, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flifetimes.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -50,29 +50,94 @@ complicated. For example, imagine this set of operations:\n 4. You decide to use the resource.\n \n Uh oh! Your reference is pointing to an invalid resource. This is called a\n-dangling pointer or \u2018use after free\u2019, when the resource is memory.\n+dangling pointer or \u2018use after free\u2019, when the resource is memory. A small\n+example of such a situation would be:\n+\n+```rust,compile_fail\n+let r;              // Introduce reference: r\n+{\n+    let i = 1;      // Introduce scoped value: i\n+    r = &i;         // Store reference of i in r\n+}                   // i goes out of scope and is dropped.\n+\n+println!(\"{}\", r);  // r still refers to i\n+```\n \n To fix this, we have to make sure that step four never happens after step\n-three. The ownership system in Rust does this through a concept called\n-lifetimes, which describe the scope that a reference is valid for.\n+three. In the small example above the Rust compiler is able to report the issue\n+as it can see the lifetimes of the various values in the function.\n \n-When we have a function that takes an argument by reference, we can be\n-implicit or explicit about the lifetime of the reference:\n+When we have a function that takes arguments by reference the situation becomes\n+more complex. Consider the following example:\n \n-```rust\n-// implicit\n-fn foo(x: &i32) {\n+```rust,compile_fail,E0106\n+fn skip_prefix(line: &str, prefix: &str) -> &str {\n+    // ...\n+#   line\n }\n \n-// explicit\n-fn bar<'a>(x: &'a i32) {\n+let line = \"lang:en=Hello World!\";\n+let lang = \"en\";\n+\n+let v;\n+{\n+    let p = format!(\"lang:{}=\", lang);  // -+ p goes into scope\n+    v = skip_prefix(line, p.as_str());  //  |\n+}                                       // -+ p goes out of scope\n+println!(\"{}\", v);\n+```\n+\n+Here we have a function `skip_prefix` which takes two `&str` references\n+as parameters and returns a single `&str` reference. We call it\n+by passing in references to `line` and `p`: Two variables with different\n+lifetimes. Now the safety of the `println!`-line depends on whether the\n+reference returned by `skip_prefix` function references the still living\n+`line` or the already dropped `p` string.\n+\n+Because of the above ambiguity, Rust will refuse to compile the example\n+code. To get it to compile we need to tell the compiler more about the\n+lifetimes of the references. This can be done by making the lifetimes\n+explicit in the function declaration:\n+\n+```rust\n+fn skip_prefix<'a, 'b>(line: &'a str, prefix: &'b str) -> &'a str {\n+    // ...\n+#   line\n }\n ```\n \n+Let's examine the changes without going too deep into the syntax for now -\n+we'll get to that later. The first change was adding the `<'a, 'b>` after the\n+method name. This introduces two lifetime parameters: `'a` and `'b`. Next each\n+reference in the function signature was associated with one of the lifetime\n+parameters by adding the lifetime name after the `&`. This tells the compiler\n+how the lifetimes between different references are related.\n+\n+As a result the compiler is now able to deduce that the return value of\n+`skip_prefix` has the same lifetime as the `line` parameter, which makes the `v`\n+reference safe to use even after the `p` goes out of scope in the original\n+example.\n+\n+In addition to the compiler being able to validate the usage of `skip_prefix`\n+return value, it can also ensure that the implementation follows the contract\n+established by the function declaration. This is useful especially when you are\n+implementing traits that are introduced [later in the book][traits].\n+\n+**Note** It's important to understand that lifetime annotations are\n+_descriptive_, not _prescriptive_. This means that how long a reference is valid\n+is determined by the code, not by the annotations. The annotations, however,\n+give information about lifetimes to the compiler that uses them to check the\n+validity of references. The compiler can do so without annotations in simple\n+cases, but needs the programmers support in complex scenarios.\n+\n+[traits]: traits.html\n+\n+# Syntax\n+\n The `'a` reads \u2018the lifetime a\u2019. Technically, every reference has some lifetime\n associated with it, but the compiler lets you elide (i.e. omit, see\n-[\"Lifetime Elision\"][lifetime-elision] below) them in common cases.\n-Before we get to that, though, let\u2019s break the explicit example down:\n+[\"Lifetime Elision\"][lifetime-elision] below) them in common cases. Before we\n+get to that, though, let\u2019s look at a short example with explicit lifetimes:\n \n [lifetime-elision]: #lifetime-elision\n \n@@ -90,7 +155,8 @@ focus on the lifetimes aspect.\n [generics]: generics.html\n \n We use `<>` to declare our lifetimes. This says that `bar` has one lifetime,\n-`'a`. If we had two reference parameters, it would look like this:\n+`'a`. If we had two reference parameters with different lifetimes, it would\n+look like this:\n \n \n ```rust,ignore"}, {"sha": "a711397b211dbd5d1ea7c2ea1c214e185d244909", "filename": "src/doc/book/ownership.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fownership.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -57,13 +57,13 @@ of scope at the end of `foo()`, Rust will clean up everything related to the\n vector, even the heap-allocated memory. This happens deterministically, at the\n end of the scope.\n \n-We'll cover [vectors] in detail later in this chapter; we only use them\n+We covered [vectors] in the previous chapter; we use them\n here as an example of a type that allocates space on the heap at runtime. They\n behave like [arrays], except their size may change by `push()`ing more\n elements onto them.\n \n Vectors have a [generic type][generics] `Vec<T>`, so in this example `v` will have type\n-`Vec<i32>`. We'll cover generics in detail later in this chapter.\n+`Vec<i32>`. We'll cover [generics] in detail in a later chapter.\n \n [arrays]: primitive-types.html#arrays\n [vectors]: vectors.html"}, {"sha": "1e2f061b06745484e11f70c522e36eae44ae5df3", "filename": "src/doc/book/references-and-borrowing.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -86,7 +86,7 @@ fn main() {\n         return v.iter().fold(0, |a, &b| a + b);\n     }\n     // Borrow two vectors and sum them.\n-    // This kind of borrowing does not allow mutation to the borrowed.\n+    // This kind of borrowing does not allow mutation through the borrowed reference.\n     fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n         // do stuff with v1 and v2\n         let s1 = sum_vec(v1);\n@@ -240,7 +240,7 @@ fn main() {\n \n In other words, the mutable borrow is held through the rest of our example. What\n we want is for the mutable borrow by `y` to end so that the resource can be\n-returned to the owner, `x`. `x` can then provide a immutable borrow to `println!`.\n+returned to the owner, `x`. `x` can then provide an immutable borrow to `println!`.\n In Rust, borrowing is tied to the scope that the borrow is valid for. And our\n scopes look like this:\n "}, {"sha": "1e05b01d30d46531843a8b1a3cd45767f0013772", "filename": "src/doc/book/syntax-index.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsyntax-index.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -61,7 +61,6 @@\n * `-` (`- expr`): arithmetic negation.  Overloadable (`Neg`).\n * `-=` (`var -= expr`): arithmetic subtraction & assignment. Overloadable (`SubAssign`).\n * `->` (`fn(\u2026) -> type`, `|\u2026| -> type`): function and closure return type.  See [Functions], [Closures].\n-* `-> !` (`fn(\u2026) -> !`, `|\u2026| -> !`): diverging function or closure. See [Diverging Functions].\n * `.` (`expr.ident`): member access.  See [Structs], [Method Syntax].\n * `..` (`..`, `expr..`, `..expr`, `expr..expr`): right-exclusive range literal.\n * `..` (`..expr`): struct literal update syntax.  See [Structs (Update syntax)].\n@@ -159,6 +158,10 @@\n * `/*!\u2026*/`: inner block doc comment.  See [Comments].\n * `/**\u2026*/`: outer block doc comment.  See [Comments].\n \n+<!-- Special types -->\n+\n+* `!`: always empty Never type.  See [Diverging Functions].\n+\n <!-- Various things involving parens and tuples -->\n \n * `()`: empty tuple (*a.k.a.* unit), both literal and type."}, {"sha": "3bdf1b7b7f2291aff05b316900e934c042332130", "filename": "src/doc/book/testing.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftesting.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -380,9 +380,9 @@ the `tests` directory.\n \n # The `tests` directory\n \n-Each file in `tests/*.rs` directory is treated as individual crate.\n-So, to write an integration test, let's make a `tests` directory, and\n-put a `tests/integration_test.rs` file inside, with this as its contents:\n+Each file in `tests/*.rs` directory is treated as an individual crate.\n+To write an integration test, let's make a `tests` directory and\n+put a `tests/integration_test.rs` file inside with this as its contents:\n \n ```rust,ignore\n extern crate adder;"}, {"sha": "b0d954adf6771c9bacd8d3877d5dd57ef4abcd34", "filename": "src/doc/book/traits.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftraits.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -291,7 +291,7 @@ let result = f.write(buf);\n \n We need to `use` the `Write` trait first:\n \n-```rust,ignore\n+```rust,no_run\n use std::io::Write;\n \n let mut f = std::fs::File::create(\"foo.txt\").expect(\"Couldn\u2019t create foo.txt\");"}, {"sha": "3798336f0a52419c579cf8f9c1c2b8e191c27a0b", "filename": "src/doc/book/type-aliases.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Ftype-aliases.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Ftype-aliases.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftype-aliases.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -1,4 +1,4 @@\n-% `type` Aliases\n+% Type Aliases\n \n The `type` keyword lets you declare an alias of another type:\n "}, {"sha": "03f17371de68d8aea04f76fe43fdd632e7b9bb07", "filename": "src/doc/book/variable-bindings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fvariable-bindings.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -161,7 +161,7 @@ Could not compile `hello_world`.\n \n Rust will not let us use a value that has not been initialized.\n \n-Let take a minute to talk about this stuff we've added to `println!`.\n+Let us take a minute to talk about this stuff we've added to `println!`.\n \n If you include two curly braces (`{}`, some call them moustaches...) in your\n string to print, Rust will interpret this as a request to interpolate some sort"}, {"sha": "77e151235e822d4281d365d6908d13bf8073a231", "filename": "src/doc/footer.inc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Ffooter.inc", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Ffooter.inc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ffooter.inc?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -5,4 +5,3 @@ or the <a href=\"https://opensource.org/licenses/MIT\">MIT license</a>, at your op\n </p><p>\n This file may not be copied, modified, or distributed except according to those terms.\n </p></footer>\n-<script type=\"text/javascript\" src=\"playpen.js\"></script>"}, {"sha": "690d44cc2cb7bc1585624121a5f99724df337957", "filename": "src/doc/grammar.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -764,6 +764,13 @@ bound-list := bound | bound '+' bound-list\n bound := path | lifetime\n ```\n \n+### Never type\n+An empty type\n+\n+```antlr\n+never_type : \"!\" ;\n+```\n+\n ### Object types\n \n **FIXME:** grammar?"}, {"sha": "4838ecd2d42e62108b156dd760d9c8eb19b9942e", "filename": "src/doc/reference.md", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -2472,8 +2472,7 @@ The currently implemented features of the reference compiler are:\n * - `default_type_parameter_fallback` - Allows type parameter defaults to\n                                         influence type inference.\n \n-* - `stmt_expr_attributes` - Allows attributes on expressions and\n-                             non-item statements.\n+* - `stmt_expr_attributes` - Allows attributes on expressions.\n \n * - `type_ascription` - Allows type ascription expressions `expr: Type`.\n \n@@ -3110,10 +3109,12 @@ the lambda expression captures its environment by reference, effectively\n borrowing pointers to all outer variables mentioned inside the function.\n Alternately, the compiler may infer that a lambda expression should copy or\n move values (depending on their type) from the environment into the lambda\n-expression's captured environment.\n+expression's captured environment. A lambda can be forced to capture its\n+environment by moving values by prefixing it with the `move` keyword.\n \n In this example, we define a function `ten_times` that takes a higher-order\n-function argument, and we then call it with a lambda expression as an argument:\n+function argument, and we then call it with a lambda expression as an argument,\n+followed by a lambda expression that moves values from its environment.\n \n ```\n fn ten_times<F>(f: F) where F: Fn(i32) {\n@@ -3123,6 +3124,9 @@ fn ten_times<F>(f: F) where F: Fn(i32) {\n }\n \n ten_times(|j| println!(\"hello, {}\", j));\n+\n+let word = \"konnichiwa\".to_owned();\n+ten_times(move |j| println!(\"{}, {}\", word, j));\n ```\n \n ### Infinite loops\n@@ -3959,6 +3963,16 @@ the top-level type for the implementation of the called method. If no such metho\n found, `.deref()` is called and the compiler continues to search for the method\n implementation in the returned type `U`.\n \n+## The `Send` trait\n+\n+The `Send` trait indicates that a value of this type is safe to send from one\n+thread to another.\n+\n+## The `Sync` trait\n+\n+The `Sync` trait indicates that a value of this type is safe to share between\n+multiple threads.\n+\n # Memory model\n \n A Rust program's memory consists of a static set of *items* and a *heap*.\n@@ -4009,9 +4023,9 @@ Methods that take either `self` or `Box<Self>` can optionally place them in a\n mutable variable by prefixing them with `mut` (similar to regular arguments):\n \n ```\n-trait Changer {\n-    fn change(mut self) -> Self;\n-    fn modify(mut self: Box<Self>) -> Box<Self>;\n+trait Changer: Sized {\n+    fn change(mut self) {}\n+    fn modify(mut self: Box<Self>) {}\n }\n ```\n \n@@ -4064,6 +4078,12 @@ be ignored in favor of only building the artifacts specified by command line.\n   Rust code into an existing non-Rust application because it will not have\n   dynamic dependencies on other Rust code.\n \n+* `--crate-type=cdylib`, `#[crate_type = \"cdylib\"]` - A dynamic system\n+  library will be produced.  This is used when compiling Rust code as\n+  a dynamic library to be loaded from another language.  This output type will\n+  create `*.so` files on Linux, `*.dylib` files on OSX, and `*.dll` files on\n+  Windows.\n+\n * `--crate-type=rlib`, `#[crate_type = \"rlib\"]` - A \"Rust library\" file will be\n   produced. This is used as an intermediate artifact and can be thought of as a\n   \"static Rust library\". These `rlib` files, unlike `staticlib` files, are"}, {"sha": "932594b99126df489783fc68eb306bf29ed70bbe", "filename": "src/doc/rust.css", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -159,7 +159,7 @@ em {\n \n footer {\n     border-top: 1px solid #ddd;\n-    font-size: 14.3px;\n+    font-size: 14px;\n     font-style: italic;\n     padding-top: 5px;\n     margin-top: 3em;\n@@ -336,20 +336,22 @@ table th {\n \n /* Code snippets */\n \n-.rusttest { display: none; }\n pre.rust { position: relative; }\n a.test-arrow {\n+    background-color: rgba(78, 139, 202, 0.2);\n     display: inline-block;\n     position: absolute;\n-\n-    background-color: #4e8bca;\n     color: #f5f5f5;\n     padding: 5px 10px 5px 10px;\n     border-radius: 5px;\n     font-size: 130%;\n     top: 5px;\n     right: 5px;\n }\n+a.test-arrow:hover{\n+    background-color: #4e8bca;\n+    text-decoration: none;\n+}\n \n .unstable-feature {\n     border: 2px solid red;"}, {"sha": "eb562877c85732702a0d449808f67f4d463fd030", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -328,7 +328,7 @@ def extract_length_and_ptr_from_slice(slice_val):\n UNQUALIFIED_TYPE_MARKERS = frozenset([\"(\", \"[\", \"&\", \"*\"])\n \n def extract_type_name(qualified_type_name):\n-    '''Extracts the type name from a fully qualified path'''\n+    \"\"\"Extracts the type name from a fully qualified path\"\"\"\n     if qualified_type_name[0] in UNQUALIFIED_TYPE_MARKERS:\n         return qualified_type_name\n "}, {"sha": "afac8d6bbaefcdc4d33984e22fa91210e89a37ee", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -170,7 +170,7 @@ def rust_pretty_printer_lookup_function(gdb_val):\n #=------------------------------------------------------------------------------\n # Pretty Printer Classes\n #=------------------------------------------------------------------------------\n-class RustStructPrinter:\n+class RustStructPrinter(object):\n     def __init__(self, val, omit_first_field, omit_type_name, is_tuple_like):\n         self.__val = val\n         self.__omit_first_field = omit_first_field\n@@ -205,11 +205,12 @@ def display_hint(self):\n             return \"\"\n \n \n-class RustSlicePrinter:\n+class RustSlicePrinter(object):\n     def __init__(self, val):\n         self.__val = val\n \n-    def display_hint(self):\n+    @staticmethod\n+    def display_hint():\n         return \"array\"\n \n     def to_string(self):\n@@ -226,7 +227,7 @@ def children(self):\n             yield (str(index), (raw_ptr + index).dereference())\n \n \n-class RustStringSlicePrinter:\n+class RustStringSlicePrinter(object):\n     def __init__(self, val):\n         self.__val = val\n \n@@ -236,11 +237,12 @@ def to_string(self):\n         return '\"%s\"' % raw_ptr.string(encoding=\"utf-8\", length=length)\n \n \n-class RustStdVecPrinter:\n+class RustStdVecPrinter(object):\n     def __init__(self, val):\n         self.__val = val\n \n-    def display_hint(self):\n+    @staticmethod\n+    def display_hint():\n         return \"array\"\n \n     def to_string(self):\n@@ -255,7 +257,7 @@ def children(self):\n             yield (str(index), (gdb_ptr + index).dereference())\n \n \n-class RustStdStringPrinter:\n+class RustStdStringPrinter(object):\n     def __init__(self, val):\n         self.__val = val\n \n@@ -266,7 +268,7 @@ def to_string(self):\n                                                             length=length)\n \n \n-class RustCStyleVariantPrinter:\n+class RustCStyleVariantPrinter(object):\n     def __init__(self, val):\n         assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_ENUM\n         self.__val = val\n@@ -275,7 +277,7 @@ def to_string(self):\n         return str(self.__val.get_wrapped_value())\n \n \n-class IdentityPrinter:\n+class IdentityPrinter(object):\n     def __init__(self, string):\n         self.string = string\n "}, {"sha": "4952cf4f82c3b22c026200f20a5b83d3aad94c7d", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -37,14 +37,14 @@\n \n \n def print_debug(s):\n-    \"Print something if DEBUG_OUTPUT is True\"\n+    \"\"\"Print something if DEBUG_OUTPUT is True\"\"\"\n     global DEBUG_OUTPUT\n     if DEBUG_OUTPUT:\n         print(\"DEBUG: \" + str(s))\n \n \n def normalize_whitespace(s):\n-    \"Replace newlines, tabs, multiple spaces, etc with exactly one space\"\n+    \"\"\"Replace newlines, tabs, multiple spaces, etc with exactly one space\"\"\"\n     return re.sub(\"\\s+\", \" \", s)\n \n \n@@ -71,7 +71,7 @@ def breakpoint_callback(frame, bp_loc, dict):\n \n \n def execute_command(command_interpreter, command):\n-    \"Executes a single CLI command\"\n+    \"\"\"Executes a single CLI command\"\"\"\n     global new_breakpoints\n     global registered_breakpoints\n "}, {"sha": "335acae5fb6f7df5817da3b5a14b6bfb4f539f4e", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -171,10 +171,10 @@ def print_val(lldb_val, internal_dict):\n #=--------------------------------------------------------------------------------------------------\n \n def print_struct_val(val, internal_dict, omit_first_field, omit_type_name, is_tuple_like):\n-    '''\n+    \"\"\"\n     Prints a struct, tuple, or tuple struct value with Rust syntax.\n     Ignores any fields before field_start_index.\n-    '''\n+    \"\"\"\n     assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_STRUCT\n \n     if omit_type_name:\n@@ -221,7 +221,7 @@ def render_child(child_index):\n                        \"body\": body}\n \n def print_pointer_val(val, internal_dict):\n-    '''Prints a pointer value with Rust syntax'''\n+    \"\"\"Prints a pointer value with Rust syntax\"\"\"\n     assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n     sigil = \"&\"\n     type_name = val.type.get_unqualified_type_name()\n@@ -275,8 +275,8 @@ def print_std_string_val(val, internal_dict):\n #=--------------------------------------------------------------------------------------------------\n \n def print_array_of_values(array_name, data_ptr_val, length, internal_dict):\n-    '''Prints a contigous memory range, interpreting it as values of the\n-       pointee-type of data_ptr_val.'''\n+    \"\"\"Prints a contigous memory range, interpreting it as values of the\n+       pointee-type of data_ptr_val.\"\"\"\n \n     data_ptr_type = data_ptr_val.type\n     assert data_ptr_type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR"}, {"sha": "ee77206640eab2a70bc8f6f086a9fe1b76ef95db", "filename": "src/etc/local_stage0.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Flocal_stage0.sh", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Flocal_stage0.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flocal_stage0.sh?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -18,7 +18,7 @@ LIB_PREFIX=lib\n \n OS=`uname -s`\n case $OS in\n-    (\"Linux\"|\"FreeBSD\"|\"DragonFly\"|\"Bitrig\"|\"OpenBSD\"|\"SunOS\")\n+    (\"Linux\"|\"FreeBSD\"|\"DragonFly\"|\"Bitrig\"|\"OpenBSD\"|\"SunOS\"|\"Haiku\")\n     BIN_SUF=\n     LIB_SUF=.so\n     ;;\n@@ -71,6 +71,7 @@ cp ${PREFIX}/${LIB_DIR}/${LIB_PREFIX}log*${LIB_SUF} ${TARG_DIR}/stage0/${LIB_DIR\n cp ${PREFIX}/${LIB_DIR}/${LIB_PREFIX}rbml*${LIB_SUF} ${TARG_DIR}/stage0/${LIB_DIR}/\n cp ${PREFIX}/${LIB_DIR}/${LIB_PREFIX}serialize*${LIB_SUF} ${TARG_DIR}/stage0/${LIB_DIR}/\n cp ${PREFIX}/${LIB_DIR}/${LIB_PREFIX}term*${LIB_SUF} ${TARG_DIR}/stage0/${LIB_DIR}/\n+cp ${PREFIX}/${LIB_DIR}/${LIB_PREFIX}proc_macro*${LIB_SUF} ${TARG_DIR}/stage0/${LIB_DIR}/\n \n # do not fail if one of the above fails, as all we need is a working rustc!\n exit 0"}, {"sha": "e3c08bb35e075cf9b4de507728884fb8504952f4", "filename": "src/etc/platform-intrinsics/generator.py", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -119,16 +119,19 @@ class Void(Type):\n     def __init__(self):\n         Type.__init__(self, 0)\n \n-    def compiler_ctor(self):\n+    @staticmethod\n+    def compiler_ctor():\n         return '::VOID'\n \n     def compiler_ctor_ref(self):\n         return '&' + self.compiler_ctor()\n \n-    def rust_name(self):\n+    @staticmethod\n+    def rust_name():\n         return '()'\n \n-    def type_info(self, platform_info):\n+    @staticmethod\n+    def type_info(platform_info):\n         return None\n \n     def __eq__(self, other):\n@@ -282,7 +285,7 @@ def __eq__(self, other):\n \n class Pointer(Type):\n     def __init__(self, elem, llvm_elem, const):\n-        self._elem = elem;\n+        self._elem = elem\n         self._llvm_elem = llvm_elem\n         self._const = const\n         Type.__init__(self, BITWIDTH_POINTER)\n@@ -503,7 +506,7 @@ def monomorphise(self):\n             # must be a power of two\n             assert width & (width - 1) == 0\n             def recur(processed, untouched):\n-                if untouched == []:\n+                if not untouched:\n                     ret = processed[0]\n                     args = processed[1:]\n                     yield MonomorphicIntrinsic(self._platform, self.intrinsic, width,\n@@ -756,22 +759,26 @@ class ExternBlock(object):\n     def __init__(self):\n         pass\n \n-    def open(self, platform):\n+    @staticmethod\n+    def open(platform):\n         return 'extern \"platform-intrinsic\" {'\n \n-    def render(self, mono):\n+    @staticmethod\n+    def render(mono):\n         return '    fn {}{}{};'.format(mono.platform_prefix(),\n                                        mono.intrinsic_name(),\n                                        mono.intrinsic_signature())\n \n-    def close(self):\n+    @staticmethod\n+    def close():\n         return '}'\n \n class CompilerDefs(object):\n     def __init__(self):\n         pass\n \n-    def open(self, platform):\n+    @staticmethod\n+    def open(platform):\n         return '''\\\n // Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n@@ -798,7 +805,8 @@ def open(self, platform):\n     if !name.starts_with(\"{0}\") {{ return None }}\n     Some(match &name[\"{0}\".len()..] {{'''.format(platform.platform_prefix())\n \n-    def render(self, mono):\n+    @staticmethod\n+    def render(mono):\n         return '''\\\n         \"{}\" => Intrinsic {{\n             inputs: {{ static INPUTS: [&'static Type; {}] = [{}]; &INPUTS }},\n@@ -810,7 +818,8 @@ def render(self, mono):\n                       mono.compiler_ret(),\n                       mono.llvm_name())\n \n-    def close(self):\n+    @staticmethod\n+    def close():\n         return '''\\\n         _ => return None,\n     })"}, {"sha": "bc141877b373f49b0c19b5977b2e25ada528fc45", "filename": "src/etc/test-float-parse/runtests.py", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fruntests.py?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -177,15 +177,13 @@ def run(test):\n \n \n def interact(proc, queue):\n-    line = \"\"\n     n = 0\n     while proc.poll() is None:\n         line = proc.stdout.readline()\n         if not line:\n             continue\n         assert line.endswith('\\n'), \"incomplete line: \" + repr(line)\n         queue.put(line)\n-        line = \"\"\n         n += 1\n         if n % UPDATE_EVERY_N == 0:\n             msg(\"got\", str(n // 1000) + \"k\", \"records\")"}, {"sha": "bddc83f63d25de55f785edddd399dfdd7fcc7645", "filename": "src/etc/unicode.py", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -82,28 +82,28 @@ def load_unicode_data(f):\n     canon_decomp = {}\n     compat_decomp = {}\n \n-    udict = {};\n-    range_start = -1;\n+    udict = {}\n+    range_start = -1\n     for line in fileinput.input(f):\n-        data = line.split(';');\n+        data = line.split(';')\n         if len(data) != 15:\n             continue\n-        cp = int(data[0], 16);\n+        cp = int(data[0], 16)\n         if is_surrogate(cp):\n             continue\n         if range_start >= 0:\n             for i in xrange(range_start, cp):\n-                udict[i] = data;\n-            range_start = -1;\n+                udict[i] = data\n+            range_start = -1\n         if data[1].endswith(\", First>\"):\n-            range_start = cp;\n-            continue;\n-        udict[cp] = data;\n+            range_start = cp\n+            continue\n+        udict[cp] = data\n \n     for code in udict:\n-        [code_org, name, gencat, combine, bidi,\n+        (code_org, name, gencat, combine, bidi,\n          decomp, deci, digit, num, mirror,\n-         old, iso, upcase, lowcase, titlecase ] = udict[code];\n+         old, iso, upcase, lowcase, titlecase) = udict[code]\n \n         # generate char to char direct common and simple conversions\n         # uppercase to lowercase\n@@ -382,7 +382,7 @@ def emit_bool_trie(f, name, t_data, is_pub=True):\n     global bytes_old, bytes_new\n     bytes_old += 8 * len(t_data)\n     CHUNK = 64\n-    rawdata = [False] * 0x110000;\n+    rawdata = [False] * 0x110000\n     for (lo, hi) in t_data:\n         for cp in range(lo, hi + 1):\n             rawdata[cp] = True"}, {"sha": "7a07e007ce1c48eb8902dd4ba7d0e41fd5ccf75b", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 282, "deletions": 147, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -10,35 +10,11 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-//! Threadsafe reference-counted boxes (the `Arc<T>` type).\n+//! Thread-safe reference-counting pointers.\n //!\n-//! The `Arc<T>` type provides shared ownership of an immutable value through\n-//! atomic reference counting.\n+//! See the [`Arc<T>`][arc] documentation for more details.\n //!\n-//! `Weak<T>` is a weak reference to the `Arc<T>` box, and it is created by\n-//! the `downgrade` method.\n-//! # Examples\n-//!\n-//! Sharing some immutable data between threads:\n-//!\n-// Note that we **do not** run these tests here. The windows builders get super\n-// unhappy of a thread outlives the main thread and then exits at the same time\n-// (something deadlocks) so we just avoid this entirely by not running these\n-// tests.\n-//! ```no_run\n-//! use std::sync::Arc;\n-//! use std::thread;\n-//!\n-//! let five = Arc::new(5);\n-//!\n-//! for _ in 0..10 {\n-//!     let five = five.clone();\n-//!\n-//!     thread::spawn(move || {\n-//!         println!(\"{:?}\", five);\n-//!     });\n-//! }\n-//! ```\n+//! [arc]: struct.Arc.html\n \n use boxed::Box;\n \n@@ -62,72 +38,114 @@ use heap::deallocate;\n \n const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n \n-/// An atomically reference counted wrapper for shared state.\n-/// Destruction is deterministic, and will occur as soon as the last owner is\n-/// gone. It is marked as `Send` because it uses atomic reference counting.\n+/// A thread-safe reference-counting pointer.\n ///\n-/// If you do not need thread-safety, and just need shared ownership, consider\n-/// the [`Rc<T>` type](../rc/struct.Rc.html). It is the same as `Arc<T>`, but\n-/// does not use atomics, making it both thread-unsafe as well as significantly\n-/// faster when updating the reference count.\n+/// The type `Arc<T>` provides shared ownership of a value of type `T`,\n+/// allocated in the heap. Invoking [`clone`][clone] on `Arc` produces\n+/// a new pointer to the same value in the heap. When the last `Arc`\n+/// pointer to a given value is destroyed, the pointed-to value is\n+/// also destroyed.\n ///\n-/// Note: the inherent methods defined on `Arc<T>` are all associated functions,\n-/// which means that you have to call them as e.g.  `Arc::get_mut(&value)`\n-/// instead of `value.get_mut()`.  This is so that there are no conflicts with\n-/// methods on the inner type `T`, which are what you want to call in the\n-/// majority of cases.\n+/// Shared references in Rust disallow mutation by default, and `Arc` is no\n+/// exception. If you need to mutate through an `Arc`, use [`Mutex`][mutex],\n+/// [`RwLock`][rwlock], or one of the [`Atomic`][atomic] types.\n ///\n-/// # Examples\n+/// `Arc` uses atomic operations for reference counting, so `Arc`s can be\n+/// sent between threads. In other words, `Arc<T>` implements [`Send`][send]\n+/// as long as `T` implements `Send` and [`Sync`][sync]. The disadvantage is\n+/// that atomic operations are more expensive than ordinary memory accesses.\n+/// If you are not sharing reference-counted values between threads, consider\n+/// using [`rc::Rc`][rc] for lower overhead. `Rc` is a safe default, because\n+/// the compiler will catch any attempt to send an `Rc` between threads.\n+/// However, a library might choose `Arc` in order to give library consumers\n+/// more flexibility.\n+///\n+/// The [`downgrade`][downgrade] method can be used to create a non-owning\n+/// [`Weak`][weak] pointer. A `Weak` pointer can be [`upgrade`][upgrade]d\n+/// to an `Arc`, but this will return [`None`][option] if the value has\n+/// already been dropped.\n ///\n-/// In this example, a large vector of data will be shared by several threads. First we\n-/// wrap it with a `Arc::new` and then clone the `Arc<T>` reference for every thread (which will\n-/// increase the reference count atomically).\n+/// A cycle between `Arc` pointers will never be deallocated. For this reason,\n+/// `Weak` is used to break cycles. For example, a tree could have strong\n+/// `Arc` pointers from parent nodes to children, and `Weak` pointers from\n+/// children back to their parents.\n+///\n+/// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n+/// so you can call `T`'s methods on a value of type `Arc<T>`. To avoid name\n+/// clashes with `T`'s methods, the methods of `Arc<T>` itself are [associated\n+/// functions][assoc], called using function-like syntax:\n ///\n /// ```\n /// use std::sync::Arc;\n-/// use std::thread;\n+/// let my_arc = Arc::new(());\n+///\n+/// Arc::downgrade(&my_arc);\n+/// ```\n ///\n-/// fn main() {\n-///     let numbers: Vec<_> = (0..100).collect();\n-///     let shared_numbers = Arc::new(numbers);\n+/// `Weak<T>` does not auto-dereference to `T`, because the value may have\n+/// already been destroyed.\n ///\n-///     for _ in 0..10 {\n-///         // prepare a copy of reference here and it will be moved to the thread\n-///         let child_numbers = shared_numbers.clone();\n+/// [arc]: struct.Arc.html\n+/// [weak]: struct.Weak.html\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+/// [mutex]: ../../std/sync/struct.Mutex.html\n+/// [rwlock]: ../../std/sync/struct.RwLock.html\n+/// [atomic]: ../../std/sync/atomic/index.html\n+/// [send]: ../../std/marker/trait.Send.html\n+/// [sync]: ../../std/marker/trait.Sync.html\n+/// [deref]: ../../std/ops/trait.Deref.html\n+/// [downgrade]: struct.Arc.html#method.downgrade\n+/// [upgrade]: struct.Weak.html#method.upgrade\n+/// [option]: ../../std/option/enum.Option.html\n+/// [assoc]: ../../book/method-syntax.html#associated-functions\n ///\n-///         thread::spawn(move || {\n-///             let local_numbers = &child_numbers[..];\n+/// # Examples\n ///\n-///             // Work with the local numbers\n-///         });\n-///     }\n-/// }\n-/// ```\n-/// You can also share mutable data between threads safely\n-/// by putting it inside `Mutex` and then share `Mutex` immutably\n-/// with `Arc<T>` as shown below.\n+/// Sharing some immutable data between threads:\n ///\n-// See comment at the top of this file for why the test is no_run\n+// Note that we **do not** run these tests here. The windows builders get super\n+// unhappy if a thread outlives the main thread and then exits at the same time\n+// (something deadlocks) so we just avoid this entirely by not running these\n+// tests.\n /// ```no_run\n-/// use std::sync::{Arc, Mutex};\n+/// use std::sync::Arc;\n /// use std::thread;\n ///\n-/// let five = Arc::new(Mutex::new(5));\n+/// let five = Arc::new(5);\n ///\n /// for _ in 0..10 {\n ///     let five = five.clone();\n ///\n ///     thread::spawn(move || {\n-///         let mut number = five.lock().unwrap();\n+///         println!(\"{:?}\", five);\n+///     });\n+/// }\n+/// ```\n ///\n-///         *number += 1;\n+/// Sharing a mutable `AtomicUsize`:\n ///\n-///         println!(\"{}\", *number); // prints 6\n+/// ```no_run\n+/// use std::sync::Arc;\n+/// use std::sync::atomic::{AtomicUsize, Ordering};\n+/// use std::thread;\n+///\n+/// let val = Arc::new(AtomicUsize::new(5));\n+///\n+/// for _ in 0..10 {\n+///     let val = val.clone();\n+///\n+///     thread::spawn(move || {\n+///         let v = val.fetch_add(1, Ordering::SeqCst);\n+///         println!(\"{:?}\", v);\n ///     });\n /// }\n /// ```\n-\n-#[cfg_attr(stage0, unsafe_no_drop_flag)]\n+///\n+/// See the [`rc` documentation][rc_examples] for more examples of reference\n+/// counting in general.\n+///\n+/// [rc_examples]: ../../std/rc/index.html#examples\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Arc<T: ?Sized> {\n     ptr: Shared<ArcInner<T>>,\n@@ -141,19 +159,18 @@ unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n \n-/// A weak pointer to an `Arc`.\n+/// A weak version of [`Arc`][arc].\n ///\n-/// Weak pointers will not keep the data inside of the `Arc` alive, and can be\n-/// used to break cycles between `Arc` pointers.\n+/// `Weak` pointers do not count towards determining if the inner value\n+/// should be dropped.\n ///\n-/// A `Weak<T>` pointer can be upgraded to an `Arc<T>` pointer, but\n-/// will return `None` if the value has already been dropped.\n+/// The typical way to obtain a `Weak` pointer is to call\n+/// [`Arc::downgrade`][downgrade].\n ///\n-/// For example, a tree with parent pointers can be represented by putting the\n-/// nodes behind strong `Arc<T>` pointers, and then storing the parent pointers\n-/// as `Weak<T>` pointers.\n-\n-#[cfg_attr(stage0, unsafe_no_drop_flag)]\n+/// See the [`Arc`][arc] documentation for more details.\n+///\n+/// [arc]: struct.Arc.html\n+/// [downgrade]: struct.Arc.html#method.downgrade\n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     ptr: Shared<ArcInner<T>>,\n@@ -211,12 +228,15 @@ impl<T> Arc<T> {\n         Arc { ptr: unsafe { Shared::new(Box::into_raw(x)) } }\n     }\n \n-    /// Unwraps the contained value if the `Arc<T>` has exactly one strong reference.\n+    /// Returns the contained value, if the `Arc` has exactly one strong reference.\n     ///\n-    /// Otherwise, an `Err` is returned with the same `Arc<T>`.\n+    /// Otherwise, an [`Err`][result] is returned with the same `Arc` that was\n+    /// passed in.\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n+    /// [result]: ../../std/result/enum.Result.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -227,7 +247,7 @@ impl<T> Arc<T> {\n     ///\n     /// let x = Arc::new(4);\n     /// let _y = x.clone();\n-    /// assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n+    /// assert_eq!(*Arc::try_unwrap(x).unwrap_err(), 4);\n     /// ```\n     #[inline]\n     #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n@@ -253,7 +273,9 @@ impl<T> Arc<T> {\n }\n \n impl<T: ?Sized> Arc<T> {\n-    /// Downgrades the `Arc<T>` to a `Weak<T>` reference.\n+    /// Creates a new [`Weak`][weak] pointer to this value.\n+    ///\n+    /// [weak]: struct.Weak.html\n     ///\n     /// # Examples\n     ///\n@@ -291,15 +313,53 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Get the number of weak references to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    ///\n+    /// Be careful how you use this information, because another thread\n+    /// may change the weak count at any time.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(arc_counts)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    /// let _weak_five = Arc::downgrade(&five);\n+    ///\n+    /// // This assertion is deterministic because we haven't shared\n+    /// // the `Arc` or `Weak` between threads.\n+    /// assert_eq!(1, Arc::weak_count(&five));\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"arc_counts\", reason = \"not clearly useful, and racy\",\n                issue = \"28356\")]\n     pub fn weak_count(this: &Self) -> usize {\n         this.inner().weak.load(SeqCst) - 1\n     }\n \n-    /// Get the number of strong references to this value.\n+    /// Gets the number of strong (`Arc`) pointers to this value.\n+    ///\n+    /// Be careful how you use this information, because another thread\n+    /// may change the strong count at any time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(arc_counts)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    /// let _also_five = five.clone();\n+    ///\n+    /// // This assertion is deterministic because we haven't shared\n+    /// // the `Arc` between threads.\n+    /// assert_eq!(2, Arc::strong_count(&five));\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"arc_counts\", reason = \"not clearly useful, and racy\",\n                issue = \"28356\")]\n@@ -336,8 +396,8 @@ impl<T: ?Sized> Arc<T> {\n     #[unstable(feature = \"ptr_eq\",\n                reason = \"newly added\",\n                issue = \"36497\")]\n-    /// Return whether two `Arc` references point to the same value\n-    /// (not just values that compare equal).\n+    /// Returns true if the two `Arc`s point to the same value (not\n+    /// just values that compare as equal).\n     ///\n     /// # Examples\n     ///\n@@ -362,9 +422,10 @@ impl<T: ?Sized> Arc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for Arc<T> {\n-    /// Makes a clone of the `Arc<T>`.\n+    /// Makes a clone of the `Arc` pointer.\n     ///\n-    /// This increases the strong reference count.\n+    /// This creates another pointer to the same inner value, increasing the\n+    /// strong reference count.\n     ///\n     /// # Examples\n     ///\n@@ -420,11 +481,17 @@ impl<T: ?Sized> Deref for Arc<T> {\n }\n \n impl<T: Clone> Arc<T> {\n-    /// Make a mutable reference into the given `Arc<T>`.\n-    /// If the `Arc<T>` has more than one strong reference, or any weak\n-    /// references, the inner data is cloned.\n+    /// Makes a mutable reference into the given `Arc`.\n+    ///\n+    /// If there are other `Arc` or [`Weak`][weak] pointers to the same value,\n+    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n+    /// ensure unique ownership. This is also referred to as clone-on-write.\n+    ///\n+    /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n     ///\n-    /// This is also referred to as a copy-on-write.\n+    /// [weak]: struct.Weak.html\n+    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    /// [get_mut]: struct.Arc.html#method.get_mut\n     ///\n     /// # Examples\n     ///\n@@ -439,10 +506,9 @@ impl<T: Clone> Arc<T> {\n     /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n     /// *Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n     ///\n-    /// // Note: data and other_data now point to different numbers\n+    /// // Now `data` and `other_data` point to different values.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n@@ -501,8 +567,19 @@ impl<T: Clone> Arc<T> {\n }\n \n impl<T: ?Sized> Arc<T> {\n-    /// Returns a mutable reference to the contained value if the `Arc<T>` has\n-    /// one strong reference and no weak references.\n+    /// Returns a mutable reference to the inner value, if there are\n+    /// no other `Arc` or [`Weak`][weak] pointers to the same value.\n+    ///\n+    /// Returns [`None`][option] otherwise, because it is not safe to\n+    /// mutate a shared value.\n+    ///\n+    /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n+    /// the inner value when it's shared.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    /// [option]: ../../std/option/enum.Option.html\n+    /// [make_mut]: struct.Arc.html#method.make_mut\n+    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n     ///\n     /// # Examples\n     ///\n@@ -564,30 +641,32 @@ impl<T: ?Sized> Arc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for Arc<T> {\n-    /// Drops the `Arc<T>`.\n+    /// Drops the `Arc`.\n     ///\n     /// This will decrement the strong reference count. If the strong reference\n-    /// count becomes zero and the only other references are `Weak<T>` ones,\n-    /// `drop`s the inner value.\n+    /// count reaches zero then the only other references (if any) are\n+    /// [`Weak`][weak], so we `drop` the inner value.\n+    ///\n+    /// [weak]: struct.Weak.html\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// {\n-    ///     let five = Arc::new(5);\n-    ///\n-    ///     // stuff\n+    /// struct Foo;\n     ///\n-    ///     drop(five); // explicit drop\n+    /// impl Drop for Foo {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"dropped!\");\n+    ///     }\n     /// }\n-    /// {\n-    ///     let five = Arc::new(5);\n     ///\n-    ///     // stuff\n+    /// let foo  = Arc::new(Foo);\n+    /// let foo2 = foo.clone();\n     ///\n-    /// } // implicit drop\n+    /// drop(foo);    // Doesn't print anything\n+    /// drop(foo2);   // Prints \"dropped!\"\n     /// ```\n     #[unsafe_destructor_blind_to_params]\n     #[inline]\n@@ -625,17 +704,22 @@ impl<T: ?Sized> Drop for Arc<T> {\n }\n \n impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>` without an accompanying instance of T.\n+    /// Constructs a new `Weak<T>`, without an accompanying instance of `T`.\n     ///\n-    /// This allocates memory for T, but does not initialize it. Calling\n-    /// Weak<T>::upgrade() on the return value always gives None.\n+    /// This allocates memory for `T`, but does not initialize it. Calling\n+    /// [`upgrade`][upgrade] on the return value always gives\n+    /// [`None`][option].\n+    ///\n+    /// [upgrade]: struct.Weak.html#method.upgrade\n+    /// [option]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::sync::Weak;\n     ///\n     /// let empty: Weak<i64> = Weak::new();\n+    /// assert!(empty.upgrade().is_none());\n     /// ```\n     #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n     pub fn new() -> Weak<T> {\n@@ -652,12 +736,13 @@ impl<T> Weak<T> {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Upgrades a weak reference to a strong reference.\n+    /// Upgrades the `Weak` pointer to an [`Arc`][arc], if possible.\n     ///\n-    /// Upgrades the `Weak<T>` reference to an `Arc<T>`, if possible.\n+    /// Returns [`None`][option] if the strong count has reached zero and the\n+    /// inner value was destroyed.\n     ///\n-    /// Returns `None` if there were no strong references and the data was\n-    /// destroyed.\n+    /// [arc]: struct.Arc.html\n+    /// [option]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n     ///\n@@ -669,6 +754,13 @@ impl<T: ?Sized> Weak<T> {\n     /// let weak_five = Arc::downgrade(&five);\n     ///\n     /// let strong_five: Option<Arc<_>> = weak_five.upgrade();\n+    /// assert!(strong_five.is_some());\n+    ///\n+    /// // Destroy all strong pointers.\n+    /// drop(strong_five);\n+    /// drop(five);\n+    ///\n+    /// assert!(weak_five.upgrade().is_none());\n     /// ```\n     #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n     pub fn upgrade(&self) -> Option<Arc<T>> {\n@@ -711,9 +803,10 @@ impl<T: ?Sized> Weak<T> {\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak<T>`.\n+    /// Makes a clone of the `Weak` pointer.\n     ///\n-    /// This increases the weak reference count.\n+    /// This creates another pointer to the same inner value, increasing the\n+    /// weak reference count.\n     ///\n     /// # Examples\n     ///\n@@ -745,15 +838,31 @@ impl<T: ?Sized> Clone for Weak<T> {\n \n #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n impl<T> Default for Weak<T> {\n-    /// Constructs a new `Weak<T>` without an accompanying instance of T.\n+    /// Constructs a new `Weak<T>`, without an accompanying instance of `T`.\n+    ///\n+    /// This allocates memory for `T`, but does not initialize it. Calling\n+    /// [`upgrade`][upgrade] on the return value always gives\n+    /// [`None`][option].\n+    ///\n+    /// [upgrade]: struct.Weak.html#method.upgrade\n+    /// [option]: ../../std/option/enum.Option.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Weak;\n+    ///\n+    /// let empty: Weak<i64> = Default::default();\n+    /// assert!(empty.upgrade().is_none());\n+    /// ```\n     fn default() -> Weak<T> {\n         Weak::new()\n     }\n }\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Drop for Weak<T> {\n-    /// Drops the `Weak<T>`.\n+    /// Drops the `Weak` pointer.\n     ///\n     /// This will decrement the weak reference count.\n     ///\n@@ -762,21 +871,22 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// {\n-    ///     let five = Arc::new(5);\n-    ///     let weak_five = Arc::downgrade(&five);\n-    ///\n-    ///     // stuff\n+    /// struct Foo;\n     ///\n-    ///     drop(weak_five); // explicit drop\n+    /// impl Drop for Foo {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"dropped!\");\n+    ///     }\n     /// }\n-    /// {\n-    ///     let five = Arc::new(5);\n-    ///     let weak_five = Arc::downgrade(&five);\n     ///\n-    ///     // stuff\n+    /// let foo = Arc::new(Foo);\n+    /// let weak_foo = Arc::downgrade(&foo);\n+    /// let other_weak_foo = weak_foo.clone();\n     ///\n-    /// } // implicit drop\n+    /// drop(weak_foo);   // Doesn't print anything\n+    /// drop(foo);        // Prints \"dropped!\"\n+    ///\n+    /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n         let ptr = *self.ptr;\n@@ -798,9 +908,9 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n-    /// Equality for two `Arc<T>`s.\n+    /// Equality for two `Arc`s.\n     ///\n-    /// Two `Arc<T>`s are equal if their inner value are equal.\n+    /// Two `Arc`s are equal if their inner values are equal.\n     ///\n     /// # Examples\n     ///\n@@ -809,15 +919,15 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five == Arc::new(5);\n+    /// assert!(five == Arc::new(5));\n     /// ```\n     fn eq(&self, other: &Arc<T>) -> bool {\n         *(*self) == *(*other)\n     }\n \n-    /// Inequality for two `Arc<T>`s.\n+    /// Inequality for two `Arc`s.\n     ///\n-    /// Two `Arc<T>`s are unequal if their inner value are unequal.\n+    /// Two `Arc`s are unequal if their inner values are unequal.\n     ///\n     /// # Examples\n     ///\n@@ -826,32 +936,33 @@ impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five != Arc::new(5);\n+    /// assert!(five != Arc::new(6));\n     /// ```\n     fn ne(&self, other: &Arc<T>) -> bool {\n         *(*self) != *(*other)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n-    /// Partial comparison for two `Arc<T>`s.\n+    /// Partial comparison for two `Arc`s.\n     ///\n     /// The two are compared by calling `partial_cmp()` on their inner values.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::sync::Arc;\n+    /// use std::cmp::Ordering;\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five.partial_cmp(&Arc::new(5));\n+    /// assert_eq!(Some(Ordering::Less), five.partial_cmp(&Arc::new(6)));\n     /// ```\n     fn partial_cmp(&self, other: &Arc<T>) -> Option<Ordering> {\n         (**self).partial_cmp(&**other)\n     }\n \n-    /// Less-than comparison for two `Arc<T>`s.\n+    /// Less-than comparison for two `Arc`s.\n     ///\n     /// The two are compared by calling `<` on their inner values.\n     ///\n@@ -862,13 +973,13 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five < Arc::new(5);\n+    /// assert!(five < Arc::new(6));\n     /// ```\n     fn lt(&self, other: &Arc<T>) -> bool {\n         *(*self) < *(*other)\n     }\n \n-    /// 'Less-than or equal to' comparison for two `Arc<T>`s.\n+    /// 'Less than or equal to' comparison for two `Arc`s.\n     ///\n     /// The two are compared by calling `<=` on their inner values.\n     ///\n@@ -879,13 +990,13 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five <= Arc::new(5);\n+    /// assert!(five <= Arc::new(5));\n     /// ```\n     fn le(&self, other: &Arc<T>) -> bool {\n         *(*self) <= *(*other)\n     }\n \n-    /// Greater-than comparison for two `Arc<T>`s.\n+    /// Greater-than comparison for two `Arc`s.\n     ///\n     /// The two are compared by calling `>` on their inner values.\n     ///\n@@ -896,13 +1007,13 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five > Arc::new(5);\n+    /// assert!(five > Arc::new(4));\n     /// ```\n     fn gt(&self, other: &Arc<T>) -> bool {\n         *(*self) > *(*other)\n     }\n \n-    /// 'Greater-than or equal to' comparison for two `Arc<T>`s.\n+    /// 'Greater than or equal to' comparison for two `Arc`s.\n     ///\n     /// The two are compared by calling `>=` on their inner values.\n     ///\n@@ -913,14 +1024,28 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// five >= Arc::new(5);\n+    /// assert!(five >= Arc::new(5));\n     /// ```\n     fn ge(&self, other: &Arc<T>) -> bool {\n         *(*self) >= *(*other)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Ord> Ord for Arc<T> {\n+    /// Comparison for two `Arc`s.\n+    ///\n+    /// The two are compared by calling `cmp()` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// assert_eq!(Ordering::Less, five.cmp(&Arc::new(6)));\n+    /// ```\n     fn cmp(&self, other: &Arc<T>) -> Ordering {\n         (**self).cmp(&**other)\n     }\n@@ -951,7 +1076,16 @@ impl<T: ?Sized> fmt::Pointer for Arc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Default> Default for Arc<T> {\n-    /// Creates a new `Arc<T>`, with the `Default` value for T.\n+    /// Creates a new `Arc<T>`, with the `Default` value for `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x: Arc<i32> = Default::default();\n+    /// assert_eq!(*x, 0);\n+    /// ```\n     fn default() -> Arc<T> {\n         Arc::new(Default::default())\n     }\n@@ -1002,6 +1136,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn manually_share_arc() {\n         let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         let arc_v = Arc::new(v);"}, {"sha": "28f4dda1408830264612d571a35d7f651868f988", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -244,12 +244,14 @@ impl<T: ?Sized> Box<T> {\n     /// the destructor of `T` and free the allocated memory. Since the\n     /// way `Box` allocates and releases memory is unspecified, the\n     /// only valid pointer to pass to this function is the one taken\n-    /// from another `Box` via the `Box::into_raw` function.\n+    /// from another `Box` via the [`Box::into_raw`] function.\n     ///\n     /// This function is unsafe because improper use may lead to\n     /// memory problems. For example, a double-free may occur if the\n     /// function is called twice on the same raw pointer.\n     ///\n+    /// [`Box::into_raw`]: struct.Box.html#method.into_raw\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -269,12 +271,14 @@ impl<T: ?Sized> Box<T> {\n     /// memory previously managed by the `Box`. In particular, the\n     /// caller should properly destroy `T` and release the memory. The\n     /// proper way to do so is to convert the raw pointer back into a\n-    /// `Box` with the `Box::from_raw` function.\n+    /// `Box` with the [`Box::from_raw`] function.\n     ///\n     /// Note: this is an associated function, which means that you have\n     /// to call it as `Box::into_raw(b)` instead of `b.into_raw()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     ///\n+    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "31491106d97ee1b22a88d9f1184adc6322c56926", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -88,7 +88,6 @@\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unique)]\n-#![cfg_attr(stage0, feature(unsafe_no_drop_flag))]\n #![feature(unsize)]\n \n #![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol))]"}, {"sha": "f23ea0ea8bf710dcf7794e2560ca14e7eb6595f6", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -44,7 +44,6 @@ use core::cmp;\n /// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n-#[cfg_attr(stage0, unsafe_no_drop_flag)]\n pub struct RawVec<T> {\n     ptr: Unique<T>,\n     cap: usize,\n@@ -58,11 +57,7 @@ impl<T> RawVec<T> {\n     pub fn new() -> Self {\n         unsafe {\n             // !0 is usize::MAX. This branch should be stripped at compile time.\n-            let cap = if mem::size_of::<T>() == 0 {\n-                !0\n-            } else {\n-                0\n-            };\n+            let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n \n             // heap::EMPTY doubles as \"unallocated\" and \"zero-sized allocation\"\n             RawVec {\n@@ -210,11 +205,7 @@ impl<T> RawVec<T> {\n \n             let (new_cap, ptr) = if self.cap == 0 {\n                 // skip to 4 because tiny Vec's are dumb; but not if that would cause overflow\n-                let new_cap = if elem_size > (!0) / 8 {\n-                    1\n-                } else {\n-                    4\n-                };\n+                let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                 let ptr = heap::allocate(new_cap * elem_size, align);\n                 (new_cap, ptr)\n             } else {\n@@ -348,7 +339,7 @@ impl<T> RawVec<T> {\n         let elem_size = mem::size_of::<T>();\n         // Nothing we can really do about these checks :(\n         let required_cap = used_cap.checked_add(needed_extra_cap)\n-                                   .expect(\"capacity overflow\");\n+            .expect(\"capacity overflow\");\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n         let double_cap = self.cap * 2;\n         // `double_cap` guarantees exponential growth."}, {"sha": "740d13c476222a44680a45b70717cd3e83cc1b0b", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 347, "deletions": 163, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -10,90 +10,139 @@\n \n #![allow(deprecated)]\n \n-//! Unsynchronized reference-counted boxes (the `Rc<T>` type) which are usable\n-//! only within a single thread.\n+//! Single-threaded reference-counting pointers.\n //!\n-//! The `Rc<T>` type provides shared ownership of an immutable value.\n-//! Destruction is deterministic, and will occur as soon as the last owner is\n-//! gone. It is marked as non-sendable because it avoids the overhead of atomic\n-//! reference counting.\n+//! The type [`Rc<T>`][rc] provides shared ownership of a value of type `T`,\n+//! allocated in the heap. Invoking [`clone`][clone] on `Rc` produces a new\n+//! pointer to the same value in the heap. When the last `Rc` pointer to a\n+//! given value is destroyed, the pointed-to value is also destroyed.\n //!\n-//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer\n-//! to the box. A `Weak<T>` pointer can be upgraded to an `Rc<T>` pointer, but\n-//! will return `None` if the value has already been dropped.\n+//! Shared references in Rust disallow mutation by default, and `Rc` is no\n+//! exception. If you need to mutate through an `Rc`, use [`Cell`][cell] or\n+//! [`RefCell`][refcell].\n //!\n-//! For example, a tree with parent pointers can be represented by putting the\n-//! nodes behind strong `Rc<T>` pointers, and then storing the parent pointers\n-//! as `Weak<T>` pointers.\n+//! `Rc` uses non-atomic reference counting. This means that overhead is very\n+//! low, but an `Rc` cannot be sent between threads, and consequently `Rc`\n+//! does not implement [`Send`][send]. As a result, the Rust compiler\n+//! will check *at compile time* that you are not sending `Rc`s between\n+//! threads. If you need multi-threaded, atomic reference counting, use\n+//! [`sync::Arc`][arc].\n+//!\n+//! The [`downgrade`][downgrade] method can be used to create a non-owning\n+//! [`Weak`][weak] pointer. A `Weak` pointer can be [`upgrade`][upgrade]d\n+//! to an `Rc`, but this will return [`None`][option] if the value has\n+//! already been dropped.\n+//!\n+//! A cycle between `Rc` pointers will never be deallocated. For this reason,\n+//! `Weak` is used to break cycles. For example, a tree could have strong\n+//! `Rc` pointers from parent nodes to children, and `Weak` pointers from\n+//! children back to their parents.\n+//!\n+//! `Rc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n+//! so you can call `T`'s methods on a value of type `Rc<T>`. To avoid name\n+//! clashes with `T`'s methods, the methods of `Rc<T>` itself are [associated\n+//! functions][assoc], called using function-like syntax:\n+//!\n+//! ```\n+//! use std::rc::Rc;\n+//! let my_rc = Rc::new(());\n+//!\n+//! Rc::downgrade(&my_rc);\n+//! ```\n+//!\n+//! `Weak<T>` does not auto-dereference to `T`, because the value may have\n+//! already been destroyed.\n+//!\n+//! [rc]: struct.Rc.html\n+//! [weak]: struct.Weak.html\n+//! [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+//! [cell]: ../../std/cell/struct.Cell.html\n+//! [refcell]: ../../std/cell/struct.RefCell.html\n+//! [send]: ../../std/marker/trait.Send.html\n+//! [arc]: ../../std/sync/struct.Arc.html\n+//! [deref]: ../../std/ops/trait.Deref.html\n+//! [downgrade]: struct.Rc.html#method.downgrade\n+//! [upgrade]: struct.Weak.html#method.upgrade\n+//! [option]: ../../std/option/enum.Option.html\n+//! [assoc]: ../../book/method-syntax.html#associated-functions\n //!\n //! # Examples\n //!\n //! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.\n //! We want to have our `Gadget`s point to their `Owner`. We can't do this with\n //! unique ownership, because more than one gadget may belong to the same\n-//! `Owner`. `Rc<T>` allows us to share an `Owner` between multiple `Gadget`s,\n+//! `Owner`. `Rc` allows us to share an `Owner` between multiple `Gadget`s,\n //! and have the `Owner` remain allocated as long as any `Gadget` points at it.\n //!\n-//! ```rust\n+//! ```\n //! use std::rc::Rc;\n //!\n //! struct Owner {\n-//!     name: String\n+//!     name: String,\n //!     // ...other fields\n //! }\n //!\n //! struct Gadget {\n //!     id: i32,\n-//!     owner: Rc<Owner>\n+//!     owner: Rc<Owner>,\n //!     // ...other fields\n //! }\n //!\n //! fn main() {\n-//!     // Create a reference counted Owner.\n-//!     let gadget_owner : Rc<Owner> = Rc::new(\n-//!         Owner { name: String::from(\"Gadget Man\") }\n+//!     // Create a reference-counted `Owner`.\n+//!     let gadget_owner: Rc<Owner> = Rc::new(\n+//!         Owner {\n+//!             name: \"Gadget Man\".to_string(),\n+//!         }\n //!     );\n //!\n-//!     // Create Gadgets belonging to gadget_owner. To increment the reference\n-//!     // count we clone the `Rc<T>` object.\n-//!     let gadget1 = Gadget { id: 1, owner: gadget_owner.clone() };\n-//!     let gadget2 = Gadget { id: 2, owner: gadget_owner.clone() };\n+//!     // Create `Gadget`s belonging to `gadget_owner`. Cloning the `Rc<Owner>`\n+//!     // value gives us a new pointer to the same `Owner` value, incrementing\n+//!     // the reference count in the process.\n+//!     let gadget1 = Gadget {\n+//!         id: 1,\n+//!         owner: gadget_owner.clone(),\n+//!     };\n+//!     let gadget2 = Gadget {\n+//!         id: 2,\n+//!         owner: gadget_owner.clone(),\n+//!     };\n //!\n+//!     // Dispose of our local variable `gadget_owner`.\n //!     drop(gadget_owner);\n //!\n-//!     // Despite dropping gadget_owner, we're still able to print out the name\n-//!     // of the Owner of the Gadgets. This is because we've only dropped the\n-//!     // reference count object, not the Owner it wraps. As long as there are\n-//!     // other `Rc<T>` objects pointing at the same Owner, it will remain\n-//!     // allocated. Notice that the `Rc<T>` wrapper around Gadget.owner gets\n-//!     // automatically dereferenced for us.\n+//!     // Despite dropping `gadget_owner`, we're still able to print out the name\n+//!     // of the `Owner` of the `Gadget`s. This is because we've only dropped a\n+//!     // single `Rc<Owner>`, not the `Owner` it points to. As long as there are\n+//!     // other `Rc<Owner>` values pointing at the same `Owner`, it will remain\n+//!     // allocated. The field projection `gadget1.owner.name` works because\n+//!     // `Rc<Owner>` automatically dereferences to `Owner`.\n //!     println!(\"Gadget {} owned by {}\", gadget1.id, gadget1.owner.name);\n //!     println!(\"Gadget {} owned by {}\", gadget2.id, gadget2.owner.name);\n //!\n-//!     // At the end of the method, gadget1 and gadget2 get destroyed, and with\n-//!     // them the last counted references to our Owner. Gadget Man now gets\n-//!     // destroyed as well.\n+//!     // At the end of the function, `gadget1` and `gadget2` are destroyed, and\n+//!     // with them the last counted references to our `Owner`. Gadget Man now\n+//!     // gets destroyed as well.\n //! }\n //! ```\n //!\n //! If our requirements change, and we also need to be able to traverse from\n-//! Owner \u2192\u00a0Gadget, we will run into problems: an `Rc<T>` pointer from Owner\n-//! \u2192\u00a0Gadget introduces a cycle between the objects. This means that their\n-//! reference counts can never reach 0, and the objects will remain allocated: a\n-//! memory leak. In order to get around this, we can use `Weak<T>` pointers.\n-//! These pointers don't contribute to the total count.\n+//! `Owner` to\u00a0`Gadget`, we will run into problems. An `Rc` pointer from `Owner`\n+//! to `Gadget` introduces a cycle between the values. This means that their\n+//! reference counts can never reach 0, and the values will remain allocated\n+//! forever: a memory leak. In order to get around this, we can use `Weak`\n+//! pointers.\n //!\n //! Rust actually makes it somewhat difficult to produce this loop in the first\n-//! place: in order to end up with two objects that point at each other, one of\n-//! them needs to be mutable. This is problematic because `Rc<T>` enforces\n-//! memory safety by only giving out shared references to the object it wraps,\n+//! place. In order to end up with two values that point at each other, one of\n+//! them needs to be mutable. This is difficult because `Rc` enforces\n+//! memory safety by only giving out shared references to the value it wraps,\n //! and these don't allow direct mutation. We need to wrap the part of the\n-//! object we wish to mutate in a `RefCell`, which provides *interior\n+//! value we wish to mutate in a [`RefCell`][refcell], which provides *interior\n //! mutability*: a method to achieve mutability through a shared reference.\n-//! `RefCell` enforces Rust's borrowing rules at runtime.  Read the `Cell`\n-//! documentation for more details on interior mutability.\n+//! `RefCell` enforces Rust's borrowing rules at runtime.\n //!\n-//! ```rust\n+//! ```\n //! use std::rc::Rc;\n //! use std::rc::Weak;\n //! use std::cell::RefCell;\n@@ -111,41 +160,58 @@\n //! }\n //!\n //! fn main() {\n-//!     // Create a reference counted Owner. Note the fact that we've put the\n-//!     // Owner's vector of Gadgets inside a RefCell so that we can mutate it\n-//!     // through a shared reference.\n-//!     let gadget_owner : Rc<Owner> = Rc::new(\n+//!     // Create a reference-counted `Owner`. Note that we've put the `Owner`'s\n+//!     // vector of `Gadget`s inside a `RefCell` so that we can mutate it through\n+//!     // a shared reference.\n+//!     let gadget_owner: Rc<Owner> = Rc::new(\n //!         Owner {\n //!             name: \"Gadget Man\".to_string(),\n-//!             gadgets: RefCell::new(Vec::new()),\n+//!             gadgets: RefCell::new(vec![]),\n+//!         }\n+//!     );\n+//!\n+//!     // Create `Gadget`s belonging to `gadget_owner`, as before.\n+//!     let gadget1 = Rc::new(\n+//!         Gadget {\n+//!             id: 1,\n+//!             owner: gadget_owner.clone(),\n+//!         }\n+//!     );\n+//!     let gadget2 = Rc::new(\n+//!         Gadget {\n+//!             id: 2,\n+//!             owner: gadget_owner.clone(),\n //!         }\n //!     );\n //!\n-//!     // Create Gadgets belonging to gadget_owner as before.\n-//!     let gadget1 = Rc::new(Gadget{id: 1, owner: gadget_owner.clone()});\n-//!     let gadget2 = Rc::new(Gadget{id: 2, owner: gadget_owner.clone()});\n+//!     // Add the `Gadget`s to their `Owner`.\n+//!     {\n+//!         let mut gadgets = gadget_owner.gadgets.borrow_mut();\n+//!         gadgets.push(Rc::downgrade(&gadget1));\n+//!         gadgets.push(Rc::downgrade(&gadget2));\n //!\n-//!     // Add the Gadgets to their Owner. To do this we mutably borrow from\n-//!     // the RefCell holding the Owner's Gadgets.\n-//!     gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget1));\n-//!     gadget_owner.gadgets.borrow_mut().push(Rc::downgrade(&gadget2));\n+//!         // `RefCell` dynamic borrow ends here.\n+//!     }\n //!\n-//!     // Iterate over our Gadgets, printing their details out\n-//!     for gadget_opt in gadget_owner.gadgets.borrow().iter() {\n+//!     // Iterate over our `Gadget`s, printing their details out.\n+//!     for gadget_weak in gadget_owner.gadgets.borrow().iter() {\n //!\n-//!         // gadget_opt is a Weak<Gadget>. Since weak pointers can't guarantee\n-//!         // that their object is still allocated, we need to call upgrade()\n-//!         // on them to turn them into a strong reference. This returns an\n-//!         // Option, which contains a reference to our object if it still\n-//!         // exists.\n-//!         let gadget = gadget_opt.upgrade().unwrap();\n+//!         // `gadget_weak` is a `Weak<Gadget>`. Since `Weak` pointers can't\n+//!         // guarantee the value is still allocated, we need to call\n+//!         // `upgrade`, which returns an `Option<Rc<Gadget>>`.\n+//!         //\n+//!         // In this case we know the value still exists, so we simply\n+//!         // `unwrap` the `Option`. In a more complicated program, you might\n+//!         // need graceful error handling for a `None` result.\n+//!\n+//!         let gadget = gadget_weak.upgrade().unwrap();\n //!         println!(\"Gadget {} owned by {}\", gadget.id, gadget.owner.name);\n //!     }\n //!\n-//!     // At the end of the method, gadget_owner, gadget1 and gadget2 get\n-//!     // destroyed. There are now no strong (`Rc<T>`) references to the gadgets.\n-//!     // Once they get destroyed, the Gadgets get destroyed. This zeroes the\n-//!     // reference count on Gadget Man, they get destroyed as well.\n+//!     // At the end of the function, `gadget_owner`, `gadget1`, and `gadget2`\n+//!     // are destroyed. There are now no strong (`Rc`) pointers to the\n+//!     // gadgets, so they are destroyed. This zeroes the reference count on\n+//!     // Gadget Man, so he gets destroyed as well.\n //! }\n //! ```\n \n@@ -164,13 +230,14 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::{abort, assume};\n use core::marker;\n use core::marker::Unsize;\n-use core::mem::{self, align_of_val, forget, size_of_val, uninitialized};\n+use core::mem::{self, align_of_val, forget, size_of, size_of_val, uninitialized};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, Shared};\n use core::convert::From;\n \n use heap::deallocate;\n+use raw_vec::RawVec;\n \n struct RcBox<T: ?Sized> {\n     strong: Cell<usize>,\n@@ -179,16 +246,14 @@ struct RcBox<T: ?Sized> {\n }\n \n \n-/// A reference-counted pointer type over an immutable value.\n+/// A single-threaded reference-counting pointer.\n ///\n-/// See the [module level documentation](./index.html) for more details.\n+/// See the [module-level documentation](./index.html) for more details.\n ///\n-/// Note: the inherent methods defined on `Rc<T>` are all associated functions,\n-/// which means that you have to call them as e.g. `Rc::get_mut(&value)` instead\n-/// of `value.get_mut()`.  This is so that there are no conflicts with methods\n-/// on the inner type `T`, which are what you want to call in the majority of\n-/// cases.\n-#[cfg_attr(stage0, unsafe_no_drop_flag)]\n+/// The inherent methods of `Rc` are all associated functions, which means\n+/// that you have to call them as e.g. `Rc::get_mut(&value)` instead of\n+/// `value.get_mut()`.  This avoids conflicts with methods of the inner\n+/// type `T`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n     ptr: Shared<RcBox<T>>,\n@@ -229,12 +294,15 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Unwraps the contained value if the `Rc<T>` has exactly one strong reference.\n+    /// Returns the contained value, if the `Rc` has exactly one strong reference.\n     ///\n-    /// Otherwise, an `Err` is returned with the same `Rc<T>`.\n+    /// Otherwise, an [`Err`][result] is returned with the same `Rc` that was\n+    /// passed in.\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n+    /// [result]: ../../std/result/enum.Result.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -245,7 +313,7 @@ impl<T> Rc<T> {\n     ///\n     /// let x = Rc::new(4);\n     /// let _y = x.clone();\n-    /// assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n+    /// assert_eq!(*Rc::try_unwrap(x).unwrap_err(), 4);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n@@ -268,7 +336,11 @@ impl<T> Rc<T> {\n         }\n     }\n \n-    /// Checks if `Rc::try_unwrap` would return `Ok`.\n+    /// Checks whether [`Rc::try_unwrap`][try_unwrap] would return\n+    /// [`Ok`][result].\n+    ///\n+    /// [try_unwrap]: struct.Rc.html#method.try_unwrap\n+    /// [result]: ../../std/result/enum.Result.html\n     ///\n     /// # Examples\n     ///\n@@ -284,7 +356,7 @@ impl<T> Rc<T> {\n     /// let x = Rc::new(4);\n     /// let _y = x.clone();\n     /// assert!(!Rc::would_unwrap(&x));\n-    /// assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n+    /// assert_eq!(*Rc::try_unwrap(x).unwrap_err(), 4);\n     /// ```\n     #[unstable(feature = \"rc_would_unwrap\",\n                reason = \"just added for niche usecase\",\n@@ -294,8 +366,35 @@ impl<T> Rc<T> {\n     }\n }\n \n+impl Rc<str> {\n+    /// Constructs a new `Rc<str>` from a string slice.\n+    #[doc(hidden)]\n+    #[unstable(feature = \"rustc_private\",\n+               reason = \"for internal use in rustc\",\n+               issue = \"0\")]\n+    pub fn __from_str(value: &str) -> Rc<str> {\n+        unsafe {\n+            // Allocate enough space for `RcBox<str>`.\n+            let aligned_len = 2 + (value.len() + size_of::<usize>() - 1) / size_of::<usize>();\n+            let vec = RawVec::<usize>::with_capacity(aligned_len);\n+            let ptr = vec.ptr();\n+            forget(vec);\n+            // Initialize fields of `RcBox<str>`.\n+            *ptr.offset(0) = 1; // strong: Cell::new(1)\n+            *ptr.offset(1) = 1; // weak: Cell::new(1)\n+            ptr::copy_nonoverlapping(value.as_ptr(), ptr.offset(2) as *mut u8, value.len());\n+            // Combine the allocation address and the string length into a fat pointer to `RcBox`.\n+            let rcbox_ptr: *mut RcBox<str> = mem::transmute([ptr as usize, value.len()]);\n+            assert!(aligned_len * size_of::<usize>() == size_of_val(&*rcbox_ptr));\n+            Rc { ptr: Shared::new(rcbox_ptr) }\n+        }\n+    }\n+}\n+\n impl<T: ?Sized> Rc<T> {\n-    /// Creates a new `Weak<T>` reference from this value.\n+    /// Creates a new [`Weak`][weak] pointer to this value.\n+    ///\n+    /// [weak]: struct.Weak.html\n     ///\n     /// # Examples\n     ///\n@@ -312,24 +411,54 @@ impl<T: ?Sized> Rc<T> {\n         Weak { ptr: this.ptr }\n     }\n \n-    /// Get the number of weak references to this value.\n+    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_counts)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    /// let _weak_five = Rc::downgrade(&five);\n+    ///\n+    /// assert_eq!(1, Rc::weak_count(&five));\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"rc_counts\", reason = \"not clearly useful\",\n                issue = \"28356\")]\n     pub fn weak_count(this: &Self) -> usize {\n         this.weak() - 1\n     }\n \n-    /// Get the number of strong references to this value.\n+    /// Gets the number of strong (`Rc`) pointers to this value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(rc_counts)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let five = Rc::new(5);\n+    /// let _also_five = five.clone();\n+    ///\n+    /// assert_eq!(2, Rc::strong_count(&five));\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"rc_counts\", reason = \"not clearly useful\",\n                issue = \"28356\")]\n     pub fn strong_count(this: &Self) -> usize {\n         this.strong()\n     }\n \n-    /// Returns true if there are no other `Rc` or `Weak<T>` values that share\n-    /// the same inner value.\n+    /// Returns true if there are no other `Rc` or [`Weak`][weak] pointers to\n+    /// this inner value.\n+    ///\n+    /// [weak]: struct.Weak.html\n     ///\n     /// # Examples\n     ///\n@@ -349,10 +478,19 @@ impl<T: ?Sized> Rc<T> {\n         Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1\n     }\n \n-    /// Returns a mutable reference to the contained value if the `Rc<T>` has\n-    /// one strong reference and no weak references.\n+    /// Returns a mutable reference to the inner value, if there are\n+    /// no other `Rc` or [`Weak`][weak] pointers to the same value.\n+    ///\n+    /// Returns [`None`][option] otherwise, because it is not safe to\n+    /// mutate a shared value.\n+    ///\n+    /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n+    /// the inner value when it's shared.\n     ///\n-    /// Returns `None` if the `Rc<T>` is not unique.\n+    /// [weak]: struct.Weak.html\n+    /// [option]: ../../std/option/enum.Option.html\n+    /// [make_mut]: struct.Rc.html#method.make_mut\n+    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n     ///\n     /// # Examples\n     ///\n@@ -381,8 +519,8 @@ impl<T: ?Sized> Rc<T> {\n     #[unstable(feature = \"ptr_eq\",\n                reason = \"newly added\",\n                issue = \"36497\")]\n-    /// Return whether two `Rc` references point to the same value\n-    /// (not just values that compare equal).\n+    /// Returns true if the two `Rc`s point to the same value (not\n+    /// just values that compare as equal).\n     ///\n     /// # Examples\n     ///\n@@ -406,11 +544,17 @@ impl<T: ?Sized> Rc<T> {\n }\n \n impl<T: Clone> Rc<T> {\n-    /// Make a mutable reference into the given `Rc<T>` by cloning the inner\n-    /// data if the `Rc<T>` doesn't have one strong reference and no weak\n-    /// references.\n+    /// Makes a mutable reference into the given `Rc`.\n+    ///\n+    /// If there are other `Rc` or [`Weak`][weak] pointers to the same value,\n+    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n+    /// ensure unique ownership. This is also referred to as clone-on-write.\n+    ///\n+    /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n     ///\n-    /// This is also referred to as a copy-on-write.\n+    /// [weak]: struct.Weak.html\n+    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    /// [get_mut]: struct.Rc.html#method.get_mut\n     ///\n     /// # Examples\n     ///\n@@ -419,16 +563,15 @@ impl<T: Clone> Rc<T> {\n     ///\n     /// let mut data = Rc::new(5);\n     ///\n-    /// *Rc::make_mut(&mut data) += 1;             // Won't clone anything\n-    /// let mut other_data = data.clone(); // Won't clone inner data\n-    /// *Rc::make_mut(&mut data) += 1;             // Clones inner data\n-    /// *Rc::make_mut(&mut data) += 1;             // Won't clone anything\n-    /// *Rc::make_mut(&mut other_data) *= 2;       // Won't clone anything\n+    /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n+    /// let mut other_data = data.clone();    // Won't clone inner data\n+    /// *Rc::make_mut(&mut data) += 1;        // Clones inner data\n+    /// *Rc::make_mut(&mut data) += 1;        // Won't clone anything\n+    /// *Rc::make_mut(&mut other_data) *= 2;  // Won't clone anything\n     ///\n-    /// // Note: data and other_data now point to different numbers\n+    /// // Now `data` and `other_data` point to different values.\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n-    ///\n     /// ```\n     #[inline]\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n@@ -470,30 +613,32 @@ impl<T: ?Sized> Deref for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for Rc<T> {\n-    /// Drops the `Rc<T>`.\n+    /// Drops the `Rc`.\n     ///\n     /// This will decrement the strong reference count. If the strong reference\n-    /// count becomes zero and the only other references are `Weak<T>` ones,\n-    /// `drop`s the inner value.\n+    /// count reaches zero then the only other references (if any) are\n+    /// [`Weak`][weak], so we `drop` the inner value.\n+    ///\n+    /// [weak]: struct.Weak.html\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///\n-    ///     // stuff\n+    /// struct Foo;\n     ///\n-    ///     drop(five); // explicit drop\n+    /// impl Drop for Foo {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"dropped!\");\n+    ///     }\n     /// }\n-    /// {\n-    ///     let five = Rc::new(5);\n     ///\n-    ///     // stuff\n+    /// let foo  = Rc::new(Foo);\n+    /// let foo2 = foo.clone();\n     ///\n-    /// } // implicit drop\n+    /// drop(foo);    // Doesn't print anything\n+    /// drop(foo2);   // Prints \"dropped!\"\n     /// ```\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n@@ -519,10 +664,10 @@ impl<T: ?Sized> Drop for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for Rc<T> {\n-    /// Makes a clone of the `Rc<T>`.\n+    /// Makes a clone of the `Rc` pointer.\n     ///\n-    /// When you clone an `Rc<T>`, it will create another pointer to the data and\n-    /// increase the strong reference counter.\n+    /// This creates another pointer to the same inner value, increasing the\n+    /// strong reference count.\n     ///\n     /// # Examples\n     ///\n@@ -550,6 +695,7 @@ impl<T: Default> Default for Rc<T> {\n     /// use std::rc::Rc;\n     ///\n     /// let x: Rc<i32> = Default::default();\n+    /// assert_eq!(*x, 0);\n     /// ```\n     #[inline]\n     fn default() -> Rc<T> {\n@@ -559,9 +705,9 @@ impl<T: Default> Default for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n-    /// Equality for two `Rc<T>`s.\n+    /// Equality for two `Rc`s.\n     ///\n-    /// Two `Rc<T>`s are equal if their inner value are equal.\n+    /// Two `Rc`s are equal if their inner values are equal.\n     ///\n     /// # Examples\n     ///\n@@ -570,16 +716,16 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five == Rc::new(5);\n+    /// assert!(five == Rc::new(5));\n     /// ```\n     #[inline(always)]\n     fn eq(&self, other: &Rc<T>) -> bool {\n         **self == **other\n     }\n \n-    /// Inequality for two `Rc<T>`s.\n+    /// Inequality for two `Rc`s.\n     ///\n-    /// Two `Rc<T>`s are unequal if their inner value are unequal.\n+    /// Two `Rc`s are unequal if their inner values are unequal.\n     ///\n     /// # Examples\n     ///\n@@ -588,7 +734,7 @@ impl<T: ?Sized + PartialEq> PartialEq for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five != Rc::new(5);\n+    /// assert!(five != Rc::new(6));\n     /// ```\n     #[inline(always)]\n     fn ne(&self, other: &Rc<T>) -> bool {\n@@ -601,25 +747,26 @@ impl<T: ?Sized + Eq> Eq for Rc<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n-    /// Partial comparison for two `Rc<T>`s.\n+    /// Partial comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `partial_cmp()` on their inner values.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::rc::Rc;\n+    /// use std::cmp::Ordering;\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five.partial_cmp(&Rc::new(5));\n+    /// assert_eq!(Some(Ordering::Less), five.partial_cmp(&Rc::new(6)));\n     /// ```\n     #[inline(always)]\n     fn partial_cmp(&self, other: &Rc<T>) -> Option<Ordering> {\n         (**self).partial_cmp(&**other)\n     }\n \n-    /// Less-than comparison for two `Rc<T>`s.\n+    /// Less-than comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `<` on their inner values.\n     ///\n@@ -630,14 +777,14 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five < Rc::new(5);\n+    /// assert!(five < Rc::new(6));\n     /// ```\n     #[inline(always)]\n     fn lt(&self, other: &Rc<T>) -> bool {\n         **self < **other\n     }\n \n-    /// 'Less-than or equal to' comparison for two `Rc<T>`s.\n+    /// 'Less than or equal to' comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `<=` on their inner values.\n     ///\n@@ -648,14 +795,14 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five <= Rc::new(5);\n+    /// assert!(five <= Rc::new(5));\n     /// ```\n     #[inline(always)]\n     fn le(&self, other: &Rc<T>) -> bool {\n         **self <= **other\n     }\n \n-    /// Greater-than comparison for two `Rc<T>`s.\n+    /// Greater-than comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `>` on their inner values.\n     ///\n@@ -666,14 +813,14 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five > Rc::new(5);\n+    /// assert!(five > Rc::new(4));\n     /// ```\n     #[inline(always)]\n     fn gt(&self, other: &Rc<T>) -> bool {\n         **self > **other\n     }\n \n-    /// 'Greater-than or equal to' comparison for two `Rc<T>`s.\n+    /// 'Greater than or equal to' comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `>=` on their inner values.\n     ///\n@@ -684,7 +831,7 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five >= Rc::new(5);\n+    /// assert!(five >= Rc::new(5));\n     /// ```\n     #[inline(always)]\n     fn ge(&self, other: &Rc<T>) -> bool {\n@@ -694,18 +841,19 @@ impl<T: ?Sized + PartialOrd> PartialOrd for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Ord> Ord for Rc<T> {\n-    /// Comparison for two `Rc<T>`s.\n+    /// Comparison for two `Rc`s.\n     ///\n     /// The two are compared by calling `cmp()` on their inner values.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::rc::Rc;\n+    /// use std::cmp::Ordering;\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// five.partial_cmp(&Rc::new(5));\n+    /// assert_eq!(Ordering::Less, five.cmp(&Rc::new(6)));\n     /// ```\n     #[inline]\n     fn cmp(&self, other: &Rc<T>) -> Ordering {\n@@ -748,13 +896,18 @@ impl<T> From<T> for Rc<T> {\n     }\n }\n \n-/// A weak version of `Rc<T>`.\n+/// A weak version of [`Rc`][rc].\n+///\n+/// `Weak` pointers do not count towards determining if the inner value\n+/// should be dropped.\n+///\n+/// The typical way to obtain a `Weak` pointer is to call\n+/// [`Rc::downgrade`][downgrade].\n ///\n-/// Weak references do not count when determining if the inner value should be\n-/// dropped.\n+/// See the [module-level documentation](./index.html) for more details.\n ///\n-/// See the [module level documentation](./index.html) for more.\n-#[cfg_attr(stage0, unsafe_no_drop_flag)]\n+/// [rc]: struct.Rc.html\n+/// [downgrade]: struct.Rc.html#method.downgrade\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n     ptr: Shared<RcBox<T>>,\n@@ -769,17 +922,22 @@ impl<T: ?Sized> !marker::Sync for Weak<T> {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>` without an accompanying instance of T.\n+    /// Constructs a new `Weak<T>`, without an accompanying instance of `T`.\n     ///\n-    /// This allocates memory for T, but does not initialize it. Calling\n-    /// Weak<T>::upgrade() on the return value always gives None.\n+    /// This allocates memory for `T`, but does not initialize it. Calling\n+    /// [`upgrade`][upgrade] on the return value always gives\n+    /// [`None`][option].\n+    ///\n+    /// [upgrade]: struct.Weak.html#method.upgrade\n+    /// [option]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::rc::Weak;\n     ///\n     /// let empty: Weak<i64> = Weak::new();\n+    /// assert!(empty.upgrade().is_none());\n     /// ```\n     #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n     pub fn new() -> Weak<T> {\n@@ -796,12 +954,13 @@ impl<T> Weak<T> {\n }\n \n impl<T: ?Sized> Weak<T> {\n-    /// Upgrades a weak reference to a strong reference.\n+    /// Upgrades the `Weak` pointer to an [`Rc`][rc], if possible.\n     ///\n-    /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n+    /// Returns [`None`][option] if the strong count has reached zero and the\n+    /// inner value was destroyed.\n     ///\n-    /// Returns `None` if there were no strong references and the data was\n-    /// destroyed.\n+    /// [rc]: struct.Rc.html\n+    /// [option]: ../../std/option/enum.Option.html\n     ///\n     /// # Examples\n     ///\n@@ -813,6 +972,13 @@ impl<T: ?Sized> Weak<T> {\n     /// let weak_five = Rc::downgrade(&five);\n     ///\n     /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n+    /// assert!(strong_five.is_some());\n+    ///\n+    /// // Destroy all strong pointers.\n+    /// drop(strong_five);\n+    /// drop(five);\n+    ///\n+    /// assert!(weak_five.upgrade().is_none());\n     /// ```\n     #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n@@ -827,7 +993,7 @@ impl<T: ?Sized> Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Drop for Weak<T> {\n-    /// Drops the `Weak<T>`.\n+    /// Drops the `Weak` pointer.\n     ///\n     /// This will decrement the weak reference count.\n     ///\n@@ -836,21 +1002,22 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///     let weak_five = Rc::downgrade(&five);\n+    /// struct Foo;\n     ///\n-    ///     // stuff\n-    ///\n-    ///     drop(weak_five); // explicit drop\n+    /// impl Drop for Foo {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"dropped!\");\n+    ///     }\n     /// }\n-    /// {\n-    ///     let five = Rc::new(5);\n-    ///     let weak_five = Rc::downgrade(&five);\n     ///\n-    ///     // stuff\n+    /// let foo = Rc::new(Foo);\n+    /// let weak_foo = Rc::downgrade(&foo);\n+    /// let other_weak_foo = weak_foo.clone();\n+    ///\n+    /// drop(weak_foo);   // Doesn't print anything\n+    /// drop(foo);        // Prints \"dropped!\"\n     ///\n-    /// } // implicit drop\n+    /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n@@ -868,9 +1035,10 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak<T>`.\n+    /// Makes a clone of the `Weak` pointer.\n     ///\n-    /// This increases the weak reference count.\n+    /// This creates another pointer to the same inner value, increasing the\n+    /// weak reference count.\n     ///\n     /// # Examples\n     ///\n@@ -897,7 +1065,23 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n \n #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n impl<T> Default for Weak<T> {\n-    /// Creates a new `Weak<T>`.\n+    /// Constructs a new `Weak<T>`, without an accompanying instance of `T`.\n+    ///\n+    /// This allocates memory for `T`, but does not initialize it. Calling\n+    /// [`upgrade`][upgrade] on the return value always gives\n+    /// [`None`][option].\n+    ///\n+    /// [upgrade]: struct.Weak.html#method.upgrade\n+    /// [option]: ../../std/option/enum.Option.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::rc::Weak;\n+    ///\n+    /// let empty: Weak<i64> = Default::default();\n+    /// assert!(empty.upgrade().is_none());\n+    /// ```\n     fn default() -> Weak<T> {\n         Weak::new()\n     }"}, {"sha": "08a1f8ae8c6caf9d33915fe25bcb6e2649196358", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -22,11 +22,25 @@ fn main() {\n     println!(\"cargo:rustc-cfg=cargobuild\");\n     println!(\"cargo:rerun-if-changed=build.rs\");\n \n-    let target = env::var(\"TARGET\").unwrap();\n-    let host = env::var(\"HOST\").unwrap();\n+    let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n+    let host = env::var(\"HOST\").expect(\"HOST was not set\");\n     let build_dir = PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n     let src_dir = env::current_dir().unwrap();\n \n+    // FIXME: This is a hack to support building targets that don't\n+    // support jemalloc alongside hosts that do. The jemalloc build is\n+    // controlled by a feature of the std crate, and if that feature\n+    // changes between targets, it invalidates the fingerprint of\n+    // std's build script (this is a cargo bug); so we must ensure\n+    // that the feature set used by std is the same across all\n+    // targets, which means we have to build the alloc_jemalloc crate\n+    // for targets like emscripten, even if we don't use it.\n+    if target.contains(\"rumprun\") || target.contains(\"bitrig\") || target.contains(\"openbsd\") ||\n+       target.contains(\"msvc\") || target.contains(\"emscripten\") || target.contains(\"fuchsia\") {\n+        println!(\"cargo:rustc-cfg=dummy_jemalloc\");\n+        return;\n+    }\n+\n     if let Some(jemalloc) = env::var_os(\"JEMALLOC_OVERRIDE\") {\n         let jemalloc = PathBuf::from(jemalloc);\n         println!(\"cargo:rustc-link-search=native={}\",\n@@ -46,16 +60,16 @@ fn main() {\n     // only msvc returns None for ar so unwrap is okay\n     let ar = build_helper::cc2ar(compiler.path(), &target).unwrap();\n     let cflags = compiler.args()\n-                         .iter()\n-                         .map(|s| s.to_str().unwrap())\n-                         .collect::<Vec<_>>()\n-                         .join(\" \");\n+        .iter()\n+        .map(|s| s.to_str().unwrap())\n+        .collect::<Vec<_>>()\n+        .join(\" \");\n \n     let mut stack = src_dir.join(\"../jemalloc\")\n-                           .read_dir()\n-                           .unwrap()\n-                           .map(|e| e.unwrap())\n-                           .collect::<Vec<_>>();\n+        .read_dir()\n+        .unwrap()\n+        .map(|e| e.unwrap())\n+        .collect::<Vec<_>>();\n     while let Some(entry) = stack.pop() {\n         let path = entry.path();\n         if entry.file_type().unwrap().is_dir() {\n@@ -137,10 +151,10 @@ fn main() {\n \n     run(&mut cmd);\n     run(Command::new(\"make\")\n-            .current_dir(&build_dir)\n-            .arg(\"build_lib_static\")\n-            .arg(\"-j\")\n-            .arg(env::var(\"NUM_JOBS\").unwrap()));\n+        .current_dir(&build_dir)\n+        .arg(\"build_lib_static\")\n+        .arg(\"-j\")\n+        .arg(env::var(\"NUM_JOBS\").expect(\"NUM_JOBS was not set\")));\n \n     if target.contains(\"windows\") {\n         println!(\"cargo:rustc-link-lib=static=jemalloc\");"}, {"sha": "21e45f9c4b20c81598c7629da18deeedc31941b4", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 154, "deletions": 108, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -23,124 +23,170 @@\n \n extern crate libc;\n \n-use libc::{c_int, c_void, size_t};\n+pub use imp::*;\n \n-// Linkage directives to pull in jemalloc and its dependencies.\n-//\n-// On some platforms we need to be sure to link in `pthread` which jemalloc\n-// depends on, and specifically on android we need to also link to libgcc.\n-// Currently jemalloc is compiled with gcc which will generate calls to\n-// intrinsics that are libgcc specific (e.g. those intrinsics aren't present in\n-// libcompiler-rt), so link that in to get that support.\n-#[link(name = \"jemalloc\", kind = \"static\")]\n-#[cfg_attr(target_os = \"android\", link(name = \"gcc\"))]\n-#[cfg_attr(all(not(windows),\n-               not(target_os = \"android\"),\n-               not(target_env = \"musl\")),\n-           link(name = \"pthread\"))]\n-#[cfg(not(cargobuild))]\n-extern \"C\" {}\n-\n-// Note that the symbols here are prefixed by default on OSX and Windows (we\n-// don't explicitly request it), and on Android and DragonFly we explicitly\n-// request it as unprefixing cause segfaults (mismatches in allocators).\n-extern \"C\" {\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n-                   target_os = \"dragonfly\", target_os = \"windows\"),\n-               link_name = \"je_mallocx\")]\n-    fn mallocx(size: size_t, flags: c_int) -> *mut c_void;\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n-                   target_os = \"dragonfly\", target_os = \"windows\"),\n-               link_name = \"je_rallocx\")]\n-    fn rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n-                   target_os = \"dragonfly\", target_os = \"windows\"),\n-               link_name = \"je_xallocx\")]\n-    fn xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n-                   target_os = \"dragonfly\", target_os = \"windows\"),\n-               link_name = \"je_sdallocx\")]\n-    fn sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n-    #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n-                   target_os = \"dragonfly\", target_os = \"windows\"),\n-               link_name = \"je_nallocx\")]\n-    fn nallocx(size: size_t, flags: c_int) -> size_t;\n-}\n+// See comments in build.rs for why we sometimes build a crate that does nothing\n+#[cfg(not(dummy_jemalloc))]\n+mod imp {\n+    use libc::{c_int, c_void, size_t};\n \n-// The minimum alignment guaranteed by the architecture. This value is used to\n-// add fast paths for low alignment values. In practice, the alignment is a\n-// constant at the call site and the branch will be optimized out.\n-#[cfg(all(any(target_arch = \"arm\",\n-              target_arch = \"mips\",\n-              target_arch = \"powerpc\")))]\n-const MIN_ALIGN: usize = 8;\n-#[cfg(all(any(target_arch = \"x86\",\n-              target_arch = \"x86_64\",\n-              target_arch = \"aarch64\",\n-              target_arch = \"powerpc64\",\n-              target_arch = \"mips64\",\n-              target_arch = \"s390x\")))]\n-const MIN_ALIGN: usize = 16;\n-\n-// MALLOCX_ALIGN(a) macro\n-fn mallocx_align(a: usize) -> c_int {\n-    a.trailing_zeros() as c_int\n-}\n+    // Linkage directives to pull in jemalloc and its dependencies.\n+    //\n+    // On some platforms we need to be sure to link in `pthread` which jemalloc\n+    // depends on, and specifically on android we need to also link to libgcc.\n+    // Currently jemalloc is compiled with gcc which will generate calls to\n+    // intrinsics that are libgcc specific (e.g. those intrinsics aren't present in\n+    // libcompiler-rt), so link that in to get that support.\n+    #[link(name = \"jemalloc\", kind = \"static\")]\n+    #[cfg_attr(target_os = \"android\", link(name = \"gcc\"))]\n+    #[cfg_attr(all(not(windows),\n+                   not(target_os = \"android\"),\n+                   not(target_env = \"musl\")),\n+               link(name = \"pthread\"))]\n+    #[cfg(not(cargobuild))]\n+    extern \"C\" {}\n+\n+    // Note that the symbols here are prefixed by default on OSX and Windows (we\n+    // don't explicitly request it), and on Android and DragonFly we explicitly\n+    // request it as unprefixing cause segfaults (mismatches in allocators).\n+    extern \"C\" {\n+        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                       target_os = \"dragonfly\", target_os = \"windows\"),\n+                   link_name = \"je_mallocx\")]\n+        fn mallocx(size: size_t, flags: c_int) -> *mut c_void;\n+        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                       target_os = \"dragonfly\", target_os = \"windows\"),\n+                   link_name = \"je_rallocx\")]\n+        fn rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n+        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                       target_os = \"dragonfly\", target_os = \"windows\"),\n+                   link_name = \"je_xallocx\")]\n+        fn xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n+        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                       target_os = \"dragonfly\", target_os = \"windows\"),\n+                   link_name = \"je_sdallocx\")]\n+        fn sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n+        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                       target_os = \"dragonfly\", target_os = \"windows\"),\n+                   link_name = \"je_nallocx\")]\n+        fn nallocx(size: size_t, flags: c_int) -> size_t;\n+    }\n+\n+    // The minimum alignment guaranteed by the architecture. This value is used to\n+    // add fast paths for low alignment values. In practice, the alignment is a\n+    // constant at the call site and the branch will be optimized out.\n+    #[cfg(all(any(target_arch = \"arm\",\n+                  target_arch = \"mips\",\n+                  target_arch = \"powerpc\")))]\n+    const MIN_ALIGN: usize = 8;\n+    #[cfg(all(any(target_arch = \"x86\",\n+                  target_arch = \"x86_64\",\n+                  target_arch = \"aarch64\",\n+                  target_arch = \"powerpc64\",\n+                  target_arch = \"mips64\",\n+                  target_arch = \"s390x\")))]\n+    const MIN_ALIGN: usize = 16;\n+\n+    // MALLOCX_ALIGN(a) macro\n+    fn mallocx_align(a: usize) -> c_int {\n+        a.trailing_zeros() as c_int\n+    }\n+\n+    fn align_to_flags(align: usize) -> c_int {\n+        if align <= MIN_ALIGN {\n+            0\n+        } else {\n+            mallocx_align(align)\n+        }\n+    }\n+\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n+        let flags = align_to_flags(align);\n+        unsafe { mallocx(size as size_t, flags) as *mut u8 }\n+    }\n+\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_reallocate(ptr: *mut u8,\n+                                        _old_size: usize,\n+                                        size: usize,\n+                                        align: usize)\n+                                        -> *mut u8 {\n+        let flags = align_to_flags(align);\n+        unsafe { rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8 }\n+    }\n+\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_reallocate_inplace(ptr: *mut u8,\n+                                                _old_size: usize,\n+                                                size: usize,\n+                                                align: usize)\n+                                                -> usize {\n+        let flags = align_to_flags(align);\n+        unsafe { xallocx(ptr as *mut c_void, size as size_t, 0, flags) as usize }\n+    }\n \n-fn align_to_flags(align: usize) -> c_int {\n-    if align <= MIN_ALIGN {\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n+        let flags = align_to_flags(align);\n+        unsafe { sdallocx(ptr as *mut c_void, old_size as size_t, flags) }\n+    }\n+\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n+        let flags = align_to_flags(align);\n+        unsafe { nallocx(size as size_t, flags) as usize }\n+    }\n+\n+    // These symbols are used by jemalloc on android but the really old android\n+    // we're building on doesn't have them defined, so just make sure the symbols\n+    // are available.\n+    #[no_mangle]\n+    #[cfg(target_os = \"android\")]\n+    pub extern \"C\" fn pthread_atfork(_prefork: *mut u8,\n+                                     _postfork_parent: *mut u8,\n+                                     _postfork_child: *mut u8)\n+                                     -> i32 {\n         0\n-    } else {\n-        mallocx_align(align)\n     }\n }\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n-    let flags = align_to_flags(align);\n-    unsafe { mallocx(size as size_t, flags) as *mut u8 }\n-}\n+#[cfg(dummy_jemalloc)]\n+mod imp {\n+    fn bogus() -> ! {\n+        panic!(\"jemalloc is not implemented for this platform\");\n+    }\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_reallocate(ptr: *mut u8,\n-                                    _old_size: usize,\n-                                    size: usize,\n-                                    align: usize)\n-                                    -> *mut u8 {\n-    let flags = align_to_flags(align);\n-    unsafe { rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8 }\n-}\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_allocate(_size: usize, _align: usize) -> *mut u8 {\n+        bogus()\n+    }\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_reallocate_inplace(ptr: *mut u8,\n-                                            _old_size: usize,\n-                                            size: usize,\n-                                            align: usize)\n-                                            -> usize {\n-    let flags = align_to_flags(align);\n-    unsafe { xallocx(ptr as *mut c_void, size as size_t, 0, flags) as usize }\n-}\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_reallocate(_ptr: *mut u8,\n+                                        _old_size: usize,\n+                                        _size: usize,\n+                                        _align: usize)\n+                                        -> *mut u8 {\n+        bogus()\n+    }\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n-    let flags = align_to_flags(align);\n-    unsafe { sdallocx(ptr as *mut c_void, old_size as size_t, flags) }\n-}\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_reallocate_inplace(_ptr: *mut u8,\n+                                                _old_size: usize,\n+                                                _size: usize,\n+                                                _align: usize)\n+                                                -> usize {\n+        bogus()\n+    }\n \n-#[no_mangle]\n-pub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n-    let flags = align_to_flags(align);\n-    unsafe { nallocx(size as size_t, flags) as usize }\n-}\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_deallocate(_ptr: *mut u8, _old_size: usize, _align: usize) {\n+        bogus()\n+    }\n \n-// These symbols are used by jemalloc on android but the really old android\n-// we're building on doesn't have them defined, so just make sure the symbols\n-// are available.\n-#[no_mangle]\n-#[cfg(target_os = \"android\")]\n-pub extern \"C\" fn pthread_atfork(_prefork: *mut u8,\n-                                 _postfork_parent: *mut u8,\n-                                 _postfork_child: *mut u8)\n-                                 -> i32 {\n-    0\n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_usable_size(_size: usize, _align: usize) -> usize {\n+        bogus()\n+    }\n }"}, {"sha": "a4fabb5a2c96dbd69dc39340f1bdfb8ffea8250a", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -29,7 +29,8 @@\n               target_arch = \"mips\",\n               target_arch = \"powerpc\",\n               target_arch = \"powerpc64\",\n-              target_arch = \"asmjs\")))]\n+              target_arch = \"asmjs\",\n+              target_arch = \"wasm32\")))]\n const MIN_ALIGN: usize = 8;\n #[cfg(all(any(target_arch = \"x86_64\",\n               target_arch = \"aarch64\",\n@@ -165,6 +166,7 @@ mod imp {\n         fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n         fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n         fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n+        fn GetLastError() -> DWORD;\n     }\n \n     #[repr(C)]\n@@ -220,11 +222,7 @@ mod imp {\n                                   HEAP_REALLOC_IN_PLACE_ONLY,\n                                   ptr as LPVOID,\n                                   size as SIZE_T) as *mut u8;\n-            if new.is_null() {\n-                old_size\n-            } else {\n-                size\n-            }\n+            if new.is_null() { old_size } else { size }\n         } else {\n             old_size\n         }\n@@ -233,11 +231,11 @@ mod imp {\n     pub unsafe fn deallocate(ptr: *mut u8, _old_size: usize, align: usize) {\n         if align <= MIN_ALIGN {\n             let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n-            debug_assert!(err != 0);\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\", GetLastError());\n         } else {\n             let header = get_header(ptr);\n             let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n-            debug_assert!(err != 0);\n+            debug_assert!(err != 0, \"Failed to free heap memory: {}\", GetLastError());\n         }\n     }\n "}, {"sha": "6044bec2c5af7126873a0ad7ce2b95439e8d4c7f", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 90, "deletions": 50, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -15,9 +15,8 @@\n //! of individual objects while the arena itself is still alive. The benefit\n //! of an arena is very fast allocation; just a pointer bump.\n //!\n-//! This crate has two arenas implemented: `TypedArena`, which is a simpler\n-//! arena but can only hold objects of a single type, and `Arena`, which is a\n-//! more complex, slower arena which can hold objects of any type.\n+//! This crate implements `TypedArena`, a simple arena that can only hold\n+//! objects of a single type.\n \n #![crate_name = \"arena\"]\n #![unstable(feature = \"rustc_private\", issue = \"27812\")]\n@@ -47,11 +46,12 @@ use std::intrinsics;\n use std::marker::{PhantomData, Send};\n use std::mem;\n use std::ptr;\n+use std::slice;\n \n use alloc::heap;\n use alloc::raw_vec::RawVec;\n \n-/// A faster arena that can hold objects of only one type.\n+/// An arena that can hold objects of only one type.\n pub struct TypedArena<T> {\n     /// A pointer to the next object to be allocated.\n     ptr: Cell<*mut T>,\n@@ -60,7 +60,7 @@ pub struct TypedArena<T> {\n     /// reached, a new chunk is allocated.\n     end: Cell<*mut T>,\n \n-    /// A vector arena segments.\n+    /// A vector of arena chunks.\n     chunks: RefCell<Vec<TypedArenaChunk<T>>>,\n \n     /// Marker indicating that dropping the arena causes its owned\n@@ -69,7 +69,7 @@ pub struct TypedArena<T> {\n }\n \n struct TypedArenaChunk<T> {\n-    /// Pointer to the next arena segment.\n+    /// The raw storage for the arena chunk.\n     storage: RawVec<T>,\n }\n \n@@ -117,34 +117,24 @@ impl<T> TypedArenaChunk<T> {\n const PAGE: usize = 4096;\n \n impl<T> TypedArena<T> {\n-    /// Creates a new `TypedArena` with preallocated space for many objects.\n+    /// Creates a new `TypedArena`.\n     #[inline]\n     pub fn new() -> TypedArena<T> {\n-        // Reserve at least one page.\n-        let elem_size = cmp::max(1, mem::size_of::<T>());\n-        TypedArena::with_capacity(PAGE / elem_size)\n-    }\n-\n-    /// Creates a new `TypedArena` with preallocated space for the given number of\n-    /// objects.\n-    #[inline]\n-    pub fn with_capacity(capacity: usize) -> TypedArena<T> {\n-        unsafe {\n-            let chunk = TypedArenaChunk::<T>::new(cmp::max(1, capacity));\n-            TypedArena {\n-                ptr: Cell::new(chunk.start()),\n-                end: Cell::new(chunk.end()),\n-                chunks: RefCell::new(vec![chunk]),\n-                _own: PhantomData,\n-            }\n+        TypedArena {\n+            // We set both `ptr` and `end` to 0 so that the first call to\n+            // alloc() will trigger a grow().\n+            ptr: Cell::new(0 as *mut T),\n+            end: Cell::new(0 as *mut T),\n+            chunks: RefCell::new(vec![]),\n+            _own: PhantomData,\n         }\n     }\n \n     /// Allocates an object in the `TypedArena`, returning a reference to it.\n     #[inline]\n     pub fn alloc(&self, object: T) -> &mut T {\n         if self.ptr == self.end {\n-            self.grow()\n+            self.grow(1)\n         }\n \n         unsafe {\n@@ -165,35 +155,79 @@ impl<T> TypedArena<T> {\n         }\n     }\n \n+    /// Allocates a slice of objects that are copy into the `TypedArena`, returning a mutable\n+    /// reference to it. Will panic if passed a zero-sized types.\n+    ///\n+    /// Panics:\n+    ///  - Zero-sized types\n+    ///  - Zero-length slices\n+    #[inline]\n+    pub fn alloc_slice(&self, slice: &[T]) -> &mut [T]\n+        where T: Copy {\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(slice.len() != 0);\n+\n+        let available_capacity_bytes = self.end.get() as usize - self.ptr.get() as usize;\n+        let at_least_bytes = slice.len() * mem::size_of::<T>();\n+        if available_capacity_bytes < at_least_bytes {\n+            self.grow(slice.len());\n+        }\n+\n+        unsafe {\n+            let start_ptr = self.ptr.get();\n+            let arena_slice = slice::from_raw_parts_mut(start_ptr, slice.len());\n+            self.ptr.set(start_ptr.offset(arena_slice.len() as isize));\n+            arena_slice.copy_from_slice(slice);\n+            arena_slice\n+        }\n+    }\n+\n     /// Grows the arena.\n     #[inline(never)]\n     #[cold]\n-    fn grow(&self) {\n+    fn grow(&self, n: usize) {\n         unsafe {\n             let mut chunks = self.chunks.borrow_mut();\n-            let prev_capacity = chunks.last().unwrap().storage.cap();\n-            let new_capacity = prev_capacity.checked_mul(2).unwrap();\n-            if chunks.last_mut().unwrap().storage.double_in_place() {\n-                self.end.set(chunks.last().unwrap().end());\n+            let (chunk, mut new_capacity);\n+            if let Some(last_chunk) = chunks.last_mut() {\n+                let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n+                let currently_used_cap = used_bytes / mem::size_of::<T>();\n+                if last_chunk.storage.reserve_in_place(currently_used_cap, n) {\n+                    self.end.set(last_chunk.end());\n+                    return;\n+                } else {\n+                    let prev_capacity = last_chunk.storage.cap();\n+                    loop {\n+                        new_capacity = prev_capacity.checked_mul(2).unwrap();\n+                        if new_capacity >= currently_used_cap + n {\n+                            break;\n+                        }\n+                    }\n+                }\n             } else {\n-                let chunk = TypedArenaChunk::<T>::new(new_capacity);\n-                self.ptr.set(chunk.start());\n-                self.end.set(chunk.end());\n-                chunks.push(chunk);\n+                let elem_size = cmp::max(1, mem::size_of::<T>());\n+                new_capacity = cmp::max(n, PAGE / elem_size);\n             }\n+            chunk = TypedArenaChunk::<T>::new(new_capacity);\n+            self.ptr.set(chunk.start());\n+            self.end.set(chunk.end());\n+            chunks.push(chunk);\n         }\n     }\n+\n     /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n     pub fn clear(&mut self) {\n         unsafe {\n             // Clear the last chunk, which is partially filled.\n             let mut chunks_borrow = self.chunks.borrow_mut();\n-            let last_idx = chunks_borrow.len() - 1;\n-            self.clear_last_chunk(&mut chunks_borrow[last_idx]);\n-            // If `T` is ZST, code below has no effect.\n-            for mut chunk in chunks_borrow.drain(..last_idx) {\n-                let cap = chunk.storage.cap();\n-                chunk.destroy(cap);\n+            if let Some(mut last_chunk) = chunks_borrow.pop() {\n+                self.clear_last_chunk(&mut last_chunk);\n+                // If `T` is ZST, code below has no effect.\n+                for mut chunk in chunks_borrow.drain(..) {\n+                    let cap = chunk.storage.cap();\n+                    chunk.destroy(cap);\n+                }\n+                chunks_borrow.push(last_chunk);\n             }\n         }\n     }\n@@ -230,13 +264,14 @@ impl<T> Drop for TypedArena<T> {\n         unsafe {\n             // Determine how much was filled.\n             let mut chunks_borrow = self.chunks.borrow_mut();\n-            let mut last_chunk = chunks_borrow.pop().unwrap();\n-            // Drop the contents of the last chunk.\n-            self.clear_last_chunk(&mut last_chunk);\n-            // The last chunk will be dropped. Destroy all other chunks.\n-            for chunk in chunks_borrow.iter_mut() {\n-                let cap = chunk.storage.cap();\n-                chunk.destroy(cap);\n+            if let Some(mut last_chunk) = chunks_borrow.pop() {\n+                // Drop the contents of the last chunk.\n+                self.clear_last_chunk(&mut last_chunk);\n+                // The last chunk will be dropped. Destroy all other chunks.\n+                for chunk in chunks_borrow.iter_mut() {\n+                    let cap = chunk.storage.cap();\n+                    chunk.destroy(cap);\n+                }\n             }\n             // RawVec handles deallocation of `last_chunk` and `self.chunks`.\n         }\n@@ -260,6 +295,12 @@ mod tests {\n         z: i32,\n     }\n \n+    #[test]\n+    pub fn test_unused() {\n+        let arena: TypedArena<Point> = TypedArena::new();\n+        assert!(arena.chunks.borrow().is_empty());\n+    }\n+\n     #[test]\n     fn test_arena_alloc_nested() {\n         struct Inner {\n@@ -296,9 +337,8 @@ mod tests {\n \n         let arena = Wrap(TypedArena::new());\n \n-        let result = arena.alloc_outer(|| {\n-            Outer { inner: arena.alloc_inner(|| Inner { value: 10 }) }\n-        });\n+        let result =\n+            arena.alloc_outer(|| Outer { inner: arena.alloc_inner(|| Inner { value: 10 }) });\n \n         assert_eq!(result.inner.value, 10);\n     }"}, {"sha": "b4be8a43213d8dbf4974f18c7fd73d5ad7b02ed5", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -535,6 +535,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// #![feature(binary_heap_extras)]\n+    /// #![allow(deprecated)]\n     ///\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n@@ -549,6 +550,7 @@ impl<T: Ord> BinaryHeap<T> {\n     #[unstable(feature = \"binary_heap_extras\",\n                reason = \"needs to be audited\",\n                issue = \"28147\")]\n+    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `peek_mut` instead\")]\n     pub fn push_pop(&mut self, mut item: T) -> T {\n         match self.data.get_mut(0) {\n             None => return item,\n@@ -575,6 +577,7 @@ impl<T: Ord> BinaryHeap<T> {\n     ///\n     /// ```\n     /// #![feature(binary_heap_extras)]\n+    /// #![allow(deprecated)]\n     ///\n     /// use std::collections::BinaryHeap;\n     /// let mut heap = BinaryHeap::new();\n@@ -587,6 +590,7 @@ impl<T: Ord> BinaryHeap<T> {\n     #[unstable(feature = \"binary_heap_extras\",\n                reason = \"needs to be audited\",\n                issue = \"28147\")]\n+    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `peek_mut` instead\")]\n     pub fn replace(&mut self, mut item: T) -> Option<T> {\n         if !self.is_empty() {\n             swap(&mut item, &mut self.data[0]);\n@@ -1029,7 +1033,7 @@ pub struct Drain<'a, T: 'a> {\n     iter: vec::Drain<'a, T>,\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -1044,15 +1048,15 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.iter.next_back()\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]"}, {"sha": "8f9c35783379133e98a31bc58c9d1c086d0e936e", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 62, "deletions": 3, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -14,7 +14,7 @@\n \n use core::cmp::Ordering;\n use core::hash::{Hash, Hasher};\n-use core::ops::Deref;\n+use core::ops::{Add, AddAssign, Deref};\n \n use fmt;\n \n@@ -86,16 +86,29 @@ impl<T> ToOwned for T where T: Clone {\n /// ```\n /// use std::borrow::Cow;\n ///\n-/// # #[allow(dead_code)]\n /// fn abs_all(input: &mut Cow<[i32]>) {\n ///     for i in 0..input.len() {\n ///         let v = input[i];\n ///         if v < 0 {\n-///             // clones into a vector the first time (if not already owned)\n+///             // Clones into a vector if not already owned.\n ///             input.to_mut()[i] = -v;\n ///         }\n ///     }\n /// }\n+///\n+/// // No clone occurs because `input` doesn't need to be mutated.\n+/// let slice = [0, 1, 2];\n+/// let mut input = Cow::from(&slice[..]);\n+/// abs_all(&mut input);\n+///\n+/// // Clone occurs because `input` needs to be mutated.\n+/// let slice = [-1, 0, 1];\n+/// let mut input = Cow::from(&slice[..]);\n+/// abs_all(&mut input);\n+///\n+/// // No clone occurs because `input` is already owned.\n+/// let mut input = Cow::from(vec![-1, 0, 1]);\n+/// abs_all(&mut input);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Cow<'a, B: ?Sized + 'a>\n@@ -270,3 +283,49 @@ impl<'a, T: ?Sized + ToOwned> AsRef<T> for Cow<'a, T> {\n         self\n     }\n }\n+\n+#[stable(feature = \"cow_add\", since = \"1.13.0\")]\n+impl<'a> Add<&'a str> for Cow<'a, str> {\n+    type Output = Cow<'a, str>;\n+\n+    fn add(self, rhs: &'a str) -> Self {\n+        if self == \"\" {\n+            Cow::Borrowed(rhs)\n+        } else if rhs == \"\" {\n+            self\n+        } else {\n+            Cow::Owned(self.into_owned() + rhs)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"cow_add\", since = \"1.13.0\")]\n+impl<'a> Add<Cow<'a, str>> for Cow<'a, str> {\n+    type Output = Cow<'a, str>;\n+\n+    fn add(self, rhs: Cow<'a, str>) -> Self {\n+        if self == \"\" {\n+            rhs\n+        } else if rhs == \"\" {\n+            self\n+        } else {\n+            Cow::Owned(self.into_owned() + rhs.borrow())\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"cow_add\", since = \"1.13.0\")]\n+impl<'a> AddAssign<&'a str> for Cow<'a, str> {\n+    fn add_assign(&mut self, rhs: &'a str) {\n+        if rhs == \"\" { return; }\n+        self.to_mut().push_str(rhs);\n+    }\n+}\n+\n+#[stable(feature = \"cow_add\", since = \"1.13.0\")]\n+impl<'a> AddAssign<Cow<'a, str>> for Cow<'a, str> {\n+    fn add_assign(&mut self, rhs: Cow<'a, str>) {\n+        if rhs == \"\" { return; }\n+        self.to_mut().push_str(rhs.borrow());\n+    }\n+}"}, {"sha": "788236c24d063a75a00b86cfbc496a1df1f5b6e8", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -136,6 +136,7 @@ pub struct BTreeMap<K, V> {\n     length: usize,\n }\n \n+#[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n impl<K, V> Drop for BTreeMap<K, V> {\n     #[unsafe_destructor_blind_to_params]\n     fn drop(&mut self) {\n@@ -146,6 +147,7 @@ impl<K, V> Drop for BTreeMap<K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n     fn clone(&self) -> BTreeMap<K, V> {\n         fn clone_subtree<K: Clone, V: Clone>(node: node::NodeRef<marker::Immut,\n@@ -1125,6 +1127,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K: 'a, V: 'a> IntoIterator for &'a BTreeMap<K, V> {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n@@ -1134,6 +1137,7 @@ impl<'a, K: 'a, V: 'a> IntoIterator for &'a BTreeMap<K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n     type Item = (&'a K, &'a V);\n \n@@ -1154,6 +1158,7 @@ impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for Iter<'a, K, V> {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K: 'a, V: 'a> DoubleEndedIterator for Iter<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n         if self.length == 0 {\n@@ -1165,12 +1170,14 @@ impl<'a, K: 'a, V: 'a> DoubleEndedIterator for Iter<'a, K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K: 'a, V: 'a> ExactSizeIterator for Iter<'a, K, V> {\n     fn len(&self) -> usize {\n         self.length\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Clone for Iter<'a, K, V> {\n     fn clone(&self) -> Iter<'a, K, V> {\n         Iter {\n@@ -1180,6 +1187,7 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K: 'a, V: 'a> IntoIterator for &'a mut BTreeMap<K, V> {\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;\n@@ -1189,6 +1197,7 @@ impl<'a, K: 'a, V: 'a> IntoIterator for &'a mut BTreeMap<K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n     type Item = (&'a K, &'a mut V);\n \n@@ -1206,6 +1215,7 @@ impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K: 'a, V: 'a> DoubleEndedIterator for IterMut<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a mut V)> {\n         if self.length == 0 {\n@@ -1217,6 +1227,7 @@ impl<'a, K: 'a, V: 'a> DoubleEndedIterator for IterMut<'a, K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K: 'a, V: 'a> ExactSizeIterator for IterMut<'a, K, V> {\n     fn len(&self) -> usize {\n         self.length\n@@ -1226,6 +1237,7 @@ impl<'a, K: 'a, V: 'a> ExactSizeIterator for IterMut<'a, K, V> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for IterMut<'a, K, V> {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> IntoIterator for BTreeMap<K, V> {\n     type Item = (K, V);\n     type IntoIter = IntoIter<K, V>;\n@@ -1244,6 +1256,7 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     }\n }\n \n+#[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n impl<K, V> Drop for IntoIter<K, V> {\n     fn drop(&mut self) {\n         for _ in &mut *self {\n@@ -1260,6 +1273,7 @@ impl<K, V> Drop for IntoIter<K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n@@ -1304,6 +1318,7 @@ impl<K, V> Iterator for IntoIter<K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> {\n         if self.length == 0 {\n@@ -1342,6 +1357,7 @@ impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n     fn len(&self) -> usize {\n         self.length\n@@ -1351,6 +1367,7 @@ impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<K, V> FusedIterator for IntoIter<K, V> {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     type Item = &'a K;\n \n@@ -1363,12 +1380,14 @@ impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n     fn next_back(&mut self) -> Option<&'a K> {\n         self.inner.next_back().map(|(k, _)| k)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n     fn len(&self) -> usize {\n         self.inner.len()\n@@ -1378,12 +1397,14 @@ impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for Keys<'a, K, V> {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Clone for Keys<'a, K, V> {\n     fn clone(&self) -> Keys<'a, K, V> {\n         Keys { inner: self.inner.clone() }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Iterator for Values<'a, K, V> {\n     type Item = &'a V;\n \n@@ -1396,12 +1417,14 @@ impl<'a, K, V> Iterator for Values<'a, K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n     fn next_back(&mut self) -> Option<&'a V> {\n         self.inner.next_back().map(|(_, v)| v)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n     fn len(&self) -> usize {\n         self.inner.len()\n@@ -1411,6 +1434,7 @@ impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, K, V> FusedIterator for Values<'a, K, V> {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Clone for Values<'a, K, V> {\n     fn clone(&self) -> Values<'a, K, V> {\n         Values { inner: self.inner.clone() }\n@@ -1635,6 +1659,7 @@ impl<'a, K, V> RangeMut<'a, K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n     fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> BTreeMap<K, V> {\n         let mut map = BTreeMap::new();\n@@ -1643,6 +1668,7 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n     fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n@@ -1652,12 +1678,14 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n+#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n     fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         for elt in self {\n@@ -1666,41 +1694,48 @@ impl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Default for BTreeMap<K, V> {\n     /// Creates an empty `BTreeMap<K, V>`.\n     fn default() -> BTreeMap<K, V> {\n         BTreeMap::new()\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: PartialEq, V: PartialEq> PartialEq for BTreeMap<K, V> {\n     fn eq(&self, other: &BTreeMap<K, V>) -> bool {\n         self.len() == other.len() && self.iter().zip(other).all(|(a, b)| a == b)\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Eq, V: Eq> Eq for BTreeMap<K, V> {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: PartialOrd, V: PartialOrd> PartialOrd for BTreeMap<K, V> {\n     #[inline]\n     fn partial_cmp(&self, other: &BTreeMap<K, V>) -> Option<Ordering> {\n         self.iter().partial_cmp(other.iter())\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n     #[inline]\n     fn cmp(&self, other: &BTreeMap<K, V>) -> Ordering {\n         self.iter().cmp(other.iter())\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_map().entries(self.iter()).finish()\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n     where K: Borrow<Q>,\n           Q: Ord"}, {"sha": "c57266d9e3b4a5b013a97842bac3ef044220836a", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -779,6 +779,7 @@ impl<T: Debug> Debug for BTreeSet<T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> {\n         Iter { iter: self.iter.clone() }\n@@ -864,6 +865,7 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Difference<'a, T> {\n     fn clone(&self) -> Difference<'a, T> {\n         Difference {\n@@ -901,6 +903,7 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T: Ord> FusedIterator for Difference<'a, T> {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for SymmetricDifference<'a, T> {\n     fn clone(&self) -> SymmetricDifference<'a, T> {\n         SymmetricDifference {\n@@ -934,6 +937,7 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T: Ord> FusedIterator for SymmetricDifference<'a, T> {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Intersection<'a, T> {\n     fn clone(&self) -> Intersection<'a, T> {\n         Intersection {\n@@ -977,6 +981,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T: Ord> FusedIterator for Intersection<'a, T> {}\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Union<'a, T> {\n     fn clone(&self) -> Union<'a, T> {\n         Union {"}, {"sha": "2d12b4ccffe01aa246611dd2afa3fb51b86052ef", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -48,7 +48,6 @@ impl<E> Clone for EnumSet<E> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<E: CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt.debug_set().entries(self).finish()\n@@ -277,7 +276,6 @@ impl<E: CLike> FromIterator<E> for EnumSet<E> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, E> IntoIterator for &'a EnumSet<E> where E: CLike\n {\n     type Item = E;\n@@ -296,7 +294,6 @@ impl<E: CLike> Extend<E> for EnumSet<E> {\n     }\n }\n \n-#[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, E: 'a + CLike + Copy> Extend<&'a E> for EnumSet<E> {\n     fn extend<I: IntoIterator<Item = &'a E>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());"}, {"sha": "883417e9f4ec76c90bcc9f3e4dbc7dc32dafe1cb", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -261,8 +261,8 @@\n //! This and `writeln` are two macros which are used to emit the format string\n //! to a specified stream. This is used to prevent intermediate allocations of\n //! format strings and instead directly write the output. Under the hood, this\n-//! function is actually invoking the `write` function defined in this module.\n-//! Example usage is:\n+//! function is actually invoking the `write_fmt` function defined on the\n+//! `std::io::Write` trait. Example usage is:\n //!\n //! ```\n //! # #![allow(unused_must_use)]\n@@ -327,7 +327,7 @@\n //! format := '{' [ argument ] [ ':' format_spec ] '}'\n //! argument := integer | identifier\n //!\n-//! format_spec := [[fill]align][sign]['#'][0][width]['.' precision][type]\n+//! format_spec := [[fill]align][sign]['#']['0'][width]['.' precision][type]\n //! fill := character\n //! align := '<' | '^' | '>'\n //! sign := '+' | '-'"}, {"sha": "990de541b6783db047df209c0c013f7c5502bca7", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -52,7 +52,6 @@\n #![feature(step_by)]\n #![feature(unicode)]\n #![feature(unique)]\n-#![cfg_attr(stage0, feature(unsafe_no_drop_flag))]\n #![cfg_attr(test, feature(rand, test))]\n \n #![no_std]"}, {"sha": "67f3708a62b91dbf50e83d6bf98fcb5842f967b0", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -1294,6 +1294,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_send() {\n         let n = list_from(&[1, 2, 3]);\n         thread::spawn(move || {"}, {"sha": "3115be00a4d720094fe846219a7d8d91470d924f", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -68,7 +68,9 @@ macro_rules! vec {\n }\n \n /// Use the syntax described in `std::fmt` to create a value of type `String`.\n-/// See `std::fmt` for more information.\n+/// See [`std::fmt`][fmt] for more information.\n+///\n+/// [fmt]: ../std/fmt/index.html\n ///\n /// # Examples\n ///"}, {"sha": "75796cf94bfc2bbc37a2915284dad4f040cb5e0c", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 46, "deletions": 32, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -36,17 +36,17 @@\n //!\n //! ## Structs\n //!\n-//! There are several structs that are useful for slices, such as `Iter`, which\n+//! There are several structs that are useful for slices, such as [`Iter`], which\n //! represents iteration over a slice.\n //!\n //! ## Trait Implementations\n //!\n //! There are several implementations of common traits for slices. Some examples\n //! include:\n //!\n-//! * `Clone`\n-//! * `Eq`, `Ord` - for slices whose element type are `Eq` or `Ord`.\n-//! * `Hash` - for slices whose element type is `Hash`\n+//! * [`Clone`]\n+//! * [`Eq`], [`Ord`] - for slices whose element type are [`Eq`] or [`Ord`].\n+//! * [`Hash`] - for slices whose element type is [`Hash`].\n //!\n //! ## Iteration\n //!\n@@ -73,12 +73,24 @@\n //! the element type of the slice is `i32`, the element type of the iterator is\n //! `&mut i32`.\n //!\n-//! * `.iter()` and `.iter_mut()` are the explicit methods to return the default\n+//! * [`.iter()`] and [`.iter_mut()`] are the explicit methods to return the default\n //!   iterators.\n-//! * Further methods that return iterators are `.split()`, `.splitn()`,\n-//!   `.chunks()`, `.windows()` and more.\n+//! * Further methods that return iterators are [`.split()`], [`.splitn()`],\n+//!   [`.chunks()`], [`.windows()`] and more.\n //!\n //! *[See also the slice primitive type](../../std/primitive.slice.html).*\n+//!\n+//! [`Clone`]: ../../std/clone/trait.Clone.html\n+//! [`Eq`]: ../../std/cmp/trait.Eq.html\n+//! [`Ord`]: ../../std/cmp/trait.Ord.html\n+//! [`Iter`]: struct.Iter.html\n+//! [`Hash`]: ../../std/hash/trait.Hash.html\n+//! [`.iter()`]: ../../std/primitive.slice.html#method.iter\n+//! [`.iter_mut()`]: ../../std/primitive.slice.html#method.iter_mut\n+//! [`.split()`]: ../../std/primitive.slice.html#method.split\n+//! [`.splitn()`]: ../../std/primitive.slice.html#method.splitn\n+//! [`.chunks()`]: ../../std/primitive.slice.html#method.chunks\n+//! [`.windows()`]: ../../std/primitive.slice.html#method.windows\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n // Many of the usings in this module are only used in the test configuration.\n@@ -168,7 +180,7 @@ impl<T> [T] {\n         core_slice::SliceExt::len(self)\n     }\n \n-    /// Returns true if the slice has a length of 0\n+    /// Returns true if the slice has a length of 0.\n     ///\n     /// # Example\n     ///\n@@ -402,7 +414,7 @@ impl<T> [T] {\n         core_slice::SliceExt::get_unchecked_mut(self, index)\n     }\n \n-    /// Returns an raw pointer to the slice's buffer\n+    /// Returns an raw pointer to the slice's buffer.\n     ///\n     /// The caller must ensure that the slice outlives the pointer this\n     /// function returns, or else it will end up pointing to garbage.\n@@ -468,7 +480,7 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n     /// v.swap(1, 3);\n     /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n@@ -483,7 +495,7 @@ impl<T> [T] {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [1, 2, 3];\n     /// v.reverse();\n     /// assert!(v == [3, 2, 1]);\n@@ -567,9 +579,9 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over `size` elements of the slice at a\n-    /// time. The chunks are slices and do not overlap. If `size` does not divide the\n-    /// length of the slice, then the last chunk will not have length\n-    /// `size`.\n+    /// time. The chunks are slices and do not overlap. If `size` does\n+    /// not divide the length of the slice, then the last chunk will\n+    /// not have length `size`.\n     ///\n     /// # Panics\n     ///\n@@ -656,7 +668,7 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [1, 2, 3, 4, 5, 6];\n     ///\n     /// // scoped to restrict the lifetime of the borrows\n@@ -754,7 +766,7 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to returning at most `n` items.  The matched element is\n+    /// `pred`, limited to returning at most `n` items. The matched element is\n     /// not contained in the subslices.\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n@@ -781,7 +793,7 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to returning at most `n` items.  The matched element is\n+    /// `pred`, limited to returning at most `n` items. The matched element is\n     /// not contained in the subslices.\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n@@ -835,7 +847,7 @@ impl<T> [T] {\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to returning at most `n` items. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n+    /// the slice and works backwards. The matched element is not contained in\n     /// the subslices.\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n@@ -922,9 +934,9 @@ impl<T> [T] {\n     ///\n     /// Looks up a series of four elements. The first is found, with a\n     /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n+    /// found; the fourth could match any position in `[1, 4]`.\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n     ///\n     /// assert_eq!(s.binary_search(&13),  Ok(9));\n@@ -956,9 +968,9 @@ impl<T> [T] {\n     ///\n     /// Looks up a series of four elements. The first is found, with a\n     /// uniquely determined position; the second and third are not\n-    /// found; the fourth could match any position in `[1,4]`.\n+    /// found; the fourth could match any position in `[1, 4]`.\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];\n     ///\n     /// let seek = 13;\n@@ -982,21 +994,23 @@ impl<T> [T] {\n     /// Binary search a sorted slice with a key extraction function.\n     ///\n     /// Assumes that the slice is sorted by the key, for instance with\n-    /// `sort_by_key` using the same key extraction function.\n+    /// [`sort_by_key`] using the same key extraction function.\n     ///\n     /// If a matching value is found then returns `Ok`, containing the\n     /// index for the matched element; if no match is found then `Err`\n     /// is returned, containing the index where a matching element could\n     /// be inserted while maintaining sorted order.\n     ///\n+    /// [`sort_by_key`]: #method.sort_by_key\n+    ///\n     /// # Examples\n     ///\n     /// Looks up a series of four elements in a slice of pairs sorted by\n     /// their second elements. The first is found, with a uniquely\n     /// determined position; the second and third are not found; the\n-    /// fourth could match any position in `[1,4]`.\n+    /// fourth could match any position in `[1, 4]`.\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),\n     ///          (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n     ///          (1, 21), (2, 34), (4, 55)];\n@@ -1023,7 +1037,7 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [-5, 4, 1, -3, 2];\n     ///\n     /// v.sort();\n@@ -1037,15 +1051,15 @@ impl<T> [T] {\n         self.sort_by(|a, b| a.cmp(b))\n     }\n \n-    /// Sorts the slice, in place, using `key` to extract a key by which to\n+    /// Sorts the slice, in place, using `f` to extract a key by which to\n     /// order the sort by.\n     ///\n     /// This sort is stable and `O(n log n)` worst-case but allocates\n     /// approximately `2 * n`, where `n` is the length of `self`.\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [-5i32, 4, 1, -3, 2];\n     ///\n     /// v.sort_by_key(|k| k.abs());\n@@ -1067,7 +1081,7 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut v = [5, 4, 1, 3, 2];\n     /// v.sort_by(|a, b| a.cmp(b));\n     /// assert!(v == [1, 2, 3, 4, 5]);\n@@ -1094,7 +1108,7 @@ impl<T> [T] {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut dst = [0, 0, 0];\n     /// let src = [1, 2, 3];\n     ///\n@@ -1116,7 +1130,7 @@ impl<T> [T] {\n     ///\n     /// # Example\n     ///\n-    /// ```rust\n+    /// ```\n     /// let mut dst = [0, 0, 0];\n     /// let src = [1, 2, 3];\n     ///\n@@ -1156,7 +1170,7 @@ impl<T> [T] {\n     /// let x = s.into_vec();\n     /// // `s` cannot be used anymore because it has been converted into `x`.\n     ///\n-    /// assert_eq!(x, vec!(10, 40, 30));\n+    /// assert_eq!(x, vec![10, 40, 30]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "48a74bdecbbefa60db93ba3a74c94dcc1d0e79a3", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -122,7 +122,7 @@ pub struct EncodeUtf16<'a> {\n     encoder: Utf16Encoder<Chars<'a>>,\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n impl<'a> Iterator for EncodeUtf16<'a> {\n     type Item = u16;\n \n@@ -697,7 +697,7 @@ impl str {\n     ///\n     /// Basic usage:\n     ///\n-    /// ```rust\n+    /// ```\n     /// let bananas = \"bananas\";\n     ///\n     /// assert!(bananas.ends_with(\"anas\"));\n@@ -900,7 +900,7 @@ impl str {\n     ///\n     /// It does _not_ give you:\n     ///\n-    /// ```rust,ignore\n+    /// ```,ignore\n     /// assert_eq!(d, &[\"a\", \"b\", \"c\"]);\n     /// ```\n     ///\n@@ -1053,10 +1053,10 @@ impl str {\n     }\n \n     /// An iterator over substrings of the given string slice, separated by a\n-    /// pattern, restricted to returning at most `count` items.\n+    /// pattern, restricted to returning at most `n` items.\n     ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// string slice.\n+    /// If `n` substrings are returned, the last substring (the `n`th substring)\n+    /// will contain the remainder of the string.\n     ///\n     /// The pattern can be a `&str`, [`char`], or a closure that determines the\n     /// split.\n@@ -1098,16 +1098,16 @@ impl str {\n     /// assert_eq!(v, [\"abc\", \"defXghi\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n-        core_str::StrExt::splitn(self, count, pat)\n+    pub fn splitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> SplitN<'a, P> {\n+        core_str::StrExt::splitn(self, n, pat)\n     }\n \n     /// An iterator over substrings of this string slice, separated by a\n     /// pattern, starting from the end of the string, restricted to returning\n-    /// at most `count` items.\n+    /// at most `n` items.\n     ///\n-    /// The last element returned, if any, will contain the remainder of the\n-    /// string slice.\n+    /// If `n` substrings are returned, the last substring (the `n`th substring)\n+    /// will contain the remainder of the string.\n     ///\n     /// The pattern can be a `&str`, [`char`], or a closure that\n     /// determines the split.\n@@ -1145,10 +1145,10 @@ impl str {\n     /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n-        core_str::StrExt::rsplitn(self, count, pat)\n+        core_str::StrExt::rsplitn(self, n, pat)\n     }\n \n     /// An iterator over the matches of a pattern within the given string\n@@ -1789,4 +1789,24 @@ impl str {\n             String::from_utf8_unchecked(slice.into_vec())\n         }\n     }\n+\n+    /// Create a [`String`] by repeating a string `n` times.\n+    ///\n+    /// [`String`]: string/struct.String.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(repeat_str)]\n+    ///\n+    /// assert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));\n+    /// ```\n+    #[unstable(feature = \"repeat_str\", issue = \"37079\")]\n+    pub fn repeat(&self, n: usize) -> String {\n+        let mut s = String::with_capacity(self.len() * n);\n+        s.extend((0..n).map(|_| self));\n+        s\n+    }\n }"}, {"sha": "286f06b6fe32ac23c4a88ea2fe036279b2d7e631", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 20, "deletions": 31, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -14,24 +14,25 @@\n //! [`ToString`]s, and several error types that may result from working with\n //! [`String`]s.\n //!\n-//! [`String`]: struct.String.html\n //! [`ToString`]: trait.ToString.html\n //!\n //! # Examples\n //!\n-//! There are multiple ways to create a new `String` from a string literal:\n+//! There are multiple ways to create a new [`String`] from a string literal:\n //!\n-//! ```rust\n+//! ```\n //! let s = \"Hello\".to_string();\n //!\n //! let s = String::from(\"world\");\n //! let s: String = \"also this\".into();\n //! ```\n //!\n-//! You can create a new `String` from an existing one by concatenating with\n+//! You can create a new [`String`] from an existing one by concatenating with\n //! `+`:\n //!\n-//! ```rust\n+//! [`String`]: struct.String.html\n+//!\n+//! ```\n //! let s = \"Hello\".to_string();\n //!\n //! let message = s + \" world!\";\n@@ -40,7 +41,7 @@\n //! If you have a vector of valid UTF-8 bytes, you can make a `String` out of\n //! it. You can do the reverse too.\n //!\n-//! ```rust\n+//! ```\n //! let sparkle_heart = vec![240, 159, 146, 150];\n //!\n //! // We know these bytes are valid, so we'll use `unwrap()`.\n@@ -134,10 +135,10 @@ use boxed::Box;\n /// Indexing is intended to be a constant-time operation, but UTF-8 encoding\n /// does not allow us to do this. Furthermore, it's not clear what sort of\n /// thing the index should return: a byte, a codepoint, or a grapheme cluster.\n-/// The [`as_bytes()`] and [`chars()`] methods return iterators over the first\n+/// The [`bytes()`] and [`chars()`] methods return iterators over the first\n /// two, respectively.\n ///\n-/// [`as_bytes()`]: #method.as_bytes\n+/// [`bytes()`]: #method.bytes\n /// [`chars()`]: #method.chars\n ///\n /// # Deref\n@@ -975,7 +976,7 @@ impl String {\n     pub fn push(&mut self, ch: char) {\n         match ch.len_utf8() {\n             1 => self.vec.push(ch as u8),\n-            _ => self.vec.extend_from_slice(ch.encode_utf8().as_slice()),\n+            _ => self.vec.extend_from_slice(ch.encode_utf8(&mut [0;4]).as_bytes()),\n         }\n     }\n \n@@ -1131,10 +1132,11 @@ impl String {\n         let len = self.len();\n         assert!(idx <= len);\n         assert!(self.is_char_boundary(idx));\n-        let bits = ch.encode_utf8();\n+        let mut bits = [0; 4];\n+        let bits = ch.encode_utf8(&mut bits).as_bytes();\n \n         unsafe {\n-            self.insert_bytes(idx, bits.as_slice());\n+            self.insert_bytes(idx, bits);\n         }\n     }\n \n@@ -1858,6 +1860,13 @@ impl<'a> From<&'a str> for String {\n     }\n }\n \n+#[stable(feature = \"string_from_cow_str\", since = \"1.14.0\")]\n+impl<'a> From<Cow<'a, str>> for String {\n+    fn from(s: Cow<'a, str>) -> String {\n+        s.into_owned()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> From<&'a str> for Cow<'a, str> {\n     #[inline]\n@@ -1902,26 +1911,6 @@ impl Into<Vec<u8>> for String {\n     }\n }\n \n-#[stable(feature = \"stringfromchars\", since = \"1.12.0\")]\n-impl<'a> From<&'a [char]> for String {\n-    #[inline]\n-    fn from(v: &'a [char]) -> String {\n-        let mut s = String::with_capacity(v.len());\n-        for c in v {\n-            s.push(*c);\n-        }\n-        s\n-    }\n-}\n-\n-#[stable(feature = \"stringfromchars\", since = \"1.12.0\")]\n-impl From<Vec<char>> for String {\n-    #[inline]\n-    fn from(v: Vec<char>) -> String {\n-        String::from(v.as_slice())\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Write for String {\n     #[inline]"}, {"sha": "d94a27917e869434d67fb5c320a07e574e17f3fe", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 254, "deletions": 155, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -16,13 +16,13 @@\n //!\n //! # Examples\n //!\n-//! You can explicitly create a `Vec<T>` with `new()`:\n+//! You can explicitly create a [`Vec<T>`] with [`new()`]:\n //!\n //! ```\n //! let v: Vec<i32> = Vec::new();\n //! ```\n //!\n-//! ...or by using the `vec!` macro:\n+//! ...or by using the [`vec!`] macro:\n //!\n //! ```\n //! let v: Vec<i32> = vec![];\n@@ -32,7 +32,7 @@\n //! let v = vec![0; 10]; // ten zeroes\n //! ```\n //!\n-//! You can `push` values onto the end of a vector (which will grow the vector\n+//! You can [`push`] values onto the end of a vector (which will grow the vector\n //! as needed):\n //!\n //! ```\n@@ -49,13 +49,20 @@\n //! let two = v.pop();\n //! ```\n //!\n-//! Vectors also support indexing (through the `Index` and `IndexMut` traits):\n+//! Vectors also support indexing (through the [`Index`] and [`IndexMut`] traits):\n //!\n //! ```\n //! let mut v = vec![1, 2, 3];\n //! let three = v[2];\n //! v[1] = v[1] + 5;\n //! ```\n+//!\n+//! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+//! [`new()`]: ../../std/vec/struct.Vec.html#method.new\n+//! [`push`]: ../../std/vec/struct.Vec.html#method.push\n+//! [`Index`]: ../../std/ops/trait.Index.html\n+//! [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n+//! [`vec!`]: ../../std/macro.vec.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -79,7 +86,7 @@ use core::slice;\n use super::SpecExtend;\n use super::range::RangeArgument;\n \n-/// A contiguous growable array type, written `Vec<T>` but pronounced 'vector.'\n+/// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n /// # Examples\n ///\n@@ -105,7 +112,7 @@ use super::range::RangeArgument;\n /// assert_eq!(vec, [7, 1, 2, 3]);\n /// ```\n ///\n-/// The `vec!` macro is provided to make initialization more convenient:\n+/// The [`vec!`] macro is provided to make initialization more convenient:\n ///\n /// ```\n /// let mut vec = vec![1, 2, 3];\n@@ -137,19 +144,19 @@ use super::range::RangeArgument;\n ///\n /// # Indexing\n ///\n-/// The Vec type allows to access values by index, because it implements the\n-/// `Index` trait. An example will be more explicit:\n+/// The `Vec` type allows to access values by index, because it implements the\n+/// [`Index`] trait. An example will be more explicit:\n ///\n /// ```\n-/// let v = vec!(0, 2, 4, 6);\n+/// let v = vec![0, 2, 4, 6];\n /// println!(\"{}\", v[1]); // it will display '2'\n /// ```\n ///\n-/// However be careful: if you try to access an index which isn't in the Vec,\n+/// However be careful: if you try to access an index which isn't in the `Vec`,\n /// your software will panic! You cannot do this:\n ///\n /// ```ignore\n-/// let v = vec!(0, 2, 4, 6);\n+/// let v = vec![0, 2, 4, 6];\n /// println!(\"{}\", v[6]); // it will panic!\n /// ```\n ///\n@@ -158,15 +165,15 @@ use super::range::RangeArgument;\n ///\n /// # Slicing\n ///\n-/// A Vec can be mutable. Slices, on the other hand, are read-only objects.\n-/// To get a slice, use \"&\". Example:\n+/// A `Vec` can be mutable. Slices, on the other hand, are read-only objects.\n+/// To get a slice, use `&`. Example:\n ///\n /// ```\n /// fn read_slice(slice: &[usize]) {\n ///     // ...\n /// }\n ///\n-/// let v = vec!(0, 1);\n+/// let v = vec![0, 1];\n /// read_slice(&v);\n ///\n /// // ... and that's all!\n@@ -175,8 +182,8 @@ use super::range::RangeArgument;\n /// ```\n ///\n /// In Rust, it's more common to pass slices as arguments rather than vectors\n-/// when you just want to provide a read access. The same goes for String and\n-/// &str.\n+/// when you just want to provide a read access. The same goes for [`String`] and\n+/// [`&str`].\n ///\n /// # Capacity and reallocation\n ///\n@@ -191,84 +198,100 @@ use super::range::RangeArgument;\n /// with space for 10 more elements. Pushing 10 or fewer elements onto the\n /// vector will not change its capacity or cause reallocation to occur. However,\n /// if the vector's length is increased to 11, it will have to reallocate, which\n-/// can be slow. For this reason, it is recommended to use `Vec::with_capacity`\n+/// can be slow. For this reason, it is recommended to use [`Vec::with_capacity`]\n /// whenever possible to specify how big the vector is expected to get.\n ///\n /// # Guarantees\n ///\n-/// Due to its incredibly fundamental nature, Vec makes a lot of guarantees\n+/// Due to its incredibly fundamental nature, `Vec` makes a lot of guarantees\n /// about its design. This ensures that it's as low-overhead as possible in\n /// the general case, and can be correctly manipulated in primitive ways\n /// by unsafe code. Note that these guarantees refer to an unqualified `Vec<T>`.\n /// If additional type parameters are added (e.g. to support custom allocators),\n /// overriding their defaults may change the behavior.\n ///\n-/// Most fundamentally, Vec is and always will be a (pointer, capacity, length)\n+/// Most fundamentally, `Vec` is and always will be a (pointer, capacity, length)\n /// triplet. No more, no less. The order of these fields is completely\n /// unspecified, and you should use the appropriate methods to modify these.\n /// The pointer will never be null, so this type is null-pointer-optimized.\n ///\n /// However, the pointer may not actually point to allocated memory. In particular,\n-/// if you construct a Vec with capacity 0 via `Vec::new()`, `vec![]`,\n-/// `Vec::with_capacity(0)`, or by calling `shrink_to_fit()` on an empty Vec, it\n-/// will not allocate memory. Similarly, if you store zero-sized types inside\n-/// a Vec, it will not allocate space for them. *Note that in this case the\n-/// Vec may not report a `capacity()` of 0*. Vec will allocate if and only\n-/// if `mem::size_of::<T>() * capacity() > 0`. In general, Vec's allocation\n+/// if you construct a `Vec` with capacity 0 via [`Vec::new()`], [`vec![]`][`vec!`],\n+/// [`Vec::with_capacity(0)`][`Vec::with_capacity`], or by calling [`shrink_to_fit()`]\n+/// on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\n+/// types inside a `Vec`, it will not allocate space for them. *Note that in this case\n+/// the `Vec` may not report a [`capacity()`] of 0*. `Vec` will allocate if and only\n+/// if [`mem::size_of::<T>()`]` * capacity() > 0`. In general, `Vec`'s allocation\n /// details are subtle enough that it is strongly recommended that you only\n-/// free memory allocated by a Vec by creating a new Vec and dropping it.\n+/// free memory allocated by a `Vec` by creating a new `Vec` and dropping it.\n ///\n-/// If a Vec *has* allocated memory, then the memory it points to is on the heap\n+/// If a `Vec` *has* allocated memory, then the memory it points to is on the heap\n /// (as defined by the allocator Rust is configured to use by default), and its\n-/// pointer points to `len()` initialized elements in order (what you would see\n-/// if you coerced it to a slice), followed by `capacity() - len()` logically\n-/// uninitialized elements.\n+/// pointer points to [`len()`] initialized elements in order (what you would see\n+/// if you coerced it to a slice), followed by [`capacity()`]` - `[`len()`]\n+/// logically uninitialized elements.\n ///\n-/// Vec will never perform a \"small optimization\" where elements are actually\n+/// `Vec` will never perform a \"small optimization\" where elements are actually\n /// stored on the stack for two reasons:\n ///\n /// * It would make it more difficult for unsafe code to correctly manipulate\n-///   a Vec. The contents of a Vec wouldn't have a stable address if it were\n-///   only moved, and it would be more difficult to determine if a Vec had\n+///   a `Vec`. The contents of a `Vec` wouldn't have a stable address if it were\n+///   only moved, and it would be more difficult to determine if a `Vec` had\n ///   actually allocated memory.\n ///\n /// * It would penalize the general case, incurring an additional branch\n ///   on every access.\n ///\n-/// Vec will never automatically shrink itself, even if completely empty. This\n-/// ensures no unnecessary allocations or deallocations occur. Emptying a Vec\n-/// and then filling it back up to the same `len()` should incur no calls to\n-/// the allocator. If you wish to free up unused memory, use `shrink_to_fit`.\n+/// `Vec` will never automatically shrink itself, even if completely empty. This\n+/// ensures no unnecessary allocations or deallocations occur. Emptying a `Vec`\n+/// and then filling it back up to the same [`len()`] should incur no calls to\n+/// the allocator. If you wish to free up unused memory, use\n+/// [`shrink_to_fit`][`shrink_to_fit()`].\n ///\n-/// `push` and `insert` will never (re)allocate if the reported capacity is\n-/// sufficient. `push` and `insert` *will* (re)allocate if `len() == capacity()`.\n-/// That is, the reported capacity is completely accurate, and can be relied on.\n-/// It can even be used to manually free the memory allocated by a Vec if\n-/// desired. Bulk insertion methods *may* reallocate, even when not necessary.\n+/// [`push`] and [`insert`] will never (re)allocate if the reported capacity is\n+/// sufficient. [`push`] and [`insert`] *will* (re)allocate if\n+/// [`len()`]` == `[`capacity()`]. That is, the reported capacity is completely\n+/// accurate, and can be relied on. It can even be used to manually free the memory\n+/// allocated by a `Vec` if desired. Bulk insertion methods *may* reallocate, even\n+/// when not necessary.\n ///\n-/// Vec does not guarantee any particular growth strategy when reallocating\n-/// when full, nor when `reserve` is called. The current strategy is basic\n+/// `Vec` does not guarantee any particular growth strategy when reallocating\n+/// when full, nor when [`reserve`] is called. The current strategy is basic\n /// and it may prove desirable to use a non-constant growth factor. Whatever\n-/// strategy is used will of course guarantee `O(1)` amortized `push`.\n+/// strategy is used will of course guarantee `O(1)` amortized [`push`].\n ///\n-/// `vec![x; n]`, `vec![a, b, c, d]`, and `Vec::with_capacity(n)`, will all\n-/// produce a Vec with exactly the requested capacity. If `len() == capacity()`,\n-/// (as is the case for the `vec!` macro), then a `Vec<T>` can be converted\n-/// to and from a `Box<[T]>` without reallocating or moving the elements.\n+/// `vec![x; n]`, `vec![a, b, c, d]`, and\n+/// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all produce a `Vec`\n+/// with exactly the requested capacity. If [`len()`]` == `[`capacity()`],\n+/// (as is the case for the [`vec!`] macro), then a `Vec<T>` can be converted to\n+/// and from a [`Box<[T]>`][owned slice] without reallocating or moving the elements.\n ///\n-/// Vec will not specifically overwrite any data that is removed from it,\n+/// `Vec` will not specifically overwrite any data that is removed from it,\n /// but also won't specifically preserve it. Its uninitialized memory is\n /// scratch space that it may use however it wants. It will generally just do\n /// whatever is most efficient or otherwise easy to implement. Do not rely on\n-/// removed data to be erased for security purposes. Even if you drop a Vec, its\n-/// buffer may simply be reused by another Vec. Even if you zero a Vec's memory\n+/// removed data to be erased for security purposes. Even if you drop a `Vec`, its\n+/// buffer may simply be reused by another `Vec`. Even if you zero a `Vec`'s memory\n /// first, that may not actually happen because the optimizer does not consider\n /// this a side-effect that must be preserved.\n ///\n-/// Vec does not currently guarantee the order in which elements are dropped\n+/// `Vec` does not currently guarantee the order in which elements are dropped\n /// (the order has changed in the past, and may change again).\n ///\n-#[cfg_attr(stage0, unsafe_no_drop_flag)]\n+/// [`vec!`]: ../../std/macro.vec.html\n+/// [`Index`]: ../../std/ops/trait.Index.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`&str`]: ../../std/primitive.str.html\n+/// [`Vec::with_capacity`]: ../../std/vec/struct.Vec.html#method.with_capacity\n+/// [`Vec::new()`]: ../../std/vec/struct.Vec.html#method.new\n+/// [`shrink_to_fit()`]: ../../std/vec/struct.Vec.html#method.shrink_to_fit\n+/// [`capacity()`]: ../../std/vec/struct.Vec.html#method.capacity\n+/// [`mem::size_of::<T>()`]: ../../std/mem/fn.size_of.html\n+/// [`len()`]: ../../std/vec/struct.Vec.html#method.len\n+/// [`push`]: ../../std/vec/struct.Vec.html#method.push\n+/// [`insert`]: ../../std/vec/struct.Vec.html#method.insert\n+/// [`reserve`]: ../../std/vec/struct.Vec.html#method.reserve\n+/// [owned slice]: ../../std/boxed/struct.Box.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n     buf: RawVec<T>,\n@@ -305,9 +328,10 @@ impl<T> Vec<T> {\n     /// reallocating. If `capacity` is 0, the vector will not allocate.\n     ///\n     /// It is important to note that this function does not specify the *length*\n-    /// of the returned vector, but only the *capacity*. (For an explanation of\n-    /// the difference between length and capacity, see the main `Vec<T>` docs\n-    /// above, 'Capacity and reallocation'.)\n+    /// of the returned vector, but only the *capacity*. For an explanation of\n+    /// the difference between length and capacity, see *[Capacity and reallocation]*.\n+    ///\n+    /// [Capacity and reallocation]: #capacity-and-reallocation\n     ///\n     /// # Examples\n     ///\n@@ -341,7 +365,7 @@ impl<T> Vec<T> {\n     /// This is highly unsafe, due to the number of invariants that aren't\n     /// checked:\n     ///\n-    /// * `ptr` needs to have been previously allocated via `String`/`Vec<T>`\n+    /// * `ptr` needs to have been previously allocated via [`String`]/`Vec<T>`\n     ///   (at least, it's highly likely to be incorrect if it wasn't).\n     /// * `length` needs to be less than or equal to `capacity`.\n     /// * `capacity` needs to be the capacity that the pointer was allocated with.\n@@ -355,6 +379,8 @@ impl<T> Vec<T> {\n     /// that nothing else uses the pointer after calling this\n     /// function.\n     ///\n+    /// [`String`]: ../../std/string/struct.String.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -471,11 +497,15 @@ impl<T> Vec<T> {\n         self.buf.shrink_to_fit(self.len);\n     }\n \n-    /// Converts the vector into Box<[T]>.\n+    /// Converts the vector into [`Box<[T]>`][owned slice].\n     ///\n     /// Note that this will drop any excess capacity. Calling this and\n-    /// converting back to a vector with `into_vec()` is equivalent to calling\n-    /// `shrink_to_fit()`.\n+    /// converting back to a vector with [`into_vec()`] is equivalent to calling\n+    /// [`shrink_to_fit()`].\n+    ///\n+    /// [owned slice]: ../../std/boxed/struct.Box.html\n+    /// [`into_vec()`]: ../../std/primitive.slice.html#method.into_vec\n+    /// [`shrink_to_fit()`]: #method.shrink_to_fit\n     ///\n     /// # Examples\n     ///\n@@ -674,7 +704,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `index` is greater than the vector's length.\n+    /// Panics if `index` is out of bounds.\n     ///\n     /// # Examples\n     ///\n@@ -749,7 +779,7 @@ impl<T> Vec<T> {\n \n     /// Retains only the elements specified by the predicate.\n     ///\n-    /// In other words, remove all elements `e` such that `f(&e)` returns false.\n+    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n     /// This method operates in place and preserves the order of the retained\n     /// elements.\n     ///\n@@ -782,6 +812,130 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Removes consecutive elements in the vector that resolve to the same key.\n+    ///\n+    /// If the vector is sorted, this removes all duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(dedup_by)]\n+    ///\n+    /// let mut vec = vec![10, 20, 21, 30, 20];\n+    ///\n+    /// vec.dedup_by_key(|i| *i / 10);\n+    ///\n+    /// assert_eq!(vec, [10, 20, 30, 20]);\n+    /// ```\n+    #[unstable(feature = \"dedup_by\", reason = \"recently added\", issue = \"37087\")]\n+    #[inline]\n+    pub fn dedup_by_key<F, K>(&mut self, mut key: F) where F: FnMut(&mut T) -> K, K: PartialEq {\n+        self.dedup_by(|a, b| key(a) == key(b))\n+    }\n+\n+    /// Removes consecutive elements in the vector that resolve to the same key.\n+    ///\n+    /// If the vector is sorted, this removes all duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(dedup_by)]\n+    /// use std::ascii::AsciiExt;\n+    ///\n+    /// let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n+    ///\n+    /// vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n+    ///\n+    /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n+    /// ```\n+    #[unstable(feature = \"dedup_by\", reason = \"recently added\", issue = \"37087\")]\n+    pub fn dedup_by<F>(&mut self, mut same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n+        unsafe {\n+            // Although we have a mutable reference to `self`, we cannot make\n+            // *arbitrary* changes. The `same_bucket` calls could panic, so we\n+            // must ensure that the vector is in a valid state at all time.\n+            //\n+            // The way that we handle this is by using swaps; we iterate\n+            // over all the elements, swapping as we go so that at the end\n+            // the elements we wish to keep are in the front, and those we\n+            // wish to reject are at the back. We can then truncate the\n+            // vector. This operation is still O(n).\n+            //\n+            // Example: We start in this state, where `r` represents \"next\n+            // read\" and `w` represents \"next_write`.\n+            //\n+            //           r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //           w\n+            //\n+            // Comparing self[r] against self[w-1], this is not a duplicate, so\n+            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n+            // r and w, leaving us with:\n+            //\n+            //               r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //               w\n+            //\n+            // Comparing self[r] against self[w-1], this value is a duplicate,\n+            // so we increment `r` but leave everything else unchanged:\n+            //\n+            //                   r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //               w\n+            //\n+            // Comparing self[r] against self[w-1], this is not a duplicate,\n+            // so swap self[r] and self[w] and advance r and w:\n+            //\n+            //                       r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //                   w\n+            //\n+            // Not a duplicate, repeat:\n+            //\n+            //                           r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //                       w\n+            //\n+            // Duplicate, advance r. End of vec. Truncate to w.\n+\n+            let ln = self.len();\n+            if ln <= 1 {\n+                return;\n+            }\n+\n+            // Avoid bounds checks by using raw pointers.\n+            let p = self.as_mut_ptr();\n+            let mut r: usize = 1;\n+            let mut w: usize = 1;\n+\n+            while r < ln {\n+                let p_r = p.offset(r as isize);\n+                let p_wm1 = p.offset((w - 1) as isize);\n+                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n+                    if r != w {\n+                        let p_w = p_wm1.offset(1);\n+                        mem::swap(&mut *p_r, &mut *p_w);\n+                    }\n+                    w += 1;\n+                }\n+                r += 1;\n+            }\n+\n+            self.truncate(w);\n+        }\n+    }\n+\n     /// Appends an element to the back of a collection.\n     ///\n     /// # Panics\n@@ -810,9 +964,11 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Removes the last element from a vector and returns it, or `None` if it\n+    /// Removes the last element from a vector and returns it, or [`None`] if it\n     /// is empty.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1156,90 +1312,9 @@ impl<T: PartialEq> Vec<T> {\n     /// assert_eq!(vec, [1, 2, 3, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn dedup(&mut self) {\n-        unsafe {\n-            // Although we have a mutable reference to `self`, we cannot make\n-            // *arbitrary* changes. The `PartialEq` comparisons could panic, so we\n-            // must ensure that the vector is in a valid state at all time.\n-            //\n-            // The way that we handle this is by using swaps; we iterate\n-            // over all the elements, swapping as we go so that at the end\n-            // the elements we wish to keep are in the front, and those we\n-            // wish to reject are at the back. We can then truncate the\n-            // vector. This operation is still O(n).\n-            //\n-            // Example: We start in this state, where `r` represents \"next\n-            // read\" and `w` represents \"next_write`.\n-            //\n-            //           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //           w\n-            //\n-            // Comparing self[r] against self[w-1], this is not a duplicate, so\n-            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n-            // r and w, leaving us with:\n-            //\n-            //               r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this value is a duplicate,\n-            // so we increment `r` but leave everything else unchanged:\n-            //\n-            //                   r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this is not a duplicate,\n-            // so swap self[r] and self[w] and advance r and w:\n-            //\n-            //                       r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                   w\n-            //\n-            // Not a duplicate, repeat:\n-            //\n-            //                           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                       w\n-            //\n-            // Duplicate, advance r. End of vec. Truncate to w.\n-\n-            let ln = self.len();\n-            if ln <= 1 {\n-                return;\n-            }\n-\n-            // Avoid bounds checks by using raw pointers.\n-            let p = self.as_mut_ptr();\n-            let mut r: usize = 1;\n-            let mut w: usize = 1;\n-\n-            while r < ln {\n-                let p_r = p.offset(r as isize);\n-                let p_wm1 = p.offset((w - 1) as isize);\n-                if *p_r != *p_wm1 {\n-                    if r != w {\n-                        let p_w = p_wm1.offset(1);\n-                        mem::swap(&mut *p_r, &mut *p_w);\n-                    }\n-                    w += 1;\n-                }\n-                r += 1;\n-            }\n-\n-            self.truncate(w);\n-        }\n+        self.dedup_by(|a, b| a == b)\n     }\n }\n \n@@ -1572,7 +1647,24 @@ impl<T> Vec<T> {\n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Copy> Extend<&'a T> for Vec<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n-        self.extend(iter.into_iter().cloned());\n+        <I as SpecExtendVec<T>>::extend_vec(iter, self);\n+    }\n+}\n+\n+// helper trait for specialization of Vec's Extend impl\n+trait SpecExtendVec<T> {\n+    fn extend_vec(self, vec: &mut Vec<T>);\n+}\n+\n+impl <'a, T: 'a + Copy, I: IntoIterator<Item=&'a T>> SpecExtendVec<T> for I {\n+    default fn extend_vec(self, vec: &mut Vec<T>) {\n+        vec.extend(self.into_iter().cloned());\n+    }\n+}\n+\n+impl<'a, T: Copy> SpecExtendVec<T> for &'a [T] {\n+    fn extend_vec(self, vec: &mut Vec<T>) {\n+        vec.extend_from_slice(self);\n     }\n }\n \n@@ -1705,6 +1797,13 @@ impl<'a, T: Clone> From<&'a [T]> for Vec<T> {\n     }\n }\n \n+#[stable(feature = \"vec_from_cow_slice\", since = \"1.14.0\")]\n+impl<'a, T> From<Cow<'a, [T]>> for Vec<T> where [T]: ToOwned<Owned=Vec<T>> {\n+    fn from(s: Cow<'a, [T]>) -> Vec<T> {\n+        s.into_owned()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> From<&'a str> for Vec<u8> {\n     fn from(s: &'a str) -> Vec<u8> {\n@@ -1756,7 +1855,7 @@ pub struct IntoIter<T> {\n     end: *const T,\n }\n \n-#[stable(feature = \"vec_intoiter_debug\", since = \"\")]\n+#[stable(feature = \"vec_intoiter_debug\", since = \"1.13.0\")]\n impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_tuple(\"IntoIter\")\n@@ -1770,7 +1869,7 @@ impl<T> IntoIter<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// # #![feature(vec_into_iter_as_slice)]\n     /// let vec = vec!['a', 'b', 'c'];\n     /// let mut into_iter = vec.into_iter();\n@@ -1789,7 +1888,7 @@ impl<T> IntoIter<T> {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// # #![feature(vec_into_iter_as_slice)]\n     /// let vec = vec!['a', 'b', 'c'];\n     /// let mut into_iter = vec.into_iter();\n@@ -1930,7 +2029,7 @@ unsafe impl<'a, T: Sync> Sync for Drain<'a, T> {}\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n unsafe impl<'a, T: Send> Send for Drain<'a, T> {}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, T> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -1944,15 +2043,15 @@ impl<'a, T> Iterator for Drain<'a, T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, T> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         // exhaust self first\n@@ -1974,7 +2073,7 @@ impl<'a, T> Drop for Drain<'a, T> {\n }\n \n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]"}, {"sha": "5397193cab40f476bf843fd2229f21cbf6eb7bce", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 63, "deletions": 29, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -726,33 +726,25 @@ impl<T> VecDeque<T> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut vector: VecDeque<u32> = VecDeque::new();\n+    /// let mut vector = VecDeque::new();\n     ///\n     /// vector.push_back(0);\n     /// vector.push_back(1);\n     /// vector.push_back(2);\n     ///\n-    /// assert_eq!(vector.as_slices(), (&[0u32, 1, 2] as &[u32], &[] as &[u32]));\n+    /// assert_eq!(vector.as_slices(), (&[0, 1, 2][..], &[][..]));\n     ///\n     /// vector.push_front(10);\n     /// vector.push_front(9);\n     ///\n-    /// assert_eq!(vector.as_slices(), (&[9u32, 10] as &[u32], &[0u32, 1, 2] as &[u32]));\n+    /// assert_eq!(vector.as_slices(), (&[9, 10][..], &[0, 1, 2][..]));\n     /// ```\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n         unsafe {\n-            let contiguous = self.is_contiguous();\n             let buf = self.buffer_as_slice();\n-            if contiguous {\n-                let (empty, buf) = buf.split_at(0);\n-                (&buf[self.tail..self.head], empty)\n-            } else {\n-                let (mid, right) = buf.split_at(self.tail);\n-                let (left, _) = mid.split_at(self.head);\n-                (right, left)\n-            }\n+            RingSlices::ring_slices(buf, self.head, self.tail)\n         }\n     }\n \n@@ -764,7 +756,7 @@ impl<T> VecDeque<T> {\n     /// ```\n     /// use std::collections::VecDeque;\n     ///\n-    /// let mut vector: VecDeque<u32> = VecDeque::new();\n+    /// let mut vector = VecDeque::new();\n     ///\n     /// vector.push_back(0);\n     /// vector.push_back(1);\n@@ -774,26 +766,16 @@ impl<T> VecDeque<T> {\n     ///\n     /// vector.as_mut_slices().0[0] = 42;\n     /// vector.as_mut_slices().1[0] = 24;\n-    /// assert_eq!(vector.as_slices(), (&[42u32, 10] as &[u32], &[24u32, 1] as &[u32]));\n+    /// assert_eq!(vector.as_slices(), (&[42, 10][..], &[24, 1][..]));\n     /// ```\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n         unsafe {\n-            let contiguous = self.is_contiguous();\n             let head = self.head;\n             let tail = self.tail;\n             let buf = self.buffer_as_mut_slice();\n-\n-            if contiguous {\n-                let (empty, buf) = buf.split_at_mut(0);\n-                (&mut buf[tail..head], empty)\n-            } else {\n-                let (mid, right) = buf.split_at_mut(tail);\n-                let (left, _) = mid.split_at_mut(head);\n-\n-                (right, left)\n-            }\n+            RingSlices::ring_slices(buf, head, tail)\n         }\n     }\n \n@@ -1829,6 +1811,42 @@ fn wrap_index(index: usize, size: usize) -> usize {\n     index & (size - 1)\n }\n \n+/// Returns the two slices that cover the VecDeque's valid range\n+trait RingSlices : Sized {\n+    fn slice(self, from: usize, to: usize) -> Self;\n+    fn split_at(self, i: usize) -> (Self, Self);\n+\n+    fn ring_slices(buf: Self, head: usize, tail: usize) -> (Self, Self) {\n+        let contiguous = tail <= head;\n+        if contiguous {\n+            let (empty, buf) = buf.split_at(0);\n+            (buf.slice(tail, head), empty)\n+        } else {\n+            let (mid, right) = buf.split_at(tail);\n+            let (left, _) = mid.split_at(head);\n+            (right, left)\n+        }\n+    }\n+}\n+\n+impl<'a, T> RingSlices for &'a [T] {\n+    fn slice(self, from: usize, to: usize) -> Self {\n+        &self[from..to]\n+    }\n+    fn split_at(self, i: usize) -> (Self, Self) {\n+        (*self).split_at(i)\n+    }\n+}\n+\n+impl<'a, T> RingSlices for &'a mut [T] {\n+    fn slice(self, from: usize, to: usize) -> Self {\n+        &mut self[from..to]\n+    }\n+    fn split_at(self, i: usize) -> (Self, Self) {\n+        (*self).split_at_mut(i)\n+    }\n+}\n+\n /// Calculate the number of elements left to be read in the buffer\n #[inline]\n fn count(tail: usize, head: usize, size: usize) -> usize {\n@@ -1875,6 +1893,14 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         let len = count(self.tail, self.head, self.ring.len());\n         (len, Some(len))\n     }\n+\n+    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        accum = front.iter().fold(accum, &mut f);\n+        back.iter().fold(accum, &mut f)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1927,6 +1953,14 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         let len = count(self.tail, self.head, self.ring.len());\n         (len, Some(len))\n     }\n+\n+    fn fold<Acc, F>(self, mut accum: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n+        accum = front.iter_mut().fold(accum, &mut f);\n+        back.iter_mut().fold(accum, &mut f)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2002,7 +2036,7 @@ unsafe impl<'a, T: Sync> Sync for Drain<'a, T> {}\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n unsafe impl<'a, T: Send> Send for Drain<'a, T> {}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         for _ in self.by_ref() {}\n@@ -2051,7 +2085,7 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     type Item = T;\n \n@@ -2066,15 +2100,15 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.iter.next_back().map(|elt| unsafe { ptr::read(elt) })\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]"}, {"sha": "9cd63d87931842caf06b546bdbca546c54d40fe0", "filename": "src/libcollectionstest/binary_heap.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbinary_heap.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -139,6 +139,7 @@ fn test_push_unique() {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_push_pop() {\n     let mut heap = BinaryHeap::from(vec![5, 5, 2, 1, 3]);\n     assert_eq!(heap.len(), 5);\n@@ -153,6 +154,7 @@ fn test_push_pop() {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_replace() {\n     let mut heap = BinaryHeap::from(vec![5, 5, 2, 1, 3]);\n     assert_eq!(heap.len(), 5);\n@@ -212,6 +214,7 @@ fn test_empty_peek_mut() {\n }\n \n #[test]\n+#[allow(deprecated)]\n fn test_empty_replace() {\n     let mut heap = BinaryHeap::new();\n     assert!(heap.replace(5).is_none());\n@@ -296,5 +299,7 @@ fn test_extend_specialization() {\n \n #[allow(dead_code)]\n fn assert_covariance() {\n-    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> { d }\n+    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {\n+        d\n+    }\n }"}, {"sha": "8222da105ccad767bc1e3c51e0a97ff8dfbd859d", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -533,9 +533,7 @@ create_append_test!(test_append_1700, 1700);\n \n fn rand_data(len: usize) -> Vec<(u32, u32)> {\n     let mut rng = DeterministicRng::new();\n-    Vec::from_iter(\n-        (0..len).map(|_| (rng.next(), rng.next()))\n-    )\n+    Vec::from_iter((0..len).map(|_| (rng.next(), rng.next())))\n }\n \n #[test]"}, {"sha": "ae8b18d0c9fd92203fef9cc2bfd826aad5883bcc", "filename": "src/libcollectionstest/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -25,7 +25,7 @@ impl DeterministicRng {\n             x: 0x193a6754,\n             y: 0xa8a7d469,\n             z: 0x97830e05,\n-            w: 0x113ba7bb\n+            w: 0x113ba7bb,\n         }\n     }\n "}, {"sha": "6171b8ba624cd5581b505d3eb47cfc43d8e81c7c", "filename": "src/libcollectionstest/btree/set.rs", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fset.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -15,45 +15,51 @@ use super::DeterministicRng;\n \n #[test]\n fn test_clone_eq() {\n-  let mut m = BTreeSet::new();\n+    let mut m = BTreeSet::new();\n \n-  m.insert(1);\n-  m.insert(2);\n+    m.insert(1);\n+    m.insert(2);\n \n-  assert!(m.clone() == m);\n+    assert!(m.clone() == m);\n }\n \n #[test]\n fn test_hash() {\n-  let mut x = BTreeSet::new();\n-  let mut y = BTreeSet::new();\n+    let mut x = BTreeSet::new();\n+    let mut y = BTreeSet::new();\n \n-  x.insert(1);\n-  x.insert(2);\n-  x.insert(3);\n+    x.insert(1);\n+    x.insert(2);\n+    x.insert(3);\n \n-  y.insert(3);\n-  y.insert(2);\n-  y.insert(1);\n+    y.insert(3);\n+    y.insert(2);\n+    y.insert(1);\n \n-  assert!(::hash(&x) == ::hash(&y));\n+    assert!(::hash(&x) == ::hash(&y));\n }\n \n-fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F) where\n-    F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, &mut FnMut(&i32) -> bool) -> bool,\n+fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F)\n+    where F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, &mut FnMut(&i32) -> bool) -> bool\n {\n     let mut set_a = BTreeSet::new();\n     let mut set_b = BTreeSet::new();\n \n-    for x in a { assert!(set_a.insert(*x)) }\n-    for y in b { assert!(set_b.insert(*y)) }\n+    for x in a {\n+        assert!(set_a.insert(*x))\n+    }\n+    for y in b {\n+        assert!(set_b.insert(*y))\n+    }\n \n     let mut i = 0;\n-    f(&set_a, &set_b, &mut |&x| {\n-        assert_eq!(x, expected[i]);\n-        i += 1;\n-        true\n-    });\n+    f(&set_a,\n+      &set_b,\n+      &mut |&x| {\n+          assert_eq!(x, expected[i]);\n+          i += 1;\n+          true\n+      });\n     assert_eq!(i, expected.len());\n }\n \n@@ -82,9 +88,7 @@ fn test_difference() {\n     check_difference(&[], &[], &[]);\n     check_difference(&[1, 12], &[], &[1, 12]);\n     check_difference(&[], &[1, 2, 3, 9], &[]);\n-    check_difference(&[1, 3, 5, 9, 11],\n-                     &[3, 9],\n-                     &[1, 5, 11]);\n+    check_difference(&[1, 3, 5, 9, 11], &[3, 9], &[1, 5, 11]);\n     check_difference(&[-5, 11, 22, 33, 40, 42],\n                      &[-12, -5, 14, 23, 34, 38, 39, 50],\n                      &[11, 22, 33, 40, 42]);\n@@ -245,10 +249,18 @@ fn test_recovery() {\n fn test_variance() {\n     use std::collections::btree_set::{IntoIter, Iter, Range};\n \n-    fn set<'new>(v: BTreeSet<&'static str>) -> BTreeSet<&'new str> { v }\n-    fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str> { v }\n-    fn into_iter<'new>(v: IntoIter<&'static str>) -> IntoIter<&'new str> { v }\n-    fn range<'a, 'new>(v: Range<'a, &'static str>) -> Range<'a, &'new str> { v }\n+    fn set<'new>(v: BTreeSet<&'static str>) -> BTreeSet<&'new str> {\n+        v\n+    }\n+    fn iter<'a, 'new>(v: Iter<'a, &'static str>) -> Iter<'a, &'new str> {\n+        v\n+    }\n+    fn into_iter<'new>(v: IntoIter<&'static str>) -> IntoIter<&'new str> {\n+        v\n+    }\n+    fn range<'a, 'new>(v: Range<'a, &'static str>) -> Range<'a, &'new str> {\n+        v\n+    }\n }\n \n #[test]\n@@ -277,9 +289,7 @@ fn test_append() {\n \n fn rand_data(len: usize) -> Vec<u32> {\n     let mut rng = DeterministicRng::new();\n-    Vec::from_iter(\n-        (0..len).map(|_| rng.next())\n-    )\n+    Vec::from_iter((0..len).map(|_| rng.next()))\n }\n \n #[test]"}, {"sha": "82533ba077541e8748a206bde8a8d2a3b49961d7", "filename": "src/libcollectionstest/cow_str.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fcow_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fcow_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fcow_str.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2012-2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::borrow::Cow;\n+\n+// check that Cow<'a, str> implements addition\n+#[test]\n+fn check_cow_add() {\n+    borrowed1 = Cow::Borrowed(\"Hello, \");\n+    borrowed2 = Cow::Borrowed(\"World!\");\n+    borrow_empty = Cow::Borrowed(\"\");\n+\n+    owned1 = Cow::Owned(\"Hi, \".into());\n+    owned2 = Cow::Owned(\"Rustaceans!\".into());\n+    owned_empty = Cow::Owned(\"\".into());\n+\n+    assert_eq!(\"Hello, World!\", borrowed1 + borrowed2);\n+    assert_eq!(\"Hello, Rustaceans!\", borrowed1 + owned2);\n+\n+    assert_eq!(\"Hello, World!\", owned1 + borrowed2);\n+    assert_eq!(\"Hello, Rustaceans!\", owned1 + owned2);\n+\n+    if let Cow::Owned(_) = borrowed1 + borrow_empty {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    if let Cow::Owned(_) = borrow_empty + borrowed1 {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    if let Cow::Owned(_) = borrowed1 + owned_empty {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+    if let Cow::Owned(_) = owned_empty + borrowed1 {\n+        panic!(\"Adding empty strings to a borrow should note allocate\");\n+    }\n+}\n+\n+fn check_cow_add_assign() {\n+    borrowed1 = Cow::Borrowed(\"Hello, \");\n+    borrowed2 = Cow::Borrowed(\"World!\");\n+    borrow_empty = Cow::Borrowed(\"\");\n+\n+    owned1 = Cow::Owned(\"Hi, \".into());\n+    owned2 = Cow::Owned(\"Rustaceans!\".into());\n+    owned_empty = Cow::Owned(\"\".into());\n+\n+    let borrowed1clone = borrowed1.clone();\n+    borrowed1clone += borrow_empty;\n+    assert_eq!((&borrowed1clone).as_ptr(), (&borrowed1).as_ptr());\n+\n+    borrowed1clone += owned_empty;\n+    assert_eq!((&borrowed1clone).as_ptr(), (&borrowed1).as_ptr());\n+\n+    owned1 += borrowed2;\n+    borrowed1 += owned2;\n+\n+    assert_eq!(\"Hello, World!\", owned1);\n+    assert_eq!(\"Hello, Rustaceans!\", borrowed1);\n+}"}, {"sha": "5d3e03c2dee3691f21612ead902b7d6509c4c762", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -16,9 +16,11 @@\n #![feature(collections)]\n #![feature(collections_bound)]\n #![feature(const_fn)]\n+#![feature(dedup_by)]\n #![feature(enumset)]\n #![feature(pattern)]\n #![feature(rand)]\n+#![feature(repeat_str)]\n #![feature(step_by)]\n #![feature(str_escape)]\n #![feature(str_replacen)]\n@@ -31,9 +33,12 @@ extern crate collections;\n extern crate test;\n extern crate rustc_unicode;\n \n-use std::hash::{Hash, Hasher, SipHasher};\n+use std::hash::{Hash, Hasher};\n+use std::collections::hash_map::DefaultHasher;\n \n-#[cfg(test)] #[macro_use] mod bench;\n+#[cfg(test)]\n+#[macro_use]\n+mod bench;\n \n mod binary_heap;\n mod btree;\n@@ -47,7 +52,7 @@ mod vec_deque;\n mod vec;\n \n fn hash<T: Hash>(t: &T) -> u64 {\n-    let mut s = SipHasher::new();\n+    let mut s = DefaultHasher::new();\n     t.hash(&mut s);\n     s.finish()\n }"}, {"sha": "a6230ef471cec0f69f9cb197ae8f9cd24a16c9c0", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 19, "deletions": 59, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -315,47 +315,6 @@ fn test_clear() {\n     // If the unsafe block didn't drop things properly, we blow up here.\n }\n \n-#[test]\n-fn test_dedup() {\n-    fn case(a: Vec<i32>, b: Vec<i32>) {\n-        let mut v = a;\n-        v.dedup();\n-        assert_eq!(v, b);\n-    }\n-    case(vec![], vec![]);\n-    case(vec![1], vec![1]);\n-    case(vec![1, 1], vec![1]);\n-    case(vec![1, 2, 3], vec![1, 2, 3]);\n-    case(vec![1, 1, 2, 3], vec![1, 2, 3]);\n-    case(vec![1, 2, 2, 3], vec![1, 2, 3]);\n-    case(vec![1, 2, 3, 3], vec![1, 2, 3]);\n-    case(vec![1, 1, 2, 2, 2, 3, 3], vec![1, 2, 3]);\n-}\n-\n-#[test]\n-fn test_dedup_unique() {\n-    let mut v0: Vec<Box<_>> = vec![box 1, box 1, box 2, box 3];\n-    v0.dedup();\n-    let mut v1: Vec<Box<_>> = vec![box 1, box 2, box 2, box 3];\n-    v1.dedup();\n-    let mut v2: Vec<Box<_>> = vec![box 1, box 2, box 3, box 3];\n-    v2.dedup();\n-    // If the boxed pointers were leaked or otherwise misused, valgrind\n-    // and/or rt should raise errors.\n-}\n-\n-#[test]\n-fn test_dedup_shared() {\n-    let mut v0: Vec<Box<_>> = vec![box 1, box 1, box 2, box 3];\n-    v0.dedup();\n-    let mut v1: Vec<Box<_>> = vec![box 1, box 2, box 2, box 3];\n-    v1.dedup();\n-    let mut v2: Vec<Box<_>> = vec![box 1, box 2, box 3, box 3];\n-    v2.dedup();\n-    // If the pointers were leaked or otherwise misused, valgrind and/or\n-    // rt should raise errors.\n-}\n-\n #[test]\n fn test_retain() {\n     let mut v = vec![1, 2, 3, 4, 5];\n@@ -461,12 +420,12 @@ fn test_sort_stability() {\n             // number this element is, i.e. the second elements\n             // will occur in sorted order.\n             let mut v: Vec<_> = (0..len)\n-                                    .map(|_| {\n-                                        let n = thread_rng().gen::<usize>() % 10;\n-                                        counts[n] += 1;\n-                                        (n, counts[n])\n-                                    })\n-                                    .collect();\n+                .map(|_| {\n+                    let n = thread_rng().gen::<usize>() % 10;\n+                    counts[n] += 1;\n+                    (n, counts[n])\n+                })\n+                .collect();\n \n             // only sort on the first element, so an unstable sort\n             // may mix up the counts.\n@@ -1116,6 +1075,7 @@ fn test_box_slice_clone() {\n }\n \n #[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n fn test_box_slice_clone_panics() {\n     use std::sync::Arc;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n@@ -1156,13 +1116,13 @@ fn test_box_slice_clone_panics() {\n     };\n \n     spawn(move || {\n-        // When xs is dropped, +5.\n-        let xs = vec![canary.clone(), canary.clone(), canary.clone(), panic, canary]\n-                     .into_boxed_slice();\n+            // When xs is dropped, +5.\n+            let xs = vec![canary.clone(), canary.clone(), canary.clone(), panic, canary]\n+                .into_boxed_slice();\n \n-        // When panic is cloned, +3.\n-        xs.clone();\n-    })\n+            // When panic is cloned, +3.\n+            xs.clone();\n+        })\n         .join()\n         .unwrap_err();\n \n@@ -1414,8 +1374,8 @@ mod bench {\n         let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<BigSortable>()\n-                           .take(5)\n-                           .collect::<Vec<BigSortable>>();\n+                .take(5)\n+                .collect::<Vec<BigSortable>>();\n             v.sort();\n         });\n         b.bytes = 5 * mem::size_of::<BigSortable>() as u64;\n@@ -1426,8 +1386,8 @@ mod bench {\n         let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<BigSortable>()\n-                           .take(100)\n-                           .collect::<Vec<BigSortable>>();\n+                .take(100)\n+                .collect::<Vec<BigSortable>>();\n             v.sort();\n         });\n         b.bytes = 100 * mem::size_of::<BigSortable>() as u64;\n@@ -1438,8 +1398,8 @@ mod bench {\n         let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<BigSortable>()\n-                           .take(10000)\n-                           .collect::<Vec<BigSortable>>();\n+                .take(10000)\n+                .collect::<Vec<BigSortable>>();\n             v.sort();\n         });\n         b.bytes = 10000 * mem::size_of::<BigSortable>() as u64;"}, {"sha": "cc56bbf4890aa46de435ab3048d1952aeaaa7e18", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -786,9 +786,9 @@ fn test_rev_iterator() {\n \n #[test]\n fn test_chars_decoding() {\n+    let mut bytes = [0; 4];\n     for c in (0..0x110000).filter_map(::std::char::from_u32) {\n-        let bytes = c.encode_utf8();\n-        let s = ::std::str::from_utf8(bytes.as_slice()).unwrap();\n+        let s = c.encode_utf8(&mut bytes);\n         if Some(c) != s.chars().next() {\n             panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n         }\n@@ -797,9 +797,9 @@ fn test_chars_decoding() {\n \n #[test]\n fn test_chars_rev_decoding() {\n+    let mut bytes = [0; 4];\n     for c in (0..0x110000).filter_map(::std::char::from_u32) {\n-        let bytes = c.encode_utf8();\n-        let s = ::std::str::from_utf8(bytes.as_slice()).unwrap();\n+        let s = c.encode_utf8(&mut bytes);\n         if Some(c) != s.chars().rev().next() {\n             panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n         }\n@@ -1286,6 +1286,13 @@ fn test_cow_from() {\n     }\n }\n \n+#[test]\n+fn test_repeat() {\n+    assert_eq!(\"\".repeat(3), \"\");\n+    assert_eq!(\"abc\".repeat(0), \"\");\n+    assert_eq!(\"\u03b1\".repeat(3), \"\u03b1\u03b1\u03b1\");\n+}\n+\n mod pattern {\n     use std::str::pattern::Pattern;\n     use std::str::pattern::{Searcher, ReverseSearcher};"}, {"sha": "98de33bdaa8e14d587708ba710a5bd605b49ee1e", "filename": "src/libcollectionstest/string.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -35,6 +35,12 @@ fn test_from_str() {\n     assert_eq!(owned.as_ref().map(|s| &**s), Some(\"string\"));\n }\n \n+#[test]\n+fn test_from_cow_str() {\n+    assert_eq!(String::from(Cow::Borrowed(\"string\")), \"string\");\n+    assert_eq!(String::from(Cow::Owned(String::from(\"string\"))), \"string\");\n+}\n+\n #[test]\n fn test_unsized_to_string() {\n     let s: &str = \"abc\";"}, {"sha": "3bc1321d75653cd31a5e52e910cd62173c404fd7", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 74, "deletions": 7, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::ascii::AsciiExt;\n use std::borrow::Cow;\n use std::iter::{FromIterator, repeat};\n use std::mem::size_of;\n@@ -213,6 +214,60 @@ fn test_retain() {\n     assert_eq!(vec, [2, 4]);\n }\n \n+#[test]\n+fn test_dedup() {\n+    fn case(a: Vec<i32>, b: Vec<i32>) {\n+        let mut v = a;\n+        v.dedup();\n+        assert_eq!(v, b);\n+    }\n+    case(vec![], vec![]);\n+    case(vec![1], vec![1]);\n+    case(vec![1, 1], vec![1]);\n+    case(vec![1, 2, 3], vec![1, 2, 3]);\n+    case(vec![1, 1, 2, 3], vec![1, 2, 3]);\n+    case(vec![1, 2, 2, 3], vec![1, 2, 3]);\n+    case(vec![1, 2, 3, 3], vec![1, 2, 3]);\n+    case(vec![1, 1, 2, 2, 2, 3, 3], vec![1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_dedup_by_key() {\n+    fn case(a: Vec<i32>, b: Vec<i32>) {\n+        let mut v = a;\n+        v.dedup_by_key(|i| *i / 10);\n+        assert_eq!(v, b);\n+    }\n+    case(vec![], vec![]);\n+    case(vec![10], vec![10]);\n+    case(vec![10, 11], vec![10]);\n+    case(vec![10, 20, 30], vec![10, 20, 30]);\n+    case(vec![10, 11, 20, 30], vec![10, 20, 30]);\n+    case(vec![10, 20, 21, 30], vec![10, 20, 30]);\n+    case(vec![10, 20, 30, 31], vec![10, 20, 30]);\n+    case(vec![10, 11, 20, 21, 22, 30, 31], vec![10, 20, 30]);\n+}\n+\n+#[test]\n+fn test_dedup_by() {\n+    let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n+    vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n+\n+    assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n+}\n+\n+#[test]\n+fn test_dedup_unique() {\n+    let mut v0: Vec<Box<_>> = vec![box 1, box 1, box 2, box 3];\n+    v0.dedup();\n+    let mut v1: Vec<Box<_>> = vec![box 1, box 2, box 2, box 3];\n+    v1.dedup();\n+    let mut v2: Vec<Box<_>> = vec![box 1, box 2, box 3, box 3];\n+    v2.dedup();\n+    // If the boxed pointers were leaked or otherwise misused, valgrind\n+    // and/or rt should raise errors.\n+}\n+\n #[test]\n fn zero_sized_values() {\n     let mut v = Vec::new();\n@@ -271,22 +326,22 @@ fn test_zip_unzip() {\n \n #[test]\n fn test_vec_truncate_drop() {\n-    static mut drops: u32 = 0;\n+    static mut DROPS: u32 = 0;\n     struct Elem(i32);\n     impl Drop for Elem {\n         fn drop(&mut self) {\n             unsafe {\n-                drops += 1;\n+                DROPS += 1;\n             }\n         }\n     }\n \n     let mut v = vec![Elem(1), Elem(2), Elem(3), Elem(4), Elem(5)];\n-    assert_eq!(unsafe { drops }, 0);\n+    assert_eq!(unsafe { DROPS }, 0);\n     v.truncate(3);\n-    assert_eq!(unsafe { drops }, 2);\n+    assert_eq!(unsafe { DROPS }, 2);\n     v.truncate(0);\n-    assert_eq!(unsafe { drops }, 5);\n+    assert_eq!(unsafe { DROPS }, 5);\n }\n \n #[test]\n@@ -542,10 +597,22 @@ fn test_cow_from() {\n     }\n }\n \n+#[test]\n+fn test_from_cow() {\n+    let borrowed: &[_] = &[\"borrowed\", \"(slice)\"];\n+    let owned = vec![\"owned\", \"(vec)\"];\n+    assert_eq!(Vec::from(Cow::Borrowed(borrowed)), vec![\"borrowed\", \"(slice)\"]);\n+    assert_eq!(Vec::from(Cow::Owned(owned)), vec![\"owned\", \"(vec)\"]);\n+}\n+\n #[allow(dead_code)]\n fn assert_covariance() {\n-    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> { d }\n-    fn into_iter<'new>(i: IntoIter<&'static str>) -> IntoIter<&'new str> { i }\n+    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {\n+        d\n+    }\n+    fn into_iter<'new>(i: IntoIter<&'static str>) -> IntoIter<&'new str> {\n+        i\n+    }\n }\n \n #[bench]"}, {"sha": "f1ea85a6c5bed98e700fe42df0319a42f9765803", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -686,21 +686,21 @@ fn test_show() {\n     assert_eq!(format!(\"{:?}\", ringbuf), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n     let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"]\n-                                   .iter()\n-                                   .cloned()\n-                                   .collect();\n+        .iter()\n+        .cloned()\n+        .collect();\n     assert_eq!(format!(\"{:?}\", ringbuf),\n                \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n }\n \n #[test]\n fn test_drop() {\n-    static mut drops: i32 = 0;\n+    static mut DROPS: i32 = 0;\n     struct Elem;\n     impl Drop for Elem {\n         fn drop(&mut self) {\n             unsafe {\n-                drops += 1;\n+                DROPS += 1;\n             }\n         }\n     }\n@@ -712,17 +712,17 @@ fn test_drop() {\n     ring.push_front(Elem);\n     drop(ring);\n \n-    assert_eq!(unsafe { drops }, 4);\n+    assert_eq!(unsafe { DROPS }, 4);\n }\n \n #[test]\n fn test_drop_with_pop() {\n-    static mut drops: i32 = 0;\n+    static mut DROPS: i32 = 0;\n     struct Elem;\n     impl Drop for Elem {\n         fn drop(&mut self) {\n             unsafe {\n-                drops += 1;\n+                DROPS += 1;\n             }\n         }\n     }\n@@ -735,20 +735,20 @@ fn test_drop_with_pop() {\n \n     drop(ring.pop_back());\n     drop(ring.pop_front());\n-    assert_eq!(unsafe { drops }, 2);\n+    assert_eq!(unsafe { DROPS }, 2);\n \n     drop(ring);\n-    assert_eq!(unsafe { drops }, 4);\n+    assert_eq!(unsafe { DROPS }, 4);\n }\n \n #[test]\n fn test_drop_clear() {\n-    static mut drops: i32 = 0;\n+    static mut DROPS: i32 = 0;\n     struct Elem;\n     impl Drop for Elem {\n         fn drop(&mut self) {\n             unsafe {\n-                drops += 1;\n+                DROPS += 1;\n             }\n         }\n     }\n@@ -759,10 +759,10 @@ fn test_drop_clear() {\n     ring.push_back(Elem);\n     ring.push_front(Elem);\n     ring.clear();\n-    assert_eq!(unsafe { drops }, 4);\n+    assert_eq!(unsafe { DROPS }, 4);\n \n     drop(ring);\n-    assert_eq!(unsafe { drops }, 4);\n+    assert_eq!(unsafe { DROPS }, 4);\n }\n \n #[test]\n@@ -1003,5 +1003,7 @@ fn test_contains() {\n \n #[allow(dead_code)]\n fn assert_covariance() {\n-    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> { d }\n+    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {\n+        d\n+    }\n }"}, {"sha": "acbd39bb1630c483c3a25064c8780eb95c118728", "filename": "src/libcompiler_builtins/build.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcompiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcompiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Fbuild.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -72,7 +72,13 @@ impl Sources {\n }\n \n fn main() {\n-    let target = env::var(\"TARGET\").unwrap();\n+    let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n+\n+    // Emscripten's runtime includes all the builtins\n+    if target.contains(\"emscripten\") {\n+        return;\n+    }\n+\n     let cfg = &mut gcc::Config::new();\n \n     if target.contains(\"msvc\") {"}, {"sha": "4a703b3da68f64c1b34e48f16075ac4ef2a213dd", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![cfg_attr(not(stage0), feature(compiler_builtins))]\n+#![feature(compiler_builtins)]\n #![no_std]\n-#![cfg_attr(not(stage0), compiler_builtins)]\n+#![compiler_builtins]\n #![unstable(feature = \"compiler_builtins_lib\",\n             reason = \"internal implementation detail of rustc right now\",\n             issue = \"0\")]"}, {"sha": "eb0636e8576beb147e3c4f3823cd7e5b2cb09b46", "filename": "src/libcore/any.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -73,7 +73,6 @@\n \n use fmt;\n use intrinsics;\n-use marker::Reflect;\n \n ///////////////////////////////////////////////////////////////////////////////\n // Any trait\n@@ -86,7 +85,7 @@ use marker::Reflect;\n ///\n /// [mod]: index.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Any: Reflect + 'static {\n+pub trait Any: 'static {\n     /// Gets the `TypeId` of `self`.\n     ///\n     /// # Examples\n@@ -112,7 +111,7 @@ pub trait Any: Reflect + 'static {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Reflect + 'static + ?Sized > Any for T {\n+impl<T: 'static + ?Sized > Any for T {\n     fn get_type_id(&self) -> TypeId { TypeId::of::<T>() }\n }\n \n@@ -352,12 +351,10 @@ impl TypeId {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(get_type_id)]\n-    ///\n     /// use std::any::{Any, TypeId};\n     ///\n-    /// fn is_string(s: &Any) -> bool {\n-    ///     TypeId::of::<String>() == s.get_type_id()\n+    /// fn is_string<T: ?Sized + Any>(_s: &T) -> bool {\n+    ///     TypeId::of::<String>() == TypeId::of::<T>()\n     /// }\n     ///\n     /// fn main() {\n@@ -366,7 +363,7 @@ impl TypeId {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn of<T: ?Sized + Reflect + 'static>() -> TypeId {\n+    pub fn of<T: ?Sized + 'static>() -> TypeId {\n         TypeId {\n             t: unsafe { intrinsics::type_id::<T>() },\n         }"}, {"sha": "37bd57034a7b6ed7647f13950730facff135cc82", "filename": "src/libcore/array.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -93,13 +93,15 @@ macro_rules! __impl_slice_eq2 {\n macro_rules! array_impls {\n     ($($N:expr)+) => {\n         $(\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T> AsRef<[T]> for [T; $N] {\n                 #[inline]\n                 fn as_ref(&self) -> &[T] {\n                     &self[..]\n                 }\n             }\n \n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T> AsMut<[T]> for [T; $N] {\n                 #[inline]\n                 fn as_mut(&mut self) -> &mut [T] {"}, {"sha": "64a7a8c5ef785f1ed6f82e31ef2a6101c26a0b00", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -175,7 +175,7 @@\n \n use cmp::Ordering;\n use fmt::{self, Debug, Display};\n-use marker::{PhantomData, Unsize};\n+use marker::Unsize;\n use ops::{Deref, DerefMut, CoerceUnsized};\n \n /// A mutable memory location that admits only `Copy` data.\n@@ -403,40 +403,40 @@ pub enum BorrowState {\n }\n \n /// An error returned by [`RefCell::try_borrow`](struct.RefCell.html#method.try_borrow).\n-#[unstable(feature = \"try_borrow\", issue = \"35070\")]\n-pub struct BorrowError<'a, T: 'a + ?Sized> {\n-    marker: PhantomData<&'a RefCell<T>>,\n+#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n+pub struct BorrowError {\n+    _private: (),\n }\n \n-#[unstable(feature = \"try_borrow\", issue = \"35070\")]\n-impl<'a, T: ?Sized> Debug for BorrowError<'a, T> {\n+#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n+impl Debug for BorrowError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"BorrowError\").finish()\n     }\n }\n \n-#[unstable(feature = \"try_borrow\", issue = \"35070\")]\n-impl<'a, T: ?Sized> Display for BorrowError<'a, T> {\n+#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n+impl Display for BorrowError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         Display::fmt(\"already mutably borrowed\", f)\n     }\n }\n \n /// An error returned by [`RefCell::try_borrow_mut`](struct.RefCell.html#method.try_borrow_mut).\n-#[unstable(feature = \"try_borrow\", issue = \"35070\")]\n-pub struct BorrowMutError<'a, T: 'a + ?Sized> {\n-    marker: PhantomData<&'a RefCell<T>>,\n+#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n+pub struct BorrowMutError {\n+    _private: (),\n }\n \n-#[unstable(feature = \"try_borrow\", issue = \"35070\")]\n-impl<'a, T: ?Sized> Debug for BorrowMutError<'a, T> {\n+#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n+impl Debug for BorrowMutError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"BorrowMutError\").finish()\n     }\n }\n \n-#[unstable(feature = \"try_borrow\", issue = \"35070\")]\n-impl<'a, T: ?Sized> Display for BorrowMutError<'a, T> {\n+#[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n+impl Display for BorrowMutError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         Display::fmt(\"already borrowed\", f)\n     }\n@@ -573,8 +573,6 @@ impl<T: ?Sized> RefCell<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(try_borrow)]\n-    ///\n     /// use std::cell::RefCell;\n     ///\n     /// let c = RefCell::new(5);\n@@ -589,15 +587,15 @@ impl<T: ?Sized> RefCell<T> {\n     ///     assert!(c.try_borrow().is_ok());\n     /// }\n     /// ```\n-    #[unstable(feature = \"try_borrow\", issue = \"35070\")]\n+    #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n     #[inline]\n-    pub fn try_borrow(&self) -> Result<Ref<T>, BorrowError<T>> {\n+    pub fn try_borrow(&self) -> Result<Ref<T>, BorrowError> {\n         match BorrowRef::new(&self.borrow) {\n             Some(b) => Ok(Ref {\n                 value: unsafe { &*self.value.get() },\n                 borrow: b,\n             }),\n-            None => Err(BorrowError { marker: PhantomData }),\n+            None => Err(BorrowError { _private: () }),\n         }\n     }\n \n@@ -654,8 +652,6 @@ impl<T: ?Sized> RefCell<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(try_borrow)]\n-    ///\n     /// use std::cell::RefCell;\n     ///\n     /// let c = RefCell::new(5);\n@@ -667,15 +663,15 @@ impl<T: ?Sized> RefCell<T> {\n     ///\n     /// assert!(c.try_borrow_mut().is_ok());\n     /// ```\n-    #[unstable(feature = \"try_borrow\", issue = \"35070\")]\n+    #[stable(feature = \"try_borrow\", since = \"1.13.0\")]\n     #[inline]\n-    pub fn try_borrow_mut(&self) -> Result<RefMut<T>, BorrowMutError<T>> {\n+    pub fn try_borrow_mut(&self) -> Result<RefMut<T>, BorrowMutError> {\n         match BorrowRefMut::new(&self.borrow) {\n             Some(b) => Ok(RefMut {\n                 value: unsafe { &mut *self.value.get() },\n                 borrow: b,\n             }),\n-            None => Err(BorrowMutError { marker: PhantomData }),\n+            None => Err(BorrowMutError { _private: () }),\n         }\n     }\n "}, {"sha": "26d28049a474d3f6d4076a3a52c8092a977963d9", "filename": "src/libcore/char.rs", "status": "modified", "additions": 52, "deletions": 120, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -18,6 +18,7 @@\n use char_private::is_printable;\n use convert::TryFrom;\n use fmt;\n+use slice;\n use iter::FusedIterator;\n use mem::transmute;\n \n@@ -327,9 +328,9 @@ pub trait CharExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn len_utf16(self) -> usize;\n     #[unstable(feature = \"unicode\", issue = \"27784\")]\n-    fn encode_utf8(self) -> EncodeUtf8;\n+    fn encode_utf8(self, dst: &mut [u8]) -> &mut str;\n     #[unstable(feature = \"unicode\", issue = \"27784\")]\n-    fn encode_utf16(self) -> EncodeUtf16;\n+    fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16];\n }\n \n #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -419,47 +420,59 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    fn encode_utf8(self) -> EncodeUtf8 {\n+    fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n         let code = self as u32;\n-        let mut buf = [0; 4];\n-        let pos = if code < MAX_ONE_B {\n-            buf[3] = code as u8;\n-            3\n-        } else if code < MAX_TWO_B {\n-            buf[2] = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n-            buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n-            2\n-        } else if code < MAX_THREE_B {\n-            buf[1] = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n-            buf[2] = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n-            buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n-            1\n-        } else {\n-            buf[0] = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n-            buf[1] = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n-            buf[2] = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n-            buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n-            0\n-        };\n-        EncodeUtf8 { buf: buf, pos: pos }\n+        unsafe {\n+            let len =\n+            if code < MAX_ONE_B && !dst.is_empty() {\n+                *dst.get_unchecked_mut(0) = code as u8;\n+                1\n+            } else if code < MAX_TWO_B && dst.len() >= 2 {\n+                *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n+                *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;\n+                2\n+            } else if code < MAX_THREE_B && dst.len() >= 3  {\n+                *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n+                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;\n+                3\n+            } else if dst.len() >= 4 {\n+                *dst.get_unchecked_mut(0) = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n+                *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;\n+                4\n+            } else {\n+                panic!(\"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n+                    from_u32_unchecked(code).len_utf8(),\n+                    code,\n+                    dst.len())\n+            };\n+            transmute(slice::from_raw_parts_mut(dst.as_mut_ptr(), len))\n+        }\n     }\n \n     #[inline]\n-    fn encode_utf16(self) -> EncodeUtf16 {\n-        let mut buf = [0; 2];\n+    fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {\n         let mut code = self as u32;\n-        let pos = if (code & 0xFFFF) == code {\n-            // The BMP falls through (assuming non-surrogate, as it should)\n-            buf[1] = code as u16;\n-            1\n-        } else {\n-            // Supplementary planes break into surrogates.\n-            code -= 0x1_0000;\n-            buf[0] = 0xD800 | ((code >> 10) as u16);\n-            buf[1] = 0xDC00 | ((code as u16) & 0x3FF);\n-            0\n-        };\n-        EncodeUtf16 { buf: buf, pos: pos }\n+        unsafe {\n+            if (code & 0xFFFF) == code && !dst.is_empty() {\n+                // The BMP falls through (assuming non-surrogate, as it should)\n+                *dst.get_unchecked_mut(0) = code as u16;\n+                slice::from_raw_parts_mut(dst.as_mut_ptr(), 1)\n+            } else if dst.len() >= 2 {\n+                // Supplementary planes break into surrogates.\n+                code -= 0x1_0000;\n+                *dst.get_unchecked_mut(0) = 0xD800 | ((code >> 10) as u16);\n+                *dst.get_unchecked_mut(1) = 0xDC00 | ((code as u16) & 0x3FF);\n+                slice::from_raw_parts_mut(dst.as_mut_ptr(), 2)\n+            } else {\n+                panic!(\"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n+                    from_u32_unchecked(code).len_utf16(),\n+                    code,\n+                    dst.len())\n+            }\n+        }\n     }\n }\n \n@@ -702,88 +715,7 @@ impl ExactSizeIterator for EscapeDebug { }\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl FusedIterator for EscapeDebug {}\n \n-/// An iterator over `u8` entries represending the UTF-8 encoding of a `char`\n-/// value.\n-///\n-/// Constructed via the `.encode_utf8()` method on `char`.\n-#[unstable(feature = \"unicode\", issue = \"27784\")]\n-#[derive(Debug)]\n-pub struct EncodeUtf8 {\n-    buf: [u8; 4],\n-    pos: usize,\n-}\n-\n-impl EncodeUtf8 {\n-    /// Returns the remaining bytes of this iterator as a slice.\n-    #[unstable(feature = \"unicode\", issue = \"27784\")]\n-    pub fn as_slice(&self) -> &[u8] {\n-        &self.buf[self.pos..]\n-    }\n-}\n-\n-#[unstable(feature = \"unicode\", issue = \"27784\")]\n-impl Iterator for EncodeUtf8 {\n-    type Item = u8;\n-\n-    fn next(&mut self) -> Option<u8> {\n-        if self.pos == self.buf.len() {\n-            None\n-        } else {\n-            let ret = Some(self.buf[self.pos]);\n-            self.pos += 1;\n-            ret\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.as_slice().iter().size_hint()\n-    }\n-}\n-\n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-impl FusedIterator for EncodeUtf8 {}\n-\n-/// An iterator over `u16` entries represending the UTF-16 encoding of a `char`\n-/// value.\n-///\n-/// Constructed via the `.encode_utf16()` method on `char`.\n-#[unstable(feature = \"unicode\", issue = \"27784\")]\n-#[derive(Debug)]\n-pub struct EncodeUtf16 {\n-    buf: [u16; 2],\n-    pos: usize,\n-}\n-\n-impl EncodeUtf16 {\n-    /// Returns the remaining bytes of this iterator as a slice.\n-    #[unstable(feature = \"unicode\", issue = \"27784\")]\n-    pub fn as_slice(&self) -> &[u16] {\n-        &self.buf[self.pos..]\n-    }\n-}\n-\n-\n-#[unstable(feature = \"unicode\", issue = \"27784\")]\n-impl Iterator for EncodeUtf16 {\n-    type Item = u16;\n-\n-    fn next(&mut self) -> Option<u16> {\n-        if self.pos == self.buf.len() {\n-            None\n-        } else {\n-            let ret = Some(self.buf[self.pos]);\n-            self.pos += 1;\n-            ret\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.as_slice().iter().size_hint()\n-    }\n-}\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-impl FusedIterator for EncodeUtf16 {}\n \n /// An iterator over an iterator of bytes of the characters the bytes represent\n /// as UTF-8\n@@ -800,7 +732,7 @@ pub fn decode_utf8<I: IntoIterator<Item = u8>>(i: I) -> DecodeUtf8<I::IntoIter>\n \n /// `<DecodeUtf8 as Iterator>::next` returns this for an invalid input sequence.\n #[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[derive(PartialEq, Debug)]\n+#[derive(PartialEq, Eq, Debug)]\n pub struct InvalidSequence(());\n \n #[unstable(feature = \"decode_utf8\", issue = \"33906\")]"}, {"sha": "d72b18ae345ce144018d56722403516f99727bdd", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -129,13 +129,6 @@ pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: ::marker::PhantomData\n            reason = \"deriving hack, should not be public\",\n            issue = \"0\")]\n pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T> }\n-#[cfg(stage0)]\n-#[doc(hidden)]\n-#[inline(always)]\n-#[unstable(feature = \"derive_clone_copy\",\n-           reason = \"deriving hack, should not be public\",\n-           issue = \"0\")]\n-pub fn assert_receiver_is_clone<T: Clone + ?Sized>(_: &T) {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Clone for &'a T {"}, {"sha": "0daf658a0f42da4e5736fb0cf29e1a7d8f1329a1", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -10,10 +10,13 @@\n \n //! Functionality for ordering and comparison.\n //!\n-//! This module defines both `PartialOrd` and `PartialEq` traits which are used\n+//! This module defines both [`PartialOrd`] and [`PartialEq`] traits which are used\n //! by the compiler to implement comparison operators. Rust programs may\n-//! implement `PartialOrd` to overload the `<`, `<=`, `>`, and `>=` operators,\n-//! and may implement `PartialEq` to overload the `==` and `!=` operators.\n+//! implement [`PartialOrd`] to overload the `<`, `<=`, `>`, and `>=` operators,\n+//! and may implement [`PartialEq`] to overload the `==` and `!=` operators.\n+//!\n+//! [`PartialOrd`]: trait.PartialOrd.html\n+//! [`PartialEq`]: trait.PartialEq.html\n //!\n //! # Examples\n //!\n@@ -777,24 +780,24 @@ mod impls {\n \n     ord_impl! { char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n     impl PartialEq for ! {\n         fn eq(&self, _: &!) -> bool {\n             *self\n         }\n     }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n     impl Eq for ! {}\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n     impl PartialOrd for ! {\n         fn partial_cmp(&self, _: &!) -> Option<Ordering> {\n             *self\n         }\n     }\n \n-    #[unstable(feature = \"never_type\", issue = \"35121\")]\n+    #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n     impl Ord for ! {\n         fn cmp(&self, _: &!) -> Ordering {\n             *self"}, {"sha": "5f16a4f2435f8549e49fec9d2016f33262d9ec2f", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -92,6 +92,22 @@ pub trait AsRef<T: ?Sized> {\n /// [`Option<T>`]: ../../std/option/enum.Option.html\n /// [`Result<T, E>`]: ../../std/result/enum.Result.html\n ///\n+/// # Examples\n+///\n+/// [`Box<T>`] implements `AsMut<T>`:\n+///\n+/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n+///\n+/// ```\n+/// fn add_one<T: AsMut<u64>>(num: &mut T) {\n+///     *num.as_mut() += 1;\n+/// }\n+///\n+/// let mut boxed_num = Box::new(0);\n+/// add_one(&mut boxed_num);\n+/// assert_eq!(*boxed_num, 1);\n+/// ```\n+///\n /// # Generic Impls\n ///\n /// - `AsMut` auto-dereferences if the inner type is a reference or a mutable"}, {"sha": "2d75a8ec420b1cfa9252c8cd43d8b4a4c14a2016", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -97,9 +97,7 @@ pub trait Write {\n     /// This function will return an instance of `Error` on error.\n     #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n     fn write_char(&mut self, c: char) -> Result {\n-        self.write_str(unsafe {\n-            str::from_utf8_unchecked(c.encode_utf8().as_slice())\n-        })\n+        self.write_str(c.encode_utf8(&mut [0; 4]))\n     }\n \n     /// Glue for usage of the `write!` macro with implementors of this trait.\n@@ -272,10 +270,14 @@ impl<'a> Arguments<'a> {\n /// safely be done so, so no constructors are given and the fields are private\n /// to prevent modification.\n ///\n-/// The `format_args!` macro will safely create an instance of this structure\n+/// The [`format_args!`] macro will safely create an instance of this structure\n /// and pass it to a function or closure, passed as the first argument. The\n-/// macro validates the format string at compile-time so usage of the `write`\n-/// and `format` functions can be safely performed.\n+/// macro validates the format string at compile-time so usage of the [`write`]\n+/// and [`format`] functions can be safely performed.\n+///\n+/// [`format_args!`]: ../../std/macro.format_args.html\n+/// [`format`]: ../../std/fmt/fn.format.html\n+/// [`write`]: ../../std/fmt/fn.write.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone)]\n pub struct Arguments<'a> {\n@@ -792,7 +794,7 @@ pub trait UpperExp {\n /// assert_eq!(output, \"Hello world!\");\n /// ```\n ///\n-/// Please note that using [`write!`][write_macro] might be preferrable. Example:\n+/// Please note that using [`write!`] might be preferrable. Example:\n ///\n /// ```\n /// use std::fmt::Write;\n@@ -803,7 +805,7 @@ pub trait UpperExp {\n /// assert_eq!(output, \"Hello world!\");\n /// ```\n ///\n-/// [write_macro]: ../../std/macro.write!.html\n+/// [`write!`]: ../../std/macro.write.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn write(output: &mut Write, args: Arguments) -> Result {\n     let mut formatter = Formatter {\n@@ -920,9 +922,7 @@ impl<'a> Formatter<'a> {\n         // Writes the sign if it exists, and then the prefix if it was requested\n         let write_prefix = |f: &mut Formatter| {\n             if let Some(c) = sign {\n-                f.buf.write_str(unsafe {\n-                    str::from_utf8_unchecked(c.encode_utf8().as_slice())\n-                })?;\n+                f.buf.write_str(c.encode_utf8(&mut [0; 4]))?;\n             }\n             if prefixed { f.buf.write_str(prefix) }\n             else { Ok(()) }\n@@ -1028,10 +1028,8 @@ impl<'a> Formatter<'a> {\n             rt::v1::Alignment::Center => (padding / 2, (padding + 1) / 2),\n         };\n \n-        let fill = self.fill.encode_utf8();\n-        let fill = unsafe {\n-            str::from_utf8_unchecked(fill.as_slice())\n-        };\n+        let mut fill = [0; 4];\n+        let fill = self.fill.encode_utf8(&mut fill);\n \n         for _ in 0..pre_pad {\n             self.buf.write_str(fill)?;\n@@ -1358,14 +1356,14 @@ macro_rules! fmt_refs {\n \n fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n \n-#[unstable(feature = \"never_type\", issue = \"35121\")]\n+#[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n impl Debug for ! {\n     fn fmt(&self, _: &mut Formatter) -> Result {\n         *self\n     }\n }\n \n-#[unstable(feature = \"never_type\", issue = \"35121\")]\n+#[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n impl Display for ! {\n     fn fmt(&self, _: &mut Formatter) -> Result {\n         *self\n@@ -1431,9 +1429,7 @@ impl Display for char {\n         if f.width.is_none() && f.precision.is_none() {\n             f.write_char(*self)\n         } else {\n-            f.pad(unsafe {\n-                str::from_utf8_unchecked(self.encode_utf8().as_slice())\n-            })\n+            f.pad(self.encode_utf8(&mut [0; 4]))\n         }\n     }\n }\n@@ -1570,11 +1566,11 @@ floating! { f64 }\n // Implementation of Display/Debug for various core types\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Debug for *const T {\n+impl<T: ?Sized> Debug for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Debug for *mut T {\n+impl<T: ?Sized> Debug for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n "}, {"sha": "ec7add9c3759f9d61969d6303aa0d6363186923e", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -31,7 +31,7 @@ pub struct FormatSpec {\n }\n \n /// Possible alignments that can be requested as part of a formatting directive.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Eq)]\n pub enum Alignment {\n     /// Indication that contents should be left-aligned.\n     Left,"}, {"sha": "ac36cbaace7a89fe85cc97e5e57ee86b85dca396", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -38,7 +38,9 @@\n //! ```\n //!\n //! If you need more control over how a value is hashed, you need to implement\n-//! the `Hash` trait:\n+//! the [`Hash`] trait:\n+//!\n+//! [`Hash`]: trait.Hash.html\n //!\n //! ```rust\n //! use std::hash::{Hash, Hasher, SipHasher};\n@@ -76,9 +78,11 @@ use marker;\n use mem;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub use self::sip::SipHasher;\n \n #[unstable(feature = \"sip_hash_13\", issue = \"29754\")]\n+#[allow(deprecated)]\n pub use self::sip::{SipHasher13, SipHasher24};\n \n mod sip;\n@@ -88,21 +92,21 @@ mod sip;\n /// The `H` type parameter is an abstract hash state that is used by the `Hash`\n /// to compute the hash.\n ///\n-/// If you are also implementing `Eq`, there is an additional property that\n+/// If you are also implementing [`Eq`], there is an additional property that\n /// is important:\n ///\n /// ```text\n /// k1 == k2 -> hash(k1) == hash(k2)\n /// ```\n ///\n /// In other words, if two keys are equal, their hashes should also be equal.\n-/// `HashMap` and `HashSet` both rely on this behavior.\n+/// [`HashMap`] and [`HashSet`] both rely on this behavior.\n ///\n /// ## Derivable\n ///\n /// This trait can be used with `#[derive]` if all fields implement `Hash`.\n /// When `derive`d, the resulting hash will be the combination of the values\n-/// from calling `.hash()` on each field.\n+/// from calling [`.hash()`] on each field.\n ///\n /// ## How can I implement `Hash`?\n ///\n@@ -125,6 +129,11 @@ mod sip;\n ///     }\n /// }\n /// ```\n+///\n+/// [`Eq`]: ../../std/cmp/trait.Eq.html\n+/// [`HashMap`]: ../../std/collections/struct.HashMap.html\n+/// [`HashSet`]: ../../std/collections/struct.HashSet.html\n+/// [`.hash()`]: #tymethod.hash\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hash {\n     /// Feeds this value into the state given, updating the hasher as necessary.\n@@ -149,35 +158,35 @@ pub trait Hasher {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn finish(&self) -> u64;\n \n-    /// Writes some data into this `Hasher`\n+    /// Writes some data into this `Hasher`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write(&mut self, bytes: &[u8]);\n \n-    /// Write a single `u8` into this hasher\n+    /// Write a single `u8` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_u8(&mut self, i: u8) {\n         self.write(&[i])\n     }\n-    /// Write a single `u16` into this hasher.\n+    /// Writes a single `u16` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_u16(&mut self, i: u16) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 2]>(i) })\n     }\n-    /// Write a single `u32` into this hasher.\n+    /// Writes a single `u32` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_u32(&mut self, i: u32) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 4]>(i) })\n     }\n-    /// Write a single `u64` into this hasher.\n+    /// Writes a single `u64` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_u64(&mut self, i: u64) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i) })\n     }\n-    /// Write a single `usize` into this hasher.\n+    /// Writes a single `usize` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_usize(&mut self, i: usize) {\n@@ -187,31 +196,31 @@ pub trait Hasher {\n         self.write(bytes);\n     }\n \n-    /// Write a single `i8` into this hasher.\n+    /// Writes a single `i8` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_i8(&mut self, i: i8) {\n         self.write_u8(i as u8)\n     }\n-    /// Write a single `i16` into this hasher.\n+    /// Writes a single `i16` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_i16(&mut self, i: i16) {\n         self.write_u16(i as u16)\n     }\n-    /// Write a single `i32` into this hasher.\n+    /// Writes a single `i32` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_i32(&mut self, i: i32) {\n         self.write_u32(i as u32)\n     }\n-    /// Write a single `i64` into this hasher.\n+    /// Writes a single `i64` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_i64(&mut self, i: i64) {\n         self.write_u64(i as u64)\n     }\n-    /// Write a single `isize` into this hasher.\n+    /// Writes a single `isize` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_isize(&mut self, i: isize) {"}, {"sha": "6b3ab64dfd88ccb4bc67e1e4fdf6945ef01d8c7c", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 116, "deletions": 64, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -10,13 +10,21 @@\n \n //! An implementation of SipHash.\n \n+#![allow(deprecated)]\n+\n use marker::PhantomData;\n use ptr;\n+use cmp;\n+use mem;\n \n /// An implementation of SipHash 1-3.\n ///\n+/// This is currently the default hashing function used by standard library\n+/// (eg. `collections::HashMap` uses it by default).\n+///\n /// See: https://131002.net/siphash/\n #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+#[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n #[derive(Debug, Clone, Default)]\n pub struct SipHasher13 {\n     hasher: Hasher<Sip13Rounds>,\n@@ -26,6 +34,7 @@ pub struct SipHasher13 {\n ///\n /// See: https://131002.net/siphash/\n #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+#[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n #[derive(Debug, Clone, Default)]\n pub struct SipHasher24 {\n     hasher: Hasher<Sip24Rounds>,\n@@ -35,9 +44,6 @@ pub struct SipHasher24 {\n ///\n /// See: https://131002.net/siphash/\n ///\n-/// This is currently the default hashing function used by standard library\n-/// (eg. `collections::HashMap` uses it by default).\n-///\n /// SipHash is a general-purpose hashing function: it runs at a good\n /// speed (competitive with Spooky and City) and permits strong _keyed_\n /// hashing. This lets you key your hashtables from a strong RNG, such as\n@@ -47,6 +53,7 @@ pub struct SipHasher24 {\n /// it is not intended for cryptographic purposes. As such, all\n /// cryptographic uses of this implementation are _strongly discouraged_.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n #[derive(Debug, Clone, Default)]\n pub struct SipHasher(SipHasher24);\n \n@@ -73,93 +80,93 @@ struct State {\n     v3: u64,\n }\n \n-// sadly, these macro definitions can't appear later,\n-// because they're needed in the following defs;\n-// this design could be improved.\n-\n-macro_rules! u8to64_le {\n-    ($buf:expr, $i:expr) =>\n-    ($buf[0+$i] as u64 |\n-     ($buf[1+$i] as u64) << 8 |\n-     ($buf[2+$i] as u64) << 16 |\n-     ($buf[3+$i] as u64) << 24 |\n-     ($buf[4+$i] as u64) << 32 |\n-     ($buf[5+$i] as u64) << 40 |\n-     ($buf[6+$i] as u64) << 48 |\n-     ($buf[7+$i] as u64) << 56);\n-    ($buf:expr, $i:expr, $len:expr) =>\n+macro_rules! compress {\n+    ($state:expr) => ({\n+        compress!($state.v0, $state.v1, $state.v2, $state.v3)\n+    });\n+    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n     ({\n-        let mut t = 0;\n-        let mut out = 0;\n-        while t < $len {\n-            out |= ($buf[t+$i] as u64) << t*8;\n-            t += 1;\n-        }\n-        out\n+        $v0 = $v0.wrapping_add($v1); $v1 = $v1.rotate_left(13); $v1 ^= $v0;\n+        $v0 = $v0.rotate_left(32);\n+        $v2 = $v2.wrapping_add($v3); $v3 = $v3.rotate_left(16); $v3 ^= $v2;\n+        $v0 = $v0.wrapping_add($v3); $v3 = $v3.rotate_left(21); $v3 ^= $v0;\n+        $v2 = $v2.wrapping_add($v1); $v1 = $v1.rotate_left(17); $v1 ^= $v2;\n+        $v2 = $v2.rotate_left(32);\n     });\n }\n \n-/// Load a full u64 word from a byte stream, in LE order. Use\n+/// Load an integer of the desired type from a byte stream, in LE order. Uses\n /// `copy_nonoverlapping` to let the compiler generate the most efficient way\n-/// to load u64 from a possibly unaligned address.\n+/// to load it from a possibly unaligned address.\n ///\n-/// Unsafe because: unchecked indexing at i..i+8\n-#[inline]\n-unsafe fn load_u64_le(buf: &[u8], i: usize) -> u64 {\n-    debug_assert!(i + 8 <= buf.len());\n-    let mut data = 0u64;\n-    ptr::copy_nonoverlapping(buf.get_unchecked(i), &mut data as *mut _ as *mut u8, 8);\n-    data.to_le()\n-}\n-\n-macro_rules! rotl {\n-    ($x:expr, $b:expr) =>\n-    (($x << $b) | ($x >> (64_i32.wrapping_sub($b))))\n-}\n-\n-macro_rules! compress {\n-    ($state:expr) => ({\n-        compress!($state.v0, $state.v1, $state.v2, $state.v3)\n-    });\n-    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n+/// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\n+macro_rules! load_int_le {\n+    ($buf:expr, $i:expr, $int_ty:ident) =>\n     ({\n-        $v0 = $v0.wrapping_add($v1); $v1 = rotl!($v1, 13); $v1 ^= $v0;\n-        $v0 = rotl!($v0, 32);\n-        $v2 = $v2.wrapping_add($v3); $v3 = rotl!($v3, 16); $v3 ^= $v2;\n-        $v0 = $v0.wrapping_add($v3); $v3 = rotl!($v3, 21); $v3 ^= $v0;\n-        $v2 = $v2.wrapping_add($v1); $v1 = rotl!($v1, 17); $v1 ^= $v2;\n-        $v2 = rotl!($v2, 32);\n+       debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n+       let mut data = 0 as $int_ty;\n+       ptr::copy_nonoverlapping($buf.get_unchecked($i),\n+                                &mut data as *mut _ as *mut u8,\n+                                mem::size_of::<$int_ty>());\n+       data.to_le()\n     });\n }\n \n+/// Load an u64 using up to 7 bytes of a byte slice.\n+///\n+/// Unsafe because: unchecked indexing at start..start+len\n+#[inline]\n+unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n+    debug_assert!(len < 8);\n+    let mut i = 0; // current byte index (from LSB) in the output u64\n+    let mut out = 0;\n+    if i + 3 < len {\n+        out = load_int_le!(buf, start + i, u32) as u64;\n+        i += 4;\n+    }\n+    if i + 1 < len {\n+        out |= (load_int_le!(buf, start + i, u16) as u64) << (i * 8);\n+        i += 2\n+    }\n+    if i < len {\n+        out |= (*buf.get_unchecked(start + i) as u64) << (i * 8);\n+        i += 1;\n+    }\n+    debug_assert_eq!(i, len);\n+    out\n+}\n+\n impl SipHasher {\n     /// Creates a new `SipHasher` with the two initial keys set to 0.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n     pub fn new() -> SipHasher {\n         SipHasher::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher` that is keyed off the provided keys.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n         SipHasher(SipHasher24::new_with_keys(key0, key1))\n     }\n }\n \n-\n impl SipHasher13 {\n     /// Creates a new `SipHasher13` with the two initial keys set to 0.\n     #[inline]\n     #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n     pub fn new() -> SipHasher13 {\n         SipHasher13::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher13` that is keyed off the provided keys.\n     #[inline]\n     #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher13 {\n         SipHasher13 {\n             hasher: Hasher::new_with_keys(key0, key1)\n@@ -171,13 +178,15 @@ impl SipHasher24 {\n     /// Creates a new `SipHasher24` with the two initial keys set to 0.\n     #[inline]\n     #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n     pub fn new() -> SipHasher24 {\n         SipHasher24::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher24` that is keyed off the provided keys.\n     #[inline]\n     #[unstable(feature = \"sip_hash_13\", issue = \"34767\")]\n+    #[rustc_deprecated(since = \"1.13.0\", reason = \"use `DefaultHasher` instead\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher24 {\n         SipHasher24 {\n             hasher: Hasher::new_with_keys(key0, key1)\n@@ -215,6 +224,37 @@ impl<S: Sip> Hasher<S> {\n         self.state.v3 = self.k1 ^ 0x7465646279746573;\n         self.ntail = 0;\n     }\n+\n+    // Specialized write function that is only valid for buffers with len <= 8.\n+    // It's used to force inlining of write_u8 and write_usize, those would normally be inlined\n+    // except for composite types (that includes slices and str hashing because of delimiter).\n+    // Without this extra push the compiler is very reluctant to inline delimiter writes,\n+    // degrading performance substantially for the most common use cases.\n+    #[inline(always)]\n+    fn short_write(&mut self, msg: &[u8]) {\n+        debug_assert!(msg.len() <= 8);\n+        let length = msg.len();\n+        self.length += length;\n+\n+        let needed = 8 - self.ntail;\n+        let fill = cmp::min(length, needed);\n+        if fill == 8 {\n+            self.tail = unsafe { load_int_le!(msg, 0, u64) };\n+        } else {\n+            self.tail |= unsafe { u8to64_le(msg, 0, fill) } << (8 * self.ntail);\n+            if length < needed {\n+                self.ntail += length;\n+                return;\n+            }\n+        }\n+        self.state.v3 ^= self.tail;\n+        S::c_rounds(&mut self.state);\n+        self.state.v0 ^= self.tail;\n+\n+        // Buffered tail is now flushed, process new input.\n+        self.ntail = length - needed;\n+        self.tail = unsafe { u8to64_le(msg, needed, self.ntail) };\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -257,6 +297,21 @@ impl super::Hasher for SipHasher24 {\n }\n \n impl<S: Sip> super::Hasher for Hasher<S> {\n+    // see short_write comment for explanation\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        let bytes = unsafe {\n+            ::slice::from_raw_parts(&i as *const usize as *const u8, mem::size_of::<usize>())\n+        };\n+        self.short_write(bytes);\n+    }\n+\n+    // see short_write comment for explanation\n+    #[inline]\n+    fn write_u8(&mut self, i: u8) {\n+        self.short_write(&[i]);\n+    }\n+\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();\n@@ -266,19 +321,16 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n \n         if self.ntail != 0 {\n             needed = 8 - self.ntail;\n+            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << 8 * self.ntail;\n             if length < needed {\n-                self.tail |= u8to64_le!(msg, 0, length) << 8 * self.ntail;\n                 self.ntail += length;\n                 return\n+            } else {\n+                self.state.v3 ^= self.tail;\n+                S::c_rounds(&mut self.state);\n+                self.state.v0 ^= self.tail;\n+                self.ntail = 0;\n             }\n-\n-            let m = self.tail | u8to64_le!(msg, 0, needed) << 8 * self.ntail;\n-\n-            self.state.v3 ^= m;\n-            S::c_rounds(&mut self.state);\n-            self.state.v0 ^= m;\n-\n-            self.ntail = 0;\n         }\n \n         // Buffered tail is now flushed, process new input.\n@@ -287,7 +339,7 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n \n         let mut i = needed;\n         while i < len - left {\n-            let mi = unsafe { load_u64_le(msg, i) };\n+            let mi = unsafe { load_int_le!(msg, i, u64) };\n \n             self.state.v3 ^= mi;\n             S::c_rounds(&mut self.state);\n@@ -296,7 +348,7 @@ impl<S: Sip> super::Hasher for Hasher<S> {\n             i += 8;\n         }\n \n-        self.tail = u8to64_le!(msg, i, left);\n+        self.tail = unsafe { u8to64_le(msg, i, left) };\n         self.ntail = left;\n     }\n "}, {"sha": "e844a158484af488b2adea942de2127bc12644cc", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -194,14 +194,12 @@ extern \"rust-intrinsic\" {\n     /// own, or if it does not enable any significant optimizations.\n     pub fn assume(b: bool);\n \n-    #[cfg(not(stage0))]\n     /// Hints to the compiler that branch condition is likely to be true.\n     /// Returns the value passed to it.\n     ///\n     /// Any use other than with `if` statements will probably not have an effect.\n     pub fn likely(b: bool) -> bool;\n \n-    #[cfg(not(stage0))]\n     /// Hints to the compiler that branch condition is likely to be false.\n     /// Returns the value passed to it.\n     ///\n@@ -596,6 +594,19 @@ extern \"rust-intrinsic\" {\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `dst` to `val`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ptr;\n+    ///\n+    /// let mut vec = vec![0; 4];\n+    /// unsafe {\n+    ///     let vec_ptr = vec.as_mut_ptr();\n+    ///     ptr::write_bytes(vec_ptr, b'a', 2);\n+    /// }\n+    /// assert_eq!(vec, [b'a', b'a', 0, 0]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n "}, {"sha": "5a12f5db19ddb6f0a2fe363013d379e688aed645", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -195,13 +195,9 @@ pub trait Iterator {\n         last\n     }\n \n-    /// Consumes the `n` first elements of the iterator, then returns the\n-    /// `next()` one.\n+    /// Returns the `n`th element of the iterator.\n     ///\n-    /// This method will evaluate the iterator `n` times, discarding those elements.\n-    /// After it does so, it will call [`next()`] and return its value.\n-    ///\n-    /// [`next()`]: #tymethod.next\n+    /// Note that all preceding elements will be consumed (i.e. discarded).\n     ///\n     /// Like most indexing operations, the count starts from zero, so `nth(0)`\n     /// returns the first value, `nth(1)` the second, and so on."}, {"sha": "df4f5e5c5764335d1cc53cde45caa840bb14ad27", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 108, "deletions": 41, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -386,7 +386,7 @@ pub struct Cloned<I> {\n     it: I,\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n impl<'a, I, T: 'a> Iterator for Cloned<I>\n     where I: Iterator<Item=&'a T>, T: Clone\n {\n@@ -399,9 +399,15 @@ impl<'a, I, T: 'a> Iterator for Cloned<I>\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.it.size_hint()\n     }\n+\n+    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.fold(init, move |acc, elt| f(acc, elt.clone()))\n+    }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n     where I: DoubleEndedIterator<Item=&'a T>, T: Clone\n {\n@@ -410,7 +416,7 @@ impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n     where I: ExactSizeIterator<Item=&'a T>, T: Clone\n {}\n@@ -420,6 +426,18 @@ impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n     where I: FusedIterator<Item=&'a T>, T: Clone\n {}\n \n+#[doc(hidden)]\n+unsafe impl<'a, I, T: 'a> TrustedRandomAccess for Cloned<I>\n+    where I: TrustedRandomAccess<Item=&'a T>, T: Clone\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        self.it.get_unchecked(i).clone()\n+    }\n+\n+    #[inline]\n+    fn may_have_side_effect() -> bool { true }\n+}\n+\n /// An iterator that repeats endlessly.\n ///\n /// This `struct` is created by the [`cycle()`] method on [`Iterator`]. See its\n@@ -532,6 +550,25 @@ impl<A, B> Iterator for Chain<A, B> where\n         }\n     }\n \n+    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+        where F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut accum = init;\n+        match self.state {\n+            ChainState::Both | ChainState::Front => {\n+                accum = self.a.fold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        match self.state {\n+            ChainState::Both | ChainState::Back => {\n+                accum = self.b.fold(accum, &mut f);\n+            }\n+            _ => { }\n+        }\n+        accum\n+    }\n+\n     #[inline]\n     fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n         match self.state {\n@@ -643,7 +680,9 @@ impl<A, B> FusedIterator for Chain<A, B>\n pub struct Zip<A, B> {\n     a: A,\n     b: B,\n-    spec: <(A, B) as ZipImplData>::Data,\n+    // index and len are only used by the specialized version of zip\n+    index: usize,\n+    len: usize,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -685,17 +724,6 @@ trait ZipImpl<A, B> {\n               B: DoubleEndedIterator + ExactSizeIterator;\n }\n \n-// Zip specialization data members\n-#[doc(hidden)]\n-trait ZipImplData {\n-    type Data: 'static + Clone + Default + fmt::Debug;\n-}\n-\n-#[doc(hidden)]\n-impl<T> ZipImplData for T {\n-    default type Data = ();\n-}\n-\n // General Zip impl\n #[doc(hidden)]\n impl<A, B> ZipImpl<A, B> for Zip<A, B>\n@@ -706,7 +734,8 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n         Zip {\n             a: a,\n             b: b,\n-            spec: Default::default(), // unused\n+            index: 0, // unused\n+            len: 0, // unused\n         }\n     }\n \n@@ -759,20 +788,6 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n     }\n }\n \n-#[doc(hidden)]\n-#[derive(Default, Debug, Clone)]\n-struct ZipImplFields {\n-    index: usize,\n-    len: usize,\n-}\n-\n-#[doc(hidden)]\n-impl<A, B> ZipImplData for (A, B)\n-    where A: TrustedRandomAccess, B: TrustedRandomAccess\n-{\n-    type Data = ZipImplFields;\n-}\n-\n #[doc(hidden)]\n impl<A, B> ZipImpl<A, B> for Zip<A, B>\n     where A: TrustedRandomAccess, B: TrustedRandomAccess\n@@ -782,29 +797,34 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n         Zip {\n             a: a,\n             b: b,\n-            spec: ZipImplFields {\n-                index: 0,\n-                len: len,\n-            }\n+            index: 0,\n+            len: len,\n         }\n     }\n \n     #[inline]\n     fn next(&mut self) -> Option<(A::Item, B::Item)> {\n-        if self.spec.index < self.spec.len {\n-            let i = self.spec.index;\n-            self.spec.index += 1;\n+        if self.index < self.len {\n+            let i = self.index;\n+            self.index += 1;\n             unsafe {\n                 Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n             }\n+        } else if A::may_have_side_effect() && self.index < self.a.len() {\n+            // match the base implementation's potential side effects\n+            unsafe {\n+                self.a.get_unchecked(self.index);\n+            }\n+            self.index += 1;\n+            None\n         } else {\n             None\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.spec.len - self.spec.index;\n+        let len = self.len - self.index;\n         (len, Some(len))\n     }\n \n@@ -813,9 +833,26 @@ impl<A, B> ZipImpl<A, B> for Zip<A, B>\n         where A: DoubleEndedIterator + ExactSizeIterator,\n               B: DoubleEndedIterator + ExactSizeIterator\n     {\n-        if self.spec.index < self.spec.len {\n-            self.spec.len -= 1;\n-            let i = self.spec.len;\n+        // Adjust a, b to equal length\n+        if A::may_have_side_effect() {\n+            let sz = self.a.len();\n+            if sz > self.len {\n+                for _ in 0..sz - cmp::max(self.len, self.index) {\n+                    self.a.next_back();\n+                }\n+            }\n+        }\n+        if B::may_have_side_effect() {\n+            let sz = self.b.len();\n+            if sz > self.len {\n+                for _ in 0..sz - self.len {\n+                    self.b.next_back();\n+                }\n+            }\n+        }\n+        if self.index < self.len {\n+            self.len -= 1;\n+            let i = self.len;\n             unsafe {\n                 Some((self.a.get_unchecked(i), self.b.get_unchecked(i)))\n             }\n@@ -838,6 +875,9 @@ unsafe impl<A, B> TrustedRandomAccess for Zip<A, B>\n         (self.a.get_unchecked(i), self.b.get_unchecked(i))\n     }\n \n+    fn may_have_side_effect() -> bool {\n+        A::may_have_side_effect() || B::may_have_side_effect()\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -924,6 +964,13 @@ impl<B, I: Iterator, F> Iterator for Map<I, F> where F: FnMut(I::Item) -> B {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    fn fold<Acc, G>(self, init: Acc, mut g: G) -> Acc\n+        where G: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let mut f = self.f;\n+        self.iter.fold(init, move |acc, elt| g(acc, f(elt)))\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -944,6 +991,18 @@ impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n impl<B, I: FusedIterator, F> FusedIterator for Map<I, F>\n     where F: FnMut(I::Item) -> B {}\n \n+#[doc(hidden)]\n+unsafe impl<B, I, F> TrustedRandomAccess for Map<I, F>\n+    where I: TrustedRandomAccess,\n+          F: FnMut(I::Item) -> B,\n+{\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item {\n+        (self.f)(self.iter.get_unchecked(i))\n+    }\n+    #[inline]\n+    fn may_have_side_effect() -> bool { true }\n+}\n+\n /// An iterator that filters the elements of `iter` with `predicate`.\n ///\n /// This `struct` is created by the [`filter()`] method on [`Iterator`]. See its\n@@ -1159,6 +1218,10 @@ unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n     unsafe fn get_unchecked(&mut self, i: usize) -> (usize, I::Item) {\n         (self.count + i, self.iter.get_unchecked(i))\n     }\n+\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n@@ -1788,6 +1851,10 @@ unsafe impl<I> TrustedRandomAccess for Fuse<I>\n     unsafe fn get_unchecked(&mut self, i: usize) -> I::Item {\n         self.iter.get_unchecked(i)\n     }\n+\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]"}, {"sha": "eaa3d50c88adedee40ca18d6f3310adc31933e94", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -328,7 +328,8 @@ impl<A: Step> ops::RangeInclusive<A> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"step_by\", reason = \"recent addition\",\n+           issue = \"27741\")]\n impl<A> Iterator for StepBy<A, ops::RangeFrom<A>> where\n     A: Clone,\n     for<'a> &'a A: Add<&'a A, Output = A>\n@@ -352,7 +353,8 @@ impl<A> Iterator for StepBy<A, ops::RangeFrom<A>> where\n impl<A> FusedIterator for StepBy<A, ops::RangeFrom<A>>\n     where A: Clone, for<'a> &'a A: Add<&'a A, Output = A> {}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"step_by\", reason = \"recent addition\",\n+           issue = \"27741\")]\n impl<A: Step + Clone> Iterator for StepBy<A, ops::Range<A>> {\n     type Item = A;\n \n@@ -466,7 +468,11 @@ macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl ExactSizeIterator for ops::Range<$t> { }\n+    )*)\n+}\n \n+macro_rules! range_incl_exact_iter_impl {\n+    ($($t:ty)*) => ($(\n         #[unstable(feature = \"inclusive_range\",\n                    reason = \"recently added, follows RFC\",\n                    issue = \"28237\")]\n@@ -500,9 +506,12 @@ impl<A: Step> Iterator for ops::Range<A> where\n     }\n }\n \n-// Ranges of u64 and i64 are excluded because they cannot guarantee having\n-// a length <= usize::MAX, which is required by ExactSizeIterator.\n+// These macros generate `ExactSizeIterator` impls for various range types.\n+// Range<{u,i}64> and RangeInclusive<{u,i}{32,64,size}> are excluded\n+// because they cannot guarantee having a length <= usize::MAX, which is\n+// required by ExactSizeIterator.\n range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n+range_incl_exact_iter_impl!(u8 u16 i8 i16);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Step + Clone> DoubleEndedIterator for ops::Range<A> where"}, {"sha": "bc1aaa09f3dbd35d3f566c667dc896564b591ce5", "filename": "src/libcore/iter_private.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fiter_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fiter_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter_private.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -14,12 +14,15 @@\n /// # Safety\n ///\n /// The iterator's .len() and size_hint() must be exact.\n+/// `.len()` must be cheap to call.\n ///\n /// .get_unchecked() must return distinct mutable references for distinct\n /// indices (if applicable), and must return a valid reference if index is in\n /// 0..self.len().\n #[doc(hidden)]\n pub unsafe trait TrustedRandomAccess : ExactSizeIterator {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item;\n+    /// Return `true` if getting an iterator element may have\n+    /// side effects. Remember to take inner iterators into account.\n+    fn may_have_side_effect() -> bool;\n }\n-"}, {"sha": "28101d21fc25ecd691ae7eae8e91f43b270f652d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -89,7 +89,7 @@\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![feature(never_type)]\n #![feature(prelude_import)]\n "}, {"sha": "e6c3f549ec8e6c918fcc7a90606888939add4bdb", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -119,6 +119,44 @@ macro_rules! assert_eq {\n     });\n }\n \n+/// Asserts that two expressions are not equal to each other.\n+///\n+/// On panic, this macro will print the values of the expressions with their\n+/// debug representations.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// let a = 3;\n+/// let b = 2;\n+/// assert_ne!(a, b);\n+/// ```\n+#[macro_export]\n+#[stable(feature = \"assert_ne\", since = \"1.12.0\")]\n+macro_rules! assert_ne {\n+    ($left:expr , $right:expr) => ({\n+        match (&$left, &$right) {\n+            (left_val, right_val) => {\n+                if *left_val == *right_val {\n+                    panic!(\"assertion failed: `(left != right)` \\\n+                           (left: `{:?}`, right: `{:?}`)\", left_val, right_val)\n+                }\n+            }\n+        }\n+    });\n+    ($left:expr , $right:expr, $($arg:tt)*) => ({\n+        match (&($left), &($right)) {\n+            (left_val, right_val) => {\n+                if *left_val == *right_val {\n+                    panic!(\"assertion failed: `(left != right)` \\\n+                           (left: `{:?}`, right: `{:?}`): {}\", left_val, right_val,\n+                           format_args!($($arg)*))\n+                }\n+            }\n+        }\n+    });\n+}\n+\n /// Ensure that a boolean expression is `true` at runtime.\n ///\n /// This will invoke the `panic!` macro if the provided expression cannot be\n@@ -189,9 +227,37 @@ macro_rules! debug_assert_eq {\n     ($($arg:tt)*) => (if cfg!(debug_assertions) { assert_eq!($($arg)*); })\n }\n \n+/// Asserts that two expressions are not equal to each other.\n+///\n+/// On panic, this macro will print the values of the expressions with their\n+/// debug representations.\n+///\n+/// Unlike `assert_ne!`, `debug_assert_ne!` statements are only enabled in non\n+/// optimized builds by default. An optimized build will omit all\n+/// `debug_assert_ne!` statements unless `-C debug-assertions` is passed to the\n+/// compiler. This makes `debug_assert_ne!` useful for checks that are too\n+/// expensive to be present in a release build but may be helpful during\n+/// development.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// let a = 3;\n+/// let b = 2;\n+/// debug_assert_ne!(a, b);\n+/// ```\n+#[macro_export]\n+#[stable(feature = \"assert_ne\", since = \"1.12.0\")]\n+macro_rules! debug_assert_ne {\n+    ($($arg:tt)*) => (if cfg!(debug_assertions) { assert_ne!($($arg)*); })\n+}\n+\n /// Helper macro for reducing boilerplate code for matching `Result` together\n /// with converting downstream errors.\n ///\n+/// Prefer using `?` syntax to `try!`. `?` is built in to the language and is\n+/// more succinct than `try!`. It is the standard method for error propagation.\n+///\n /// `try!` matches the given `Result`. In case of the `Ok` variant, the\n /// expression has the value of the wrapped value.\n ///\n@@ -443,3 +509,143 @@ macro_rules! unreachable {\n macro_rules! unimplemented {\n     () => (panic!(\"not yet implemented\"))\n }\n+\n+/// Built-in macros to the compiler itself.\n+///\n+/// These macros do not have any corresponding definition with a `macro_rules!`\n+/// macro, but are documented here. Their implementations can be found hardcoded\n+/// into libsyntax itself.\n+///\n+/// For more information, see documentation for `std`'s macros.\n+#[cfg(dox)]\n+pub mod builtin {\n+    /// The core macro for formatted string creation & output.\n+    ///\n+    /// For more information, see the documentation for [`std::format_args!`].\n+    ///\n+    /// [`std::format_args!`]: ../std/macro.format_args.html\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[macro_export]\n+    macro_rules! format_args { ($fmt:expr, $($args:tt)*) => ({\n+        /* compiler built-in */\n+    }) }\n+\n+    /// Inspect an environment variable at compile time.\n+    ///\n+    /// For more information, see the documentation for [`std::env!`].\n+    ///\n+    /// [`std::env!`]: ../std/macro.env.html\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[macro_export]\n+    macro_rules! env { ($name:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Optionally inspect an environment variable at compile time.\n+    ///\n+    /// For more information, see the documentation for [`std::option_env!`].\n+    ///\n+    /// [`std::option_env!`]: ../std/macro.option_env.html\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[macro_export]\n+    macro_rules! option_env { ($name:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Concatenate identifiers into one identifier.\n+    ///\n+    /// For more information, see the documentation for [`std::concat_idents!`].\n+    ///\n+    /// [`std::concat_idents!`]: ../std/macro.concat_idents.html\n+    #[unstable(feature = \"concat_idents_macro\", issue = \"29599\")]\n+    #[macro_export]\n+    macro_rules! concat_idents {\n+        ($($e:ident),*) => ({ /* compiler built-in */ })\n+    }\n+\n+    /// Concatenates literals into a static string slice.\n+    ///\n+    /// For more information, see the documentation for [`std::concat!`].\n+    ///\n+    /// [`std::concat!`]: ../std/macro.concat.html\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[macro_export]\n+    macro_rules! concat { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which expands to the line number on which it was invoked.\n+    ///\n+    /// For more information, see the documentation for [`std::line!`].\n+    ///\n+    /// [`std::line!`]: ../std/macro.line.html\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[macro_export]\n+    macro_rules! line { () => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which expands to the column number on which it was invoked.\n+    ///\n+    /// For more information, see the documentation for [`std::column!`].\n+    ///\n+    /// [`std::column!`]: ../std/macro.column.html\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[macro_export]\n+    macro_rules! column { () => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which expands to the file name from which it was invoked.\n+    ///\n+    /// For more information, see the documentation for [`std::file!`].\n+    ///\n+    /// [`std::file!`]: ../std/macro.file.html\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[macro_export]\n+    macro_rules! file { () => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which stringifies its argument.\n+    ///\n+    /// For more information, see the documentation for [`std::stringify!`].\n+    ///\n+    /// [`std::stringify!`]: ../std/macro.stringify.html\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[macro_export]\n+    macro_rules! stringify { ($t:tt) => ({ /* compiler built-in */ }) }\n+\n+    /// Includes a utf8-encoded file as a string.\n+    ///\n+    /// For more information, see the documentation for [`std::include_str!`].\n+    ///\n+    /// [`std::include_str!`]: ../std/macro.include_str.html\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[macro_export]\n+    macro_rules! include_str { ($file:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Includes a file as a reference to a byte array.\n+    ///\n+    /// For more information, see the documentation for [`std::include_bytes!`].\n+    ///\n+    /// [`std::include_bytes!`]: ../std/macro.include_bytes.html\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[macro_export]\n+    macro_rules! include_bytes { ($file:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Expands to a string that represents the current module path.\n+    ///\n+    /// For more information, see the documentation for [`std::module_path!`].\n+    ///\n+    /// [`std::module_path!`]: ../std/macro.module_path.html\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[macro_export]\n+    macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n+\n+    /// Boolean evaluation of configuration flags.\n+    ///\n+    /// For more information, see the documentation for [`std::cfg!`].\n+    ///\n+    /// [`std::cfg!`]: ../std/macro.cfg.html\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[macro_export]\n+    macro_rules! cfg { ($($cfg:tt)*) => ({ /* compiler built-in */ }) }\n+\n+    /// Parse a file as an expression or an item according to the context.\n+    ///\n+    /// For more information, see the documentation for [`std::include!`].\n+    ///\n+    /// [`std::include!`]: ../std/macro.include.html\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[macro_export]\n+    macro_rules! include { ($file:expr) => ({ /* compiler built-in */ }) }\n+}"}, {"sha": "03d8af1563d6de1e639bd7fc4ea73068acb077d9", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 271, "deletions": 155, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Primitive traits and marker types representing basic 'kinds' of types.\n+//! Primitive traits and types representing basic properties of types.\n //!\n //! Rust types can be classified in various useful ways according to\n-//! intrinsic properties of the type. These classifications, often called\n-//! 'kinds', are represented as traits.\n+//! their intrinsic properties. These classifications are represented\n+//! as traits.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -22,7 +22,21 @@ use hash::Hasher;\n \n /// Types that can be transferred across thread boundaries.\n ///\n-/// This trait is automatically derived when the compiler determines it's appropriate.\n+/// This trait is automatically implemented when the compiler determines it's\n+/// appropriate.\n+///\n+/// An example of a non-`Send` type is the reference-counting pointer\n+/// [`rc::Rc`][rc]. If two threads attempt to clone `Rc`s that point to the same\n+/// reference-counted value, they might try to update the reference count at the\n+/// same time, which is [undefined behavior][ub] because `Rc` doesn't use atomic\n+/// operations. Its cousin [`sync::Arc`][arc] does use atomic operations (incurring\n+/// some overhead) and thus is `Send`.\n+///\n+/// See [the Nomicon](../../nomicon/send-and-sync.html) for more details.\n+///\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [arc]: ../../std/sync/struct.Arc.html\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"send\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be sent between threads safely\"]\n@@ -38,10 +52,10 @@ impl<T: ?Sized> !Send for *const T { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> !Send for *mut T { }\n \n-/// Types with a constant size known at compile-time.\n+/// Types with a constant size known at compile time.\n ///\n-/// All type parameters which can be bounded have an implicit bound of `Sized`. The special syntax\n-/// `?Sized` can be used to remove this bound if it is not appropriate.\n+/// All type parameters have an implicit bound of `Sized`. The special syntax\n+/// `?Sized` can be used to remove this bound if it's not appropriate.\n ///\n /// ```\n /// # #![allow(dead_code)]\n@@ -51,6 +65,26 @@ impl<T: ?Sized> !Send for *mut T { }\n /// // struct FooUse(Foo<[i32]>); // error: Sized is not implemented for [i32]\n /// struct BarUse(Bar<[i32]>); // OK\n /// ```\n+///\n+/// The one exception is the implicit `Self` type of a trait, which does not\n+/// get an implicit `Sized` bound. This is because a `Sized` bound prevents\n+/// the trait from being used to form a [trait object]:\n+///\n+/// ```\n+/// # #![allow(unused_variables)]\n+/// trait Foo { }\n+/// trait Bar: Sized { }\n+///\n+/// struct Impl;\n+/// impl Foo for Impl { }\n+/// impl Bar for Impl { }\n+///\n+/// let x: &Foo = &Impl;    // OK\n+/// // let y: &Bar = &Impl; // error: the trait `Bar` cannot\n+///                         // be made into an object\n+/// ```\n+///\n+/// [trait object]: ../../book/trait-objects.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n@@ -59,14 +93,27 @@ pub trait Sized {\n     // Empty.\n }\n \n-/// Types that can be \"unsized\" to a dynamically sized type.\n+/// Types that can be \"unsized\" to a dynamically-sized type.\n+///\n+/// For example, the sized array type `[i8; 2]` implements `Unsize<[i8]>` and\n+/// `Unsize<fmt::Debug>`.\n+///\n+/// All implementations of `Unsize` are provided automatically by the compiler.\n+///\n+/// `Unsize` is used along with [`ops::CoerceUnsized`][coerceunsized] to allow\n+/// \"user-defined\" containers such as [`rc::Rc`][rc] to contain dynamically-sized\n+/// types. See the [DST coercion RFC][RFC982] for more details.\n+///\n+/// [coerceunsized]: ../ops/trait.CoerceUnsized.html\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [RFC982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n #[unstable(feature = \"unsize\", issue = \"27732\")]\n #[lang=\"unsize\"]\n pub trait Unsize<T: ?Sized> {\n     // Empty.\n }\n \n-/// Types that can be copied by simply copying bits (i.e. `memcpy`).\n+/// Types whose values can be duplicated simply by copying bits.\n ///\n /// By default, variable bindings have 'move semantics.' In other\n /// words:\n@@ -87,7 +134,8 @@ pub trait Unsize<T: ?Sized> {\n /// However, if a type implements `Copy`, it instead has 'copy semantics':\n ///\n /// ```\n-/// // we can just derive a `Copy` implementation\n+/// // We can derive a `Copy` implementation. `Clone` is also required, as it's\n+/// // a supertrait of `Copy`.\n /// #[derive(Debug, Copy, Clone)]\n /// struct Foo;\n ///\n@@ -100,13 +148,59 @@ pub trait Unsize<T: ?Sized> {\n /// println!(\"{:?}\", x); // A-OK!\n /// ```\n ///\n-/// It's important to note that in these two examples, the only difference is if you are allowed to\n-/// access `x` after the assignment: a move is also a bitwise copy under the hood.\n+/// It's important to note that in these two examples, the only difference is whether you\n+/// are allowed to access `x` after the assignment. Under the hood, both a copy and a move\n+/// can result in bits being copied in memory, although this is sometimes optimized away.\n+///\n+/// ## How can I implement `Copy`?\n+///\n+/// There are two ways to implement `Copy` on your type. The simplest is to use `derive`:\n+///\n+/// ```\n+/// #[derive(Copy, Clone)]\n+/// struct MyStruct;\n+/// ```\n+///\n+/// You can also implement `Copy` and `Clone` manually:\n+///\n+/// ```\n+/// struct MyStruct;\n+///\n+/// impl Copy for MyStruct { }\n+///\n+/// impl Clone for MyStruct {\n+///     fn clone(&self) -> MyStruct {\n+///         *self\n+///     }\n+/// }\n+/// ```\n+///\n+/// There is a small difference between the two: the `derive` strategy will also place a `Copy`\n+/// bound on type parameters, which isn't always desired.\n+///\n+/// ## What's the difference between `Copy` and `Clone`?\n+///\n+/// Copies happen implicitly, for example as part of an assignment `y = x`. The behavior of\n+/// `Copy` is not overloadable; it is always a simple bit-wise copy.\n+///\n+/// Cloning is an explicit action, `x.clone()`. The implementation of [`Clone`][clone] can\n+/// provide any type-specific behavior necessary to duplicate values safely. For example,\n+/// the implementation of `Clone` for [`String`][string] needs to copy the pointed-to string\n+/// buffer in the heap. A simple bitwise copy of `String` values would merely copy the\n+/// pointer, leading to a double free down the line. For this reason, `String` is `Clone`\n+/// but not `Copy`.\n+///\n+/// `Clone` is a supertrait of `Copy`, so everything which is `Copy` must also implement\n+/// `Clone`. If a type is `Copy` then its `Clone` implementation need only return `*self`\n+/// (see the example above).\n+///\n+/// [clone]: ../clone/trait.Clone.html\n+/// [string]: ../../std/string/struct.String.html\n ///\n /// ## When can my type be `Copy`?\n ///\n /// A type can implement `Copy` if all of its components implement `Copy`. For example, this\n-/// `struct` can be `Copy`:\n+/// struct can be `Copy`:\n ///\n /// ```\n /// # #[allow(dead_code)]\n@@ -116,7 +210,8 @@ pub trait Unsize<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// A `struct` can be `Copy`, and `i32` is `Copy`, so therefore, `Point` is eligible to be `Copy`.\n+/// A struct can be `Copy`, and `i32` is `Copy`, therefore `Point` is eligible to be `Copy`.\n+/// By contrast, consider\n ///\n /// ```\n /// # #![allow(dead_code)]\n@@ -126,57 +221,35 @@ pub trait Unsize<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// The `PointList` `struct` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we\n+/// The struct `PointList` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we\n /// attempt to derive a `Copy` implementation, we'll get an error:\n ///\n /// ```text\n /// the trait `Copy` may not be implemented for this type; field `points` does not implement `Copy`\n /// ```\n ///\n-/// ## When can my type _not_ be `Copy`?\n+/// ## When *can't* my type be `Copy`?\n ///\n /// Some types can't be copied safely. For example, copying `&mut T` would create an aliased\n-/// mutable reference, and copying [`String`] would result in two attempts to free the same buffer.\n+/// mutable reference. Copying [`String`] would duplicate responsibility for managing the `String`'s\n+/// buffer, leading to a double free.\n ///\n /// Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's\n /// managing some resource besides its own [`size_of::<T>()`] bytes.\n ///\n-/// ## What if I derive `Copy` on a type that can't?\n-///\n-/// If you try to derive `Copy` on a struct or enum, you will get a compile-time error.\n-/// Specifically, with structs you'll get [E0204](https://doc.rust-lang.org/error-index.html#E0204)\n-/// and with enums you'll get [E0205](https://doc.rust-lang.org/error-index.html#E0205).\n-///\n-/// ## When should my type be `Copy`?\n-///\n-/// Generally speaking, if your type _can_ implement `Copy`, it should. There's one important thing\n-/// to consider though: if you think your type may _not_ be able to implement `Copy` in the future,\n-/// then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking\n-/// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n+/// If you try to implement `Copy` on a struct or enum containing non-`Copy` data, you will get a\n+/// compile-time error. Specifically, with structs you'll get [E0204] and with enums you'll get\n+/// [E0205].\n ///\n-/// ## Derivable\n+/// [E0204]: https://doc.rust-lang.org/error-index.html#E0204\n+/// [E0205]: https://doc.rust-lang.org/error-index.html#E0205\n ///\n-/// This trait can be used with `#[derive]` if all of its components implement `Copy` and the type.\n+/// ## When *should* my type be `Copy`?\n ///\n-/// ## How can I implement `Copy`?\n-///\n-/// There are two ways to implement `Copy` on your type:\n-///\n-/// ```\n-/// #[derive(Copy, Clone)]\n-/// struct MyStruct;\n-/// ```\n-///\n-/// and\n-///\n-/// ```\n-/// struct MyStruct;\n-/// impl Copy for MyStruct {}\n-/// impl Clone for MyStruct { fn clone(&self) -> MyStruct { *self } }\n-/// ```\n-///\n-/// There is a small difference between the two: the `derive` strategy will also place a `Copy`\n-/// bound on type parameters, which isn't always desired.\n+/// Generally speaking, if your type _can_ implement `Copy`, it should. Keep in mind, though,\n+/// that implementing `Copy` is part of the public API of your type. If the type might become\n+/// non-`Copy` in the future, it could be prudent to omit the `Copy` implementation now, to\n+/// avoid a breaking API change.\n ///\n /// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n /// [`String`]: ../../std/string/struct.String.html\n@@ -188,64 +261,74 @@ pub trait Copy : Clone {\n     // Empty.\n }\n \n-/// Types that can be safely shared between threads when aliased.\n+/// Types for which it is safe to share references between threads.\n+///\n+/// This trait is automatically implemented when the compiler determines\n+/// it's appropriate.\n ///\n /// The precise definition is: a type `T` is `Sync` if `&T` is\n-/// thread-safe. In other words, there is no possibility of data races\n-/// when passing `&T` references between threads.\n-///\n-/// As one would expect, primitive types like [`u8`] and [`f64`] are all\n-/// `Sync`, and so are simple aggregate types containing them (like\n-/// tuples, structs and enums). More instances of basic `Sync` types\n-/// include \"immutable\" types like `&T` and those with simple\n-/// inherited mutability, such as [`Box<T>`], [`Vec<T>`] and most other\n-/// collection types. (Generic parameters need to be `Sync` for their\n-/// container to be `Sync`.)\n-///\n-/// A somewhat surprising consequence of the definition is `&mut T` is\n-/// `Sync` (if `T` is `Sync`) even though it seems that it might\n-/// provide unsynchronized mutation. The trick is a mutable reference\n-/// stored in an aliasable reference (that is, `& &mut T`) becomes\n-/// read-only, as if it were a `& &T`, hence there is no risk of a data\n-/// race.\n+/// [`Send`][send]. In other words, if there is no possibility of\n+/// [undefined behavior][ub] (including data races) when passing\n+/// `&T` references between threads.\n+///\n+/// As one would expect, primitive types like [`u8`][u8] and [`f64`][f64]\n+/// are all `Sync`, and so are simple aggregate types containing them,\n+/// like tuples, structs and enums. More examples of basic `Sync`\n+/// types include \"immutable\" types like `&T`, and those with simple\n+/// inherited mutability, such as [`Box<T>`][box], [`Vec<T>`][vec] and\n+/// most other collection types. (Generic parameters need to be `Sync`\n+/// for their container to be `Sync`.)\n+///\n+/// A somewhat surprising consequence of the definition is that `&mut T`\n+/// is `Sync` (if `T` is `Sync`) even though it seems like that might\n+/// provide unsynchronized mutation. The trick is that a mutable\n+/// reference behind a shared reference (that is, `& &mut T`)\n+/// becomes read-only, as if it were a `& &T`. Hence there is no risk\n+/// of a data race.\n ///\n /// Types that are not `Sync` are those that have \"interior\n-/// mutability\" in a non-thread-safe way, such as [`Cell`] and [`RefCell`]\n-/// in [`std::cell`]. These types allow for mutation of their contents\n-/// even when in an immutable, aliasable slot, e.g. the contents of\n-/// [`&Cell<T>`][`Cell`] can be [`.set`], and do not ensure data races are\n-/// impossible, hence they cannot be `Sync`. A higher level example\n-/// of a non-`Sync` type is the reference counted pointer\n-/// [`std::rc::Rc`][`Rc`], because any reference [`&Rc<T>`][`Rc`] can clone a new\n-/// reference, which modifies the reference counts in a non-atomic\n-/// way.\n-///\n-/// For cases when one does need thread-safe interior mutability,\n-/// types like the atomics in [`std::sync`][`sync`] and [`Mutex`] / [`RwLock`] in\n-/// the [`sync`] crate do ensure that any mutation cannot cause data\n-/// races.  Hence these types are `Sync`.\n-///\n-/// Any types with interior mutability must also use the [`std::cell::UnsafeCell`]\n-/// wrapper around the value(s) which can be mutated when behind a `&`\n-/// reference; not doing this is undefined behavior (for example,\n-/// [`transmute`]-ing from `&T` to `&mut T` is invalid).\n+/// mutability\" in a non-thread-safe form, such as [`cell::Cell`][cell]\n+/// and [`cell::RefCell`][refcell]. These types allow for mutation of\n+/// their contents even through an immutable, shared reference. For\n+/// example the `set` method on `Cell<T>` takes `&self`, so it requires\n+/// only a shared reference `&Cell<T>`. The method performs no\n+/// synchronization, thus `Cell` cannot be `Sync`.\n ///\n-/// This trait is automatically derived when the compiler determines it's appropriate.\n+/// Another example of a non-`Sync` type is the reference-counting\n+/// pointer [`rc::Rc`][rc]. Given any reference `&Rc<T>`, you can clone\n+/// a new `Rc<T>`, modifying the reference counts in a non-atomic way.\n ///\n-/// [`u8`]: ../../std/primitive.u8.html\n-/// [`f64`]: ../../std/primitive.f64.html\n-/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n-/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n-/// [`Cell`]: ../../std/cell/struct.Cell.html\n-/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n-/// [`std::cell`]: ../../std/cell/index.html\n-/// [`.set`]: ../../std/cell/struct.Cell.html#method.set\n-/// [`Rc`]: ../../std/rc/struct.Rc.html\n-/// [`sync`]: ../../std/sync/index.html\n-/// [`Mutex`]: ../../std/sync/struct.Mutex.html\n-/// [`RwLock`]: ../../std/sync/struct.RwLock.html\n-/// [`std::cell::UnsafeCell`]: ../../std/cell/struct.UnsafeCell.html\n-/// [`transmute`]: ../../std/mem/fn.transmute.html\n+/// For cases when one does need thread-safe interior mutability,\n+/// Rust provides [atomic data types], as well as explicit locking via\n+/// [`sync::Mutex`][mutex] and [`sync::RWLock`][rwlock]. These types\n+/// ensure that any mutation cannot cause data races, hence the types\n+/// are `Sync`. Likewise, [`sync::Arc`][arc] provides a thread-safe\n+/// analogue of `Rc`.\n+///\n+/// Any types with interior mutability must also use the\n+/// [`cell::UnsafeCell`][unsafecell] wrapper around the value(s) which\n+/// can be mutated through a shared reference. Failing to doing this is\n+/// [undefined behavior][ub]. For example, [`transmute`][transmute]-ing\n+/// from `&T` to `&mut T` is invalid.\n+///\n+/// See [the Nomicon](../../nomicon/send-and-sync.html) for more\n+/// details about `Sync`.\n+///\n+/// [send]: trait.Send.html\n+/// [u8]: ../../std/primitive.u8.html\n+/// [f64]: ../../std/primitive.f64.html\n+/// [box]: ../../std/boxed/struct.Box.html\n+/// [vec]: ../../std/vec/struct.Vec.html\n+/// [cell]: ../cell/struct.Cell.html\n+/// [refcell]: ../cell/struct.RefCell.html\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [arc]: ../../std/sync/struct.Arc.html\n+/// [atomic data types]: ../sync/atomic/index.html\n+/// [mutex]: ../../std/sync/struct.Mutex.html\n+/// [rwlock]: ../../std/sync/struct.RwLock.html\n+/// [unsafecell]: ../cell/struct.UnsafeCell.html\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [transmute]: ../../std/mem/fn.transmute.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]\n@@ -314,29 +397,30 @@ macro_rules! impls{\n         )\n }\n \n-/// `PhantomData<T>` allows you to describe that a type acts as if it stores a value of type `T`,\n-/// even though it does not. This allows you to inform the compiler about certain safety properties\n-/// of your code.\n+/// Zero-sized type used to mark things that \"act like\" they own a `T`.\n ///\n-/// For a more in-depth explanation of how to use `PhantomData<T>`, please see [the Nomicon].\n+/// Adding a `PhantomData<T>` field to your type tells the compiler that your\n+/// type acts as though it stores a value of type `T`, even though it doesn't\n+/// really. This information is used when computing certain safety properties.\n ///\n-/// [the Nomicon]: ../../nomicon/phantom-data.html\n+/// For a more in-depth explanation of how to use `PhantomData<T>`, please see\n+/// [the Nomicon](../../nomicon/phantom-data.html).\n ///\n /// # A ghastly note \ud83d\udc7b\ud83d\udc7b\ud83d\udc7b\n ///\n-/// Though they both have scary names, `PhantomData<T>` and 'phantom types' are related, but not\n-/// identical. Phantom types are a more general concept that don't require `PhantomData<T>` to\n-/// implement, but `PhantomData<T>` is the most common way to implement them in a correct manner.\n+/// Though they both have scary names, `PhantomData` and 'phantom types' are\n+/// related, but not identical. A phantom type parameter is simply a type\n+/// parameter which is never used. In Rust, this often causes the compiler to\n+/// complain, and the solution is to add a \"dummy\" use by way of `PhantomData`.\n ///\n /// # Examples\n ///\n-/// ## Unused lifetime parameter\n+/// ## Unused lifetime parameters\n ///\n-/// Perhaps the most common time that `PhantomData` is required is\n-/// with a struct that has an unused lifetime parameter, typically as\n-/// part of some unsafe code. For example, here is a struct `Slice`\n-/// that has two pointers of type `*const T`, presumably pointing into\n-/// an array somewhere:\n+/// Perhaps the most common use case for `PhantomData` is a struct that has an\n+/// unused lifetime parameter, typically as part of some unsafe code. For\n+/// example, here is a struct `Slice` that has two pointers of type `*const T`,\n+/// presumably pointing into an array somewhere:\n ///\n /// ```ignore\n /// struct Slice<'a, T> {\n@@ -350,7 +434,7 @@ macro_rules! impls{\n /// intent is not expressed in the code, since there are no uses of\n /// the lifetime `'a` and hence it is not clear what data it applies\n /// to. We can correct this by telling the compiler to act *as if* the\n-/// `Slice` struct contained a borrowed reference `&'a T`:\n+/// `Slice` struct contained a reference `&'a T`:\n ///\n /// ```\n /// use std::marker::PhantomData;\n@@ -359,29 +443,53 @@ macro_rules! impls{\n /// struct Slice<'a, T: 'a> {\n ///     start: *const T,\n ///     end: *const T,\n-///     phantom: PhantomData<&'a T>\n+///     phantom: PhantomData<&'a T>,\n /// }\n /// ```\n ///\n-/// This also in turn requires that we annotate `T:'a`, indicating\n-/// that `T` is a type that can be borrowed for the lifetime `'a`.\n+/// This also in turn requires the annotation `T: 'a`, indicating\n+/// that any references in `T` are valid over the lifetime `'a`.\n+///\n+/// When initializing a `Slice` you simply provide the value\n+/// `PhantomData` for the field `phantom`:\n+///\n+/// ```\n+/// # #![allow(dead_code)]\n+/// # use std::marker::PhantomData;\n+/// # struct Slice<'a, T: 'a> {\n+/// #     start: *const T,\n+/// #     end: *const T,\n+/// #     phantom: PhantomData<&'a T>,\n+/// # }\n+/// fn borrow_vec<'a, T>(vec: &'a Vec<T>) -> Slice<'a, T> {\n+///     let ptr = vec.as_ptr();\n+///     Slice {\n+///         start: ptr,\n+///         end: unsafe { ptr.offset(vec.len() as isize) },\n+///         phantom: PhantomData,\n+///     }\n+/// }\n+/// ```\n ///\n /// ## Unused type parameters\n ///\n-/// It sometimes happens that there are unused type parameters that\n+/// It sometimes happens that you have unused type parameters which\n /// indicate what type of data a struct is \"tied\" to, even though that\n /// data is not actually found in the struct itself. Here is an\n-/// example where this arises when handling external resources over a\n-/// foreign function interface. `PhantomData<T>` can prevent\n-/// mismatches by enforcing types in the method implementations:\n+/// example where this arises with [FFI]. The foreign interface uses\n+/// handles of type `*mut ()` to refer to Rust values of different\n+/// types. We track the Rust type using a phantom type parameter on\n+/// the struct `ExternalResource` which wraps a handle.\n+///\n+/// [FFI]: ../../book/ffi.html\n ///\n /// ```\n /// # #![allow(dead_code)]\n-/// # trait ResType { fn foo(&self); }\n+/// # trait ResType { }\n /// # struct ParamType;\n /// # mod foreign_lib {\n-/// # pub fn new(_: usize) -> *mut () { 42 as *mut () }\n-/// # pub fn do_stuff(_: *mut (), _: usize) {}\n+/// #     pub fn new(_: usize) -> *mut () { 42 as *mut () }\n+/// #     pub fn do_stuff(_: *mut (), _: usize) {}\n /// # }\n /// # fn convert_params(_: ParamType) -> usize { 42 }\n /// use std::marker::PhantomData;\n@@ -408,21 +516,20 @@ macro_rules! impls{\n /// }\n /// ```\n ///\n-/// ## Indicating ownership\n+/// ## Ownership and the drop check\n ///\n-/// Adding a field of type `PhantomData<T>` also indicates that your\n-/// struct owns data of type `T`. This in turn implies that when your\n-/// struct is dropped, it may in turn drop one or more instances of\n-/// the type `T`, though that may not be apparent from the other\n-/// structure of the type itself. This is commonly necessary if the\n-/// structure is using a raw pointer like `*mut T` whose referent\n-/// may be dropped when the type is dropped, as a `*mut T` is\n-/// otherwise not treated as owned.\n+/// Adding a field of type `PhantomData<T>` indicates that your\n+/// type owns data of type `T`. This in turn implies that when your\n+/// type is dropped, it may drop one or more instances of the type\n+/// `T`. This has bearing on the Rust compiler's [drop check]\n+/// analysis.\n ///\n /// If your struct does not in fact *own* the data of type `T`, it is\n /// better to use a reference type, like `PhantomData<&'a T>`\n /// (ideally) or `PhantomData<*const T>` (if no lifetime applies), so\n /// as not to indicate ownership.\n+///\n+/// [drop check]: ../../nomicon/dropck.html\n #[lang = \"phantom_data\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PhantomData<T:?Sized>;\n@@ -438,10 +545,13 @@ mod impls {\n \n /// Types that can be reflected over.\n ///\n-/// This trait is implemented for all types. Its purpose is to ensure\n-/// that when you write a generic function that will employ\n-/// reflection, that must be reflected (no pun intended) in the\n-/// generic bounds of that function. Here is an example:\n+/// By \"reflection\" we mean use of the [`Any`][any] trait, or related\n+/// machinery such as [`TypeId`][typeid].\n+///\n+/// `Reflect` is implemented for all types. Its purpose is to ensure\n+/// that when you write a generic function that will employ reflection,\n+/// that must be reflected (no pun intended) in the generic bounds of\n+/// that function.\n ///\n /// ```\n /// #![feature(reflect_marker)]\n@@ -455,30 +565,36 @@ mod impls {\n /// }\n /// ```\n ///\n-/// Without the declaration `T: Reflect`, `foo` would not type check\n-/// (note: as a matter of style, it would be preferable to write\n-/// `T: Any`, because `T: Any` implies `T: Reflect` and `T: 'static`, but\n-/// we use `Reflect` here to show how it works). The `Reflect` bound\n-/// thus serves to alert `foo`'s caller to the fact that `foo` may\n-/// behave differently depending on whether `T = u32` or not. In\n-/// particular, thanks to the `Reflect` bound, callers know that a\n-/// function declared like `fn bar<T>(...)` will always act in\n-/// precisely the same way no matter what type `T` is supplied,\n-/// because there are no bounds declared on `T`. (The ability for a\n-/// caller to reason about what a function may do based solely on what\n-/// generic bounds are declared is often called the [\"parametricity\n-/// property\"][1].)\n-///\n-/// [1]: http://en.wikipedia.org/wiki/Parametricity\n+/// Without the bound `T: Reflect`, `foo` would not typecheck. (As\n+/// a matter of style, it would be preferable to write `T: Any`,\n+/// because `T: Any` implies `T: Reflect` and `T: 'static`, but we\n+/// use `Reflect` here for illustrative purposes.)\n+///\n+/// The `Reflect` bound serves to alert `foo`'s caller to the\n+/// fact that `foo` may behave differently depending on whether\n+/// `T` is `u32` or not. The ability for a caller to reason about what\n+/// a function may do based solely on what generic bounds are declared\n+/// is often called the \"[parametricity property][param]\". Despite the\n+/// use of `Reflect`, Rust lacks true parametricity because a generic\n+/// function can, at the very least, call [`mem::size_of`][size_of]\n+/// without employing any trait bounds whatsoever.\n+///\n+/// [any]: ../any/trait.Any.html\n+/// [typeid]: ../any/struct.TypeId.html\n+/// [param]: http://en.wikipedia.org/wiki/Parametricity\n+/// [size_of]: ../mem/fn.size_of.html\n #[rustc_reflect_like]\n #[unstable(feature = \"reflect_marker\",\n            reason = \"requires RFC and more experience\",\n            issue = \"27749\")]\n+#[rustc_deprecated(since = \"1.14.0\", reason = \"Specialization makes parametricity impossible\")]\n #[rustc_on_unimplemented = \"`{Self}` does not implement `Any`; \\\n                             ensure all type parameters are bounded by `Any`\"]\n pub trait Reflect {}\n \n #[unstable(feature = \"reflect_marker\",\n            reason = \"requires RFC and more experience\",\n            issue = \"27749\")]\n+#[rustc_deprecated(since = \"1.14.0\", reason = \"Specialization makes parametricity impossible\")]\n+#[allow(deprecated)]\n impl Reflect for .. { }"}, {"sha": "e0aa25724c1f93924ce901139295d840355328af", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -15,7 +15,12 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use clone;\n+use cmp;\n+use fmt;\n+use hash;\n use intrinsics;\n+use marker::{Copy, PhantomData, Sized};\n use ptr;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -647,3 +652,80 @@ pub fn drop<T>(_x: T) { }\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     ptr::read(src as *const T as *const U)\n }\n+\n+/// Opaque type representing the discriminant of an enum.\n+///\n+/// See the `discriminant` function in this module for more information.\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+pub struct Discriminant<T>(u64, PhantomData<*const T>);\n+\n+// N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n+\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+impl<T> Copy for Discriminant<T> {}\n+\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+impl<T> clone::Clone for Discriminant<T> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+impl<T> cmp::PartialEq for Discriminant<T> {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.0 == rhs.0\n+    }\n+}\n+\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+impl<T> cmp::Eq for Discriminant<T> {}\n+\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+impl<T> hash::Hash for Discriminant<T> {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        self.0.hash(state);\n+    }\n+}\n+\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+impl<T> fmt::Debug for Discriminant<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt.debug_tuple(\"Discriminant\")\n+           .field(&self.0)\n+           .finish()\n+    }\n+}\n+\n+/// Returns a value uniquely identifying the enum variant in `v`.\n+///\n+/// If `T` is not an enum, calling this function will not result in undefined behavior, but the\n+/// return value is unspecified.\n+///\n+/// # Stability\n+///\n+/// The discriminant of an enum variant may change if the enum definition changes. A discriminant\n+/// of some variant will not change between compilations with the same compiler.\n+///\n+/// # Examples\n+///\n+/// This can be used to compare enums that carry data, while disregarding\n+/// the actual data:\n+///\n+/// ```\n+/// #![feature(discriminant_value)]\n+/// use std::mem;\n+///\n+/// enum Foo { A(&'static str), B(i32), C(i32) }\n+///\n+/// assert!(mem::discriminant(&Foo::A(\"bar\")) == mem::discriminant(&Foo::A(\"baz\")));\n+/// assert!(mem::discriminant(&Foo::B(1))     == mem::discriminant(&Foo::B(2)));\n+/// assert!(mem::discriminant(&Foo::B(3))     != mem::discriminant(&Foo::C(3)));\n+/// ```\n+#[unstable(feature = \"discriminant_value\", reason = \"recently added, follows RFC\", issue = \"24263\")]\n+pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n+    unsafe {\n+        Discriminant(intrinsics::discriminant_value(v), PhantomData)\n+    }\n+}\n+"}, {"sha": "a1f4630c304bf93dff849a7d479910658e085a43", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -34,19 +34,22 @@ use intrinsics;\n pub trait FullOps: Sized {\n     /// Returns `(carry', v')` such that `carry' * 2^W + v' = self + other + carry`,\n     /// where `W` is the number of bits in `Self`.\n-    fn full_add(self, other: Self, carry: bool) -> (bool /*carry*/, Self);\n+    fn full_add(self, other: Self, carry: bool) -> (bool /* carry */, Self);\n \n     /// Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + carry`,\n     /// where `W` is the number of bits in `Self`.\n-    fn full_mul(self, other: Self, carry: Self) -> (Self /*carry*/, Self);\n+    fn full_mul(self, other: Self, carry: Self) -> (Self /* carry */, Self);\n \n     /// Returns `(carry', v')` such that `carry' * 2^W + v' = self * other + other2 + carry`,\n     /// where `W` is the number of bits in `Self`.\n-    fn full_mul_add(self, other: Self, other2: Self, carry: Self) -> (Self /*carry*/, Self);\n+    fn full_mul_add(self, other: Self, other2: Self, carry: Self) -> (Self /* carry */, Self);\n \n     /// Returns `(quo, rem)` such that `borrow * 2^W + self = quo * other + rem`\n     /// and `0 <= rem < other`, where `W` is the number of bits in `Self`.\n-    fn full_div_rem(self, other: Self, borrow: Self) -> (Self /*quotient*/, Self /*remainder*/);\n+    fn full_div_rem(self,\n+                    other: Self,\n+                    borrow: Self)\n+                    -> (Self /* quotient */, Self /* remainder */);\n }\n \n macro_rules! impl_full_ops {\n@@ -100,11 +103,7 @@ impl_full_ops! {\n \n /// Table of powers of 5 representable in digits. Specifically, the largest {u8, u16, u32} value\n /// that's a power of five, plus the corresponding exponent. Used in `mul_pow5`.\n-const SMALL_POW5: [(u64, usize); 3] = [\n-    (125, 3),\n-    (15625, 6),\n-    (1_220_703_125, 13),\n-];\n+const SMALL_POW5: [(u64, usize); 3] = [(125, 3), (15625, 6), (1_220_703_125, 13)];\n \n macro_rules! define_bignum {\n     ($name:ident: type=$ty:ty, n=$n:expr) => ("}, {"sha": "eee3e9250fe816a2778afbc3616cd76c9aba6efa", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -155,13 +155,13 @@ from_str_float_impl!(f64);\n /// [`FromStr`]: ../str/trait.FromStr.html\n /// [`f32`]: ../../std/primitive.f32.html\n /// [`f64`]: ../../std/primitive.f64.html\n-#[derive(Debug, Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseFloatError {\n     kind: FloatErrorKind\n }\n \n-#[derive(Debug, Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n enum FloatErrorKind {\n     Empty,\n     Invalid,"}, {"sha": "11eea753f93f912a579dd607cddae2e39f61eb24", "filename": "src/libcore/num/diy_float.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Fdiy_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Fdiy_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdiy_float.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -49,12 +49,30 @@ impl Fp {\n     pub fn normalize(&self) -> Fp {\n         let mut f = self.f;\n         let mut e = self.e;\n-        if f >> (64 - 32) == 0 { f <<= 32; e -= 32; }\n-        if f >> (64 - 16) == 0 { f <<= 16; e -= 16; }\n-        if f >> (64 -  8) == 0 { f <<=  8; e -=  8; }\n-        if f >> (64 -  4) == 0 { f <<=  4; e -=  4; }\n-        if f >> (64 -  2) == 0 { f <<=  2; e -=  2; }\n-        if f >> (64 -  1) == 0 { f <<=  1; e -=  1; }\n+        if f >> (64 - 32) == 0 {\n+            f <<= 32;\n+            e -= 32;\n+        }\n+        if f >> (64 - 16) == 0 {\n+            f <<= 16;\n+            e -= 16;\n+        }\n+        if f >> (64 - 8) == 0 {\n+            f <<= 8;\n+            e -= 8;\n+        }\n+        if f >> (64 - 4) == 0 {\n+            f <<= 4;\n+            e -= 4;\n+        }\n+        if f >> (64 - 2) == 0 {\n+            f <<= 2;\n+            e -= 2;\n+        }\n+        if f >> (64 - 1) == 0 {\n+            f <<= 1;\n+            e -= 1;\n+        }\n         debug_assert!(f >= (1 >> 63));\n         Fp { f: f, e: e }\n     }\n@@ -66,6 +84,9 @@ impl Fp {\n         assert!(edelta >= 0);\n         let edelta = edelta as usize;\n         assert_eq!(self.f << edelta >> edelta, self.f);\n-        Fp { f: self.f << edelta, e: e }\n+        Fp {\n+            f: self.f << edelta,\n+            e: e,\n+        }\n     }\n }"}, {"sha": "4527d46a27d8a9590f6e64ebdf0376ae561996d6", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -61,13 +61,13 @@ pub const MAX_10_EXP: i32 = 38;\n \n /// Not a Number (NaN).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const NAN: f32 = 0.0_f32/0.0_f32;\n+pub const NAN: f32 = 0.0_f32 / 0.0_f32;\n /// Infinity (\u221e).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const INFINITY: f32 = 1.0_f32/0.0_f32;\n+pub const INFINITY: f32 = 1.0_f32 / 0.0_f32;\n /// Negative infinity (-\u221e).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n+pub const NEG_INFINITY: f32 = -1.0_f32 / 0.0_f32;\n \n /// Basic mathematical constants.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -144,26 +144,40 @@ pub mod consts {\n            issue = \"32110\")]\n impl Float for f32 {\n     #[inline]\n-    fn nan() -> f32 { NAN }\n+    fn nan() -> f32 {\n+        NAN\n+    }\n \n     #[inline]\n-    fn infinity() -> f32 { INFINITY }\n+    fn infinity() -> f32 {\n+        INFINITY\n+    }\n \n     #[inline]\n-    fn neg_infinity() -> f32 { NEG_INFINITY }\n+    fn neg_infinity() -> f32 {\n+        NEG_INFINITY\n+    }\n \n     #[inline]\n-    fn zero() -> f32 { 0.0 }\n+    fn zero() -> f32 {\n+        0.0\n+    }\n \n     #[inline]\n-    fn neg_zero() -> f32 { -0.0 }\n+    fn neg_zero() -> f32 {\n+        -0.0\n+    }\n \n     #[inline]\n-    fn one() -> f32 { 1.0 }\n+    fn one() -> f32 {\n+        1.0\n+    }\n \n     /// Returns `true` if the number is NaN.\n     #[inline]\n-    fn is_nan(self) -> bool { self != self }\n+    fn is_nan(self) -> bool {\n+        self != self\n+    }\n \n     /// Returns `true` if the number is infinite.\n     #[inline]\n@@ -192,11 +206,11 @@ impl Float for f32 {\n \n         let bits: u32 = unsafe { mem::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n-            (0, 0)        => Fp::Zero,\n-            (_, 0)        => Fp::Subnormal,\n+            (0, 0) => Fp::Zero,\n+            (_, 0) => Fp::Subnormal,\n             (0, EXP_MASK) => Fp::Infinite,\n             (_, EXP_MASK) => Fp::Nan,\n-            _             => Fp::Normal,\n+            _ => Fp::Normal,\n         }\n     }\n \n@@ -252,7 +266,9 @@ impl Float for f32 {\n \n     /// Returns the reciprocal (multiplicative inverse) of the number.\n     #[inline]\n-    fn recip(self) -> f32 { 1.0 / self }\n+    fn recip(self) -> f32 {\n+        1.0 / self\n+    }\n \n     #[inline]\n     fn powi(self, n: i32) -> f32 {\n@@ -261,7 +277,9 @@ impl Float for f32 {\n \n     /// Converts to degrees, assuming the number is in radians.\n     #[inline]\n-    fn to_degrees(self) -> f32 { self * (180.0f32 / consts::PI) }\n+    fn to_degrees(self) -> f32 {\n+        self * (180.0f32 / consts::PI)\n+    }\n \n     /// Converts to radians, assuming the number is in degrees.\n     #[inline]"}, {"sha": "991a856834948687cf00c59d5879149733af6bc6", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -61,13 +61,13 @@ pub const MAX_10_EXP: i32 = 308;\n \n /// Not a Number (NaN).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const NAN: f64 = 0.0_f64/0.0_f64;\n+pub const NAN: f64 = 0.0_f64 / 0.0_f64;\n /// Infinity (\u221e).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const INFINITY: f64 = 1.0_f64/0.0_f64;\n+pub const INFINITY: f64 = 1.0_f64 / 0.0_f64;\n /// Negative infinity (-\u221e).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n+pub const NEG_INFINITY: f64 = -1.0_f64 / 0.0_f64;\n \n /// Basic mathematical constants.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -144,26 +144,40 @@ pub mod consts {\n            issue = \"32110\")]\n impl Float for f64 {\n     #[inline]\n-    fn nan() -> f64 { NAN }\n+    fn nan() -> f64 {\n+        NAN\n+    }\n \n     #[inline]\n-    fn infinity() -> f64 { INFINITY }\n+    fn infinity() -> f64 {\n+        INFINITY\n+    }\n \n     #[inline]\n-    fn neg_infinity() -> f64 { NEG_INFINITY }\n+    fn neg_infinity() -> f64 {\n+        NEG_INFINITY\n+    }\n \n     #[inline]\n-    fn zero() -> f64 { 0.0 }\n+    fn zero() -> f64 {\n+        0.0\n+    }\n \n     #[inline]\n-    fn neg_zero() -> f64 { -0.0 }\n+    fn neg_zero() -> f64 {\n+        -0.0\n+    }\n \n     #[inline]\n-    fn one() -> f64 { 1.0 }\n+    fn one() -> f64 {\n+        1.0\n+    }\n \n     /// Returns `true` if the number is NaN.\n     #[inline]\n-    fn is_nan(self) -> bool { self != self }\n+    fn is_nan(self) -> bool {\n+        self != self\n+    }\n \n     /// Returns `true` if the number is infinite.\n     #[inline]\n@@ -192,11 +206,11 @@ impl Float for f64 {\n \n         let bits: u64 = unsafe { mem::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n-            (0, 0)        => Fp::Zero,\n-            (_, 0)        => Fp::Subnormal,\n+            (0, 0) => Fp::Zero,\n+            (_, 0) => Fp::Subnormal,\n             (0, EXP_MASK) => Fp::Infinite,\n             (_, EXP_MASK) => Fp::Nan,\n-            _             => Fp::Normal,\n+            _ => Fp::Normal,\n         }\n     }\n \n@@ -252,7 +266,9 @@ impl Float for f64 {\n \n     /// Returns the reciprocal (multiplicative inverse) of the number.\n     #[inline]\n-    fn recip(self) -> f64 { 1.0 / self }\n+    fn recip(self) -> f64 {\n+        1.0 / self\n+    }\n \n     #[inline]\n     fn powi(self, n: i32) -> f64 {\n@@ -261,7 +277,9 @@ impl Float for f64 {\n \n     /// Converts to degrees, assuming the number is in radians.\n     #[inline]\n-    fn to_degrees(self) -> f64 { self * (180.0f64 / consts::PI) }\n+    fn to_degrees(self) -> f64 {\n+        self * (180.0f64 / consts::PI)\n+    }\n \n     /// Converts to radians, assuming the number is in degrees.\n     #[inline]"}, {"sha": "72529d3da01d11b0325827f103096b9b2356c779", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -21,7 +21,7 @@ use num::dec2flt::rawfp::RawFloat;\n /// - Any number from `(mant - minus) * 2^exp` to `(mant + plus) * 2^exp` will\n ///   round to the original value. The range is inclusive only when\n ///   `inclusive` is true.\n-#[derive(Copy, Clone, Debug, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct Decoded {\n     /// The scaled mantissa.\n     pub mant: u64,\n@@ -38,7 +38,7 @@ pub struct Decoded {\n }\n \n /// Decoded unsigned value.\n-#[derive(Copy, Clone, Debug, PartialEq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum FullDecoded {\n     /// Not-a-number.\n     Nan,"}, {"sha": "a4529909e83ef61ddbd82d2fb5586ca317c98308", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 34, "deletions": 44, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -43,7 +43,8 @@ use str::FromStr;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Default, Hash)]\n-pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n+pub struct Wrapping<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+                       pub T);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Wrapping<T> {\n@@ -516,11 +517,10 @@ macro_rules! int_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn checked_div(self, other: Self) -> Option<Self> {\n-            if other == 0 {\n+            if other == 0 || (self == Self::min_value() && other == -1) {\n                 None\n             } else {\n-                let (a, b) = self.overflowing_div(other);\n-                if b {None} else {Some(a)}\n+                Some(unsafe { intrinsics::unchecked_div(self, other) })\n             }\n         }\n \n@@ -541,11 +541,10 @@ macro_rules! int_impl {\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n         pub fn checked_rem(self, other: Self) -> Option<Self> {\n-            if other == 0 {\n+            if other == 0 || (self == Self::min_value() && other == -1) {\n                 None\n             } else {\n-                let (a, b) = self.overflowing_rem(other);\n-                if b {None} else {Some(a)}\n+                Some(unsafe { intrinsics::unchecked_rem(self, other) })\n             }\n         }\n \n@@ -613,14 +612,12 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(no_panic_abs)]\n-        ///\n         /// use std::i32;\n         ///\n         /// assert_eq!((-5i32).checked_abs(), Some(5));\n         /// assert_eq!(i32::MIN.checked_abs(), None);\n         /// ```\n-        #[unstable(feature = \"no_panic_abs\", issue = \"35057\")]\n+        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n         #[inline]\n         pub fn checked_abs(self) -> Option<Self> {\n             if self.is_negative() {\n@@ -895,14 +892,12 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(no_panic_abs)]\n-        ///\n         /// assert_eq!(100i8.wrapping_abs(), 100);\n         /// assert_eq!((-100i8).wrapping_abs(), 100);\n         /// assert_eq!((-128i8).wrapping_abs(), -128);\n         /// assert_eq!((-128i8).wrapping_abs() as u8, 128);\n         /// ```\n-        #[unstable(feature = \"no_panic_abs\", issue = \"35057\")]\n+        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n         #[inline(always)]\n         pub fn wrapping_abs(self) -> Self {\n             if self.is_negative() {\n@@ -1133,13 +1128,11 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(no_panic_abs)]\n-        ///\n         /// assert_eq!(10i8.overflowing_abs(), (10,false));\n         /// assert_eq!((-10i8).overflowing_abs(), (10,false));\n         /// assert_eq!((-128i8).overflowing_abs(), (-128,true));\n         /// ```\n-        #[unstable(feature = \"no_panic_abs\", issue = \"35057\")]\n+        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n         #[inline]\n         pub fn overflowing_abs(self) -> (Self, bool) {\n             if self.is_negative() {\n@@ -1694,7 +1687,7 @@ macro_rules! uint_impl {\n         pub fn checked_div(self, other: Self) -> Option<Self> {\n             match other {\n                 0 => None,\n-                other => Some(self / other),\n+                other => Some(unsafe { intrinsics::unchecked_div(self, other) }),\n             }\n         }\n \n@@ -1715,7 +1708,7 @@ macro_rules! uint_impl {\n             if other == 0 {\n                 None\n             } else {\n-                Some(self % other)\n+                Some(unsafe { intrinsics::unchecked_rem(self, other) })\n             }\n         }\n \n@@ -2211,25 +2204,21 @@ macro_rules! uint_impl {\n             let mut base = self;\n             let mut acc = 1;\n \n-            let mut prev_base = self;\n-            let mut base_oflo = false;\n-            while exp > 0 {\n+            while exp > 1 {\n                 if (exp & 1) == 1 {\n-                    if base_oflo {\n-                        // ensure overflow occurs in the same manner it\n-                        // would have otherwise (i.e. signal any exception\n-                        // it would have otherwise).\n-                        acc = acc * (prev_base * prev_base);\n-                    } else {\n-                        acc = acc * base;\n-                    }\n+                    acc = acc * base;\n                 }\n-                prev_base = base;\n-                let (new_base, new_base_oflo) = base.overflowing_mul(base);\n-                base = new_base;\n-                base_oflo = new_base_oflo;\n                 exp /= 2;\n+                base = base * base;\n+            }\n+\n+            // Deal with the final bit of the exponent separately, since\n+            // squaring the base afterwards is not necessary and may cause a\n+            // needless overflow.\n+            if exp == 1 {\n+                acc = acc * base;\n             }\n+\n             acc\n         }\n \n@@ -2405,7 +2394,7 @@ impl usize {\n /// assert_eq!(nan.classify(), FpCategory::Nan);\n /// assert_eq!(sub.classify(), FpCategory::Subnormal);\n /// ```\n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum FpCategory {\n     /// \"Not a Number\", often obtained by dividing by zero.\n@@ -2414,7 +2403,7 @@ pub enum FpCategory {\n \n     /// Positive or negative infinity.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Infinite ,\n+    Infinite,\n \n     /// Positive or negative zero.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2580,7 +2569,7 @@ impl fmt::Display for TryFromIntError {\n \n macro_rules! same_sign_from_int_impl {\n     ($storage:ty, $target:ty, $($source:ty),*) => {$(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[unstable(feature = \"try_from\", issue = \"33417\")]\n         impl TryFrom<$source> for $target {\n             type Err = TryFromIntError;\n \n@@ -2610,7 +2599,7 @@ same_sign_from_int_impl!(i64, isize, i8, i16, i32, i64, isize);\n \n macro_rules! cross_sign_from_int_impl {\n     ($unsigned:ty, $($signed:ty),*) => {$(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[unstable(feature = \"try_from\", issue = \"33417\")]\n         impl TryFrom<$unsigned> for $signed {\n             type Err = TryFromIntError;\n \n@@ -2624,7 +2613,7 @@ macro_rules! cross_sign_from_int_impl {\n             }\n         }\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[unstable(feature = \"try_from\", issue = \"33417\")]\n         impl TryFrom<$signed> for $unsigned {\n             type Err = TryFromIntError;\n \n@@ -2674,8 +2663,7 @@ macro_rules! doit {\n }\n doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n \n-fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n-                                         -> Result<T, ParseIntError> {\n+fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, ParseIntError> {\n     use self::IntErrorKind::*;\n     use self::ParseIntError as PIE;\n \n@@ -2698,7 +2686,7 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n     let (is_positive, digits) = match src[0] {\n         b'+' => (true, &src[1..]),\n         b'-' if is_signed_ty => (false, &src[1..]),\n-        _ => (true, src)\n+        _ => (true, src),\n     };\n \n     if digits.is_empty() {\n@@ -2748,11 +2736,13 @@ fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32)\n /// on the primitive integer types, such as [`i8::from_str_radix()`].\n ///\n /// [`i8::from_str_radix()`]: ../../std/primitive.i8.html#method.from_str_radix\n-#[derive(Debug, Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ParseIntError { kind: IntErrorKind }\n+pub struct ParseIntError {\n+    kind: IntErrorKind,\n+}\n \n-#[derive(Debug, Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n enum IntErrorKind {\n     Empty,\n     InvalidDigit,"}, {"sha": "d35c451ac2604471de90bf2426d18d528fde1486", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -28,7 +28,7 @@ macro_rules! sh_impl_signed {\n             }\n         }\n \n-        #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n             #[inline(always)]\n             fn shl_assign(&mut self, other: $f) {\n@@ -50,7 +50,7 @@ macro_rules! sh_impl_signed {\n             }\n         }\n \n-        #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n             #[inline(always)]\n             fn shr_assign(&mut self, other: $f) {\n@@ -72,7 +72,7 @@ macro_rules! sh_impl_unsigned {\n             }\n         }\n \n-        #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n             #[inline(always)]\n             fn shl_assign(&mut self, other: $f) {\n@@ -90,7 +90,7 @@ macro_rules! sh_impl_unsigned {\n             }\n         }\n \n-        #[stable(feature = \"wrapping_impls\", since = \"1.7.0\")]\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n             #[inline(always)]\n             fn shr_assign(&mut self, other: $f) {\n@@ -310,13 +310,13 @@ mod shift_max {\n         pub const isize: u32 = super::i64;\n     }\n \n-    pub const  i8: u32 = (1 << 3) - 1;\n+    pub const i8: u32 = (1 << 3) - 1;\n     pub const i16: u32 = (1 << 4) - 1;\n     pub const i32: u32 = (1 << 5) - 1;\n     pub const i64: u32 = (1 << 6) - 1;\n     pub use self::platform::isize;\n \n-    pub const  u8: u32 = i8;\n+    pub const u8: u32 = i8;\n     pub const u16: u32 = i16;\n     pub const u32: u32 = i32;\n     pub const u64: u32 = i64;"}, {"sha": "62aa57bbbbf055e5eeb33f80727ab9de99220c0f", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 90, "deletions": 37, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -14,7 +14,7 @@\n //!\n //! Some of these traits are imported by the prelude, so they are available in\n //! every Rust program. Only operators backed by traits can be overloaded. For\n-//! example, the addition operator (`+`) can be overloaded through the `Add`\n+//! example, the addition operator (`+`) can be overloaded through the [`Add`]\n //! trait, but since the assignment operator (`=`) has no backing trait, there\n //! is no way of overloading its semantics. Additionally, this module does not\n //! provide any mechanism to create new operators. If traitless overloading or\n@@ -30,17 +30,18 @@\n //! contexts involving built-in types, this is usually not a problem.\n //! However, using these operators in generic code, requires some\n //! attention if values have to be reused as opposed to letting the operators\n-//! consume them. One option is to occasionally use `clone()`.\n+//! consume them. One option is to occasionally use [`clone()`].\n //! Another option is to rely on the types involved providing additional\n //! operator implementations for references. For example, for a user-defined\n //! type `T` which is supposed to support addition, it is probably a good\n-//! idea to have both `T` and `&T` implement the traits `Add<T>` and `Add<&T>`\n-//! so that generic code can be written without unnecessary cloning.\n+//! idea to have both `T` and `&T` implement the traits [`Add<T>`][`Add`] and\n+//! [`Add<&T>`][`Add`] so that generic code can be written without unnecessary\n+//! cloning.\n //!\n //! # Examples\n //!\n-//! This example creates a `Point` struct that implements `Add` and `Sub`, and\n-//! then demonstrates adding and subtracting two `Point`s.\n+//! This example creates a `Point` struct that implements [`Add`] and [`Sub`],\n+//! and then demonstrates adding and subtracting two `Point`s.\n //!\n //! ```rust\n //! use std::ops::{Add, Sub};\n@@ -75,18 +76,14 @@\n //! See the documentation for each trait for an example implementation.\n //!\n //! The [`Fn`], [`FnMut`], and [`FnOnce`] traits are implemented by types that can be\n-//! invoked like functions. Note that `Fn` takes `&self`, `FnMut` takes `&mut\n-//! self` and `FnOnce` takes `self`. These correspond to the three kinds of\n+//! invoked like functions. Note that [`Fn`] takes `&self`, [`FnMut`] takes `&mut\n+//! self` and [`FnOnce`] takes `self`. These correspond to the three kinds of\n //! methods that can be invoked on an instance: call-by-reference,\n //! call-by-mutable-reference, and call-by-value. The most common use of these\n //! traits is to act as bounds to higher-level functions that take functions or\n //! closures as arguments.\n //!\n-//! [`Fn`]: trait.Fn.html\n-//! [`FnMut`]: trait.FnMut.html\n-//! [`FnOnce`]: trait.FnOnce.html\n-//!\n-//! Taking a `Fn` as a parameter:\n+//! Taking a [`Fn`] as a parameter:\n //!\n //! ```rust\n //! fn call_with_one<F>(func: F) -> usize\n@@ -99,7 +96,7 @@\n //! assert_eq!(call_with_one(double), 2);\n //! ```\n //!\n-//! Taking a `FnMut` as a parameter:\n+//! Taking a [`FnMut`] as a parameter:\n //!\n //! ```rust\n //! fn do_twice<F>(mut func: F)\n@@ -118,7 +115,7 @@\n //! assert_eq!(x, 5);\n //! ```\n //!\n-//! Taking a `FnOnce` as a parameter:\n+//! Taking a [`FnOnce`] as a parameter:\n //!\n //! ```rust\n //! fn consume_with_relish<F>(func: F)\n@@ -140,6 +137,13 @@\n //!\n //! // `consume_and_return_x` can no longer be invoked at this point\n //! ```\n+//!\n+//! [`Fn`]: trait.Fn.html\n+//! [`FnMut`]: trait.FnMut.html\n+//! [`FnOnce`]: trait.FnOnce.html\n+//! [`Add`]: trait.Add.html\n+//! [`Sub`]: trait.Sub.html\n+//! [`clone()`]: ../clone/trait.Clone.html#tymethod.clone\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -1641,7 +1645,7 @@ rem_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n #[lang = \"bitand_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n pub trait BitAndAssign<Rhs=Self> {\n-    /// The method for the `&` operator\n+    /// The method for the `&=` operator\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitand_assign(&mut self, Rhs);\n }\n@@ -1873,12 +1877,20 @@ macro_rules! shr_assign_impl_all {\n shr_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n \n /// The `Index` trait is used to specify the functionality of indexing operations\n-/// like `arr[idx]` when used in an immutable context.\n+/// like `container[index]` when used in an immutable context.\n+///\n+/// `container[index]` is actually syntactic sugar for `*container.index(index)`,\n+/// but only when used as an immutable value. If a mutable value is requested,\n+/// [`IndexMut`] is used instead. This allows nice things such as\n+/// `let value = v[index]` if `value` implements [`Copy`].\n+///\n+/// [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n ///\n /// # Examples\n ///\n-/// This example implements `Index` on a read-only `NucleotideCount` container,\n-/// enabling individual counts to be retrieved with index syntax.\n+/// The following example implements `Index` on a read-only `NucleotideCount`\n+/// container, enabling individual counts to be retrieved with index syntax.\n ///\n /// ```\n /// use std::ops::Index;\n@@ -1924,50 +1936,91 @@ pub trait Index<Idx: ?Sized> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output: ?Sized;\n \n-    /// The method for the indexing (`Foo[Bar]`) operation\n+    /// The method for the indexing (`container[index]`) operation\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index(&self, index: Idx) -> &Self::Output;\n }\n \n /// The `IndexMut` trait is used to specify the functionality of indexing\n-/// operations like `arr[idx]`, when used in a mutable context.\n+/// operations like `container[index]` when used in a mutable context.\n+///\n+/// `container[index]` is actually syntactic sugar for\n+/// `*container.index_mut(index)`, but only when used as a mutable value. If\n+/// an immutable value is requested, the [`Index`] trait is used instead. This\n+/// allows nice things such as `v[index] = value` if `value` implements [`Copy`].\n+///\n+/// [`Index`]: ../../std/ops/trait.Index.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `IndexMut`. When `Foo[Bar]` happens, it ends up\n-/// calling `index_mut`, and therefore, `main` prints `Indexing!`.\n+/// A very simple implementation of a `Balance` struct that has two sides, where\n+/// each can be indexed mutably and immutably.\n ///\n /// ```\n-/// use std::ops::{Index, IndexMut};\n+/// use std::ops::{Index,IndexMut};\n ///\n-/// #[derive(Copy, Clone)]\n-/// struct Foo;\n-/// struct Bar;\n+/// #[derive(Debug)]\n+/// enum Side {\n+///     Left,\n+///     Right,\n+/// }\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// enum Weight {\n+///     Kilogram(f32),\n+///     Pound(f32),\n+/// }\n ///\n-/// impl Index<Bar> for Foo {\n-///     type Output = Foo;\n+/// struct Balance {\n+///     pub left: Weight,\n+///     pub right:Weight,\n+/// }\n+///\n+/// impl Index<Side> for Balance {\n+///     type Output = Weight;\n ///\n-///     fn index<'a>(&'a self, _index: Bar) -> &'a Foo {\n-///         self\n+///     fn index<'a>(&'a self, index: Side) -> &'a Weight {\n+///         println!(\"Accessing {:?}-side of balance immutably\", index);\n+///         match index {\n+///             Side::Left => &self.left,\n+///             Side::Right => &self.right,\n+///         }\n ///     }\n /// }\n ///\n-/// impl IndexMut<Bar> for Foo {\n-///     fn index_mut<'a>(&'a mut self, _index: Bar) -> &'a mut Foo {\n-///         println!(\"Indexing!\");\n-///         self\n+/// impl IndexMut<Side> for Balance {\n+///     fn index_mut<'a>(&'a mut self, index: Side) -> &'a mut Weight {\n+///         println!(\"Accessing {:?}-side of balance mutably\", index);\n+///         match index {\n+///             Side::Left => &mut self.left,\n+///             Side::Right => &mut self.right,\n+///         }\n ///     }\n /// }\n ///\n /// fn main() {\n-///     &mut Foo[Bar];\n+///     let mut balance = Balance {\n+///         right: Weight::Kilogram(2.5),\n+///         left: Weight::Pound(1.5),\n+///     };\n+///\n+///     // In this case balance[Side::Right] is sugar for\n+///     // *balance.index(Side::Right), since we are only reading\n+///     // balance[Side::Right], not writing it.\n+///     assert_eq!(balance[Side::Right],Weight::Kilogram(2.5));\n+///\n+///     // However in this case balance[Side::Left] is sugar for\n+///     // *balance.index_mut(Side::Left), since we are writing\n+///     // balance[Side::Left].\n+///     balance[Side::Left] = Weight::Kilogram(3.0);\n /// }\n /// ```\n #[lang = \"index_mut\"]\n #[rustc_on_unimplemented = \"the type `{Self}` cannot be mutably indexed by `{Idx}`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n-    /// The method for the indexing (`Foo[Bar]`) operation\n+    /// The method for the mutable indexing (`container[index]`) operation\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n }"}, {"sha": "a74979911d34d1edfdb2fc6dc07c6657afb24102", "filename": "src/libcore/option.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -296,16 +296,14 @@ impl<T> Option<T> {\n \n     /// Moves the value `v` out of the `Option<T>` if it is `Some(v)`.\n     ///\n-    /// # Panics\n-    ///\n-    /// Panics if the self value equals `None`.\n-    ///\n-    /// # Safety note\n-    ///\n     /// In general, because this function may panic, its use is discouraged.\n     /// Instead, prefer to use pattern matching and handle the `None`\n     /// case explicitly.\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics if the self value equals `None`.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -916,12 +914,12 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// ```\n     /// use std::u16;\n     ///\n-    /// let v = vec!(1, 2);\n+    /// let v = vec![1, 2];\n     /// let res: Option<Vec<u16>> = v.iter().map(|&x: &u16|\n     ///     if x == u16::MAX { None }\n     ///     else { Some(x + 1) }\n     /// ).collect();\n-    /// assert!(res == Some(vec!(2, 3)));\n+    /// assert!(res == Some(vec![2, 3]));\n     /// ```\n     #[inline]\n     fn from_iter<I: IntoIterator<Item=Option<A>>>(iter: I) -> Option<V> {"}, {"sha": "3fa6a97d4cd156204a660c0fadce6741406c6f5a", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -18,36 +18,50 @@\n \n // Reexported core operators\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use marker::{Copy, Send, Sized, Sync};\n+#[doc(no_inline)]\n+pub use marker::{Copy, Send, Sized, Sync};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use ops::{Drop, Fn, FnMut, FnOnce};\n+#[doc(no_inline)]\n+pub use ops::{Drop, Fn, FnMut, FnOnce};\n \n // Reexported functions\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use mem::drop;\n+#[doc(no_inline)]\n+pub use mem::drop;\n \n // Reexported types and traits\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use clone::Clone;\n+#[doc(no_inline)]\n+pub use clone::Clone;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n+#[doc(no_inline)]\n+pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use convert::{AsRef, AsMut, Into, From};\n+#[doc(no_inline)]\n+pub use convert::{AsRef, AsMut, Into, From};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use default::Default;\n+#[doc(no_inline)]\n+pub use default::Default;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use iter::{Iterator, Extend, IntoIterator};\n+#[doc(no_inline)]\n+pub use iter::{Iterator, Extend, IntoIterator};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use iter::{DoubleEndedIterator, ExactSizeIterator};\n+#[doc(no_inline)]\n+pub use iter::{DoubleEndedIterator, ExactSizeIterator};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use option::Option::{self, Some, None};\n+#[doc(no_inline)]\n+pub use option::Option::{self, Some, None};\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n+#[doc(no_inline)]\n+pub use result::Result::{self, Ok, Err};\n \n // Reexported extension traits for primitive types\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use slice::SliceExt;\n+#[doc(no_inline)]\n+pub use slice::SliceExt;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use str::StrExt;\n+#[doc(no_inline)]\n+pub use str::StrExt;\n #[stable(feature = \"core_prelude\", since = \"1.4.0\")]\n-#[doc(no_inline)] pub use char::CharExt;\n+#[doc(no_inline)]\n+pub use char::CharExt;"}, {"sha": "f0510422a07d7b67faf2ed6442f46bc1be5d3bed", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -761,7 +761,7 @@ impl<T:?Sized> Deref for Unique<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[unstable(feature = \"unique\", issue = \"27730\")]\n impl<T> fmt::Pointer for Unique<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Pointer::fmt(&*self.pointer, f)"}, {"sha": "3d34f62006785641c00e6bc167637fa632e7a4f9", "filename": "src/libcore/result.rs", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -792,6 +792,44 @@ impl<T: fmt::Debug, E> Result<T, E> {\n     }\n }\n \n+impl<T: Default, E> Result<T, E> {\n+    /// Returns the contained value or a default\n+    ///\n+    /// Consumes the `self` argument then, if `Ok`, returns the contained\n+    /// value, otherwise if `Err`, returns the default value for that\n+    /// type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Convert a string to an integer, turning poorly-formed strings\n+    /// into 0 (the default value for integers). [`parse`] converts\n+    /// a string to any other type that implements [`FromStr`], returning an\n+    /// `Err` on error.\n+    ///\n+    /// ```\n+    /// #![feature(result_unwrap_or_default)]\n+    ///\n+    /// let good_year_from_input = \"1909\";\n+    /// let bad_year_from_input = \"190blarg\";\n+    /// let good_year = good_year_from_input.parse().unwrap_or_default();\n+    /// let bad_year = bad_year_from_input.parse().unwrap_or_default();\n+    ///\n+    /// assert_eq!(1909, good_year);\n+    /// assert_eq!(0, bad_year);\n+    ///\n+    /// [`parse`]: ../../std/primitive.str.html#method.parse\n+    /// [`FromStr`]: ../../std/str/trait.FromStr.html\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"result_unwrap_or_default\", issue = \"0\")]\n+    pub fn unwrap_or_default(self) -> T {\n+        match self {\n+            Ok(x) => x,\n+            Err(_) => Default::default(),\n+        }\n+    }\n+}\n+\n // This is a separate function to reduce the code size of the methods\n #[inline(never)]\n #[cold]\n@@ -977,12 +1015,12 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// ```\n     /// use std::u32;\n     ///\n-    /// let v = vec!(1, 2);\n+    /// let v = vec![1, 2];\n     /// let res: Result<Vec<u32>, &'static str> = v.iter().map(|&x: &u32|\n     ///     if x == u32::MAX { Err(\"Overflow!\") }\n     ///     else { Ok(x + 1) }\n     /// ).collect();\n-    /// assert!(res == Ok(vec!(2, 3)));\n+    /// assert!(res == Ok(vec![2, 3]));\n     /// ```\n     #[inline]\n     fn from_iter<I: IntoIterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {\n@@ -1008,6 +1046,11 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n                     None => None,\n                 }\n             }\n+\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n+                let (_min, max) = self.iter.size_hint();\n+                (0, max)\n+            }\n         }\n \n         let mut adapter = Adapter { iter: iter.into_iter(), err: None };"}, {"sha": "31be404ba905a1fcb580d0e219aa4528c7b96972", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -1968,11 +1968,13 @@ unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n         &*self.ptr.offset(i as isize)\n     }\n+    fn may_have_side_effect() -> bool { false }\n }\n \n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n         &mut *self.ptr.offset(i as isize)\n     }\n+    fn may_have_side_effect() -> bool { false }\n }"}, {"sha": "d63d2d64fe1018fc40d8065cb3cf018973586730", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -101,7 +101,7 @@ impl FromStr for bool {\n }\n \n /// An error returned when parsing a `bool` from a string fails.\n-#[derive(Debug, Clone, PartialEq)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseBoolError { _priv: () }\n "}, {"sha": "657f7e7992fee06ba53947f87802138df76500a7", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -95,7 +95,7 @@ pub struct AtomicBool {\n #[cfg(target_has_atomic = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for AtomicBool {\n-    /// Creates an `AtomicBool` initialised as false.\n+    /// Creates an `AtomicBool` initialized to `false`.\n     fn default() -> Self {\n         Self::new(false)\n     }\n@@ -277,7 +277,9 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n-        unsafe { atomic_store(self.v.get(), val as u8, order); }\n+        unsafe {\n+            atomic_store(self.v.get(), val as u8, order);\n+        }\n     }\n \n     /// Stores a value into the bool, returning the old value.\n@@ -366,9 +368,11 @@ impl AtomicBool {\n                             current: bool,\n                             new: bool,\n                             success: Ordering,\n-                            failure: Ordering) -> Result<bool, bool> {\n-        match unsafe { atomic_compare_exchange(self.v.get(), current as u8, new as u8,\n-                                               success, failure) } {\n+                            failure: Ordering)\n+                            -> Result<bool, bool> {\n+        match unsafe {\n+            atomic_compare_exchange(self.v.get(), current as u8, new as u8, success, failure)\n+        } {\n             Ok(x) => Ok(x != 0),\n             Err(x) => Err(x != 0),\n         }\n@@ -409,9 +413,11 @@ impl AtomicBool {\n                                  current: bool,\n                                  new: bool,\n                                  success: Ordering,\n-                                 failure: Ordering) -> Result<bool, bool> {\n-        match unsafe { atomic_compare_exchange_weak(self.v.get(), current as u8, new as u8,\n-                                                    success, failure) } {\n+                                 failure: Ordering)\n+                                 -> Result<bool, bool> {\n+        match unsafe {\n+            atomic_compare_exchange_weak(self.v.get(), current as u8, new as u8, success, failure)\n+        } {\n             Ok(x) => Ok(x != 0),\n             Err(x) => Err(x != 0),\n         }\n@@ -632,9 +638,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> *mut T {\n-        unsafe {\n-            atomic_load(self.p.get() as *mut usize, order) as *mut T\n-        }\n+        unsafe { atomic_load(self.p.get() as *mut usize, order) as *mut T }\n     }\n \n     /// Stores a value into the pointer.\n@@ -660,7 +664,9 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n-        unsafe { atomic_store(self.p.get() as *mut usize, ptr as usize, order); }\n+        unsafe {\n+            atomic_store(self.p.get() as *mut usize, ptr as usize, order);\n+        }\n     }\n \n     /// Stores a value into the pointer, returning the old value.\n@@ -745,7 +751,8 @@ impl<T> AtomicPtr<T> {\n                             current: *mut T,\n                             new: *mut T,\n                             success: Ordering,\n-                            failure: Ordering) -> Result<*mut T, *mut T> {\n+                            failure: Ordering)\n+                            -> Result<*mut T, *mut T> {\n         unsafe {\n             let res = atomic_compare_exchange(self.p.get() as *mut usize,\n                                               current as usize,\n@@ -794,7 +801,8 @@ impl<T> AtomicPtr<T> {\n                                  current: *mut T,\n                                  new: *mut T,\n                                  success: Ordering,\n-                                 failure: Ordering) -> Result<*mut T, *mut T> {\n+                                 failure: Ordering)\n+                                 -> Result<*mut T, *mut T> {\n         unsafe {\n             let res = atomic_compare_exchange_weak(self.p.get() as *mut usize,\n                                                    current as usize,\n@@ -1266,9 +1274,9 @@ fn strongest_failure_ordering(order: Ordering) -> Ordering {\n     match order {\n         Release => Relaxed,\n         Relaxed => Relaxed,\n-        SeqCst  => SeqCst,\n+        SeqCst => SeqCst,\n         Acquire => Acquire,\n-        AcqRel  => Acquire,\n+        AcqRel => Acquire,\n     }\n }\n \n@@ -1277,9 +1285,9 @@ unsafe fn atomic_store<T>(dst: *mut T, val: T, order: Ordering) {\n     match order {\n         Release => intrinsics::atomic_store_rel(dst, val),\n         Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n-        SeqCst  => intrinsics::atomic_store(dst, val),\n+        SeqCst => intrinsics::atomic_store(dst, val),\n         Acquire => panic!(\"there is no such thing as an acquire store\"),\n-        AcqRel  => panic!(\"there is no such thing as an acquire/release store\"),\n+        AcqRel => panic!(\"there is no such thing as an acquire/release store\"),\n     }\n }\n \n@@ -1288,9 +1296,9 @@ unsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_load_acq(dst),\n         Relaxed => intrinsics::atomic_load_relaxed(dst),\n-        SeqCst  => intrinsics::atomic_load(dst),\n+        SeqCst => intrinsics::atomic_load(dst),\n         Release => panic!(\"there is no such thing as a release load\"),\n-        AcqRel  => panic!(\"there is no such thing as an acquire/release load\"),\n+        AcqRel => panic!(\"there is no such thing as an acquire/release load\"),\n     }\n }\n \n@@ -1299,9 +1307,9 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n         Release => intrinsics::atomic_xchg_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xchg_acqrel(dst, val),\n+        AcqRel => intrinsics::atomic_xchg_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n-        SeqCst  => intrinsics::atomic_xchg(dst, val)\n+        SeqCst => intrinsics::atomic_xchg(dst, val),\n     }\n }\n \n@@ -1311,9 +1319,9 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n         Release => intrinsics::atomic_xadd_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xadd_acqrel(dst, val),\n+        AcqRel => intrinsics::atomic_xadd_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n-        SeqCst  => intrinsics::atomic_xadd(dst, val)\n+        SeqCst => intrinsics::atomic_xadd(dst, val),\n     }\n }\n \n@@ -1323,9 +1331,9 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n         Release => intrinsics::atomic_xsub_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xsub_acqrel(dst, val),\n+        AcqRel => intrinsics::atomic_xsub_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n-        SeqCst  => intrinsics::atomic_xsub(dst, val)\n+        SeqCst => intrinsics::atomic_xsub(dst, val),\n     }\n }\n \n@@ -1334,63 +1342,57 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n                                      old: T,\n                                      new: T,\n                                      success: Ordering,\n-                                     failure: Ordering) -> Result<T, T> {\n+                                     failure: Ordering)\n+                                     -> Result<T, T> {\n     let (val, ok) = match (success, failure) {\n         (Acquire, Acquire) => intrinsics::atomic_cxchg_acq(dst, old, new),\n         (Release, Relaxed) => intrinsics::atomic_cxchg_rel(dst, old, new),\n-        (AcqRel, Acquire)  => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n+        (AcqRel, Acquire) => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n         (Relaxed, Relaxed) => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n-        (SeqCst, SeqCst)   => intrinsics::atomic_cxchg(dst, old, new),\n+        (SeqCst, SeqCst) => intrinsics::atomic_cxchg(dst, old, new),\n         (Acquire, Relaxed) => intrinsics::atomic_cxchg_acq_failrelaxed(dst, old, new),\n-        (AcqRel, Relaxed)  => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n-        (SeqCst, Relaxed)  => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n-        (SeqCst, Acquire)  => intrinsics::atomic_cxchg_failacq(dst, old, new),\n+        (AcqRel, Relaxed) => intrinsics::atomic_cxchg_acqrel_failrelaxed(dst, old, new),\n+        (SeqCst, Relaxed) => intrinsics::atomic_cxchg_failrelaxed(dst, old, new),\n+        (SeqCst, Acquire) => intrinsics::atomic_cxchg_failacq(dst, old, new),\n         (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n         (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n         _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n     };\n-    if ok {\n-        Ok(val)\n-    } else {\n-        Err(val)\n-    }\n+    if ok { Ok(val) } else { Err(val) }\n }\n \n #[inline]\n unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n                                           old: T,\n                                           new: T,\n                                           success: Ordering,\n-                                          failure: Ordering) -> Result<T, T> {\n+                                          failure: Ordering)\n+                                          -> Result<T, T> {\n     let (val, ok) = match (success, failure) {\n         (Acquire, Acquire) => intrinsics::atomic_cxchgweak_acq(dst, old, new),\n         (Release, Relaxed) => intrinsics::atomic_cxchgweak_rel(dst, old, new),\n-        (AcqRel, Acquire)  => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n+        (AcqRel, Acquire) => intrinsics::atomic_cxchgweak_acqrel(dst, old, new),\n         (Relaxed, Relaxed) => intrinsics::atomic_cxchgweak_relaxed(dst, old, new),\n-        (SeqCst, SeqCst)   => intrinsics::atomic_cxchgweak(dst, old, new),\n+        (SeqCst, SeqCst) => intrinsics::atomic_cxchgweak(dst, old, new),\n         (Acquire, Relaxed) => intrinsics::atomic_cxchgweak_acq_failrelaxed(dst, old, new),\n-        (AcqRel, Relaxed)  => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n-        (SeqCst, Relaxed)  => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n-        (SeqCst, Acquire)  => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n+        (AcqRel, Relaxed) => intrinsics::atomic_cxchgweak_acqrel_failrelaxed(dst, old, new),\n+        (SeqCst, Relaxed) => intrinsics::atomic_cxchgweak_failrelaxed(dst, old, new),\n+        (SeqCst, Acquire) => intrinsics::atomic_cxchgweak_failacq(dst, old, new),\n         (_, AcqRel) => panic!(\"there is no such thing as an acquire/release failure ordering\"),\n         (_, Release) => panic!(\"there is no such thing as a release failure ordering\"),\n         _ => panic!(\"a failure ordering can't be stronger than a success ordering\"),\n     };\n-    if ok {\n-        Ok(val)\n-    } else {\n-        Err(val)\n-    }\n+    if ok { Ok(val) } else { Err(val) }\n }\n \n #[inline]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n         Release => intrinsics::atomic_and_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_and_acqrel(dst, val),\n+        AcqRel => intrinsics::atomic_and_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n-        SeqCst  => intrinsics::atomic_and(dst, val)\n+        SeqCst => intrinsics::atomic_and(dst, val),\n     }\n }\n \n@@ -1399,9 +1401,9 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n         Release => intrinsics::atomic_or_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_or_acqrel(dst, val),\n+        AcqRel => intrinsics::atomic_or_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n-        SeqCst  => intrinsics::atomic_or(dst, val)\n+        SeqCst => intrinsics::atomic_or(dst, val),\n     }\n }\n \n@@ -1410,9 +1412,9 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n         Release => intrinsics::atomic_xor_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xor_acqrel(dst, val),\n+        AcqRel => intrinsics::atomic_xor_acqrel(dst, val),\n         Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n-        SeqCst  => intrinsics::atomic_xor(dst, val)\n+        SeqCst => intrinsics::atomic_xor(dst, val),\n     }\n }\n \n@@ -1443,9 +1445,9 @@ pub fn fence(order: Ordering) {\n         match order {\n             Acquire => intrinsics::atomic_fence_acq(),\n             Release => intrinsics::atomic_fence_rel(),\n-            AcqRel  => intrinsics::atomic_fence_acqrel(),\n-            SeqCst  => intrinsics::atomic_fence(),\n-            Relaxed => panic!(\"there is no such thing as a relaxed fence\")\n+            AcqRel => intrinsics::atomic_fence_acqrel(),\n+            SeqCst => intrinsics::atomic_fence(),\n+            Relaxed => panic!(\"there is no such thing as a relaxed fence\"),\n         }\n     }\n }"}, {"sha": "7da0b6902f2717f5f6a584cd77d2c15eba74ed96", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::char;\n+use std::{char,str};\n use std::convert::TryFrom;\n \n #[test]\n@@ -248,10 +248,12 @@ fn test_escape_unicode() {\n #[test]\n fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n-        assert_eq!(input.encode_utf8().as_slice(), expect);\n-        for (a, b) in input.encode_utf8().zip(expect) {\n-            assert_eq!(a, *b);\n-        }\n+        let mut buf = [0; 4];\n+        let ptr = buf.as_ptr();\n+        let s = input.encode_utf8(&mut buf);\n+        assert_eq!(s.as_ptr() as usize, ptr as usize);\n+        assert!(str::from_utf8(s.as_bytes()).is_ok());\n+        assert_eq!(s.as_bytes(), expect);\n     }\n \n     check('x', &[0x78]);\n@@ -263,10 +265,11 @@ fn test_encode_utf8() {\n #[test]\n fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n-        assert_eq!(input.encode_utf16().as_slice(), expect);\n-        for (a, b) in input.encode_utf16().zip(expect) {\n-            assert_eq!(a, *b);\n-        }\n+        let mut buf = [0; 2];\n+        let ptr = buf.as_mut_ptr();\n+        let b = input.encode_utf16(&mut buf);\n+        assert_eq!(b.as_mut_ptr() as usize, ptr as usize);\n+        assert_eq!(b, expect);\n     }\n \n     check('x', &[0x0078]);"}, {"sha": "fa3bfdea42df8194734d8ccb3e80222f9b1d5636", "filename": "src/libcoretest/hash/sip.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcoretest%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcoretest%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fsip.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -7,10 +7,14 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n+#![allow(deprecated)]\n+\n use test::{Bencher, black_box};\n \n use core::hash::{Hash, Hasher};\n use core::hash::{SipHasher, SipHasher13, SipHasher24};\n+use core::{slice, mem};\n \n // Hash just the bytes of the slice, without length prefix\n struct Bytes<'a>(&'a [u8]);\n@@ -324,6 +328,26 @@ fn test_hash_no_concat_alias() {\n     assert!(hash(&v) != hash(&w));\n }\n \n+#[test]\n+fn test_write_short_works() {\n+    let test_usize = 0xd0c0b0a0usize;\n+    let mut h1 = SipHasher24::new();\n+    h1.write_usize(test_usize);\n+    h1.write(b\"bytes\");\n+    h1.write(b\"string\");\n+    h1.write_u8(0xFFu8);\n+    h1.write_u8(0x01u8);\n+    let mut h2 = SipHasher24::new();\n+    h2.write(unsafe {\n+        slice::from_raw_parts(&test_usize as *const _ as *const u8,\n+                              mem::size_of::<usize>())\n+    });\n+    h2.write(b\"bytes\");\n+    h2.write(b\"string\");\n+    h2.write(&[0xFFu8, 0x01u8]);\n+    assert_eq!(h1.finish(), h2.finish());\n+}\n+\n #[bench]\n fn bench_str_under_8_bytes(b: &mut Bencher) {\n     let s = \"foo\";"}, {"sha": "58b6444ef88cd95f278d4c0b458516573b1cc5c4", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -985,6 +985,18 @@ fn test_empty() {\n     assert_eq!(it.next(), None);\n }\n \n+#[test]\n+fn test_chain_fold() {\n+    let xs = [1, 2, 3];\n+    let ys = [1, 2, 0];\n+\n+    let mut iter = xs.iter().chain(&ys);\n+    iter.next();\n+    let mut result = Vec::new();\n+    iter.fold((), |(), &elt| result.push(elt));\n+    assert_eq!(&[2, 3, 1, 2, 0], &result[..]);\n+}\n+\n #[bench]\n fn bench_rposition(b: &mut Bencher) {\n     let it: Vec<usize> = (0..300).collect();"}, {"sha": "b8c01e570f5091d26fc24a6da770e019524c2465", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -35,6 +35,7 @@\n #![feature(iter_max_by)]\n #![feature(iter_min_by)]\n #![feature(ordering_chaining)]\n+#![feature(result_unwrap_or_default)]\n \n extern crate core;\n extern crate test;"}, {"sha": "0bca616ea9abcc99e5fc604ee4d91f2472b2985d", "filename": "src/libcoretest/num/flt2dec/estimator.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Festimator.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME https://github.com/kripken/emscripten/issues/4563\n+// NB we have to actually not compile this test to avoid\n+// an undefined symbol error\n+#![cfg(not(target_os = \"emscripten\"))]\n+\n use core::num::flt2dec::estimator::*;\n \n #[test]"}, {"sha": "bc2cd8bbfc6512158415e957a23f408378b881c2", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -183,3 +183,9 @@ pub fn test_iter_mut() {\n     }\n     assert_eq!(err, Err(\"error\"));\n }\n+\n+#[test]\n+pub fn test_unwrap_or_default() {\n+    assert_eq!(op1().unwrap_or_default(), 666);\n+    assert_eq!(op2().unwrap_or_default(), 0);\n+}"}, {"sha": "3c608ef9c9268b5554fae5617d108c42e8015ea5", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -94,11 +94,14 @@ extern \"C\" {\n                                     -> *mut c_void;\n }\n \n-const LZ_NORM: c_int = 0x80;  // LZ with 128 probes, \"normal\"\n-const TINFL_FLAG_PARSE_ZLIB_HEADER: c_int = 0x1; // parse zlib header and adler32 checksum\n-const TDEFL_WRITE_ZLIB_HEADER: c_int = 0x01000; // write zlib header and adler32 checksum\n+const LZ_FAST: c_int = 0x01;  // LZ with 1 probe, \"fast\"\n+const TDEFL_GREEDY_PARSING_FLAG: c_int = 0x04000; // fast greedy parsing instead of lazy parsing\n \n-fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Bytes {\n+/// Compress a buffer without writing any sort of header on the output. Fast\n+/// compression is used because it is almost twice as fast as default\n+/// compression and the compression ratio is only marginally worse.\n+pub fn deflate_bytes(bytes: &[u8]) -> Bytes {\n+    let flags = LZ_FAST | TDEFL_GREEDY_PARSING_FLAG;\n     unsafe {\n         let mut outsz: size_t = 0;\n         let res = tdefl_compress_mem_to_heap(bytes.as_ptr() as *const _,\n@@ -113,17 +116,9 @@ fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Bytes {\n     }\n }\n \n-/// Compress a buffer, without writing any sort of header on the output.\n-pub fn deflate_bytes(bytes: &[u8]) -> Bytes {\n-    deflate_bytes_internal(bytes, LZ_NORM)\n-}\n-\n-/// Compress a buffer, using a header that zlib can understand.\n-pub fn deflate_bytes_zlib(bytes: &[u8]) -> Bytes {\n-    deflate_bytes_internal(bytes, LZ_NORM | TDEFL_WRITE_ZLIB_HEADER)\n-}\n-\n-fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Result<Bytes, Error> {\n+/// Decompress a buffer without parsing any sort of header on the input.\n+pub fn inflate_bytes(bytes: &[u8]) -> Result<Bytes, Error> {\n+    let flags = 0;\n     unsafe {\n         let mut outsz: size_t = 0;\n         let res = tinfl_decompress_mem_to_heap(bytes.as_ptr() as *const _,\n@@ -141,16 +136,6 @@ fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Result<Bytes, Error> {\n     }\n }\n \n-/// Decompress a buffer, without parsing any sort of header on the input.\n-pub fn inflate_bytes(bytes: &[u8]) -> Result<Bytes, Error> {\n-    inflate_bytes_internal(bytes, 0)\n-}\n-\n-/// Decompress a buffer that starts with a zlib header.\n-pub fn inflate_bytes_zlib(bytes: &[u8]) -> Result<Bytes, Error> {\n-    inflate_bytes_internal(bytes, TINFL_FLAG_PARSE_ZLIB_HEADER)\n-}\n-\n #[cfg(test)]\n mod tests {\n     #![allow(deprecated)]"}, {"sha": "4d2f1b999a2aec763b96be41930766f315cc0024", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -1610,8 +1610,8 @@ Options:\n \n     #[test]\n     fn test_args_with_equals() {\n-        let args = vec!(\"--one\".to_string(), \"A=B\".to_string(),\n-                        \"--two=C=D\".to_string());\n+        let args = vec![\"--one\".to_string(), \"A=B\".to_string(),\n+                        \"--two=C=D\".to_string()];\n         let opts = vec![optopt(\"o\", \"one\", \"One\", \"INFO\"),\n                         optopt(\"t\", \"two\", \"Two\", \"INFO\")];\n         let matches = &match getopts(&args, &opts) {"}, {"sha": "03057af4a843bf07a8de8dfadf4c064cdd72bade", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -58,7 +58,7 @@\n //! struct Edges(Vec<Ed>);\n //!\n //! pub fn render_to<W: Write>(output: &mut W) {\n-//!     let edges = Edges(vec!((0,1), (0,2), (1,3), (2,3), (3,4), (4,4)));\n+//!     let edges = Edges(vec![(0,1), (0,2), (1,3), (2,3), (3,4), (4,4)]);\n //!     dot::render(&edges, output).unwrap()\n //! }\n //!\n@@ -164,8 +164,8 @@\n //! struct Graph { nodes: Vec<&'static str>, edges: Vec<(usize,usize)> }\n //!\n //! pub fn render_to<W: Write>(output: &mut W) {\n-//!     let nodes = vec!(\"{x,y}\",\"{x}\",\"{y}\",\"{}\");\n-//!     let edges = vec!((0,1), (0,2), (1,3), (2,3));\n+//!     let nodes = vec![\"{x,y}\",\"{x}\",\"{y}\",\"{}\"];\n+//!     let edges = vec![(0,1), (0,2), (1,3), (2,3)];\n //!     let graph = Graph { nodes: nodes, edges: edges };\n //!\n //!     dot::render(&graph, output).unwrap()\n@@ -226,8 +226,8 @@\n //! struct Graph { nodes: Vec<&'static str>, edges: Vec<(usize,usize)> }\n //!\n //! pub fn render_to<W: Write>(output: &mut W) {\n-//!     let nodes = vec!(\"{x,y}\",\"{x}\",\"{y}\",\"{}\");\n-//!     let edges = vec!((0,1), (0,2), (1,3), (2,3));\n+//!     let nodes = vec![\"{x,y}\",\"{x}\",\"{y}\",\"{}\"];\n+//!     let edges = vec![(0,1), (0,2), (1,3), (2,3)];\n //!     let graph = Graph { nodes: nodes, edges: edges };\n //!\n //!     dot::render(&graph, output).unwrap()\n@@ -295,7 +295,7 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(str_escape)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n \n use self::LabelText::*;\n "}, {"sha": "7d9b71f0971f8fa196d864d7071f216a59036d6e", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -1 +1 @@\n-Subproject commit d4f6a19c55a03e3f9f6fb7377911b37ed807eb6c\n+Subproject commit 7d9b71f0971f8fa196d864d7071f216a59036d6e"}, {"sha": "eb50d6e6135ef2124e10987519d18225fdf566f4", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -22,12 +22,12 @@ pub const LOG_LEVEL_NAMES: [&'static str; 5] = [\"ERROR\", \"WARN\", \"INFO\", \"DEBUG\"\n /// Parse an individual log level that is either a number or a symbolic log level\n fn parse_log_level(level: &str) -> Option<u32> {\n     level.parse::<u32>()\n-         .ok()\n-         .or_else(|| {\n-             let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n-             pos.map(|p| p as u32 + 1)\n-         })\n-         .map(|p| cmp::min(p, ::MAX_LOG_LEVEL))\n+        .ok()\n+        .or_else(|| {\n+            let pos = LOG_LEVEL_NAMES.iter().position(|&name| name.eq_ignore_ascii_case(level));\n+            pos.map(|p| p as u32 + 1)\n+        })\n+        .map(|p| cmp::min(p, ::MAX_LOG_LEVEL))\n }\n \n /// Parse a logging specification string (e.g: \"crate1,crate2::mod3,crate3::x=1/foo\")\n@@ -52,32 +52,31 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<String>) {\n                 continue;\n             }\n             let mut parts = s.split('=');\n-            let (log_level, name) = match (parts.next(),\n-                                           parts.next().map(|s| s.trim()),\n-                                           parts.next()) {\n-                (Some(part0), None, None) => {\n-                    // if the single argument is a log-level string or number,\n-                    // treat that as a global fallback\n-                    match parse_log_level(part0) {\n-                        Some(num) => (num, None),\n-                        None => (::MAX_LOG_LEVEL, Some(part0)),\n+            let (log_level, name) =\n+                match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {\n+                    (Some(part0), None, None) => {\n+                        // if the single argument is a log-level string or number,\n+                        // treat that as a global fallback\n+                        match parse_log_level(part0) {\n+                            Some(num) => (num, None),\n+                            None => (::MAX_LOG_LEVEL, Some(part0)),\n+                        }\n                     }\n-                }\n-                (Some(part0), Some(\"\"), None) => (::MAX_LOG_LEVEL, Some(part0)),\n-                (Some(part0), Some(part1), None) => {\n-                    match parse_log_level(part1) {\n-                        Some(num) => (num, Some(part0)),\n-                        _ => {\n-                            println!(\"warning: invalid logging spec '{}', ignoring it\", part1);\n-                            continue;\n+                    (Some(part0), Some(\"\"), None) => (::MAX_LOG_LEVEL, Some(part0)),\n+                    (Some(part0), Some(part1), None) => {\n+                        match parse_log_level(part1) {\n+                            Some(num) => (num, Some(part0)),\n+                            _ => {\n+                                println!(\"warning: invalid logging spec '{}', ignoring it\", part1);\n+                                continue;\n+                            }\n                         }\n                     }\n-                }\n-                _ => {\n-                    println!(\"warning: invalid logging spec '{}', ignoring it\", s);\n-                    continue;\n-                }\n-            };\n+                    _ => {\n+                        println!(\"warning: invalid logging spec '{}', ignoring it\", s);\n+                        continue;\n+                    }\n+                };\n             dirs.push(LogDirective {\n                 name: name.map(str::to_owned),\n                 level: log_level,"}, {"sha": "20d826d4a470ee7c7c14d85b6760caade6f26eef", "filename": "src/libpanic_unwind/Cargo.lock", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4e2822c5c28bb342e5862ba7cc0b90b865c68be1/src%2Flibpanic_unwind%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4e2822c5c28bb342e5862ba7cc0b90b865c68be1/src%2Flibpanic_unwind%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2FCargo.lock?ref=4e2822c5c28bb342e5862ba7cc0b90b865c68be1", "patch": "@@ -1,27 +0,0 @@\n-[root]\n-name = \"panic_unwind\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"alloc 0.0.0\",\n- \"core 0.0.0\",\n- \"libc 0.0.0\",\n-]\n-\n-[[package]]\n-name = \"alloc\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"core 0.0.0\",\n-]\n-\n-[[package]]\n-name = \"core\"\n-version = \"0.0.0\"\n-\n-[[package]]\n-name = \"libc\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"core 0.0.0\",\n-]\n-"}, {"sha": "e7994f4e0ef0a3837ee33ad2719db00e18d45c80", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -116,7 +116,7 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n         // The \"IP\" is an index into the call-site table, with two exceptions:\n         // -1 means 'no-action', and 0 means 'terminate'.\n         match ip as isize {\n-           -1 => return EHAction::None,\n+            -1 => return EHAction::None,\n             0 => return EHAction::Terminate,\n             _ => (),\n         }\n@@ -182,12 +182,8 @@ unsafe fn read_encoded_pointer(reader: &mut DwarfReader,\n             assert!(context.func_start != 0);\n             context.func_start\n         }\n-        DW_EH_PE_textrel => {\n-            (*context.get_text_start)()\n-        }\n-        DW_EH_PE_datarel => {\n-            (*context.get_data_start)()\n-        }\n+        DW_EH_PE_textrel => (*context.get_text_start)(),\n+        DW_EH_PE_datarel => (*context.get_data_start)(),\n         _ => panic!(),\n     };\n "}, {"sha": "0e48e37c92358150f285f4cc5db6357e098b9fb3", "filename": "src/libpanic_unwind/emcc.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unwinding for emscripten\n+//!\n+//! Whereas Rust's usual unwinding implementation for Unix platforms\n+//! calls into the libunwind APIs directly, on emscripten we instead\n+//! call into the C++ unwinding APIs. This is just an expedience since\n+//! emscripten's runtime always implements those APIs and does not\n+//! implement libunwind.\n+\n+#![allow(private_no_mangle_fns)]\n+\n+use core::any::Any;\n+use core::ptr;\n+use alloc::boxed::Box;\n+use libc::{self, c_int};\n+use unwind as uw;\n+use core::mem;\n+\n+pub fn payload() -> *mut u8 {\n+    ptr::null_mut()\n+}\n+\n+pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {\n+    assert!(!ptr.is_null());\n+    let ex = ptr::read(ptr as *mut _);\n+    __cxa_free_exception(ptr as *mut _);\n+    ex\n+}\n+\n+pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n+    let sz = mem::size_of_val(&data);\n+    let exception = __cxa_allocate_exception(sz);\n+    if exception == ptr::null_mut() {\n+        return uw::_URC_FATAL_PHASE1_ERROR as u32;\n+    }\n+    let exception = exception as *mut Box<Any + Send>;\n+    ptr::write(exception, data);\n+    __cxa_throw(exception as *mut _, ptr::null_mut(), ptr::null_mut());\n+\n+    unreachable!()\n+}\n+\n+#[lang = \"eh_personality\"]\n+#[no_mangle]\n+unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n+                                         actions: uw::_Unwind_Action,\n+                                         exception_class: uw::_Unwind_Exception_Class,\n+                                         exception_object: *mut uw::_Unwind_Exception,\n+                                         context: *mut uw::_Unwind_Context)\n+                                         -> uw::_Unwind_Reason_Code {\n+    __gxx_personality_v0(version, actions, exception_class, exception_object, context)\n+}\n+\n+extern \"C\" {\n+    fn __cxa_allocate_exception(thrown_size: libc::size_t) -> *mut libc::c_void;\n+    fn __cxa_free_exception(thrown_exception: *mut libc::c_void);\n+    fn __cxa_throw(thrown_exception: *mut libc::c_void,\n+                   tinfo: *mut libc::c_void,\n+                   dest: *mut libc::c_void);\n+    fn __gxx_personality_v0(version: c_int,\n+                            actions: uw::_Unwind_Action,\n+                            exception_class: uw::_Unwind_Exception_Class,\n+                            exception_object: *mut uw::_Unwind_Exception,\n+                            context: *mut uw::_Unwind_Context)\n+                            -> uw::_Unwind_Reason_Code;\n+}"}, {"sha": "f0f19be3366bd064f9699fa87271f7518007f401", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -156,14 +156,16 @@ unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n     let eh_action = find_eh_action(context);\n     if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n         match eh_action {\n-            EHAction::None | EHAction::Cleanup(_) => return uw::_URC_CONTINUE_UNWIND,\n+            EHAction::None |\n+            EHAction::Cleanup(_) => return uw::_URC_CONTINUE_UNWIND,\n             EHAction::Catch(_) => return uw::_URC_HANDLER_FOUND,\n             EHAction::Terminate => return uw::_URC_FATAL_PHASE1_ERROR,\n         }\n     } else {\n         match eh_action {\n             EHAction::None => return uw::_URC_CONTINUE_UNWIND,\n-            EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+            EHAction::Cleanup(lpad) |\n+            EHAction::Catch(lpad) => {\n                 uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n                 uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n                 uw::_Unwind_SetIP(context, lpad);\n@@ -182,7 +184,7 @@ unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n                                          exception_object: *mut uw::_Unwind_Exception,\n                                          context: *mut uw::_Unwind_Context)\n-                                        -> uw::_Unwind_Reason_Code {\n+                                         -> uw::_Unwind_Reason_Code {\n     let state = state as c_int;\n     let action = state & uw::_US_ACTION_MASK as c_int;\n     let search_phase = if action == uw::_US_VIRTUAL_UNWIND_FRAME as c_int {\n@@ -191,7 +193,7 @@ unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n         // we want to continue unwinding the stack, otherwise all our backtraces\n         // would end at __rust_try\n         if state & uw::_US_FORCE_UNWIND as c_int != 0 {\n-            return continue_unwind(exception_object, context)\n+            return continue_unwind(exception_object, context);\n         }\n         true\n     } else if action == uw::_US_UNWIND_FRAME_STARTING as c_int {\n@@ -207,7 +209,9 @@ unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n     // To preserve signatures of functions like _Unwind_GetLanguageSpecificData(), which\n     // take only the context pointer, GCC personality routines stash a pointer to exception_object\n     // in the context, using location reserved for ARM's \"scratch register\" (r12).\n-    uw::_Unwind_SetGR(context, uw::UNWIND_POINTER_REG, exception_object as uw::_Unwind_Ptr);\n+    uw::_Unwind_SetGR(context,\n+                      uw::UNWIND_POINTER_REG,\n+                      exception_object as uw::_Unwind_Ptr);\n     // ...A more principled approach would be to provide the full definition of ARM's\n     // _Unwind_Context in our libunwind bindings and fetch the required data from there directly,\n     // bypassing DWARF compatibility functions.\n@@ -223,7 +227,8 @@ unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n     } else {\n         match eh_action {\n             EHAction::None => return continue_unwind(exception_object, context),\n-            EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+            EHAction::Cleanup(lpad) |\n+            EHAction::Catch(lpad) => {\n                 uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0, exception_object as uintptr_t);\n                 uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n                 uw::_Unwind_SetIP(context, lpad);\n@@ -247,8 +252,8 @@ unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n     // defined in libgcc\n     extern \"C\" {\n         fn __gnu_unwind_frame(exception_object: *mut uw::_Unwind_Exception,\n-                                context: *mut uw::_Unwind_Context)\n-                                -> uw::_Unwind_Reason_Code;\n+                              context: *mut uw::_Unwind_Context)\n+                              -> uw::_Unwind_Reason_Code;\n     }\n }\n \n@@ -287,7 +292,7 @@ unsafe extern \"C\" fn rust_eh_unwind_resume(panic_ctx: *mut u8) -> ! {\n // to actively register their unwind info sections via unwinder API.\n //\n // This module defines two symbols which are referenced and called from\n-// rsbegin.rs to reigster our information with the GCC runtime. The\n+// rsbegin.rs to register our information with the GCC runtime. The\n // implementation of stack unwinding is (for now) deferred to libgcc_eh, however\n // Rust crates use these Rust-specific entry points to avoid potential clashes\n // with any GCC runtime."}, {"sha": "ff483fa823e0cc0c86d7b224474b0ad5ae7266d7", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -68,10 +68,16 @@ mod imp;\n mod imp;\n \n // i686-pc-windows-gnu and all others\n-#[cfg(any(unix, all(windows, target_arch = \"x86\", target_env = \"gnu\")))]\n+#[cfg(any(all(unix, not(target_os = \"emscripten\")),\n+          all(windows, target_arch = \"x86\", target_env = \"gnu\")))]\n #[path = \"gcc.rs\"]\n mod imp;\n \n+// emscripten\n+#[cfg(target_os = \"emscripten\")]\n+#[path = \"emcc.rs\"]\n+mod imp;\n+\n mod dwarf;\n mod windows;\n "}, {"sha": "d4906b556b31a5be0fd2e9922dd7c9ade6629f0e", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -129,7 +129,8 @@ unsafe fn find_landing_pad(dc: &c::DISPATCHER_CONTEXT) -> Option<usize> {\n     };\n     match find_eh_action(dc.HandlerData, &eh_ctx) {\n         EHAction::None => None,\n-        EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => Some(lpad),\n+        EHAction::Cleanup(lpad) |\n+        EHAction::Catch(lpad) => Some(lpad),\n         EHAction::Terminate => intrinsics::abort(),\n     }\n }"}, {"sha": "7ce65d0fe4dbcb98a66143d5790ca009abde5768", "filename": "src/libproc_macro/Cargo.toml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2FCargo.toml?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -4,12 +4,8 @@ name = \"proc_macro\"\n version = \"0.0.0\"\n \n [lib]\n-name = \"proc_macro\"\n path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-log = { path = \"../liblog\" }\n-rustc_plugin = { path = \"../librustc_plugin\" }\n syntax = { path = \"../libsyntax\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "1d2c64d6d938aa815b6afc0fa6e03fd6e7ca4dd4", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 138, "deletions": 110, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -8,130 +8,158 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! # Proc_Macro\n+//! A support library for macro authors when defining new macros.\n //!\n-//! A library for procedural macro writers.\n+//! This library, provided by the standard distribution, provides the types\n+//! consumed in the interfaces of procedurally defined macro definitions.\n+//! Currently the primary use of this crate is to provide the ability to define\n+//! new custom derive modes through `#[proc_macro_derive]`.\n //!\n-//! ## Usage\n-//! This package provides the `qquote!` macro for syntax creation, and the prelude\n-//! (at libproc_macro::prelude) provides a number of operations:\n-//! - `concat`, for concatenating two TokenStreams.\n-//! - `ident_eq`, for checking if two identifiers are equal regardless of syntax context.\n-//! - `str_to_token_ident`, for converting an `&str` into a Token.\n-//! - `keyword_to_token_delim`, for converting a `parse::token::keywords::Keyword` into a\n-//!    Token.\n-//! - `build_delimited`, for creating a new TokenStream from an existing one and a delimiter\n-//!    by wrapping the TokenStream in the delimiter.\n-//! - `build_bracket_delimited`, `build_brace_delimited`, and `build_paren_delimited`, for\n-//!    easing the above.\n-//! - `build_empty_args`, which returns a TokenStream containing `()`.\n-//! - `lex`, which takes an `&str` and returns the TokenStream it represents.\n+//! Added recently as part of [RFC 1681] this crate is currently *unstable* and\n+//! requires the `#![feature(proc_macro_lib)]` directive to use.\n //!\n-//! The `qquote!` macro also imports `syntax::ext::proc_macro_shim::prelude::*`, so you\n-//! will need to `extern crate syntax` for usage. (This is a temporary solution until more\n-//! of the external API in libproc_macro is stabilized to support the token construction\n-//! operations that the qausiquoter relies on.) The shim file also provides additional\n-//! operations, such as `build_block_emitter` (as used in the `cond` example below).\n-//!\n-//! ## TokenStreams\n-//!\n-//! TokenStreams serve as the basis of the macro system. They are, in essence, vectors of\n-//! TokenTrees, where indexing treats delimited values as a single term. That is, the term\n-//! `even(a+c) && even(b)` will be indexibly encoded as `even | (a+c) | even | (b)` where,\n-//! in reality, `(a+c)` is actually a decorated pointer to `a | + | c`.\n-//!\n-//! If a user has a TokenStream that is a single, delimited value, they can use\n-//! `maybe_delimited` to destruct it and receive the internal vector as a new TokenStream\n-//! as:\n-//! ```\n-//! `(a+c)`.maybe_delimited() ~> Some(a | + | c)`\n-//! ```\n-//!\n-//! Check the TokenStream documentation for more information; the structure also provides\n-//! cheap concatenation and slicing.\n-//!\n-//! ## Quasiquotation\n-//!\n-//! The quasiquoter creates output that, when run, constructs the tokenstream specified as\n-//! input. For example, `qquote!(5 + 5)` will produce a program, that, when run, will\n-//! construct the TokenStream `5 | + | 5`.\n-//!\n-//! ### Unquoting\n-//!\n-//! Unquoting is currently done as `unquote`, and works by taking the single next\n-//! TokenTree in the TokenStream as the unquoted term. Ergonomically, `unquote(foo)` works\n-//! fine, but `unquote foo` is also supported.\n-//!\n-//! A simple example might be:\n-//!\n-//!```\n-//!fn double(tmp: TokenStream) -> TokenStream {\n-//!    qquote!(unquote(tmp) * 2)\n-//!}\n-//!```\n-//!\n-//! ### Large Example: Implementing Scheme's `cond`\n-//!\n-//! Below is the full implementation of Scheme's `cond` operator.\n-//!\n-//! ```\n-//! fn cond_rec(input: TokenStream) -> TokenStream {\n-//!   if input.is_empty() { return quote!(); }\n-//!\n-//!   let next = input.slice(0..1);\n-//!   let rest = input.slice_from(1..);\n-//!\n-//!   let clause : TokenStream = match next.maybe_delimited() {\n-//!     Some(ts) => ts,\n-//!     _ => panic!(\"Invalid input\"),\n-//!   };\n-//!\n-//!   // clause is ([test]) [rhs]\n-//!   if clause.len() < 2 { panic!(\"Invalid macro usage in cond: {:?}\", clause) }\n-//!\n-//!   let test: TokenStream = clause.slice(0..1);\n-//!   let rhs: TokenStream = clause.slice_from(1..);\n-//!\n-//!   if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n-//!     quote!({unquote(rhs)})\n-//!   } else {\n-//!     quote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })\n-//!   }\n-//! }\n-//! ```\n+//! [RFC 1681]: https://github.com/rust-lang/rfcs/blob/master/text/1681-macros-1.1.md\n //!\n+//! Note that this crate is intentionally very bare-bones currently. The main\n+//! type, `TokenStream`, only supports `fmt::Display` and `FromStr`\n+//! implementations, indicating that it can only go to and come from a string.\n+//! This functionality is intended to be expanded over time as more surface\n+//! area for macro authors is stabilized.\n \n #![crate_name = \"proc_macro\"]\n-#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n-#![feature(plugin_registrar)]\n-#![crate_type = \"dylib\"]\n+#![unstable(feature = \"proc_macro_lib\", issue = \"27812\")]\n #![crate_type = \"rlib\"]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![crate_type = \"dylib\"]\n #![cfg_attr(not(stage0), deny(warnings))]\n+#![deny(missing_docs)]\n \n-#![feature(staged_api)]\n-#![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n+#![feature(staged_api)]\n+#![feature(lang_items)]\n \n-extern crate rustc_plugin;\n extern crate syntax;\n-extern crate syntax_pos;\n-#[macro_use] extern crate log;\n \n-mod qquote;\n-pub mod build;\n-pub mod parse;\n-pub mod prelude;\n-use qquote::qquote;\n+use std::fmt;\n+use std::str::FromStr;\n+\n+use syntax::ast;\n+use syntax::parse;\n+use syntax::ptr::P;\n+\n+/// The main type provided by this crate, representing an abstract stream of\n+/// tokens.\n+///\n+/// This is both the input and output of `#[proc_macro_derive]` definitions.\n+/// Currently it's required to be a list of valid Rust items, but this\n+/// restriction may be lifted in the future.\n+///\n+/// The API of this type is intentionally bare-bones, but it'll be expanded over\n+/// time!\n+pub struct TokenStream {\n+    inner: Vec<P<ast::Item>>,\n+}\n+\n+/// Error returned from `TokenStream::from_str`.\n+#[derive(Debug)]\n+pub struct LexError {\n+    _inner: (),\n+}\n+\n+/// Permanently unstable internal implementation details of this crate. This\n+/// should not be used.\n+///\n+/// These methods are used by the rest of the compiler to generate instances of\n+/// `TokenStream` to hand to macro definitions, as well as consume the output.\n+///\n+/// Note that this module is also intentionally separate from the rest of the\n+/// crate. This allows the `#[unstable]` directive below to naturally apply to\n+/// all of the contents.\n+#[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n+#[doc(hidden)]\n+pub mod __internal {\n+    use std::cell::Cell;\n+\n+    use syntax::ast;\n+    use syntax::ptr::P;\n+    use syntax::parse::ParseSess;\n+    use super::TokenStream;\n+\n+    pub fn new_token_stream(item: P<ast::Item>) -> TokenStream {\n+        TokenStream { inner: vec![item] }\n+    }\n \n-use rustc_plugin::Registry;\n+    pub fn token_stream_items(stream: TokenStream) -> Vec<P<ast::Item>> {\n+        stream.inner\n+    }\n \n-// ____________________________________________________________________________________________\n-// Main macro definition\n+    pub trait Registry {\n+        fn register_custom_derive(&mut self,\n+                                  trait_name: &str,\n+                                  expand: fn(TokenStream) -> TokenStream);\n+    }\n+\n+    // Emulate scoped_thread_local!() here essentially\n+    thread_local! {\n+        static CURRENT_SESS: Cell<*const ParseSess> = Cell::new(0 as *const _);\n+    }\n+\n+    pub fn set_parse_sess<F, R>(sess: &ParseSess, f: F) -> R\n+        where F: FnOnce() -> R\n+    {\n+        struct Reset { prev: *const ParseSess }\n+\n+        impl Drop for Reset {\n+            fn drop(&mut self) {\n+                CURRENT_SESS.with(|p| p.set(self.prev));\n+            }\n+        }\n+\n+        CURRENT_SESS.with(|p| {\n+            let _reset = Reset { prev: p.get() };\n+            p.set(sess);\n+            f()\n+        })\n+    }\n+\n+    pub fn with_parse_sess<F, R>(f: F) -> R\n+        where F: FnOnce(&ParseSess) -> R\n+    {\n+        let p = CURRENT_SESS.with(|p| p.get());\n+        assert!(!p.is_null());\n+        f(unsafe { &*p })\n+    }\n+}\n+\n+impl FromStr for TokenStream {\n+    type Err = LexError;\n+\n+    fn from_str(src: &str) -> Result<TokenStream, LexError> {\n+        __internal::with_parse_sess(|sess| {\n+            let src = src.to_string();\n+            let name = \"<proc-macro source code>\".to_string();\n+            let mut parser = parse::new_parser_from_source_str(sess, name, src);\n+            let mut ret = TokenStream { inner: Vec::new() };\n+            loop {\n+                match parser.parse_item() {\n+                    Ok(Some(item)) => ret.inner.push(item),\n+                    Ok(None) => return Ok(ret),\n+                    Err(mut err) => {\n+                        err.cancel();\n+                        return Err(LexError { _inner: () })\n+                    }\n+                }\n+            }\n+        })\n+    }\n+}\n \n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"qquote\", qquote);\n+impl fmt::Display for TokenStream {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for item in self.inner.iter() {\n+            let item = syntax::print::pprust::item_to_string(item);\n+            try!(f.write_str(&item));\n+            try!(f.write_str(\"\\n\"));\n+        }\n+        Ok(())\n+    }\n }"}, {"sha": "4bc3f488d32808fd7743c57b23157abf6a07c4ce", "filename": "src/libproc_macro_plugin/Cargo.toml", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_plugin%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_plugin%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2FCargo.toml?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -0,0 +1,15 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"proc_macro_plugin\"\n+version = \"0.0.0\"\n+\n+[lib]\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+rustc_plugin = { path = \"../librustc_plugin\" }\n+syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+proc_macro_tokens = { path = \"../libproc_macro_tokens\" }"}, {"sha": "c45762bfb6e71525a9a1605152fbfd902c1399dc", "filename": "src/libproc_macro_plugin/lib.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -0,0 +1,107 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! # Proc_Macro\n+//!\n+//! A library for procedural macro writers.\n+//!\n+//! ## Usage\n+//! This crate provides the `qquote!` macro for syntax creation.\n+//!\n+//! The `qquote!` macro imports `syntax::ext::proc_macro_shim::prelude::*`, so you\n+//! will need to `extern crate syntax` for usage. (This is a temporary solution until more\n+//! of the external API in libproc_macro_tokens is stabilized to support the token construction\n+//! operations that the qausiquoter relies on.) The shim file also provides additional\n+//! operations, such as `build_block_emitter` (as used in the `cond` example below).\n+//!\n+//! ## Quasiquotation\n+//!\n+//! The quasiquoter creates output that, when run, constructs the tokenstream specified as\n+//! input. For example, `qquote!(5 + 5)` will produce a program, that, when run, will\n+//! construct the TokenStream `5 | + | 5`.\n+//!\n+//! ### Unquoting\n+//!\n+//! Unquoting is currently done as `unquote`, and works by taking the single next\n+//! TokenTree in the TokenStream as the unquoted term. Ergonomically, `unquote(foo)` works\n+//! fine, but `unquote foo` is also supported.\n+//!\n+//! A simple example might be:\n+//!\n+//!```\n+//!fn double(tmp: TokenStream) -> TokenStream {\n+//!    qquote!(unquote(tmp) * 2)\n+//!}\n+//!```\n+//!\n+//! ### Large Example: Implementing Scheme's `cond`\n+//!\n+//! Below is the full implementation of Scheme's `cond` operator.\n+//!\n+//! ```\n+//! fn cond_rec(input: TokenStream) -> TokenStream {\n+//!   if input.is_empty() { return quote!(); }\n+//!\n+//!   let next = input.slice(0..1);\n+//!   let rest = input.slice_from(1..);\n+//!\n+//!   let clause : TokenStream = match next.maybe_delimited() {\n+//!     Some(ts) => ts,\n+//!     _ => panic!(\"Invalid input\"),\n+//!   };\n+//!\n+//!   // clause is ([test]) [rhs]\n+//!   if clause.len() < 2 { panic!(\"Invalid macro usage in cond: {:?}\", clause) }\n+//!\n+//!   let test: TokenStream = clause.slice(0..1);\n+//!   let rhs: TokenStream = clause.slice_from(1..);\n+//!\n+//!   if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n+//!     quote!({unquote(rhs)})\n+//!   } else {\n+//!     quote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })\n+//!   }\n+//! }\n+//! ```\n+//!\n+\n+#![crate_name = \"proc_macro_plugin\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![feature(plugin_registrar)]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![cfg_attr(not(stage0), deny(warnings))]\n+\n+#![feature(staged_api)]\n+#![feature(rustc_diagnostic_macros)]\n+#![feature(rustc_private)]\n+\n+extern crate rustc_plugin;\n+extern crate syntax;\n+extern crate syntax_pos;\n+extern crate proc_macro_tokens;\n+#[macro_use] extern crate log;\n+\n+mod qquote;\n+\n+use qquote::qquote;\n+\n+use rustc_plugin::Registry;\n+\n+// ____________________________________________________________________________________________\n+// Main macro definition\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_macro(\"qquote\", qquote);\n+}"}, {"sha": "e5a3abc2ea982e01a8e06bd95d0905790c086ec3", "filename": "src/libproc_macro_plugin/qquote.rs", "status": "renamed", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_plugin%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_plugin%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Fqquote.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -24,12 +24,9 @@\n //! TokenStream that resembles the output syntax.\n //!\n \n-extern crate rustc_plugin;\n-extern crate syntax;\n-extern crate syntax_pos;\n+use proc_macro_tokens::build::*;\n+use proc_macro_tokens::parse::lex;\n \n-use build::*;\n-use parse::lex;\n use qquote::int_build::*;\n \n use syntax::ast::Ident;\n@@ -51,7 +48,7 @@ pub fn qquote<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n     let output = qquoter(cx, TokenStream::from_tts(tts.clone().to_owned()));\n     debug!(\"\\nQQ out: {}\\n\", pprust::tts_to_string(&output.to_tts()[..]));\n     let imports = concat(lex(\"use syntax::ext::proc_macro_shim::prelude::*;\"),\n-                         lex(\"use proc_macro::prelude::*;\"));\n+                         lex(\"use proc_macro_tokens::prelude::*;\"));\n     build_block_emitter(cx, sp, build_brace_delimited(concat(imports, output)))\n }\n \n@@ -219,7 +216,7 @@ fn convert_complex_tts<'cx>(cx: &'cx mut ExtCtxt, tts: Vec<QTT>) -> (Bindings, T\n \n                 let sep = build_delim_tok(qdl.delim);\n \n-                pushes.push(build_mod_call(vec![str_to_ident(\"proc_macro\"),\n+                pushes.push(build_mod_call(vec![str_to_ident(\"proc_macro_tokens\"),\n                                                str_to_ident(\"build\"),\n                                                str_to_ident(\"build_delimited\")],\n                                           concat(from_tokens(vec![Token::Ident(new_id)]),\n@@ -264,11 +261,8 @@ fn is_qquote(id: Ident) -> bool {\n }\n \n mod int_build {\n-    extern crate syntax;\n-    extern crate syntax_pos;\n-\n-    use parse::*;\n-    use build::*;\n+    use proc_macro_tokens::build::*;\n+    use proc_macro_tokens::parse::*;\n \n     use syntax::ast::{self, Ident};\n     use syntax::codemap::{DUMMY_SP};", "previous_filename": "src/libproc_macro/qquote.rs"}, {"sha": "2b66d56759f35b220debeab20ea604f5f51f07bb", "filename": "src/libproc_macro_tokens/Cargo.toml", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_tokens%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_tokens%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2FCargo.toml?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -1,12 +1,13 @@\n [package]\n authors = [\"The Rust Project Developers\"]\n-name = \"rustc_macro\"\n+name = \"proc_macro_tokens\"\n version = \"0.0.0\"\n \n [lib]\n-name = \"rustc_macro\"\n path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n syntax = { path = \"../libsyntax\" }\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+log = { path = \"../liblog\" }", "previous_filename": "src/librustc_macro/Cargo.toml"}, {"sha": "7b7590b863b71aa5e5eba1e63d13a5f707dea352", "filename": "src/libproc_macro_tokens/build.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_tokens%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_tokens%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Fbuild.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "previous_filename": "src/libproc_macro/build.rs"}, {"sha": "3bfa2fbb29fbdab24e1493859a35a66d4ec7dd86", "filename": "src/libproc_macro_tokens/lib.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_tokens%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_tokens%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! # Proc_Macro\n+//!\n+//! A library for procedural macro writers.\n+//!\n+//! ## Usage\n+//! This crate provides the prelude (at libproc_macro_tokens::prelude), which\n+//! provides a number of operations:\n+//! - `concat`, for concatenating two TokenStreams.\n+//! - `ident_eq`, for checking if two identifiers are equal regardless of syntax context.\n+//! - `str_to_token_ident`, for converting an `&str` into a Token.\n+//! - `keyword_to_token_delim`, for converting a `parse::token::keywords::Keyword` into a\n+//!    Token.\n+//! - `build_delimited`, for creating a new TokenStream from an existing one and a delimiter\n+//!    by wrapping the TokenStream in the delimiter.\n+//! - `build_bracket_delimited`, `build_brace_delimited`, and `build_paren_delimited`, for\n+//!    easing the above.\n+//! - `build_empty_args`, which returns a TokenStream containing `()`.\n+//! - `lex`, which takes an `&str` and returns the TokenStream it represents.\n+//!\n+//! ## TokenStreams\n+//!\n+//! TokenStreams serve as the basis of the macro system. They are, in essence, vectors of\n+//! TokenTrees, where indexing treats delimited values as a single term. That is, the term\n+//! `even(a+c) && even(b)` will be indexibly encoded as `even | (a+c) | even | (b)` where,\n+//! in reality, `(a+c)` is actually a decorated pointer to `a | + | c`.\n+//!\n+//! If a user has a TokenStream that is a single, delimited value, they can use\n+//! `maybe_delimited` to destruct it and receive the internal vector as a new TokenStream\n+//! as:\n+//! ```\n+//! `(a+c)`.maybe_delimited() ~> Some(a | + | c)`\n+//! ```\n+//!\n+//! Check the TokenStream documentation for more information; the structure also provides\n+//! cheap concatenation and slicing.\n+//!\n+\n+#![crate_name = \"proc_macro_tokens\"]\n+#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n+#![crate_type = \"dylib\"]\n+#![crate_type = \"rlib\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![cfg_attr(not(stage0), deny(warnings))]\n+\n+#![feature(staged_api)]\n+#![feature(rustc_private)]\n+\n+extern crate syntax;\n+extern crate syntax_pos;\n+#[macro_use] extern crate log;\n+\n+pub mod build;\n+pub mod parse;\n+pub mod prelude;"}, {"sha": "9af8a68cdcf497887b75e09a94f5917215d33bee", "filename": "src/libproc_macro_tokens/parse.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_tokens%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_tokens%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Fparse.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "previous_filename": "src/libproc_macro/parse.rs"}, {"sha": "4c0c8ba6c6684b1c375236a4e13fefa2a5cbcfab", "filename": "src/libproc_macro_tokens/prelude.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_tokens%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibproc_macro_tokens%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Fprelude.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "previous_filename": "src/libproc_macro/prelude.rs"}, {"sha": "7dc0d19e6a615cd32e04e869ff89a978d1fa2df1", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -217,8 +217,8 @@ mod tests {\n         let mut ra: ChaChaRng = SeedableRng::from_seed(&*s);\n         let mut rb: ChaChaRng = SeedableRng::from_seed(&*s);\n         assert!(ra.gen_ascii_chars()\n-                  .take(100)\n-                  .eq(rb.gen_ascii_chars().take(100)));\n+            .take(100)\n+            .eq(rb.gen_ascii_chars().take(100)));\n     }\n \n     #[test]\n@@ -227,8 +227,8 @@ mod tests {\n         let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n         let mut rb: ChaChaRng = SeedableRng::from_seed(seed);\n         assert!(ra.gen_ascii_chars()\n-                  .take(100)\n-                  .eq(rb.gen_ascii_chars().take(100)));\n+            .take(100)\n+            .eq(rb.gen_ascii_chars().take(100)));\n     }\n \n     #[test]\n@@ -253,17 +253,17 @@ mod tests {\n \n         let v = (0..16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n-                   vec!(0xade0b876, 0x903df1a0, 0xe56a5d40, 0x28bd8653,\n+                   vec![0xade0b876, 0x903df1a0, 0xe56a5d40, 0x28bd8653,\n                         0xb819d2bd, 0x1aed8da0, 0xccef36a8, 0xc70d778b,\n                         0x7c5941da, 0x8d485751, 0x3fe02477, 0x374ad8b8,\n-                        0xf4b8436a, 0x1ca11815, 0x69b687c3, 0x8665eeb2));\n+                        0xf4b8436a, 0x1ca11815, 0x69b687c3, 0x8665eeb2]);\n \n         let v = (0..16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n-                   vec!(0xbee7079f, 0x7a385155, 0x7c97ba98, 0x0d082d73,\n+                   vec![0xbee7079f, 0x7a385155, 0x7c97ba98, 0x0d082d73,\n                         0xa0290fcb, 0x6965e348, 0x3e53c612, 0xed7aee32,\n                         0x7621b729, 0x434ee69c, 0xb03371d5, 0xd539d874,\n-                        0x281fed31, 0x45fb0a51, 0x1f0ae1ac, 0x6f4d794b));\n+                        0x281fed31, 0x45fb0a51, 0x1f0ae1ac, 0x6f4d794b]);\n \n \n         let seed: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n@@ -280,10 +280,10 @@ mod tests {\n         }\n \n         assert_eq!(v,\n-                   vec!(0xf225c81a, 0x6ab1be57, 0x04d42951, 0x70858036,\n+                   vec![0xf225c81a, 0x6ab1be57, 0x04d42951, 0x70858036,\n                         0x49884684, 0x64efec72, 0x4be2d186, 0x3615b384,\n                         0x11cfa18e, 0xd3c50049, 0x75c775f6, 0x434c6530,\n-                        0x2c5bad8f, 0x898881dc, 0x5f1c86d9, 0xc1f8e7f4));\n+                        0x2c5bad8f, 0x898881dc, 0x5f1c86d9, 0xc1f8e7f4]);\n     }\n \n     #[test]"}, {"sha": "41175c81df8918bbd5302e8f816296ab150a01f9", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -237,18 +237,10 @@ fn ziggurat<R: Rng, P, Z>(rng: &mut R,\n \n         // u is either U(-1, 1) or U(0, 1) depending on if this is a\n         // symmetric distribution or not.\n-        let u = if symmetric {\n-            2.0 * f - 1.0\n-        } else {\n-            f\n-        };\n+        let u = if symmetric { 2.0 * f - 1.0 } else { f };\n         let x = u * x_tab[i];\n \n-        let test_x = if symmetric {\n-            x.abs()\n-        } else {\n-            x\n-        };\n+        let test_x = if symmetric { x.abs() } else { x };\n \n         // algebraically equivalent to |u| < x_tab[i+1]/x_tab[i] (or u < x_tab[i+1]/x_tab[i])\n         if test_x < x_tab[i + 1] {\n@@ -320,37 +312,37 @@ mod tests {\n             }}\n         }\n \n-        t!(vec!(Weighted { weight: 1, item: 10 }),\n+        t!(vec![Weighted { weight: 1, item: 10 }],\n            [10]);\n \n         // skip some\n-        t!(vec!(Weighted { weight: 0, item: 20 },\n+        t!(vec![Weighted { weight: 0, item: 20 },\n                 Weighted { weight: 2, item: 21 },\n                 Weighted { weight: 0, item: 22 },\n-                Weighted { weight: 1, item: 23 }),\n+                Weighted { weight: 1, item: 23 }],\n            [21, 21, 23]);\n \n         // different weights\n-        t!(vec!(Weighted { weight: 4, item: 30 },\n-                Weighted { weight: 3, item: 31 }),\n+        t!(vec![Weighted { weight: 4, item: 30 },\n+                Weighted { weight: 3, item: 31 }],\n            [30, 30, 30, 30, 31, 31, 31]);\n \n         // check that we're binary searching\n         // correctly with some vectors of odd\n         // length.\n-        t!(vec!(Weighted { weight: 1, item: 40 },\n+        t!(vec![Weighted { weight: 1, item: 40 },\n                 Weighted { weight: 1, item: 41 },\n                 Weighted { weight: 1, item: 42 },\n                 Weighted { weight: 1, item: 43 },\n-                Weighted { weight: 1, item: 44 }),\n+                Weighted { weight: 1, item: 44 }],\n            [40, 41, 42, 43, 44]);\n-        t!(vec!(Weighted { weight: 1, item: 50 },\n+        t!(vec![Weighted { weight: 1, item: 50 },\n                 Weighted { weight: 1, item: 51 },\n                 Weighted { weight: 1, item: 52 },\n                 Weighted { weight: 1, item: 53 },\n                 Weighted { weight: 1, item: 54 },\n                 Weighted { weight: 1, item: 55 },\n-                Weighted { weight: 1, item: 56 }),\n+                Weighted { weight: 1, item: 56 }],\n            [50, 51, 52, 53, 54, 55, 56]);\n     }\n "}, {"sha": "69d5015f18140153a339df182a1789f66ada22c8", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -599,17 +599,17 @@ mod tests {\n         let mut ra: IsaacRng = SeedableRng::from_seed(&s[..]);\n         let mut rb: IsaacRng = SeedableRng::from_seed(&s[..]);\n         assert!(ra.gen_ascii_chars()\n-                  .take(100)\n-                  .eq(rb.gen_ascii_chars().take(100)));\n+            .take(100)\n+            .eq(rb.gen_ascii_chars().take(100)));\n     }\n     #[test]\n     fn test_rng_64_rand_seeded() {\n         let s = ::test::rng().gen_iter::<u64>().take(256).collect::<Vec<u64>>();\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(&s[..]);\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(&s[..]);\n         assert!(ra.gen_ascii_chars()\n-                  .take(100)\n-                  .eq(rb.gen_ascii_chars().take(100)));\n+            .take(100)\n+            .eq(rb.gen_ascii_chars().take(100)));\n     }\n \n     #[test]\n@@ -618,17 +618,17 @@ mod tests {\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         assert!(ra.gen_ascii_chars()\n-                  .take(100)\n-                  .eq(rb.gen_ascii_chars().take(100)));\n+            .take(100)\n+            .eq(rb.gen_ascii_chars().take(100)));\n     }\n     #[test]\n     fn test_rng_64_seeded() {\n         let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         assert!(ra.gen_ascii_chars()\n-                  .take(100)\n-                  .eq(rb.gen_ascii_chars().take(100)));\n+            .take(100)\n+            .eq(rb.gen_ascii_chars().take(100)));\n     }\n \n     #[test]\n@@ -662,8 +662,8 @@ mod tests {\n         // Regression test that isaac is actually using the above vector\n         let v = (0..10).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n-                   vec!(2558573138, 873787463, 263499565, 2103644246, 3595684709,\n-                        4203127393, 264982119, 2765226902, 2737944514, 3900253796));\n+                   vec![2558573138, 873787463, 263499565, 2103644246, 3595684709,\n+                        4203127393, 264982119, 2765226902, 2737944514, 3900253796]);\n \n         let seed: &[_] = &[12345, 67890, 54321, 9876];\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n@@ -674,8 +674,8 @@ mod tests {\n \n         let v = (0..10).map(|_| rb.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n-                   vec!(3676831399, 3183332890, 2834741178, 3854698763, 2717568474,\n-                        1576568959, 3507990155, 179069555, 141456972, 2478885421));\n+                   vec![3676831399, 3183332890, 2834741178, 3854698763, 2717568474,\n+                        1576568959, 3507990155, 179069555, 141456972, 2478885421]);\n     }\n     #[test]\n     #[rustfmt_skip]\n@@ -685,10 +685,10 @@ mod tests {\n         // Regression test that isaac is actually using the above vector\n         let v = (0..10).map(|_| ra.next_u64()).collect::<Vec<_>>();\n         assert_eq!(v,\n-                   vec!(547121783600835980, 14377643087320773276, 17351601304698403469,\n+                   vec![547121783600835980, 14377643087320773276, 17351601304698403469,\n                         1238879483818134882, 11952566807690396487, 13970131091560099343,\n                         4469761996653280935, 15552757044682284409, 6860251611068737823,\n-                        13722198873481261842));\n+                        13722198873481261842]);\n \n         let seed: &[_] = &[12345, 67890, 54321, 9876];\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n@@ -699,10 +699,10 @@ mod tests {\n \n         let v = (0..10).map(|_| rb.next_u64()).collect::<Vec<_>>();\n         assert_eq!(v,\n-                   vec!(18143823860592706164, 8491801882678285927, 2699425367717515619,\n+                   vec![18143823860592706164, 8491801882678285927, 2699425367717515619,\n                         17196852593171130876, 2606123525235546165, 15790932315217671084,\n                         596345674630742204, 9947027391921273664, 11788097613744130851,\n-                        10391409374914919106));\n+                        10391409374914919106]);\n \n     }\n "}, {"sha": "b0d824da3ab4795a45b39b449300eed1c3a5f1ae", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -203,10 +203,6 @@ tuple_impl!{A, B, C, D, E, F, G, H, I, J, K, L}\n impl<T: Rand> Rand for Option<T> {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> Option<T> {\n-        if rng.gen() {\n-            Some(rng.gen())\n-        } else {\n-            None\n-        }\n+        if rng.gen() { Some(rng.gen()) } else { None }\n     }\n }"}, {"sha": "b8a65842e2ff59388c52a938edd22372ca62a117", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -138,7 +138,7 @@ mod tests {\n         }\n     }\n     impl Default for Counter {\n-    /// Constructs a `Counter` with initial value zero.\n+        /// Constructs a `Counter` with initial value zero.\n         fn default() -> Counter {\n             Counter { i: 0 }\n         }\n@@ -169,8 +169,8 @@ mod tests {\n         let mut ra: MyRng = SeedableRng::from_seed((ReseedWithDefault, 2));\n         let mut rb: MyRng = SeedableRng::from_seed((ReseedWithDefault, 2));\n         assert!(ra.gen_ascii_chars()\n-                  .take(100)\n-                  .eq(rb.gen_ascii_chars().take(100)));\n+            .take(100)\n+            .eq(rb.gen_ascii_chars().take(100)));\n     }\n \n     #[test]"}, {"sha": "ab89ac2b7a1eb6a1c5f66cccd696d9ca3a863c1d", "filename": "src/librbml/Cargo.toml", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4e2822c5c28bb342e5862ba7cc0b90b865c68be1/src%2Flibrbml%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4e2822c5c28bb342e5862ba7cc0b90b865c68be1/src%2Flibrbml%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2FCargo.toml?ref=4e2822c5c28bb342e5862ba7cc0b90b865c68be1", "patch": "@@ -1,13 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rbml\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"rbml\"\n-path = \"lib.rs\"\n-crate-type = [\"dylib\"]\n-\n-[dependencies]\n-log = { path = \"../liblog\" }\n-serialize = { path = \"../libserialize\" }"}, {"sha": "5a8a52f7dfc6e15d9b5bc215395f620ae75e1747", "filename": "src/librbml/lib.rs", "status": "removed", "additions": 0, "deletions": 1609, "changes": 1609, "blob_url": "https://github.com/rust-lang/rust/blob/4e2822c5c28bb342e5862ba7cc0b90b865c68be1/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2822c5c28bb342e5862ba7cc0b90b865c68be1/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=4e2822c5c28bb342e5862ba7cc0b90b865c68be1", "patch": "@@ -1,1609 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Really Bad Markup Language (rbml) is an internal serialization format of rustc.\n-//! This is not intended to be used by users.\n-//!\n-//! Originally based on the Extensible Binary Markup Language\n-//! (ebml; http://www.matroska.org/technical/specs/rfc/index.html),\n-//! it is now a separate format tuned for the rust object metadata.\n-//!\n-//! # Encoding\n-//!\n-//! RBML document consists of the tag, length and data.\n-//! The encoded data can contain multiple RBML documents concatenated.\n-//!\n-//! **Tags** are a hint for the following data.\n-//! Tags are a number from 0x000 to 0xfff, where 0xf0 through 0xff is reserved.\n-//! Tags less than 0xf0 are encoded in one literal byte.\n-//! Tags greater than 0xff are encoded in two big-endian bytes,\n-//! where the tag number is ORed with 0xf000. (E.g. tag 0x123 = `f1 23`)\n-//!\n-//! **Lengths** encode the length of the following data.\n-//! It is a variable-length unsigned isize, and one of the following forms:\n-//!\n-//! - `80` through `fe` for lengths up to 0x7e;\n-//! - `40 ff` through `7f ff` for lengths up to 0x3fff;\n-//! - `20 40 00` through `3f ff ff` for lengths up to 0x1fffff;\n-//! - `10 20 00 00` through `1f ff ff ff` for lengths up to 0xfffffff.\n-//!\n-//! The \"overlong\" form is allowed so that the length can be encoded\n-//! without the prior knowledge of the encoded data.\n-//! For example, the length 0 can be represented either by `80`, `40 00`,\n-//! `20 00 00` or `10 00 00 00`.\n-//! The encoder tries to minimize the length if possible.\n-//! Also, some predefined tags listed below are so commonly used that\n-//! their lengths are omitted (\"implicit length\").\n-//!\n-//! **Data** can be either binary bytes or zero or more nested RBML documents.\n-//! Nested documents cannot overflow, and should be entirely contained\n-//! within a parent document.\n-//!\n-//! # Predefined Tags\n-//!\n-//! Most RBML tags are defined by the application.\n-//! (For the rust object metadata, see also `rustc::metadata::common`.)\n-//! RBML itself does define a set of predefined tags however,\n-//! intended for the auto-serialization implementation.\n-//!\n-//! Predefined tags with an implicit length:\n-//!\n-//! - `U8`  (`00`): 1-byte unsigned integer.\n-//! - `U16` (`01`): 2-byte big endian unsigned integer.\n-//! - `U32` (`02`): 4-byte big endian unsigned integer.\n-//! - `U64` (`03`): 8-byte big endian unsigned integer.\n-//!   Any of `U*` tags can be used to encode primitive unsigned integer types,\n-//!   as long as it is no greater than the actual size.\n-//!   For example, `u8` can only be represented via the `U8` tag.\n-//!\n-//! - `I8`  (`04`): 1-byte signed integer.\n-//! - `I16` (`05`): 2-byte big endian signed integer.\n-//! - `I32` (`06`): 4-byte big endian signed integer.\n-//! - `I64` (`07`): 8-byte big endian signed integer.\n-//!   Similar to `U*` tags. Always uses two's complement encoding.\n-//!\n-//! - `Bool` (`08`): 1-byte boolean value, `00` for false and `01` for true.\n-//!\n-//! - `Char` (`09`): 4-byte big endian Unicode scalar value.\n-//!   Surrogate pairs or out-of-bound values are invalid.\n-//!\n-//! - `F32` (`0a`): 4-byte big endian unsigned integer representing\n-//!   IEEE 754 binary32 floating-point format.\n-//! - `F64` (`0b`): 8-byte big endian unsigned integer representing\n-//!   IEEE 754 binary64 floating-point format.\n-//!\n-//! - `Sub8`  (`0c`): 1-byte unsigned integer for supplementary information.\n-//! - `Sub32` (`0d`): 4-byte unsigned integer for supplementary information.\n-//!   Those two tags normally occur as the first subdocument of certain tags,\n-//!   namely `Enum`, `Vec` and `Map`, to provide a variant or size information.\n-//!   They can be used interchangeably.\n-//!\n-//! Predefined tags with an explicit length:\n-//!\n-//! - `Str` (`10`): A UTF-8-encoded string.\n-//!\n-//! - `Enum` (`11`): An enum.\n-//!   The first subdocument should be `Sub*` tags with a variant ID.\n-//!   Subsequent subdocuments, if any, encode variant arguments.\n-//!\n-//! - `Vec` (`12`): A vector (sequence).\n-//! - `VecElt` (`13`): A vector element.\n-//!   The first subdocument should be `Sub*` tags with the number of elements.\n-//!   Subsequent subdocuments should be `VecElt` tag per each element.\n-//!\n-//! - `Map` (`14`): A map (associated array).\n-//! - `MapKey` (`15`): A key part of the map entry.\n-//! - `MapVal` (`16`): A value part of the map entry.\n-//!   The first subdocument should be `Sub*` tags with the number of entries.\n-//!   Subsequent subdocuments should be an alternating sequence of\n-//!   `MapKey` and `MapVal` tags per each entry.\n-//!\n-//! - `Opaque` (`17`): An opaque, custom-format tag.\n-//!   Used to wrap ordinary custom tags or data in the auto-serialized context.\n-//!   Rustc typically uses this to encode type information.\n-//!\n-//! First 0x20 tags are reserved by RBML; custom tags start at 0x20.\n-\n-#![crate_name = \"rbml\"]\n-#![unstable(feature = \"rustc_private\", issue = \"27812\")]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"https://play.rust-lang.org/\",\n-       test(attr(deny(warnings))))]\n-#![cfg_attr(not(stage0), deny(warnings))]\n-\n-#![feature(rustc_private)]\n-#![feature(staged_api)]\n-#![feature(question_mark)]\n-\n-#![cfg_attr(test, feature(test))]\n-\n-extern crate serialize;\n-\n-#[cfg(test)]\n-extern crate serialize as rustc_serialize; // Used by RustcEncodable\n-\n-#[macro_use]\n-extern crate log;\n-\n-#[cfg(test)]\n-extern crate test;\n-\n-pub mod opaque;\n-pub mod leb128;\n-\n-pub use self::EbmlEncoderTag::*;\n-pub use self::Error::*;\n-\n-use std::str;\n-use std::fmt;\n-\n-/// Common data structures\n-#[derive(Clone, Copy)]\n-pub struct Doc<'a> {\n-    pub data: &'a [u8],\n-    pub start: usize,\n-    pub end: usize,\n-}\n-\n-impl<'doc> Doc<'doc> {\n-    pub fn new(data: &'doc [u8]) -> Doc<'doc> {\n-        Doc {\n-            data: data,\n-            start: 0,\n-            end: data.len(),\n-        }\n-    }\n-\n-    pub fn get(&self, tag: usize) -> Doc<'doc> {\n-        reader::get_doc(*self, tag)\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.start == self.end\n-    }\n-\n-    pub fn as_str(&self) -> &'doc str {\n-        str::from_utf8(&self.data[self.start..self.end]).unwrap()\n-    }\n-\n-    pub fn to_string(&self) -> String {\n-        self.as_str().to_string()\n-    }\n-}\n-\n-pub struct TaggedDoc<'a> {\n-    tag: usize,\n-    pub doc: Doc<'a>,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum EbmlEncoderTag {\n-    // tags 00..1f are reserved for auto-serialization.\n-    // first NUM_IMPLICIT_TAGS tags are implicitly sized and lengths are not encoded.\n-    EsU8 = 0x00, // + 1 byte\n-    EsU16 = 0x01, // + 2 bytes\n-    EsU32 = 0x02, // + 4 bytes\n-    EsU64 = 0x03, // + 8 bytes\n-    EsI8 = 0x04, // + 1 byte\n-    EsI16 = 0x05, // + 2 bytes\n-    EsI32 = 0x06, // + 4 bytes\n-    EsI64 = 0x07, // + 8 bytes\n-    EsBool = 0x08, // + 1 byte\n-    EsChar = 0x09, // + 4 bytes\n-    EsF32 = 0x0a, // + 4 bytes\n-    EsF64 = 0x0b, // + 8 bytes\n-    EsSub8 = 0x0c, // + 1 byte\n-    EsSub32 = 0x0d, // + 4 bytes\n-    // 0x0e and 0x0f are reserved\n-    EsStr = 0x10,\n-    EsEnum = 0x11, // encodes the variant id as the first EsSub*\n-    EsVec = 0x12, // encodes the # of elements as the first EsSub*\n-    EsVecElt = 0x13,\n-    EsMap = 0x14, // encodes the # of pairs as the first EsSub*\n-    EsMapKey = 0x15,\n-    EsMapVal = 0x16,\n-    EsOpaque = 0x17,\n-}\n-\n-const NUM_TAGS: usize = 0x1000;\n-const NUM_IMPLICIT_TAGS: usize = 0x0e;\n-\n-#[cfg_attr(rustfmt, rustfmt_skip)]\n-static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n-    1, 2, 4, 8, // EsU*\n-    1, 2, 4, 8, // ESI*\n-    1, // EsBool\n-    4, // EsChar\n-    4, 8, // EsF*\n-    1, 4, // EsSub*\n-];\n-\n-#[derive(Debug)]\n-pub enum Error {\n-    IntTooBig(usize),\n-    InvalidTag(usize),\n-    Expected(String),\n-    IoError(std::io::Error),\n-    ApplicationError(String),\n-}\n-\n-impl fmt::Display for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // FIXME: this should be a more useful display form\n-        fmt::Debug::fmt(self, f)\n-    }\n-}\n-// --------------------------------------\n-\n-pub mod reader {\n-    use std::char;\n-\n-    use std::isize;\n-    use std::mem::transmute;\n-\n-    use serialize;\n-\n-    use super::opaque;\n-    use super::{ApplicationError, EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n-                EsU64, EsU32, EsU16, EsU8, EsI64, EsI32, EsI16, EsI8, EsBool, EsF64, EsF32,\n-                EsChar, EsStr, EsMapVal, EsOpaque, EbmlEncoderTag, Doc, TaggedDoc, Error,\n-                IntTooBig, InvalidTag, Expected, NUM_IMPLICIT_TAGS, TAG_IMPLICIT_LEN};\n-\n-    pub type DecodeResult<T> = Result<T, Error>;\n-    // rbml reading\n-\n-    macro_rules! try_or {\n-        ($e:expr, $r:expr) => (\n-            match $e {\n-                Ok(e) => e,\n-                Err(e) => {\n-                    debug!(\"ignored error: {:?}\", e);\n-                    return $r\n-                }\n-            }\n-        )\n-    }\n-\n-    #[derive(Copy, Clone)]\n-    pub struct Res {\n-        pub val: usize,\n-        pub next: usize,\n-    }\n-\n-    pub fn tag_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n-        let v = data[start] as usize;\n-        if v < 0xf0 {\n-            Ok(Res {\n-                val: v,\n-                next: start + 1,\n-            })\n-        } else if v > 0xf0 {\n-            Ok(Res {\n-                val: ((v & 0xf) << 8) | data[start + 1] as usize,\n-                next: start + 2,\n-            })\n-        } else {\n-            // every tag starting with byte 0xf0 is an overlong form, which is prohibited.\n-            Err(InvalidTag(v))\n-        }\n-    }\n-\n-    #[inline(never)]\n-    fn vuint_at_slow(data: &[u8], start: usize) -> DecodeResult<Res> {\n-        let a = data[start];\n-        if a & 0x80 != 0 {\n-            return Ok(Res {\n-                val: (a & 0x7f) as usize,\n-                next: start + 1,\n-            });\n-        }\n-        if a & 0x40 != 0 {\n-            return Ok(Res {\n-                val: ((a & 0x3f) as usize) << 8 | (data[start + 1] as usize),\n-                next: start + 2,\n-            });\n-        }\n-        if a & 0x20 != 0 {\n-            return Ok(Res {\n-                val: ((a & 0x1f) as usize) << 16 | (data[start + 1] as usize) << 8 |\n-                     (data[start + 2] as usize),\n-                next: start + 3,\n-            });\n-        }\n-        if a & 0x10 != 0 {\n-            return Ok(Res {\n-                val: ((a & 0x0f) as usize) << 24 | (data[start + 1] as usize) << 16 |\n-                     (data[start + 2] as usize) << 8 |\n-                     (data[start + 3] as usize),\n-                next: start + 4,\n-            });\n-        }\n-        Err(IntTooBig(a as usize))\n-    }\n-\n-    pub fn vuint_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n-        if data.len() - start < 4 {\n-            return vuint_at_slow(data, start);\n-        }\n-\n-        // Lookup table for parsing EBML Element IDs as per\n-        // http://ebml.sourceforge.net/specs/ The Element IDs are parsed by\n-        // reading a big endian u32 positioned at data[start].  Using the four\n-        // most significant bits of the u32 we lookup in the table below how\n-        // the element ID should be derived from it.\n-        //\n-        // The table stores tuples (shift, mask) where shift is the number the\n-        // u32 should be right shifted with and mask is the value the right\n-        // shifted value should be masked with.  If for example the most\n-        // significant bit is set this means it's a class A ID and the u32\n-        // should be right shifted with 24 and masked with 0x7f. Therefore we\n-        // store (24, 0x7f) at index 0x8 - 0xF (four bit numbers where the most\n-        // significant bit is set).\n-        //\n-        // By storing the number of shifts and masks in a table instead of\n-        // checking in order if the most significant bit is set, the second\n-        // most significant bit is set etc. we can replace up to three\n-        // \"and+branch\" with a single table lookup which gives us a measured\n-        // speedup of around 2x on x86_64.\n-        static SHIFT_MASK_TABLE: [(usize, u32); 16] = [(0, 0x0),\n-                                                       (0, 0x0fffffff),\n-                                                       (8, 0x1fffff),\n-                                                       (8, 0x1fffff),\n-                                                       (16, 0x3fff),\n-                                                       (16, 0x3fff),\n-                                                       (16, 0x3fff),\n-                                                       (16, 0x3fff),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f),\n-                                                       (24, 0x7f)];\n-\n-        unsafe {\n-            let ptr = data.as_ptr().offset(start as isize) as *const u32;\n-            let val = u32::from_be(*ptr);\n-\n-            let i = (val >> 28) as usize;\n-            let (shift, mask) = SHIFT_MASK_TABLE[i];\n-            Ok(Res {\n-                val: ((val >> shift) & mask) as usize,\n-                next: start + ((32 - shift) >> 3),\n-            })\n-        }\n-    }\n-\n-    pub fn tag_len_at(data: &[u8], tag: Res) -> DecodeResult<Res> {\n-        if tag.val < NUM_IMPLICIT_TAGS && TAG_IMPLICIT_LEN[tag.val] >= 0 {\n-            Ok(Res {\n-                val: TAG_IMPLICIT_LEN[tag.val] as usize,\n-                next: tag.next,\n-            })\n-        } else {\n-            vuint_at(data, tag.next)\n-        }\n-    }\n-\n-    pub fn doc_at<'a>(data: &'a [u8], start: usize) -> DecodeResult<TaggedDoc<'a>> {\n-        let elt_tag = tag_at(data, start)?;\n-        let elt_size = tag_len_at(data, elt_tag)?;\n-        let end = elt_size.next + elt_size.val;\n-        Ok(TaggedDoc {\n-            tag: elt_tag.val,\n-            doc: Doc {\n-                data: data,\n-                start: elt_size.next,\n-                end: end,\n-            },\n-        })\n-    }\n-\n-    pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: usize) -> Option<Doc<'a>> {\n-        let mut pos = d.start;\n-        while pos < d.end {\n-            let elt_tag = try_or!(tag_at(d.data, pos), None);\n-            let elt_size = try_or!(tag_len_at(d.data, elt_tag), None);\n-            pos = elt_size.next + elt_size.val;\n-            if elt_tag.val == tg {\n-                return Some(Doc {\n-                    data: d.data,\n-                    start: elt_size.next,\n-                    end: pos,\n-                });\n-            }\n-        }\n-        None\n-    }\n-\n-    pub fn get_doc<'a>(d: Doc<'a>, tg: usize) -> Doc<'a> {\n-        match maybe_get_doc(d, tg) {\n-            Some(d) => d,\n-            None => {\n-                error!(\"failed to find block with tag {:?}\", tg);\n-                panic!();\n-            }\n-        }\n-    }\n-\n-    pub fn docs<'a>(d: Doc<'a>) -> DocsIterator<'a> {\n-        DocsIterator { d: d }\n-    }\n-\n-    pub struct DocsIterator<'a> {\n-        d: Doc<'a>,\n-    }\n-\n-    impl<'a> Iterator for DocsIterator<'a> {\n-        type Item = (usize, Doc<'a>);\n-\n-        fn next(&mut self) -> Option<(usize, Doc<'a>)> {\n-            if self.d.start >= self.d.end {\n-                return None;\n-            }\n-\n-            let elt_tag = try_or!(tag_at(self.d.data, self.d.start), {\n-                self.d.start = self.d.end;\n-                None\n-            });\n-            let elt_size = try_or!(tag_len_at(self.d.data, elt_tag), {\n-                self.d.start = self.d.end;\n-                None\n-            });\n-\n-            let end = elt_size.next + elt_size.val;\n-            let doc = Doc {\n-                data: self.d.data,\n-                start: elt_size.next,\n-                end: end,\n-            };\n-\n-            self.d.start = end;\n-            return Some((elt_tag.val, doc));\n-        }\n-    }\n-\n-    pub fn tagged_docs<'a>(d: Doc<'a>, tag: usize) -> TaggedDocsIterator<'a> {\n-        TaggedDocsIterator {\n-            iter: docs(d),\n-            tag: tag,\n-        }\n-    }\n-\n-    pub struct TaggedDocsIterator<'a> {\n-        iter: DocsIterator<'a>,\n-        tag: usize,\n-    }\n-\n-    impl<'a> Iterator for TaggedDocsIterator<'a> {\n-        type Item = Doc<'a>;\n-\n-        fn next(&mut self) -> Option<Doc<'a>> {\n-            while let Some((tag, doc)) = self.iter.next() {\n-                if tag == self.tag {\n-                    return Some(doc);\n-                }\n-            }\n-            None\n-        }\n-    }\n-\n-    pub fn with_doc_data<T, F>(d: Doc, f: F) -> T\n-        where F: FnOnce(&[u8]) -> T\n-    {\n-        f(&d.data[d.start..d.end])\n-    }\n-\n-    pub fn doc_as_u8(d: Doc) -> u8 {\n-        assert_eq!(d.end, d.start + 1);\n-        d.data[d.start]\n-    }\n-\n-    pub fn doc_as_u64(d: Doc) -> u64 {\n-        if d.end >= 8 {\n-            // For performance, we read 8 big-endian bytes,\n-            // and mask off the junk if there is any. This\n-            // obviously won't work on the first 8 bytes\n-            // of a file - we will fall of the start\n-            // of the page and segfault.\n-\n-            let mut b = [0; 8];\n-            b.copy_from_slice(&d.data[d.end - 8..d.end]);\n-            let data = unsafe { (*(b.as_ptr() as *const u64)).to_be() };\n-            let len = d.end - d.start;\n-            if len < 8 {\n-                data & ((1 << (len * 8)) - 1)\n-            } else {\n-                data\n-            }\n-        } else {\n-            let mut result = 0;\n-            for b in &d.data[d.start..d.end] {\n-                result = (result << 8) + (*b as u64);\n-            }\n-            result\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn doc_as_u16(d: Doc) -> u16 {\n-        doc_as_u64(d) as u16\n-    }\n-    #[inline]\n-    pub fn doc_as_u32(d: Doc) -> u32 {\n-        doc_as_u64(d) as u32\n-    }\n-\n-    #[inline]\n-    pub fn doc_as_i8(d: Doc) -> i8 {\n-        doc_as_u8(d) as i8\n-    }\n-    #[inline]\n-    pub fn doc_as_i16(d: Doc) -> i16 {\n-        doc_as_u16(d) as i16\n-    }\n-    #[inline]\n-    pub fn doc_as_i32(d: Doc) -> i32 {\n-        doc_as_u32(d) as i32\n-    }\n-    #[inline]\n-    pub fn doc_as_i64(d: Doc) -> i64 {\n-        doc_as_u64(d) as i64\n-    }\n-\n-    pub struct Decoder<'a> {\n-        parent: Doc<'a>,\n-        pos: usize,\n-    }\n-\n-    impl<'doc> Decoder<'doc> {\n-        pub fn new(d: Doc<'doc>) -> Decoder<'doc> {\n-            Decoder {\n-                parent: d,\n-                pos: d.start,\n-            }\n-        }\n-\n-        fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<Doc<'doc>> {\n-            debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n-            if self.pos >= self.parent.end {\n-                return Err(Expected(format!(\"no more documents in current node!\")));\n-            }\n-            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-            debug!(\"self.parent={:?}-{:?} self.pos={:?} r_tag={:?} r_doc={:?}-{:?}\",\n-                   self.parent.start,\n-                   self.parent.end,\n-                   self.pos,\n-                   r_tag,\n-                   r_doc.start,\n-                   r_doc.end);\n-            if r_tag != (exp_tag as usize) {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n-                                            exp_tag,\n-                                            r_tag)));\n-            }\n-            if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                             {:#x}\",\n-                                            r_doc.end,\n-                                            self.parent.end)));\n-            }\n-            self.pos = r_doc.end;\n-            Ok(r_doc)\n-        }\n-\n-        fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            let d = self.next_doc(exp_tag)?;\n-            let old_parent = self.parent;\n-            let old_pos = self.pos;\n-            self.parent = d;\n-            self.pos = d.start;\n-            let r = f(self)?;\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(r)\n-        }\n-\n-        fn _next_sub(&mut self) -> DecodeResult<usize> {\n-            // empty vector/map optimization\n-            if self.parent.is_empty() {\n-                return Ok(0);\n-            }\n-\n-            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-            let r = if r_tag == (EsSub8 as usize) {\n-                doc_as_u8(r_doc) as usize\n-            } else if r_tag == (EsSub32 as usize) {\n-                doc_as_u32(r_doc) as usize\n-            } else {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} or {:?} but found \\\n-                                             tag {:?}\",\n-                                            EsSub8,\n-                                            EsSub32,\n-                                            r_tag)));\n-            };\n-            if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                             {:#x}\",\n-                                            r_doc.end,\n-                                            self.parent.end)));\n-            }\n-            self.pos = r_doc.end;\n-            debug!(\"_next_sub result={:?}\", r);\n-            Ok(r)\n-        }\n-\n-        // variable-length unsigned integer with different tags.\n-        // `first_tag` should be a tag for u8 or i8.\n-        // `last_tag` should be the largest allowed integer tag with the matching signedness.\n-        // all tags between them should be valid, in the order of u8, u16, u32 and u64.\n-        fn _next_int(&mut self,\n-                     first_tag: EbmlEncoderTag,\n-                     last_tag: EbmlEncoderTag)\n-                     -> DecodeResult<u64> {\n-            if self.pos >= self.parent.end {\n-                return Err(Expected(format!(\"no more documents in current node!\")));\n-            }\n-\n-            let TaggedDoc { tag: r_tag, doc: r_doc } = doc_at(self.parent.data, self.pos)?;\n-            let r = if first_tag as usize <= r_tag && r_tag <= last_tag as usize {\n-                match r_tag - first_tag as usize {\n-                    0 => doc_as_u8(r_doc) as u64,\n-                    1 => doc_as_u16(r_doc) as u64,\n-                    2 => doc_as_u32(r_doc) as u64,\n-                    3 => doc_as_u64(r_doc),\n-                    _ => unreachable!(),\n-                }\n-            } else {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} through {:?} but \\\n-                                             found tag {:?}\",\n-                                            first_tag,\n-                                            last_tag,\n-                                            r_tag)));\n-            };\n-            if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to \\\n-                                             {:#x}\",\n-                                            r_doc.end,\n-                                            self.parent.end)));\n-            }\n-            self.pos = r_doc.end;\n-            debug!(\"_next_int({:?}, {:?}) result={:?}\", first_tag, last_tag, r);\n-            Ok(r)\n-        }\n-\n-        pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R>\n-            where F: FnOnce(&mut opaque::Decoder, Doc) -> DecodeResult<R>\n-        {\n-            let doc = self.next_doc(EsOpaque)?;\n-\n-            let result = {\n-                let mut opaque_decoder = opaque::Decoder::new(doc.data, doc.start);\n-                op(&mut opaque_decoder, doc)?\n-            };\n-\n-            Ok(result)\n-        }\n-\n-        pub fn position(&self) -> usize {\n-            self.pos\n-        }\n-\n-        pub fn advance(&mut self, bytes: usize) {\n-            self.pos += bytes;\n-        }\n-    }\n-\n-    impl<'doc> serialize::Decoder for Decoder<'doc> {\n-        type Error = Error;\n-        fn read_nil(&mut self) -> DecodeResult<()> {\n-            Ok(())\n-        }\n-\n-        fn read_u64(&mut self) -> DecodeResult<u64> {\n-            self._next_int(EsU8, EsU64)\n-        }\n-        fn read_u32(&mut self) -> DecodeResult<u32> {\n-            Ok(self._next_int(EsU8, EsU32)? as u32)\n-        }\n-        fn read_u16(&mut self) -> DecodeResult<u16> {\n-            Ok(self._next_int(EsU8, EsU16)? as u16)\n-        }\n-        fn read_u8(&mut self) -> DecodeResult<u8> {\n-            Ok(doc_as_u8(self.next_doc(EsU8)?))\n-        }\n-        fn read_usize(&mut self) -> DecodeResult<usize> {\n-            let v = self._next_int(EsU8, EsU64)?;\n-            if v > (::std::usize::MAX as u64) {\n-                Err(IntTooBig(v as usize))\n-            } else {\n-                Ok(v as usize)\n-            }\n-        }\n-\n-        fn read_i64(&mut self) -> DecodeResult<i64> {\n-            Ok(self._next_int(EsI8, EsI64)? as i64)\n-        }\n-        fn read_i32(&mut self) -> DecodeResult<i32> {\n-            Ok(self._next_int(EsI8, EsI32)? as i32)\n-        }\n-        fn read_i16(&mut self) -> DecodeResult<i16> {\n-            Ok(self._next_int(EsI8, EsI16)? as i16)\n-        }\n-        fn read_i8(&mut self) -> DecodeResult<i8> {\n-            Ok(doc_as_u8(self.next_doc(EsI8)?) as i8)\n-        }\n-        fn read_isize(&mut self) -> DecodeResult<isize> {\n-            let v = self._next_int(EsI8, EsI64)? as i64;\n-            if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n-                debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n-                Err(IntTooBig(v as usize))\n-            } else {\n-                Ok(v as isize)\n-            }\n-        }\n-\n-        fn read_bool(&mut self) -> DecodeResult<bool> {\n-            Ok(doc_as_u8(self.next_doc(EsBool)?) != 0)\n-        }\n-\n-        fn read_f64(&mut self) -> DecodeResult<f64> {\n-            let bits = doc_as_u64(self.next_doc(EsF64)?);\n-            Ok(unsafe { transmute(bits) })\n-        }\n-        fn read_f32(&mut self) -> DecodeResult<f32> {\n-            let bits = doc_as_u32(self.next_doc(EsF32)?);\n-            Ok(unsafe { transmute(bits) })\n-        }\n-        fn read_char(&mut self) -> DecodeResult<char> {\n-            Ok(char::from_u32(doc_as_u32(self.next_doc(EsChar)?)).unwrap())\n-        }\n-        fn read_str(&mut self) -> DecodeResult<String> {\n-            Ok(self.next_doc(EsStr)?.to_string())\n-        }\n-\n-        // Compound types:\n-        fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum({})\", name);\n-\n-            let doc = self.next_doc(EsEnum)?;\n-\n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = self.parent.start;\n-\n-            let result = f(self)?;\n-\n-            self.parent = old_parent;\n-            self.pos = old_pos;\n-            Ok(result)\n-        }\n-\n-        fn read_enum_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_variant()\");\n-            let idx = self._next_sub()?;\n-            debug!(\"  idx={}\", idx);\n-\n-            f(self, idx)\n-        }\n-\n-        fn read_enum_variant_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_variant_arg(idx={})\", idx);\n-            f(self)\n-        }\n-\n-        fn read_enum_struct_variant<T, F>(&mut self, _: &[&str], mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_struct_variant()\");\n-            let idx = self._next_sub()?;\n-            debug!(\"  idx={}\", idx);\n-\n-            f(self, idx)\n-        }\n-\n-        fn read_enum_struct_variant_field<T, F>(&mut self,\n-                                                name: &str,\n-                                                idx: usize,\n-                                                f: F)\n-                                                -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n-            f(self)\n-        }\n-\n-        fn read_struct<T, F>(&mut self, name: &str, _: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_struct(name={})\", name);\n-            f(self)\n-        }\n-\n-        fn read_struct_field<T, F>(&mut self, name: &str, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n-            f(self)\n-        }\n-\n-        fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple()\");\n-            self.read_seq(move |d, len| {\n-                if len == tuple_len {\n-                    f(d)\n-                } else {\n-                    Err(Expected(format!(\"Expected tuple of length `{}`, found tuple of length \\\n-                                          `{}`\",\n-                                         tuple_len,\n-                                         len)))\n-                }\n-            })\n-        }\n-\n-        fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple_arg(idx={})\", idx);\n-            self.read_seq_elt(idx, f)\n-        }\n-\n-        fn read_tuple_struct<T, F>(&mut self, name: &str, len: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple_struct(name={})\", name);\n-            self.read_tuple(len, f)\n-        }\n-\n-        fn read_tuple_struct_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_tuple_struct_arg(idx={})\", idx);\n-            self.read_tuple_arg(idx, f)\n-        }\n-\n-        fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, bool) -> DecodeResult<T>\n-        {\n-            debug!(\"read_option()\");\n-            self.read_enum(\"Option\", move |this| {\n-                this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n-                    match idx {\n-                        0 => f(this, false),\n-                        1 => f(this, true),\n-                        _ => Err(Expected(format!(\"Expected None or Some\"))),\n-                    }\n-                })\n-            })\n-        }\n-\n-        fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_seq()\");\n-            self.push_doc(EsVec, move |d| {\n-                let len = d._next_sub()?;\n-                debug!(\"  len={}\", len);\n-                f(d, len)\n-            })\n-        }\n-\n-        fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_seq_elt(idx={})\", idx);\n-            self.push_doc(EsVecElt, f)\n-        }\n-\n-        fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>\n-        {\n-            debug!(\"read_map()\");\n-            self.push_doc(EsMap, move |d| {\n-                let len = d._next_sub()?;\n-                debug!(\"  len={}\", len);\n-                f(d, len)\n-            })\n-        }\n-\n-        fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_map_elt_key(idx={})\", idx);\n-            self.push_doc(EsMapKey, f)\n-        }\n-\n-        fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-            where F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>\n-        {\n-            debug!(\"read_map_elt_val(idx={})\", idx);\n-            self.push_doc(EsMapVal, f)\n-        }\n-\n-        fn error(&mut self, err: &str) -> Error {\n-            ApplicationError(err.to_string())\n-        }\n-    }\n-}\n-\n-pub mod writer {\n-    use std::mem;\n-    use std::io::prelude::*;\n-    use std::io::{self, SeekFrom, Cursor};\n-\n-    use super::opaque;\n-    use super::{EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey, EsU64, EsU32, EsU16,\n-                EsU8, EsI64, EsI32, EsI16, EsI8, EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n-                EsOpaque, NUM_IMPLICIT_TAGS, NUM_TAGS};\n-\n-    use serialize;\n-\n-\n-    pub type EncodeResult = io::Result<()>;\n-\n-    // rbml writing\n-    pub struct Encoder<'a> {\n-        pub writer: &'a mut Cursor<Vec<u8>>,\n-        size_positions: Vec<u64>,\n-        relax_limit: u64, // do not move encoded bytes before this position\n-    }\n-\n-    fn write_tag<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n-        if n < 0xf0 {\n-            w.write_all(&[n as u8])\n-        } else if 0x100 <= n && n < NUM_TAGS {\n-            w.write_all(&[0xf0 | (n >> 8) as u8, n as u8])\n-        } else {\n-            Err(io::Error::new(io::ErrorKind::Other, &format!(\"invalid tag: {}\", n)[..]))\n-        }\n-    }\n-\n-    fn write_sized_vuint<W: Write>(w: &mut W, n: usize, size: usize) -> EncodeResult {\n-        match size {\n-            1 => w.write_all(&[0x80 | (n as u8)]),\n-            2 => w.write_all(&[0x40 | ((n >> 8) as u8), n as u8]),\n-            3 => w.write_all(&[0x20 | ((n >> 16) as u8), (n >> 8) as u8, n as u8]),\n-            4 => w.write_all(&[0x10 | ((n >> 24) as u8), (n >> 16) as u8, (n >> 8) as u8, n as u8]),\n-            _ => Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..])),\n-        }\n-    }\n-\n-    pub fn write_vuint<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n-        if n < 0x7f {\n-            return write_sized_vuint(w, n, 1);\n-        }\n-        if n < 0x4000 {\n-            return write_sized_vuint(w, n, 2);\n-        }\n-        if n < 0x200000 {\n-            return write_sized_vuint(w, n, 3);\n-        }\n-        if n < 0x10000000 {\n-            return write_sized_vuint(w, n, 4);\n-        }\n-        Err(io::Error::new(io::ErrorKind::Other, &format!(\"isize too big: {}\", n)[..]))\n-    }\n-\n-    impl<'a> Encoder<'a> {\n-        pub fn new(w: &'a mut Cursor<Vec<u8>>) -> Encoder<'a> {\n-            Encoder {\n-                writer: w,\n-                size_positions: vec![],\n-                relax_limit: 0,\n-            }\n-        }\n-\n-        pub fn start_tag(&mut self, tag_id: usize) -> EncodeResult {\n-            debug!(\"Start tag {:?}\", tag_id);\n-            assert!(tag_id >= NUM_IMPLICIT_TAGS);\n-\n-            // Write the enum ID:\n-            write_tag(self.writer, tag_id)?;\n-\n-            // Write a placeholder four-byte size.\n-            let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n-            self.size_positions.push(cur_pos);\n-            let zeroes: &[u8] = &[0, 0, 0, 0];\n-            self.writer.write_all(zeroes)\n-        }\n-\n-        pub fn end_tag(&mut self) -> EncodeResult {\n-            let last_size_pos = self.size_positions.pop().unwrap();\n-            let cur_pos = self.writer.seek(SeekFrom::Current(0))?;\n-            self.writer.seek(SeekFrom::Start(last_size_pos))?;\n-            let size = (cur_pos - last_size_pos - 4) as usize;\n-\n-            // relax the size encoding for small tags (bigger tags are costly to move).\n-            // we should never try to move the stable positions, however.\n-            const RELAX_MAX_SIZE: usize = 0x100;\n-            if size <= RELAX_MAX_SIZE && last_size_pos >= self.relax_limit {\n-                // we can't alter the buffer in place, so have a temporary buffer\n-                let mut buf = [0u8; RELAX_MAX_SIZE];\n-                {\n-                    let last_size_pos = last_size_pos as usize;\n-                    let data = &self.writer.get_ref()[last_size_pos + 4..cur_pos as usize];\n-                    buf[..size].copy_from_slice(data);\n-                }\n-\n-                // overwrite the size and data and continue\n-                write_vuint(self.writer, size)?;\n-                self.writer.write_all(&buf[..size])?;\n-            } else {\n-                // overwrite the size with an overlong encoding and skip past the data\n-                write_sized_vuint(self.writer, size, 4)?;\n-                self.writer.seek(SeekFrom::Start(cur_pos))?;\n-            }\n-\n-            debug!(\"End tag (size = {:?})\", size);\n-            Ok(())\n-        }\n-\n-        pub fn wr_tag<F>(&mut self, tag_id: usize, blk: F) -> EncodeResult\n-            where F: FnOnce() -> EncodeResult\n-        {\n-            self.start_tag(tag_id)?;\n-            blk()?;\n-            self.end_tag()\n-        }\n-\n-        pub fn wr_tagged_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n-            assert!(tag_id >= NUM_IMPLICIT_TAGS);\n-            write_tag(self.writer, tag_id)?;\n-            write_vuint(self.writer, b.len())?;\n-            self.writer.write_all(b)\n-        }\n-\n-        pub fn wr_tagged_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n-            let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n-            // tagged integers are emitted in big-endian, with no\n-            // leading zeros.\n-            let leading_zero_bytes = v.leading_zeros() / 8;\n-            self.wr_tagged_bytes(tag_id, &bytes[leading_zero_bytes as usize..])\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_u32(&mut self, tag_id: usize, v: u32) -> EncodeResult {\n-            self.wr_tagged_u64(tag_id, v as u64)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n-            self.wr_tagged_u64(tag_id, v as u64)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n-            self.wr_tagged_bytes(tag_id, &[v])\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n-            self.wr_tagged_u64(tag_id, v as u64)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n-            self.wr_tagged_u32(tag_id, v as u32)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n-            self.wr_tagged_u16(tag_id, v as u16)\n-        }\n-\n-        #[inline]\n-        pub fn wr_tagged_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n-            self.wr_tagged_bytes(tag_id, &[v as u8])\n-        }\n-\n-        pub fn wr_tagged_str(&mut self, tag_id: usize, v: &str) -> EncodeResult {\n-            self.wr_tagged_bytes(tag_id, v.as_bytes())\n-        }\n-\n-        // for auto-serialization\n-        fn wr_tagged_raw_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n-            write_tag(self.writer, tag_id)?;\n-            self.writer.write_all(b)\n-        }\n-\n-        fn wr_tagged_raw_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n-            let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_raw_bytes(tag_id, &bytes)\n-        }\n-\n-        fn wr_tagged_raw_u32(&mut self, tag_id: usize, v: u32) -> EncodeResult {\n-            let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_raw_bytes(tag_id, &bytes)\n-        }\n-\n-        fn wr_tagged_raw_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n-            let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_raw_bytes(tag_id, &bytes)\n-        }\n-\n-        fn wr_tagged_raw_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n-            self.wr_tagged_raw_bytes(tag_id, &[v])\n-        }\n-\n-        fn wr_tagged_raw_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n-            self.wr_tagged_raw_u64(tag_id, v as u64)\n-        }\n-\n-        fn wr_tagged_raw_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n-            self.wr_tagged_raw_u32(tag_id, v as u32)\n-        }\n-\n-        fn wr_tagged_raw_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n-            self.wr_tagged_raw_u16(tag_id, v as u16)\n-        }\n-\n-        fn wr_tagged_raw_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n-            self.wr_tagged_raw_bytes(tag_id, &[v as u8])\n-        }\n-\n-        pub fn wr_bytes(&mut self, b: &[u8]) -> EncodeResult {\n-            debug!(\"Write {:?} bytes\", b.len());\n-            self.writer.write_all(b)\n-        }\n-\n-        pub fn wr_str(&mut self, s: &str) -> EncodeResult {\n-            debug!(\"Write str: {:?}\", s);\n-            self.writer.write_all(s.as_bytes())\n-        }\n-\n-        /// Returns the current position while marking it stable, i.e.\n-        /// generated bytes so far wouldn't be affected by relaxation.\n-        pub fn mark_stable_position(&mut self) -> u64 {\n-            let pos = self.writer.seek(SeekFrom::Current(0)).unwrap();\n-            if self.relax_limit < pos {\n-                self.relax_limit = pos;\n-            }\n-            pos\n-        }\n-    }\n-\n-    impl<'a> Encoder<'a> {\n-        // used internally to emit things like the vector length and so on\n-        fn _emit_tagged_sub(&mut self, v: usize) -> EncodeResult {\n-            if v as u8 as usize == v {\n-                self.wr_tagged_raw_u8(EsSub8 as usize, v as u8)\n-            } else if v as u32 as usize == v {\n-                self.wr_tagged_raw_u32(EsSub32 as usize, v as u32)\n-            } else {\n-                Err(io::Error::new(io::ErrorKind::Other,\n-                                   &format!(\"length or variant id too big: {}\", v)[..]))\n-            }\n-        }\n-\n-        pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult\n-            where F: FnOnce(&mut opaque::Encoder) -> EncodeResult\n-        {\n-            self.start_tag(EsOpaque as usize)?;\n-\n-            {\n-                let mut opaque_encoder = opaque::Encoder::new(self.writer);\n-                f(&mut opaque_encoder)?;\n-            }\n-\n-            self.mark_stable_position();\n-            self.end_tag()\n-        }\n-    }\n-\n-    impl<'a> serialize::Encoder for Encoder<'a> {\n-        type Error = io::Error;\n-\n-        fn emit_nil(&mut self) -> EncodeResult {\n-            Ok(())\n-        }\n-\n-        fn emit_usize(&mut self, v: usize) -> EncodeResult {\n-            self.emit_u64(v as u64)\n-        }\n-        fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-            if v as u32 as u64 == v {\n-                self.emit_u32(v as u32)\n-            } else {\n-                self.wr_tagged_raw_u64(EsU64 as usize, v)\n-            }\n-        }\n-        fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-            if v as u16 as u32 == v {\n-                self.emit_u16(v as u16)\n-            } else {\n-                self.wr_tagged_raw_u32(EsU32 as usize, v)\n-            }\n-        }\n-        fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-            if v as u8 as u16 == v {\n-                self.emit_u8(v as u8)\n-            } else {\n-                self.wr_tagged_raw_u16(EsU16 as usize, v)\n-            }\n-        }\n-        fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-            self.wr_tagged_raw_u8(EsU8 as usize, v)\n-        }\n-\n-        fn emit_isize(&mut self, v: isize) -> EncodeResult {\n-            self.emit_i64(v as i64)\n-        }\n-        fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-            if v as i32 as i64 == v {\n-                self.emit_i32(v as i32)\n-            } else {\n-                self.wr_tagged_raw_i64(EsI64 as usize, v)\n-            }\n-        }\n-        fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-            if v as i16 as i32 == v {\n-                self.emit_i16(v as i16)\n-            } else {\n-                self.wr_tagged_raw_i32(EsI32 as usize, v)\n-            }\n-        }\n-        fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-            if v as i8 as i16 == v {\n-                self.emit_i8(v as i8)\n-            } else {\n-                self.wr_tagged_raw_i16(EsI16 as usize, v)\n-            }\n-        }\n-        fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-            self.wr_tagged_raw_i8(EsI8 as usize, v)\n-        }\n-\n-        fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-            self.wr_tagged_raw_u8(EsBool as usize, v as u8)\n-        }\n-\n-        fn emit_f64(&mut self, v: f64) -> EncodeResult {\n-            let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_raw_u64(EsF64 as usize, bits)\n-        }\n-        fn emit_f32(&mut self, v: f32) -> EncodeResult {\n-            let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_raw_u32(EsF32 as usize, bits)\n-        }\n-        fn emit_char(&mut self, v: char) -> EncodeResult {\n-            self.wr_tagged_raw_u32(EsChar as usize, v as u32)\n-        }\n-\n-        fn emit_str(&mut self, v: &str) -> EncodeResult {\n-            self.wr_tagged_str(EsStr as usize, v)\n-        }\n-\n-        fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.start_tag(EsEnum as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_enum_variant<F>(&mut self, _: &str, v_id: usize, _: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self._emit_tagged_sub(v_id)?;\n-            f(self)\n-        }\n-\n-        fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_enum_struct_variant<F>(&mut self,\n-                                       v_name: &str,\n-                                       v_id: usize,\n-                                       cnt: usize,\n-                                       f: F)\n-                                       -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_enum_variant(v_name, v_id, cnt, f)\n-        }\n-\n-        fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_enum_variant_arg(idx, f)\n-        }\n-\n-        fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            f(self)\n-        }\n-\n-        fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq(len, f)\n-        }\n-        fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_seq_elt(idx, f)\n-        }\n-\n-        fn emit_option<F>(&mut self, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.emit_enum(\"Option\", f)\n-        }\n-        fn emit_option_none(&mut self) -> EncodeResult {\n-            self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n-        }\n-        fn emit_option_some<F>(&mut self, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-\n-            self.emit_enum_variant(\"Some\", 1, 1, f)\n-        }\n-\n-        fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            if len == 0 {\n-                // empty vector optimization\n-                return self.wr_tagged_bytes(EsVec as usize, &[]);\n-            }\n-\n-            self.start_tag(EsVec as usize)?;\n-            self._emit_tagged_sub(len)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-\n-            self.start_tag(EsVecElt as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            if len == 0 {\n-                // empty map optimization\n-                return self.wr_tagged_bytes(EsMap as usize, &[]);\n-            }\n-\n-            self.start_tag(EsMap as usize)?;\n-            self._emit_tagged_sub(len)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-\n-            self.start_tag(EsMapKey as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-\n-        fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n-            where F: FnOnce(&mut Encoder<'a>) -> EncodeResult\n-        {\n-            self.start_tag(EsMapVal as usize)?;\n-            f(self)?;\n-            self.end_tag()\n-        }\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-// Testing\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::{Doc, reader, writer};\n-\n-    use serialize::{Encodable, Decodable};\n-\n-    use std::io::Cursor;\n-\n-    #[test]\n-    fn test_vuint_at() {\n-        let data = &[\n-            0x80,\n-            0xff,\n-            0x40, 0x00,\n-            0x7f, 0xff,\n-            0x20, 0x00, 0x00,\n-            0x3f, 0xff, 0xff,\n-            0x10, 0x00, 0x00, 0x00,\n-            0x1f, 0xff, 0xff, 0xff\n-        ];\n-\n-        let mut res: reader::Res;\n-\n-        // Class A\n-        res = reader::vuint_at(data, 0).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 1);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 7) - 1);\n-        assert_eq!(res.next, 2);\n-\n-        // Class B\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 4);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 14) - 1);\n-        assert_eq!(res.next, 6);\n-\n-        // Class C\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 9);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 21) - 1);\n-        assert_eq!(res.next, 12);\n-\n-        // Class D\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, 0);\n-        assert_eq!(res.next, 16);\n-        res = reader::vuint_at(data, res.next).unwrap();\n-        assert_eq!(res.val, (1 << 28) - 1);\n-        assert_eq!(res.next, 20);\n-    }\n-\n-    #[test]\n-    fn test_option_int() {\n-        fn test_v(v: Option<isize>) {\n-            debug!(\"v == {:?}\", v);\n-            let mut wr = Cursor::new(Vec::new());\n-            {\n-                let mut rbml_w = writer::Encoder::new(&mut wr);\n-                let _ = v.encode(&mut rbml_w);\n-            }\n-            let rbml_doc = Doc::new(wr.get_ref());\n-            let mut deser = reader::Decoder::new(rbml_doc);\n-            let v1 = Decodable::decode(&mut deser).unwrap();\n-            debug!(\"v1 == {:?}\", v1);\n-            assert_eq!(v, v1);\n-        }\n-\n-        test_v(Some(22));\n-        test_v(None);\n-        test_v(Some(3));\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    #![allow(non_snake_case)]\n-    use test::Bencher;\n-    use super::reader;\n-\n-    #[bench]\n-    pub fn vuint_at_A_aligned(b: &mut Bencher) {\n-        let data = (0..4 * 100)\n-                       .map(|i| {\n-                           match i % 2 {\n-                               0 => 0x80,\n-                               _ => i as u8,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 0;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_A_unaligned(b: &mut Bencher) {\n-        let data = (0..4 * 100 + 1)\n-                       .map(|i| {\n-                           match i % 2 {\n-                               1 => 0x80,\n-                               _ => i as u8,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 1;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_D_aligned(b: &mut Bencher) {\n-        let data = (0..4 * 100)\n-                       .map(|i| {\n-                           match i % 4 {\n-                               0 => 0x10,\n-                               3 => i as u8,\n-                               _ => 0,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 0;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    pub fn vuint_at_D_unaligned(b: &mut Bencher) {\n-        let data = (0..4 * 100 + 1)\n-                       .map(|i| {\n-                           match i % 4 {\n-                               1 => 0x10,\n-                               0 => i as u8,\n-                               _ => 0,\n-                           }\n-                       })\n-                       .collect::<Vec<_>>();\n-        let mut sum = 0;\n-        b.iter(|| {\n-            let mut i = 1;\n-            while i < data.len() {\n-                sum += reader::vuint_at(&data, i).unwrap().val;\n-                i += 4;\n-            }\n-        });\n-    }\n-}"}, {"sha": "578ef68b00386f3be294d68748acafc59128460f", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -14,7 +14,6 @@ flate = { path = \"../libflate\" }\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n log = { path = \"../liblog\" }\n-rbml = { path = \"../librbml\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }"}, {"sha": "1b2976b7435d8e38ed66dc9cf9d9d2921aaa6324", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_ast_node(pat.id, &[pats_exit])\n             }\n \n-            PatKind::Vec(ref pre, ref vec, ref post) => {\n+            PatKind::Slice(ref pre, ref vec, ref post) => {\n                 let pre_exit = self.pats_all(pre.iter(), pred);\n                 let vec_exit = self.pats_all(vec.iter(), pre_exit);\n                 let post_exit = self.pats_all(post.iter(), vec_exit);\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_unreachable_node()\n             }\n \n-            hir::ExprVec(ref elems) => {\n+            hir::ExprArray(ref elems) => {\n                 self.straightline(expr, pred, elems.iter().map(|e| &**e))\n             }\n \n@@ -536,7 +536,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn add_contained_edge(&mut self,\n                           source: CFGIndex,\n                           target: CFGIndex) {\n-        let data = CFGEdgeData {exiting_scopes: vec!() };\n+        let data = CFGEdgeData {exiting_scopes: vec![] };\n         self.graph.add_edge(source, target, data);\n     }\n \n@@ -545,7 +545,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         from_index: CFGIndex,\n                         to_loop: LoopScope,\n                         to_index: CFGIndex) {\n-        let mut data = CFGEdgeData {exiting_scopes: vec!() };\n+        let mut data = CFGEdgeData {exiting_scopes: vec![] };\n         let mut scope = self.tcx.region_maps.node_extent(from_expr.id);\n         let target_scope = self.tcx.region_maps.node_extent(to_loop.loop_id);\n         while scope != target_scope {\n@@ -559,7 +559,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                           _from_expr: &hir::Expr,\n                           from_index: CFGIndex) {\n         let mut data = CFGEdgeData {\n-            exiting_scopes: vec!(),\n+            exiting_scopes: vec![],\n         };\n         for &LoopScope { loop_id: id, .. } in self.loop_scopes.iter().rev() {\n             data.exiting_scopes.push(id);"}, {"sha": "e99ffa95ed63ca3314bb81989ec3a2de3a0f49e4", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -51,7 +51,6 @@ pub enum DepNode<D: Clone + Debug> {\n     WorkProduct(Arc<WorkProductId>),\n \n     // Represents different phases in the compiler.\n-    CrateReader,\n     CollectLanguageItems,\n     CheckStaticRecursion,\n     ResolveLifetimes,\n@@ -103,18 +102,13 @@ pub enum DepNode<D: Clone + Debug> {\n     // table in the tcx (or elsewhere) maps to one of these\n     // nodes. Often we map multiple tables to the same node if there\n     // is no point in distinguishing them (e.g., both the type and\n-    // predicates for an item wind up in `ItemSignature`). Other\n-    // times, such as `ImplItems` vs `TraitItemDefIds`, tables which\n-    // might be mergable are kept distinct because the sets of def-ids\n-    // to which they apply are disjoint, and hence we might as well\n-    // have distinct labels for easier debugging.\n+    // predicates for an item wind up in `ItemSignature`).\n     ImplOrTraitItems(D),\n     ItemSignature(D),\n     FieldTy(D),\n     SizedConstraint(D),\n-    TraitItemDefIds(D),\n+    ImplOrTraitItemDefIds(D),\n     InherentImpls(D),\n-    ImplItems(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -162,9 +156,8 @@ impl<D: Clone + Debug> DepNode<D> {\n             ImplOrTraitItems,\n             ItemSignature,\n             FieldTy,\n-            TraitItemDefIds,\n+            ImplOrTraitItemDefIds,\n             InherentImpls,\n-            ImplItems,\n             TraitImpls,\n             ReprHints,\n         }\n@@ -177,7 +170,6 @@ impl<D: Clone + Debug> DepNode<D> {\n \n         match *self {\n             Krate => Some(Krate),\n-            CrateReader => Some(CrateReader),\n             CollectLanguageItems => Some(CollectLanguageItems),\n             CheckStaticRecursion => Some(CheckStaticRecursion),\n             ResolveLifetimes => Some(ResolveLifetimes),\n@@ -231,9 +223,8 @@ impl<D: Clone + Debug> DepNode<D> {\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n             FieldTy(ref d) => op(d).map(FieldTy),\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n-            TraitItemDefIds(ref d) => op(d).map(TraitItemDefIds),\n+            ImplOrTraitItemDefIds(ref d) => op(d).map(ImplOrTraitItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),\n-            ImplItems(ref d) => op(d).map(ImplItems),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),"}, {"sha": "fac3586afc7b965f80f5e7e24c778f7cd82ca579", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -51,22 +51,15 @@ impl DepGraph {\n         }\n     }\n \n-    /// True if we are actually building a dep-graph. If this returns false,\n-    /// then the other methods on this `DepGraph` will have no net effect.\n-    #[inline]\n-    pub fn enabled(&self) -> bool {\n-        self.data.thread.enabled()\n-    }\n-\n     pub fn query(&self) -> DepGraphQuery<DefId> {\n         self.data.thread.query()\n     }\n \n-    pub fn in_ignore<'graph>(&'graph self) -> raii::IgnoreTask<'graph> {\n+    pub fn in_ignore<'graph>(&'graph self) -> Option<raii::IgnoreTask<'graph>> {\n         raii::IgnoreTask::new(&self.data.thread)\n     }\n \n-    pub fn in_task<'graph>(&'graph self, key: DepNode<DefId>) -> raii::DepTask<'graph> {\n+    pub fn in_task<'graph>(&'graph self, key: DepNode<DefId>) -> Option<raii::DepTask<'graph>> {\n         raii::DepTask::new(&self.data.thread, key)\n     }\n \n@@ -85,11 +78,15 @@ impl DepGraph {\n     }\n \n     pub fn read(&self, v: DepNode<DefId>) {\n-        self.data.thread.enqueue(DepMessage::Read(v));\n+        if self.data.thread.is_enqueue_enabled() {\n+            self.data.thread.enqueue(DepMessage::Read(v));\n+        }\n     }\n \n     pub fn write(&self, v: DepNode<DefId>) {\n-        self.data.thread.enqueue(DepMessage::Write(v));\n+        if self.data.thread.is_enqueue_enabled() {\n+            self.data.thread.enqueue(DepMessage::Write(v));\n+        }\n     }\n \n     /// Indicates that a previous work product exists for `v`. This is"}, {"sha": "e39797599acfdc2512bc3afe04ca02115e38557e", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -19,15 +19,21 @@ pub struct DepTask<'graph> {\n \n impl<'graph> DepTask<'graph> {\n     pub fn new(data: &'graph DepGraphThreadData, key: DepNode<DefId>)\n-               -> DepTask<'graph> {\n-        data.enqueue(DepMessage::PushTask(key.clone()));\n-        DepTask { data: data, key: Some(key) }\n+               -> Option<DepTask<'graph>> {\n+        if data.is_enqueue_enabled() {\n+            data.enqueue(DepMessage::PushTask(key.clone()));\n+            Some(DepTask { data: data, key: Some(key) })\n+        } else {\n+            None\n+        }\n     }\n }\n \n impl<'graph> Drop for DepTask<'graph> {\n     fn drop(&mut self) {\n-        self.data.enqueue(DepMessage::PopTask(self.key.take().unwrap()));\n+        if self.data.is_enqueue_enabled() {\n+            self.data.enqueue(DepMessage::PopTask(self.key.take().unwrap()));\n+        }\n     }\n }\n \n@@ -36,15 +42,21 @@ pub struct IgnoreTask<'graph> {\n }\n \n impl<'graph> IgnoreTask<'graph> {\n-    pub fn new(data: &'graph DepGraphThreadData) -> IgnoreTask<'graph> {\n-        data.enqueue(DepMessage::PushIgnore);\n-        IgnoreTask { data: data }\n+    pub fn new(data: &'graph DepGraphThreadData) -> Option<IgnoreTask<'graph>> {\n+        if data.is_enqueue_enabled() {\n+            data.enqueue(DepMessage::PushIgnore);\n+            Some(IgnoreTask { data: data })\n+        } else {\n+            None\n+        }\n     }\n }\n \n impl<'graph> Drop for IgnoreTask<'graph> {\n     fn drop(&mut self) {\n-        self.data.enqueue(DepMessage::PopIgnore);\n+        if self.data.is_enqueue_enabled() {\n+            self.data.enqueue(DepMessage::PopIgnore);\n+        }\n     }\n }\n "}, {"sha": "06def4bf19af31ea5b573ae6540d6722288c2b6b", "filename": "src/librustc/dep_graph/shadow.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fdep_graph%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fshadow.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -64,6 +64,11 @@ impl ShadowGraph {\n         }\n     }\n \n+    #[inline]\n+    pub fn enabled(&self) -> bool {\n+        ENABLED\n+    }\n+\n     pub fn enqueue(&self, message: &DepMessage) {\n         if ENABLED {\n             match self.stack.borrow_state() {"}, {"sha": "9f755cf86e4e4e59c2ec15c3479850b3785c2291", "filename": "src/librustc/dep_graph/thread.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fdep_graph%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fthread.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -88,15 +88,24 @@ impl DepGraphThreadData {\n         }\n     }\n \n+    /// True if we are actually building the full dep-graph.\n     #[inline]\n-    pub fn enabled(&self) -> bool {\n+    pub fn is_fully_enabled(&self) -> bool {\n         self.enabled\n     }\n \n+    /// True if (a) we are actually building the full dep-graph, or (b) we are\n+    /// only enqueuing messages in order to sanity-check them (which happens\n+    /// when debug assertions are enabled).\n+    #[inline]\n+    pub fn is_enqueue_enabled(&self) -> bool {\n+        self.is_fully_enabled() || self.shadow_graph.enabled()\n+    }\n+\n     /// Sends the current batch of messages to the thread. Installs a\n     /// new vector of messages.\n     fn swap(&self) {\n-        assert!(self.enabled, \"should never swap if not enabled\");\n+        assert!(self.is_fully_enabled(), \"should never swap if not fully enabled\");\n \n         // should be a buffer waiting for us (though of course we may\n         // have to wait for depgraph thread to finish processing the\n@@ -112,7 +121,7 @@ impl DepGraphThreadData {\n     }\n \n     pub fn query(&self) -> DepGraphQuery<DefId> {\n-        assert!(self.enabled, \"cannot query if dep graph construction not enabled\");\n+        assert!(self.is_fully_enabled(), \"should never query if not fully enabled\");\n         self.enqueue(DepMessage::Query);\n         self.swap();\n         self.query_in.recv().unwrap()\n@@ -122,9 +131,9 @@ impl DepGraphThreadData {\n     /// the buffer is full, this may swap.)\n     #[inline]\n     pub fn enqueue(&self, message: DepMessage) {\n+        assert!(self.is_enqueue_enabled(), \"should never enqueue if not enqueue-enabled\");\n         self.shadow_graph.enqueue(&message);\n-\n-        if self.enabled {\n+        if self.is_fully_enabled() {\n             self.enqueue_enabled(message);\n         }\n     }"}, {"sha": "465a09505e4a77e4c9b8e86cebb1182d946f4e57", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -1327,30 +1327,6 @@ let x: i32 = \"I am not a number!\";\n //      |\n //    type `i32` assigned to variable `x`\n ```\n-\n-Another situation in which this occurs is when you attempt to use the `try!`\n-macro inside a function that does not return a `Result<T, E>`:\n-\n-```compile_fail,E0308\n-use std::fs::File;\n-\n-fn main() {\n-    let mut f = try!(File::create(\"foo.txt\"));\n-}\n-```\n-\n-This code gives an error like this:\n-\n-```text\n-<std macros>:5:8: 6:42 error: mismatched types:\n- expected `()`,\n-     found `core::result::Result<_, _>`\n- (expected (),\n-     found enum `core::result::Result`) [E0308]\n-```\n-\n-`try!` returns a `Result<T, E>`, and so the function must. But `main()` has\n-`()` as its return type, hence the error.\n \"##,\n \n E0309: r##\"\n@@ -1431,6 +1407,23 @@ fn make_child<'elve>(x: &mut &'elve isize, y: &mut &'elve isize) {\n ```\n \"##,\n \n+E0317: r##\"\n+This error occurs when an `if` expression without an `else` block is used in a\n+context where a type other than `()` is expected, for example a `let`\n+expression:\n+\n+```compile_fail,E0317\n+fn main() {\n+    let x = 5;\n+    let a = if x == 5 { 1 };\n+}\n+```\n+\n+An `if` expression without an `else` block has the type `()`, so this is a type\n+error. To resolve it, add an `else` block having the same type as the `if`\n+block.\n+\"##,\n+\n E0398: r##\"\n In Rust 1.3, the default object lifetime bounds are expected to change, as\n described in RFC #1156 [1]. You are getting a warning because the compiler"}, {"sha": "8b9cee1d2f6d6184bfbe61cbdd2011d161852ab7", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 61, "deletions": 47, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -13,37 +13,46 @@ use util::nodemap::NodeMap;\n use syntax::ast;\n use hir;\n \n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum CtorKind {\n+    // Constructor function automatically created by a tuple struct/variant.\n+    Fn,\n+    // Constructor constant automatically created by a unit struct/variant.\n+    Const,\n+    // Unusable name in value namespace created by a struct variant.\n+    Fictive,\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Def {\n-    Fn(DefId),\n-    SelfTy(Option<DefId> /* trait */, Option<ast::NodeId> /* impl */),\n+    // Type namespace\n     Mod(DefId),\n-    ForeignMod(DefId),\n-    Static(DefId, bool /* is_mutbl */),\n-    Const(DefId),\n-    AssociatedConst(DefId),\n-    Local(DefId, // def id of variable\n-             ast::NodeId), // node id of variable\n-    Variant(DefId /* enum */, DefId /* variant */),\n+    Struct(DefId), // DefId refers to NodeId of the struct itself\n+    Union(DefId),\n     Enum(DefId),\n-    TyAlias(DefId),\n-    AssociatedTy(DefId /* trait */, DefId),\n+    Variant(DefId),\n     Trait(DefId),\n+    TyAlias(DefId),\n+    AssociatedTy(DefId),\n     PrimTy(hir::PrimTy),\n     TyParam(DefId),\n-    Upvar(DefId,        // def id of closed over local\n-             ast::NodeId,  // node id of closed over local\n-             usize,        // index in the freevars list of the closure\n-             ast::NodeId), // expr node that creates the closure\n+    SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n \n-    // If Def::Struct lives in type namespace it denotes a struct item and its DefId refers\n-    // to NodeId of the struct itself.\n-    // If Def::Struct lives in value namespace (e.g. tuple struct, unit struct expressions)\n-    // it denotes a constructor and its DefId refers to NodeId of the struct's constructor.\n-    Struct(DefId),\n-    Union(DefId),\n-    Label(ast::NodeId),\n+    // Value namespace\n+    Fn(DefId),\n+    Const(DefId),\n+    Static(DefId, bool /* is_mutbl */),\n+    StructCtor(DefId, CtorKind), // DefId refers to NodeId of the struct's constructor\n+    VariantCtor(DefId, CtorKind),\n     Method(DefId),\n+    AssociatedConst(DefId),\n+    Local(DefId),\n+    Upvar(DefId,        // def id of closed over local\n+          usize,        // index in the freevars list of the closure\n+          ast::NodeId), // expr node that creates the closure\n+    Label(ast::NodeId),\n+\n+    // Both namespaces\n     Err,\n }\n \n@@ -94,37 +103,37 @@ pub type DefMap = NodeMap<PathResolution>;\n // within.\n pub type ExportMap = NodeMap<Vec<Export>>;\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct Export {\n-    pub name: ast::Name,    // The name of the target.\n-    pub def_id: DefId, // The definition of the target.\n+    pub name: ast::Name, // The name of the target.\n+    pub def: Def, // The definition of the target.\n }\n \n-impl Def {\n-    pub fn var_id(&self) -> ast::NodeId {\n-        match *self {\n-            Def::Local(_, id) |\n-            Def::Upvar(_, id, ..) => {\n-                id\n-            }\n-\n-            Def::Fn(..) | Def::Mod(..) | Def::ForeignMod(..) | Def::Static(..) |\n-            Def::Variant(..) | Def::Enum(..) | Def::TyAlias(..) | Def::AssociatedTy(..) |\n-            Def::TyParam(..) | Def::Struct(..) | Def::Union(..) | Def::Trait(..) |\n-            Def::Method(..) | Def::Const(..) | Def::AssociatedConst(..) |\n-            Def::PrimTy(..) | Def::Label(..) | Def::SelfTy(..) | Def::Err => {\n-                bug!(\"attempted .var_id() on invalid {:?}\", self)\n-            }\n+impl CtorKind {\n+    pub fn from_ast(vdata: &ast::VariantData) -> CtorKind {\n+        match *vdata {\n+            ast::VariantData::Tuple(..) => CtorKind::Fn,\n+            ast::VariantData::Unit(..) => CtorKind::Const,\n+            ast::VariantData::Struct(..) => CtorKind::Fictive,\n         }\n     }\n+    pub fn from_hir(vdata: &hir::VariantData) -> CtorKind {\n+        match *vdata {\n+            hir::VariantData::Tuple(..) => CtorKind::Fn,\n+            hir::VariantData::Unit(..) => CtorKind::Const,\n+            hir::VariantData::Struct(..) => CtorKind::Fictive,\n+        }\n+    }\n+}\n \n+impl Def {\n     pub fn def_id(&self) -> DefId {\n         match *self {\n-            Def::Fn(id) | Def::Mod(id) | Def::ForeignMod(id) | Def::Static(id, _) |\n-            Def::Variant(_, id) | Def::Enum(id) | Def::TyAlias(id) | Def::AssociatedTy(_, id) |\n-            Def::TyParam(id) | Def::Struct(id) | Def::Union(id) | Def::Trait(id) |\n-            Def::Method(id) | Def::Const(id) | Def::AssociatedConst(id) |\n-            Def::Local(id, _) | Def::Upvar(id, ..) => {\n+            Def::Fn(id) | Def::Mod(id) | Def::Static(id, _) |\n+            Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) | Def::TyAlias(id) |\n+            Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n+            Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n+            Def::AssociatedConst(id) | Def::Local(id) | Def::Upvar(id, ..) => {\n                 id\n             }\n \n@@ -141,13 +150,18 @@ impl Def {\n         match *self {\n             Def::Fn(..) => \"function\",\n             Def::Mod(..) => \"module\",\n-            Def::ForeignMod(..) => \"foreign module\",\n             Def::Static(..) => \"static\",\n             Def::Variant(..) => \"variant\",\n+            Def::VariantCtor(.., CtorKind::Fn) => \"tuple variant\",\n+            Def::VariantCtor(.., CtorKind::Const) => \"unit variant\",\n+            Def::VariantCtor(.., CtorKind::Fictive) => \"struct variant\",\n             Def::Enum(..) => \"enum\",\n-            Def::TyAlias(..) => \"type\",\n+            Def::TyAlias(..) => \"type alias\",\n             Def::AssociatedTy(..) => \"associated type\",\n             Def::Struct(..) => \"struct\",\n+            Def::StructCtor(.., CtorKind::Fn) => \"tuple struct\",\n+            Def::StructCtor(.., CtorKind::Const) => \"unit struct\",\n+            Def::StructCtor(.., CtorKind::Fictive) => bug!(\"impossible struct constructor\"),\n             Def::Union(..) => \"union\",\n             Def::Trait(..) => \"trait\",\n             Def::Method(..) => \"method\","}, {"sha": "399243551d6518b14f7af6807e8d0b3edbf54e94", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -8,12 +8,69 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::cstore::LOCAL_CRATE;\n use ty;\n-use syntax::ast::CrateNum;\n+\n+use rustc_data_structures::indexed_vec::Idx;\n+use serialize::{self, Encoder, Decoder};\n+\n use std::fmt;\n use std::u32;\n \n+#[derive(Clone, Copy, Eq, Ord, PartialOrd, PartialEq, Hash, Debug)]\n+pub struct CrateNum(u32);\n+\n+impl Idx for CrateNum {\n+    fn new(value: usize) -> Self {\n+        assert!(value < (u32::MAX) as usize);\n+        CrateNum(value as u32)\n+    }\n+\n+    fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+/// Item definitions in the currently-compiled crate would have the CrateNum\n+/// LOCAL_CRATE in their DefId.\n+pub const LOCAL_CRATE: CrateNum = CrateNum(0);\n+\n+impl CrateNum {\n+    pub fn new(x: usize) -> CrateNum {\n+        assert!(x < (u32::MAX as usize));\n+        CrateNum(x as u32)\n+    }\n+\n+    pub fn from_u32(x: u32) -> CrateNum {\n+        CrateNum(x)\n+    }\n+\n+    pub fn as_usize(&self) -> usize {\n+        self.0 as usize\n+    }\n+\n+    pub fn as_u32(&self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+impl fmt::Display for CrateNum {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+impl serialize::UseSpecializedEncodable for CrateNum {\n+    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_u32(self.0)\n+    }\n+}\n+\n+impl serialize::UseSpecializedDecodable for CrateNum {\n+    fn default_decode<D: Decoder>(d: &mut D) -> Result<CrateNum, D::Error> {\n+        d.read_u32().map(CrateNum)\n+    }\n+}\n+\n /// A DefIndex is an index into the hir-map for a crate, identifying a\n /// particular definition. It should really be considered an interned\n /// shorthand for a particular DefPath.\n@@ -46,8 +103,7 @@ pub const CRATE_DEF_INDEX: DefIndex = DefIndex(0);\n \n /// A DefId identifies a particular *definition*, by combining a crate\n /// index and a def index.\n-#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n-           RustcDecodable, Hash, Copy)]\n+#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct DefId {\n     pub krate: CrateNum,\n     pub index: DefIndex,"}, {"sha": "57b5599bd1d7ffd59065f0d20c3077cbc0437f2b", "filename": "src/librustc/hir/fold.rs", "status": "removed", "additions": 0, "deletions": 1131, "changes": 1131, "blob_url": "https://github.com/rust-lang/rust/blob/4e2822c5c28bb342e5862ba7cc0b90b865c68be1/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2822c5c28bb342e5862ba7cc0b90b865c68be1/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=4e2822c5c28bb342e5862ba7cc0b90b865c68be1", "patch": "@@ -1,1131 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A Folder represents an HIR->HIR fold; it accepts a HIR piece,\n-//! and returns a piece of the same type.\n-\n-use hir::*;\n-use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_};\n-use syntax::ast::{NestedMetaItem, NestedMetaItemKind, MetaItem, MetaItemKind};\n-use hir;\n-use syntax_pos::Span;\n-use syntax::codemap::{respan, Spanned};\n-use syntax::ptr::P;\n-use syntax::parse::token::keywords;\n-use syntax::util::move_map::MoveMap;\n-\n-pub trait Folder : Sized {\n-    // Any additions to this trait should happen in form\n-    // of a call to a public `noop_*` function that only calls\n-    // out to the folder again, not other `noop_*` functions.\n-    //\n-    // This is a necessary API workaround to the problem of not\n-    // being able to call out to the super default method\n-    // in an overridden default method.\n-\n-    fn fold_crate(&mut self, c: Crate) -> Crate {\n-        noop_fold_crate(c, self)\n-    }\n-\n-    fn fold_meta_items(&mut self, meta_items: HirVec<P<MetaItem>>) -> HirVec<P<MetaItem>> {\n-        noop_fold_meta_items(meta_items, self)\n-    }\n-\n-    fn fold_meta_list_item(&mut self, list_item: NestedMetaItem) -> NestedMetaItem {\n-        noop_fold_meta_list_item(list_item, self)\n-    }\n-\n-    fn fold_meta_item(&mut self, meta_item: P<MetaItem>) -> P<MetaItem> {\n-        noop_fold_meta_item(meta_item, self)\n-    }\n-\n-    fn fold_view_path(&mut self, view_path: P<ViewPath>) -> P<ViewPath> {\n-        noop_fold_view_path(view_path, self)\n-    }\n-\n-    fn fold_foreign_item(&mut self, ni: ForeignItem) -> ForeignItem {\n-        noop_fold_foreign_item(ni, self)\n-    }\n-\n-    fn fold_item(&mut self, i: Item) -> Item {\n-        noop_fold_item(i, self)\n-    }\n-\n-    fn fold_item_id(&mut self, i: ItemId) -> ItemId {\n-        noop_fold_item_id(i, self)\n-    }\n-\n-    fn fold_struct_field(&mut self, sf: StructField) -> StructField {\n-        noop_fold_struct_field(sf, self)\n-    }\n-\n-    fn fold_item_underscore(&mut self, i: Item_) -> Item_ {\n-        noop_fold_item_underscore(i, self)\n-    }\n-\n-    fn fold_trait_item(&mut self, i: TraitItem) -> TraitItem {\n-        noop_fold_trait_item(i, self)\n-    }\n-\n-    fn fold_impl_item(&mut self, i: ImplItem) -> ImplItem {\n-        noop_fold_impl_item(i, self)\n-    }\n-\n-    fn fold_fn_decl(&mut self, d: P<FnDecl>) -> P<FnDecl> {\n-        noop_fold_fn_decl(d, self)\n-    }\n-\n-    fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n-        noop_fold_block(b, self)\n-    }\n-\n-    fn fold_stmt(&mut self, s: Stmt) -> Stmt {\n-        noop_fold_stmt(s, self)\n-    }\n-\n-    fn fold_arm(&mut self, a: Arm) -> Arm {\n-        noop_fold_arm(a, self)\n-    }\n-\n-    fn fold_pat(&mut self, p: P<Pat>) -> P<Pat> {\n-        noop_fold_pat(p, self)\n-    }\n-\n-    fn fold_decl(&mut self, d: P<Decl>) -> P<Decl> {\n-        noop_fold_decl(d, self)\n-    }\n-\n-    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n-        e.map(|e| noop_fold_expr(e, self))\n-    }\n-\n-    fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n-        noop_fold_ty(t, self)\n-    }\n-\n-    fn fold_ty_binding(&mut self, t: TypeBinding) -> TypeBinding {\n-        noop_fold_ty_binding(t, self)\n-    }\n-\n-    fn fold_mod(&mut self, m: Mod) -> Mod {\n-        noop_fold_mod(m, self)\n-    }\n-\n-    fn fold_foreign_mod(&mut self, nm: ForeignMod) -> ForeignMod {\n-        noop_fold_foreign_mod(nm, self)\n-    }\n-\n-    fn fold_variant(&mut self, v: Variant) -> Variant {\n-        noop_fold_variant(v, self)\n-    }\n-\n-    fn fold_name(&mut self, n: Name) -> Name {\n-        noop_fold_name(n, self)\n-    }\n-\n-    fn fold_usize(&mut self, i: usize) -> usize {\n-        noop_fold_usize(i, self)\n-    }\n-\n-    fn fold_path(&mut self, p: Path) -> Path {\n-        noop_fold_path(p, self)\n-    }\n-\n-    fn fold_path_parameters(&mut self, p: PathParameters) -> PathParameters {\n-        noop_fold_path_parameters(p, self)\n-    }\n-\n-    fn fold_angle_bracketed_parameter_data(&mut self,\n-                                           p: AngleBracketedParameterData)\n-                                           -> AngleBracketedParameterData {\n-        noop_fold_angle_bracketed_parameter_data(p, self)\n-    }\n-\n-    fn fold_parenthesized_parameter_data(&mut self,\n-                                         p: ParenthesizedParameterData)\n-                                         -> ParenthesizedParameterData {\n-        noop_fold_parenthesized_parameter_data(p, self)\n-    }\n-\n-    fn fold_local(&mut self, l: P<Local>) -> P<Local> {\n-        noop_fold_local(l, self)\n-    }\n-\n-    fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n-        noop_fold_lifetime(l, self)\n-    }\n-\n-    fn fold_lifetime_def(&mut self, l: LifetimeDef) -> LifetimeDef {\n-        noop_fold_lifetime_def(l, self)\n-    }\n-\n-    fn fold_attribute(&mut self, at: Attribute) -> Option<Attribute> {\n-        noop_fold_attribute(at, self)\n-    }\n-\n-    fn fold_arg(&mut self, a: Arg) -> Arg {\n-        noop_fold_arg(a, self)\n-    }\n-\n-    fn fold_generics(&mut self, generics: Generics) -> Generics {\n-        noop_fold_generics(generics, self)\n-    }\n-\n-    fn fold_trait_ref(&mut self, p: TraitRef) -> TraitRef {\n-        noop_fold_trait_ref(p, self)\n-    }\n-\n-    fn fold_poly_trait_ref(&mut self, p: PolyTraitRef) -> PolyTraitRef {\n-        noop_fold_poly_trait_ref(p, self)\n-    }\n-\n-    fn fold_variant_data(&mut self, vdata: VariantData) -> VariantData {\n-        noop_fold_variant_data(vdata, self)\n-    }\n-\n-    fn fold_lifetimes(&mut self, lts: HirVec<Lifetime>) -> HirVec<Lifetime> {\n-        noop_fold_lifetimes(lts, self)\n-    }\n-\n-    fn fold_lifetime_defs(&mut self, lts: HirVec<LifetimeDef>) -> HirVec<LifetimeDef> {\n-        noop_fold_lifetime_defs(lts, self)\n-    }\n-\n-    fn fold_ty_param(&mut self, tp: TyParam) -> TyParam {\n-        noop_fold_ty_param(tp, self)\n-    }\n-\n-    fn fold_ty_params(&mut self, tps: HirVec<TyParam>) -> HirVec<TyParam> {\n-        noop_fold_ty_params(tps, self)\n-    }\n-\n-    fn fold_opt_lifetime(&mut self, o_lt: Option<Lifetime>) -> Option<Lifetime> {\n-        noop_fold_opt_lifetime(o_lt, self)\n-    }\n-\n-    fn fold_opt_bounds(&mut self,\n-                       b: Option<TyParamBounds>)\n-                       -> Option<TyParamBounds> {\n-        noop_fold_opt_bounds(b, self)\n-    }\n-\n-    fn fold_bounds(&mut self, b: TyParamBounds) -> TyParamBounds {\n-        noop_fold_bounds(b, self)\n-    }\n-\n-    fn fold_ty_param_bound(&mut self, tpb: TyParamBound) -> TyParamBound {\n-        noop_fold_ty_param_bound(tpb, self)\n-    }\n-\n-    fn fold_mt(&mut self, mt: MutTy) -> MutTy {\n-        noop_fold_mt(mt, self)\n-    }\n-\n-    fn fold_field(&mut self, field: Field) -> Field {\n-        noop_fold_field(field, self)\n-    }\n-\n-    fn fold_where_clause(&mut self, where_clause: WhereClause) -> WhereClause {\n-        noop_fold_where_clause(where_clause, self)\n-    }\n-\n-    fn fold_where_predicate(&mut self, where_predicate: WherePredicate) -> WherePredicate {\n-        noop_fold_where_predicate(where_predicate, self)\n-    }\n-\n-    /// called for the `id` on each declaration\n-    fn new_id(&mut self, i: NodeId) -> NodeId {\n-        i\n-    }\n-\n-    /// called for ids that are references (e.g., ItemDef)\n-    fn map_id(&mut self, i: NodeId) -> NodeId {\n-        i\n-    }\n-\n-    fn new_span(&mut self, sp: Span) -> Span {\n-        sp\n-    }\n-}\n-\n-pub fn noop_fold_meta_items<T: Folder>(meta_items: HirVec<P<MetaItem>>,\n-                                       fld: &mut T)\n-                                       -> HirVec<P<MetaItem>> {\n-    meta_items.move_map(|x| fld.fold_meta_item(x))\n-}\n-\n-pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<ViewPath> {\n-    view_path.map(|Spanned { node, span }| {\n-        Spanned {\n-            node: match node {\n-                ViewPathSimple(name, path) => {\n-                    ViewPathSimple(name, fld.fold_path(path))\n-                }\n-                ViewPathGlob(path) => {\n-                    ViewPathGlob(fld.fold_path(path))\n-                }\n-                ViewPathList(path, path_list_idents) => {\n-                    ViewPathList(fld.fold_path(path),\n-                                 path_list_idents.move_map(|path_list_ident| {\n-                                     Spanned {\n-                                         node: PathListItem_ {\n-                                             id: fld.new_id(path_list_ident.node.id),\n-                                             name: path_list_ident.node.name,\n-                                             rename: path_list_ident.node.rename,\n-                                         },\n-                                         span: fld.new_span(path_list_ident.span),\n-                                     }\n-                                 }))\n-                }\n-            },\n-            span: fld.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn fold_attrs<T, F>(attrs: T, fld: &mut F) -> T\n-    where T: Into<Vec<Attribute>> + From<Vec<Attribute>>,\n-          F: Folder,\n-{\n-    attrs.into().move_flat_map(|x| fld.fold_attribute(x)).into()\n-}\n-\n-pub fn noop_fold_arm<T: Folder>(Arm { attrs, pats, guard, body }: Arm, fld: &mut T) -> Arm {\n-    Arm {\n-        attrs: fold_attrs(attrs, fld),\n-        pats: pats.move_map(|x| fld.fold_pat(x)),\n-        guard: guard.map(|x| fld.fold_expr(x)),\n-        body: fld.fold_expr(body),\n-    }\n-}\n-\n-pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> P<Decl> {\n-    d.map(|Spanned { node, span }| {\n-        match node {\n-            DeclLocal(l) => Spanned {\n-                node: DeclLocal(fld.fold_local(l)),\n-                span: fld.new_span(span),\n-            },\n-            DeclItem(it) => Spanned {\n-                node: DeclItem(fld.fold_item_id(it)),\n-                span: fld.new_span(span),\n-            },\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_ty_binding<T: Folder>(b: TypeBinding, fld: &mut T) -> TypeBinding {\n-    TypeBinding {\n-        id: fld.new_id(b.id),\n-        name: b.name,\n-        ty: fld.fold_ty(b.ty),\n-        span: fld.new_span(b.span),\n-    }\n-}\n-\n-pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n-    t.map(|Ty { id, node, span }| {\n-        Ty {\n-            id: fld.new_id(id),\n-            node: match node {\n-                TyInfer => node,\n-                TyVec(ty) => TyVec(fld.fold_ty(ty)),\n-                TyPtr(mt) => TyPtr(fld.fold_mt(mt)),\n-                TyRptr(region, mt) => {\n-                    TyRptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n-                }\n-                TyBareFn(f) => {\n-                    TyBareFn(f.map(|BareFnTy { lifetimes, unsafety, abi, decl }| {\n-                        BareFnTy {\n-                            lifetimes: fld.fold_lifetime_defs(lifetimes),\n-                            unsafety: unsafety,\n-                            abi: abi,\n-                            decl: fld.fold_fn_decl(decl),\n-                        }\n-                    }))\n-                }\n-                TyNever => node,\n-                TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n-                TyPath(qself, path) => {\n-                    let qself = qself.map(|QSelf { ty, position }| {\n-                        QSelf {\n-                            ty: fld.fold_ty(ty),\n-                            position: position,\n-                        }\n-                    });\n-                    TyPath(qself, fld.fold_path(path))\n-                }\n-                TyObjectSum(ty, bounds) => {\n-                    TyObjectSum(fld.fold_ty(ty), fld.fold_bounds(bounds))\n-                }\n-                TyFixedLengthVec(ty, e) => {\n-                    TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n-                }\n-                TyTypeof(expr) => {\n-                    TyTypeof(fld.fold_expr(expr))\n-                }\n-                TyPolyTraitRef(bounds) => {\n-                    TyPolyTraitRef(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n-                }\n-                TyImplTrait(bounds) => {\n-                    TyImplTrait(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n-                }\n-            },\n-            span: fld.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod { abi, items }: ForeignMod,\n-                                        fld: &mut T)\n-                                        -> ForeignMod {\n-    ForeignMod {\n-        abi: abi,\n-        items: items.move_map(|x| fld.fold_foreign_item(x)),\n-    }\n-}\n-\n-pub fn noop_fold_variant<T: Folder>(v: Variant, fld: &mut T) -> Variant {\n-    Spanned {\n-        node: Variant_ {\n-            name: v.node.name,\n-            attrs: fold_attrs(v.node.attrs, fld),\n-            data: fld.fold_variant_data(v.node.data),\n-            disr_expr: v.node.disr_expr.map(|e| fld.fold_expr(e)),\n-        },\n-        span: fld.new_span(v.span),\n-    }\n-}\n-\n-pub fn noop_fold_name<T: Folder>(n: Name, _: &mut T) -> Name {\n-    n\n-}\n-\n-pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n-    i\n-}\n-\n-pub fn noop_fold_path<T: Folder>(Path { global, segments, span }: Path, fld: &mut T) -> Path {\n-    Path {\n-        global: global,\n-        segments: segments.move_map(|PathSegment { name, parameters }| {\n-            PathSegment {\n-                name: fld.fold_name(name),\n-                parameters: fld.fold_path_parameters(parameters),\n-            }\n-        }),\n-        span: fld.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_path_parameters<T: Folder>(path_parameters: PathParameters,\n-                                            fld: &mut T)\n-                                            -> PathParameters {\n-    match path_parameters {\n-        AngleBracketedParameters(data) =>\n-            AngleBracketedParameters(fld.fold_angle_bracketed_parameter_data(data)),\n-        ParenthesizedParameters(data) =>\n-            ParenthesizedParameters(fld.fold_parenthesized_parameter_data(data)),\n-    }\n-}\n-\n-pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedParameterData,\n-                                                           fld: &mut T)\n-                                                           -> AngleBracketedParameterData {\n-    let AngleBracketedParameterData { lifetimes, types, bindings } = data;\n-    AngleBracketedParameterData {\n-        lifetimes: fld.fold_lifetimes(lifetimes),\n-        types: types.move_map(|ty| fld.fold_ty(ty)),\n-        bindings: bindings.move_map(|b| fld.fold_ty_binding(b)),\n-    }\n-}\n-\n-pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,\n-                                                         fld: &mut T)\n-                                                         -> ParenthesizedParameterData {\n-    let ParenthesizedParameterData { inputs, output, span } = data;\n-    ParenthesizedParameterData {\n-        inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n-        output: output.map(|ty| fld.fold_ty(ty)),\n-        span: fld.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n-    l.map(|Local { id, pat, ty, init, span, attrs }| {\n-        Local {\n-            id: fld.new_id(id),\n-            ty: ty.map(|t| fld.fold_ty(t)),\n-            pat: fld.fold_pat(pat),\n-            init: init.map(|e| fld.fold_expr(e)),\n-            span: fld.new_span(span),\n-            attrs: fold_attrs(attrs, fld),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attribute> {\n-    let Spanned {node: Attribute_ {id, style, value, is_sugared_doc}, span} = at;\n-    Some(Spanned {\n-        node: Attribute_ {\n-            id: id,\n-            style: style,\n-            value: fld.fold_meta_item(value),\n-            is_sugared_doc: is_sugared_doc,\n-        },\n-        span: fld.new_span(span),\n-    })\n-}\n-\n-pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)\n-    -> NestedMetaItem {\n-    Spanned {\n-        node: match li.node {\n-            NestedMetaItemKind::MetaItem(mi) =>  {\n-                NestedMetaItemKind::MetaItem(fld.fold_meta_item(mi))\n-            },\n-            NestedMetaItemKind::Literal(lit) => NestedMetaItemKind::Literal(lit)\n-        },\n-        span: fld.new_span(li.span)\n-    }\n-}\n-\n-pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n-    mi.map(|Spanned { node, span }| {\n-        Spanned {\n-            node: match node {\n-                MetaItemKind::Word(id) => MetaItemKind::Word(id),\n-                MetaItemKind::List(id, mis) => {\n-                    MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_list_item(e)))\n-                }\n-                MetaItemKind::NameValue(id, s) => MetaItemKind::NameValue(id, s),\n-            },\n-            span: fld.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_arg<T: Folder>(Arg { id, pat, ty }: Arg, fld: &mut T) -> Arg {\n-    Arg {\n-        id: fld.new_id(id),\n-        pat: fld.fold_pat(pat),\n-        ty: fld.fold_ty(ty),\n-    }\n-}\n-\n-pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n-    decl.map(|FnDecl { inputs, output, variadic }| {\n-        FnDecl {\n-            inputs: inputs.move_map(|x| fld.fold_arg(x)),\n-            output: match output {\n-                Return(ty) => Return(fld.fold_ty(ty)),\n-                DefaultReturn(span) => DefaultReturn(span),\n-            },\n-            variadic: variadic,\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T) -> TyParamBound\n-    where T: Folder\n-{\n-    match tpb {\n-        TraitTyParamBound(ty, modifier) => TraitTyParamBound(fld.fold_poly_trait_ref(ty), modifier),\n-        RegionTyParamBound(lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n-    }\n-}\n-\n-pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n-    let TyParam {id, name, bounds, default, span} = tp;\n-    TyParam {\n-        id: fld.new_id(id),\n-        name: name,\n-        bounds: fld.fold_bounds(bounds),\n-        default: default.map(|x| fld.fold_ty(x)),\n-        span: span,\n-    }\n-}\n-\n-pub fn noop_fold_ty_params<T: Folder>(tps: HirVec<TyParam>,\n-                                      fld: &mut T)\n-                                      -> HirVec<TyParam> {\n-    tps.move_map(|tp| fld.fold_ty_param(tp))\n-}\n-\n-pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n-    Lifetime {\n-        id: fld.new_id(l.id),\n-        name: l.name,\n-        span: fld.new_span(l.span),\n-    }\n-}\n-\n-pub fn noop_fold_lifetime_def<T: Folder>(l: LifetimeDef, fld: &mut T) -> LifetimeDef {\n-    LifetimeDef {\n-        lifetime: fld.fold_lifetime(l.lifetime),\n-        bounds: fld.fold_lifetimes(l.bounds),\n-    }\n-}\n-\n-pub fn noop_fold_lifetimes<T: Folder>(lts: HirVec<Lifetime>, fld: &mut T) -> HirVec<Lifetime> {\n-    lts.move_map(|l| fld.fold_lifetime(l))\n-}\n-\n-pub fn noop_fold_lifetime_defs<T: Folder>(lts: HirVec<LifetimeDef>,\n-                                          fld: &mut T)\n-                                          -> HirVec<LifetimeDef> {\n-    lts.move_map(|l| fld.fold_lifetime_def(l))\n-}\n-\n-pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: Option<Lifetime>, fld: &mut T) -> Option<Lifetime> {\n-    o_lt.map(|lt| fld.fold_lifetime(lt))\n-}\n-\n-pub fn noop_fold_generics<T: Folder>(Generics {ty_params, lifetimes, where_clause, span}: Generics,\n-                                     fld: &mut T)\n-                                     -> Generics {\n-    Generics {\n-        ty_params: fld.fold_ty_params(ty_params),\n-        lifetimes: fld.fold_lifetime_defs(lifetimes),\n-        where_clause: fld.fold_where_clause(where_clause),\n-        span: fld.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_where_clause<T: Folder>(WhereClause { id, predicates }: WhereClause,\n-                                         fld: &mut T)\n-                                         -> WhereClause {\n-    WhereClause {\n-        id: fld.new_id(id),\n-        predicates: predicates.move_map(|predicate| fld.fold_where_predicate(predicate)),\n-    }\n-}\n-\n-pub fn noop_fold_where_predicate<T: Folder>(pred: WherePredicate, fld: &mut T) -> WherePredicate {\n-    match pred {\n-        hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{bound_lifetimes,\n-                                                                     bounded_ty,\n-                                                                     bounds,\n-                                                                     span}) => {\n-            hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                bound_lifetimes: fld.fold_lifetime_defs(bound_lifetimes),\n-                bounded_ty: fld.fold_ty(bounded_ty),\n-                bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n-                span: fld.new_span(span),\n-            })\n-        }\n-        hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{lifetime,\n-                                                                       bounds,\n-                                                                       span}) => {\n-            hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                span: fld.new_span(span),\n-                lifetime: fld.fold_lifetime(lifetime),\n-                bounds: bounds.move_map(|bound| fld.fold_lifetime(bound)),\n-            })\n-        }\n-        hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{id,\n-                                                               path,\n-                                                               ty,\n-                                                               span}) => {\n-            hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                id: fld.new_id(id),\n-                path: fld.fold_path(path),\n-                ty: fld.fold_ty(ty),\n-                span: fld.new_span(span),\n-            })\n-        }\n-    }\n-}\n-\n-pub fn noop_fold_variant_data<T: Folder>(vdata: VariantData, fld: &mut T) -> VariantData {\n-    match vdata {\n-        VariantData::Struct(fields, id) => {\n-            VariantData::Struct(fields.move_map(|f| fld.fold_struct_field(f)),\n-                                fld.new_id(id))\n-        }\n-        VariantData::Tuple(fields, id) => {\n-            VariantData::Tuple(fields.move_map(|f| fld.fold_struct_field(f)),\n-                               fld.new_id(id))\n-        }\n-        VariantData::Unit(id) => VariantData::Unit(fld.new_id(id)),\n-    }\n-}\n-\n-pub fn noop_fold_trait_ref<T: Folder>(p: TraitRef, fld: &mut T) -> TraitRef {\n-    let id = fld.new_id(p.ref_id);\n-    let TraitRef {\n-        path,\n-        ref_id: _,\n-    } = p;\n-    hir::TraitRef {\n-        path: fld.fold_path(path),\n-        ref_id: id,\n-    }\n-}\n-\n-pub fn noop_fold_poly_trait_ref<T: Folder>(p: PolyTraitRef, fld: &mut T) -> PolyTraitRef {\n-    hir::PolyTraitRef {\n-        bound_lifetimes: fld.fold_lifetime_defs(p.bound_lifetimes),\n-        trait_ref: fld.fold_trait_ref(p.trait_ref),\n-        span: fld.new_span(p.span),\n-    }\n-}\n-\n-pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructField {\n-    StructField {\n-        span: fld.new_span(f.span),\n-        id: fld.new_id(f.id),\n-        name: f.name,\n-        vis: f.vis,\n-        ty: fld.fold_ty(f.ty),\n-        attrs: fold_attrs(f.attrs, fld),\n-    }\n-}\n-\n-pub fn noop_fold_field<T: Folder>(Field { name, expr, span }: Field, folder: &mut T) -> Field {\n-    Field {\n-        name: respan(folder.new_span(name.span), folder.fold_name(name.node)),\n-        expr: folder.fold_expr(expr),\n-        span: folder.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_mt<T: Folder>(MutTy { ty, mutbl }: MutTy, folder: &mut T) -> MutTy {\n-    MutTy {\n-        ty: folder.fold_ty(ty),\n-        mutbl: mutbl,\n-    }\n-}\n-\n-pub fn noop_fold_opt_bounds<T: Folder>(b: Option<TyParamBounds>,\n-                                       folder: &mut T)\n-                                       -> Option<TyParamBounds> {\n-    b.map(|bounds| folder.fold_bounds(bounds))\n-}\n-\n-fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T) -> TyParamBounds {\n-    bounds.move_map(|bound| folder.fold_ty_param_bound(bound))\n-}\n-\n-pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    b.map(|Block { id, stmts, expr, rules, span }| {\n-        Block {\n-            id: folder.new_id(id),\n-            stmts: stmts.move_map(|s| folder.fold_stmt(s)),\n-            expr: expr.map(|x| folder.fold_expr(x)),\n-            rules: rules,\n-            span: folder.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n-    match i {\n-        ItemExternCrate(string) => ItemExternCrate(string),\n-        ItemUse(view_path) => {\n-            ItemUse(folder.fold_view_path(view_path))\n-        }\n-        ItemStatic(t, m, e) => {\n-            ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n-        }\n-        ItemConst(t, e) => {\n-            ItemConst(folder.fold_ty(t), folder.fold_expr(e))\n-        }\n-        ItemFn(decl, unsafety, constness, abi, generics, body) => {\n-            ItemFn(folder.fold_fn_decl(decl),\n-                   unsafety,\n-                   constness,\n-                   abi,\n-                   folder.fold_generics(generics),\n-                   folder.fold_block(body))\n-        }\n-        ItemMod(m) => ItemMod(folder.fold_mod(m)),\n-        ItemForeignMod(nm) => ItemForeignMod(folder.fold_foreign_mod(nm)),\n-        ItemTy(t, generics) => {\n-            ItemTy(folder.fold_ty(t), folder.fold_generics(generics))\n-        }\n-        ItemEnum(enum_definition, generics) => {\n-            ItemEnum(hir::EnumDef {\n-                         variants: enum_definition.variants.move_map(|x| folder.fold_variant(x)),\n-                     },\n-                     folder.fold_generics(generics))\n-        }\n-        ItemStruct(struct_def, generics) => {\n-            let struct_def = folder.fold_variant_data(struct_def);\n-            ItemStruct(struct_def, folder.fold_generics(generics))\n-        }\n-        ItemUnion(struct_def, generics) => {\n-            let struct_def = folder.fold_variant_data(struct_def);\n-            ItemUnion(struct_def, folder.fold_generics(generics))\n-        }\n-        ItemDefaultImpl(unsafety, ref trait_ref) => {\n-            ItemDefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n-        }\n-        ItemImpl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n-            let new_impl_items = impl_items\n-                .move_map(|item| folder.fold_impl_item(item));\n-            let ifce = match ifce {\n-                None => None,\n-                Some(ref trait_ref) => {\n-                    Some(folder.fold_trait_ref((*trait_ref).clone()))\n-                }\n-            };\n-            ItemImpl(unsafety,\n-                     polarity,\n-                     folder.fold_generics(generics),\n-                     ifce,\n-                     folder.fold_ty(ty),\n-                     new_impl_items)\n-        }\n-        ItemTrait(unsafety, generics, bounds, items) => {\n-            let bounds = folder.fold_bounds(bounds);\n-            let items = items.move_map(|item| folder.fold_trait_item(item));\n-            ItemTrait(unsafety, folder.fold_generics(generics), bounds, items)\n-        }\n-    }\n-}\n-\n-pub fn noop_fold_trait_item<T: Folder>(i: TraitItem,\n-                                       folder: &mut T)\n-                                       -> TraitItem {\n-    TraitItem {\n-        id: folder.new_id(i.id),\n-        name: folder.fold_name(i.name),\n-        attrs: fold_attrs(i.attrs, folder),\n-        node: match i.node {\n-            ConstTraitItem(ty, default) => {\n-                ConstTraitItem(folder.fold_ty(ty), default.map(|x| folder.fold_expr(x)))\n-            }\n-            MethodTraitItem(sig, body) => {\n-                MethodTraitItem(noop_fold_method_sig(sig, folder),\n-                                body.map(|x| folder.fold_block(x)))\n-            }\n-            TypeTraitItem(bounds, default) => {\n-                TypeTraitItem(folder.fold_bounds(bounds),\n-                              default.map(|x| folder.fold_ty(x)))\n-            }\n-        },\n-        span: folder.new_span(i.span),\n-    }\n-}\n-\n-pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T) -> ImplItem {\n-    ImplItem {\n-        id: folder.new_id(i.id),\n-        name: folder.fold_name(i.name),\n-        attrs: fold_attrs(i.attrs, folder),\n-        vis: i.vis,\n-        defaultness: i.defaultness,\n-        node: match i.node {\n-            ImplItemKind::Const(ty, expr) => {\n-                ImplItemKind::Const(folder.fold_ty(ty), folder.fold_expr(expr))\n-            }\n-            ImplItemKind::Method(sig, body) => {\n-                ImplItemKind::Method(noop_fold_method_sig(sig, folder), folder.fold_block(body))\n-            }\n-            ImplItemKind::Type(ty) => ImplItemKind::Type(folder.fold_ty(ty)),\n-        },\n-        span: folder.new_span(i.span),\n-    }\n-}\n-\n-pub fn noop_fold_mod<T: Folder>(Mod { inner, item_ids }: Mod, folder: &mut T) -> Mod {\n-    Mod {\n-        inner: folder.new_span(inner),\n-        item_ids: item_ids.move_map(|x| folder.fold_item_id(x)),\n-    }\n-}\n-\n-pub fn noop_fold_crate<T: Folder>(Crate { module, attrs, config, span,\n-                                          exported_macros, items }: Crate,\n-                                  folder: &mut T)\n-                                  -> Crate {\n-    let config = folder.fold_meta_items(config);\n-\n-    let crate_mod = folder.fold_item(hir::Item {\n-        name: keywords::Invalid.name(),\n-        attrs: attrs,\n-        id: DUMMY_NODE_ID,\n-        vis: hir::Public,\n-        span: span,\n-        node: hir::ItemMod(module),\n-    });\n-\n-    let (module, attrs, span) = match crate_mod {\n-        hir::Item { attrs, span, node, .. } => {\n-            match node {\n-                hir::ItemMod(m) => (m, attrs, span),\n-                _ => panic!(\"fold converted a module to not a module\"),\n-            }\n-        }\n-    };\n-\n-    let items = items.into_iter()\n-                     .map(|(id, item)| (id, folder.fold_item(item)))\n-                     .collect();\n-\n-    Crate {\n-        module: module,\n-        attrs: attrs,\n-        config: config,\n-        span: span,\n-        exported_macros: exported_macros,\n-        items: items,\n-    }\n-}\n-\n-pub fn noop_fold_item_id<T: Folder>(i: ItemId, folder: &mut T) -> ItemId {\n-    let id = folder.map_id(i.id);\n-    ItemId { id: id }\n-}\n-\n-// fold one item into one item\n-pub fn noop_fold_item<T: Folder>(item: Item, folder: &mut T) -> Item {\n-    let Item { id, name, attrs, node, vis, span } = item;\n-    let id = folder.new_id(id);\n-    let node = folder.fold_item_underscore(node);\n-\n-    Item {\n-        id: id,\n-        name: folder.fold_name(name),\n-        attrs: fold_attrs(attrs, folder),\n-        node: node,\n-        vis: vis,\n-        span: folder.new_span(span),\n-    }\n-}\n-\n-pub fn noop_fold_foreign_item<T: Folder>(ni: ForeignItem, folder: &mut T) -> ForeignItem {\n-    ForeignItem {\n-        id: folder.new_id(ni.id),\n-        name: folder.fold_name(ni.name),\n-        attrs: fold_attrs(ni.attrs, folder),\n-        node: match ni.node {\n-            ForeignItemFn(fdec, generics) => {\n-                ForeignItemFn(folder.fold_fn_decl(fdec), folder.fold_generics(generics))\n-            }\n-            ForeignItemStatic(t, m) => {\n-                ForeignItemStatic(folder.fold_ty(t), m)\n-            }\n-        },\n-        vis: ni.vis,\n-        span: folder.new_span(ni.span),\n-    }\n-}\n-\n-pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> MethodSig {\n-    MethodSig {\n-        generics: folder.fold_generics(sig.generics),\n-        abi: sig.abi,\n-        unsafety: sig.unsafety,\n-        constness: sig.constness,\n-        decl: folder.fold_fn_decl(sig.decl),\n-    }\n-}\n-\n-pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n-    p.map(|Pat { id, node, span }| {\n-        Pat {\n-            id: folder.new_id(id),\n-            node: match node {\n-                PatKind::Wild => PatKind::Wild,\n-                PatKind::Binding(binding_mode, pth1, sub) => {\n-                    PatKind::Binding(binding_mode,\n-                             Spanned {\n-                                 span: folder.new_span(pth1.span),\n-                                 node: folder.fold_name(pth1.node),\n-                             },\n-                             sub.map(|x| folder.fold_pat(x)))\n-                }\n-                PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n-                PatKind::TupleStruct(pth, pats, ddpos) => {\n-                    PatKind::TupleStruct(folder.fold_path(pth),\n-                            pats.move_map(|x| folder.fold_pat(x)), ddpos)\n-                }\n-                PatKind::Path(opt_qself, pth) => {\n-                    let opt_qself = opt_qself.map(|qself| {\n-                        QSelf { ty: folder.fold_ty(qself.ty), position: qself.position }\n-                    });\n-                    PatKind::Path(opt_qself, folder.fold_path(pth))\n-                }\n-                PatKind::Struct(pth, fields, etc) => {\n-                    let pth = folder.fold_path(pth);\n-                    let fs = fields.move_map(|f| {\n-                        Spanned {\n-                            span: folder.new_span(f.span),\n-                            node: hir::FieldPat {\n-                                name: f.node.name,\n-                                pat: folder.fold_pat(f.node.pat),\n-                                is_shorthand: f.node.is_shorthand,\n-                            },\n-                        }\n-                    });\n-                    PatKind::Struct(pth, fs, etc)\n-                }\n-                PatKind::Tuple(elts, ddpos) => {\n-                    PatKind::Tuple(elts.move_map(|x| folder.fold_pat(x)), ddpos)\n-                }\n-                PatKind::Box(inner) => PatKind::Box(folder.fold_pat(inner)),\n-                PatKind::Ref(inner, mutbl) => PatKind::Ref(folder.fold_pat(inner), mutbl),\n-                PatKind::Range(e1, e2) => {\n-                    PatKind::Range(folder.fold_expr(e1), folder.fold_expr(e2))\n-                }\n-                PatKind::Vec(before, slice, after) => {\n-                    PatKind::Vec(before.move_map(|x| folder.fold_pat(x)),\n-                           slice.map(|x| folder.fold_pat(x)),\n-                           after.move_map(|x| folder.fold_pat(x)))\n-                }\n-            },\n-            span: folder.new_span(span),\n-        }\n-    })\n-}\n-\n-pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &mut T) -> Expr {\n-    Expr {\n-        id: folder.new_id(id),\n-        node: match node {\n-            ExprBox(e) => {\n-                ExprBox(folder.fold_expr(e))\n-            }\n-            ExprVec(exprs) => {\n-                ExprVec(exprs.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprRepeat(expr, count) => {\n-                ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count))\n-            }\n-            ExprTup(elts) => ExprTup(elts.move_map(|x| folder.fold_expr(x))),\n-            ExprCall(f, args) => {\n-                ExprCall(folder.fold_expr(f), args.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprMethodCall(name, tps, args) => {\n-                ExprMethodCall(respan(folder.new_span(name.span), folder.fold_name(name.node)),\n-                               tps.move_map(|x| folder.fold_ty(x)),\n-                               args.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprBinary(binop, lhs, rhs) => {\n-                ExprBinary(binop, folder.fold_expr(lhs), folder.fold_expr(rhs))\n-            }\n-            ExprUnary(binop, ohs) => {\n-                ExprUnary(binop, folder.fold_expr(ohs))\n-            }\n-            ExprLit(l) => ExprLit(l),\n-            ExprCast(expr, ty) => {\n-                ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))\n-            }\n-            ExprType(expr, ty) => {\n-                ExprType(folder.fold_expr(expr), folder.fold_ty(ty))\n-            }\n-            ExprAddrOf(m, ohs) => ExprAddrOf(m, folder.fold_expr(ohs)),\n-            ExprIf(cond, tr, fl) => {\n-                ExprIf(folder.fold_expr(cond),\n-                       folder.fold_block(tr),\n-                       fl.map(|x| folder.fold_expr(x)))\n-            }\n-            ExprWhile(cond, body, opt_name) => {\n-                ExprWhile(folder.fold_expr(cond),\n-                          folder.fold_block(body),\n-                          opt_name.map(|label| {\n-                              respan(folder.new_span(label.span), folder.fold_name(label.node))\n-                          }))\n-            }\n-            ExprLoop(body, opt_name) => {\n-                ExprLoop(folder.fold_block(body),\n-                         opt_name.map(|label| {\n-                             respan(folder.new_span(label.span), folder.fold_name(label.node))\n-                         }))\n-            }\n-            ExprMatch(expr, arms, source) => {\n-                ExprMatch(folder.fold_expr(expr),\n-                          arms.move_map(|x| folder.fold_arm(x)),\n-                          source)\n-            }\n-            ExprClosure(capture_clause, decl, body, fn_decl_span) => {\n-                ExprClosure(capture_clause,\n-                            folder.fold_fn_decl(decl),\n-                            folder.fold_block(body),\n-                            folder.new_span(fn_decl_span))\n-            }\n-            ExprBlock(blk) => ExprBlock(folder.fold_block(blk)),\n-            ExprAssign(el, er) => {\n-                ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n-            }\n-            ExprAssignOp(op, el, er) => {\n-                ExprAssignOp(op, folder.fold_expr(el), folder.fold_expr(er))\n-            }\n-            ExprField(el, name) => {\n-                ExprField(folder.fold_expr(el),\n-                          respan(folder.new_span(name.span), folder.fold_name(name.node)))\n-            }\n-            ExprTupField(el, index) => {\n-                ExprTupField(folder.fold_expr(el),\n-                             respan(folder.new_span(index.span), folder.fold_usize(index.node)))\n-            }\n-            ExprIndex(el, er) => {\n-                ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n-            }\n-            ExprPath(qself, path) => {\n-                let qself = qself.map(|QSelf { ty, position }| {\n-                    QSelf {\n-                        ty: folder.fold_ty(ty),\n-                        position: position,\n-                    }\n-                });\n-                ExprPath(qself, folder.fold_path(path))\n-            }\n-            ExprBreak(opt_name) => ExprBreak(opt_name.map(|label| {\n-                respan(folder.new_span(label.span), folder.fold_name(label.node))\n-            })),\n-            ExprAgain(opt_name) => ExprAgain(opt_name.map(|label| {\n-                respan(folder.new_span(label.span), folder.fold_name(label.node))\n-            })),\n-            ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),\n-            ExprInlineAsm(asm, outputs, inputs) => {\n-                ExprInlineAsm(asm,\n-                              outputs.move_map(|x| folder.fold_expr(x)),\n-                              inputs.move_map(|x| folder.fold_expr(x)))\n-            }\n-            ExprStruct(path, fields, maybe_expr) => {\n-                ExprStruct(folder.fold_path(path),\n-                           fields.move_map(|x| folder.fold_field(x)),\n-                           maybe_expr.map(|x| folder.fold_expr(x)))\n-            }\n-        },\n-        span: folder.new_span(span),\n-        attrs: fold_attrs(attrs, folder),\n-    }\n-}\n-\n-pub fn noop_fold_stmt<T: Folder>(stmt: Stmt, folder: &mut T) -> Stmt {\n-    let span = folder.new_span(stmt.span);\n-    match stmt.node {\n-        StmtDecl(d, id) => {\n-            let id = folder.new_id(id);\n-            Spanned {\n-                node: StmtDecl(folder.fold_decl(d), id),\n-                span: span\n-            }\n-        }\n-        StmtExpr(e, id) => {\n-            let id = folder.new_id(id);\n-            Spanned {\n-                node: StmtExpr(folder.fold_expr(e), id),\n-                span: span,\n-            }\n-        }\n-        StmtSemi(e, id) => {\n-            let id = folder.new_id(id);\n-            Spanned {\n-                node: StmtSemi(folder.fold_expr(e), id),\n-                span: span,\n-            }\n-        }\n-    }\n-}"}, {"sha": "b1771f52da2c6fef8b4fa31ade542c9ea393c380", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -394,7 +394,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     visitor.visit_id(typ.id);\n \n     match typ.node {\n-        TyVec(ref ty) => {\n+        TySlice(ref ty) => {\n             visitor.visit_ty(ty)\n         }\n         TyPtr(ref mutable_type) => {\n@@ -422,7 +422,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n-        TyFixedLengthVec(ref ty, ref expression) => {\n+        TyArray(ref ty, ref expression) => {\n             visitor.visit_ty(ty);\n             visitor.visit_expr(expression)\n         }\n@@ -520,7 +520,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n             visitor.visit_expr(upper_bound)\n         }\n         PatKind::Wild => (),\n-        PatKind::Vec(ref prepatterns, ref slice_pattern, ref postpatterns) => {\n+        PatKind::Slice(ref prepatterns, ref slice_pattern, ref postpatterns) => {\n             walk_list!(visitor, visit_pat, prepatterns);\n             walk_list!(visitor, visit_pat, slice_pattern);\n             walk_list!(visitor, visit_pat, postpatterns);\n@@ -749,7 +749,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprBox(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprVec(ref subexpressions) => {\n+        ExprArray(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n         ExprRepeat(ref element, ref count) => {\n@@ -881,8 +881,8 @@ pub struct IdRange {\n impl IdRange {\n     pub fn max() -> IdRange {\n         IdRange {\n-            min: u32::MAX,\n-            max: u32::MIN,\n+            min: NodeId::from_u32(u32::MAX),\n+            max: NodeId::from_u32(u32::MIN),\n         }\n     }\n \n@@ -896,7 +896,7 @@ impl IdRange {\n \n     pub fn add(&mut self, id: NodeId) {\n         self.min = cmp::min(self.min, id);\n-        self.max = cmp::max(self.max, id + 1);\n+        self.max = cmp::max(self.max, NodeId::from_u32(id.as_u32() + 1));\n     }\n \n }"}, {"sha": "620ee30c95628a100ca6ff35b01bc349fe76f1fe", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 57, "deletions": 75, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -61,7 +61,7 @@ use syntax_pos::Span;\n pub struct LoweringContext<'a> {\n     crate_root: Option<&'static str>,\n     // Use to assign ids to hir nodes that do not directly correspond to an ast node\n-    sess: Option<&'a Session>,\n+    sess: &'a Session,\n     // As we walk the AST we must keep track of the current 'parent' def id (in\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n@@ -81,21 +81,7 @@ pub trait Resolver {\n \n     // We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n     // This should only return `None` during testing.\n-    fn definitions(&mut self) -> Option<&mut Definitions>;\n-}\n-\n-pub struct DummyResolver;\n-impl Resolver for DummyResolver {\n-    fn resolve_generated_global_path(&mut self, _path: &hir::Path, _is_value: bool) -> Def {\n-        Def::Err\n-    }\n-    fn get_resolution(&mut self, _id: NodeId) -> Option<PathResolution> {\n-        None\n-    }\n-    fn record_resolution(&mut self, _id: NodeId, _def: Def) {}\n-    fn definitions(&mut self) -> Option<&mut Definitions> {\n-        None\n-    }\n+    fn definitions(&mut self) -> &mut Definitions;\n }\n \n pub fn lower_crate(sess: &Session,\n@@ -108,29 +94,14 @@ pub fn lower_crate(sess: &Session,\n     let _ignore = sess.dep_graph.in_ignore();\n \n     LoweringContext {\n-        crate_root: if std_inject::no_core(krate) {\n-            None\n-        } else if std_inject::no_std(krate) {\n-            Some(\"core\")\n-        } else {\n-            Some(\"std\")\n-        },\n-        sess: Some(sess),\n+        crate_root: std_inject::injected_crate_name(krate),\n+        sess: sess,\n         parent_def: None,\n         resolver: resolver,\n     }.lower_crate(krate)\n }\n \n impl<'a> LoweringContext<'a> {\n-    pub fn testing_context(resolver: &'a mut Resolver) -> Self {\n-        LoweringContext {\n-            crate_root: None,\n-            sess: None,\n-            parent_def: None,\n-            resolver: resolver,\n-        }\n-    }\n-\n     fn lower_crate(&mut self, c: &Crate) -> hir::Crate {\n         struct ItemLowerer<'lcx, 'interner: 'lcx> {\n             items: BTreeMap<NodeId, hir::Item>,\n@@ -153,20 +124,18 @@ impl<'a> LoweringContext<'a> {\n         hir::Crate {\n             module: self.lower_mod(&c.module),\n             attrs: self.lower_attrs(&c.attrs),\n-            config: c.config.clone().into(),\n             span: c.span,\n             exported_macros: c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect(),\n             items: items,\n         }\n     }\n \n     fn next_id(&self) -> NodeId {\n-        self.sess.map(Session::next_node_id).unwrap_or(0)\n+        self.sess.next_node_id()\n     }\n \n     fn diagnostic(&self) -> &errors::Handler {\n-        self.sess.map(Session::diagnostic)\n-                 .unwrap_or_else(|| panic!(\"this lowerer cannot emit diagnostics\"))\n+        self.sess.diagnostic()\n     }\n \n     fn str_to_ident(&self, s: &'static str) -> Name {\n@@ -177,9 +146,9 @@ impl<'a> LoweringContext<'a> {\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n         let old_def = self.parent_def;\n-        self.parent_def = match self.resolver.definitions() {\n-            Some(defs) => Some(defs.opt_def_index(parent_id).unwrap()),\n-            None => old_def,\n+        self.parent_def = {\n+            let defs = self.resolver.definitions();\n+            Some(defs.opt_def_index(parent_id).unwrap())\n         };\n \n         let result = f(self);\n@@ -246,30 +215,31 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_ty(&mut self, t: &Ty) -> P<hir::Ty> {\n-        use syntax::ast::TyKind::*;\n         P(hir::Ty {\n             id: t.id,\n             node: match t.node {\n-                Infer | ImplicitSelf => hir::TyInfer,\n-                Vec(ref ty) => hir::TyVec(self.lower_ty(ty)),\n-                Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt)),\n-                Rptr(ref region, ref mt) => {\n+                TyKind::Infer | TyKind::ImplicitSelf => hir::TyInfer,\n+                TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty)),\n+                TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt)),\n+                TyKind::Rptr(ref region, ref mt) => {\n                     hir::TyRptr(self.lower_opt_lifetime(region), self.lower_mt(mt))\n                 }\n-                BareFn(ref f) => {\n+                TyKind::BareFn(ref f) => {\n                     hir::TyBareFn(P(hir::BareFnTy {\n                         lifetimes: self.lower_lifetime_defs(&f.lifetimes),\n                         unsafety: self.lower_unsafety(f.unsafety),\n                         abi: f.abi,\n                         decl: self.lower_fn_decl(&f.decl),\n                     }))\n                 }\n-                Never => hir::TyNever,\n-                Tup(ref tys) => hir::TyTup(tys.iter().map(|ty| self.lower_ty(ty)).collect()),\n-                Paren(ref ty) => {\n+                TyKind::Never => hir::TyNever,\n+                TyKind::Tup(ref tys) => {\n+                    hir::TyTup(tys.iter().map(|ty| self.lower_ty(ty)).collect())\n+                }\n+                TyKind::Paren(ref ty) => {\n                     return self.lower_ty(ty);\n                 }\n-                Path(ref qself, ref path) => {\n+                TyKind::Path(ref qself, ref path) => {\n                     let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n                         hir::QSelf {\n                             ty: self.lower_ty(ty),\n@@ -278,22 +248,22 @@ impl<'a> LoweringContext<'a> {\n                     });\n                     hir::TyPath(qself, self.lower_path(path))\n                 }\n-                ObjectSum(ref ty, ref bounds) => {\n+                TyKind::ObjectSum(ref ty, ref bounds) => {\n                     hir::TyObjectSum(self.lower_ty(ty), self.lower_bounds(bounds))\n                 }\n-                FixedLengthVec(ref ty, ref e) => {\n-                    hir::TyFixedLengthVec(self.lower_ty(ty), self.lower_expr(e))\n+                TyKind::Array(ref ty, ref e) => {\n+                    hir::TyArray(self.lower_ty(ty), self.lower_expr(e))\n                 }\n-                Typeof(ref expr) => {\n+                TyKind::Typeof(ref expr) => {\n                     hir::TyTypeof(self.lower_expr(expr))\n                 }\n-                PolyTraitRef(ref bounds) => {\n+                TyKind::PolyTraitRef(ref bounds) => {\n                     hir::TyPolyTraitRef(self.lower_bounds(bounds))\n                 }\n-                ImplTrait(ref bounds) => {\n+                TyKind::ImplTrait(ref bounds) => {\n                     hir::TyImplTrait(self.lower_bounds(bounds))\n                 }\n-                Mac(_) => panic!(\"TyMac should have been expanded by now.\"),\n+                TyKind::Mac(_) => panic!(\"TyMac should have been expanded by now.\"),\n             },\n             span: t.span,\n         })\n@@ -415,12 +385,22 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_ty_param(&mut self, tp: &TyParam) -> hir::TyParam {\n+        let mut name = tp.ident.name;\n+\n+        // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n+        // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n+        // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n+        if name == token::keywords::SelfType.name() {\n+            name = token::gensym(\"Self\");\n+        }\n+\n         hir::TyParam {\n             id: tp.id,\n-            name: tp.ident.name,\n+            name: name,\n             bounds: self.lower_bounds(&tp.bounds),\n             default: tp.default.as_ref().map(|x| self.lower_ty(x)),\n             span: tp.span,\n+            pure_wrt_drop: tp.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n         }\n     }\n \n@@ -440,6 +420,7 @@ impl<'a> LoweringContext<'a> {\n         hir::LifetimeDef {\n             lifetime: self.lower_lifetime(&l.lifetime),\n             bounds: self.lower_lifetimes(&l.bounds),\n+            pure_wrt_drop: l.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n         }\n     }\n \n@@ -561,6 +542,7 @@ impl<'a> LoweringContext<'a> {\n             name: respan(f.ident.span, f.ident.node.name),\n             expr: self.lower_expr(&f.expr),\n             span: f.span,\n+            is_shorthand: f.is_shorthand,\n         }\n     }\n \n@@ -734,8 +716,6 @@ impl<'a> LoweringContext<'a> {\n             id: m.id,\n             span: m.span,\n             imported_from: m.imported_from.map(|x| x.name),\n-            export: m.export,\n-            use_locally: m.use_locally,\n             allow_internal_unstable: m.allow_internal_unstable,\n             body: m.body.clone().into(),\n         }\n@@ -869,10 +849,9 @@ impl<'a> LoweringContext<'a> {\n                     })\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n-                PatKind::TupleStruct(ref pth, ref pats, ddpos) => {\n-                    hir::PatKind::TupleStruct(self.lower_path(pth),\n-                                              pats.iter().map(|x| self.lower_pat(x)).collect(),\n-                                              ddpos)\n+                PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n+                    hir::PatKind::TupleStruct(self.lower_path(path),\n+                                        pats.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n                 }\n                 PatKind::Path(ref opt_qself, ref path) => {\n                     let opt_qself = opt_qself.as_ref().map(|qself| {\n@@ -906,8 +885,8 @@ impl<'a> LoweringContext<'a> {\n                 PatKind::Range(ref e1, ref e2) => {\n                     hir::PatKind::Range(self.lower_expr(e1), self.lower_expr(e2))\n                 }\n-                PatKind::Vec(ref before, ref slice, ref after) => {\n-                    hir::PatKind::Vec(before.iter().map(|x| self.lower_pat(x)).collect(),\n+                PatKind::Slice(ref before, ref slice, ref after) => {\n+                    hir::PatKind::Slice(before.iter().map(|x| self.lower_pat(x)).collect(),\n                                 slice.as_ref().map(|x| self.lower_pat(x)),\n                                 after.iter().map(|x| self.lower_pat(x)).collect())\n                 }\n@@ -1046,7 +1025,7 @@ impl<'a> LoweringContext<'a> {\n                 }\n \n                 ExprKind::Vec(ref exprs) => {\n-                    hir::ExprVec(exprs.iter().map(|x| self.lower_expr(x)).collect())\n+                    hir::ExprArray(exprs.iter().map(|x| self.lower_expr(x)).collect())\n                 }\n                 ExprKind::Repeat(ref expr, ref count) => {\n                     let expr = self.lower_expr(expr);\n@@ -1239,7 +1218,7 @@ impl<'a> LoweringContext<'a> {\n                         alignstack,\n                         dialect,\n                         expn_id,\n-                    }) => hir::ExprInlineAsm(hir::InlineAsm {\n+                    }) => hir::ExprInlineAsm(P(hir::InlineAsm {\n                     inputs: inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n                     outputs: outputs.iter()\n                                     .map(|out| {\n@@ -1257,7 +1236,7 @@ impl<'a> LoweringContext<'a> {\n                     alignstack: alignstack,\n                     dialect: dialect,\n                     expn_id: expn_id,\n-                }, outputs.iter().map(|out| self.lower_expr(&out.expr)).collect(),\n+                }), outputs.iter().map(|out| self.lower_expr(&out.expr)).collect(),\n                    inputs.iter().map(|&(_, ref input)| self.lower_expr(input)).collect()),\n                 ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n                     hir::ExprStruct(self.lower_path(path),\n@@ -1703,6 +1682,7 @@ impl<'a> LoweringContext<'a> {\n             },\n             span: span,\n             expr: expr,\n+            is_shorthand: false,\n         }\n     }\n \n@@ -1719,9 +1699,10 @@ impl<'a> LoweringContext<'a> {\n         let expr_path = hir::ExprPath(None, self.path_ident(span, id));\n         let expr = self.expr(span, expr_path, ThinVec::new());\n \n-        let def = self.resolver.definitions().map(|defs| {\n-            Def::Local(defs.local_def_id(binding), binding)\n-        }).unwrap_or(Def::Err);\n+        let def = {\n+            let defs = self.resolver.definitions();\n+            Def::Local(defs.local_def_id(binding))\n+        };\n         self.resolver.record_resolution(expr.id, def);\n \n         expr\n@@ -1869,11 +1850,12 @@ impl<'a> LoweringContext<'a> {\n         let pat = self.pat(span, pat_ident);\n \n         let parent_def = self.parent_def;\n-        let def = self.resolver.definitions().map(|defs| {\n+        let def = {\n+            let defs = self.resolver.definitions();\n             let def_path_data = DefPathData::Binding(name.as_str());\n             let def_index = defs.create_def_with_parent(parent_def, pat.id, def_path_data);\n-            Def::Local(DefId::local(def_index), pat.id)\n-        }).unwrap_or(Def::Err);\n+            Def::Local(DefId::local(def_index))\n+        };\n         self.resolver.record_resolution(pat.id, def);\n \n         pat"}, {"sha": "3d9031a136e280cdbd0b5b0ac88178655f121825", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -27,6 +27,10 @@ pub struct NodeCollector<'ast> {\n     pub map: Vec<MapEntry<'ast>>,\n     /// The parent of this node\n     pub parent_node: NodeId,\n+    /// If true, completely ignore nested items. We set this when loading\n+    /// HIR from metadata, since in that case we only want the HIR for\n+    /// one specific item (and not the ones nested inside of it).\n+    pub ignore_nested_items: bool\n }\n \n impl<'ast> NodeCollector<'ast> {\n@@ -35,6 +39,7 @@ impl<'ast> NodeCollector<'ast> {\n             krate: krate,\n             map: vec![],\n             parent_node: CRATE_NODE_ID,\n+            ignore_nested_items: false\n         };\n         collector.insert_entry(CRATE_NODE_ID, RootCrate);\n \n@@ -52,6 +57,7 @@ impl<'ast> NodeCollector<'ast> {\n             krate: krate,\n             map: map,\n             parent_node: parent_node,\n+            ignore_nested_items: true\n         };\n \n         assert_eq!(parent_def_path.krate, parent_def_id.krate);\n@@ -63,10 +69,10 @@ impl<'ast> NodeCollector<'ast> {\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n         debug!(\"ast_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n-        if id as usize >= len {\n-            self.map.extend(repeat(NotPresent).take(id as usize - len + 1));\n+        if id.as_usize() >= len {\n+            self.map.extend(repeat(NotPresent).take(id.as_usize() - len + 1));\n         }\n-        self.map[id as usize] = entry;\n+        self.map[id.as_usize()] = entry;\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n@@ -88,7 +94,9 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     /// their outer items.\n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n-        self.visit_item(self.krate.item(item.id))\n+        if !self.ignore_nested_items {\n+            self.visit_item(self.krate.item(item.id))\n+        }\n     }\n \n     fn visit_item(&mut self, i: &'ast Item) {"}, {"sha": "421843a7f11d8752af6ac3bfa71126a14d68d097", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 89, "deletions": 69, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -17,44 +17,42 @@ use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n use middle::cstore::InlinedItem;\n \n use syntax::ast::*;\n+use syntax::ext::hygiene::Mark;\n use syntax::visit;\n-use syntax::parse::token;\n+use syntax::parse::token::{self, keywords};\n \n /// Creates def ids for nodes in the HIR.\n-pub struct DefCollector<'ast> {\n+pub struct DefCollector<'a> {\n     // If we are walking HIR (c.f., AST), we need to keep a reference to the\n     // crate.\n-    hir_crate: Option<&'ast hir::Crate>,\n-    definitions: &'ast mut Definitions,\n+    hir_crate: Option<&'a hir::Crate>,\n+    definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,\n+    pub visit_macro_invoc: Option<&'a mut FnMut(MacroInvocationData)>,\n }\n \n-impl<'ast> DefCollector<'ast> {\n-    pub fn root(definitions: &'ast mut Definitions) -> DefCollector<'ast> {\n-        let mut collector = DefCollector {\n+pub struct MacroInvocationData {\n+    pub mark: Mark,\n+    pub def_index: DefIndex,\n+    pub const_integer: bool,\n+}\n+\n+impl<'a> DefCollector<'a> {\n+    pub fn new(definitions: &'a mut Definitions) -> Self {\n+        DefCollector {\n             hir_crate: None,\n             definitions: definitions,\n             parent_def: None,\n-        };\n-        let root = collector.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n-        assert_eq!(root, CRATE_DEF_INDEX);\n-        collector.parent_def = Some(root);\n-\n-        collector.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n-\n-        collector\n+            visit_macro_invoc: None,\n+        }\n     }\n \n     pub fn extend(parent_node: NodeId,\n                   parent_def_path: DefPath,\n                   parent_def_id: DefId,\n-                  definitions: &'ast mut Definitions)\n-                  -> DefCollector<'ast> {\n-        let mut collector = DefCollector {\n-            hir_crate: None,\n-            parent_def: None,\n-            definitions: definitions,\n-        };\n+                  definitions: &'a mut Definitions)\n+                  -> Self {\n+        let mut collector = DefCollector::new(definitions);\n \n         assert_eq!(parent_def_path.krate, parent_def_id.krate);\n         let root_path = Box::new(InlinedRootPath {\n@@ -68,17 +66,21 @@ impl<'ast> DefCollector<'ast> {\n         collector\n     }\n \n-    pub fn walk_item(&mut self, ii: &'ast InlinedItem, krate: &'ast hir::Crate) {\n-        self.hir_crate = Some(krate);\n-        ii.visit(self);\n+    pub fn collect_root(&mut self) {\n+        let root = self.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n+        assert_eq!(root, CRATE_DEF_INDEX);\n+        self.parent_def = Some(root);\n+\n+        self.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n     }\n \n-    fn parent_def(&self) -> Option<DefIndex> {\n-        self.parent_def\n+    pub fn walk_item(&mut self, ii: &'a InlinedItem, krate: &'a hir::Crate) {\n+        self.hir_crate = Some(krate);\n+        ii.visit(self);\n     }\n \n     fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n-        let parent_def = self.parent_def();\n+        let parent_def = self.parent_def;\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n         self.definitions.create_def_with_parent(parent_def, node_id, data)\n     }\n@@ -91,29 +93,28 @@ impl<'ast> DefCollector<'ast> {\n         self.definitions.create_def_with_parent(parent, node_id, data)\n     }\n \n-    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n+    pub fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n         let parent = self.parent_def;\n         self.parent_def = Some(parent_def);\n         f(self);\n         self.parent_def = parent;\n     }\n \n-    fn visit_ast_const_integer(&mut self, expr: &Expr) {\n-        // Find the node which will be used after lowering.\n-        if let ExprKind::Paren(ref inner) = expr.node {\n-            return self.visit_ast_const_integer(inner);\n-        }\n-\n-        // FIXME(eddyb) Closures should have separate\n-        // function definition IDs and expression IDs.\n-        if let ExprKind::Closure(..) = expr.node {\n-            return;\n+    pub fn visit_ast_const_integer(&mut self, expr: &Expr) {\n+        match expr.node {\n+            // Find the node which will be used after lowering.\n+            ExprKind::Paren(ref inner) => return self.visit_ast_const_integer(inner),\n+            ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id, true),\n+            // FIXME(eddyb) Closures should have separate\n+            // function definition IDs and expression IDs.\n+            ExprKind::Closure(..) => return,\n+            _ => {}\n         }\n \n         self.create_def(expr.id, DefPathData::Initializer);\n     }\n \n-    fn visit_hir_const_integer(&mut self, expr: &'ast hir::Expr) {\n+    fn visit_hir_const_integer(&mut self, expr: &hir::Expr) {\n         // FIXME(eddyb) Closures should have separate\n         // function definition IDs and expression IDs.\n         if let hir::ExprClosure(..) = expr.node {\n@@ -122,9 +123,19 @@ impl<'ast> DefCollector<'ast> {\n \n         self.create_def(expr.id, DefPathData::Initializer);\n     }\n+\n+    fn visit_macro_invoc(&mut self, id: NodeId, const_integer: bool) {\n+        if let Some(ref mut visit) = self.visit_macro_invoc {\n+            visit(MacroInvocationData {\n+                mark: Mark::from_placeholder_id(id),\n+                const_integer: const_integer,\n+                def_index: self.parent_def.unwrap(),\n+            })\n+        }\n+    }\n }\n \n-impl<'ast> visit::Visitor for DefCollector<'ast> {\n+impl<'a> visit::Visitor for DefCollector<'a> {\n     fn visit_item(&mut self, i: &Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n@@ -136,10 +147,14 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) | ItemKind::Trait(..) |\n             ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n                 DefPathData::TypeNs(i.ident.name.as_str()),\n+            ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n+                return visit::walk_item(self, i);\n+            }\n             ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_str()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n                 DefPathData::ValueNs(i.ident.name.as_str()),\n-            ItemKind::Mac(..) => DefPathData::MacroDef(i.ident.name.as_str()),\n+            ItemKind::Mac(..) if i.id == DUMMY_NODE_ID => return, // Scope placeholder\n+            ItemKind::Mac(..) => return self.visit_macro_invoc(i.id, false),\n             ItemKind::Use(..) => DefPathData::Misc,\n         };\n         let def = self.create_def(i.id, def_data);\n@@ -205,7 +220,7 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n                 DefPathData::ValueNs(ti.ident.name.as_str()),\n             TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name.as_str()),\n-            TraitItemKind::Macro(..) => DefPathData::MacroDef(ti.ident.name.as_str()),\n+            TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id, false),\n         };\n \n         let def = self.create_def(ti.id, def_data);\n@@ -223,7 +238,7 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n                 DefPathData::ValueNs(ii.ident.name.as_str()),\n             ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name.as_str()),\n-            ImplItemKind::Macro(..) => DefPathData::MacroDef(ii.ident.name.as_str()),\n+            ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id, false),\n         };\n \n         let def = self.create_def(ii.id, def_data);\n@@ -239,9 +254,13 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n     fn visit_pat(&mut self, pat: &Pat) {\n         let parent_def = self.parent_def;\n \n-        if let PatKind::Ident(_, id, _) = pat.node {\n-            let def = self.create_def(pat.id, DefPathData::Binding(id.node.name.as_str()));\n-            self.parent_def = Some(def);\n+        match pat.node {\n+            PatKind::Mac(..) => return self.visit_macro_invoc(pat.id, false),\n+            PatKind::Ident(_, id, _) => {\n+                let def = self.create_def(pat.id, DefPathData::Binding(id.node.name.as_str()));\n+                self.parent_def = Some(def);\n+            }\n+            _ => {}\n         }\n \n         visit::walk_pat(self, pat);\n@@ -251,25 +270,28 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n     fn visit_expr(&mut self, expr: &Expr) {\n         let parent_def = self.parent_def;\n \n-        if let ExprKind::Repeat(_, ref count) = expr.node {\n-            self.visit_ast_const_integer(count);\n-        }\n-\n-        if let ExprKind::Closure(..) = expr.node {\n-            let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n-            self.parent_def = Some(def);\n+        match expr.node {\n+            ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id, false),\n+            ExprKind::Repeat(_, ref count) => self.visit_ast_const_integer(count),\n+            ExprKind::Closure(..) => {\n+                let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n+                self.parent_def = Some(def);\n+            }\n+            _ => {}\n         }\n \n         visit::walk_expr(self, expr);\n         self.parent_def = parent_def;\n     }\n \n     fn visit_ty(&mut self, ty: &Ty) {\n-        if let TyKind::FixedLengthVec(_, ref length) = ty.node {\n-            self.visit_ast_const_integer(length);\n-        }\n-        if let TyKind::ImplTrait(..) = ty.node {\n-            self.create_def(ty.id, DefPathData::ImplTrait);\n+        match ty.node {\n+            TyKind::Mac(..) => return self.visit_macro_invoc(ty.id, false),\n+            TyKind::Array(_, ref length) => self.visit_ast_const_integer(length),\n+            TyKind::ImplTrait(..) => {\n+                self.create_def(ty.id, DefPathData::ImplTrait);\n+            }\n+            _ => {}\n         }\n         visit::walk_ty(self, ty);\n     }\n@@ -281,19 +303,17 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n     fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n         self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name.as_str()));\n     }\n+\n+    fn visit_stmt(&mut self, stmt: &Stmt) {\n+        match stmt.node {\n+            StmtKind::Mac(..) => self.visit_macro_invoc(stmt.id, false),\n+            _ => visit::walk_stmt(self, stmt),\n+        }\n+    }\n }\n \n // We walk the HIR rather than the AST when reading items from metadata.\n impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n-    /// Because we want to track parent items and so forth, enable\n-    /// deep walking so that we walk nested items in the context of\n-    /// their outer items.\n-    fn visit_nested_item(&mut self, item_id: hir::ItemId) {\n-        debug!(\"visit_nested_item: {:?}\", item_id);\n-        let item = self.hir_crate.unwrap().item(item_id.id);\n-        self.visit_item(item)\n-    }\n-\n     fn visit_item(&mut self, i: &'ast hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n@@ -429,7 +449,7 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n     }\n \n     fn visit_ty(&mut self, ty: &'ast hir::Ty) {\n-        if let hir::TyFixedLengthVec(_, ref length) = ty.node {\n+        if let hir::TyArray(_, ref length) = ty.node {\n             self.visit_hir_const_integer(length);\n         }\n         if let hir::TyImplTrait(..) = ty.node {"}, {"sha": "e8b3714bbe3b885bbaa57035bd4a9ed344f8d30d", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::cstore::LOCAL_CRATE;\n-use hir::def_id::{DefId, DefIndex};\n-use hir::map::def_collector::DefCollector;\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use rustc_data_structures::fnv::FnvHashMap;\n use std::fmt::Write;\n-use std::hash::{Hash, Hasher, SipHasher};\n-use syntax::{ast, visit};\n-use syntax::parse::token::InternedString;\n+use std::hash::{Hash, Hasher};\n+use std::collections::hash_map::DefaultHasher;\n+use syntax::ast;\n+use syntax::parse::token::{self, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n \n@@ -70,15 +69,15 @@ pub struct DefPath {\n     pub data: Vec<DisambiguatedDefPathData>,\n \n     /// what krate root is this path relative to?\n-    pub krate: ast::CrateNum,\n+    pub krate: CrateNum,\n }\n \n impl DefPath {\n     pub fn is_local(&self) -> bool {\n         self.krate == LOCAL_CRATE\n     }\n \n-    pub fn make<FN>(start_krate: ast::CrateNum,\n+    pub fn make<FN>(start_krate: CrateNum,\n                     start_index: DefIndex,\n                     mut get_key: FN) -> DefPath\n         where FN: FnMut(DefIndex) -> DefKey\n@@ -116,11 +115,7 @@ impl DefPath {\n     pub fn to_string(&self, tcx: TyCtxt) -> String {\n         let mut s = String::with_capacity(self.data.len() * 16);\n \n-        if self.krate == LOCAL_CRATE {\n-            s.push_str(&tcx.crate_name(self.krate));\n-        } else {\n-            s.push_str(&tcx.sess.cstore.original_crate_name(self.krate));\n-        }\n+        s.push_str(&tcx.original_crate_name(self.krate));\n         s.push_str(\"/\");\n         s.push_str(&tcx.crate_disambiguator(self.krate));\n \n@@ -136,13 +131,13 @@ impl DefPath {\n     }\n \n     pub fn deterministic_hash(&self, tcx: TyCtxt) -> u64 {\n-        let mut state = SipHasher::new();\n+        let mut state = DefaultHasher::new();\n         self.deterministic_hash_to(tcx, &mut state);\n         state.finish()\n     }\n \n     pub fn deterministic_hash_to<H: Hasher>(&self, tcx: TyCtxt, state: &mut H) {\n-        tcx.crate_name(self.krate).hash(state);\n+        tcx.original_crate_name(self.krate).hash(state);\n         tcx.crate_disambiguator(self.krate).hash(state);\n         self.data.hash(state);\n     }\n@@ -229,11 +224,6 @@ impl Definitions {\n         }\n     }\n \n-    pub fn collect(&mut self, krate: &ast::Crate) {\n-        let mut def_collector = DefCollector::root(self);\n-        visit::walk_crate(&mut def_collector, krate);\n-    }\n-\n     /// Get the number of definitions.\n     pub fn len(&self) -> usize {\n         self.data.len()\n@@ -327,6 +317,30 @@ impl Definitions {\n }\n \n impl DefPathData {\n+    pub fn get_opt_name(&self) -> Option<ast::Name> {\n+        use self::DefPathData::*;\n+        match *self {\n+            TypeNs(ref name) |\n+            ValueNs(ref name) |\n+            Module(ref name) |\n+            MacroDef(ref name) |\n+            TypeParam(ref name) |\n+            LifetimeDef(ref name) |\n+            EnumVariant(ref name) |\n+            Binding(ref name) |\n+            Field(ref name) => Some(token::intern(name)),\n+\n+            Impl |\n+            CrateRoot |\n+            InlinedRoot(_) |\n+            Misc |\n+            ClosureExpr |\n+            StructCtor |\n+            Initializer |\n+            ImplTrait => None\n+        }\n+    }\n+\n     pub fn as_interned_str(&self) -> InternedString {\n         use self::DefPathData::*;\n         match *self {"}, {"sha": "39114ec4238e72a9682c6a7b99f87e6ed7fe48f1", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 30, "deletions": 102, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -11,7 +11,7 @@\n pub use self::Node::*;\n use self::MapEntry::*;\n use self::collector::NodeCollector;\n-use self::def_collector::DefCollector;\n+pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n                             DisambiguatedDefPathData, InlinedRootPath};\n \n@@ -22,17 +22,15 @@ use middle::cstore::InlinedItem as II;\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use syntax::abi::Abi;\n-use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, };\n+use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n use syntax_pos::Span;\n \n use hir::*;\n-use hir::fold::Folder;\n use hir::print as pprust;\n \n use arena::TypedArena;\n use std::cell::RefCell;\n-use std::cmp;\n use std::io;\n use std::mem;\n \n@@ -240,7 +238,7 @@ impl<'ast> Map<'ast> {\n         let mut id = id0;\n         if !self.is_inlined_node_id(id) {\n             loop {\n-                match map[id as usize] {\n+                match map[id.as_usize()] {\n                     EntryItem(_, item) => {\n                         let def_id = self.local_def_id(item.id);\n                         // NB                          ^~~~~~~\n@@ -262,7 +260,7 @@ impl<'ast> Map<'ast> {\n                     EntryVariant(p, _) |\n                     EntryExpr(p, _) |\n                     EntryStmt(p, _) |\n-                EntryTy(p, _) |\n+                    EntryTy(p, _) |\n                     EntryLocal(p, _) |\n                     EntryPat(p, _) |\n                     EntryBlock(p, _) |\n@@ -295,7 +293,7 @@ impl<'ast> Map<'ast> {\n             // reading from an inlined def-id is really a read out of\n             // the metadata from which we loaded the item.\n             loop {\n-                match map[id as usize] {\n+                match map[id.as_usize()] {\n                     EntryItem(p, _) |\n                     EntryForeignItem(p, _) |\n                     EntryTraitItem(p, _) |\n@@ -373,7 +371,7 @@ impl<'ast> Map<'ast> {\n     }\n \n     fn find_entry(&self, id: NodeId) -> Option<MapEntry<'ast>> {\n-        self.map.borrow().get(id as usize).cloned()\n+        self.map.borrow().get(id.as_usize()).cloned()\n     }\n \n     pub fn krate(&self) -> &'ast Crate {\n@@ -456,8 +454,8 @@ impl<'ast> Map<'ast> {\n         let mut id = start_id;\n         loop {\n             let parent_node = self.get_parent_node(id);\n-            if parent_node == 0 {\n-                return Ok(0);\n+            if parent_node == CRATE_NODE_ID {\n+                return Ok(CRATE_NODE_ID);\n             }\n             if parent_node == id {\n                 return Err(id);\n@@ -582,22 +580,24 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_struct(&self, id: NodeId) -> &'ast VariantData {\n+    pub fn expect_variant_data(&self, id: NodeId) -> &'ast VariantData {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n                 match i.node {\n-                    ItemStruct(ref struct_def, _) => struct_def,\n-                    _ => bug!(\"struct ID bound to non-struct\")\n+                    ItemStruct(ref struct_def, _) |\n+                    ItemUnion(ref struct_def, _) => struct_def,\n+                    _ => {\n+                        bug!(\"struct ID bound to non-struct {}\",\n+                             self.node_to_string(id));\n+                    }\n                 }\n             }\n-            Some(NodeVariant(variant)) => {\n-                if variant.node.data.is_struct() {\n-                    &variant.node.data\n-                } else {\n-                    bug!(\"struct ID bound to enum variant that isn't struct-like\")\n-                }\n+            Some(NodeStructCtor(data)) => data,\n+            Some(NodeVariant(variant)) => &variant.node.data,\n+            _ => {\n+                bug!(\"expected struct or variant, found {}\",\n+                     self.node_to_string(id));\n             }\n-            _ => bug!(\"expected struct, found {}\", self.node_to_string(id)),\n         }\n     }\n \n@@ -680,7 +680,7 @@ impl<'ast> Map<'ast> {\n             map: self,\n             item_name: parts.last().unwrap(),\n             in_which: &parts[..parts.len() - 1],\n-            idx: 0,\n+            idx: CRATE_NODE_ID,\n         }\n     }\n \n@@ -801,10 +801,10 @@ impl<'a, 'ast> Iterator for NodesMatchingSuffix<'a, 'ast> {\n     fn next(&mut self) -> Option<NodeId> {\n         loop {\n             let idx = self.idx;\n-            if idx as usize >= self.map.entry_count() {\n+            if idx.as_usize() >= self.map.entry_count() {\n                 return None;\n             }\n-            self.idx += 1;\n+            self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n             let name = match self.map.find_entry(idx) {\n                 Some(EntryItem(_, n))       => n.name(),\n                 Some(EntryForeignItem(_, n))=> n.name(),\n@@ -832,57 +832,6 @@ impl Named for Variant_ { fn name(&self) -> Name { self.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n-pub trait FoldOps {\n-    fn new_id(&self, id: NodeId) -> NodeId {\n-        id\n-    }\n-    fn new_def_id(&self, def_id: DefId) -> DefId {\n-        def_id\n-    }\n-    fn new_span(&self, span: Span) -> Span {\n-        span\n-    }\n-}\n-\n-/// A Folder that updates IDs and Span's according to fold_ops.\n-pub struct IdAndSpanUpdater<F> {\n-    fold_ops: F,\n-    min_id_assigned: NodeId,\n-    max_id_assigned: NodeId,\n-}\n-\n-impl<F: FoldOps> IdAndSpanUpdater<F> {\n-    pub fn new(fold_ops: F) -> IdAndSpanUpdater<F> {\n-        IdAndSpanUpdater {\n-            fold_ops: fold_ops,\n-            min_id_assigned: ::std::u32::MAX,\n-            max_id_assigned: ::std::u32::MIN,\n-        }\n-    }\n-\n-    pub fn id_range(&self) -> intravisit::IdRange {\n-        intravisit::IdRange {\n-            min: self.min_id_assigned,\n-            max: self.max_id_assigned + 1,\n-        }\n-    }\n-}\n-\n-impl<F: FoldOps> Folder for IdAndSpanUpdater<F> {\n-    fn new_id(&mut self, id: NodeId) -> NodeId {\n-        let id = self.fold_ops.new_id(id);\n-\n-        self.min_id_assigned = cmp::min(self.min_id_assigned, id);\n-        self.max_id_assigned = cmp::max(self.max_id_assigned, id);\n-\n-        id\n-    }\n-\n-    fn new_span(&mut self, span: Span) -> Span {\n-        self.fold_ops.new_span(span)\n-    }\n-}\n-\n pub fn map_crate<'ast>(forest: &'ast mut Forest,\n                        definitions: Definitions)\n                        -> Map<'ast> {\n@@ -906,7 +855,7 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    let local_node_id_watermark = map.len() as NodeId;\n+    let local_node_id_watermark = NodeId::new(map.len());\n     let local_def_id_watermark = definitions.len();\n \n     Map {\n@@ -921,36 +870,15 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n \n /// Used for items loaded from external crate that are being inlined into this\n /// crate.\n-pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n-                                          parent_def_path: DefPath,\n-                                          parent_def_id: DefId,\n-                                          ii: InlinedItem,\n-                                          fold_ops: F)\n-                                          -> &'ast InlinedItem {\n+pub fn map_decoded_item<'ast>(map: &Map<'ast>,\n+                              parent_def_path: DefPath,\n+                              parent_def_id: DefId,\n+                              ii: InlinedItem,\n+                              ii_parent_id: NodeId)\n+                              -> &'ast InlinedItem {\n     let _ignore = map.forest.dep_graph.in_ignore();\n \n-    let mut fld = IdAndSpanUpdater::new(fold_ops);\n-    let ii = match ii {\n-        II::Item(d, i) => II::Item(fld.fold_ops.new_def_id(d),\n-                                   i.map(|i| fld.fold_item(i))),\n-        II::TraitItem(d, ti) => {\n-            II::TraitItem(fld.fold_ops.new_def_id(d),\n-                          ti.map(|ti| fld.fold_trait_item(ti)))\n-        }\n-        II::ImplItem(d, ii) => {\n-            II::ImplItem(fld.fold_ops.new_def_id(d),\n-                         ii.map(|ii| fld.fold_impl_item(ii)))\n-        }\n-    };\n-\n     let ii = map.forest.inlined_items.alloc(ii);\n-    let ii_parent_id = fld.new_id(DUMMY_NODE_ID);\n-\n-    // Assert that the ii_parent_id is the last NodeId in our reserved range\n-    assert!(ii_parent_id == fld.max_id_assigned);\n-    // Assert that we did not violate the invariant that all inlined HIR items\n-    // have NodeIds greater than or equal to `local_node_id_watermark`\n-    assert!(fld.min_id_assigned >= map.local_node_id_watermark);\n \n     let defs = &mut *map.definitions.borrow_mut();\n     let mut def_collector = DefCollector::extend(ii_parent_id,"}, {"sha": "c451a789193aaecb0f917a69a3987eaf5282fa55", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -67,7 +67,6 @@ macro_rules! hir_vec {\n pub mod check_attr;\n pub mod def;\n pub mod def_id;\n-pub mod fold;\n pub mod intravisit;\n pub mod lowering;\n pub mod map;\n@@ -96,6 +95,7 @@ impl fmt::Debug for Lifetime {\n pub struct LifetimeDef {\n     pub lifetime: Lifetime,\n     pub bounds: HirVec<Lifetime>,\n+    pub pure_wrt_drop: bool,\n }\n \n /// A \"Path\" is essentially Rust's notion of a name; for instance:\n@@ -291,6 +291,7 @@ pub struct TyParam {\n     pub bounds: TyParamBounds,\n     pub default: Option<P<Ty>>,\n     pub span: Span,\n+    pub pure_wrt_drop: bool,\n }\n \n /// Represents lifetimes and type parameters attached to a declaration\n@@ -329,6 +330,36 @@ impl Generics {\n     }\n }\n \n+pub enum UnsafeGeneric {\n+    Region(LifetimeDef, &'static str),\n+    Type(TyParam, &'static str),\n+}\n+\n+impl UnsafeGeneric {\n+    pub fn attr_name(&self) -> &'static str {\n+        match *self {\n+            UnsafeGeneric::Region(_, s) => s,\n+            UnsafeGeneric::Type(_, s) => s,\n+        }\n+    }\n+}\n+\n+impl Generics {\n+    pub fn carries_unsafe_attr(&self) -> Option<UnsafeGeneric> {\n+        for r in &self.lifetimes {\n+            if r.pure_wrt_drop {\n+                return Some(UnsafeGeneric::Region(r.clone(), \"may_dangle\"));\n+            }\n+        }\n+        for t in &self.ty_params {\n+            if t.pure_wrt_drop {\n+                return Some(UnsafeGeneric::Type(t.clone(), \"may_dangle\"));\n+            }\n+        }\n+        return None;\n+    }\n+}\n+\n /// A `where` clause in a definition\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereClause {\n@@ -382,7 +413,6 @@ pub type CrateConfig = HirVec<P<MetaItem>>;\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: HirVec<Attribute>,\n-    pub config: CrateConfig,\n     pub span: Span,\n     pub exported_macros: HirVec<MacroDef>,\n \n@@ -427,8 +457,6 @@ pub struct MacroDef {\n     pub id: NodeId,\n     pub span: Span,\n     pub imported_from: Option<Name>,\n-    pub export: bool,\n-    pub use_locally: bool,\n     pub allow_internal_unstable: bool,\n     pub body: HirVec<TokenTree>,\n }\n@@ -479,7 +507,7 @@ impl Pat {\n             PatKind::Box(ref s) | PatKind::Ref(ref s, _) => {\n                 s.walk_(it)\n             }\n-            PatKind::Vec(ref before, ref slice, ref after) => {\n+            PatKind::Slice(ref before, ref slice, ref after) => {\n                 before.iter().all(|p| p.walk_(it)) &&\n                 slice.iter().all(|p| p.walk_(it)) &&\n                 after.iter().all(|p| p.walk_(it))\n@@ -555,8 +583,8 @@ pub enum PatKind {\n     /// A range pattern, e.g. `1...2`\n     Range(P<Expr>, P<Expr>),\n     /// `[a, b, ..i, y, z]` is represented as:\n-    ///     `PatKind::Vec(box [a, b], Some(i), box [y, z])`\n-    Vec(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n+    ///     `PatKind::Slice(box [a, b], Some(i), box [y, z])`\n+    Slice(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -788,6 +816,7 @@ pub struct Field {\n     pub name: Spanned<Name>,\n     pub expr: P<Expr>,\n     pub span: Span,\n+    pub is_shorthand: bool,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -827,7 +856,7 @@ pub enum Expr_ {\n     /// A `box x` expression.\n     ExprBox(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n-    ExprVec(HirVec<P<Expr>>),\n+    ExprArray(HirVec<P<Expr>>),\n     /// A function call\n     ///\n     /// The first field resolves to the function itself (usually an `ExprPath`),\n@@ -911,7 +940,7 @@ pub enum Expr_ {\n     ExprRet(Option<P<Expr>>),\n \n     /// Inline assembly (from `asm!`), with its outputs and inputs.\n-    ExprInlineAsm(InlineAsm, Vec<P<Expr>>, Vec<P<Expr>>),\n+    ExprInlineAsm(P<InlineAsm>, HirVec<P<Expr>>, HirVec<P<Expr>>),\n \n     /// A struct or struct-like variant literal expression.\n     ///\n@@ -1081,10 +1110,10 @@ pub struct BareFnTy {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n /// The different kinds of types recognized by the compiler\n pub enum Ty_ {\n-    /// A variable length array (`[T]`)\n-    TyVec(P<Ty>),\n+    /// A variable length slice (`[T]`)\n+    TySlice(P<Ty>),\n     /// A fixed length array (`[T; n]`)\n-    TyFixedLengthVec(P<Ty>, P<Expr>),\n+    TyArray(P<Ty>, P<Expr>),\n     /// A raw pointer (`*const T` or `*mut T`)\n     TyPtr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)"}, {"sha": "0deea941463617f664141b7a86ff8b2e7bd932fc", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -58,11 +58,11 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n         PatKind::Path(..) |\n         PatKind::Struct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Variant(..)) => true,\n+                Some(Def::Variant(..)) | Some(Def::VariantCtor(..)) => true,\n                 _ => false\n             }\n         }\n-        PatKind::Vec(..) => true,\n+        PatKind::Slice(..) => true,\n         _ => false\n     }\n }\n@@ -173,10 +173,9 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n             PatKind::TupleStruct(..) |\n             PatKind::Path(..) |\n             PatKind::Struct(..) => {\n-                match dm.get(&p.id) {\n-                    Some(&PathResolution { base_def: Def::Variant(_, id), .. }) => {\n-                        variants.push(id);\n-                    }\n+                match dm.get(&p.id).map(|d| d.full_def()) {\n+                    Some(Def::Variant(id)) |\n+                    Some(Def::VariantCtor(id, ..)) => variants.push(id),\n                     _ => ()\n                 }\n             }"}, {"sha": "657c10bab12eb0fbe43c8ed6b3e553053d74a2e4", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -486,7 +486,7 @@ impl<'a> State<'a> {\n         self.maybe_print_comment(ty.span.lo)?;\n         self.ibox(0)?;\n         match ty.node {\n-            hir::TyVec(ref ty) => {\n+            hir::TySlice(ref ty) => {\n                 word(&mut self.s, \"[\")?;\n                 self.print_type(&ty)?;\n                 word(&mut self.s, \"]\")?;\n@@ -543,7 +543,7 @@ impl<'a> State<'a> {\n             hir::TyImplTrait(ref bounds) => {\n                 self.print_bounds(\"impl \", &bounds[..])?;\n             }\n-            hir::TyFixedLengthVec(ref ty, ref v) => {\n+            hir::TyArray(ref ty, ref v) => {\n                 word(&mut self.s, \"[\")?;\n                 self.print_type(&ty)?;\n                 word(&mut self.s, \"; \")?;\n@@ -1229,8 +1229,10 @@ impl<'a> State<'a> {\n                            &fields[..],\n                            |s, field| {\n                                s.ibox(indent_unit)?;\n-                               s.print_name(field.name.node)?;\n-                               s.word_space(\":\")?;\n+                               if !field.is_shorthand {\n+                                    s.print_name(field.name.node)?;\n+                                    s.word_space(\":\")?;\n+                               }\n                                s.print_expr(&field.expr)?;\n                                s.end()\n                            },\n@@ -1319,7 +1321,7 @@ impl<'a> State<'a> {\n                 self.word_space(\"box\")?;\n                 self.print_expr(expr)?;\n             }\n-            hir::ExprVec(ref exprs) => {\n+            hir::ExprArray(ref exprs) => {\n                 self.print_expr_vec(&exprs[..])?;\n             }\n             hir::ExprRepeat(ref element, ref count) => {\n@@ -1829,7 +1831,7 @@ impl<'a> State<'a> {\n                 word(&mut self.s, \"...\")?;\n                 self.print_expr(&end)?;\n             }\n-            PatKind::Vec(ref before, ref slice, ref after) => {\n+            PatKind::Slice(ref before, ref slice, ref after) => {\n                 word(&mut self.s, \"[\")?;\n                 self.commasep(Inconsistent, &before[..], |s, p| s.print_pat(&p))?;\n                 if let Some(ref p) = *slice {"}, {"sha": "fda08eba0213521cdafd89c2446ae08c2e589f3b", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -49,6 +49,7 @@ use ty::relate::{RelateResult, TypeRelation};\n use traits::PredicateObligations;\n \n use syntax::ast;\n+use syntax::util::small_vector::SmallVector;\n use syntax_pos::Span;\n \n #[derive(Clone)]\n@@ -181,7 +182,9 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n                        a_is_expected: bool)\n                        -> RelateResult<'tcx, ()>\n     {\n-        let mut stack = Vec::new();\n+        // We use SmallVector here instead of Vec because this code is hot and\n+        // it's rare that the stack length exceeds 1.\n+        let mut stack = SmallVector::zero();\n         stack.push((a_ty, dir, b_vid));\n         loop {\n             // For each turn of the loop, we extract a tuple"}, {"sha": "5e3925b0b3c98f00b00b67144dfdd92da9e5401b", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -457,7 +457,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n             same_regions.push(SameRegions {\n                 scope_id: scope_id,\n-                regions: vec!(sub_fr.bound_region, sup_fr.bound_region)\n+                regions: vec![sub_fr.bound_region, sup_fr.bound_region]\n             })\n         }\n     }\n@@ -577,11 +577,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                          terr: &TypeError<'tcx>)\n                                          -> DiagnosticBuilder<'tcx>\n     {\n-        // FIXME: do we want to use a different error code for each origin?\n-        let mut diag = struct_span_err!(\n-            self.tcx.sess, trace.origin.span(), E0308,\n-            \"{}\", trace.origin.as_failure_str()\n-        );\n+        let span = trace.origin.span();\n+        let failure_str = trace.origin.as_failure_str();\n+        let mut diag = match trace.origin {\n+            TypeOrigin::IfExpressionWithNoElse(_) => {\n+                struct_span_err!(self.tcx.sess, span, E0317, \"{}\", failure_str)\n+            },\n+            _ => {\n+                struct_span_err!(self.tcx.sess, span, E0308, \"{}\", failure_str)\n+            },\n+        };\n         self.note_type_err(&mut diag, trace.origin, None, Some(trace.values), terr);\n         diag\n     }\n@@ -1226,16 +1231,17 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                          lifetime: hir::Lifetime,\n                          region_names: &HashSet<ast::Name>)\n                          -> hir::HirVec<hir::TyParam> {\n-        ty_params.iter().map(|ty_param| {\n-            let bounds = self.rebuild_ty_param_bounds(ty_param.bounds.clone(),\n+        ty_params.into_iter().map(|ty_param| {\n+            let bounds = self.rebuild_ty_param_bounds(ty_param.bounds,\n                                                       lifetime,\n                                                       region_names);\n             hir::TyParam {\n                 name: ty_param.name,\n                 id: ty_param.id,\n                 bounds: bounds,\n-                default: ty_param.default.clone(),\n+                default: ty_param.default,\n                 span: ty_param.span,\n+                pure_wrt_drop: ty_param.pure_wrt_drop,\n             }\n         }).collect()\n     }\n@@ -1294,8 +1300,11 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                         -> hir::Generics {\n         let mut lifetimes = Vec::new();\n         for lt in add {\n-            lifetimes.push(hir::LifetimeDef { lifetime: *lt,\n-                                              bounds: hir::HirVec::new() });\n+            lifetimes.push(hir::LifetimeDef {\n+                lifetime: *lt,\n+                bounds: hir::HirVec::new(),\n+                pure_wrt_drop: false,\n+            });\n         }\n         for lt in &generics.lifetimes {\n             if keep.contains(&lt.lifetime.name) ||\n@@ -1350,7 +1359,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                                 region_names: &HashSet<ast::Name>)\n                                 -> P<hir::Ty> {\n         let mut new_ty = P(ty.clone());\n-        let mut ty_queue = vec!(ty);\n+        let mut ty_queue = vec![ty];\n         while !ty_queue.is_empty() {\n             let cur_ty = ty_queue.remove(0);\n             match cur_ty.node {\n@@ -1433,8 +1442,8 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 hir::TyPtr(ref mut_ty) => {\n                     ty_queue.push(&mut_ty.ty);\n                 }\n-                hir::TyVec(ref ty) |\n-                hir::TyFixedLengthVec(ref ty, _) => {\n+                hir::TySlice(ref ty) |\n+                hir::TyArray(ref ty, _) => {\n                     ty_queue.push(&ty);\n                 }\n                 hir::TyTup(ref tys) => ty_queue.extend(tys.iter().map(|ty| &**ty)),\n@@ -1469,9 +1478,9 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                             ty: build_to(mut_ty.ty, to),\n                         })\n                     }\n-                    hir::TyVec(ty) => hir::TyVec(build_to(ty, to)),\n-                    hir::TyFixedLengthVec(ty, e) => {\n-                        hir::TyFixedLengthVec(build_to(ty, to), e)\n+                    hir::TySlice(ty) => hir::TySlice(build_to(ty, to)),\n+                    hir::TyArray(ty, e) => {\n+                        hir::TyArray(build_to(ty, to), e)\n                     }\n                     hir::TyTup(tys) => {\n                         hir::TyTup(tys.into_iter().map(|ty| build_to(ty, to)).collect())"}, {"sha": "828f9f32baac8d3446b066ed01f7e20dbc20ed49", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -61,9 +61,8 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n                   -> Ty<'tcx> where\n         F: FnOnce(u32) -> ty::InferTy,\n     {\n-        match opt_ty {\n-            Some(ty) => { return ty.fold_with(self); }\n-            None => { }\n+        if let Some(ty) = opt_ty {\n+            return ty.fold_with(self);\n         }\n \n         match self.freshen_map.entry(key) {"}, {"sha": "25b899b3c56cd1bae9d3a454e3d732e68434adce", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -749,13 +749,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn plug_leaks<T>(&self,\n                          skol_map: SkolemizationMap<'tcx>,\n                          snapshot: &CombinedSnapshot,\n-                         value: &T) -> T\n+                         value: T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n         debug!(\"plug_leaks(skol_map={:?}, value={:?})\",\n                skol_map,\n                value);\n \n+        if skol_map.is_empty() {\n+            return value;\n+        }\n+\n         // Compute a mapping from the \"taint set\" of each skolemized\n         // region back to the `ty::BoundRegion` that it originally\n         // represented. Because `leak_check` passed, we know that\n@@ -775,7 +779,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         // Remove any instantiated type variables from `value`; those can hide\n         // references to regions from the `fold_regions` code below.\n-        let value = self.resolve_type_vars_if_possible(value);\n+        let value = self.resolve_type_vars_if_possible(&value);\n \n         // Map any skolemization byproducts back to a late-bound\n         // region. Put that late-bound region at whatever the outermost\n@@ -813,9 +817,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         });\n \n-        debug!(\"plug_leaks: result={:?}\",\n-               result);\n-\n         self.pop_skolemized(skol_map, snapshot);\n \n         debug!(\"plug_leaks: result={:?}\", result);\n@@ -838,5 +839,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"pop_skolemized({:?})\", skol_map);\n         let skol_regions: FnvHashSet<_> = skol_map.values().cloned().collect();\n         self.region_vars.pop_skolemized(&skol_regions, &snapshot.region_vars_snapshot);\n+        if !skol_map.is_empty() {\n+            self.projection_cache.borrow_mut().rollback_skolemized(\n+                &snapshot.projection_cache_snapshot);\n+        }\n     }\n }"}, {"sha": "af994e884fe47638aebfaebf5f2fbc784005232c", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -25,7 +25,7 @@ use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::region::CodeExtent;\n use mir::tcx::LvalueTy;\n-use ty::subst::{Subst, Substs};\n+use ty::subst::{Kind, Subst, Substs};\n use ty::adjustment;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n@@ -583,7 +583,8 @@ impl_trans_normalize!('gcx,\n     ty::FnSig<'gcx>,\n     &'gcx ty::BareFnTy<'gcx>,\n     ty::ClosureSubsts<'gcx>,\n-    ty::PolyTraitRef<'gcx>\n+    ty::PolyTraitRef<'gcx>,\n+    ty::ExistentialTraitRef<'gcx>\n );\n \n impl<'gcx> TransNormalize<'gcx> for LvalueTy<'gcx> {\n@@ -603,6 +604,18 @@ impl<'gcx> TransNormalize<'gcx> for LvalueTy<'gcx> {\n \n // NOTE: Callable from trans only!\n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+    /// Currently, higher-ranked type bounds inhibit normalization. Therefore,\n+    /// each time we erase them in translation, we need to normalize\n+    /// the contents.\n+    pub fn erase_late_bound_regions_and_normalize<T>(self, value: &ty::Binder<T>)\n+        -> T\n+        where T: TransNormalize<'tcx>\n+    {\n+        assert!(!value.needs_subst());\n+        let value = self.erase_late_bound_regions(value);\n+        self.normalize_associated_type(&value)\n+    }\n+\n     pub fn normalize_associated_type<T>(self, value: &T) -> T\n         where T: TransNormalize<'tcx>\n     {\n@@ -1208,7 +1221,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn type_var_for_def(&self,\n                             span: Span,\n                             def: &ty::TypeParameterDef<'tcx>,\n-                            substs: &Substs<'tcx>)\n+                            substs: &[Kind<'tcx>])\n                             -> Ty<'tcx> {\n         let default = def.default.map(|default| {\n             type_variable::Default {"}, {"sha": "289f7d6c7380088ba4a8bb6f25d346a864f4f284", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -63,9 +63,8 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n         return;\n     }\n \n-    let requested_node: Option<ast::NodeId> = env::var(\"RUST_REGION_GRAPH_NODE\")\n-                                                  .ok()\n-                                                  .and_then(|s| s.parse().ok());\n+    let requested_node = env::var(\"RUST_REGION_GRAPH_NODE\")\n+        .ok().and_then(|s| s.parse().map(ast::NodeId::new).ok());\n \n     if requested_node.is_some() && requested_node != Some(subject_node) {\n         return;"}, {"sha": "3856ea420b0f30c73d4a5e1be4c72972445fedfd", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -12,8 +12,9 @@ pub use self::RelationDir::*;\n use self::TypeVariableValue::*;\n use self::UndoEntry::*;\n use hir::def_id::{DefId};\n-use ty::{self, Ty};\n+use syntax::util::small_vector::SmallVector;\n use syntax_pos::Span;\n+use ty::{self, Ty};\n \n use std::cmp::min;\n use std::marker::PhantomData;\n@@ -149,7 +150,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         &mut self,\n         vid: ty::TyVid,\n         ty: Ty<'tcx>,\n-        stack: &mut Vec<(Ty<'tcx>, RelationDir, ty::TyVid)>)\n+        stack: &mut SmallVector<(Ty<'tcx>, RelationDir, ty::TyVid)>)\n     {\n         debug_assert!(self.root_var(vid) == vid);\n         let old_value = {"}, {"sha": "d17402d21342b196338e5d80dab67da0431843fe", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -40,7 +40,7 @@\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n-#![feature(question_mark)]\n+#![cfg_attr(stage0, feature(question_mark))]\n #![cfg_attr(test, feature(test))]\n \n extern crate arena;\n@@ -50,7 +50,6 @@ extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n-extern crate rbml;\n extern crate rustc_llvm as llvm;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n@@ -106,23 +105,12 @@ pub mod middle {\n     pub mod weak_lang_items;\n }\n \n-pub mod mir {\n-    mod cache;\n-    pub mod repr;\n-    pub mod tcx;\n-    pub mod visit;\n-    pub mod transform;\n-    pub mod traversal;\n-    pub mod mir_map;\n-}\n-\n+pub mod mir;\n pub mod session;\n pub mod traits;\n pub mod ty;\n \n pub mod util {\n-    pub use rustc_back::sha2;\n-\n     pub mod common;\n     pub mod ppaux;\n     pub mod nodemap;"}, {"sha": "3472c77cf42272038e401f17a493aba49466c96e", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -120,35 +120,29 @@ declare_lint! {\n \n declare_lint! {\n     pub INACCESSIBLE_EXTERN_CRATE,\n-    Warn,\n+    Deny,\n     \"use of inaccessible extern crate erroneously allowed\"\n }\n \n declare_lint! {\n     pub INVALID_TYPE_PARAM_DEFAULT,\n-    Warn,\n+    Deny,\n     \"type parameter default erroneously allowed in invalid location\"\n }\n \n declare_lint! {\n     pub ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN,\n-    Warn,\n+    Deny,\n     \"floating-point constants cannot be used in patterns\"\n }\n \n declare_lint! {\n     pub ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n-    Warn,\n+    Deny,\n     \"constants of struct or enum type can only be used in a pattern if \\\n      the struct or enum has `#[derive(PartialEq, Eq)]`\"\n }\n \n-declare_lint! {\n-    pub MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n-    Deny,\n-    \"unit struct or enum variant erroneously allowed to match via path::ident(..)\"\n-}\n-\n declare_lint! {\n     pub RAW_POINTER_DERIVE,\n     Warn,\n@@ -170,7 +164,7 @@ declare_lint! {\n \n declare_lint! {\n     pub OVERLAPPING_INHERENT_IMPLS,\n-    Warn,\n+    Deny,\n     \"two overlapping inherent impls define an item with the same name were erroneously allowed\"\n }\n \n@@ -182,13 +176,13 @@ declare_lint! {\n \n declare_lint! {\n     pub SUPER_OR_SELF_IN_GLOBAL_PATH,\n-    Warn,\n+    Deny,\n     \"detects super or self keywords at the beginning of global path\"\n }\n \n declare_lint! {\n     pub LIFETIME_UNDERSCORE,\n-    Warn,\n+    Deny,\n     \"lifetimes or labels named `'_` were erroneously allowed\"\n }\n \n@@ -198,6 +192,12 @@ declare_lint! {\n     \"safe access to extern statics was erroneously allowed\"\n }\n \n+declare_lint! {\n+    pub PATTERNS_IN_FNS_WITHOUT_BODY,\n+    Warn,\n+    \"patterns in functions without body were erroneously allowed\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -226,7 +226,6 @@ impl LintPass for HardwiredLints {\n             INVALID_TYPE_PARAM_DEFAULT,\n             ILLEGAL_FLOATING_POINT_CONSTANT_PATTERN,\n             ILLEGAL_STRUCT_OR_ENUM_CONSTANT_PATTERN,\n-            MATCH_OF_UNIT_VARIANT_VIA_PAREN_DOTDOT,\n             CONST_ERR,\n             RAW_POINTER_DERIVE,\n             TRANSMUTE_FROM_FN_ITEM_TYPES,\n@@ -235,7 +234,8 @@ impl LintPass for HardwiredLints {\n             SUPER_OR_SELF_IN_GLOBAL_PATH,\n             HR_LIFETIME_IN_ASSOC_TYPE,\n             LIFETIME_UNDERSCORE,\n-            SAFE_EXTERN_STATICS\n+            SAFE_EXTERN_STATICS,\n+            PATTERNS_IN_FNS_WITHOUT_BODY\n         )\n     }\n }"}, {"sha": "20463f42d3b1df95435bcc3704f9a980870f1317", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -127,9 +127,9 @@ impl LintStore {\n \n     pub fn new() -> LintStore {\n         LintStore {\n-            lints: vec!(),\n-            early_passes: Some(vec!()),\n-            late_passes: Some(vec!()),\n+            lints: vec![],\n+            early_passes: Some(vec![]),\n+            late_passes: Some(vec![]),\n             by_name: FnvHashMap(),\n             levels: FnvHashMap(),\n             future_incompatible: FnvHashMap(),\n@@ -345,7 +345,7 @@ macro_rules! run_lints { ($cx:expr, $f:ident, $ps:ident, $($args:expr),*) => ({\n // See also the hir version just below.\n pub fn gather_attrs(attrs: &[ast::Attribute])\n                     -> Vec<Result<(InternedString, Level, Span), Span>> {\n-    let mut out = vec!();\n+    let mut out = vec![];\n     for attr in attrs {\n         let r = gather_attr(attr);\n         out.extend(r.into_iter());\n@@ -355,7 +355,7 @@ pub fn gather_attrs(attrs: &[ast::Attribute])\n \n pub fn gather_attr(attr: &ast::Attribute)\n                    -> Vec<Result<(InternedString, Level, Span), Span>> {\n-    let mut out = vec!();\n+    let mut out = vec![];\n \n     let level = match Level::from_str(&attr.name()) {\n         None => return out,\n@@ -452,8 +452,7 @@ pub fn raw_struct_lint<'a>(sess: &'a Session,\n     }\n \n     if let Some(span) = def {\n-        let explanation = \"lint level defined here\";\n-        err.span_note(span, &explanation);\n+        sess.diag_span_note_once(&mut err, lint, span, \"lint level defined here\");\n     }\n \n     err"}, {"sha": "7eea6a2fcf2709cee8cb26d642d5e78254cf4af1", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -314,5 +314,4 @@ pub enum LintSource {\n pub type LevelSource = (Level, LintSource);\n \n pub mod builtin;\n-\n mod context;"}, {"sha": "59a5147ed1c1681bc8d66ad765f99f5291845e6e", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 97, "deletions": 318, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -23,31 +23,28 @@\n // probably get a better home if someone can find one.\n \n use hir::def::{self, Def};\n-use hir::def_id::{DefId, DefIndex};\n+use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map as hir_map;\n-use hir::map::definitions::DefKey;\n+use hir::map::definitions::{Definitions, DefKey};\n use hir::svh::Svh;\n use middle::lang_items;\n-use ty::{self, Ty, TyCtxt, VariantKind};\n-use mir::repr::Mir;\n-use mir::mir_map::MirMap;\n+use ty::{self, Ty, TyCtxt};\n+use mir::Mir;\n use session::Session;\n-use session::config::PanicStrategy;\n use session::search_paths::PathKind;\n-use util::nodemap::{FnvHashMap, NodeSet, DefIdMap};\n-use std::rc::Rc;\n+use util::nodemap::{NodeSet, DefIdMap};\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n-use syntax::ext::base::LoadedMacro;\n+use syntax::ext::base::SyntaxExtension;\n use syntax::ptr::P;\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n use hir;\n use hir::intravisit::Visitor;\n+use rustc_back::PanicStrategy;\n \n-pub use self::DefLike::{DlDef, DlField, DlImpl};\n pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n \n // lonely orphan structs and enums looking for a better home\n@@ -64,30 +61,20 @@ pub struct LinkMeta {\n pub struct CrateSource {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n-    pub cnum: ast::CrateNum,\n+    pub cnum: CrateNum,\n }\n \n-#[derive(Copy, Debug, PartialEq, Clone)]\n+#[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable)]\n pub enum LinkagePreference {\n     RequireDynamic,\n     RequireStatic,\n }\n \n-enum_from_u32! {\n-    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-    pub enum NativeLibraryKind {\n-        NativeStatic,    // native static library (.a archive)\n-        NativeFramework, // OSX-specific\n-        NativeUnknown,   // default way to specify a dynamic library\n-    }\n-}\n-\n-// Something that a name can resolve to.\n-#[derive(Copy, Clone, Debug)]\n-pub enum DefLike {\n-    DlDef(Def),\n-    DlImpl(DefId),\n-    DlField\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub enum NativeLibraryKind {\n+    NativeStatic,    // native static library (.a archive)\n+    NativeFramework, // OSX-specific\n+    NativeUnknown,   // default way to specify a dynamic library\n }\n \n /// The data we save and restore about an inlined item or method.  This is not\n@@ -101,24 +88,13 @@ pub enum InlinedItem {\n }\n \n /// A borrowed version of `hir::InlinedItem`.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n pub enum InlinedItemRef<'a> {\n     Item(DefId, &'a hir::Item),\n     TraitItem(DefId, &'a hir::TraitItem),\n     ImplItem(DefId, &'a hir::ImplItem)\n }\n \n-/// Item definitions in the currently-compiled crate would have the CrateNum\n-/// LOCAL_CRATE in their DefId.\n-pub const LOCAL_CRATE: ast::CrateNum = 0;\n-\n-#[derive(Copy, Clone)]\n-pub struct ChildItem {\n-    pub def: DefLike,\n-    pub name: ast::Name,\n-    pub vis: ty::Visibility,\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct ExternCrate {\n     /// def_id of an `extern crate` in the current crate that caused\n@@ -144,47 +120,39 @@ pub struct ExternCrate {\n /// can be accessed.\n pub trait CrateStore<'tcx> {\n     // item info\n+    fn describe_def(&self, def: DefId) -> Option<Def>;\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n     fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind;\n     fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                       -> ty::ClosureTy<'tcx>;\n     fn item_variances(&self, def: DefId) -> Vec<ty::Variance>;\n-    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx>;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>>;\n-    fn item_name(&self, def: DefId) -> ast::Name;\n-    fn opt_item_name(&self, def: DefId) -> Option<ast::Name>;\n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx>;\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx>;\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                         -> &'tcx ty::Generics<'tcx>;\n+                         -> ty::Generics<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n-    fn method_arg_names(&self, did: DefId) -> Vec<String>;\n+    fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n-    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId>;\n-    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                  -> Vec<Rc<ty::Method<'tcx>>>;\n-    fn trait_item_def_ids(&self, def: DefId)\n-                          -> Vec<ty::ImplOrTraitItemId>;\n+    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>;\n \n     // impl info\n-    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>;\n+    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId>;\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>>;\n-    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>;\n+    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity;\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>;\n-    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                             -> Vec<Rc<ty::AssociatedConst<'tcx>>>;\n     fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n@@ -195,87 +163,69 @@ pub trait CrateStore<'tcx> {\n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n     fn is_defaulted_trait(&self, did: DefId) -> bool;\n-    fn is_impl(&self, did: DefId) -> bool;\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n-    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool;\n     fn is_foreign_item(&self, did: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n-    fn is_typedef(&self, did: DefId) -> bool;\n \n     // crate metadata\n-    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n-                                    -> Vec<(ast::CrateNum, LinkagePreference)>;\n-    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>;\n-    fn missing_lang_items(&self, cnum: ast::CrateNum) -> Vec<lang_items::LangItem>;\n-    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_allocator(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_panic_runtime(&self, cnum: ast::CrateNum) -> bool;\n-    fn is_compiler_builtins(&self, cnum: ast::CrateNum) -> bool;\n-    fn panic_strategy(&self, cnum: ast::CrateNum) -> PanicStrategy;\n-    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate>;\n-    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>;\n+    fn dylib_dependency_formats(&self, cnum: CrateNum)\n+                                    -> Vec<(CrateNum, LinkagePreference)>;\n+    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>;\n+    fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>;\n+    fn is_staged_api(&self, cnum: CrateNum) -> bool;\n+    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool;\n+    fn is_allocator(&self, cnum: CrateNum) -> bool;\n+    fn is_panic_runtime(&self, cnum: CrateNum) -> bool;\n+    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool;\n+    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy;\n+    fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>;\n     /// The name of the crate as it is referred to in source code of the current\n     /// crate.\n-    fn crate_name(&self, cnum: ast::CrateNum) -> InternedString;\n+    fn crate_name(&self, cnum: CrateNum) -> InternedString;\n     /// The name of the crate as it is stored in the crate's metadata.\n-    fn original_crate_name(&self, cnum: ast::CrateNum) -> InternedString;\n-    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh;\n-    fn crate_disambiguator(&self, cnum: ast::CrateNum) -> InternedString;\n-    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n-                                -> FnvHashMap<DefId, Vec<ast::Attribute>>;\n-    fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>;\n-    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>;\n-    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>;\n-    fn is_no_builtins(&self, cnum: ast::CrateNum) -> bool;\n+    fn original_crate_name(&self, cnum: CrateNum) -> InternedString;\n+    fn crate_hash(&self, cnum: CrateNum) -> Svh;\n+    fn crate_disambiguator(&self, cnum: CrateNum) -> InternedString;\n+    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n+    fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>;\n+    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>;\n+    fn is_no_builtins(&self, cnum: CrateNum) -> bool;\n \n     // resolve\n     fn def_index_for_def_key(&self,\n-                             cnum: ast::CrateNum,\n+                             cnum: CrateNum,\n                              def: DefKey)\n                              -> Option<DefIndex>;\n     fn def_key(&self, def: DefId) -> hir_map::DefKey;\n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath>;\n-    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind>;\n-    fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>;\n-    fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n-    fn item_children(&self, did: DefId) -> Vec<ChildItem>;\n-    fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>;\n+    fn item_children(&self, did: DefId) -> Vec<def::Export>;\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<(&'tcx InlinedItem, ast::NodeId)>;\n     fn local_node_for_inlined_defid(&'tcx self, def_id: DefId) -> Option<ast::NodeId>;\n     fn defid_for_inlined_node(&'tcx self, node_id: ast::NodeId) -> Option<DefId>;\n \n-    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<Mir<'tcx>>;\n+    fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n-    fn crates(&self) -> Vec<ast::CrateNum>;\n+    fn crates(&self) -> Vec<CrateNum>;\n     fn used_libraries(&self) -> Vec<(String, NativeLibraryKind)>;\n     fn used_link_args(&self) -> Vec<String>;\n \n     // utility functions\n     fn metadata_filename(&self) -> &str;\n     fn metadata_section_name(&self, target: &Target) -> &str;\n-    fn encode_type<'a>(&self,\n-                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       ty: Ty<'tcx>,\n-                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n-                       -> Vec<u8>;\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>;\n-    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource;\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>;\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>;\n+    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n+    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n-                           reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>,\n-                           krate: &hir::Crate) -> Vec<u8>;\n+                           reachable: &NodeSet) -> Vec<u8>;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -324,59 +274,51 @@ pub struct DummyCrateStore;\n #[allow(unused_variables)]\n impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // item info\n+    fn describe_def(&self, def: DefId) -> Option<Def> { bug!(\"describe_def\") }\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n     fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n-    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind  { bug!(\"closure_kind\") }\n+    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind { bug!(\"closure_kind\") }\n     fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                       -> ty::ClosureTy<'tcx>  { bug!(\"closure_ty\") }\n     fn item_variances(&self, def: DefId) -> Vec<ty::Variance> { bug!(\"item_variances\") }\n-    fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { bug!(\"repr_attrs\") }\n     fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> Ty<'tcx> { bug!(\"item_type\") }\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>> {\n         bug!(\"visible_parent_map\")\n     }\n-    fn item_name(&self, def: DefId) -> ast::Name { bug!(\"item_name\") }\n-    fn opt_item_name(&self, def: DefId) -> Option<ast::Name> { bug!(\"opt_item_name\") }\n     fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n     fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                         -> &'tcx ty::Generics<'tcx> { bug!(\"item_generics\") }\n+                         -> ty::Generics<'tcx> { bug!(\"item_generics\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n         { bug!(\"trait_def\") }\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n         { bug!(\"adt_def\") }\n-    fn method_arg_names(&self, did: DefId) -> Vec<String> { bug!(\"method_arg_names\") }\n+    fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name> { bug!(\"fn_arg_names\") }\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info\n-    fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n-    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                                  -> Vec<Rc<ty::Method<'tcx>>> { bug!(\"provided_trait_methods\") }\n-    fn trait_item_def_ids(&self, def: DefId)\n-                          -> Vec<ty::ImplOrTraitItemId> { bug!(\"trait_item_def_ids\") }\n+    fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId> { vec![] }\n     fn def_index_for_def_key(&self,\n-                             cnum: ast::CrateNum,\n+                             cnum: CrateNum,\n                              def: DefKey)\n                              -> Option<DefIndex> {\n         None\n     }\n \n     // impl info\n-    fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n-        { bug!(\"impl_items\") }\n+    fn impl_or_trait_items(&self, def_id: DefId) -> Vec<DefId>\n+        { bug!(\"impl_or_trait_items\") }\n     fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n-    fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity> { bug!(\"impl_polarity\") }\n+    fn impl_polarity(&self, def: DefId) -> hir::ImplPolarity { bug!(\"impl_polarity\") }\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>\n         { bug!(\"custom_coerce_unsized_kind\") }\n-    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                             -> Vec<Rc<ty::AssociatedConst<'tcx>>> { bug!(\"associated_consts\") }\n     fn impl_parent(&self, def: DefId) -> Option<DefId> { bug!(\"impl_parent\") }\n \n     // trait/impl-item info\n@@ -387,64 +329,48 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n     fn is_defaulted_trait(&self, did: DefId) -> bool { bug!(\"is_defaulted_trait\") }\n-    fn is_impl(&self, did: DefId) -> bool { bug!(\"is_impl\") }\n     fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n-    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool\n-        { bug!(\"is_extern_item\") }\n     fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n-    fn is_typedef(&self, did: DefId) -> bool { bug!(\"is_typedef\") }\n \n     // crate metadata\n-    fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n-                                    -> Vec<(ast::CrateNum, LinkagePreference)>\n+    fn dylib_dependency_formats(&self, cnum: CrateNum)\n+                                    -> Vec<(CrateNum, LinkagePreference)>\n         { bug!(\"dylib_dependency_formats\") }\n-    fn lang_items(&self, cnum: ast::CrateNum) -> Vec<(DefIndex, usize)>\n+    fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n         { bug!(\"lang_items\") }\n-    fn missing_lang_items(&self, cnum: ast::CrateNum) -> Vec<lang_items::LangItem>\n+    fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>\n         { bug!(\"missing_lang_items\") }\n-    fn is_staged_api(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_staged_api\") }\n-    fn is_explicitly_linked(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_explicitly_linked\") }\n-    fn is_allocator(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_allocator\") }\n-    fn is_panic_runtime(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_panic_runtime\") }\n-    fn is_compiler_builtins(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_compiler_builtins\") }\n-    fn panic_strategy(&self, cnum: ast::CrateNum) -> PanicStrategy {\n+    fn is_staged_api(&self, cnum: CrateNum) -> bool { bug!(\"is_staged_api\") }\n+    fn is_explicitly_linked(&self, cnum: CrateNum) -> bool { bug!(\"is_explicitly_linked\") }\n+    fn is_allocator(&self, cnum: CrateNum) -> bool { bug!(\"is_allocator\") }\n+    fn is_panic_runtime(&self, cnum: CrateNum) -> bool { bug!(\"is_panic_runtime\") }\n+    fn is_compiler_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_compiler_builtins\") }\n+    fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy {\n         bug!(\"panic_strategy\")\n     }\n-    fn extern_crate(&self, cnum: ast::CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n-    fn crate_attrs(&self, cnum: ast::CrateNum) -> Vec<ast::Attribute>\n-        { bug!(\"crate_attrs\") }\n-    fn crate_name(&self, cnum: ast::CrateNum) -> InternedString { bug!(\"crate_name\") }\n-    fn original_crate_name(&self, cnum: ast::CrateNum) -> InternedString {\n+    fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n+    fn crate_name(&self, cnum: CrateNum) -> InternedString { bug!(\"crate_name\") }\n+    fn original_crate_name(&self, cnum: CrateNum) -> InternedString {\n         bug!(\"original_crate_name\")\n     }\n-    fn crate_hash(&self, cnum: ast::CrateNum) -> Svh { bug!(\"crate_hash\") }\n-    fn crate_disambiguator(&self, cnum: ast::CrateNum)\n+    fn crate_hash(&self, cnum: CrateNum) -> Svh { bug!(\"crate_hash\") }\n+    fn crate_disambiguator(&self, cnum: CrateNum)\n                            -> InternedString { bug!(\"crate_disambiguator\") }\n-    fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n-                                -> FnvHashMap<DefId, Vec<ast::Attribute>>\n-        { bug!(\"crate_struct_field_attrs\") }\n-    fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>\n+    fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n         { bug!(\"plugin_registrar_fn\") }\n-    fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>\n+    fn native_libraries(&self, cnum: CrateNum) -> Vec<(NativeLibraryKind, String)>\n         { bug!(\"native_libraries\") }\n-    fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId> { bug!(\"reachable_ids\") }\n-    fn is_no_builtins(&self, cnum: ast::CrateNum) -> bool { bug!(\"is_no_builtins\") }\n+    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId> { bug!(\"reachable_ids\") }\n+    fn is_no_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_no_builtins\") }\n \n     // resolve\n     fn def_key(&self, def: DefId) -> hir_map::DefKey { bug!(\"def_key\") }\n     fn relative_def_path(&self, def: DefId) -> Option<hir_map::DefPath> {\n         bug!(\"relative_def_path\")\n     }\n-    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> { bug!(\"variant_kind\") }\n-    fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n-        { bug!(\"struct_ctor_def_id\") }\n-    fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>\n-        { bug!(\"tuple_struct_definition_if_ctor\") }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n-    fn item_children(&self, did: DefId) -> Vec<ChildItem> { bug!(\"item_children\") }\n-    fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>\n-        { bug!(\"crate_top_level_items\") }\n+    fn item_children(&self, did: DefId) -> Vec<def::Export> { bug!(\"item_children\") }\n \n     // misc. metadata\n     fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n@@ -458,195 +384,48 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         bug!(\"defid_for_inlined_node\")\n     }\n \n-    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n-                              -> Option<Mir<'tcx>> { bug!(\"maybe_get_item_mir\") }\n+    fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                        -> Mir<'tcx> { bug!(\"get_item_mir\") }\n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         bug!(\"is_item_mir_available\")\n     }\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n-    fn crates(&self) -> Vec<ast::CrateNum> { vec![] }\n+    fn crates(&self) -> Vec<CrateNum> { vec![] }\n     fn used_libraries(&self) -> Vec<(String, NativeLibraryKind)> { vec![] }\n     fn used_link_args(&self) -> Vec<String> { vec![] }\n \n     // utility functions\n     fn metadata_filename(&self) -> &str { bug!(\"metadata_filename\") }\n     fn metadata_section_name(&self, target: &Target) -> &str { bug!(\"metadata_section_name\") }\n-    fn encode_type<'a>(&self,\n-                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       ty: Ty<'tcx>,\n-                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n-                       -> Vec<u8> {\n-        bug!(\"encode_type\")\n-    }\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>\n         { vec![] }\n-    fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n-    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum> { None }\n+    fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n+    fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            link_meta: &LinkMeta,\n-                           reachable: &NodeSet,\n-                           mir_map: &MirMap<'tcx>,\n-                           krate: &hir::Crate) -> Vec<u8> { vec![] }\n+                           reachable: &NodeSet) -> Vec<u8> { vec![] }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n-pub trait MacroLoader {\n-     fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n+pub enum LoadedMacros {\n+    MacroRules(Vec<ast::MacroDef>),\n+    ProcMacros(Vec<(ast::Name, SyntaxExtension)>),\n }\n \n-/// Metadata encoding and decoding can make use of thread-local encoding and\n-/// decoding contexts. These allow implementers of serialize::Encodable and\n-/// Decodable to access information and datastructures that would otherwise not\n-/// be available to them. For example, we can automatically translate def-id and\n-/// span information during decoding because the decoding context knows which\n-/// crate the data is decoded from. Or it allows to make ty::Ty decodable\n-/// because the context has access to the TyCtxt that is needed for creating\n-/// ty::Ty instances.\n-///\n-/// Note, however, that this only works for RBML-based encoding and decoding at\n-/// the moment.\n-pub mod tls {\n-    use rbml::opaque::Encoder as OpaqueEncoder;\n-    use rbml::opaque::Decoder as OpaqueDecoder;\n-    use serialize;\n-    use std::cell::Cell;\n-    use std::mem;\n-    use ty::{self, Ty, TyCtxt};\n-    use ty::subst::Substs;\n-    use hir::def_id::DefId;\n-\n-    pub trait EncodingContext<'tcx> {\n-        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n-        fn encode_ty(&self, encoder: &mut OpaqueEncoder, t: Ty<'tcx>);\n-        fn encode_substs(&self, encoder: &mut OpaqueEncoder, substs: &Substs<'tcx>);\n-    }\n-\n-    /// Marker type used for the TLS slot.\n-    /// The type context cannot be used directly because the TLS\n-    /// in libstd doesn't allow types generic over lifetimes.\n-    struct TlsPayload;\n-\n-    thread_local! {\n-        static TLS_ENCODING: Cell<Option<*const TlsPayload>> = Cell::new(None)\n-    }\n-\n-    /// Execute f after pushing the given EncodingContext onto the TLS stack.\n-    pub fn enter_encoding_context<'tcx, F, R>(ecx: &EncodingContext<'tcx>,\n-                                              encoder: &mut OpaqueEncoder,\n-                                              f: F) -> R\n-        where F: FnOnce(&EncodingContext<'tcx>, &mut OpaqueEncoder) -> R\n-    {\n-        let tls_payload = (ecx as *const _, encoder as *mut _);\n-        let tls_ptr = &tls_payload as *const _ as *const TlsPayload;\n-        TLS_ENCODING.with(|tls| {\n-            let prev = tls.get();\n-            tls.set(Some(tls_ptr));\n-            let ret = f(ecx, encoder);\n-            tls.set(prev);\n-            return ret\n-        })\n-    }\n-\n-    /// Execute f with access to the thread-local encoding context and\n-    /// rbml encoder. This function will panic if the encoder passed in and the\n-    /// context encoder are not the same.\n-    ///\n-    /// Note that this method is 'practically' safe due to its checking that the\n-    /// encoder passed in is the same as the one in TLS, but it would still be\n-    /// possible to construct cases where the EncodingContext is exchanged\n-    /// while the same encoder is used, thus working with a wrong context.\n-    pub fn with_encoding_context<'tcx, E, F, R>(encoder: &mut E, f: F) -> R\n-        where F: FnOnce(&EncodingContext<'tcx>, &mut OpaqueEncoder) -> R,\n-              E: serialize::Encoder\n-    {\n-        unsafe {\n-            unsafe_with_encoding_context(|ecx, tls_encoder| {\n-                assert!(encoder as *mut _ as usize == tls_encoder as *mut _ as usize);\n-\n-                let ecx: &EncodingContext<'tcx> = mem::transmute(ecx);\n-\n-                f(ecx, tls_encoder)\n-            })\n-        }\n-    }\n-\n-    /// Execute f with access to the thread-local encoding context and\n-    /// rbml encoder.\n-    pub unsafe fn unsafe_with_encoding_context<F, R>(f: F) -> R\n-        where F: FnOnce(&EncodingContext, &mut OpaqueEncoder) -> R\n-    {\n-        TLS_ENCODING.with(|tls| {\n-            let tls = tls.get().unwrap();\n-            let tls_payload = tls as *mut (&EncodingContext, &mut OpaqueEncoder);\n-            f((*tls_payload).0, (*tls_payload).1)\n-        })\n-    }\n-\n-    pub trait DecodingContext<'tcx> {\n-        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n-        fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx>;\n-        fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> &'tcx Substs<'tcx>;\n-        fn translate_def_id(&self, def_id: DefId) -> DefId;\n-    }\n-\n-    thread_local! {\n-        static TLS_DECODING: Cell<Option<*const TlsPayload>> = Cell::new(None)\n-    }\n-\n-    /// Execute f after pushing the given DecodingContext onto the TLS stack.\n-    pub fn enter_decoding_context<'tcx, F, R>(dcx: &DecodingContext<'tcx>,\n-                                              decoder: &mut OpaqueDecoder,\n-                                              f: F) -> R\n-        where F: FnOnce(&DecodingContext<'tcx>, &mut OpaqueDecoder) -> R\n-    {\n-        let tls_payload = (dcx as *const _, decoder as *mut _);\n-        let tls_ptr = &tls_payload as *const _ as *const TlsPayload;\n-        TLS_DECODING.with(|tls| {\n-            let prev = tls.get();\n-            tls.set(Some(tls_ptr));\n-            let ret = f(dcx, decoder);\n-            tls.set(prev);\n-            return ret\n-        })\n-    }\n-\n-    /// Execute f with access to the thread-local decoding context and\n-    /// rbml decoder. This function will panic if the decoder passed in and the\n-    /// context decoder are not the same.\n-    ///\n-    /// Note that this method is 'practically' safe due to its checking that the\n-    /// decoder passed in is the same as the one in TLS, but it would still be\n-    /// possible to construct cases where the DecodingContext is exchanged\n-    /// while the same decoder is used, thus working with a wrong context.\n-    pub fn with_decoding_context<'decoder, 'tcx, D, F, R>(d: &'decoder mut D, f: F) -> R\n-        where D: serialize::Decoder,\n-              F: FnOnce(&DecodingContext<'tcx>,\n-                        &mut OpaqueDecoder) -> R,\n-              'tcx: 'decoder\n-    {\n-        unsafe {\n-            unsafe_with_decoding_context(|dcx, decoder| {\n-                assert!((d as *mut _ as usize) == (decoder as *mut _ as usize));\n-\n-                let dcx: &DecodingContext<'tcx> = mem::transmute(dcx);\n-\n-                f(dcx, decoder)\n-            })\n+impl LoadedMacros {\n+    pub fn is_proc_macros(&self) -> bool {\n+        match *self {\n+            LoadedMacros::ProcMacros(_) => true,\n+            _ => false,\n         }\n     }\n+}\n \n-    /// Execute f with access to the thread-local decoding context and\n-    /// rbml decoder.\n-    pub unsafe fn unsafe_with_decoding_context<F, R>(f: F) -> R\n-        where F: FnOnce(&DecodingContext, &mut OpaqueDecoder) -> R\n-    {\n-        TLS_DECODING.with(|tls| {\n-            let tls = tls.get().unwrap();\n-            let tls_payload = tls as *mut (&DecodingContext, &mut OpaqueDecoder);\n-            f((*tls_payload).0, (*tls_payload).1)\n-        })\n-    }\n+pub trait CrateLoader {\n+    fn process_item(&mut self, item: &ast::Item, defs: &Definitions, load_macros: bool)\n+                    -> Option<LoadedMacros>;\n+    fn postprocess(&mut self, krate: &ast::Crate);\n }"}, {"sha": "7f3a58808c225edbf261871171935d1d2a88fcc7", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -112,10 +112,10 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n            ps: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n         let id = match node {\n-            pprust::NodeName(_) => 0,\n+            pprust::NodeName(_) => ast::CRATE_NODE_ID,\n             pprust::NodeExpr(expr) => expr.id,\n             pprust::NodeBlock(blk) => blk.id,\n-            pprust::NodeItem(_) | pprust::NodeSubItem(_) => 0,\n+            pprust::NodeItem(_) | pprust::NodeSubItem(_) => ast::CRATE_NODE_ID,\n             pprust::NodePat(pat) => pat.id\n         };\n "}, {"sha": "dc634b08784a4a266031dab0a7befb94f716896b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -106,10 +106,11 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 self.check_def_id(def.def_id());\n             }\n             _ if self.ignore_non_const_paths => (),\n-            Def::PrimTy(_) => (),\n-            Def::SelfTy(..) => (),\n-            Def::Variant(enum_id, variant_id) => {\n-                self.check_def_id(enum_id);\n+            Def::PrimTy(..) | Def::SelfTy(..) => (),\n+            Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n+                if let Some(enum_id) = self.tcx.parent_def_id(variant_id) {\n+                    self.check_def_id(enum_id);\n+                }\n                 if !self.ignore_variant_stack.contains(&variant_id) {\n                     self.check_def_id(variant_id);\n                 }\n@@ -470,13 +471,12 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // This is done to handle the case where, for example, the static\n         // method of a private type is used, but the type itself is never\n         // called directly.\n-        let impl_items = self.tcx.impl_items.borrow();\n+        let impl_items = self.tcx.impl_or_trait_item_def_ids.borrow();\n         if let Some(impl_list) =\n                 self.tcx.inherent_impls.borrow().get(&self.tcx.map.local_def_id(id)) {\n             for impl_did in impl_list.iter() {\n-                for item_did in impl_items.get(impl_did).unwrap().iter() {\n-                    if let Some(item_node_id) =\n-                            self.tcx.map.as_local_node_id(item_did.def_id()) {\n+                for &item_did in &impl_items[impl_did][..] {\n+                    if let Some(item_node_id) = self.tcx.map.as_local_node_id(item_did) {\n                         if self.live_symbols.contains(&item_node_id) {\n                             return true;\n                         }"}, {"sha": "656d3146fe5d124c314f664e6444fd06efe6df2a", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -61,12 +61,13 @@\n //! Additionally, the algorithm is geared towards finding *any* solution rather\n //! than finding a number of solutions (there are normally quite a few).\n \n-use syntax::ast;\n+use hir::def_id::CrateNum;\n \n use session;\n-use session::config::{self, PanicStrategy};\n+use session::config;\n use middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n use util::nodemap::FnvHashMap;\n+use rustc_back::PanicStrategy;\n \n /// A list of dependencies for a certain crate type.\n ///\n@@ -140,12 +141,12 @@ fn calculate_type(sess: &session::Session,\n         }\n \n         // Everything else falls through below. This will happen either with the\n-        // `-C prefer-dynamic` or because we're a rustc-macro crate. Note that\n-        // rustc-macro crates are required to be dylibs, and they're currently\n+        // `-C prefer-dynamic` or because we're a proc-macro crate. Note that\n+        // proc-macro crates are required to be dylibs, and they're currently\n         // required to link to libsyntax as well.\n         config::CrateTypeExecutable |\n         config::CrateTypeDylib |\n-        config::CrateTypeRustcMacro => {},\n+        config::CrateTypeProcMacro => {},\n     }\n \n     let mut formats = FnvHashMap();\n@@ -169,9 +170,9 @@ fn calculate_type(sess: &session::Session,\n     }\n \n     // Collect what we've got so far in the return vector.\n-    let last_crate = sess.cstore.crates().len() as ast::CrateNum;\n+    let last_crate = sess.cstore.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n-        match formats.get(&cnum) {\n+        match formats.get(&CrateNum::new(cnum)) {\n             Some(&RequireDynamic) => Linkage::Dynamic,\n             Some(&RequireStatic) => Linkage::IncludedFromDylib,\n             None => Linkage::NotLinked,\n@@ -191,7 +192,7 @@ fn calculate_type(sess: &session::Session,\n             assert!(src.rlib.is_some());\n             info!(\"adding staticlib: {}\", sess.cstore.crate_name(cnum));\n             add_library(sess, cnum, RequireStatic, &mut formats);\n-            ret[cnum as usize - 1] = Linkage::Static;\n+            ret[cnum.as_usize() - 1] = Linkage::Static;\n         }\n     }\n \n@@ -213,7 +214,7 @@ fn calculate_type(sess: &session::Session,\n     // For situations like this, we perform one last pass over the dependencies,\n     // making sure that everything is available in the requested format.\n     for (cnum, kind) in ret.iter().enumerate() {\n-        let cnum = (cnum + 1) as ast::CrateNum;\n+        let cnum = CrateNum::new(cnum + 1);\n         let src = sess.cstore.used_crate_source(cnum);\n         match *kind {\n             Linkage::NotLinked |\n@@ -237,9 +238,9 @@ fn calculate_type(sess: &session::Session,\n }\n \n fn add_library(sess: &session::Session,\n-               cnum: ast::CrateNum,\n+               cnum: CrateNum,\n                link: LinkagePreference,\n-               m: &mut FnvHashMap<ast::CrateNum, LinkagePreference>) {\n+               m: &mut FnvHashMap<CrateNum, LinkagePreference>) {\n     match m.get(&cnum) {\n         Some(&link2) => {\n             // If the linkages differ, then we'd have two copies of the library\n@@ -269,9 +270,9 @@ fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n \n     // All crates are available in an rlib format, so we're just going to link\n     // everything in explicitly so long as it's actually required.\n-    let last_crate = sess.cstore.crates().len() as ast::CrateNum;\n+    let last_crate = sess.cstore.crates().len();\n     let mut ret = (1..last_crate+1).map(|cnum| {\n-        if sess.cstore.is_explicitly_linked(cnum) {\n+        if sess.cstore.is_explicitly_linked(CrateNum::new(cnum)) {\n             Linkage::Static\n         } else {\n             Linkage::NotLinked\n@@ -298,11 +299,11 @@ fn attempt_static(sess: &session::Session) -> Option<DependencyList> {\n // a required dependency) in one of the session's field. If this field is not\n // set then this compilation doesn't actually need the dependency and we can\n // also skip this step entirely.\n-fn activate_injected_dep(injected: Option<ast::CrateNum>,\n+fn activate_injected_dep(injected: Option<CrateNum>,\n                          list: &mut DependencyList,\n-                         replaces_injected: &Fn(ast::CrateNum) -> bool) {\n+                         replaces_injected: &Fn(CrateNum) -> bool) {\n     for (i, slot) in list.iter().enumerate() {\n-        let cnum = (i + 1) as ast::CrateNum;\n+        let cnum = CrateNum::new(i + 1);\n         if !replaces_injected(cnum) {\n             continue\n         }\n@@ -311,7 +312,7 @@ fn activate_injected_dep(injected: Option<ast::CrateNum>,\n         }\n     }\n     if let Some(injected) = injected {\n-        let idx = injected as usize - 1;\n+        let idx = injected.as_usize() - 1;\n         assert_eq!(list[idx], Linkage::NotLinked);\n         list[idx] = Linkage::Static;\n     }\n@@ -329,7 +330,7 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n         if let Linkage::NotLinked = *linkage {\n             continue\n         }\n-        let cnum = (i + 1) as ast::CrateNum;\n+        let cnum = CrateNum::new(i + 1);\n         if sess.cstore.is_allocator(cnum) {\n             if let Some(prev) = allocator {\n                 let prev_name = sess.cstore.crate_name(prev);\n@@ -357,7 +358,7 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n     // only one, but we perform validation here that all the panic strategy\n     // compilation modes for the whole DAG are valid.\n     if let Some((cnum, found_strategy)) = panic_runtime {\n-        let desired_strategy = sess.opts.cg.panic.clone();\n+        let desired_strategy = sess.panic_strategy();\n \n         // First up, validate that our selected panic runtime is indeed exactly\n         // our same strategy.\n@@ -380,7 +381,7 @@ fn verify_ok(sess: &session::Session, list: &[Linkage]) {\n             if desired_strategy == PanicStrategy::Abort {\n                 continue\n             }\n-            let cnum = (i + 1) as ast::CrateNum;\n+            let cnum = CrateNum::new(i + 1);\n             let found_strategy = sess.cstore.panic_strategy(cnum);\n             if desired_strategy == found_strategy {\n                 continue"}, {"sha": "c37b6df369dfcf46ef302b40850a8874aecad116", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -442,7 +442,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            hir::ExprVec(ref exprs) => {\n+            hir::ExprArray(ref exprs) => {\n                 self.consume_exprs(exprs);\n             }\n \n@@ -1003,7 +1003,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n             match tcx.expect_def_or_none(pat.id) {\n-                Some(Def::Variant(enum_did, variant_did)) => {\n+                Some(Def::Variant(variant_did)) |\n+                Some(Def::VariantCtor(variant_did, ..)) => {\n+                    let enum_did = tcx.parent_def_id(variant_did).unwrap();\n                     let downcast_cmt = if tcx.lookup_adt_def(enum_did).is_univariant() {\n                         cmt_pat\n                     } else {\n@@ -1014,12 +1016,14 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n                     delegate.matched_pat(pat, downcast_cmt, match_mode);\n                 }\n-                Some(Def::Struct(..)) | Some(Def::Union(..)) |\n-                Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) => {\n+                Some(Def::Struct(..)) | Some(Def::StructCtor(..)) | Some(Def::Union(..)) |\n+                Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) | Some(Def::SelfTy(..)) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n                     delegate.matched_pat(pat, cmt_pat, match_mode);\n                 }\n-                _ => {}\n+                None | Some(Def::Local(..)) |\n+                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {}\n+                def => bug!(\"unexpected definition: {:?}\", def)\n             }\n         }));\n     }\n@@ -1029,7 +1033,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n-                let id_var = freevar.def.var_id();\n+                let def_id = freevar.def.def_id();\n+                let id_var = self.tcx().map.as_local_node_id(def_id).unwrap();\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n                                              closure_expr_id: closure_expr.id };\n                 let upvar_capture = self.mc.infcx.upvar_capture(upvar_id).unwrap();\n@@ -1061,7 +1066,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_id = upvar_def.var_id();\n+        let var_id = self.tcx().map.as_local_node_id(upvar_def.def_id()).unwrap();\n         let var_ty = self.mc.infcx.node_ty(var_id)?;\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }"}, {"sha": "1acd0fb0f79c05d4c0c29fb3d0abd7e2e1f50dd1", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -103,11 +103,16 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        span_err!(self.infcx.tcx.sess, span, E0512,\n+        struct_span_err!(self.infcx.tcx.sess, span, E0512,\n                   \"transmute called with differently sized types: \\\n                    {} ({}) to {} ({})\",\n                   from, skeleton_string(from, sk_from),\n-                  to, skeleton_string(to, sk_to));\n+                  to, skeleton_string(to, sk_to))\n+            .span_label(span,\n+                &format!(\"transmuting between {} and {}\",\n+                    skeleton_string(from, sk_from),\n+                    skeleton_string(to, sk_to)))\n+            .emit();\n     }\n }\n "}, {"sha": "3175230ab6a5e43694a9731ee2bbbdf0443546f3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -43,7 +43,7 @@ macro_rules! language_item_table {\n \n \n enum_from_u32! {\n-    #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+    #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n     pub enum LangItem {\n         $($variant,)*\n     }\n@@ -59,7 +59,7 @@ impl LanguageItems {\n         fn foo(_: LangItem) -> Option<DefId> { None }\n \n         LanguageItems {\n-            items: vec!($(foo($variant)),*),\n+            items: vec![$(foo($variant)),*],\n             missing: Vec::new(),\n         }\n     }"}, {"sha": "79396b9ca4dab155cda150de99f7af64395c3a90", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "patch": "@@ -465,7 +465,8 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         let mut call_caps = Vec::new();\n         ir.tcx.with_freevars(expr.id, |freevars| {\n             for fv in freevars {\n-                if let Def::Local(_, rv) = fv.def {\n+                if let Def::Local(def_id) = fv.def {\n+                    let rv = ir.tcx.map.as_local_node_id(def_id).unwrap();\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n                     call_caps.push(CaptureInfo {ln: fv_ln,\n                                                 var_nid: rv});\n@@ -489,7 +490,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n \n       // otherwise, live nodes are not required:\n       hir::ExprIndex(..) | hir::ExprField(..) | hir::ExprTupField(..) |\n-      hir::ExprVec(..) | hir::ExprCall(..) | hir::ExprMethodCall(..) |\n+      hir::ExprArray(..) | hir::ExprCall(..) | hir::ExprMethodCall(..) |\n       hir::ExprTup(..) | hir::ExprBinary(..) | hir::ExprAddrOf(..) |\n       hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprBreak(_) |\n       hir::ExprAgain(_) | hir::ExprLit(_) | hir::ExprRet(..) |\n@@ -1094,7 +1095,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           // Uninteresting cases: just propagate in rev exec order\n \n-          hir::ExprVec(ref exprs) => {\n+          hir::ExprArray(ref exprs) => {\n             self.propagate_through_exprs(&exprs[..], succ)\n           }\n \n@@ -1270,7 +1271,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n         match self.ir.tcx.expect_def(expr.id) {\n-          Def::Local(_, nid) => {\n+          Def::Local(def_id) => {\n+            let nid = self.ir.tcx.map.as_local_node_id(def_id).unwrap();\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0 {\n                 self.init_from_succ(ln, succ);\n@@ -1434,7 +1436,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       hir::ExprCall(..) | hir::ExprMethodCall(..) | hir::ExprIf(..) |\n       hir::ExprMatch(..) | hir::ExprWhile(..) | hir::ExprLoop(..) |\n       hir::ExprIndex(..) | hir::ExprField(..) | hir::ExprTupField(..) |\n-      hir::ExprVec(..) | hir::ExprTup(..) | hir::ExprBinary(..) |\n+      hir::ExprArray(..) | hir::ExprTup(..) | hir::ExprBinary(..) |\n       hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprRet(..) |\n       hir::ExprBreak(..) | hir::ExprAgain(..) | hir::ExprLit(_) |\n       hir::ExprBlock(..) | hir::ExprAddrOf(..) |\n@@ -1529,11 +1531,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n             hir::ExprPath(..) => {\n-                if let Def::Local(_, nid) = self.ir.tcx.expect_def(expr.id) {\n+                if let Def::Local(def_id) = self.ir.tcx.expect_def(expr.id) {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability\n                     // as being used.\n+                    let nid = self.ir.tcx.map.as_local_node_id(def_id).unwrap();\n                     let ln = self.live_node(expr.id, expr.span);\n                     let var = self.variable(nid, expr.span);\n                     self.warn_about_dead_assign(expr.span, expr.id, ln, var);"}, {"sha": "9214138d2107769abc9c5a72e20f4478b9746f01", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "a476d0f6f30a673056748841055513c5a2189c31", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "30b735b9c24e359c9561a2e5f0b19ce4b8a01841", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 15, "deletions": 43, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "2d93c33afb4095e743978841418b33b9ce65dc2b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "5192575972b0200ade1b38ac3a9cedf15b16530c", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "2c08e17f8f1a5c8e4ed66272c6fe10ca8cd30f39", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "bc9bbebb1796a83627c3fe418ce934e395df3335", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "92de65798d3cbb18db8277631034ce72439f3f6d", "filename": "src/librustc/mir/mir_map.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4e2822c5c28bb342e5862ba7cc0b90b865c68be1/src%2Flibrustc%2Fmir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2822c5c28bb342e5862ba7cc0b90b865c68be1/src%2Flibrustc%2Fmir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmir_map.rs?ref=4e2822c5c28bb342e5862ba7cc0b90b865c68be1"}, {"sha": "9d82006ac9f9df244df43c0fb5e734bbdc4fc0d1", "filename": "src/librustc/mir/mod.rs", "status": "renamed", "additions": 205, "deletions": 126, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4", "previous_filename": "src/librustc/mir/repr.rs"}, {"sha": "f9afbaf104a663048df411e654afc08bc50d9936", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "3576ae662a005033e1a5f200327b9d03228dfa75", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "6057e7ec7e0f5164c2606941eb4a47331a01d12d", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "db7267ca0d4b888f340c46f85a369988fa3bc2d8", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 120, "deletions": 60, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "87a5c6410a8410e0b3daf242c93dbf8f70559418", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 59, "deletions": 72, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "82c2425aead734f4244f8f62a97febb54366a475", "filename": "src/librustc/session/filesearch.rs", "status": "modified", "additions": 37, "deletions": 45, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Ffilesearch.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "1ce5b223fbefe8cbc03b59ffb2a99d9c16792b4c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 76, "deletions": 17, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "68c88249ec0c36b29c3d061069f116dd438b6a53", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "9435f96c08a220c2afe2899fa2df97b1d224e08a", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "ded2fdc58b42b39fb5d6274ef01368ad740d9fe4", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "7ba10d9c0a58e1140d35de18d2148993014a5191", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 84, "deletions": 2, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "ce882c48377f74f3bb37bbb948235d01ec1bcf25", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "e75c8bd43340482372ecd0e8dc4520075f78dd8c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "e37425901c8c8f2dd74ae0d89cc9ce127692f9e3", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "1374719ef49c4875bd7eafe97a4fdd348a414a35", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 16, "deletions": 47, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "a0792dcf4dd59282863fd6fd304b50bbf9e09200", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "cfe370343ae490093682f58b15a0cc3469972184", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "62cc78141db468847f0cd70c59b390addb611e62", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 231, "deletions": 90, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "9b345c2d02329b5f1f6ca1e7a3a7da130cdb01b8", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "befc9533c387b338747e386c4e876ab0ff19ec44", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "649d78f9d9e2d003a028e441d4fd9e3d3f0c5a58", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "ae0a4a0e6bd112765c9b9a0a7c42d4f0d649598b", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "fdf5185eb69e2f205e3aa3d0aabe5daaa5d7e422", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "5ce43d905ec717cd84ec4c2d83d27f405314f880", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 103, "deletions": 63, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "cad87081a93b4a59e3dc63bab26fe8552a6bc0ac", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "588857e557c22fce71271141a104d135918afb1e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 181, "deletions": 237, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "cb90e6392cf03c613c28fc9b1173d4e84a72cf6a", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "3165edebf1a46256e302514fa4c8625bfb90db1f", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 6, "deletions": 38, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "92dfb883ef301db00d4287a4ffb2e4910230835e", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 67, "deletions": 57, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "a4ceecd8c9d7b27ef74df324a89def091b6c176b", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 84, "deletions": 105, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "3ff2ed76e571e3a8b308657186d9a069331e57cf", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "cca4069ba5a1799255be43dfd653e6d6b2f63ff5", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 144, "deletions": 27, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "bebdebf127a54542ec4bdf8a066ce516edc6edc1", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "1135199d2254a248a10092ee3c344390dc0adab9", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "5ca567410291ad3edacf7647aa810913a965b42b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 42, "deletions": 23, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "da5f787bdf31e3d9be859acdef4e83e178722215", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "97fb39c17ea0e58e77aec4bdca3a9ca5cefdd58f", "filename": "src/librustc_back/sha2.rs", "status": "removed", "additions": 0, "deletions": 679, "changes": 679, "blob_url": "https://github.com/rust-lang/rust/blob/4e2822c5c28bb342e5862ba7cc0b90b865c68be1/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e2822c5c28bb342e5862ba7cc0b90b865c68be1/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=4e2822c5c28bb342e5862ba7cc0b90b865c68be1"}, {"sha": "5ef79359140f775bc6bd6396c22926dfd0d04b5d", "filename": "src/librustc_back/target/aarch64_apple_ios.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_apple_ios.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "140195c780b9cae7eaa5cf45016a9cd55cf6e723", "filename": "src/librustc_back/target/aarch64_linux_android.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "a93a46d140238dabd7cd9122be1c20fbdf1e1b70", "filename": "src/librustc_back/target/aarch64_unknown_fuchsia.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_fuchsia.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "5f6335d405f5ea40fe49b1e7827c51a9ecc6ead1", "filename": "src/librustc_back/target/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "ad132c27cb8412210f9920c9cb8c11905f9819b1", "filename": "src/librustc_back/target/arm_base.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farm_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farm_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_base.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "c7d2df4344cb1efad4e8b22e6e4551751e25cbb5", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "77d35edfbd09cc465ef90a0a9afe03684a9d56d5", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabi.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "b183412be1934853bed150bfe546c3141d014cd3", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "261d4353c7a09f6b2623b2c109ed7df084e41cb0", "filename": "src/librustc_back/target/arm_unknown_linux_musleabi.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabi.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "1443dcf5bad418327f65be7807ee1bf31f4fe504", "filename": "src/librustc_back/target/arm_unknown_linux_musleabihf.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_musleabihf.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "9e9c443930624311c36e6f8483f8624b5bcf9f13", "filename": "src/librustc_back/target/armv7_apple_ios.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_apple_ios.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "42f0deaa3fbff7016f4283483061e4e937657c81", "filename": "src/librustc_back/target/armv7_linux_androideabi.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_linux_androideabi.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "96ccedd5bea5c4b59a0f6a37349d97550e8784c9", "filename": "src/librustc_back/target/armv7_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_gnueabihf.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "8f66e6a4f58d484ac385ff5830575eb7fcb47436", "filename": "src/librustc_back/target/armv7_unknown_linux_musleabihf.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_musleabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_musleabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7_unknown_linux_musleabihf.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "6edde6e73efd34415ce62bd70a9b77dd347dcfdc", "filename": "src/librustc_back/target/armv7s_apple_ios.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farmv7s_apple_ios.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "d86a9b093272e9b78b93e7b976f7fb4a84d483fe", "filename": "src/librustc_back/target/asmjs_unknown_emscripten.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "7555181a15cf20d5a5d3856401b10df91a5bfe10", "filename": "src/librustc_back/target/dragonfly_base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fdragonfly_base.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "7555181a15cf20d5a5d3856401b10df91a5bfe10", "filename": "src/librustc_back/target/freebsd_base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffreebsd_base.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "69546684cb70bda5c5626811199f0b72c56c8bc0", "filename": "src/librustc_back/target/fuchsia_base.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Ffuchsia_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Ffuchsia_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Ffuchsia_base.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "5e319ba1838a0a9558e4d31fe65092da0b5dd7b5", "filename": "src/librustc_back/target/haiku_base.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fhaiku_base.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "319ada4f8e17c11b05f56aa50fdebd75c805aca2", "filename": "src/librustc_back/target/i386_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "d3b09d9a0f1121354a76ce92cb56194e27b0b031", "filename": "src/librustc_back/target/i686_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "a2c007d49696021d50c5b6a7164b1d1b0a235ca6", "filename": "src/librustc_back/target/i686_linux_android.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_linux_android.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "0c2c5433e6c41c2515de68e9a0bbbe5ac35b1ef0", "filename": "src/librustc_back/target/i686_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "2290d2057f13076f28ae40ba66e9a9bbaeceaf3e", "filename": "src/librustc_back/target/i686_pc_windows_msvc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_msvc.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "d8f8431e66e7fa51b3937a8ced9dfedb78d09c3f", "filename": "src/librustc_back/target/i686_unknown_dragonfly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "ddbc74f25c9cdd9533283ea759a040239b808a26", "filename": "src/librustc_back/target/i686_unknown_freebsd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_freebsd.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "9078206c9e069cf3b98ee93c19626d217299d0c3", "filename": "src/librustc_back/target/i686_unknown_haiku.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_haiku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_haiku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_haiku.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "bf9c28b0c10e5ada26c1c2b13462aab4aeb4ff07", "filename": "src/librustc_back/target/i686_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "3d563fa6e5d97ece067ba6f547af8b33c80e9467", "filename": "src/librustc_back/target/i686_unknown_linux_musl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_musl.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "891e7dda14a2a4d931e3171966e97d4e7a53fb1e", "filename": "src/librustc_back/target/le32_unknown_nacl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fle32_unknown_nacl.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "c284840ecb4bdbdc3b06714732a85fabbe51d93d", "filename": "src/librustc_back/target/mips64_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips64_unknown_linux_gnuabi64.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "17895836fe87b54dba7020dbd5b2d00be9c0ecfd", "filename": "src/librustc_back/target/mips64el_unknown_linux_gnuabi64.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips64el_unknown_linux_gnuabi64.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "a6d8fae2536cae8628ab3d3b09fb64553ff442d1", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "e4a6d2a55d9813ea4ea188540edae6126447ff1d", "filename": "src/librustc_back/target/mips_unknown_linux_musl.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_musl.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "ccc64ea393b7885694640f22b6373ed7dfedf4f3", "filename": "src/librustc_back/target/mips_unknown_linux_uclibc.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_uclibc.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "9b8b1d5713f1d950771a36d3da49fe750208d944", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "5693bddd0488a51c780e53dbc07c2e641748e345", "filename": "src/librustc_back/target/mipsel_unknown_linux_musl.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_musl.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "3acade5a474445f1431585dbc0d62a79fed5a369", "filename": "src/librustc_back/target/mipsel_unknown_linux_uclibc.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_uclibc.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "4d9315a1a3bdb7b556e7e0cb7948dba6c3106329", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 83, "deletions": 13, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "6e038a7ed56ee2b9fae85974e934a5fda7c4b6ac", "filename": "src/librustc_back/target/netbsd_base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fnetbsd_base.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "90e6631841bef54600549e303001e091584ffadb", "filename": "src/librustc_back/target/openbsd_base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "909c5488dcb70374eaae5535870fe9606428af24", "filename": "src/librustc_back/target/powerpc64_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc64_unknown_linux_gnu.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "a692346ca0ffeeb95a88bf2183f3eea8b6ca4f90", "filename": "src/librustc_back/target/powerpc64le_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc64le_unknown_linux_gnu.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "284772c43319aedf193fd12af276ea1586adbd14", "filename": "src/librustc_back/target/powerpc_unknown_linux_gnu.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fpowerpc_unknown_linux_gnu.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "6e2dd6cd67c933962bac3d89eb0096aada18c4ff", "filename": "src/librustc_back/target/s390x_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fs390x_unknown_linux_gnu.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "6bb496649a8584cd31abf5c3419d0913db9d1300", "filename": "src/librustc_back/target/thumb_base.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fthumb_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fthumb_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fthumb_base.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "6c22f98538459ea5711308df1729b475ec60ab97", "filename": "src/librustc_back/target/thumbv6m_none_eabi.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fthumbv6m_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fthumbv6m_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fthumbv6m_none_eabi.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "ddad4e3624f3cef16a960f8f5058fcf82f2370e1", "filename": "src/librustc_back/target/thumbv7em_none_eabi.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fthumbv7em_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fthumbv7em_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fthumbv7em_none_eabi.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}, {"sha": "a9fac48e8e5ac39c549ea88439af6d99851d8102", "filename": "src/librustc_back/target/thumbv7em_none_eabihf.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fthumbv7em_none_eabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/655effedf25e2039d283b839429bf2f42b7012a4/src%2Flibrustc_back%2Ftarget%2Fthumbv7em_none_eabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fthumbv7em_none_eabihf.rs?ref=655effedf25e2039d283b839429bf2f42b7012a4"}]}