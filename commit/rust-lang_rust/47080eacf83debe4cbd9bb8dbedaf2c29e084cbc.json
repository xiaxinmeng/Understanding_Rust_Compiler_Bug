{"sha": "47080eacf83debe4cbd9bb8dbedaf2c29e084cbc", "node_id": "C_kwDOAAsO6NoAKDQ3MDgwZWFjZjgzZGViZTRjYmQ5YmI4ZGJlZGFmMmMyOWUwODRjYmM", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-05-25T09:44:44Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-05-25T10:00:13Z"}, "message": "Improve invalid memory ordering diagnostics.", "tree": {"sha": "3c9954ecaa34bc04a015a7363946c9966c0e976b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c9954ecaa34bc04a015a7363946c9966c0e976b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47080eacf83debe4cbd9bb8dbedaf2c29e084cbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47080eacf83debe4cbd9bb8dbedaf2c29e084cbc", "html_url": "https://github.com/rust-lang/rust/commit/47080eacf83debe4cbd9bb8dbedaf2c29e084cbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47080eacf83debe4cbd9bb8dbedaf2c29e084cbc/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "acb5c16fa8acf7fd3b48fc218881f006577bab1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/acb5c16fa8acf7fd3b48fc218881f006577bab1a", "html_url": "https://github.com/rust-lang/rust/commit/acb5c16fa8acf7fd3b48fc218881f006577bab1a"}], "stats": {"total": 143, "additions": 61, "deletions": 82}, "files": [{"sha": "170d85f5cd50b598c98d6b20ac9c9ef48c95415a", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 61, "deletions": 82, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/47080eacf83debe4cbd9bb8dbedaf2c29e084cbc/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47080eacf83debe4cbd9bb8dbedaf2c29e084cbc/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=47080eacf83debe4cbd9bb8dbedaf2c29e084cbc", "patch": "@@ -4,7 +4,6 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::{is_range_literal, Expr, ExprKind, Node};\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n@@ -1483,39 +1482,32 @@ impl InvalidAtomicOrdering {\n         None\n     }\n \n-    fn matches_ordering(cx: &LateContext<'_>, did: DefId, orderings: &[Symbol]) -> bool {\n+    fn match_ordering(cx: &LateContext<'_>, ord_arg: &Expr<'_>) -> Option<Symbol> {\n+        let ExprKind::Path(ref ord_qpath) = ord_arg.kind else { return None };\n+        let did = cx.qpath_res(ord_qpath, ord_arg.hir_id).opt_def_id()?;\n         let tcx = cx.tcx;\n         let atomic_ordering = tcx.get_diagnostic_item(sym::Ordering);\n-        orderings.iter().any(|ordering| {\n-            tcx.item_name(did) == *ordering && {\n-                let parent = tcx.parent(did);\n-                Some(parent) == atomic_ordering\n-                    // needed in case this is a ctor, not a variant\n-                    || tcx.opt_parent(parent) == atomic_ordering\n-            }\n-        })\n-    }\n-\n-    fn opt_ordering_defid(cx: &LateContext<'_>, ord_arg: &Expr<'_>) -> Option<DefId> {\n-        if let ExprKind::Path(ref ord_qpath) = ord_arg.kind {\n-            cx.qpath_res(ord_qpath, ord_arg.hir_id).opt_def_id()\n-        } else {\n-            None\n-        }\n+        let name = tcx.item_name(did);\n+        let parent = tcx.parent(did);\n+        [sym::Relaxed, sym::Release, sym::Acquire, sym::AcqRel, sym::SeqCst].into_iter().find(\n+            |&ordering| {\n+                name == ordering\n+                    && (Some(parent) == atomic_ordering\n+                            // needed in case this is a ctor, not a variant\n+                            || tcx.opt_parent(parent) == atomic_ordering)\n+            },\n+        )\n     }\n \n     fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        use rustc_hir::def::{DefKind, Res};\n-        use rustc_hir::QPath;\n         if let Some((method, args)) = Self::inherent_atomic_method_call(cx, expr, &[sym::load, sym::store])\n             && let Some((ordering_arg, invalid_ordering)) = match method {\n                 sym::load => Some((&args[1], sym::Release)),\n                 sym::store => Some((&args[2], sym::Acquire)),\n                 _ => None,\n             }\n-            && let ExprKind::Path(QPath::Resolved(_, path)) = ordering_arg.kind\n-            && let Res::Def(DefKind::Ctor(..), ctor_id) = path.res\n-            && Self::matches_ordering(cx, ctor_id, &[invalid_ordering, sym::AcqRel])\n+            && let Some(ordering) = Self::match_ordering(cx, ordering_arg)\n+            && (ordering == invalid_ordering || ordering == sym::AcqRel)\n         {\n             cx.struct_span_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, |diag| {\n                 if method == sym::load {\n@@ -1537,9 +1529,7 @@ impl InvalidAtomicOrdering {\n             && let ExprKind::Path(ref func_qpath) = func.kind\n             && let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id()\n             && matches!(cx.tcx.get_diagnostic_name(def_id), Some(sym::fence | sym::compiler_fence))\n-            && let ExprKind::Path(ref ordering_qpath) = &args[0].kind\n-            && let Some(ordering_def_id) = cx.qpath_res(ordering_qpath, args[0].hir_id).opt_def_id()\n-            && Self::matches_ordering(cx, ordering_def_id, &[sym::Relaxed])\n+            && Self::match_ordering(cx, &args[0]) == Some(sym::Relaxed)\n         {\n             cx.struct_span_lint(INVALID_ATOMIC_ORDERING, args[0].span, |diag| {\n                 diag.build(\"memory fences cannot have `Relaxed` ordering\")\n@@ -1550,62 +1540,51 @@ impl InvalidAtomicOrdering {\n     }\n \n     fn check_atomic_compare_exchange(cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if let Some((method, args)) = Self::inherent_atomic_method_call(cx, expr, &[sym::fetch_update, sym::compare_exchange, sym::compare_exchange_weak])\n-            && let Some((success_order_arg, failure_order_arg)) = match method {\n-                sym::fetch_update => Some((&args[1], &args[2])),\n-                sym::compare_exchange | sym::compare_exchange_weak => Some((&args[3], &args[4])),\n-                _ => None,\n-            }\n-            && let Some(fail_ordering_def_id) = Self::opt_ordering_defid(cx, failure_order_arg)\n-        {\n-            // Helper type holding on to some checking and error reporting data. Has\n-            // - (success ordering,\n-            // - list of failure orderings forbidden by the success order,\n-            // - suggestion message)\n-            type OrdLintInfo = (Symbol, &'static [Symbol], &'static str);\n-            const RELAXED: OrdLintInfo = (sym::Relaxed, &[sym::SeqCst, sym::Acquire], \"ordering mode `Relaxed`\");\n-            const ACQUIRE: OrdLintInfo = (sym::Acquire, &[sym::SeqCst], \"ordering modes `Acquire` or `Relaxed`\");\n-            const SEQ_CST: OrdLintInfo = (sym::SeqCst, &[], \"ordering modes `Acquire`, `SeqCst` or `Relaxed`\");\n-            const RELEASE: OrdLintInfo = (sym::Release, RELAXED.1, RELAXED.2);\n-            const ACQREL: OrdLintInfo = (sym::AcqRel, ACQUIRE.1, ACQUIRE.2);\n-            const SEARCH: [OrdLintInfo; 5] = [RELAXED, ACQUIRE, SEQ_CST, RELEASE, ACQREL];\n-\n-            let success_lint_info = Self::opt_ordering_defid(cx, success_order_arg)\n-                .and_then(|success_ord_def_id| -> Option<OrdLintInfo> {\n-                    SEARCH\n-                        .iter()\n-                        .copied()\n-                        .find(|(ordering, ..)| {\n-                            Self::matches_ordering(cx, success_ord_def_id, &[*ordering])\n-                        })\n-                });\n-            if Self::matches_ordering(cx, fail_ordering_def_id, &[sym::Release, sym::AcqRel]) {\n-                // If we don't know the success order is, use what we'd suggest\n-                // if it were maximally permissive.\n-                let suggested = success_lint_info.unwrap_or(SEQ_CST).2;\n-                cx.struct_span_lint(INVALID_ATOMIC_ORDERING, failure_order_arg.span, |diag| {\n-                    let msg = format!(\n-                        \"{}'s failure ordering may not be `Release` or `AcqRel`\",\n-                        method,\n-                    );\n-                    diag.build(&msg)\n-                        .help(&format!(\"consider using {} instead\", suggested))\n-                        .emit();\n-                });\n-            } else if let Some((success_ord, bad_ords_given_success, suggested)) = success_lint_info {\n-                if Self::matches_ordering(cx, fail_ordering_def_id, bad_ords_given_success) {\n-                    cx.struct_span_lint(INVALID_ATOMIC_ORDERING, failure_order_arg.span, |diag| {\n-                        let msg = format!(\n-                            \"{}'s failure ordering may not be stronger than the success ordering of `{}`\",\n-                            method,\n-                            success_ord,\n-                        );\n-                        diag.build(&msg)\n-                            .help(&format!(\"consider using {} instead\", suggested))\n-                            .emit();\n-                    });\n-                }\n-            }\n+        let Some((method, args)) = Self::inherent_atomic_method_call(cx, expr, &[sym::fetch_update, sym::compare_exchange, sym::compare_exchange_weak])\n+            else {return };\n+\n+        let (success_order_arg, fail_order_arg) = match method {\n+            sym::fetch_update => (&args[1], &args[2]),\n+            sym::compare_exchange | sym::compare_exchange_weak => (&args[3], &args[4]),\n+            _ => return,\n+        };\n+\n+        let Some(fail_ordering) = Self::match_ordering(cx, fail_order_arg) else { return };\n+\n+        if matches!(fail_ordering, sym::Release | sym::AcqRel) {\n+            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, fail_order_arg.span, |diag| {\n+                diag.build(&format!(\n+                    \"{method}'s failure ordering may not be `Release` or `AcqRel`, \\\n+                    since a failed {method} does not result in a write\",\n+                ))\n+                .span_label(fail_order_arg.span, \"invalid failure ordering\")\n+                .help(\"consider using Acquire or Relaxed failure ordering instead\")\n+                .emit();\n+            });\n+        }\n+\n+        let Some(success_ordering) = Self::match_ordering(cx, success_order_arg) else { return };\n+\n+        if matches!(\n+            (success_ordering, fail_ordering),\n+            (sym::Relaxed | sym::Release, sym::Acquire)\n+                | (sym::Relaxed | sym::Release | sym::Acquire | sym::AcqRel, sym::SeqCst)\n+        ) {\n+            let success_suggestion =\n+                if success_ordering == sym::Release && fail_ordering == sym::Acquire {\n+                    sym::AcqRel\n+                } else {\n+                    fail_ordering\n+                };\n+            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, success_order_arg.span, |diag| {\n+                diag.build(&format!(\n+                    \"{method}'s success ordering must be at least as strong as its failure ordering\"\n+                ))\n+                .span_label(fail_order_arg.span, format!(\"{fail_ordering} failure ordering\"))\n+                .span_label(success_order_arg.span, format!(\"{success_ordering} success ordering\"))\n+                .help(format!(\"consider using {success_suggestion} success ordering instead\"))\n+                .emit();\n+            });\n         }\n     }\n }"}]}