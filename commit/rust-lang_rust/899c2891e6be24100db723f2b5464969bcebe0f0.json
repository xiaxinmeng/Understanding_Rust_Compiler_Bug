{"sha": "899c2891e6be24100db723f2b5464969bcebe0f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5OWMyODkxZTZiZTI0MTAwZGI3MjNmMmI1NDY0OTY5YmNlYmUwZjA=", "commit": {"author": {"name": "Keith Yeung", "email": "kungfukeith11@gmail.com", "date": "2016-08-28T22:48:56Z"}, "committer": {"name": "Keith Yeung", "email": "kungfukeith11@gmail.com", "date": "2016-08-29T17:27:59Z"}, "message": "Fix illegal instruction caused by overflow in channel cloning", "tree": {"sha": "563ba3175d542f719dc233af876a451304991729", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/563ba3175d542f719dc233af876a451304991729"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/899c2891e6be24100db723f2b5464969bcebe0f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/899c2891e6be24100db723f2b5464969bcebe0f0", "html_url": "https://github.com/rust-lang/rust/commit/899c2891e6be24100db723f2b5464969bcebe0f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/899c2891e6be24100db723f2b5464969bcebe0f0/comments", "author": {"login": "KiChjang", "id": 3248587, "node_id": "MDQ6VXNlcjMyNDg1ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/3248587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KiChjang", "html_url": "https://github.com/KiChjang", "followers_url": "https://api.github.com/users/KiChjang/followers", "following_url": "https://api.github.com/users/KiChjang/following{/other_user}", "gists_url": "https://api.github.com/users/KiChjang/gists{/gist_id}", "starred_url": "https://api.github.com/users/KiChjang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KiChjang/subscriptions", "organizations_url": "https://api.github.com/users/KiChjang/orgs", "repos_url": "https://api.github.com/users/KiChjang/repos", "events_url": "https://api.github.com/users/KiChjang/events{/privacy}", "received_events_url": "https://api.github.com/users/KiChjang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KiChjang", "id": 3248587, "node_id": "MDQ6VXNlcjMyNDg1ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/3248587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KiChjang", "html_url": "https://github.com/KiChjang", "followers_url": "https://api.github.com/users/KiChjang/followers", "following_url": "https://api.github.com/users/KiChjang/following{/other_user}", "gists_url": "https://api.github.com/users/KiChjang/gists{/gist_id}", "starred_url": "https://api.github.com/users/KiChjang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KiChjang/subscriptions", "organizations_url": "https://api.github.com/users/KiChjang/orgs", "repos_url": "https://api.github.com/users/KiChjang/repos", "events_url": "https://api.github.com/users/KiChjang/events{/privacy}", "received_events_url": "https://api.github.com/users/KiChjang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4791e086d671d429db864787f6b60547a28b0f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4791e086d671d429db864787f6b60547a28b0f5", "html_url": "https://github.com/rust-lang/rust/commit/e4791e086d671d429db864787f6b60547a28b0f5"}], "stats": {"total": 28, "additions": 24, "deletions": 4}, "files": [{"sha": "2a9618251ff52ef21597c733eeae677ff9c2f8a2", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/899c2891e6be24100db723f2b5464969bcebe0f0/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/899c2891e6be24100db723f2b5464969bcebe0f0/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=899c2891e6be24100db723f2b5464969bcebe0f0", "patch": "@@ -21,6 +21,7 @@\n pub use self::Failure::*;\n \n use core::cmp;\n+use core::intrinsics::abort;\n use core::isize;\n \n use sync::atomic::{AtomicUsize, AtomicIsize, AtomicBool, Ordering};\n@@ -34,6 +35,7 @@ use time::Instant;\n \n const DISCONNECTED: isize = isize::MIN;\n const FUDGE: isize = 1024;\n+const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n #[cfg(test)]\n const MAX_STEALS: isize = 5;\n #[cfg(not(test))]\n@@ -46,7 +48,7 @@ pub struct Packet<T> {\n     to_wake: AtomicUsize, // SignalToken for wake up\n \n     // The number of channels which are currently using this packet.\n-    channels: AtomicIsize,\n+    channels: AtomicUsize,\n \n     // See the discussion in Port::drop and the channel send methods for what\n     // these are used for\n@@ -72,7 +74,7 @@ impl<T> Packet<T> {\n             cnt: AtomicIsize::new(0),\n             steals: 0,\n             to_wake: AtomicUsize::new(0),\n-            channels: AtomicIsize::new(2),\n+            channels: AtomicUsize::new(2),\n             port_dropped: AtomicBool::new(false),\n             sender_drain: AtomicIsize::new(0),\n             select_lock: Mutex::new(()),\n@@ -340,7 +342,14 @@ impl<T> Packet<T> {\n     // Prepares this shared packet for a channel clone, essentially just bumping\n     // a refcount.\n     pub fn clone_chan(&mut self) {\n-        self.channels.fetch_add(1, Ordering::SeqCst);\n+        let old_count = self.channels.fetch_add(1, Ordering::SeqCst);\n+\n+        // See comments on Arc::clone() on why we do this (for `mem::forget`).\n+        if old_count > MAX_REFCOUNT {\n+            unsafe {\n+                abort();\n+            }\n+        }\n     }\n \n     // Decrement the reference count on a channel. This is called whenever a"}, {"sha": "1d16e002a2bef460ce2d1cdb16397606e49f035e", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/899c2891e6be24100db723f2b5464969bcebe0f0/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/899c2891e6be24100db723f2b5464969bcebe0f0/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=899c2891e6be24100db723f2b5464969bcebe0f0", "patch": "@@ -36,6 +36,8 @@\n pub use self::Failure::*;\n use self::Blocker::*;\n \n+use core::intrinsics::abort;\n+use core::isize;\n use core::mem;\n use core::ptr;\n \n@@ -45,6 +47,8 @@ use sync::mpsc::select::StartResult::{self, Installed, Abort};\n use sync::{Mutex, MutexGuard};\n use time::Instant;\n \n+const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n+\n pub struct Packet<T> {\n     /// Only field outside of the mutex. Just done for kicks, but mainly because\n     /// the other shared channel already had the code implemented\n@@ -350,7 +354,14 @@ impl<T> Packet<T> {\n     // Prepares this shared packet for a channel clone, essentially just bumping\n     // a refcount.\n     pub fn clone_chan(&self) {\n-        self.channels.fetch_add(1, Ordering::SeqCst);\n+        let old_count = self.channels.fetch_add(1, Ordering::SeqCst);\n+\n+        // See comments on Arc::clone() on why we do this (for `mem::forget`).\n+        if old_count > MAX_REFCOUNT {\n+            unsafe {\n+                abort();\n+            }\n+        }\n     }\n \n     pub fn drop_chan(&self) {"}]}