{"sha": "0bc7d285189caaffc13e4d6856baf895f72ed80c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYzdkMjg1MTg5Y2FhZmZjMTNlNGQ2ODU2YmFmODk1ZjcyZWQ4MGM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-30T15:41:50Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-30T15:41:50Z"}, "message": "refactor $crate handling\n\nIntroduce proper hygiene module, which should grow quite a bit\neventually.", "tree": {"sha": "792693f3b35d2a23107ee5a1e4bbb13bc2806c41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/792693f3b35d2a23107ee5a1e4bbb13bc2806c41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bc7d285189caaffc13e4d6856baf895f72ed80c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bc7d285189caaffc13e4d6856baf895f72ed80c", "html_url": "https://github.com/rust-lang/rust/commit/0bc7d285189caaffc13e4d6856baf895f72ed80c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bc7d285189caaffc13e4d6856baf895f72ed80c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e34e71c62d9b4cf0ab237969e03ecde893ab347b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e34e71c62d9b4cf0ab237969e03ecde893ab347b", "html_url": "https://github.com/rust-lang/rust/commit/e34e71c62d9b4cf0ab237969e03ecde893ab347b"}], "stats": {"total": 207, "additions": 118, "deletions": 89}, "files": [{"sha": "575d78198c49ee750926ad6f6ba11e58f8d4d7ea", "filename": "crates/ra_hir/src/expr/lower.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bc7d285189caaffc13e4d6856baf895f72ed80c/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc7d285189caaffc13e4d6856baf895f72ed80c/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs?ref=0bc7d285189caaffc13e4d6856baf895f72ed80c", "patch": "@@ -1,6 +1,7 @@\n //! FIXME: write short doc here\n \n use hir_def::{\n+    hygiene::Hygiene,\n     name::{self, AsName, Name},\n     path::GenericArgs,\n     type_ref::TypeRef,\n@@ -597,7 +598,8 @@ where\n     }\n \n     fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n-        Path::from_src(Source { ast: path, file_id: self.current_file_id }, self.db)\n+        let hygiene = Hygiene::new(self.db, self.current_file_id);\n+        Path::from_src(path, &hygiene)\n     }\n }\n "}, {"sha": "9e4a4001770f04470ea59d7c5cb161df565035d6", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0bc7d285189caaffc13e4d6856baf895f72ed80c/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc7d285189caaffc13e4d6856baf895f72ed80c/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=0bc7d285189caaffc13e4d6856baf895f72ed80c", "patch": "@@ -3,7 +3,7 @@\n use rustc_hash::FxHashMap;\n use std::sync::Arc;\n \n-use hir_def::{attr::Attr, type_ref::TypeRef};\n+use hir_def::{attr::Attr, hygiene::Hygiene, type_ref::TypeRef};\n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n use ra_cfg::CfgOptions;\n use ra_syntax::{\n@@ -227,10 +227,11 @@ impl ModuleImplBlocks {\n         owner: &dyn ast::ModuleItemOwner,\n         file_id: HirFileId,\n     ) {\n+        let hygiene = Hygiene::new(db, file_id);\n         for item in owner.items_with_macros() {\n             match item {\n                 ast::ItemOrMacro::Item(ast::ModuleItem::ImplBlock(impl_block_ast)) => {\n-                    let attrs = Attr::from_attrs_owner(file_id, &impl_block_ast, db);\n+                    let attrs = Attr::from_attrs_owner(&impl_block_ast, &hygiene);\n                     if attrs.map_or(false, |attrs| {\n                         attrs.iter().any(|attr| attr.is_cfg_enabled(cfg_options) == Some(false))\n                     }) {\n@@ -247,7 +248,7 @@ impl ModuleImplBlocks {\n                 }\n                 ast::ItemOrMacro::Item(_) => (),\n                 ast::ItemOrMacro::Macro(macro_call) => {\n-                    let attrs = Attr::from_attrs_owner(file_id, &macro_call, db);\n+                    let attrs = Attr::from_attrs_owner(&macro_call, &hygiene);\n                     if attrs.map_or(false, |attrs| {\n                         attrs.iter().any(|attr| attr.is_cfg_enabled(cfg_options) == Some(false))\n                     }) {\n@@ -256,9 +257,8 @@ impl ModuleImplBlocks {\n \n                     //FIXME: we should really cut down on the boilerplate required to process a macro\n                     let ast_id = AstId::new(file_id, db.ast_id_map(file_id).ast_id(&macro_call));\n-                    if let Some(path) = macro_call\n-                        .path()\n-                        .and_then(|path| Path::from_src(Source { ast: path, file_id }, db))\n+                    if let Some(path) =\n+                        macro_call.path().and_then(|path| Path::from_src(path, &hygiene))\n                     {\n                         if let Some(def) = self.module.resolver(db).resolve_path_as_macro(db, &path)\n                         {"}, {"sha": "71f92adc297972103138222a21714252658c64ce", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0bc7d285189caaffc13e4d6856baf895f72ed80c/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc7d285189caaffc13e4d6856baf895f72ed80c/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=0bc7d285189caaffc13e4d6856baf895f72ed80c", "patch": "@@ -2,7 +2,6 @@\n \n use std::sync::Arc;\n \n-use hir_expand::db::AstDatabase;\n use mbe::ast_to_token_tree;\n use ra_cfg::CfgOptions;\n use ra_syntax::{\n@@ -11,7 +10,7 @@ use ra_syntax::{\n };\n use tt::Subtree;\n \n-use crate::{path::Path, HirFileId, Source};\n+use crate::{hygiene::Hygiene, path::Path};\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Attr {\n@@ -26,11 +25,8 @@ pub enum AttrInput {\n }\n \n impl Attr {\n-    pub(crate) fn from_src(\n-        Source { file_id, ast }: Source<ast::Attr>,\n-        db: &impl AstDatabase,\n-    ) -> Option<Attr> {\n-        let path = Path::from_src(Source { file_id, ast: ast.path()? }, db)?;\n+    pub(crate) fn from_src(ast: ast::Attr, hygiene: &Hygiene) -> Option<Attr> {\n+        let path = Path::from_src(ast.path()?, hygiene)?;\n         let input = match ast.input() {\n             None => None,\n             Some(ast::AttrInput::Literal(lit)) => {\n@@ -46,17 +42,13 @@ impl Attr {\n         Some(Attr { path, input })\n     }\n \n-    pub fn from_attrs_owner(\n-        file_id: HirFileId,\n-        owner: &dyn AttrsOwner,\n-        db: &impl AstDatabase,\n-    ) -> Option<Arc<[Attr]>> {\n+    pub fn from_attrs_owner(owner: &dyn AttrsOwner, hygiene: &Hygiene) -> Option<Arc<[Attr]>> {\n         let mut attrs = owner.attrs().peekable();\n         if attrs.peek().is_none() {\n             // Avoid heap allocation\n             return None;\n         }\n-        Some(attrs.flat_map(|ast| Attr::from_src(Source { file_id, ast }, db)).collect())\n+        Some(attrs.flat_map(|ast| Attr::from_src(ast, hygiene)).collect())\n     }\n \n     pub fn is_simple_atom(&self, name: &str) -> bool {"}, {"sha": "e1ae58a3bc9ab07fc504e0f76dd76c2d3500458f", "filename": "crates/ra_hir_def/src/hygiene.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0bc7d285189caaffc13e4d6856baf895f72ed80c/crates%2Fra_hir_def%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc7d285189caaffc13e4d6856baf895f72ed80c/crates%2Fra_hir_def%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fhygiene.rs?ref=0bc7d285189caaffc13e4d6856baf895f72ed80c", "patch": "@@ -0,0 +1,40 @@\n+//! This modules handles hygiene information.\n+//!\n+//! Specifically, `ast` + `Hygiene` allows you to create a `Name`. Note that, at\n+//! this moment, this is horribly incomplete and handles only `$crate`.\n+// Should this be moved to `hir_expand`? Seems like it.\n+\n+use hir_expand::{db::AstDatabase, HirFileId};\n+use ra_db::CrateId;\n+use ra_syntax::ast;\n+\n+use crate::{\n+    either::Either,\n+    name::{AsName, Name},\n+};\n+\n+#[derive(Debug)]\n+pub struct Hygiene {\n+    // This is what `$crate` expands to\n+    def_crate: Option<CrateId>,\n+}\n+\n+impl Hygiene {\n+    pub fn new(db: &impl AstDatabase, file_id: HirFileId) -> Hygiene {\n+        Hygiene { def_crate: file_id.macro_crate(db) }\n+    }\n+\n+    pub(crate) fn new_unhygienic() -> Hygiene {\n+        Hygiene { def_crate: None }\n+    }\n+\n+    // FIXME: this should just return name\n+    pub(crate) fn name_ref_to_name(&self, name_ref: ast::NameRef) -> Either<Name, CrateId> {\n+        if let Some(def_crate) = self.def_crate {\n+            if name_ref.text() == \"$crate\" {\n+                return Either::B(def_crate);\n+            }\n+        }\n+        Either::A(name_ref.as_name())\n+    }\n+}"}, {"sha": "61ccdb30d2c5abe7d495fca1d3e37ca1702a0beb", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bc7d285189caaffc13e4d6856baf895f72ed80c/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc7d285189caaffc13e4d6856baf895f72ed80c/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=0bc7d285189caaffc13e4d6856baf895f72ed80c", "patch": "@@ -13,6 +13,7 @@ pub mod attr;\n pub mod name;\n pub mod path;\n pub mod type_ref;\n+pub mod hygiene;\n \n // FIXME: this should be private\n pub mod nameres;"}, {"sha": "636364628b241d9be368c2ee085d140b948d9b26", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0bc7d285189caaffc13e4d6856baf895f72ed80c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc7d285189caaffc13e4d6856baf895f72ed80c/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=0bc7d285189caaffc13e4d6856baf895f72ed80c", "patch": "@@ -13,6 +13,7 @@ use crate::{\n     attr::Attr,\n     db::DefDatabase2,\n     either::Either,\n+    hygiene::Hygiene,\n     name::{AsName, Name},\n     path::Path,\n     FileAstId, HirFileId, ModuleSource, Source,\n@@ -78,7 +79,7 @@ impl RawItems {\n             source_ast_id_map: db.ast_id_map(file_id),\n             source_map: ImportSourceMap::default(),\n             file_id,\n-            db,\n+            hygiene: Hygiene::new(db, file_id),\n         };\n         if let Some(node) = db.parse_or_expand(file_id) {\n             if let Some(source_file) = ast::SourceFile::cast(node.clone()) {\n@@ -204,15 +205,15 @@ pub struct MacroData {\n     pub export: bool,\n }\n \n-struct RawItemsCollector<DB> {\n+struct RawItemsCollector {\n     raw_items: RawItems,\n     source_ast_id_map: Arc<AstIdMap>,\n     source_map: ImportSourceMap,\n     file_id: HirFileId,\n-    db: DB,\n+    hygiene: Hygiene,\n }\n \n-impl<DB: AstDatabase> RawItemsCollector<&DB> {\n+impl RawItemsCollector {\n     fn process_module(&mut self, current_module: Option<Module>, body: impl ast::ModuleItemOwner) {\n         for item_or_macro in body.items_with_macros() {\n             match item_or_macro {\n@@ -309,9 +310,10 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n         let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n         let attrs = self.parse_attrs(&use_item);\n \n+        let mut buf = Vec::new();\n         Path::expand_use_item(\n             Source { ast: use_item, file_id: self.file_id },\n-            self.db,\n+            &self.hygiene,\n             |path, use_tree, is_glob, alias| {\n                 let import_data = ImportData {\n                     path,\n@@ -321,14 +323,12 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n                     is_extern_crate: false,\n                     is_macro_use: false,\n                 };\n-                self.push_import(\n-                    current_module,\n-                    attrs.clone(),\n-                    import_data,\n-                    Either::A(AstPtr::new(use_tree)),\n-                );\n+                buf.push((import_data, Either::A(AstPtr::new(use_tree))));\n             },\n-        )\n+        );\n+        for (import_data, ptr) in buf {\n+            self.push_import(current_module, attrs.clone(), import_data, ptr);\n+        }\n     }\n \n     fn add_extern_crate_item(\n@@ -361,10 +361,7 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n \n     fn add_macro(&mut self, current_module: Option<Module>, m: ast::MacroCall) {\n         let attrs = self.parse_attrs(&m);\n-        let path = match m\n-            .path()\n-            .and_then(|path| Path::from_src(Source { ast: path, file_id: self.file_id }, self.db))\n-        {\n+        let path = match m.path().and_then(|path| Path::from_src(path, &self.hygiene)) {\n             Some(it) => it,\n             _ => return,\n         };\n@@ -402,6 +399,6 @@ impl<DB: AstDatabase> RawItemsCollector<&DB> {\n     }\n \n     fn parse_attrs(&self, item: &impl ast::AttrsOwner) -> Attrs {\n-        Attr::from_attrs_owner(self.file_id, item, self.db)\n+        Attr::from_attrs_owner(item, &self.hygiene)\n     }\n }"}, {"sha": "39f394c3f758352b51a6b5d59441a72e66eb9add", "filename": "crates/ra_hir_def/src/path.rs", "status": "modified", "additions": 49, "deletions": 52, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/0bc7d285189caaffc13e4d6856baf895f72ed80c/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc7d285189caaffc13e4d6856baf895f72ed80c/crates%2Fra_hir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fpath.rs?ref=0bc7d285189caaffc13e4d6856baf895f72ed80c", "patch": "@@ -2,14 +2,15 @@\n \n use std::{iter, sync::Arc};\n \n-use hir_expand::db::AstDatabase;\n use ra_db::CrateId;\n use ra_syntax::{\n     ast::{self, NameOwner, TypeAscriptionOwner},\n     AstNode,\n };\n \n use crate::{\n+    either::Either,\n+    hygiene::Hygiene,\n     name::{self, AsName, Name},\n     type_ref::TypeRef,\n     Source,\n@@ -68,11 +69,11 @@ impl Path {\n     /// Calls `cb` with all paths, represented by this use item.\n     pub fn expand_use_item(\n         item_src: Source<ast::UseItem>,\n-        db: &impl AstDatabase,\n+        hygiene: &Hygiene,\n         mut cb: impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n     ) {\n         if let Some(tree) = item_src.ast.use_tree() {\n-            expand_use_tree(None, tree, &|| item_src.file_id.macro_crate(db), &mut cb);\n+            expand_use_tree(None, tree, hygiene, &mut cb);\n         }\n     }\n \n@@ -89,17 +90,12 @@ impl Path {\n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// DEPRECATED: It does not handle `$crate` from macro call.\n     pub fn from_ast(path: ast::Path) -> Option<Path> {\n-        Path::parse(path, &|| None)\n+        Path::from_src(path, &Hygiene::new_unhygienic())\n     }\n \n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// It correctly handles `$crate` based path from macro call.\n-    pub fn from_src(source: Source<ast::Path>, db: &impl AstDatabase) -> Option<Path> {\n-        let file_id = source.file_id;\n-        Path::parse(source.ast, &|| file_id.macro_crate(db))\n-    }\n-\n-    fn parse(mut path: ast::Path, macro_crate: &impl Fn() -> Option<CrateId>) -> Option<Path> {\n+    pub fn from_src(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n         let mut kind = PathKind::Plain;\n         let mut segments = Vec::new();\n         loop {\n@@ -110,26 +106,28 @@ impl Path {\n             }\n \n             match segment.kind()? {\n-                ast::PathSegmentKind::Name(name) => {\n-                    if name.text() == \"$crate\" {\n-                        if let Some(macro_crate) = macro_crate() {\n-                            kind = PathKind::DollarCrate(macro_crate);\n+                ast::PathSegmentKind::Name(name_ref) => {\n+                    // FIXME: this should just return name\n+                    match hygiene.name_ref_to_name(name_ref) {\n+                        Either::A(name) => {\n+                            let args = segment\n+                                .type_arg_list()\n+                                .and_then(GenericArgs::from_ast)\n+                                .or_else(|| {\n+                                    GenericArgs::from_fn_like_path_ast(\n+                                        segment.param_list(),\n+                                        segment.ret_type(),\n+                                    )\n+                                })\n+                                .map(Arc::new);\n+                            let segment = PathSegment { name, args_and_bindings: args };\n+                            segments.push(segment);\n+                        }\n+                        Either::B(crate_id) => {\n+                            kind = PathKind::DollarCrate(crate_id);\n                             break;\n                         }\n                     }\n-\n-                    let args = segment\n-                        .type_arg_list()\n-                        .and_then(GenericArgs::from_ast)\n-                        .or_else(|| {\n-                            GenericArgs::from_fn_like_path_ast(\n-                                segment.param_list(),\n-                                segment.ret_type(),\n-                            )\n-                        })\n-                        .map(Arc::new);\n-                    let segment = PathSegment { name: name.as_name(), args_and_bindings: args };\n-                    segments.push(segment);\n                 }\n                 ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n                     assert!(path.qualifier().is_none()); // this can only occur at the first segment\n@@ -143,7 +141,7 @@ impl Path {\n                         }\n                         // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n                         Some(trait_ref) => {\n-                            let path = Path::parse(trait_ref.path()?, macro_crate)?;\n+                            let path = Path::from_src(trait_ref.path()?, hygiene)?;\n                             kind = path.kind;\n                             let mut prefix_segments = path.segments;\n                             prefix_segments.reverse();\n@@ -294,7 +292,7 @@ impl From<Name> for Path {\n fn expand_use_tree(\n     prefix: Option<Path>,\n     tree: ast::UseTree,\n-    macro_crate: &impl Fn() -> Option<CrateId>,\n+    hygiene: &Hygiene,\n     cb: &mut impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n ) {\n     if let Some(use_tree_list) = tree.use_tree_list() {\n@@ -303,13 +301,13 @@ fn expand_use_tree(\n             None => prefix,\n             // E.g. `use something::{inner}` (prefix is `None`, path is `something`)\n             // or `use something::{path::{inner::{innerer}}}` (prefix is `something::path`, path is `inner`)\n-            Some(path) => match convert_path(prefix, path, macro_crate) {\n+            Some(path) => match convert_path(prefix, path, hygiene) {\n                 Some(it) => Some(it),\n                 None => return, // FIXME: report errors somewhere\n             },\n         };\n         for child_tree in use_tree_list.use_trees() {\n-            expand_use_tree(prefix.clone(), child_tree, macro_crate, cb);\n+            expand_use_tree(prefix.clone(), child_tree, hygiene, cb);\n         }\n     } else {\n         let alias = tree.alias().and_then(|a| a.name()).map(|a| a.as_name());\n@@ -326,7 +324,7 @@ fn expand_use_tree(\n                     }\n                 }\n             }\n-            if let Some(path) = convert_path(prefix, ast_path, macro_crate) {\n+            if let Some(path) = convert_path(prefix, ast_path, hygiene) {\n                 let is_glob = tree.has_star();\n                 cb(path, &tree, is_glob, alias)\n             }\n@@ -336,37 +334,36 @@ fn expand_use_tree(\n     }\n }\n \n-fn convert_path(\n-    prefix: Option<Path>,\n-    path: ast::Path,\n-    macro_crate: &impl Fn() -> Option<CrateId>,\n-) -> Option<Path> {\n+fn convert_path(prefix: Option<Path>, path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n     let prefix = if let Some(qual) = path.qualifier() {\n-        Some(convert_path(prefix, qual, macro_crate)?)\n+        Some(convert_path(prefix, qual, hygiene)?)\n     } else {\n         prefix\n     };\n \n     let segment = path.segment()?;\n     let res = match segment.kind()? {\n-        ast::PathSegmentKind::Name(name) => {\n-            if name.text() == \"$crate\" {\n-                if let Some(krate) = macro_crate() {\n+        ast::PathSegmentKind::Name(name_ref) => {\n+            match hygiene.name_ref_to_name(name_ref) {\n+                Either::A(name) => {\n+                    // no type args in use\n+                    let mut res = prefix.unwrap_or_else(|| Path {\n+                        kind: PathKind::Plain,\n+                        segments: Vec::with_capacity(1),\n+                    });\n+                    res.segments.push(PathSegment {\n+                        name,\n+                        args_and_bindings: None, // no type args in use\n+                    });\n+                    res\n+                }\n+                Either::B(crate_id) => {\n                     return Some(Path::from_simple_segments(\n-                        PathKind::DollarCrate(krate),\n+                        PathKind::DollarCrate(crate_id),\n                         iter::empty(),\n-                    ));\n+                    ))\n                 }\n             }\n-\n-            // no type args in use\n-            let mut res = prefix\n-                .unwrap_or_else(|| Path { kind: PathKind::Plain, segments: Vec::with_capacity(1) });\n-            res.segments.push(PathSegment {\n-                name: name.as_name(),\n-                args_and_bindings: None, // no type args in use\n-            });\n-            res\n         }\n         ast::PathSegmentKind::CrateKw => {\n             if prefix.is_some() {"}]}