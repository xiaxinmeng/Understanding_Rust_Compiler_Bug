{"sha": "bdd0a78582efd17f588b35e3e227a65617d5afec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZDBhNzg1ODJlZmQxN2Y1ODhiMzVlM2UyMjdhNjU2MTdkNWFmZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-17T06:00:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-17T06:00:12Z"}, "message": "Auto merge of #80091 - GuillaumeGomez:str-to-symbol, r=jyn514\n\nReplace String with Symbol where possible\n\nThe same as #80047 but on different types. Might be interesting to run some perf comparison.\n\nr? `@jyn514`", "tree": {"sha": "7c29f9c5092135fffccb6a93674ec36e237286ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c29f9c5092135fffccb6a93674ec36e237286ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdd0a78582efd17f588b35e3e227a65617d5afec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd0a78582efd17f588b35e3e227a65617d5afec", "html_url": "https://github.com/rust-lang/rust/commit/bdd0a78582efd17f588b35e3e227a65617d5afec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdd0a78582efd17f588b35e3e227a65617d5afec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b84d36a0b9ea3bf305f36f08d50aa42c26f96c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b84d36a0b9ea3bf305f36f08d50aa42c26f96c2", "html_url": "https://github.com/rust-lang/rust/commit/9b84d36a0b9ea3bf305f36f08d50aa42c26f96c2"}, {"sha": "50d221c9244c87f22a791af86cff8f3139523dbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/50d221c9244c87f22a791af86cff8f3139523dbf", "html_url": "https://github.com/rust-lang/rust/commit/50d221c9244c87f22a791af86cff8f3139523dbf"}], "stats": {"total": 215, "additions": 109, "deletions": 106}, "files": [{"sha": "72603f00697ee1f5a4f875d47a4a257a88a28a91", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=bdd0a78582efd17f588b35e3e227a65617d5afec", "patch": "@@ -333,10 +333,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 match br {\n                     // We only care about named late bound regions, as we need to add them\n                     // to the 'for<>' section\n-                    ty::BrNamed(_, name) => Some(GenericParamDef {\n-                        name: name.to_string(),\n-                        kind: GenericParamDefKind::Lifetime,\n-                    }),\n+                    ty::BrNamed(_, name) => {\n+                        Some(GenericParamDef { name, kind: GenericParamDefKind::Lifetime })\n+                    }\n                     _ => None,\n                 }\n             })\n@@ -569,7 +568,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 }\n                 WherePredicate::EqPredicate { lhs, rhs } => {\n                     match lhs {\n-                        Type::QPath { name: ref left_name, ref self_type, ref trait_ } => {\n+                        Type::QPath { name: left_name, ref self_type, ref trait_ } => {\n                             let ty = &*self_type;\n                             match **trait_ {\n                                 Type::ResolvedPath {\n@@ -580,7 +579,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                 } => {\n                                     let mut new_trait_path = trait_path.clone();\n \n-                                    if self.is_fn_ty(tcx, trait_) && left_name == FN_OUTPUT_NAME {\n+                                    if self.is_fn_ty(tcx, trait_) && left_name == sym::Output {\n                                         ty_to_fn\n                                             .entry(*ty.clone())\n                                             .and_modify(|e| *e = (e.0.clone(), Some(rhs.clone())))"}, {"sha": "7bb8e5e8cfcb622e803355cdb00b351e9e852119", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=bdd0a78582efd17f588b35e3e227a65617d5afec", "patch": "@@ -12,7 +12,7 @@ use rustc_metadata::creader::LoadedMacro;\n use rustc_middle::ty;\n use rustc_mir::const_eval::is_min_const_fn;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n use crate::clean::{self, Attributes, GetDefId, ToSource, TypeKind};\n@@ -583,7 +583,7 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n     for pred in &mut g.where_predicates {\n         match *pred {\n             clean::WherePredicate::BoundPredicate { ty: clean::Generic(ref s), ref mut bounds }\n-                if *s == \"Self\" =>\n+                if *s == kw::SelfUpper =>\n             {\n                 bounds.retain(|bound| match *bound {\n                     clean::GenericBound::TraitBound(\n@@ -606,7 +606,7 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n                     name: ref _name,\n                 },\n             ref bounds,\n-        } => !(bounds.is_empty() || *s == \"Self\" && did == trait_did),\n+        } => !(bounds.is_empty() || *s == kw::SelfUpper && did == trait_did),\n         _ => true,\n     });\n     g\n@@ -621,7 +621,7 @@ fn separate_supertrait_bounds(\n     let mut ty_bounds = Vec::new();\n     g.where_predicates.retain(|pred| match *pred {\n         clean::WherePredicate::BoundPredicate { ty: clean::Generic(ref s), ref bounds }\n-            if *s == \"Self\" =>\n+            if *s == kw::SelfUpper =>\n         {\n             ty_bounds.extend(bounds.iter().cloned());\n             false"}, {"sha": "2105ec0b0ba0e1beaa4ed27e62ebdc174f1f9b5a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 30, "deletions": 37, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bdd0a78582efd17f588b35e3e227a65617d5afec", "patch": "@@ -48,8 +48,6 @@ crate use self::types::Type::*;\n crate use self::types::Visibility::{Inherited, Public};\n crate use self::types::*;\n \n-const FN_OUTPUT_NAME: &str = \"Output\";\n-\n crate trait Clean<T> {\n     fn clean(&self, cx: &DocContext<'_>) -> T;\n }\n@@ -329,10 +327,9 @@ impl Clean<GenericBound> for (ty::PolyTraitRef<'_>, &[TypeBinding]) {\n             .collect_referenced_late_bound_regions(&poly_trait_ref)\n             .into_iter()\n             .filter_map(|br| match br {\n-                ty::BrNamed(_, name) => Some(GenericParamDef {\n-                    name: name.to_string(),\n-                    kind: GenericParamDefKind::Lifetime,\n-                }),\n+                ty::BrNamed(_, name) => {\n+                    Some(GenericParamDef { name, kind: GenericParamDefKind::Lifetime })\n+                }\n                 _ => None,\n             })\n             .collect();\n@@ -546,7 +543,7 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n             GenericBound::Outlives(_) => panic!(\"cleaning a trait got a lifetime\"),\n         };\n         Type::QPath {\n-            name: cx.tcx.associated_item(self.item_def_id).ident.name.clean(cx),\n+            name: cx.tcx.associated_item(self.item_def_id).ident.name,\n             self_type: box self.self_ty().clean(cx),\n             trait_: box trait_,\n         }\n@@ -556,14 +553,12 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n impl Clean<GenericParamDef> for ty::GenericParamDef {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n-            ty::GenericParamDefKind::Lifetime => {\n-                (self.name.to_string(), GenericParamDefKind::Lifetime)\n-            }\n+            ty::GenericParamDefKind::Lifetime => (self.name, GenericParamDefKind::Lifetime),\n             ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n                 let default =\n                     if has_default { Some(cx.tcx.type_of(self.def_id).clean(cx)) } else { None };\n                 (\n-                    self.name.clean(cx),\n+                    self.name,\n                     GenericParamDefKind::Type {\n                         did: self.def_id,\n                         bounds: vec![], // These are filled in from the where-clauses.\n@@ -573,7 +568,7 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n                 )\n             }\n             ty::GenericParamDefKind::Const { .. } => (\n-                self.name.clean(cx),\n+                self.name,\n                 GenericParamDefKind::Const {\n                     did: self.def_id,\n                     ty: cx.tcx.type_of(self.def_id).clean(cx),\n@@ -599,14 +594,14 @@ impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n                     for bound in bounds {\n                         s.push_str(&format!(\" + {}\", bound.name.ident()));\n                     }\n-                    s\n+                    Symbol::intern(&s)\n                 } else {\n-                    self.name.ident().to_string()\n+                    self.name.ident().name\n                 };\n                 (name, GenericParamDefKind::Lifetime)\n             }\n             hir::GenericParamKind::Type { ref default, synthetic } => (\n-                self.name.ident().name.clean(cx),\n+                self.name.ident().name,\n                 GenericParamDefKind::Type {\n                     did: cx.tcx.hir().local_def_id(self.hir_id).to_def_id(),\n                     bounds: self.bounds.clean(cx),\n@@ -615,7 +610,7 @@ impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n                 },\n             ),\n             hir::GenericParamKind::Const { ref ty } => (\n-                self.name.ident().name.clean(cx),\n+                self.name.ident().name,\n                 GenericParamDefKind::Const {\n                     did: cx.tcx.hir().local_def_id(self.hir_id).to_def_id(),\n                     ty: ty.clean(cx),\n@@ -730,7 +725,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n             .collect::<Vec<GenericParamDef>>();\n \n         // param index -> [(DefId of trait, associated type name, type)]\n-        let mut impl_trait_proj = FxHashMap::<u32, Vec<(DefId, String, Ty<'tcx>)>>::default();\n+        let mut impl_trait_proj = FxHashMap::<u32, Vec<(DefId, Symbol, Ty<'tcx>)>>::default();\n \n         let where_predicates = preds\n             .predicates\n@@ -778,11 +773,10 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n                         if let Some(((_, trait_did, name), rhs)) =\n                             proj.as_ref().and_then(|(lhs, rhs)| Some((lhs.projection()?, rhs)))\n                         {\n-                            impl_trait_proj.entry(param_idx).or_default().push((\n-                                trait_did,\n-                                name.to_string(),\n-                                rhs,\n-                            ));\n+                            impl_trait_proj\n+                                .entry(param_idx)\n+                                .or_default()\n+                                .push((trait_did, name, rhs));\n                         }\n \n                         return None;\n@@ -800,7 +794,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n             if let crate::core::ImplTraitParam::ParamIndex(idx) = param {\n                 if let Some(proj) = impl_trait_proj.remove(&idx) {\n                     for (trait_did, name, rhs) in proj {\n-                        simplify::merge_bounds(cx, &mut bounds, trait_did, &name, &rhs.clean(cx));\n+                        simplify::merge_bounds(cx, &mut bounds, trait_did, name, &rhs.clean(cx));\n                     }\n                 }\n             } else {\n@@ -936,9 +930,9 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [Ident]) {\n                 .iter()\n                 .enumerate()\n                 .map(|(i, ty)| {\n-                    let mut name = self.1.get(i).map(|ident| ident.to_string()).unwrap_or_default();\n+                    let mut name = self.1.get(i).map(|ident| ident.name).unwrap_or(kw::Invalid);\n                     if name.is_empty() {\n-                        name = \"_\".to_string();\n+                        name = kw::Underscore;\n                     }\n                     Argument { name, type_: ty.clean(cx) }\n                 })\n@@ -995,7 +989,7 @@ impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n                     .iter()\n                     .map(|t| Argument {\n                         type_: t.clean(cx),\n-                        name: names.next().map_or_else(|| String::new(), |name| name.to_string()),\n+                        name: names.next().map(|i| i.name).unwrap_or(kw::Invalid),\n                     })\n                     .collect(),\n             },\n@@ -1150,12 +1144,12 @@ impl Clean<Item> for ty::AssocItem {\n                     };\n                     let self_arg_ty = sig.input(0).skip_binder();\n                     if self_arg_ty == self_ty {\n-                        decl.inputs.values[0].type_ = Generic(String::from(\"Self\"));\n+                        decl.inputs.values[0].type_ = Generic(kw::SelfUpper);\n                     } else if let ty::Ref(_, ty, _) = *self_arg_ty.kind() {\n                         if ty == self_ty {\n                             match decl.inputs.values[0].type_ {\n                                 BorrowedRef { ref mut type_, .. } => {\n-                                    **type_ = Generic(String::from(\"Self\"))\n+                                    **type_ = Generic(kw::SelfUpper)\n                                 }\n                                 _ => unreachable!(),\n                             }\n@@ -1210,7 +1204,7 @@ impl Clean<Item> for ty::AssocItem {\n                 }\n             }\n             ty::AssocKind::Type => {\n-                let my_name = self.ident.name.clean(cx);\n+                let my_name = self.ident.name;\n \n                 if let ty::TraitContainer(_) = self.container {\n                     let bounds = cx.tcx.explicit_item_bounds(self.def_id);\n@@ -1235,7 +1229,7 @@ impl Clean<Item> for ty::AssocItem {\n                                 _ => return None,\n                             }\n                             match **self_type {\n-                                Generic(ref s) if *s == \"Self\" => {}\n+                                Generic(ref s) if *s == kw::SelfUpper => {}\n                                 _ => return None,\n                             }\n                             Some(bounds)\n@@ -1408,7 +1402,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &DocContext<'_>) -> Type {\n                 segments: trait_segments.clean(cx),\n             };\n             Type::QPath {\n-                name: p.segments.last().expect(\"segments were empty\").ident.name.clean(cx),\n+                name: p.segments.last().expect(\"segments were empty\").ident.name,\n                 self_type: box qself.clean(cx),\n                 trait_: box resolve_type(cx, trait_path, hir_id),\n             }\n@@ -1422,7 +1416,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &DocContext<'_>) -> Type {\n             };\n             let trait_path = hir::Path { span, res, segments: &[] };\n             Type::QPath {\n-                name: segment.ident.name.clean(cx),\n+                name: segment.ident.name,\n                 self_type: box qself.clean(cx),\n                 trait_: box resolve_type(cx, trait_path.clean(cx), hir_id),\n             }\n@@ -1625,7 +1619,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 let mut bindings = vec![];\n                 for pb in obj.projection_bounds() {\n                     bindings.push(TypeBinding {\n-                        name: cx.tcx.associated_item(pb.item_def_id()).ident.name.clean(cx),\n+                        name: cx.tcx.associated_item(pb.item_def_id()).ident.name,\n                         kind: TypeBindingKind::Equality { ty: pb.skip_binder().ty.clean(cx) },\n                     });\n                 }\n@@ -1644,7 +1638,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&p.index.into()) {\n                     ImplTrait(bounds)\n                 } else {\n-                    Generic(p.name.to_string())\n+                    Generic(p.name)\n                 }\n             }\n \n@@ -1702,8 +1696,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                                                 .tcx\n                                                 .associated_item(proj.projection_ty.item_def_id)\n                                                 .ident\n-                                                .name\n-                                                .clean(cx),\n+                                                .name,\n                                             kind: TypeBindingKind::Equality {\n                                                 ty: proj.ty.clean(cx),\n                                             },\n@@ -2339,7 +2332,7 @@ impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n \n impl Clean<TypeBinding> for hir::TypeBinding<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> TypeBinding {\n-        TypeBinding { name: self.ident.name.clean(cx), kind: self.kind.clean(cx) }\n+        TypeBinding { name: self.ident.name, kind: self.kind.clean(cx) }\n     }\n }\n "}, {"sha": "16aaa9cfd20eb51b32c0ce92b801b9d65970098e", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=bdd0a78582efd17f588b35e3e227a65617d5afec", "patch": "@@ -15,6 +15,7 @@ use std::collections::BTreeMap;\n \n use rustc_hir::def_id::DefId;\n use rustc_middle::ty;\n+use rustc_span::Symbol;\n \n use crate::clean;\n use crate::clean::GenericArgs as PP;\n@@ -78,7 +79,7 @@ crate fn merge_bounds(\n     cx: &clean::DocContext<'_>,\n     bounds: &mut Vec<clean::GenericBound>,\n     trait_did: DefId,\n-    name: &str,\n+    name: Symbol,\n     rhs: &clean::Type,\n ) -> bool {\n     !bounds.iter_mut().any(|b| {\n@@ -100,7 +101,7 @@ crate fn merge_bounds(\n         match last.args {\n             PP::AngleBracketed { ref mut bindings, .. } => {\n                 bindings.push(clean::TypeBinding {\n-                    name: name.to_string(),\n+                    name,\n                     kind: clean::TypeBindingKind::Equality { ty: rhs.clone() },\n                 });\n             }"}, {"sha": "9bade5ad2ecfef486ab676bb2a98eb3cca5e77a0", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=bdd0a78582efd17f588b35e3e227a65617d5afec", "patch": "@@ -949,7 +949,7 @@ impl GenericParamDefKind {\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate struct GenericParamDef {\n-    crate name: String,\n+    crate name: Symbol,\n     crate kind: GenericParamDefKind,\n }\n \n@@ -1037,7 +1037,7 @@ crate struct Arguments {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate struct Argument {\n     crate type_: Type,\n-    crate name: String,\n+    crate name: Symbol,\n }\n \n #[derive(Clone, PartialEq, Debug)]\n@@ -1049,7 +1049,7 @@ crate enum SelfTy {\n \n impl Argument {\n     crate fn to_self(&self) -> Option<SelfTy> {\n-        if self.name != \"self\" {\n+        if self.name != kw::SelfLower {\n             return None;\n         }\n         if self.type_.is_self_type() {\n@@ -1117,7 +1117,7 @@ crate enum Type {\n     },\n     /// For parameterized types, so the consumer of the JSON don't go\n     /// looking for types which don't exist anywhere.\n-    Generic(String),\n+    Generic(Symbol),\n     /// Primitives are the fixed-size numeric types (plus int/usize/float), char,\n     /// arrays, slices, and tuples.\n     Primitive(PrimitiveType),\n@@ -1136,7 +1136,7 @@ crate enum Type {\n \n     // `<Type as Trait>::Name`\n     QPath {\n-        name: String,\n+        name: Symbol,\n         self_type: Box<Type>,\n         trait_: Box<Type>,\n     },\n@@ -1237,7 +1237,7 @@ impl Type {\n \n     crate fn is_self_type(&self) -> bool {\n         match *self {\n-            Generic(ref name) => name == \"Self\",\n+            Generic(name) => name == kw::SelfUpper,\n             _ => false,\n         }\n     }\n@@ -1282,16 +1282,16 @@ impl Type {\n         }\n     }\n \n-    crate fn projection(&self) -> Option<(&Type, DefId, &str)> {\n+    crate fn projection(&self) -> Option<(&Type, DefId, Symbol)> {\n         let (self_, trait_, name) = match self {\n-            QPath { ref self_type, ref trait_, ref name } => (self_type, trait_, name),\n+            QPath { ref self_type, ref trait_, name } => (self_type, trait_, name),\n             _ => return None,\n         };\n         let trait_did = match **trait_ {\n             ResolvedPath { did, .. } => did,\n             _ => return None,\n         };\n-        Some((&self_, trait_did, name))\n+        Some((&self_, trait_did, *name))\n     }\n }\n \n@@ -1816,7 +1816,7 @@ crate struct ProcMacro {\n /// `A: Send + Sync` in `Foo<A: Send + Sync>`).\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n crate struct TypeBinding {\n-    crate name: String,\n+    crate name: Symbol,\n     crate kind: TypeBindingKind,\n }\n "}, {"sha": "ec922b182e2bc5cfab31db87ee902193a8549258", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=bdd0a78582efd17f588b35e3e227a65617d5afec", "patch": "@@ -170,13 +170,13 @@ crate fn get_real_types(\n     cx: &DocContext<'_>,\n     recurse: i32,\n ) -> FxHashSet<(Type, TypeKind)> {\n-    let arg_s = arg.print().to_string();\n     let mut res = FxHashSet::default();\n     if recurse >= 10 {\n         // FIXME: remove this whole recurse thing when the recursion bug is fixed\n         return res;\n     }\n     if arg.is_full_generic() {\n+        let arg_s = Symbol::intern(&arg.print().to_string());\n         if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n             &WherePredicate::BoundPredicate { ref ty, .. } => ty.def_id() == arg.def_id(),\n             _ => false,\n@@ -375,13 +375,13 @@ impl ToSource for rustc_span::Span {\n     }\n }\n \n-crate fn name_from_pat(p: &hir::Pat<'_>) -> String {\n+crate fn name_from_pat(p: &hir::Pat<'_>) -> Symbol {\n     use rustc_hir::*;\n     debug!(\"trying to get a name from pattern: {:?}\", p);\n \n-    match p.kind {\n-        PatKind::Wild => \"_\".to_string(),\n-        PatKind::Binding(_, _, ident, _) => ident.to_string(),\n+    Symbol::intern(&match p.kind {\n+        PatKind::Wild => return kw::Underscore,\n+        PatKind::Binding(_, _, ident, _) => return ident.name,\n         PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),\n         PatKind::Struct(ref name, ref fields, etc) => format!(\n             \"{} {{ {}{} }}\",\n@@ -393,32 +393,37 @@ crate fn name_from_pat(p: &hir::Pat<'_>) -> String {\n                 .join(\", \"),\n             if etc { \", ..\" } else { \"\" }\n         ),\n-        PatKind::Or(ref pats) => {\n-            pats.iter().map(|p| name_from_pat(&**p)).collect::<Vec<String>>().join(\" | \")\n-        }\n+        PatKind::Or(ref pats) => pats\n+            .iter()\n+            .map(|p| name_from_pat(&**p).to_string())\n+            .collect::<Vec<String>>()\n+            .join(\" | \"),\n         PatKind::Tuple(ref elts, _) => format!(\n             \"({})\",\n-            elts.iter().map(|p| name_from_pat(&**p)).collect::<Vec<String>>().join(\", \")\n+            elts.iter()\n+                .map(|p| name_from_pat(&**p).to_string())\n+                .collect::<Vec<String>>()\n+                .join(\", \")\n         ),\n-        PatKind::Box(ref p) => name_from_pat(&**p),\n-        PatKind::Ref(ref p, _) => name_from_pat(&**p),\n+        PatKind::Box(ref p) => return name_from_pat(&**p),\n+        PatKind::Ref(ref p, _) => return name_from_pat(&**p),\n         PatKind::Lit(..) => {\n             warn!(\n                 \"tried to get argument name from PatKind::Lit, which is silly in function arguments\"\n             );\n-            \"()\".to_string()\n+            return Symbol::intern(\"()\");\n         }\n         PatKind::Range(..) => panic!(\n             \"tried to get argument name from PatKind::Range, \\\n              which is not allowed in function arguments\"\n         ),\n         PatKind::Slice(ref begin, ref mid, ref end) => {\n-            let begin = begin.iter().map(|p| name_from_pat(&**p));\n+            let begin = begin.iter().map(|p| name_from_pat(&**p).to_string());\n             let mid = mid.as_ref().map(|p| format!(\"..{}\", name_from_pat(&**p))).into_iter();\n-            let end = end.iter().map(|p| name_from_pat(&**p));\n+            let end = end.iter().map(|p| name_from_pat(&**p).to_string());\n             format!(\"[{}]\", begin.chain(mid).chain(end).collect::<Vec<_>>().join(\", \"))\n         }\n-    }\n+    })\n }\n \n crate fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n@@ -534,10 +539,10 @@ crate fn resolve_type(cx: &DocContext<'_>, path: Path, id: hir::HirId) -> Type {\n     let is_generic = match path.res {\n         Res::PrimTy(p) => return Primitive(PrimitiveType::from(p)),\n         Res::SelfTy(..) if path.segments.len() == 1 => {\n-            return Generic(kw::SelfUpper.to_string());\n+            return Generic(kw::SelfUpper);\n         }\n         Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n-            return Generic(format!(\"{:#}\", path.print()));\n+            return Generic(Symbol::intern(&format!(\"{:#}\", path.print())));\n         }\n         Res::SelfTy(..) | Res::Def(DefKind::TyParam | DefKind::AssocTy, _) => true,\n         _ => false,"}, {"sha": "c49c48922378e9720e4732aa38c294b011c9690e", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=bdd0a78582efd17f588b35e3e227a65617d5afec", "patch": "@@ -172,7 +172,7 @@ impl clean::GenericParamDef {\n         display_fn(move |f| match self.kind {\n             clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n             clean::GenericParamDefKind::Type { ref bounds, ref default, .. } => {\n-                f.write_str(&self.name)?;\n+                f.write_str(&*self.name.as_str())?;\n \n                 if !bounds.is_empty() {\n                     if f.alternate() {\n@@ -193,13 +193,10 @@ impl clean::GenericParamDef {\n                 Ok(())\n             }\n             clean::GenericParamDefKind::Const { ref ty, .. } => {\n-                f.write_str(\"const \")?;\n-                f.write_str(&self.name)?;\n-\n                 if f.alternate() {\n-                    write!(f, \": {:#}\", ty.print())\n+                    write!(f, \"const {}: {:#}\", self.name, ty.print())\n                 } else {\n-                    write!(f, \":&nbsp;{}\", ty.print())\n+                    write!(f, \"const {}:&nbsp;{}\", self.name, ty.print())\n                 }\n             }\n         })\n@@ -638,7 +635,7 @@ crate fn anchor(did: DefId, text: &str) -> impl fmt::Display + '_ {\n \n fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter<'_>, use_absolute: bool) -> fmt::Result {\n     match *t {\n-        clean::Generic(ref name) => f.write_str(name),\n+        clean::Generic(name) => write!(f, \"{}\", name),\n         clean::ResolvedPath { did, ref param_names, ref path, is_generic } => {\n             if param_names.is_some() {\n                 f.write_str(\"dyn \")?;\n@@ -1203,7 +1200,7 @@ impl clean::ImportSource {\n impl clean::TypeBinding {\n     crate fn print(&self) -> impl fmt::Display + '_ {\n         display_fn(move |f| {\n-            f.write_str(&self.name)?;\n+            f.write_str(&*self.name.as_str())?;\n             match self.kind {\n                 clean::TypeBindingKind::Equality { ref ty } => {\n                     if f.alternate() {"}, {"sha": "80f54d8e161a8dcb4437bfe34882e4a0ee7c5f83", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=bdd0a78582efd17f588b35e3e227a65617d5afec", "patch": "@@ -208,7 +208,7 @@ fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option\n             });\n             Some(path_segment.name.clone())\n         }\n-        clean::Generic(ref s) if accept_generic => Some(s.clone()),\n+        clean::Generic(s) if accept_generic => Some(s.to_string()),\n         clean::Primitive(ref p) => Some(format!(\"{:?}\", p)),\n         clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_, accept_generic),\n         // FIXME: add all from clean::Type."}, {"sha": "809cfb9d7432d7430e44e050d00a17fedc5acad4", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=bdd0a78582efd17f588b35e3e227a65617d5afec", "patch": "@@ -136,7 +136,7 @@ impl From<clean::Constant> for Constant {\n \n impl From<clean::TypeBinding> for TypeBinding {\n     fn from(binding: clean::TypeBinding) -> Self {\n-        TypeBinding { name: binding.name, binding: binding.kind.into() }\n+        TypeBinding { name: binding.name.to_string(), binding: binding.kind.into() }\n     }\n }\n \n@@ -275,7 +275,7 @@ impl From<clean::Generics> for Generics {\n \n impl From<clean::GenericParamDef> for GenericParamDef {\n     fn from(generic_param: clean::GenericParamDef) -> Self {\n-        GenericParamDef { name: generic_param.name, kind: generic_param.kind.into() }\n+        GenericParamDef { name: generic_param.name.to_string(), kind: generic_param.kind.into() }\n     }\n }\n \n@@ -351,7 +351,7 @@ impl From<clean::Type> for Type {\n                     .map(|v| v.into_iter().map(Into::into).collect())\n                     .unwrap_or_default(),\n             },\n-            Generic(s) => Type::Generic(s),\n+            Generic(s) => Type::Generic(s.to_string()),\n             Primitive(p) => Type::Primitive(p.as_str().to_string()),\n             BareFunction(f) => Type::FunctionPointer(Box::new((*f).into())),\n             Tuple(t) => Type::Tuple(t.into_iter().map(Into::into).collect()),\n@@ -370,7 +370,7 @@ impl From<clean::Type> for Type {\n                 type_: Box::new((*type_).into()),\n             },\n             QPath { name, self_type, trait_ } => Type::QualifiedPath {\n-                name,\n+                name: name.to_string(),\n                 self_type: Box::new((*self_type).into()),\n                 trait_: Box::new((*trait_).into()),\n             },\n@@ -394,7 +394,11 @@ impl From<clean::FnDecl> for FnDecl {\n     fn from(decl: clean::FnDecl) -> Self {\n         let clean::FnDecl { inputs, output, c_variadic, attrs: _ } = decl;\n         FnDecl {\n-            inputs: inputs.values.into_iter().map(|arg| (arg.name, arg.type_.into())).collect(),\n+            inputs: inputs\n+                .values\n+                .into_iter()\n+                .map(|arg| (arg.name.to_string(), arg.type_.into()))\n+                .collect(),\n             output: match output {\n                 clean::FnRetTy::Return(t) => Some(t.into()),\n                 clean::FnRetTy::DefaultReturn => None,"}, {"sha": "ea5bf94689bc7c150b626ce45fcb6fdd8a9977a2", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=bdd0a78582efd17f588b35e3e227a65617d5afec", "patch": "@@ -753,11 +753,14 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n ///\n /// These are common and we should just resolve to the trait in that case.\n fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_>>>) -> bool {\n-    matches!(*ns, PerNS {\n-        type_ns: Ok((Res::Def(DefKind::Trait, _), _)),\n-        macro_ns: Ok((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n-        ..\n-    })\n+    matches!(\n+        *ns,\n+        PerNS {\n+            type_ns: Ok((Res::Def(DefKind::Trait, _), _)),\n+            macro_ns: Ok((Res::Def(DefKind::Macro(MacroKind::Derive), _), _)),\n+            ..\n+        }\n+    )\n }\n \n impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {"}, {"sha": "1c1141e7c81226b0a042b302decb005162e6ac99", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd0a78582efd17f588b35e3e227a65617d5afec/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=bdd0a78582efd17f588b35e3e227a65617d5afec", "patch": "@@ -58,18 +58,19 @@ impl crate::doctest::Tester for Tests {\n }\n \n crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n-    if matches!(item.kind,\n+    if matches!(\n+        item.kind,\n         clean::StructFieldItem(_)\n-        | clean::VariantItem(_)\n-        | clean::AssocConstItem(_, _)\n-        | clean::AssocTypeItem(_, _)\n-        | clean::TypedefItem(_, _)\n-        | clean::StaticItem(_)\n-        | clean::ConstantItem(_)\n-        | clean::ExternCrateItem(_, _)\n-        | clean::ImportItem(_)\n-        | clean::PrimitiveItem(_)\n-        | clean::KeywordItem(_)\n+            | clean::VariantItem(_)\n+            | clean::AssocConstItem(_, _)\n+            | clean::AssocTypeItem(_, _)\n+            | clean::TypedefItem(_, _)\n+            | clean::StaticItem(_)\n+            | clean::ConstantItem(_)\n+            | clean::ExternCrateItem(_, _)\n+            | clean::ImportItem(_)\n+            | clean::PrimitiveItem(_)\n+            | clean::KeywordItem(_)\n     ) {\n         return false;\n     }"}]}