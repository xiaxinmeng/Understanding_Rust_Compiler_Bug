{"sha": "6143bdef6dc6c93c75104e514d9e851060eac6b1", "node_id": "C_kwDOAAsO6NoAKDYxNDNiZGVmNmRjNmM5M2M3NTEwNGU1MTRkOWU4NTEwNjBlYWM2YjE", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2022-02-09T20:46:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-09T20:46:41Z"}, "message": "Merge rust-lang/portable-simd#243 from ./no-overflow-panic\n\nRemove overflow panic from divrem and add basic docs to Simd<T, N>\r\n\r\nThis finishes normalizing Simd<T, N> to being approximately equivalent to Simd<Wrapping<T>, N> for all implemented operations I can think of. It also documents this fact, allowing this to close rust-lang/portable-simd#56.", "tree": {"sha": "e467414a84d310741b5c95ce8a217044f14cc18f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e467414a84d310741b5c95ce8a217044f14cc18f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6143bdef6dc6c93c75104e514d9e851060eac6b1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiBCgxCRBK7hj4Ov3rIwAA6dMIAAiizT+pM/+jTL3DqBx0LXw4\n6Y4tpUBL/pqTRZZwS+AjWTZYvB/CALYWZz7DD6zUw/KZkDtOyGLEPduqdSvkyqEz\nyvonq9Hw6YGmUxu0pDU95csQydgBZxOD9zKAgtZeDENXPFnfCNUeF4FvXmJEGWt7\nYxQZcXbqjmnjWZCOP0eyiyuX48OdiEtWIkzcAoLNOC8mkbPjReKFEGVDn9kou2Ow\nzqe8f/yTeJ+vnW9QPHFVou5AGRzRfA/bGRR5iCL19PyTadUOXjTog3Eu2UKGS2T1\nY/sv0ejL63xYod12SSuYuTrc+eYRXtGxo8vKcLLRR9A7V7CFr199aQtnUChue0k=\n=/R6x\n-----END PGP SIGNATURE-----\n", "payload": "tree e467414a84d310741b5c95ce8a217044f14cc18f\nparent 4910274686bcd144228a04d8d4d5dece4c7f5e3d\nparent 5d52455c65bf5a5eb258ed11591b8ebfa61ea5c7\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1644439601 -0800\ncommitter GitHub <noreply@github.com> 1644439601 -0800\n\nMerge rust-lang/portable-simd#243 from ./no-overflow-panic\n\nRemove overflow panic from divrem and add basic docs to Simd<T, N>\r\n\r\nThis finishes normalizing Simd<T, N> to being approximately equivalent to Simd<Wrapping<T>, N> for all implemented operations I can think of. It also documents this fact, allowing this to close rust-lang/portable-simd#56."}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6143bdef6dc6c93c75104e514d9e851060eac6b1", "html_url": "https://github.com/rust-lang/rust/commit/6143bdef6dc6c93c75104e514d9e851060eac6b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6143bdef6dc6c93c75104e514d9e851060eac6b1/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4910274686bcd144228a04d8d4d5dece4c7f5e3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4910274686bcd144228a04d8d4d5dece4c7f5e3d", "html_url": "https://github.com/rust-lang/rust/commit/4910274686bcd144228a04d8d4d5dece4c7f5e3d"}, {"sha": "5d52455c65bf5a5eb258ed11591b8ebfa61ea5c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d52455c65bf5a5eb258ed11591b8ebfa61ea5c7", "html_url": "https://github.com/rust-lang/rust/commit/5d52455c65bf5a5eb258ed11591b8ebfa61ea5c7"}], "stats": {"total": 101, "additions": 75, "deletions": 26}, "files": [{"sha": "b5d0df7548fe95cc8d9d1aff3f49cbb7d47ffabf", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6143bdef6dc6c93c75104e514d9e851060eac6b1/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6143bdef6dc6c93c75104e514d9e851060eac6b1/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=6143bdef6dc6c93c75104e514d9e851060eac6b1", "patch": "@@ -17,9 +17,15 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_mul<T>(x: T, y: T) -> T;\n \n     /// udiv/sdiv/fdiv\n+    /// ints and uints: {s,u}div incur UB if division by zero occurs.\n+    /// ints: sdiv is UB for int::MIN / -1.\n+    /// floats: fdiv is never UB, but may create NaNs or infinities.\n     pub(crate) fn simd_div<T>(x: T, y: T) -> T;\n \n     /// urem/srem/frem\n+    /// ints and uints: {s,u}rem incur UB if division by zero occurs.\n+    /// ints: srem is UB for int::MIN / -1.\n+    /// floats: frem is equivalent to libm::fmod in the \"default\" floating point environment, sans errno.\n     pub(crate) fn simd_rem<T>(x: T, y: T) -> T;\n \n     /// shl\n@@ -45,6 +51,9 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_as<T, U>(x: T) -> U;\n \n     /// neg/fneg\n+    /// ints: ultimately becomes a call to cg_ssa's BuilderMethods::neg. cg_llvm equates this to `simd_sub(Simd::splat(0), x)`.\n+    /// floats: LLVM's fneg, which changes the floating point sign bit. Some arches have instructions for it.\n+    /// Rust panics for Neg::neg(int::MIN) due to overflow, but it is not UB in LLVM without `nsw`.\n     pub(crate) fn simd_neg<T>(x: T) -> T;\n \n     /// fabs"}, {"sha": "1b35b3e717a3259591b84c1d15bd1fdff24a40d8", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6143bdef6dc6c93c75104e514d9e851060eac6b1/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6143bdef6dc6c93c75104e514d9e851060eac6b1/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=6143bdef6dc6c93c75104e514d9e851060eac6b1", "patch": "@@ -57,29 +57,40 @@ macro_rules! wrap_bitshift {\n     };\n }\n \n-// Division by zero is poison, according to LLVM.\n-// So is dividing the MIN value of a signed integer by -1,\n-// since that would return MAX + 1.\n-// FIXME: Rust allows <SInt>::MIN / -1,\n-// so we should probably figure out how to make that safe.\n+/// SAFETY: This macro must only be used to impl Div or Rem and given the matching intrinsic.\n+/// It guards against LLVM's UB conditions for integer div or rem using masks and selects,\n+/// thus guaranteeing a Rust value returns instead.\n+///\n+/// |                  | LLVM | Rust\n+/// | :--------------: | :--- | :----------\n+/// | N {/,%} 0        | UB   | panic!()\n+/// | <$int>::MIN / -1 | UB   | <$int>::MIN\n+/// | <$int>::MIN % -1 | UB   | 0\n+///\n macro_rules! int_divrem_guard {\n     (   $lhs:ident,\n         $rhs:ident,\n         {   const PANIC_ZERO: &'static str = $zero:literal;\n-            const PANIC_OVERFLOW: &'static str = $overflow:literal;\n             $simd_call:ident\n         },\n         $int:ident ) => {\n         if $rhs.lanes_eq(Simd::splat(0)).any() {\n             panic!($zero);\n-        } else if <$int>::MIN != 0\n-            && ($lhs.lanes_eq(Simd::splat(<$int>::MIN))\n-                // type inference can break here, so cut an SInt to size\n-                & $rhs.lanes_eq(Simd::splat(-1i64 as _))).any()\n-        {\n-            panic!($overflow);\n         } else {\n-            unsafe { $crate::simd::intrinsics::$simd_call($lhs, $rhs) }\n+            // Prevent otherwise-UB overflow on the MIN / -1 case.\n+            let rhs = if <$int>::MIN != 0 {\n+                // This should, at worst, optimize to a few branchless logical ops\n+                // Ideally, this entire conditional should evaporate\n+                // Fire LLVM and implement those manually if it doesn't get the hint\n+                ($lhs.lanes_eq(Simd::splat(<$int>::MIN))\n+                // type inference can break here, so cut an SInt to size\n+                & $rhs.lanes_eq(Simd::splat(-1i64 as _)))\n+                .select(Simd::splat(1), $rhs)\n+            } else {\n+                // Nice base case to make it easy to const-fold away the other branch.\n+                $rhs\n+            };\n+            unsafe { $crate::simd::intrinsics::$simd_call($lhs, rhs) }\n         }\n     };\n }\n@@ -183,15 +194,13 @@ for_base_ops! {\n     impl Div::div {\n         int_divrem_guard {\n             const PANIC_ZERO: &'static str = \"attempt to divide by zero\";\n-            const PANIC_OVERFLOW: &'static str = \"attempt to divide with overflow\";\n             simd_div\n         }\n     }\n \n     impl Rem::rem {\n         int_divrem_guard {\n             const PANIC_ZERO: &'static str = \"attempt to calculate the remainder with a divisor of zero\";\n-            const PANIC_OVERFLOW: &'static str = \"attempt to calculate the remainder with overflow\";\n             simd_rem\n         }\n     }"}, {"sha": "5bd8ed69535e160edb8353f4ad60e98e5aba3668", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6143bdef6dc6c93c75104e514d9e851060eac6b1/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6143bdef6dc6c93c75104e514d9e851060eac6b1/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=6143bdef6dc6c93c75104e514d9e851060eac6b1", "patch": "@@ -12,7 +12,38 @@ pub(crate) mod ptr;\n use crate::simd::intrinsics;\n use crate::simd::{LaneCount, Mask, MaskElement, SupportedLaneCount};\n \n-/// A SIMD vector of `LANES` elements of type `T`.\n+/// A SIMD vector of `LANES` elements of type `T`. `Simd<T, N>` has the same shape as [`[T; N]`](array), but operates like `T`.\n+///\n+/// Two vectors of the same type and length will, by convention, support the operators (+, *, etc.) that `T` does.\n+/// These take the lanes at each index on the left-hand side and right-hand side, perform the operation,\n+/// and return the result in the same lane in a vector of equal size. For a given operator, this is equivalent to zipping\n+/// the two arrays together and mapping the operator over each lane.\n+///\n+/// ```rust\n+/// # #![feature(array_zip, portable_simd)]\n+/// # use core::simd::{Simd};\n+/// let a0: [i32; 4] = [-2, 0, 2, 4];\n+/// let a1 = [10, 9, 8, 7];\n+/// let zm_add = a0.zip(a1).map(|(lhs, rhs)| lhs + rhs);\n+/// let zm_mul = a0.zip(a1).map(|(lhs, rhs)| lhs * rhs);\n+///\n+/// // `Simd<T, N>` implements `From<[T; N]>\n+/// let (v0, v1) = (Simd::from(a0), Simd::from(a1));\n+/// // Which means arrays implement `Into<Simd<T, N>>`.\n+/// assert_eq!(v0 + v1, zm_add.into());\n+/// assert_eq!(v0 * v1, zm_mul.into());\n+/// ```\n+///\n+/// `Simd` with integers has the quirk that these operations are also inherently wrapping, as if `T` was [`Wrapping<T>`].\n+/// Thus, `Simd` does not implement `wrapping_add`, because that is the default behavior.\n+/// This means there is no warning on overflows, even in \"debug\" builds.\n+/// For most applications where `Simd` is appropriate, it is \"not a bug\" to wrap,\n+/// and even \"debug builds\" are unlikely to tolerate the loss of performance.\n+/// You may want to consider using explicitly checked arithmetic if such is required.\n+/// Division by zero still causes a panic, so you may want to consider using floating point numbers if that is unacceptable.\n+///\n+/// [`Wrapping<T>`]: core::num::Wrapping\n+///\n #[repr(simd)]\n pub struct Simd<T, const LANES: usize>([T; LANES])\n where"}, {"sha": "50f7a4ca170db983187a26dfc251a9aafacb91b0", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6143bdef6dc6c93c75104e514d9e851060eac6b1/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6143bdef6dc6c93c75104e514d9e851060eac6b1/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=6143bdef6dc6c93c75104e514d9e851060eac6b1", "patch": "@@ -210,15 +210,21 @@ macro_rules! impl_signed_tests {\n                     )\n                 }\n \n-            }\n+                fn div_min_may_overflow<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(Scalar::MIN);\n+                    let b = Vector::<LANES>::splat(-1);\n+                    assert_eq!(a / b, a);\n+                }\n \n-            test_helpers::test_lanes_panic! {\n-                fn div_min_overflow_panics<const LANES: usize>() {\n+                fn rem_min_may_overflow<const LANES: usize>() {\n                     let a = Vector::<LANES>::splat(Scalar::MIN);\n                     let b = Vector::<LANES>::splat(-1);\n-                    let _ = a / b;\n+                    assert_eq!(a % b, Vector::<LANES>::splat(0));\n                 }\n \n+            }\n+\n+            test_helpers::test_lanes_panic! {\n                 fn div_by_all_zeros_panics<const LANES: usize>() {\n                     let a = Vector::<LANES>::splat(42);\n                     let b = Vector::<LANES>::splat(0);\n@@ -232,12 +238,6 @@ macro_rules! impl_signed_tests {\n                     let _ = a / b;\n                 }\n \n-                fn rem_min_overflow_panic<const LANES: usize>() {\n-                    let a = Vector::<LANES>::splat(Scalar::MIN);\n-                    let b = Vector::<LANES>::splat(-1);\n-                    let _ = a % b;\n-                }\n-\n                 fn rem_zero_panic<const LANES: usize>() {\n                     let a = Vector::<LANES>::splat(42);\n                     let b = Vector::<LANES>::splat(0);"}]}