{"sha": "f55cadb65aacded4593312e56709fff3388e5f13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1NWNhZGI2NWFhY2RlZDQ1OTMzMTJlNTY3MDlmZmYzMzg4ZTVmMTM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-11T01:39:35Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T03:43:29Z"}, "message": "chains: refactor formatting of chain items", "tree": {"sha": "c44fa0b30cce55e3bafd8f6de85ab4e16ce95727", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c44fa0b30cce55e3bafd8f6de85ab4e16ce95727"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f55cadb65aacded4593312e56709fff3388e5f13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f55cadb65aacded4593312e56709fff3388e5f13", "html_url": "https://github.com/rust-lang/rust/commit/f55cadb65aacded4593312e56709fff3388e5f13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f55cadb65aacded4593312e56709fff3388e5f13/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a56ff9d02f67a2736a6735014564fe5e496ad148", "url": "https://api.github.com/repos/rust-lang/rust/commits/a56ff9d02f67a2736a6735014564fe5e496ad148", "html_url": "https://github.com/rust-lang/rust/commit/a56ff9d02f67a2736a6735014564fe5e496ad148"}], "stats": {"total": 205, "additions": 102, "deletions": 103}, "files": [{"sha": "5e2c3e051f65e0d2b62532b01719f137f3a600ee", "filename": "src/chains.rs", "status": "modified", "additions": 102, "deletions": 103, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/f55cadb65aacded4593312e56709fff3388e5f13/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55cadb65aacded4593312e56709fff3388e5f13/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=f55cadb65aacded4593312e56709fff3388e5f13", "patch": "@@ -85,8 +85,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     // If this is just an expression with some `?`s, then format it trivially and\n     // return early.\n     if chain.children.is_empty() {\n-        let rewrite = chain.parent.expr.rewrite(context, shape.sub_width(chain.parent.tries)?)?;\n-        return Some(format!(\"{}{}\", rewrite, \"?\".repeat(chain.parent.tries)));\n+        return chain.parent.rewrite(context, shape);\n     }\n \n     match context.config.indent_style() {\n@@ -102,6 +101,89 @@ struct ChainItem {\n     tries: usize,\n }\n \n+impl Rewrite for ChainItem {\n+    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+        let rewrite = self.expr.rewrite(context, shape.sub_width(self.tries)?)?;\n+        Some(format!(\"{}{}\", rewrite, \"?\".repeat(self.tries)))\n+    }\n+}\n+\n+impl ChainItem {\n+    // Rewrite the last element in the chain `expr`. E.g., given `a.b.c` we rewrite\n+    // `.c` and any trailing `?`s.\n+    fn rewrite_postfix(\n+        &self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+    ) -> Option<String> {\n+        let shape = shape.sub_width(self.tries)?;\n+        let mut rewrite = match self.expr.node {\n+            ast::ExprKind::MethodCall(ref segment, ref expressions) => {\n+                let types = match segment.args {\n+                    Some(ref params) => match **params {\n+                        ast::GenericArgs::AngleBracketed(ref data) => &data.args[..],\n+                        _ => &[],\n+                    },\n+                    _ => &[],\n+                };\n+                Self::rewrite_method_call(segment.ident, types, expressions, self.expr.span, context, shape)?\n+            }\n+            ast::ExprKind::Field(ref nested, ref field) => {\n+                let space = if Self::is_tup_field_access(&self.expr) && Self::is_tup_field_access(nested) {\n+                    \" \"\n+                } else {\n+                    \"\"\n+                };\n+                let result = format!(\"{}.{}\", space, field.name);\n+                if result.len() <= shape.width {\n+                    result\n+                } else {\n+                    return None;\n+                }\n+            }\n+            _ => unreachable!(),\n+        };\n+        rewrite.push_str(&\"?\".repeat(self.tries));\n+        Some(rewrite)\n+    }\n+\n+    fn is_tup_field_access(expr: &ast::Expr) -> bool {\n+        match expr.node {\n+            ast::ExprKind::Field(_, ref field) => {\n+                field.name.to_string().chars().all(|c| c.is_digit(10))\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn rewrite_method_call(\n+        method_name: ast::Ident,\n+        types: &[ast::GenericArg],\n+        args: &[ptr::P<ast::Expr>],\n+        span: Span,\n+        context: &RewriteContext,\n+        shape: Shape,\n+    ) -> Option<String> {\n+        let (lo, type_str) = if types.is_empty() {\n+            (args[0].span.hi(), String::new())\n+        } else {\n+            let type_list = types\n+                .iter()\n+                .map(|ty| ty.rewrite(context, shape))\n+                .collect::<Option<Vec<_>>>()?;\n+\n+            let type_str = format!(\"::<{}>\", type_list.join(\", \"));\n+\n+            (types.last().unwrap().span().hi(), type_str)\n+        };\n+\n+        let callee_str = format!(\".{}{}\", method_name, type_str);\n+        let span = mk_sp(lo, span.hi());\n+\n+        rewrite_call(context, &callee_str, &args[1..], span, shape)\n+    }\n+}\n+\n #[derive(Debug)]\n struct Chain {\n     parent: ChainItem,\n@@ -209,21 +291,16 @@ impl <'a> ChainFormatterBlock<'a> {\n     // ```\n     // If `bar` were not part of the root, then baz would be orphaned and 'float'.\n     fn format_root(&mut self, parent: &ChainItem, context: &RewriteContext, shape: Shape) -> Option<()> {\n-        let mut root_rewrite: String = parent.expr\n-            .rewrite(context, shape)\n-            .map(|parent_rw| parent_rw + &\"?\".repeat(parent.tries))?;\n+        let mut root_rewrite: String = parent.rewrite(context, shape)?;\n \n         self.root_ends_with_block = is_block_expr(context, &parent.expr, &root_rewrite);\n         let tab_width = context.config.tab_spaces().saturating_sub(shape.offset);\n \n         while root_rewrite.len() <= tab_width && !root_rewrite.contains('\\n') {\n             let item = &self.children[0];\n             let shape = shape.offset_left(root_rewrite.len())?;\n-            match rewrite_chain_subexpr(&item.expr, context, shape) {\n-                Some(rewrite) => {\n-                    root_rewrite.push_str(&rewrite);\n-                    root_rewrite.push_str(&\"?\".repeat(item.tries));\n-                }\n+            match &item.rewrite_postfix(context, shape) {\n+                Some(rewrite) => root_rewrite.push_str(rewrite),\n                 None => break,\n             }\n \n@@ -248,10 +325,10 @@ impl <'a> ChainFormatterBlock<'a> {\n \n     fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n         self.is_block_like.push(self.root_ends_with_block);\n-        for item in &self.children[..self.children.len()] {\n-            let rewrite = rewrite_chain_subexpr(&item.expr, context, child_shape)?;\n+        for item in &self.children[..self.children.len() - 1] {\n+            let rewrite = item.rewrite_postfix(context, child_shape)?;\n             self.is_block_like.push(is_block_expr(context, &item.expr, &rewrite));\n-            self.rewrites.push(format!(\"{}{}\", rewrite, \"?\".repeat(item.tries)));\n+            self.rewrites.push(rewrite);\n         }\n         Some(())\n     }\n@@ -315,7 +392,7 @@ impl <'a> ChainFormatterBlock<'a> {\n             // First we try to 'overflow' the last child and see if it looks better than using\n             // vertical layout.\n             if let Some(shape) = last_shape.offset_left(almost_total) {\n-                if let Some(rw) = rewrite_chain_subexpr(&last.expr, context, shape) {\n+                if let Some(rw) = last.rewrite_postfix(context, shape) {\n                     // We allow overflowing here only if both of the following conditions match:\n                     // 1. The entire chain fits in a single line except the last child.\n                     // 2. `last_child_str.lines().count() >= 5`.\n@@ -328,7 +405,7 @@ impl <'a> ChainFormatterBlock<'a> {\n                         // We could not know whether overflowing is better than using vertical layout,\n                         // just by looking at the overflowed rewrite. Now we rewrite the last child\n                         // on its own line, and compare two rewrites to choose which is better.\n-                        match rewrite_chain_subexpr(&last.expr, context, last_shape) {\n+                        match last.rewrite_postfix(context, last_shape) {\n                             Some(ref new_rw) if !could_fit_single_line => {\n                                 last_subexpr_str = Some(new_rw.clone());\n                             }\n@@ -349,8 +426,8 @@ impl <'a> ChainFormatterBlock<'a> {\n             }\n         }\n \n-        last_subexpr_str = last_subexpr_str.or_else(|| rewrite_chain_subexpr(&last.expr, context, last_shape));\n-        self.rewrites.push(format!(\"{}{}\", last_subexpr_str?, \"?\".repeat(last.tries)));\n+        last_subexpr_str = last_subexpr_str.or_else(|| last.rewrite_postfix(context, last_shape));\n+        self.rewrites.push(last_subexpr_str?);\n         Some(())\n     }\n \n@@ -424,17 +501,14 @@ impl<'a> ChainFormatterVisual<'a> {\n         } else {\n             shape\n         };\n-        let mut root_rewrite = parent.expr\n-            .rewrite(context, parent_shape)\n-            .map(|parent_rw| parent_rw + &\"?\".repeat(parent.tries))?;\n+        let mut root_rewrite = parent.rewrite(context, parent_shape)?;\n \n         if !root_rewrite.contains('\\n') && Self::is_continuable(&parent.expr) {\n             let item = &self.children[0];\n             let overhead = last_line_width(&root_rewrite);\n             let shape = parent_shape.offset_left(overhead)?;\n-            let rewrite = rewrite_chain_subexpr(&item.expr, context, shape)?;\n+            let rewrite = item.rewrite_postfix(context, shape)?;\n             root_rewrite.push_str(&rewrite);\n-            root_rewrite.push_str(&\"?\".repeat(item.tries));\n \n             self.children = &self.children[1..];\n         }\n@@ -453,8 +527,8 @@ impl<'a> ChainFormatterVisual<'a> {\n \n     fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n         for item in &self.children[..self.children.len() - 1] {\n-            let rewrite = rewrite_chain_subexpr(&item.expr, context, child_shape)?;\n-            self.rewrites.push(format!(\"{}{}\", rewrite, \"?\".repeat(item.tries)));\n+            let rewrite = item.rewrite_postfix(context, child_shape)?;\n+            self.rewrites.push(rewrite);\n         }\n         Some(())\n     }\n@@ -479,7 +553,7 @@ impl<'a> ChainFormatterVisual<'a> {\n             // First we try to 'overflow' the last child and see if it looks better than using\n             // vertical layout.\n             if let Some(shape) = shape.offset_left(almost_total) {\n-                if let Some(rw) = rewrite_chain_subexpr(&last.expr, context, shape) {\n+                if let Some(rw) = last.rewrite_postfix(context, shape) {\n                     // We allow overflowing here only if both of the following conditions match:\n                     // 1. The entire chain fits in a single line except the last child.\n                     // 2. `last_child_str.lines().count() >= 5`.\n@@ -492,7 +566,7 @@ impl<'a> ChainFormatterVisual<'a> {\n                         // We could not know whether overflowing is better than using vertical layout,\n                         // just by looking at the overflowed rewrite. Now we rewrite the last child\n                         // on its own line, and compare two rewrites to choose which is better.\n-                        match rewrite_chain_subexpr(&last.expr, context, last_shape) {\n+                        match last.rewrite_postfix(context, last_shape) {\n                             Some(ref new_rw) if !could_fit_single_line => {\n                                 last_subexpr_str = Some(new_rw.clone());\n                             }\n@@ -513,8 +587,8 @@ impl<'a> ChainFormatterVisual<'a> {\n             }\n         } \n \n-        let last_subexpr_str = last_subexpr_str.or_else(|| rewrite_chain_subexpr(&last.expr, context, last_shape));\n-        self.rewrites.push(format!(\"{}{}\", last_subexpr_str?, \"?\".repeat(last.tries)));\n+        let last_subexpr_str = last_subexpr_str.or_else(|| last.rewrite_postfix(context, last_shape));\n+        self.rewrites.push(last_subexpr_str?);\n         Some(())\n     }\n \n@@ -589,78 +663,3 @@ fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool\n         _ => false,\n     }\n }\n-\n-// Rewrite the last element in the chain `expr`. E.g., given `a.b.c` we rewrite\n-// `.c`.\n-fn rewrite_chain_subexpr(\n-    expr: &ast::Expr,\n-    context: &RewriteContext,\n-    shape: Shape,\n-) -> Option<String> {\n-    let rewrite_element = |expr_str: String| {\n-        if expr_str.len() <= shape.width {\n-            Some(expr_str)\n-        } else {\n-            None\n-        }\n-    };\n-\n-    match expr.node {\n-        ast::ExprKind::MethodCall(ref segment, ref expressions) => {\n-            let types = match segment.args {\n-                Some(ref params) => match **params {\n-                    ast::GenericArgs::AngleBracketed(ref data) => &data.args[..],\n-                    _ => &[],\n-                },\n-                _ => &[],\n-            };\n-            rewrite_method_call(segment.ident, types, expressions, expr.span, context, shape)\n-        }\n-        ast::ExprKind::Field(ref nested, ref field) => {\n-            let space = if is_tup_field_access(expr) && is_tup_field_access(nested) {\n-                \" \"\n-            } else {\n-                \"\"\n-            };\n-            rewrite_element(format!(\"{}.{}\", space, field.name))\n-        }\n-        ast::ExprKind::Try(_) => rewrite_element(String::from(\"?\")),\n-        _ => unreachable!(),\n-    }\n-}\n-\n-fn is_tup_field_access(expr: &ast::Expr) -> bool {\n-    match expr.node {\n-        ast::ExprKind::Field(_, ref field) => {\n-            field.name.to_string().chars().all(|c| c.is_digit(10))\n-        }\n-        _ => false,\n-    }\n-}\n-\n-fn rewrite_method_call(\n-    method_name: ast::Ident,\n-    types: &[ast::GenericArg],\n-    args: &[ptr::P<ast::Expr>],\n-    span: Span,\n-    context: &RewriteContext,\n-    shape: Shape,\n-) -> Option<String> {\n-    let (lo, type_str) = if types.is_empty() {\n-        (args[0].span.hi(), String::new())\n-    } else {\n-        let type_list = types\n-            .iter()\n-            .map(|ty| ty.rewrite(context, shape))\n-            .collect::<Option<Vec<_>>>()?;\n-\n-        let type_str = format!(\"::<{}>\", type_list.join(\", \"));\n-\n-        (types.last().unwrap().span().hi(), type_str)\n-    };\n-\n-    let callee_str = format!(\".{}{}\", method_name, type_str);\n-    let span = mk_sp(lo, span.hi());\n-\n-    rewrite_call(context, &callee_str, &args[1..], span, shape)\n-}"}]}