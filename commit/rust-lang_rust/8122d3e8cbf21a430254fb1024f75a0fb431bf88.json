{"sha": "8122d3e8cbf21a430254fb1024f75a0fb431bf88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxMjJkM2U4Y2JmMjFhNDMwMjU0ZmIxMDI0Zjc1YTBmYjQzMWJmODg=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-06-06T17:26:50Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-06-06T17:26:50Z"}, "message": "Check for AsRef/AsMut arguments in wrong_self_convention\n\nThis fixes #451", "tree": {"sha": "89385e6df90836464fd0019fe839b6acceffbe94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89385e6df90836464fd0019fe839b6acceffbe94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8122d3e8cbf21a430254fb1024f75a0fb431bf88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8122d3e8cbf21a430254fb1024f75a0fb431bf88", "html_url": "https://github.com/rust-lang/rust/commit/8122d3e8cbf21a430254fb1024f75a0fb431bf88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8122d3e8cbf21a430254fb1024f75a0fb431bf88/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "329ddb98e137ef58000b842a1db1acdb8c2264b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/329ddb98e137ef58000b842a1db1acdb8c2264b2", "html_url": "https://github.com/rust-lang/rust/commit/329ddb98e137ef58000b842a1db1acdb8c2264b2"}], "stats": {"total": 97, "additions": 72, "deletions": 25}, "files": [{"sha": "92e3d5d3b6815f0682737c1e32b33b4a3248e4ff", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8122d3e8cbf21a430254fb1024f75a0fb431bf88/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8122d3e8cbf21a430254fb1024f75a0fb431bf88/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=8122d3e8cbf21a430254fb1024f75a0fb431bf88", "patch": "@@ -10,7 +10,7 @@ use syntax::codemap::Span;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path, match_trait_method,\n             match_type, method_chain_args, return_ty, same_tys, snippet, span_lint, span_lint_and_then,\n             span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, last_path_segment, single_segment_path,\n-            match_def_path, is_self, is_self_ty, iter_input_pats};\n+            match_def_path, is_self, is_self_ty, iter_input_pats, match_path_old};\n use utils::paths;\n use utils::sugg;\n \n@@ -649,7 +649,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 if name == method_name &&\n                    sig.decl.inputs.len() == n_args &&\n                    out_type.matches(&sig.decl.output) &&\n-                   self_kind.matches(first_arg_ty, first_arg, self_ty, false) {\n+                   self_kind.matches(first_arg_ty, first_arg, self_ty, false, &sig.generics) {\n                     span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n                         \"defining a method called `{}` on this type; consider implementing \\\n                          the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n@@ -663,7 +663,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             for &(ref conv, self_kinds) in &CONVENTIONS {\n                 if_let_chain! {[\n                     conv.check(&name.as_str()),\n-                    !self_kinds.iter().any(|k| k.matches(first_arg_ty, first_arg, self_ty, is_copy)),\n+                    !self_kinds.iter().any(|k| k.matches(first_arg_ty, first_arg, self_ty, is_copy, &sig.generics)),\n                 ], {\n                     let lint = if item.vis == hir::Visibility::Public {\n                         WRONG_PUB_SELF_CONVENTION\n@@ -1353,7 +1353,7 @@ enum SelfKind {\n }\n \n impl SelfKind {\n-    fn matches(self, ty: &hir::Ty, arg: &hir::Arg, self_ty: &hir::Ty, allow_value_for_ref: bool) -> bool {\n+    fn matches(self, ty: &hir::Ty, arg: &hir::Arg, self_ty: &hir::Ty, allow_value_for_ref: bool, generics: &hir::Generics) -> bool {\n         // Self types in the HIR are desugared to explicit self types. So it will always be `self:\n         // SomeType`,\n         // where SomeType can be `Self` or an explicit impl self type (e.g. `Foo` if the impl is on `Foo`)\n@@ -1384,7 +1384,12 @@ impl SelfKind {\n                 _ => false,\n             }\n         } else {\n-            self == SelfKind::No\n+            match self {\n+                SelfKind::Value => false,\n+                SelfKind::Ref => is_astrait(ty, self_ty, generics, &paths::ASREF_TRAIT),\n+                SelfKind::RefMut => is_astrait(ty, self_ty, generics, &paths::ASMUT_TRAIT),\n+                SelfKind::No => true\n+            }\n         }\n     }\n \n@@ -1398,6 +1403,45 @@ impl SelfKind {\n     }\n }\n \n+fn is_astrait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Generics, name: &[&str]) -> bool {\n+    single_segment_ty(ty).map_or(false, |seg| {\n+        generics.ty_params.iter().any(|param| {\n+            param.name == seg.name && param.bounds.iter().any(|bound| {\n+                if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n+                    let path = &ptr.trait_ref.path;\n+                    match_path_old(path, name) && path.segments.last().map_or(false, |s| {\n+                        if let hir::PathParameters::AngleBracketedParameters(ref data) = s.parameters {\n+                            data.types.len() == 1 && (is_self_ty(&data.types[0]) || is_ty(&*data.types[0], self_ty))\n+                        } else {\n+                            false\n+                        }\n+                    })\n+                } else {\n+                    false\n+                }\n+            })\n+        })\n+    })\n+}\n+\n+fn is_ty(ty: &hir::Ty, self_ty: &hir::Ty) -> bool {\n+    match (&ty.node, &self_ty.node) {\n+        (&hir::TyPath(hir::QPath::Resolved(_, ref ty_path)), &hir::TyPath(hir::QPath::Resolved(_, ref self_ty_path))) => {\n+            ty_path.segments.iter().rev().map(|seg| seg.name).zip(\n+                self_ty_path.segments.iter().rev().map(|seg| seg.name)).all(|(l, r)| l == r)\n+        }\n+        _ => false\n+    }\n+}\n+\n+fn single_segment_ty(ty: &hir::Ty) -> Option<&hir::PathSegment> {\n+    if let hir::TyPath(ref path) = ty.node {\n+        single_segment_path(path)\n+    } else {\n+        None\n+    }\n+}\n+\n impl Convention {\n     fn check(&self, other: &str) -> bool {\n         match *self {"}, {"sha": "eb9979343948b5110891187f3546320cf6e45f9e", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8122d3e8cbf21a430254fb1024f75a0fb431bf88/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8122d3e8cbf21a430254fb1024f75a0fb431bf88/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=8122d3e8cbf21a430254fb1024f75a0fb431bf88", "patch": "@@ -1,5 +1,6 @@\n //! This module contains paths to types and functions Clippy needs to know about.\n \n+pub const ASMUT_TRAIT: [&'static str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&'static str; 3] = [\"core\", \"convert\", \"AsRef\"];\n pub const BEGIN_PANIC: [&'static str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n pub const BINARY_HEAP: [&'static str; 3] = [\"collections\", \"binary_heap\", \"BinaryHeap\"];"}, {"sha": "91b60c8faaa23c9a7e591579dda6080f2110c8a6", "filename": "clippy_tests/examples/wrong_self_convention.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8122d3e8cbf21a430254fb1024f75a0fb431bf88/clippy_tests%2Fexamples%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8122d3e8cbf21a430254fb1024f75a0fb431bf88/clippy_tests%2Fexamples%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fwrong_self_convention.rs?ref=8122d3e8cbf21a430254fb1024f75a0fb431bf88", "patch": "@@ -29,6 +29,8 @@ impl Foo {\n     #[allow(wrong_self_convention)]\n     pub fn from_cake(self) {}\n \n+    fn as_x<F: AsRef<Self>>(_: F) { }\n+    fn as_y<F: AsRef<Foo>>(_: F) { }\n }\n \n struct Bar;"}, {"sha": "91ed88dd4afa85d806e97fd06eebd8c1c29d0863", "filename": "clippy_tests/examples/wrong_self_convention.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8122d3e8cbf21a430254fb1024f75a0fb431bf88/clippy_tests%2Fexamples%2Fwrong_self_convention.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8122d3e8cbf21a430254fb1024f75a0fb431bf88/clippy_tests%2Fexamples%2Fwrong_self_convention.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fwrong_self_convention.stderr?ref=8122d3e8cbf21a430254fb1024f75a0fb431bf88", "patch": "@@ -15,81 +15,81 @@ error: methods called `from_*` usually take no self; consider choosing a less am\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:38:15\n+  --> wrong_self_convention.rs:40:15\n    |\n-38 |     fn as_i32(self) {}\n+40 |     fn as_i32(self) {}\n    |               ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:40:17\n+  --> wrong_self_convention.rs:42:17\n    |\n-40 |     fn into_i32(&self) {}\n+42 |     fn into_i32(&self) {}\n    |                 ^^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:42:15\n+  --> wrong_self_convention.rs:44:15\n    |\n-42 |     fn is_i32(self) {}\n+44 |     fn is_i32(self) {}\n    |               ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:44:15\n+  --> wrong_self_convention.rs:46:15\n    |\n-44 |     fn to_i32(self) {}\n+46 |     fn to_i32(self) {}\n    |               ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:46:17\n+  --> wrong_self_convention.rs:48:17\n    |\n-46 |     fn from_i32(self) {}\n+48 |     fn from_i32(self) {}\n    |                 ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `as_*` usually take self by reference or self by mutable reference; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:48:19\n+  --> wrong_self_convention.rs:50:19\n    |\n-48 |     pub fn as_i64(self) {}\n+50 |     pub fn as_i64(self) {}\n    |                   ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:49:21\n+  --> wrong_self_convention.rs:51:21\n    |\n-49 |     pub fn into_i64(&self) {}\n+51 |     pub fn into_i64(&self) {}\n    |                     ^^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `is_*` usually take self by reference or no self; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:50:19\n+  --> wrong_self_convention.rs:52:19\n    |\n-50 |     pub fn is_i64(self) {}\n+52 |     pub fn is_i64(self) {}\n    |                   ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:51:19\n+  --> wrong_self_convention.rs:53:19\n    |\n-51 |     pub fn to_i64(self) {}\n+53 |     pub fn to_i64(self) {}\n    |                   ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `from_*` usually take no self; consider choosing a less ambiguous name\n-  --> wrong_self_convention.rs:52:21\n+  --> wrong_self_convention.rs:54:21\n    |\n-52 |     pub fn from_i64(self) {}\n+54 |     pub fn from_i64(self) {}\n    |                     ^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`"}]}