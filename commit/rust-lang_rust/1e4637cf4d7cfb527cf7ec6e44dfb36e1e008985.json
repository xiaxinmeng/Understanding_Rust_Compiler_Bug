{"sha": "1e4637cf4d7cfb527cf7ec6e44dfb36e1e008985", "node_id": "C_kwDOAAsO6NoAKDFlNDYzN2NmNGQ3Y2ZiNTI3Y2Y3ZWM2ZTQ0ZGZiMzZlMWUwMDg5ODU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2021-12-14T23:01:08Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-14T20:05:34Z"}, "message": "rustdoc: remove many unnecessary `.as_ref()` calls.", "tree": {"sha": "341cf419c9e5997fda886ab65056d995b5d3b3ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/341cf419c9e5997fda886ab65056d995b5d3b3ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e4637cf4d7cfb527cf7ec6e44dfb36e1e008985", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e4637cf4d7cfb527cf7ec6e44dfb36e1e008985", "html_url": "https://github.com/rust-lang/rust/commit/1e4637cf4d7cfb527cf7ec6e44dfb36e1e008985", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e4637cf4d7cfb527cf7ec6e44dfb36e1e008985/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "html_url": "https://github.com/rust-lang/rust/commit/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7"}], "stats": {"total": 67, "additions": 29, "deletions": 38}, "files": [{"sha": "dacaeac78f2b9476222a0284c38a9433bc478adc", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 29, "deletions": 38, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/1e4637cf4d7cfb527cf7ec6e44dfb36e1e008985/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e4637cf4d7cfb527cf7ec6e44dfb36e1e008985/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=1e4637cf4d7cfb527cf7ec6e44dfb36e1e008985", "patch": "@@ -263,7 +263,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n     indices.dedup_by_key(|i| {\n         (\n             items[*i].def_id,\n-            if items[*i].name.as_ref().is_some() { Some(full_path(cx, &items[*i])) } else { None },\n+            if items[*i].name.is_some() { Some(full_path(cx, &items[*i])) } else { None },\n             items[*i].type_(),\n             if items[*i].is_import() { *i } else { 0 },\n         )\n@@ -310,13 +310,13 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {} as {};\",\n                         myitem.visibility.print_with_space(myitem.def_id, cx),\n                         anchor(myitem.def_id.expect_def_id(), src, cx),\n-                        myitem.name.as_ref().unwrap(),\n+                        myitem.name.unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {};\",\n                         myitem.visibility.print_with_space(myitem.def_id, cx),\n-                        anchor(myitem.def_id.expect_def_id(), *myitem.name.as_ref().unwrap(), cx),\n+                        anchor(myitem.def_id.expect_def_id(), myitem.name.unwrap(), cx),\n                     ),\n                 }\n                 w.write_str(\"</code></div>\");\n@@ -388,7 +388,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                              {stab_tags}\\\n                      </div>\\\n                      <div class=\\\"item-right docblock-short\\\">{docs}</div>\",\n-                    name = *myitem.name.as_ref().unwrap(),\n+                    name = myitem.name.unwrap(),\n                     stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n                     docs = MarkdownSummaryLine(&doc_value, &myitem.links(cx)).into_string(),\n                     class = myitem.type_(),\n@@ -460,7 +460,7 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n     let asyncness = f.header.asyncness.print_with_space();\n     let unsafety = f.header.unsafety.print_with_space();\n     let abi = print_abi_with_space(f.header.abi).to_string();\n-    let name = it.name.as_ref().unwrap();\n+    let name = it.name.unwrap();\n \n     let generics_len = format!(\"{:#}\", f.generics.print(cx)).len();\n     let header_len = \"fn \".len()\n@@ -516,7 +516,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n                 it.visibility.print_with_space(it.def_id, cx),\n                 t.unsafety.print_with_space(),\n                 if t.is_auto { \"auto \" } else { \"\" },\n-                it.name.as_ref().unwrap(),\n+                it.name.unwrap(),\n                 t.generics.print(cx),\n                 bounds\n             );\n@@ -657,7 +657,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n     }\n \n     fn trait_item(w: &mut Buffer, cx: &Context<'_>, m: &clean::Item, t: &clean::Item) {\n-        let name = m.name.as_ref().unwrap();\n+        let name = m.name.unwrap();\n         info!(\"Documenting {} on {:?}\", name, t.name);\n         let item_type = m.type_();\n         let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n@@ -867,7 +867,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n             join_with_slash(None, &path[..path.len() - 1])\n         },\n         ty = it.type_(),\n-        name = *it.name.as_ref().unwrap()\n+        name = it.name.unwrap()\n     );\n }\n \n@@ -878,7 +878,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clea\n             write!(\n                 w,\n                 \"trait {}{}{} = {};\",\n-                it.name.as_ref().unwrap(),\n+                it.name.unwrap(),\n                 t.generics.print(cx),\n                 print_where_clause(&t.generics, cx, 0, true),\n                 bounds(&t.bounds, true, cx)\n@@ -902,7 +902,7 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean:\n             write!(\n                 w,\n                 \"type {}{}{where_clause} = impl {bounds};\",\n-                it.name.as_ref().unwrap(),\n+                it.name.unwrap(),\n                 t.generics.print(cx),\n                 where_clause = print_where_clause(&t.generics, cx, 0, true),\n                 bounds = bounds(&t.bounds, false, cx),\n@@ -941,7 +941,7 @@ fn item_typedef(\n             write!(\n                 w,\n                 \"type {}{}{where_clause} = {type_};\",\n-                it.name.as_ref().unwrap(),\n+                it.name.unwrap(),\n                 t.generics.print(cx),\n                 where_clause = print_where_clause(&t.generics, cx, 0, true),\n                 type_ = t.type_.print(cx),\n@@ -994,7 +994,7 @@ fn item_union(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::Uni\n                    Fields<a href=\\\"#fields\\\" class=\\\"anchor\\\"></a></h2>\"\n         );\n         for (field, ty) in fields {\n-            let name = field.name.as_ref().expect(\"union field name\");\n+            let name = field.name.expect(\"union field name\");\n             let id = format!(\"{}.{}\", ItemType::StructField, name);\n             write!(\n                 w,\n@@ -1039,7 +1039,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                 w,\n                 \"{}enum {}{}{}\",\n                 it.visibility.print_with_space(it.def_id, cx),\n-                it.name.as_ref().unwrap(),\n+                it.name.unwrap(),\n                 e.generics.print(cx),\n                 print_where_clause(&e.generics, cx, 0, true),\n             );\n@@ -1054,7 +1054,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                 }\n                 for v in &e.variants {\n                     w.write_str(\"    \");\n-                    let name = v.name.as_ref().unwrap();\n+                    let name = v.name.unwrap();\n                     match *v.kind {\n                         clean::VariantItem(ref var) => match var {\n                             clean::Variant::CLike => write!(w, \"{}\", name),\n@@ -1103,15 +1103,14 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n         );\n         document_non_exhaustive(w, it);\n         for variant in &e.variants {\n-            let id =\n-                cx.derive_id(format!(\"{}.{}\", ItemType::Variant, variant.name.as_ref().unwrap()));\n+            let id = cx.derive_id(format!(\"{}.{}\", ItemType::Variant, variant.name.unwrap()));\n             write!(\n                 w,\n                 \"<h3 id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n                     <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n                     <code>{name}\",\n                 id = id,\n-                name = variant.name.as_ref().unwrap()\n+                name = variant.name.unwrap()\n             );\n             if let clean::VariantItem(clean::Variant::Tuple(ref s)) = *variant.kind {\n                 w.write_str(\"(\");\n@@ -1137,11 +1136,8 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n             };\n \n             if let Some((heading, fields)) = heading_and_fields {\n-                let variant_id = cx.derive_id(format!(\n-                    \"{}.{}.fields\",\n-                    ItemType::Variant,\n-                    variant.name.as_ref().unwrap()\n-                ));\n+                let variant_id =\n+                    cx.derive_id(format!(\"{}.{}.fields\", ItemType::Variant, variant.name.unwrap()));\n                 write!(w, \"<div class=\\\"sub-variant\\\" id=\\\"{id}\\\">\", id = variant_id);\n                 write!(w, \"<h4>{heading}</h4>\", heading = heading);\n                 document_non_exhaustive(w, variant);\n@@ -1151,8 +1147,8 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                         clean::StructFieldItem(ref ty) => {\n                             let id = cx.derive_id(format!(\n                                 \"variant.{}.field.{}\",\n-                                variant.name.as_ref().unwrap(),\n-                                field.name.as_ref().unwrap()\n+                                variant.name.unwrap(),\n+                                field.name.unwrap()\n                             ));\n                             write!(\n                                 w,\n@@ -1162,7 +1158,7 @@ fn item_enum(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, e: &clean::Enum\n                                     <code>{f}:&nbsp;{t}</code>\\\n                                 </span>\",\n                                 id = id,\n-                                f = field.name.as_ref().unwrap(),\n+                                f = field.name.unwrap(),\n                                 t = ty.print(cx)\n                             );\n                             document(w, cx, field, Some(variant), HeadingOffset::H5);\n@@ -1201,7 +1197,7 @@ fn item_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Mac\n \n fn item_proc_macro(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, m: &clean::ProcMacro) {\n     wrap_into_docblock(w, |w| {\n-        let name = it.name.as_ref().expect(\"proc-macros always have names\");\n+        let name = it.name.expect(\"proc-macros always have names\");\n         match m.kind {\n             MacroKind::Bang => {\n                 wrap_item(w, \"macro\", |w| {\n@@ -1245,7 +1241,7 @@ fn item_constant(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, c: &clean::\n                 w,\n                 \"{vis}const {name}: {typ}\",\n                 vis = it.visibility.print_with_space(it.def_id, cx),\n-                name = it.name.as_ref().unwrap(),\n+                name = it.name.unwrap(),\n                 typ = c.type_.print(cx),\n             );\n \n@@ -1338,7 +1334,7 @@ fn item_static(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, s: &clean::St\n                 \"{vis}static {mutability}{name}: {typ}\",\n                 vis = it.visibility.print_with_space(it.def_id, cx),\n                 mutability = s.mutability.print_with_space(),\n-                name = it.name.as_ref().unwrap(),\n+                name = it.name.unwrap(),\n                 typ = s.type_.print(cx)\n             );\n         });\n@@ -1355,7 +1351,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n                 w,\n                 \"    {}type {};\\n}}\",\n                 it.visibility.print_with_space(it.def_id, cx),\n-                it.name.as_ref().unwrap(),\n+                it.name.unwrap(),\n             );\n         });\n     });\n@@ -1523,12 +1519,7 @@ fn render_union(\n     tab: &str,\n     cx: &Context<'_>,\n ) {\n-    write!(\n-        w,\n-        \"{}union {}\",\n-        it.visibility.print_with_space(it.def_id, cx),\n-        it.name.as_ref().unwrap()\n-    );\n+    write!(w, \"{}union {}\", it.visibility.print_with_space(it.def_id, cx), it.name.unwrap());\n     if let Some(g) = g {\n         write!(w, \"{}\", g.print(cx));\n         write!(w, \"{}\", print_where_clause(g, cx, 0, true));\n@@ -1548,7 +1539,7 @@ fn render_union(\n                 w,\n                 \"    {}{}: {},\\n{}\",\n                 field.visibility.print_with_space(field.def_id, cx),\n-                field.name.as_ref().unwrap(),\n+                field.name.unwrap(),\n                 ty.print(cx),\n                 tab\n             );\n@@ -1579,7 +1570,7 @@ fn render_struct(\n         \"{}{}{}\",\n         it.visibility.print_with_space(it.def_id, cx),\n         if structhead { \"struct \" } else { \"\" },\n-        it.name.as_ref().unwrap()\n+        it.name.unwrap()\n     );\n     if let Some(g) = g {\n         write!(w, \"{}\", g.print(cx))\n@@ -1604,7 +1595,7 @@ fn render_struct(\n                         \"\\n{}    {}{}: {},\",\n                         tab,\n                         field.visibility.print_with_space(field.def_id, cx),\n-                        field.name.as_ref().unwrap(),\n+                        field.name.unwrap(),\n                         ty.print(cx),\n                     );\n                 }"}]}