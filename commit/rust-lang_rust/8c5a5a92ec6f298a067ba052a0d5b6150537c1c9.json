{"sha": "8c5a5a92ec6f298a067ba052a0d5b6150537c1c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNWE1YTkyZWM2ZjI5OGEwNjdiYTA1MmEwZDViNjE1MDUzN2MxYzk=", "commit": {"author": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-05-26T23:57:36Z"}, "committer": {"name": "Devin R", "email": "devin.ragotzy@gmail.com", "date": "2020-06-08T20:00:33Z"}, "message": "cleaned up import suggestion formatter, look into code reuse with wildcard impotrs", "tree": {"sha": "815dd6400e8fd1b961f3238e54863c1239b95b89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/815dd6400e8fd1b961f3238e54863c1239b95b89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c5a5a92ec6f298a067ba052a0d5b6150537c1c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c5a5a92ec6f298a067ba052a0d5b6150537c1c9", "html_url": "https://github.com/rust-lang/rust/commit/8c5a5a92ec6f298a067ba052a0d5b6150537c1c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c5a5a92ec6f298a067ba052a0d5b6150537c1c9/comments", "author": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DevinR528", "id": 29749111, "node_id": "MDQ6VXNlcjI5NzQ5MTEx", "avatar_url": "https://avatars.githubusercontent.com/u/29749111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DevinR528", "html_url": "https://github.com/DevinR528", "followers_url": "https://api.github.com/users/DevinR528/followers", "following_url": "https://api.github.com/users/DevinR528/following{/other_user}", "gists_url": "https://api.github.com/users/DevinR528/gists{/gist_id}", "starred_url": "https://api.github.com/users/DevinR528/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DevinR528/subscriptions", "organizations_url": "https://api.github.com/users/DevinR528/orgs", "repos_url": "https://api.github.com/users/DevinR528/repos", "events_url": "https://api.github.com/users/DevinR528/events{/privacy}", "received_events_url": "https://api.github.com/users/DevinR528/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4f60b5ff42a4e8b5889879664002f90dacd6c04", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4f60b5ff42a4e8b5889879664002f90dacd6c04", "html_url": "https://github.com/rust-lang/rust/commit/d4f60b5ff42a4e8b5889879664002f90dacd6c04"}], "stats": {"total": 242, "additions": 64, "deletions": 178}, "files": [{"sha": "089ae79b02c232353b803d336b13d7dace75fc62", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 49, "deletions": 175, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/8c5a5a92ec6f298a067ba052a0d5b6150537c1c9/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c5a5a92ec6f298a067ba052a0d5b6150537c1c9/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=8c5a5a92ec6f298a067ba052a0d5b6150537c1c9", "patch": "@@ -29,6 +29,12 @@ declare_clippy_lint! {\n \n const BRACKETS: &[char] = &['<', '>'];\n \n+#[derive(Clone, Debug, PartialEq, Eq)]\n+struct PathAndSpan {\n+    path: String,\n+    span: Span,\n+}\n+\n /// `MacroRefData` includes the name of the macro\n /// and the path from `SourceMap::span_to_filename`.\n #[derive(Debug, Clone)]\n@@ -110,7 +116,8 @@ impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n                 for kid in cx.tcx.item_children(id).iter() {\n                     if let Res::Def(DefKind::Macro(_mac_type), mac_id) = kid.res {\n                         let span = mac_attr.span;\n-                        self.imports.push((cx.tcx.def_path_str(mac_id), span));\n+                        let def_path = cx.tcx.def_path_str(mac_id);\n+                        self.imports.push((def_path, span));\n                     }\n                 }\n             } else {\n@@ -147,127 +154,69 @@ impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n     }\n     #[allow(clippy::too_many_lines)]\n     fn check_crate_post(&mut self, cx: &LateContext<'_, '_>, _krate: &hir::Crate<'_>) {\n-        let mut import_map = FxHashMap::default();\n+        let mut used = FxHashMap::default();\n+        let mut check_dup = vec![];\n         for (import, span) in &self.imports {\n             let found_idx = self.mac_refs.iter().position(|mac| import.ends_with(&mac.name));\n \n             if let Some(idx) = found_idx {\n                 let _ = self.mac_refs.remove(idx);\n-                proccess_macro_path(*span, import, &mut import_map);\n-            }\n-        }\n-        // println!(\"{:#?}\", import_map);\n-        let mut imports = vec![];\n-        for (root, rest) in import_map {\n-            let mut path = format!(\"use {}::\", root);\n-            let mut attr_span = None;\n-            // when a multiple nested paths are found one may be written to the string\n-            // before it is found in this loop so we make note and skip it when this\n-            // loop finds it\n-            let mut found_nested = vec![];\n-            let mut count = 1;\n-            let rest_len = rest.len();\n-\n-            if rest_len > 1 {\n-                path.push_str(\"{\");\n-            }\n-\n-            for m in &rest {\n-                if attr_span.is_none() {\n-                    attr_span = Some(m.span());\n-                }\n-                if found_nested.contains(&m) {\n-                    continue;\n-                }\n-                let comma = if rest_len == count { \"\" } else { \", \" };\n-                match m {\n-                    ModPath::Item { item, .. } => {\n-                        path.push_str(&format!(\"{}{}\", item, comma));\n+                let seg = import.split(\"::\").collect::<Vec<_>>();\n+\n+                match seg.as_slice() {\n+                    [] => unreachable!(\"this should never be empty\"),\n+                    [_] => unreachable!(\"path must have two segments ?\"),\n+                    [root, item] => {\n+                        if !check_dup.contains(&item.to_string()) {\n+                            used.entry((root.to_string(), span))\n+                                .or_insert(vec![])\n+                                .push(item.to_string());\n+                            check_dup.push(item.to_string());\n+                        }\n                     },\n-                    ModPath::Nested { segments, item, .. } => {\n-                        // do any other Nested paths match the current one\n-                        let nested = rest\n-                            .iter()\n-                            // filter \"self\" out\n-                            .filter(|other_m| other_m != &m)\n-                            // filters out Nested we have previously seen\n-                            .filter(|other_m| !found_nested.contains(other_m))\n-                            // this matches the first path segment and filters non ModPath::Nested items\n-                            .filter(|other_m| other_m.matches(0, m))\n-                            .collect::<Vec<_>>();\n-\n-                        if nested.is_empty() {\n-                            path.push_str(&format!(\"{}::{}{}\", segments.join(\"::\").to_string(), item, comma))\n-                        // use mod_a::{mod_b::{one, two}, mod_c::item}\n+                    [root, rest @ ..] => {\n+                        if !rest.iter().all(|item| !check_dup.contains(&item.to_string())) {\n+                            let mut rest = rest.to_vec();\n+                            rest.sort();\n+                            used.entry((root.to_string(), span))\n+                                .or_insert(vec![])\n+                                .push(rest.join(\"::\"));\n+                            check_dup.extend(rest.iter().map(ToString::to_string));\n                         } else {\n-                            found_nested.extend(nested.iter());\n-                            found_nested.push(&m);\n-                            // we check each segment for matches with other import paths if\n-                            // one differs we have to open a new `{}`\n-                            for (idx, seg) in segments.iter().enumerate() {\n-                                path.push_str(&format!(\"{}::\", seg));\n-                                if nested.iter().all(|other_m| other_m.matches(idx, &m)) {\n-                                    continue;\n-                                }\n-\n-                                path.push_str(\"{\");\n-                                let matched_seg_items = nested\n-                                    .iter()\n-                                    .filter(|other_m| !other_m.matches(idx, &m))\n-                                    .collect::<Vec<_>>();\n-                                for item in matched_seg_items {\n-                                    if let ModPath::Nested { item, .. } = item {\n-                                        path.push_str(&format!(\n-                                            \"{}{}\",\n-                                            item,\n-                                            if nested.len() == idx + 1 { \"\" } else { \", \" }\n-                                        ));\n-                                    }\n-                                }\n-                                path.push_str(\"}\");\n-                            }\n-                            path.push_str(&format!(\"{{{}{}\", item, comma));\n-                            for (i, item) in nested.iter().enumerate() {\n-                                if let ModPath::Nested { item, segments: matched_seg, .. } = item {\n-                                    path.push_str(&format!(\n-                                        \"{}{}{}\",\n-                                        if matched_seg > segments {\n-                                            format!(\"{}::\", matched_seg[segments.len()..].join(\"::\"))\n-                                        } else {\n-                                            String::new()\n-                                        },\n-                                        item,\n-                                        if nested.len() == i + 1 { \"\" } else { \", \" }\n-                                    ));\n-                                }\n-                            }\n-                            path.push_str(\"}\");\n+                            let mut filtered = rest\n+                                .iter()\n+                                .filter(|item| !check_dup.contains(&item.to_string()))\n+                                .map(ToString::to_string)\n+                                .collect::<Vec<_>>();\n+                            filtered.sort();\n+                            used.entry((root.to_string(), span))\n+                                .or_insert(vec![])\n+                                .push(filtered.join(\"::\"));\n+                            check_dup.extend(filtered);\n                         }\n                     },\n                 }\n-                count += 1;\n             }\n-            if rest_len > 1 {\n-                path.push_str(\"};\");\n-            } else {\n-                path.push_str(\";\");\n-            }\n-            if let Some(span) = attr_span {\n-                imports.push((span, path))\n+        }\n+\n+        let mut suggestions = vec![];\n+        for ((root, span), path) in used {\n+            if path.len() == 1 {\n+                suggestions.push((span, format!(\"{}::{}\", root, path[0])))\n             } else {\n-                unreachable!(\"a span must always be attached to a macro_use attribute\")\n+                suggestions.push((span, format!(\"{}::{{{}}}\", root, path.join(\", \"))))\n             }\n         }\n \n         // If mac_refs is not empty we have encountered an import we could not handle\n         // such as `std::prelude::v1::foo` or some other macro that expands to an import.\n         if self.mac_refs.is_empty() {\n-            for (span, import) in imports {\n+            for (span, import) in suggestions {\n                 let help = format!(\"use {}\", import);\n                 span_lint_and_sugg(\n                     cx,\n                     MACRO_USE_IMPORTS,\n-                    span,\n+                    *span,\n                     \"`macro_use` attributes are no longer needed in the Rust 2018 edition\",\n                     \"remove the attribute and import the macro directly, try\",\n                     help,\n@@ -277,78 +226,3 @@ impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n         }\n     }\n }\n-\n-#[derive(Debug, PartialEq)]\n-enum ModPath {\n-    Item {\n-        item: String,\n-        span: Span,\n-    },\n-    Nested {\n-        segments: Vec<String>,\n-        item: String,\n-        span: Span,\n-    },\n-}\n-\n-impl ModPath {\n-    fn span(&self) -> Span {\n-        match self {\n-            Self::Item { span, .. } | Self::Nested { span, .. } => *span,\n-        }\n-    }\n-\n-    fn item(&self) -> &str {\n-        match self {\n-            Self::Item { item, .. } | Self::Nested { item, .. } => item,\n-        }\n-    }\n-\n-    fn matches(&self, idx: usize, other: &ModPath) -> bool {\n-        match (self, other) {\n-            (Self::Item { item, .. }, Self::Item { item: other_item, .. }) => item == other_item,\n-            (\n-                Self::Nested { segments, .. },\n-                Self::Nested {\n-                    segments: other_names, ..\n-                },\n-            ) => match (segments.get(idx), other_names.get(idx)) {\n-                (Some(seg), Some(other_seg)) => seg == other_seg,\n-                (_, _) => false,\n-            },\n-            (_, _) => false,\n-        }\n-    }\n-}\n-\n-#[allow(clippy::comparison_chain)]\n-fn proccess_macro_path(span: Span, import: &str, import_map: &mut FxHashMap<String, Vec<ModPath>>) {\n-    let mut mod_path = import.split(\"::\").collect::<Vec<_>>();\n-\n-    if mod_path.len() == 2 {\n-        let item_list = import_map.entry(mod_path[0].to_string()).or_insert_with(Vec::new);\n-\n-        if !item_list.iter().any(|mods| mods.item() == mod_path[1]) {\n-            item_list.push(ModPath::Item {\n-                item: mod_path[1].to_string(),\n-                span,\n-            });\n-        }\n-    } else if mod_path.len() > 2 {\n-        let first = mod_path.remove(0);\n-        let name = mod_path.remove(mod_path.len() - 1);\n-\n-        let nested = ModPath::Nested {\n-            segments: mod_path.into_iter().map(ToString::to_string).collect(),\n-            item: name.to_string(),\n-            span,\n-        };\n-        // CLIPPY NOTE: this told me to use `or_insert_with(vec![])`\n-        // import_map.entry(first.to_string()).or_insert(vec![]).push(nested);\n-        // which failed as `vec!` is not a closure then told me to add `||` which failed\n-        // with the redundant_closure lint so I finally gave up and used this.\n-        import_map.entry(first.to_string()).or_insert_with(Vec::new).push(nested);\n-    } else {\n-        unreachable!(\"test to see if code path hit TODO REMOVE\")\n-    }\n-}"}, {"sha": "83c8ebe6ab9ed4f79696dbb56e0d1deaed4340ca", "filename": "tests/ui/macro_use_imports.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c5a5a92ec6f298a067ba052a0d5b6150537c1c9/tests%2Fui%2Fmacro_use_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c5a5a92ec6f298a067ba052a0d5b6150537c1c9/tests%2Fui%2Fmacro_use_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.stderr?ref=8c5a5a92ec6f298a067ba052a0d5b6150537c1c9", "patch": "@@ -2,15 +2,27 @@ error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n   --> $DIR/macro_use_imports.rs:17:5\n    |\n LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use use mini_mac::ClippyMiniMacroTest;`\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mini_mac::ClippyMiniMacroTest`\n    |\n    = note: `-D clippy::macro-use-imports` implied by `-D warnings`\n \n+error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n+  --> $DIR/macro_use_imports.rs:21:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::inner::nested::string_add`\n+\n+error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n+  --> $DIR/macro_use_imports.rs:19:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{foofoo::inner, inner::try_err}`\n+\n error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n   --> $DIR/macro_use_imports.rs:15:5\n    |\n LL |     #[macro_use]\n-   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use use mac::{pub_macro, inner_mod_macro, function_macro, ty_macro, pub_in_private_macro, inner::{foofoo, try_err, nested::string_add}};`\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{pub_macro, inner_mod_macro, function_macro, ty_macro, pub_in_private_macro}`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n "}]}