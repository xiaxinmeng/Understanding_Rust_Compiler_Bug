{"sha": "50302821c4f63f487783762c1b45b412c2574334", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMzAyODIxYzRmNjNmNDg3NzgzNzYyYzFiNDViNDEyYzI1NzQzMzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-06T12:54:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-06T12:54:45Z"}, "message": "Auto merge of #51894 - mikhail-m1:8636, r=nikomatsakis\n\nfix for issue #8636\n\nr? @nikomatsakis\n\nFix #8636\n\nalso fixes #42291", "tree": {"sha": "b95c1888fc40193598cb3545c0b3d29c615acdec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b95c1888fc40193598cb3545c0b3d29c615acdec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50302821c4f63f487783762c1b45b412c2574334", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50302821c4f63f487783762c1b45b412c2574334", "html_url": "https://github.com/rust-lang/rust/commit/50302821c4f63f487783762c1b45b412c2574334", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50302821c4f63f487783762c1b45b412c2574334/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ded86ccc2c6ca226d5998365a71779a816ccf09f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ded86ccc2c6ca226d5998365a71779a816ccf09f", "html_url": "https://github.com/rust-lang/rust/commit/ded86ccc2c6ca226d5998365a71779a816ccf09f"}, {"sha": "6d0644c65a99505dfd1be844cebb84082a0466a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d0644c65a99505dfd1be844cebb84082a0466a3", "html_url": "https://github.com/rust-lang/rust/commit/6d0644c65a99505dfd1be844cebb84082a0466a3"}], "stats": {"total": 373, "additions": 357, "deletions": 16}, "files": [{"sha": "a9eec53fd94b28a2c4d7a7a70577ceda4484e3fe", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 68, "deletions": 16, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/50302821c4f63f487783762c1b45b412c2574334/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50302821c4f63f487783762c1b45b412c2574334/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=50302821c4f63f487783762c1b45b412c2574334", "patch": "@@ -15,6 +15,7 @@ use rustc::hir;\n use rustc::mir::{Mir, Place};\n use rustc::mir::{Projection, ProjectionElem};\n use rustc::ty::{self, TyCtxt};\n+use std::cmp::max;\n \n pub(super) fn places_conflict<'gcx, 'tcx>(\n     tcx: TyCtxt<'_, 'gcx, 'tcx>,\n@@ -394,27 +395,78 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n                 | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n                 | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n-                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::ConstantIndex { .. })\n-                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. })\n-                | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..))\n-                | (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. })\n-                | (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+                | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..)) => {\n                     // Array indexes (`a[0]` vs. `a[i]`). These can either be disjoint\n                     // (if the indexes differ) or equal (if they are the same), so this\n                     // is the recursive case that gives \"equal *or* disjoint\" its meaning.\n-                    //\n-                    // Note that by construction, MIR at borrowck can't subdivide\n-                    // `Subslice` accesses (e.g. `a[2..3][i]` will never be present) - they\n-                    // are only present in slice patterns, and we \"merge together\" nested\n-                    // slice patterns. That means we don't have to think about these. It's\n-                    // probably a good idea to assert this somewhere, but I'm too lazy.\n-                    //\n-                    // FIXME(#8636) we might want to return Disjoint if\n-                    // both projections are constant and disjoint.\n-                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY\");\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-INDEX\");\n                     Overlap::EqualOrDisjoint\n                 }\n-\n+                (ProjectionElem::ConstantIndex { offset: o1, min_length: _, from_end: false },\n+                    ProjectionElem::ConstantIndex { offset: o2, min_length: _, from_end: false })\n+                | (ProjectionElem::ConstantIndex { offset: o1, min_length: _, from_end: true },\n+                    ProjectionElem::ConstantIndex {\n+                        offset: o2, min_length: _, from_end: true }) => {\n+                    if o1 == o2 {\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX\");\n+                        Overlap::Disjoint\n+                    }\n+                }\n+                (ProjectionElem::ConstantIndex {\n+                    offset: offset_from_begin, min_length: min_length1, from_end: false },\n+                    ProjectionElem::ConstantIndex {\n+                        offset: offset_from_end, min_length: min_length2, from_end: true })\n+                | (ProjectionElem::ConstantIndex {\n+                    offset: offset_from_end, min_length: min_length1, from_end: true },\n+                   ProjectionElem::ConstantIndex {\n+                       offset: offset_from_begin, min_length: min_length2, from_end: false }) => {\n+                    // both patterns matched so it must be at least the greater of the two\n+                    let min_length = max(min_length1, min_length2);\n+                    // `offset_from_end` can be in range `[1..min_length]`, 1 indicates the last\n+                    // element (like -1 in Python) and `min_length` the first.\n+                    // Therefore, `min_length - offset_from_end` gives the minimal possible\n+                    // offset from the beginning\n+                    if *offset_from_begin >= min_length - offset_from_end {\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-FE\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-FE\");\n+                        Overlap::Disjoint\n+                    }\n+                }\n+                (ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false },\n+                 ProjectionElem::Subslice {from, .. })\n+                | (ProjectionElem::Subslice {from, .. },\n+                    ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false }) => {\n+                    if offset >= from {\n+                        debug!(\n+                            \"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-SUBSLICE\");\n+                        Overlap::Disjoint\n+                    }\n+                }\n+                (ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true },\n+                 ProjectionElem::Subslice {from: _, to })\n+                | (ProjectionElem::Subslice {from: _, to },\n+                    ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true }) => {\n+                    if offset > to {\n+                        debug!(\"place_element_conflict: \\\n+                               DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-SUBSLICE-FE\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-ARRAY-CONSTANT-INDEX-SUBSLICE-FE\");\n+                        Overlap::Disjoint\n+                    }\n+                }\n+                (ProjectionElem::Subslice { .. }, ProjectionElem::Subslice { .. }) => {\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-SUBSLICES\");\n+                     Overlap::EqualOrDisjoint\n+                }\n                 (ProjectionElem::Deref, _)\n                 | (ProjectionElem::Field(..), _)\n                 | (ProjectionElem::Index(..), _)"}, {"sha": "48d16102ff3c2366085a754e4eb4544bc5622e9f", "filename": "src/test/run-pass/borrowck/borrowck-slice-pattern-element-loan.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/50302821c4f63f487783762c1b45b412c2574334/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50302821c4f63f487783762c1b45b412c2574334/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs?ref=50302821c4f63f487783762c1b45b412c2574334", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-flags: -Z borrowck=mir\n+\n+#![feature(slice_patterns)]\n+\n+fn mut_head_tail<'a, A>(v: &'a mut [A]) -> Option<(&'a mut A, &'a mut [A])> {\n+    match *v {\n+        [ref mut head, ref mut tail..] => {\n+            Some((head, tail))\n+        }\n+        [] => None\n+    }\n+}\n+\n+fn main() {\n+    let mut v = [1,2,3,4];\n+    match mut_head_tail(&mut v) {\n+        None => {},\n+        Some((h,t)) => {\n+            *h = 1000;\n+            t.reverse();\n+        }\n+    }\n+}"}, {"sha": "da36f494eb6868297431f21ea17e59464e2210a1", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/50302821c4f63f487783762c1b45b412c2574334/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50302821c4f63f487783762c1b45b412c2574334/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.rs?ref=50302821c4f63f487783762c1b45b412c2574334", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-flags: -Z borrowck=mir\n+\n+#![feature(slice_patterns)]\n+\n+fn nop(_s: &[& i32]) {}\n+fn nop_subslice(_s: &[i32]) {}\n+\n+fn const_index_ok(s: &mut [i32]) {\n+    if let [ref first, ref second, _, ref fourth, ..] = *s {\n+        if let [_, _, ref mut third, ..] = *s {\n+            nop(&[first, second, third, fourth]);\n+        }\n+    }\n+}\n+\n+fn const_index_err(s: &mut [i32]) {\n+    if let [ref first, ref second, ..] = *s {\n+        if let [_, ref mut  second2, ref mut third, ..] = *s { //~ERROR\n+            nop(&[first, second, second2, third]);\n+        }\n+    }\n+}\n+\n+fn const_index_from_end_ok(s: &mut [i32]) {\n+    if let [.., ref fourth, ref third, _, ref first] = *s {\n+        if let [.., ref mut second, _] = *s {\n+            nop(&[first, second, third, fourth]);\n+        }\n+    }\n+}\n+\n+fn const_index_from_end_err(s: &mut [i32]) {\n+    if let [.., ref fourth, ref third, _, ref first] = *s {\n+        if let [.., ref mut third2, _, _] = *s { //~ERROR\n+            nop(&[first, third, third2, fourth]);\n+        }\n+    }\n+}\n+\n+fn const_index_mixed(s: &mut [i32]) {\n+    if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n+        if let [ref mut from_begin0, ..] = *s {\n+            nop(&[from_begin0, from_end1, from_end3, from_end4]);\n+        }\n+        if let [_, ref mut from_begin1, ..] = *s { //~ERROR\n+            nop(&[from_begin1, from_end1, from_end3, from_end4]);\n+        }\n+        if let [_, _, ref mut from_begin2, ..] = *s { //~ERROR\n+            nop(&[from_begin2, from_end1, from_end3, from_end4]);\n+        }\n+        if let [_, _, _, ref mut from_begin3, ..] = *s { //~ERROR\n+            nop(&[from_begin3, from_end1, from_end3, from_end4]);\n+        }\n+    }\n+    if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n+        if let [.., ref mut from_end1] = *s {\n+            nop(&[from_begin0, from_begin1, from_begin3, from_end1]);\n+        }\n+        if let [.., ref mut from_end2, _] = *s { //~ERROR\n+            nop(&[from_begin0, from_begin1, from_begin3, from_end2]);\n+        }\n+        if let [.., ref mut from_end3, _,  _] = *s { //~ERROR\n+            nop(&[from_begin0, from_begin1, from_begin3, from_end3]);\n+        }\n+        if let [.., ref mut from_end4, _, _, _] = *s { //~ERROR\n+            nop(&[from_begin0, from_begin1, from_begin3, from_end4]);\n+        }\n+    }\n+}\n+\n+fn const_index_and_subslice_ok(s: &mut [i32]) {\n+    if let [ref first, ref second, ..] = *s {\n+        if let [_, _, ref mut tail..] = *s {\n+            nop(&[first, second]);\n+            nop_subslice(tail);\n+        }\n+    }\n+}\n+\n+fn const_index_and_subslice_err(s: &mut [i32]) {\n+    if let [ref first, ref second, ..] = *s {\n+        if let [_, ref mut tail..] = *s { //~ERROR\n+            nop(&[first, second]);\n+            nop_subslice(tail);\n+        }\n+    }\n+}\n+\n+fn const_index_and_subslice_from_end_ok(s: &mut [i32]) {\n+    if let [.., ref second, ref first] = *s {\n+        if let [ref mut tail.., _, _] = *s {\n+            nop(&[first, second]);\n+            nop_subslice(tail);\n+        }\n+    }\n+}\n+\n+fn const_index_and_subslice_from_end_err(s: &mut [i32]) {\n+    if let [.., ref second, ref first] = *s {\n+        if let [ref mut tail.., _] = *s { //~ERROR\n+            nop(&[first, second]);\n+            nop_subslice(tail);\n+        }\n+    }\n+}\n+\n+fn subslices(s: &mut [i32]) {\n+    if let [_, _, _, ref s1..] = *s {\n+        if let [ref mut s2.., _, _, _] = *s { //~ERROR\n+            nop_subslice(s1);\n+            nop_subslice(s2);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let mut v = [1,2,3,4];\n+    const_index_ok(&mut v);\n+    const_index_err(&mut v);\n+    const_index_from_end_ok(&mut v);\n+    const_index_from_end_err(&mut v);\n+    const_index_and_subslice_ok(&mut v);\n+    const_index_and_subslice_err(&mut v);\n+    const_index_and_subslice_from_end_ok(&mut v);\n+    const_index_and_subslice_from_end_err(&mut v);\n+    subslices(&mut v);\n+}"}, {"sha": "16d401ec7f9bf5403815999165689231735ba545", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan.stderr", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/50302821c4f63f487783762c1b45b412c2574334/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50302821c4f63f487783762c1b45b412c2574334/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan.stderr?ref=50302821c4f63f487783762c1b45b412c2574334", "patch": "@@ -0,0 +1,119 @@\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:28:20\n+   |\n+LL |     if let [ref first, ref second, ..] = *s {\n+   |                        ---------- immutable borrow occurs here\n+LL |         if let [_, ref mut  second2, ref mut third, ..] = *s { //~ERROR\n+   |                    ^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[first, second, second2, third]);\n+   |                          ------ borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:44:21\n+   |\n+LL |     if let [.., ref fourth, ref third, _, ref first] = *s {\n+   |                             --------- immutable borrow occurs here\n+LL |         if let [.., ref mut third2, _, _] = *s { //~ERROR\n+   |                     ^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[first, third, third2, fourth]);\n+   |                          ----- borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:55:20\n+   |\n+LL |     if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n+   |                    ------------- immutable borrow occurs here\n+...\n+LL |         if let [_, ref mut from_begin1, ..] = *s { //~ERROR\n+   |                    ^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[from_begin1, from_end1, from_end3, from_end4]);\n+   |                                                      --------- borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:58:23\n+   |\n+LL |     if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n+   |                                   ------------- immutable borrow occurs here\n+...\n+LL |         if let [_, _, ref mut from_begin2, ..] = *s { //~ERROR\n+   |                       ^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[from_begin2, from_end1, from_end3, from_end4]);\n+   |                                           --------- borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:61:26\n+   |\n+LL |     if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n+   |                                   ------------- immutable borrow occurs here\n+...\n+LL |         if let [_, _, _, ref mut from_begin3, ..] = *s { //~ERROR\n+   |                          ^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[from_begin3, from_end1, from_end3, from_end4]);\n+   |                                           --------- borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:69:21\n+   |\n+LL |     if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n+   |                                                  --------------- immutable borrow occurs here\n+...\n+LL |         if let [.., ref mut from_end2, _] = *s { //~ERROR\n+   |                     ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[from_begin0, from_begin1, from_begin3, from_end2]);\n+   |                                             ----------- borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:72:21\n+   |\n+LL |     if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n+   |                                                  --------------- immutable borrow occurs here\n+...\n+LL |         if let [.., ref mut from_end3, _,  _] = *s { //~ERROR\n+   |                     ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[from_begin0, from_begin1, from_begin3, from_end3]);\n+   |                                             ----------- borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:75:21\n+   |\n+LL |     if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n+   |                              --------------- immutable borrow occurs here\n+...\n+LL |         if let [.., ref mut from_end4, _, _, _] = *s { //~ERROR\n+   |                     ^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[from_begin0, from_begin1, from_begin3, from_end4]);\n+   |                                ----------- borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:92:20\n+   |\n+LL |     if let [ref first, ref second, ..] = *s {\n+   |                        ---------- immutable borrow occurs here\n+LL |         if let [_, ref mut tail..] = *s { //~ERROR\n+   |                    ^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[first, second]);\n+   |                          ------ borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:110:17\n+   |\n+LL |     if let [.., ref second, ref first] = *s {\n+   |                 ---------- immutable borrow occurs here\n+LL |         if let [ref mut tail.., _] = *s { //~ERROR\n+   |                 ^^^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop(&[first, second]);\n+   |                          ------ borrow later used here\n+\n+error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n+  --> $DIR/borrowck-slice-pattern-element-loan.rs:119:17\n+   |\n+LL |     if let [_, _, _, ref s1..] = *s {\n+   |                      ------ immutable borrow occurs here\n+LL |         if let [ref mut s2.., _, _, _] = *s { //~ERROR\n+   |                 ^^^^^^^^^^ mutable borrow occurs here\n+LL |             nop_subslice(s1);\n+   |                          -- borrow later used here\n+\n+error: aborting due to 11 previous errors\n+\n+For more information about this error, try `rustc --explain E0502`."}]}