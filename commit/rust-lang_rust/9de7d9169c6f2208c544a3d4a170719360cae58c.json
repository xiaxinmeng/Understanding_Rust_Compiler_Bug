{"sha": "9de7d9169c6f2208c544a3d4a170719360cae58c", "node_id": "C_kwDOAAsO6NoAKDlkZTdkOTE2OWM2ZjIyMDhjNTQ0YTNkNGExNzA3MTkzNjBjYWU1OGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-23T06:58:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-23T06:58:28Z"}, "message": "Auto merge of #110655 - ChrisDenton:read-to-end, r=joshtriplett\n\nLimit read size in `File::read_to_end` loop\n\nFixes #110650.\n\nWindows file reads have perf overhead that's proportional to the buffer size. When we have a reasonable expectation that we know the file size, we can set a reasonable upper bound for the size of the buffer in one read call.", "tree": {"sha": "4b71b786d77a4597dfe4a48405267126276eb873", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b71b786d77a4597dfe4a48405267126276eb873"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9de7d9169c6f2208c544a3d4a170719360cae58c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9de7d9169c6f2208c544a3d4a170719360cae58c", "html_url": "https://github.com/rust-lang/rust/commit/9de7d9169c6f2208c544a3d4a170719360cae58c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9de7d9169c6f2208c544a3d4a170719360cae58c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61de794664e673cb98c01274b3bc88b8a994001a", "url": "https://api.github.com/repos/rust-lang/rust/commits/61de794664e673cb98c01274b3bc88b8a994001a", "html_url": "https://github.com/rust-lang/rust/commit/61de794664e673cb98c01274b3bc88b8a994001a"}, {"sha": "f74fe8bf4ca773e416d4da3a3bf37045b06ea3de", "url": "https://api.github.com/repos/rust-lang/rust/commits/f74fe8bf4ca773e416d4da3a3bf37045b06ea3de", "html_url": "https://github.com/rust-lang/rust/commit/f74fe8bf4ca773e416d4da3a3bf37045b06ea3de"}], "stats": {"total": 67, "additions": 43, "deletions": 24}, "files": [{"sha": "55580b23a6249a31541e61170b3385580b9c4055", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9de7d9169c6f2208c544a3d4a170719360cae58c/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de7d9169c6f2208c544a3d4a170719360cae58c/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=9de7d9169c6f2208c544a3d4a170719360cae58c", "patch": "@@ -249,9 +249,9 @@ pub struct DirBuilder {\n pub fn read<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {\n     fn inner(path: &Path) -> io::Result<Vec<u8>> {\n         let mut file = File::open(path)?;\n-        let size = file.metadata().map(|m| m.len()).unwrap_or(0);\n-        let mut bytes = Vec::with_capacity(size as usize);\n-        io::default_read_to_end(&mut file, &mut bytes)?;\n+        let size = file.metadata().map(|m| m.len() as usize).ok();\n+        let mut bytes = Vec::with_capacity(size.unwrap_or(0));\n+        io::default_read_to_end(&mut file, &mut bytes, size)?;\n         Ok(bytes)\n     }\n     inner(path.as_ref())\n@@ -289,9 +289,9 @@ pub fn read<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {\n pub fn read_to_string<P: AsRef<Path>>(path: P) -> io::Result<String> {\n     fn inner(path: &Path) -> io::Result<String> {\n         let mut file = File::open(path)?;\n-        let size = file.metadata().map(|m| m.len()).unwrap_or(0);\n-        let mut string = String::with_capacity(size as usize);\n-        io::default_read_to_string(&mut file, &mut string)?;\n+        let size = file.metadata().map(|m| m.len() as usize).ok();\n+        let mut string = String::with_capacity(size.unwrap_or(0));\n+        io::default_read_to_string(&mut file, &mut string, size)?;\n         Ok(string)\n     }\n     inner(path.as_ref())\n@@ -732,12 +732,12 @@ impl fmt::Debug for File {\n }\n \n /// Indicates how much extra capacity is needed to read the rest of the file.\n-fn buffer_capacity_required(mut file: &File) -> usize {\n-    let size = file.metadata().map(|m| m.len()).unwrap_or(0);\n-    let pos = file.stream_position().unwrap_or(0);\n+fn buffer_capacity_required(mut file: &File) -> Option<usize> {\n+    let size = file.metadata().map(|m| m.len()).ok()?;\n+    let pos = file.stream_position().ok()?;\n     // Don't worry about `usize` overflow because reading will fail regardless\n     // in that case.\n-    size.saturating_sub(pos) as usize\n+    Some(size.saturating_sub(pos) as usize)\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -761,14 +761,16 @@ impl Read for File {\n \n     // Reserves space in the buffer based on the file size when available.\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        buf.reserve(buffer_capacity_required(self));\n-        io::default_read_to_end(self, buf)\n+        let size = buffer_capacity_required(self);\n+        buf.reserve(size.unwrap_or(0));\n+        io::default_read_to_end(self, buf, size)\n     }\n \n     // Reserves space in the buffer based on the file size when available.\n     fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n-        buf.reserve(buffer_capacity_required(self));\n-        io::default_read_to_string(self, buf)\n+        let size = buffer_capacity_required(self);\n+        buf.reserve(size.unwrap_or(0));\n+        io::default_read_to_string(self, buf, size)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -817,14 +819,16 @@ impl Read for &File {\n \n     // Reserves space in the buffer based on the file size when available.\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        buf.reserve(buffer_capacity_required(self));\n-        io::default_read_to_end(self, buf)\n+        let size = buffer_capacity_required(self);\n+        buf.reserve(size.unwrap_or(0));\n+        io::default_read_to_end(self, buf, size)\n     }\n \n     // Reserves space in the buffer based on the file size when available.\n     fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n-        buf.reserve(buffer_capacity_required(self));\n-        io::default_read_to_string(self, buf)\n+        let size = buffer_capacity_required(self);\n+        buf.reserve(size.unwrap_or(0));\n+        io::default_read_to_string(self, buf, size)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "4cd7885bd4abb2b44e4aa3d0746caf2bf632021f", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9de7d9169c6f2208c544a3d4a170719360cae58c/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de7d9169c6f2208c544a3d4a170719360cae58c/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=9de7d9169c6f2208c544a3d4a170719360cae58c", "patch": "@@ -357,17 +357,30 @@ where\n // of data to return. Simply tacking on an extra DEFAULT_BUF_SIZE space every\n // time is 4,500 times (!) slower than a default reservation size of 32 if the\n // reader has a very small amount of data to return.\n-pub(crate) fn default_read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n+pub(crate) fn default_read_to_end<R: Read + ?Sized>(\n+    r: &mut R,\n+    buf: &mut Vec<u8>,\n+    size_hint: Option<usize>,\n+) -> Result<usize> {\n     let start_len = buf.len();\n     let start_cap = buf.capacity();\n+    // Optionally limit the maximum bytes read on each iteration.\n+    // This adds an arbitrary fiddle factor to allow for more data than we expect.\n+    let max_read_size =\n+        size_hint.and_then(|s| s.checked_add(1024)?.checked_next_multiple_of(DEFAULT_BUF_SIZE));\n \n     let mut initialized = 0; // Extra initialized bytes from previous loop iteration\n     loop {\n         if buf.len() == buf.capacity() {\n             buf.reserve(32); // buf is full, need more space\n         }\n \n-        let mut read_buf: BorrowedBuf<'_> = buf.spare_capacity_mut().into();\n+        let mut spare = buf.spare_capacity_mut();\n+        if let Some(size) = max_read_size {\n+            let len = cmp::min(spare.len(), size);\n+            spare = &mut spare[..len]\n+        }\n+        let mut read_buf: BorrowedBuf<'_> = spare.into();\n \n         // SAFETY: These bytes were initialized but not filled in the previous loop\n         unsafe {\n@@ -419,6 +432,7 @@ pub(crate) fn default_read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>\n pub(crate) fn default_read_to_string<R: Read + ?Sized>(\n     r: &mut R,\n     buf: &mut String,\n+    size_hint: Option<usize>,\n ) -> Result<usize> {\n     // Note that we do *not* call `r.read_to_end()` here. We are passing\n     // `&mut Vec<u8>` (the raw contents of `buf`) into the `read_to_end`\n@@ -429,7 +443,7 @@ pub(crate) fn default_read_to_string<R: Read + ?Sized>(\n     // To prevent extraneously checking the UTF-8-ness of the entire buffer\n     // we pass it to our hardcoded `default_read_to_end` implementation which\n     // we know is guaranteed to only read data into the end of the buffer.\n-    unsafe { append_to_string(buf, |b| default_read_to_end(r, b)) }\n+    unsafe { append_to_string(buf, |b| default_read_to_end(r, b, size_hint)) }\n }\n \n pub(crate) fn default_read_vectored<F>(read: F, bufs: &mut [IoSliceMut<'_>]) -> Result<usize>\n@@ -709,7 +723,7 @@ pub trait Read {\n     /// [`std::fs::read`]: crate::fs::read\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n-        default_read_to_end(self, buf)\n+        default_read_to_end(self, buf, None)\n     }\n \n     /// Read all bytes until EOF in this source, appending them to `buf`.\n@@ -752,7 +766,7 @@ pub trait Read {\n     /// [`std::fs::read_to_string`]: crate::fs::read_to_string\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {\n-        default_read_to_string(self, buf)\n+        default_read_to_string(self, buf, None)\n     }\n \n     /// Read the exact number of bytes required to fill `buf`."}, {"sha": "6d30f5e6c6c8d6b1afe7bacb3f6a8134cdbddd59", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9de7d9169c6f2208c544a3d4a170719360cae58c/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de7d9169c6f2208c544a3d4a170719360cae58c/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=9de7d9169c6f2208c544a3d4a170719360cae58c", "patch": "@@ -314,7 +314,7 @@ fn bench_read_to_end(b: &mut test::Bencher) {\n     b.iter(|| {\n         let mut lr = repeat(1).take(10000000);\n         let mut vec = Vec::with_capacity(1024);\n-        super::default_read_to_end(&mut lr, &mut vec)\n+        super::default_read_to_end(&mut lr, &mut vec, None)\n     });\n }\n "}, {"sha": "933f75d638ba4f724837f30fad71c84b5a6b258c", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9de7d9169c6f2208c544a3d4a170719360cae58c/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9de7d9169c6f2208c544a3d4a170719360cae58c/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=9de7d9169c6f2208c544a3d4a170719360cae58c", "patch": "@@ -288,6 +288,7 @@\n #![feature(float_next_up_down)]\n #![feature(hasher_prefixfree_extras)]\n #![feature(hashmap_internals)]\n+#![feature(int_roundings)]\n #![feature(ip)]\n #![feature(ip_in_core)]\n #![feature(maybe_uninit_slice)]"}]}