{"sha": "fde45e96b87616bfecb630c748a58856febcad34", "node_id": "C_kwDOAAsO6NoAKGZkZTQ1ZTk2Yjg3NjE2YmZlY2I2MzBjNzQ4YTU4ODU2ZmViY2FkMzQ", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-09-22T21:35:23Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-09-25T23:07:18Z"}, "message": "Remove dependency of `SubPatSet` on `Pat`", "tree": {"sha": "0b3c4b4d070e87294a7078fd8ff8d829686e0333", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b3c4b4d070e87294a7078fd8ff8d829686e0333"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fde45e96b87616bfecb630c748a58856febcad34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fde45e96b87616bfecb630c748a58856febcad34", "html_url": "https://github.com/rust-lang/rust/commit/fde45e96b87616bfecb630c748a58856febcad34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fde45e96b87616bfecb630c748a58856febcad34/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5853399aee2495107659c2de48b18900f17d3d2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5853399aee2495107659c2de48b18900f17d3d2c", "html_url": "https://github.com/rust-lang/rust/commit/5853399aee2495107659c2de48b18900f17d3d2c"}], "stats": {"total": 50, "additions": 23, "deletions": 27}, "files": [{"sha": "92b2ca42b94c333d1347d0c8e66a057d08e8788c", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fde45e96b87616bfecb630c748a58856febcad34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fde45e96b87616bfecb630c748a58856febcad34/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=fde45e96b87616bfecb630c748a58856febcad34", "patch": "@@ -624,27 +624,25 @@ impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n /// `self.is_empty()` we ensure that `self` is `Empty`, and same with `Full`. This is not important\n /// for correctness currently.\n #[derive(Debug, Clone)]\n-enum SubPatSet<'p, 'tcx> {\n+enum SubPatSet {\n     /// The empty set. This means the pattern is unreachable.\n     Empty,\n     /// The set containing the full pattern.\n     Full,\n     /// If the pattern is a pattern with a constructor or a pattern-stack, we store a set for each\n     /// of its subpatterns. Missing entries in the map are implicitly full, because that's the\n     /// common case.\n-    Seq { subpats: FxHashMap<usize, SubPatSet<'p, 'tcx>> },\n+    Seq { subpats: FxHashMap<usize, SubPatSet> },\n     /// If the pattern is an or-pattern, we store a set for each of its alternatives. Missing\n     /// entries in the map are implicitly empty. Note: we always flatten nested or-patterns.\n     Alt {\n-        subpats: FxHashMap<usize, SubPatSet<'p, 'tcx>>,\n-        /// Counts the total number of alternatives in the pattern\n-        alt_count: usize,\n-        /// We keep the pattern around to retrieve spans.\n-        pat: &'p Pat<'tcx>,\n+        subpats: FxHashMap<usize, SubPatSet>,\n+        /// Span of each alternative in the pattern\n+        spans: Vec<Span>,\n     },\n }\n \n-impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n+impl SubPatSet {\n     fn full() -> Self {\n         SubPatSet::Full\n     }\n@@ -670,8 +668,8 @@ impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n             // The whole pattern is reachable only when all its alternatives are.\n             SubPatSet::Seq { subpats } => subpats.values().all(|sub_set| sub_set.is_full()),\n             // The whole or-pattern is reachable only when all its alternatives are.\n-            SubPatSet::Alt { subpats, alt_count, .. } => {\n-                subpats.len() == *alt_count && subpats.values().all(|set| set.is_full())\n+            SubPatSet::Alt { subpats, spans, .. } => {\n+                subpats.len() == spans.len() && subpats.values().all(|set| set.is_full())\n             }\n         }\n     }\n@@ -726,7 +724,7 @@ impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n     /// whole pattern is unreachable) we return `None`.\n     fn list_unreachable_spans(&self) -> Option<Vec<Span>> {\n         /// Panics if `set.is_empty()`.\n-        fn fill_spans(set: &SubPatSet<'_, '_>, spans: &mut Vec<Span>) {\n+        fn fill_spans(set: &SubPatSet, spans: &mut Vec<Span>) {\n             match set {\n                 SubPatSet::Empty => bug!(),\n                 SubPatSet::Full => {}\n@@ -735,13 +733,12 @@ impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n                         fill_spans(sub_set, spans);\n                     }\n                 }\n-                SubPatSet::Alt { subpats, pat, alt_count, .. } => {\n-                    let expanded = expand_or_pat(pat);\n-                    for i in 0..*alt_count {\n+                SubPatSet::Alt { subpats, spans: alt_spans, .. } => {\n+                    for (i, span) in alt_spans.iter().enumerate() {\n                         let sub_set = subpats.get(&i).unwrap_or(&SubPatSet::Empty);\n                         if sub_set.is_empty() {\n                             // Found an unreachable subpattern.\n-                            spans.push(expanded[i].span);\n+                            spans.push(*span);\n                         } else {\n                             fill_spans(sub_set, spans);\n                         }\n@@ -806,7 +803,7 @@ impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n     /// Here `None` would return the full set and `Some(true | false)` would return the set\n     /// containing `false`. After `unsplit_or_pat`, we want the set to contain `None` and `false`.\n     /// This is what this function does.\n-    fn unsplit_or_pat(mut self, alt_id: usize, alt_count: usize, pat: &'p Pat<'tcx>) -> Self {\n+    fn unsplit_or_pat(mut self, alt_id: usize, spans: Vec<Span>) -> Self {\n         use SubPatSet::*;\n         if self.is_empty() {\n             return Empty;\n@@ -822,7 +819,7 @@ impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n         };\n         let mut subpats_first_col = FxHashMap::default();\n         subpats_first_col.insert(alt_id, set_first_col);\n-        let set_first_col = Alt { subpats: subpats_first_col, pat, alt_count };\n+        let set_first_col = Alt { subpats: subpats_first_col, spans };\n \n         let mut subpats = match self {\n             Full => FxHashMap::default(),\n@@ -842,19 +839,19 @@ impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n /// witnesses of non-exhaustiveness when there are any.\n /// Which variant to use is dictated by `ArmType`.\n #[derive(Clone, Debug)]\n-enum Usefulness<'p, 'tcx> {\n+enum Usefulness<'tcx> {\n     /// Carries a set of subpatterns that have been found to be reachable. If empty, this indicates\n     /// the whole pattern is unreachable. If not, this indicates that the pattern is reachable but\n     /// that some sub-patterns may be unreachable (due to or-patterns). In the absence of\n     /// or-patterns this will always be either `Empty` (the whole pattern is unreachable) or `Full`\n     /// (the whole pattern is reachable).\n-    NoWitnesses(SubPatSet<'p, 'tcx>),\n+    NoWitnesses(SubPatSet),\n     /// Carries a list of witnesses of non-exhaustiveness. If empty, indicates that the whole\n     /// pattern is unreachable.\n     WithWitnesses(Vec<Witness<'tcx>>),\n }\n \n-impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n+impl<'tcx> Usefulness<'tcx> {\n     fn new_useful(preference: ArmType) -> Self {\n         match preference {\n             FakeExtraWildcard => WithWitnesses(vec![Witness(vec![])]),\n@@ -889,17 +886,17 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n \n     /// After calculating the usefulness for a branch of an or-pattern, call this to make this\n     /// usefulness mergeable with those from the other branches.\n-    fn unsplit_or_pat(self, alt_id: usize, alt_count: usize, pat: &'p Pat<'tcx>) -> Self {\n+    fn unsplit_or_pat(self, alt_id: usize, spans: Vec<Span>) -> Self {\n         match self {\n-            NoWitnesses(subpats) => NoWitnesses(subpats.unsplit_or_pat(alt_id, alt_count, pat)),\n+            NoWitnesses(subpats) => NoWitnesses(subpats.unsplit_or_pat(alt_id, spans)),\n             WithWitnesses(_) => bug!(),\n         }\n     }\n \n     /// After calculating usefulness after a specialization, call this to reconstruct a usefulness\n     /// that makes sense for the matrix pre-specialization. This new usefulness can then be merged\n     /// with the results of specializing with the other constructors.\n-    fn apply_constructor(\n+    fn apply_constructor<'p>(\n         self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n         matrix: &Matrix<'p, 'tcx>, // used to compute missing ctors\n@@ -1099,7 +1096,7 @@ fn is_useful<'p, 'tcx>(\n     hir_id: HirId,\n     is_under_guard: bool,\n     is_top_level: bool,\n-) -> Usefulness<'p, 'tcx> {\n+) -> Usefulness<'tcx> {\n     debug!(\"matrix,v={:?}{:?}\", matrix, v);\n     let Matrix { patterns: rows, .. } = matrix;\n \n@@ -1129,15 +1126,14 @@ fn is_useful<'p, 'tcx>(\n     let mut ret = Usefulness::new_not_useful(witness_preference);\n     if is_or_pat(v.head()) {\n         debug!(\"expanding or-pattern\");\n-        let v_head = v.head();\n         let vs: Vec<_> = v.expand_or_pat().collect();\n-        let alt_count = vs.len();\n+        let spans: Vec<_> = vs.iter().map(|pat| pat.head().span).collect();\n         // We try each or-pattern branch in turn.\n         let mut matrix = matrix.clone();\n         for (i, v) in vs.into_iter().enumerate() {\n             let usefulness =\n                 is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n-            let usefulness = usefulness.unsplit_or_pat(i, alt_count, v_head);\n+            let usefulness = usefulness.unsplit_or_pat(i, spans.clone());\n             ret.extend(usefulness);\n             // If pattern has a guard don't add it to the matrix.\n             if !is_under_guard {"}]}