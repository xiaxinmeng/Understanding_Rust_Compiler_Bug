{"sha": "b62ef608d751925398ef33d1946acde2eab90d49", "node_id": "C_kwDOAAsO6NoAKGI2MmVmNjA4ZDc1MTkyNTM5OGVmMzNkMTk0NmFjZGUyZWFiOTBkNDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-22T18:42:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-22T18:42:12Z"}, "message": "Auto merge of #9691 - smoelius:lint-lintcheck, r=llogiq\n\nAdd `lintcheck` to packages linted by `dogfood` test\n\nCurrently, `lintcheck` is not checked by the `dogfood` test. I assume that is not intentional. If it is intentional, then this PR can be ignored.\n\nchangelog: Add `lintcheck` to packages linted by `dogfood` test", "tree": {"sha": "dcdb2ddf93d59c7afb842d0af0729209a3b1d681", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcdb2ddf93d59c7afb842d0af0729209a3b1d681"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b62ef608d751925398ef33d1946acde2eab90d49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b62ef608d751925398ef33d1946acde2eab90d49", "html_url": "https://github.com/rust-lang/rust/commit/b62ef608d751925398ef33d1946acde2eab90d49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b62ef608d751925398ef33d1946acde2eab90d49/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b72e451310d65ddf69441a641e2ebd6886c813b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b72e451310d65ddf69441a641e2ebd6886c813b8", "html_url": "https://github.com/rust-lang/rust/commit/b72e451310d65ddf69441a641e2ebd6886c813b8"}, {"sha": "bbee1c9d1f53fc8614fa2dc2737329555bc01b26", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbee1c9d1f53fc8614fa2dc2737329555bc01b26", "html_url": "https://github.com/rust-lang/rust/commit/bbee1c9d1f53fc8614fa2dc2737329555bc01b26"}], "stats": {"total": 158, "additions": 85, "deletions": 73}, "files": [{"sha": "b8824024e6c786bffb527a5a9c49fbcf05e95c57", "filename": "lintcheck/src/config.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b62ef608d751925398ef33d1946acde2eab90d49/lintcheck%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62ef608d751925398ef33d1946acde2eab90d49/lintcheck%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fconfig.rs?ref=b62ef608d751925398ef33d1946acde2eab90d49", "patch": "@@ -73,8 +73,7 @@ impl LintcheckConfig {\n         let sources_toml = env::var(\"LINTCHECK_TOML\").unwrap_or_else(|_| {\n             clap_config\n                 .get_one::<String>(\"crates-toml\")\n-                .map(|s| &**s)\n-                .unwrap_or(\"lintcheck/lintcheck_crates.toml\")\n+                .map_or(\"lintcheck/lintcheck_crates.toml\", |s| &**s)\n                 .into()\n         });\n \n@@ -97,7 +96,7 @@ impl LintcheckConfig {\n             Some(&0) => {\n                 // automatic choice\n                 // Rayon seems to return thread count so half that for core count\n-                (rayon::current_num_threads() / 2) as usize\n+                rayon::current_num_threads() / 2\n             },\n             Some(&threads) => threads,\n             // no -j passed, use a single thread"}, {"sha": "47724a2fedb0072c98ae11ec9149d8c7b0152f37", "filename": "lintcheck/src/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b62ef608d751925398ef33d1946acde2eab90d49/lintcheck%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62ef608d751925398ef33d1946acde2eab90d49/lintcheck%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fdriver.rs?ref=b62ef608d751925398ef33d1946acde2eab90d49", "patch": "@@ -5,7 +5,7 @@ use std::net::TcpStream;\n use std::process::{self, Command, Stdio};\n use std::{env, mem};\n \n-/// 1. Sends [DriverInfo] to the [crate::recursive::LintcheckServer] running on `addr`\n+/// 1. Sends [`DriverInfo`] to the [`crate::recursive::LintcheckServer`] running on `addr`\n /// 2. Receives [bool] from the server, if `false` returns `None`\n /// 3. Otherwise sends the stderr of running `clippy-driver` to the server\n fn run_clippy(addr: &str) -> Option<i32> {"}, {"sha": "54c1b80c42dbf0fd320aa06677770d42db78ddf9", "filename": "lintcheck/src/main.rs", "status": "modified", "additions": 70, "deletions": 64, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b62ef608d751925398ef33d1946acde2eab90d49/lintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62ef608d751925398ef33d1946acde2eab90d49/lintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fmain.rs?ref=b62ef608d751925398ef33d1946acde2eab90d49", "patch": "@@ -116,12 +116,13 @@ impl ClippyWarning {\n \n         let span = diag.spans.into_iter().find(|span| span.is_primary)?;\n \n-        let file = match Path::new(&span.file_name).strip_prefix(env!(\"CARGO_HOME\")) {\n-            Ok(stripped) => format!(\"$CARGO_HOME/{}\", stripped.display()),\n-            Err(_) => format!(\n+        let file = if let Ok(stripped) = Path::new(&span.file_name).strip_prefix(env!(\"CARGO_HOME\")) {\n+            format!(\"$CARGO_HOME/{}\", stripped.display())\n+        } else {\n+            format!(\n                 \"target/lintcheck/sources/{}-{}/{}\",\n                 crate_name, crate_version, span.file_name\n-            ),\n+            )\n         };\n \n         Some(Self {\n@@ -144,28 +145,29 @@ impl ClippyWarning {\n             }\n \n             let mut output = String::from(\"| \");\n-            let _ = write!(output, \"[`{}`]({}#L{})\", file_with_pos, file, self.line);\n+            let _ = write!(output, \"[`{file_with_pos}`]({file}#L{})\", self.line);\n             let _ = write!(output, r#\" | `{:<50}` | \"{}\" |\"#, self.lint_type, self.message);\n             output.push('\\n');\n             output\n         } else {\n-            format!(\"{} {} \\\"{}\\\"\\n\", file_with_pos, self.lint_type, self.message)\n+            format!(\"{file_with_pos} {} \\\"{}\\\"\\n\", self.lint_type, self.message)\n         }\n     }\n }\n \n+#[allow(clippy::result_large_err)]\n fn get(path: &str) -> Result<ureq::Response, ureq::Error> {\n     const MAX_RETRIES: u8 = 4;\n     let mut retries = 0;\n     loop {\n         match ureq::get(path).call() {\n             Ok(res) => return Ok(res),\n             Err(e) if retries >= MAX_RETRIES => return Err(e),\n-            Err(ureq::Error::Transport(e)) => eprintln!(\"Error: {}\", e),\n+            Err(ureq::Error::Transport(e)) => eprintln!(\"Error: {e}\"),\n             Err(e) => return Err(e),\n         }\n-        eprintln!(\"retrying in {} seconds...\", retries);\n-        thread::sleep(Duration::from_secs(retries as u64));\n+        eprintln!(\"retrying in {retries} seconds...\");\n+        thread::sleep(Duration::from_secs(u64::from(retries)));\n         retries += 1;\n     }\n }\n@@ -181,11 +183,11 @@ impl CrateSource {\n                 let krate_download_dir = PathBuf::from(LINTCHECK_DOWNLOADS);\n \n                 // url to download the crate from crates.io\n-                let url = format!(\"https://crates.io/api/v1/crates/{}/{}/download\", name, version);\n-                println!(\"Downloading and extracting {} {} from {}\", name, version, url);\n+                let url = format!(\"https://crates.io/api/v1/crates/{name}/{version}/download\");\n+                println!(\"Downloading and extracting {name} {version} from {url}\");\n                 create_dirs(&krate_download_dir, &extract_dir);\n \n-                let krate_file_path = krate_download_dir.join(format!(\"{}-{}.crate.tar.gz\", name, version));\n+                let krate_file_path = krate_download_dir.join(format!(\"{name}-{version}.crate.tar.gz\"));\n                 // don't download/extract if we already have done so\n                 if !krate_file_path.is_file() {\n                     // create a file path to download and write the crate data into\n@@ -205,7 +207,7 @@ impl CrateSource {\n                 Crate {\n                     version: version.clone(),\n                     name: name.clone(),\n-                    path: extract_dir.join(format!(\"{}-{}/\", name, version)),\n+                    path: extract_dir.join(format!(\"{name}-{version}/\")),\n                     options: options.clone(),\n                 }\n             },\n@@ -218,12 +220,12 @@ impl CrateSource {\n                 let repo_path = {\n                     let mut repo_path = PathBuf::from(LINTCHECK_SOURCES);\n                     // add a -git suffix in case we have the same crate from crates.io and a git repo\n-                    repo_path.push(format!(\"{}-git\", name));\n+                    repo_path.push(format!(\"{name}-git\"));\n                     repo_path\n                 };\n                 // clone the repo if we have not done so\n                 if !repo_path.is_dir() {\n-                    println!(\"Cloning {} and checking out {}\", url, commit);\n+                    println!(\"Cloning {url} and checking out {commit}\");\n                     if !Command::new(\"git\")\n                         .arg(\"clone\")\n                         .arg(url)\n@@ -232,7 +234,7 @@ impl CrateSource {\n                         .expect(\"Failed to clone git repo!\")\n                         .success()\n                     {\n-                        eprintln!(\"Failed to clone {} into {}\", url, repo_path.display())\n+                        eprintln!(\"Failed to clone {url} into {}\", repo_path.display());\n                     }\n                 }\n                 // check out the commit/branch/whatever\n@@ -245,7 +247,7 @@ impl CrateSource {\n                     .expect(\"Failed to check out commit\")\n                     .success()\n                 {\n-                    eprintln!(\"Failed to checkout {} of repo at {}\", commit, repo_path.display())\n+                    eprintln!(\"Failed to checkout {commit} of repo at {}\", repo_path.display());\n                 }\n \n                 Crate {\n@@ -256,22 +258,22 @@ impl CrateSource {\n                 }\n             },\n             CrateSource::Path { name, path, options } => {\n+                fn is_cache_dir(entry: &DirEntry) -> bool {\n+                    std::fs::read(entry.path().join(\"CACHEDIR.TAG\"))\n+                        .map(|x| x.starts_with(b\"Signature: 8a477f597d28d172789f06886806bc55\"))\n+                        .unwrap_or(false)\n+                }\n+\n                 // copy path into the dest_crate_root but skip directories that contain a CACHEDIR.TAG file.\n                 // The target/ directory contains a CACHEDIR.TAG file so it is the most commonly skipped directory\n                 // as a result of this filter.\n                 let dest_crate_root = PathBuf::from(LINTCHECK_SOURCES).join(name);\n                 if dest_crate_root.exists() {\n-                    println!(\"Deleting existing directory at {:?}\", dest_crate_root);\n+                    println!(\"Deleting existing directory at {dest_crate_root:?}\");\n                     std::fs::remove_dir_all(&dest_crate_root).unwrap();\n                 }\n \n-                println!(\"Copying {:?} to {:?}\", path, dest_crate_root);\n-\n-                fn is_cache_dir(entry: &DirEntry) -> bool {\n-                    std::fs::read(entry.path().join(\"CACHEDIR.TAG\"))\n-                        .map(|x| x.starts_with(b\"Signature: 8a477f597d28d172789f06886806bc55\"))\n-                        .unwrap_or(false)\n-                }\n+                println!(\"Copying {path:?} to {dest_crate_root:?}\");\n \n                 for entry in WalkDir::new(path).into_iter().filter_entry(|e| !is_cache_dir(e)) {\n                     let entry = entry.unwrap();\n@@ -301,6 +303,7 @@ impl CrateSource {\n impl Crate {\n     /// Run `cargo clippy` on the `Crate` and collect and return all the lint warnings that clippy\n     /// issued\n+    #[allow(clippy::too_many_arguments)]\n     fn run_clippy_lints(\n         &self,\n         cargo_clippy_path: &Path,\n@@ -345,14 +348,14 @@ impl Crate {\n                 clippy_args.push(opt);\n             }\n         } else {\n-            clippy_args.extend([\"-Wclippy::pedantic\", \"-Wclippy::cargo\"])\n+            clippy_args.extend([\"-Wclippy::pedantic\", \"-Wclippy::cargo\"]);\n         }\n \n         if lint_filter.is_empty() {\n             clippy_args.push(\"--cap-lints=warn\");\n         } else {\n             clippy_args.push(\"--cap-lints=allow\");\n-            clippy_args.extend(lint_filter.iter().map(|filter| filter.as_str()))\n+            clippy_args.extend(lint_filter.iter().map(std::string::String::as_str));\n         }\n \n         if let Some(server) = server {\n@@ -389,10 +392,7 @@ impl Crate {\n \n         let all_output = Command::new(&cargo_clippy_path)\n             // use the looping index to create individual target dirs\n-            .env(\n-                \"CARGO_TARGET_DIR\",\n-                shared_target_dir.join(format!(\"_{:?}\", thread_index)),\n-            )\n+            .env(\"CARGO_TARGET_DIR\", shared_target_dir.join(format!(\"_{thread_index:?}\")))\n             .args(&cargo_clippy_args)\n             .current_dir(&self.path)\n             .output()\n@@ -422,8 +422,8 @@ impl Crate {\n             {\n                 let subcrate = &stderr[63..];\n                 println!(\n-                    \"ERROR: failed to apply some suggetion to {} / to (sub)crate {}\",\n-                    self.name, subcrate\n+                    \"ERROR: failed to apply some suggetion to {} / to (sub)crate {subcrate}\",\n+                    self.name\n                 );\n             }\n             // fast path, we don't need the warnings anyway\n@@ -459,14 +459,14 @@ fn read_crates(toml_path: &Path) -> (Vec<CrateSource>, RecursiveOptions) {\n     let toml_content: String =\n         std::fs::read_to_string(toml_path).unwrap_or_else(|_| panic!(\"Failed to read {}\", toml_path.display()));\n     let crate_list: SourceList =\n-        toml::from_str(&toml_content).unwrap_or_else(|e| panic!(\"Failed to parse {}: \\n{}\", toml_path.display(), e));\n+        toml::from_str(&toml_content).unwrap_or_else(|e| panic!(\"Failed to parse {}: \\n{e}\", toml_path.display()));\n     // parse the hashmap of the toml file into a list of crates\n     let tomlcrates: Vec<TomlCrate> = crate_list.crates.into_values().collect();\n \n     // flatten TomlCrates into CrateSources (one TomlCrates may represent several versions of a crate =>\n     // multiple Cratesources)\n     let mut crate_sources = Vec::new();\n-    tomlcrates.into_iter().for_each(|tk| {\n+    for tk in tomlcrates {\n         if let Some(ref path) = tk.path {\n             crate_sources.push(CrateSource::Path {\n                 name: tk.name.clone(),\n@@ -475,13 +475,13 @@ fn read_crates(toml_path: &Path) -> (Vec<CrateSource>, RecursiveOptions) {\n             });\n         } else if let Some(ref versions) = tk.versions {\n             // if we have multiple versions, save each one\n-            versions.iter().for_each(|ver| {\n+            for ver in versions.iter() {\n                 crate_sources.push(CrateSource::CratesIo {\n                     name: tk.name.clone(),\n                     version: ver.to_string(),\n                     options: tk.options.clone(),\n                 });\n-            })\n+            }\n         } else if tk.git_url.is_some() && tk.git_hash.is_some() {\n             // otherwise, we should have a git source\n             crate_sources.push(CrateSource::Git {\n@@ -498,16 +498,19 @@ fn read_crates(toml_path: &Path) -> (Vec<CrateSource>, RecursiveOptions) {\n         if tk.versions.is_some() && (tk.git_url.is_some() || tk.git_hash.is_some())\n             || tk.git_hash.is_some() != tk.git_url.is_some()\n         {\n-            eprintln!(\"tomlkrate: {:?}\", tk);\n-            if tk.git_hash.is_some() != tk.git_url.is_some() {\n-                panic!(\"Error: Encountered TomlCrate with only one of git_hash and git_url!\");\n-            }\n-            if tk.path.is_some() && (tk.git_hash.is_some() || tk.versions.is_some()) {\n-                panic!(\"Error: TomlCrate can only have one of 'git_.*', 'version' or 'path' fields\");\n-            }\n+            eprintln!(\"tomlkrate: {tk:?}\");\n+            assert_eq!(\n+                tk.git_hash.is_some(),\n+                tk.git_url.is_some(),\n+                \"Error: Encountered TomlCrate with only one of git_hash and git_url!\"\n+            );\n+            assert!(\n+                tk.path.is_none() || (tk.git_hash.is_none() && tk.versions.is_none()),\n+                \"Error: TomlCrate can only have one of 'git_.*', 'version' or 'path' fields\"\n+            );\n             unreachable!(\"Failed to translate TomlCrate into CrateSource!\");\n         }\n-    });\n+    }\n     // sort the crates\n     crate_sources.sort();\n \n@@ -526,13 +529,13 @@ fn gather_stats(clippy_warnings: &[ClippyWarning]) -> (String, HashMap<&String,\n     let mut stats: Vec<(&&String, &usize)> = counter.iter().map(|(lint, count)| (lint, count)).collect();\n     // sort by \"000{count} {clippy::lintname}\"\n     // to not have a lint with 200 and 2 warnings take the same spot\n-    stats.sort_by_key(|(lint, count)| format!(\"{:0>4}, {}\", count, lint));\n+    stats.sort_by_key(|(lint, count)| format!(\"{count:0>4}, {lint}\"));\n \n     let mut header = String::from(\"| lint                                               | count |\\n\");\n     header.push_str(\"| -------------------------------------------------- | ----- |\\n\");\n     let stats_string = stats\n         .iter()\n-        .map(|(lint, count)| format!(\"| {:<50} |  {:>4} |\\n\", lint, count))\n+        .map(|(lint, count)| format!(\"| {lint:<50} |  {count:>4} |\\n\"))\n         .fold(header, |mut table, line| {\n             table.push_str(&line);\n             table\n@@ -569,6 +572,7 @@ fn lintcheck_needs_rerun(lintcheck_logs_path: &Path, paths: [&Path; 2]) -> bool\n     logs_modified < clippy_modified\n }\n \n+#[allow(clippy::too_many_lines)]\n fn main() {\n     // We're being executed as a `RUSTC_WRAPPER` as part of `--recursive`\n     if let Ok(addr) = env::var(\"LINTCHECK_SERVER\") {\n@@ -674,7 +678,7 @@ fn main() {\n         .unwrap();\n \n     let server = config.recursive.then(|| {\n-        let _ = fs::remove_dir_all(\"target/lintcheck/shared_target_dir/recursive\");\n+        fs::remove_dir_all(\"target/lintcheck/shared_target_dir/recursive\").unwrap_or_default();\n \n         LintcheckServer::spawn(recursive_options)\n     });\n@@ -730,8 +734,8 @@ fn main() {\n     }\n     write!(text, \"{}\", all_msgs.join(\"\")).unwrap();\n     text.push_str(\"\\n\\n### ICEs:\\n\");\n-    for (cratename, msg) in ices.iter() {\n-        let _ = write!(text, \"{}: '{}'\", cratename, msg);\n+    for (cratename, msg) in &ices {\n+        let _ = write!(text, \"{cratename}: '{msg}'\");\n     }\n \n     println!(\"Writing logs to {}\", config.lintcheck_results_path.display());\n@@ -783,10 +787,10 @@ fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, us\n     let mut new_stats_deduped = new_stats;\n \n     // remove duplicates from both hashmaps\n-    same_in_both_hashmaps.iter().for_each(|(k, v)| {\n+    for (k, v) in &same_in_both_hashmaps {\n         assert!(old_stats_deduped.remove(k) == Some(*v));\n         assert!(new_stats_deduped.remove(k) == Some(*v));\n-    });\n+    }\n \n     println!(\"\\nStats:\");\n \n@@ -795,7 +799,7 @@ fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, us\n         .iter()\n         .filter(|(new_key, _)| old_stats_deduped.get::<str>(new_key).is_none())\n         .for_each(|(new_key, new_value)| {\n-            println!(\"{} 0 => {}\", new_key, new_value);\n+            println!(\"{new_key} 0 => {new_value}\");\n         });\n \n     // list all changed counts (key is in both maps but value differs)\n@@ -804,7 +808,7 @@ fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, us\n         .filter(|(new_key, _new_val)| old_stats_deduped.get::<str>(new_key).is_some())\n         .for_each(|(new_key, new_val)| {\n             let old_val = old_stats_deduped.get::<str>(new_key).unwrap();\n-            println!(\"{} {} => {}\", new_key, old_val, new_val);\n+            println!(\"{new_key} {old_val} => {new_val}\");\n         });\n \n     // list all gone counts (key is in old status but not in new stats)\n@@ -813,7 +817,7 @@ fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, us\n         .filter(|(old_key, _)| new_stats_deduped.get::<&String>(old_key).is_none())\n         .filter(|(old_key, _)| lint_filter.is_empty() || lint_filter.contains(old_key))\n         .for_each(|(old_key, old_value)| {\n-            println!(\"{} {} => 0\", old_key, old_value);\n+            println!(\"{old_key} {old_value} => 0\");\n         });\n }\n \n@@ -824,19 +828,21 @@ fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, us\n /// This function panics if creating one of the dirs fails.\n fn create_dirs(krate_download_dir: &Path, extract_dir: &Path) {\n     std::fs::create_dir(\"target/lintcheck/\").unwrap_or_else(|err| {\n-        if err.kind() != ErrorKind::AlreadyExists {\n-            panic!(\"cannot create lintcheck target dir\");\n-        }\n+        assert_eq!(\n+            err.kind(),\n+            ErrorKind::AlreadyExists,\n+            \"cannot create lintcheck target dir\"\n+        );\n     });\n     std::fs::create_dir(krate_download_dir).unwrap_or_else(|err| {\n-        if err.kind() != ErrorKind::AlreadyExists {\n-            panic!(\"cannot create crate download dir\");\n-        }\n+        assert_eq!(err.kind(), ErrorKind::AlreadyExists, \"cannot create crate download dir\");\n     });\n     std::fs::create_dir(extract_dir).unwrap_or_else(|err| {\n-        if err.kind() != ErrorKind::AlreadyExists {\n-            panic!(\"cannot create crate extraction dir\");\n-        }\n+        assert_eq!(\n+            err.kind(),\n+            ErrorKind::AlreadyExists,\n+            \"cannot create crate extraction dir\"\n+        );\n     });\n }\n "}, {"sha": "49072e65192f21c151669b6fad5d5f16d377e8a3", "filename": "lintcheck/src/recursive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b62ef608d751925398ef33d1946acde2eab90d49/lintcheck%2Fsrc%2Frecursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62ef608d751925398ef33d1946acde2eab90d49/lintcheck%2Fsrc%2Frecursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Frecursive.rs?ref=b62ef608d751925398ef33d1946acde2eab90d49", "patch": "@@ -1,7 +1,7 @@\n //! In `--recursive` mode we set the `lintcheck` binary as the `RUSTC_WRAPPER` of `cargo check`,\n-//! this allows [crate::driver] to be run for every dependency. The driver connects to\n-//! [LintcheckServer] to ask if it should be skipped, and if not sends the stderr of running clippy\n-//! on the crate to the server\n+//! this allows [`crate::driver`] to be run for every dependency. The driver connects to\n+//! [`LintcheckServer`] to ask if it should be skipped, and if not sends the stderr of running\n+//! clippy on the crate to the server\n \n use crate::ClippyWarning;\n use crate::RecursiveOptions;\n@@ -109,8 +109,8 @@ impl LintcheckServer {\n \n         Self {\n             local_addr,\n-            sender,\n             receiver,\n+            sender,\n         }\n     }\n "}, {"sha": "6d0022f7a5ccfe56f4c5990a4c0f5258fbd95bf2", "filename": "tests/dogfood.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b62ef608d751925398ef33d1946acde2eab90d49/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62ef608d751925398ef33d1946acde2eab90d49/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=b62ef608d751925398ef33d1946acde2eab90d49", "patch": "@@ -20,7 +20,14 @@ fn dogfood_clippy() {\n     }\n \n     // \"\" is the root package\n-    for package in &[\"\", \"clippy_dev\", \"clippy_lints\", \"clippy_utils\", \"rustc_tools_util\"] {\n+    for package in &[\n+        \"\",\n+        \"clippy_dev\",\n+        \"clippy_lints\",\n+        \"clippy_utils\",\n+        \"lintcheck\",\n+        \"rustc_tools_util\",\n+    ] {\n         run_clippy_for_package(package, &[\"-D\", \"clippy::all\", \"-D\", \"clippy::pedantic\"]);\n     }\n }"}]}