{"sha": "1ff117e987be82e9cff59350fd1810ebe21f8b26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmZjExN2U5ODdiZTgyZTljZmY1OTM1MGZkMTgxMGViZTIxZjhiMjY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-04-11T23:04:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-11T23:04:10Z"}, "message": "Rollup merge of #84101 - jyn514:early-pass, r=Manishearth\n\nrustdoc: Move crate loader to collect_intra_doc_links::early\n\nThis groups the similar code together, and also allows making most of collect_intra_doc_links private again.\n\nThis builds on https://github.com/rust-lang/rust/pull/84066, but it wouldn't be too hard to base it off master if you want this to land first.\nHelps with https://github.com/rust-lang/rust/issues/83761.\n\nr? manishearth\n\nFixes https://github.com/rust-lang/rust/issues/84046", "tree": {"sha": "0978047d02b1e5b2c390a00ef326db1d4264cfa6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0978047d02b1e5b2c390a00ef326db1d4264cfa6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ff117e987be82e9cff59350fd1810ebe21f8b26", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgc4BqCRBK7hj4Ov3rIwAAdHIIABwsiVdyHBdIfvx3vMXvGQ/+\n9LyPTGJ9BzXw/cjtYrp/J5YGpgQSg3Lal2ElRaEgIyt2yBr03hWAC3owMzJIP8XG\nCL4lxIBt4PBbrDi3ggy9fpJjLZ0qtQCBtAAfcMgDEOYRL7opUKl7WqqxneLUzEAl\n6O70/mJ4N36WiTGEQ1+gY175ePX3CiFPu6jJQMorNcWDaO9Ice/ZlhZK4pWYQdtO\nCKfU3bR3dp/HRuJF/Yb9kS9aIZS/FzGSNknsMvXBfvO6fBK0YpT1cA0BWIT26vbl\nXPnxnw3X+e/l5AoOwWPoT1ZOyeGLEphvQUMmPAM3zceMrCYXD9SkusnWgsL040U=\n=1Guc\n-----END PGP SIGNATURE-----\n", "payload": "tree 0978047d02b1e5b2c390a00ef326db1d4264cfa6\nparent 3ea5a9f301c6553d3c08774af2a1fd7a7e38fadc\nparent cba50731a6998ec5a53932d6f4b891877e01a9e3\nauthor Dylan DPC <dylan.dpc@gmail.com> 1618182250 +0200\ncommitter GitHub <noreply@github.com> 1618182250 +0200\n\nRollup merge of #84101 - jyn514:early-pass, r=Manishearth\n\nrustdoc: Move crate loader to collect_intra_doc_links::early\n\nThis groups the similar code together, and also allows making most of collect_intra_doc_links private again.\n\nThis builds on https://github.com/rust-lang/rust/pull/84066, but it wouldn't be too hard to base it off master if you want this to land first.\nHelps with https://github.com/rust-lang/rust/issues/83761.\n\nr? manishearth\n\nFixes https://github.com/rust-lang/rust/issues/84046\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ff117e987be82e9cff59350fd1810ebe21f8b26", "html_url": "https://github.com/rust-lang/rust/commit/1ff117e987be82e9cff59350fd1810ebe21f8b26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ff117e987be82e9cff59350fd1810ebe21f8b26/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ea5a9f301c6553d3c08774af2a1fd7a7e38fadc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ea5a9f301c6553d3c08774af2a1fd7a7e38fadc", "html_url": "https://github.com/rust-lang/rust/commit/3ea5a9f301c6553d3c08774af2a1fd7a7e38fadc"}, {"sha": "cba50731a6998ec5a53932d6f4b891877e01a9e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cba50731a6998ec5a53932d6f4b891877e01a9e3", "html_url": "https://github.com/rust-lang/rust/commit/cba50731a6998ec5a53932d6f4b891877e01a9e3"}], "stats": {"total": 353, "additions": 220, "deletions": 133}, "files": [{"sha": "be7bff1a29c2b4d51e45cbc9afc3b4007e8c8f36", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 51, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1ff117e987be82e9cff59350fd1810ebe21f8b26/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff117e987be82e9cff59350fd1810ebe21f8b26/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=1ff117e987be82e9cff59350fd1810ebe21f8b26", "patch": "@@ -5,8 +5,8 @@ use rustc_driver::abort_on_err;\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n use rustc_feature::UnstableFeatures;\n-use rustc_hir::def::{Namespace::TypeNS, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def::Res;\n+use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n use rustc_hir::HirId;\n use rustc_hir::{\n     intravisit::{self, NestedVisitorMap, Visitor},\n@@ -356,55 +356,7 @@ crate fn create_resolver<'a>(\n     let (krate, resolver, _) = &*parts;\n     let resolver = resolver.borrow().clone();\n \n-    // Letting the resolver escape at the end of the function leads to inconsistencies between the\n-    // crates the TyCtxt sees and the resolver sees (because the resolver could load more crates\n-    // after escaping). Hopefully `IntraLinkCrateLoader` gets all the crates we need ...\n-    struct IntraLinkCrateLoader {\n-        current_mod: DefId,\n-        resolver: Rc<RefCell<interface::BoxedResolver>>,\n-    }\n-    impl ast::visit::Visitor<'_> for IntraLinkCrateLoader {\n-        fn visit_attribute(&mut self, attr: &ast::Attribute) {\n-            use crate::html::markdown::{markdown_links, MarkdownLink};\n-            use crate::passes::collect_intra_doc_links::Disambiguator;\n-\n-            if let Some(doc) = attr.doc_str() {\n-                for MarkdownLink { link, .. } in markdown_links(&doc.as_str()) {\n-                    // FIXME: this misses a *lot* of the preprocessing done in collect_intra_doc_links\n-                    // I think most of it shouldn't be necessary since we only need the crate prefix?\n-                    let path_str = match Disambiguator::from_str(&link) {\n-                        Ok(x) => x.map_or(link.as_str(), |(_, p)| p),\n-                        Err(_) => continue,\n-                    };\n-                    self.resolver.borrow_mut().access(|resolver| {\n-                        let _ = resolver.resolve_str_path_error(\n-                            attr.span,\n-                            path_str,\n-                            TypeNS,\n-                            self.current_mod,\n-                        );\n-                    });\n-                }\n-            }\n-            ast::visit::walk_attribute(self, attr);\n-        }\n-\n-        fn visit_item(&mut self, item: &ast::Item) {\n-            use rustc_ast_lowering::ResolverAstLowering;\n-\n-            if let ast::ItemKind::Mod(..) = item.kind {\n-                let new_mod =\n-                    self.resolver.borrow_mut().access(|resolver| resolver.local_def_id(item.id));\n-                let old_mod = mem::replace(&mut self.current_mod, new_mod.to_def_id());\n-                ast::visit::walk_item(self, item);\n-                self.current_mod = old_mod;\n-            } else {\n-                ast::visit::walk_item(self, item);\n-            }\n-        }\n-    }\n-    let crate_id = LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id();\n-    let mut loader = IntraLinkCrateLoader { current_mod: crate_id, resolver };\n+    let mut loader = crate::passes::collect_intra_doc_links::IntraLinkCrateLoader::new(resolver);\n     ast::visit::walk_crate(&mut loader, krate);\n \n     loader.resolver"}, {"sha": "6342110adfe0bf0ca77fd07647f5f5b0e7e7e6cd", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 140, "deletions": 81, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/1ff117e987be82e9cff59350fd1810ebe21f8b26/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff117e987be82e9cff59350fd1810ebe21f8b26/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=1ff117e987be82e9cff59350fd1810ebe21f8b26", "patch": "@@ -39,13 +39,16 @@ use crate::passes::Pass;\n \n use super::span_of_attrs;\n \n+mod early;\n+crate use early::IntraLinkCrateLoader;\n+\n crate const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n     name: \"collect-intra-doc-links\",\n     run: collect_intra_doc_links,\n     description: \"resolves intra-doc links\",\n };\n \n-crate fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     LinkCollector {\n         cx,\n         mod_ids: Vec::new(),\n@@ -892,6 +895,117 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     }\n }\n \n+enum PreprocessingError<'a> {\n+    Anchor(AnchorFailure),\n+    Disambiguator(Range<usize>, String),\n+    Resolution(ResolutionFailure<'a>, String, Option<Disambiguator>),\n+}\n+\n+impl From<AnchorFailure> for PreprocessingError<'_> {\n+    fn from(err: AnchorFailure) -> Self {\n+        Self::Anchor(err)\n+    }\n+}\n+\n+struct PreprocessingInfo {\n+    path_str: String,\n+    disambiguator: Option<Disambiguator>,\n+    extra_fragment: Option<String>,\n+    link_text: String,\n+}\n+\n+/// Returns:\n+/// - `None` if the link should be ignored.\n+/// - `Some(Err)` if the link should emit an error\n+/// - `Some(Ok)` if the link is valid\n+///\n+/// `link_buffer` is needed for lifetime reasons; it will always be overwritten and the contents ignored.\n+fn preprocess_link<'a>(\n+    ori_link: &'a MarkdownLink,\n+) -> Option<Result<PreprocessingInfo, PreprocessingError<'a>>> {\n+    // [] is mostly likely not supposed to be a link\n+    if ori_link.link.is_empty() {\n+        return None;\n+    }\n+\n+    // Bail early for real links.\n+    if ori_link.link.contains('/') {\n+        return None;\n+    }\n+\n+    let stripped = ori_link.link.replace(\"`\", \"\");\n+    let mut parts = stripped.split('#');\n+\n+    let link = parts.next().unwrap();\n+    if link.trim().is_empty() {\n+        // This is an anchor to an element of the current page, nothing to do in here!\n+        return None;\n+    }\n+    let extra_fragment = parts.next();\n+    if parts.next().is_some() {\n+        // A valid link can't have multiple #'s\n+        return Some(Err(AnchorFailure::MultipleAnchors.into()));\n+    }\n+\n+    // Parse and strip the disambiguator from the link, if present.\n+    let (path_str, disambiguator) = match Disambiguator::from_str(&link) {\n+        Ok(Some((d, path))) => (path.trim(), Some(d)),\n+        Ok(None) => (link.trim(), None),\n+        Err((err_msg, relative_range)) => {\n+            // Only report error if we would not have ignored this link. See issue #83859.\n+            if !should_ignore_link_with_disambiguators(link) {\n+                let no_backticks_range = range_between_backticks(&ori_link);\n+                let disambiguator_range = (no_backticks_range.start + relative_range.start)\n+                    ..(no_backticks_range.start + relative_range.end);\n+                return Some(Err(PreprocessingError::Disambiguator(disambiguator_range, err_msg)));\n+            } else {\n+                return None;\n+            }\n+        }\n+    };\n+\n+    if should_ignore_link(path_str) {\n+        return None;\n+    }\n+\n+    // We stripped `()` and `!` when parsing the disambiguator.\n+    // Add them back to be displayed, but not prefix disambiguators.\n+    let link_text =\n+        disambiguator.map(|d| d.display_for(path_str)).unwrap_or_else(|| path_str.to_owned());\n+\n+    // Strip generics from the path.\n+    let path_str = if path_str.contains(['<', '>'].as_slice()) {\n+        match strip_generics_from_path(&path_str) {\n+            Ok(path) => path,\n+            Err(err_kind) => {\n+                debug!(\"link has malformed generics: {}\", path_str);\n+                return Some(Err(PreprocessingError::Resolution(\n+                    err_kind,\n+                    path_str.to_owned(),\n+                    disambiguator,\n+                )));\n+            }\n+        }\n+    } else {\n+        path_str.to_owned()\n+    };\n+\n+    // Sanity check to make sure we don't have any angle brackets after stripping generics.\n+    assert!(!path_str.contains(['<', '>'].as_slice()));\n+\n+    // The link is not an intra-doc link if it still contains spaces after stripping generics.\n+    if path_str.contains(' ') {\n+        return None;\n+    }\n+\n+    Some(Ok(PreprocessingInfo {\n+        path_str,\n+        disambiguator,\n+        extra_fragment: extra_fragment.map(String::from),\n+        link_text,\n+    }))\n+}\n+\n impl LinkCollector<'_, '_> {\n     /// This is the entry point for resolving an intra-doc link.\n     ///\n@@ -907,64 +1021,36 @@ impl LinkCollector<'_, '_> {\n     ) -> Option<ItemLink> {\n         trace!(\"considering link '{}'\", ori_link.link);\n \n-        // Bail early for real links.\n-        if ori_link.link.contains('/') {\n-            return None;\n-        }\n-\n-        // [] is mostly likely not supposed to be a link\n-        if ori_link.link.is_empty() {\n-            return None;\n-        }\n-\n         let diag_info = DiagnosticInfo {\n             item,\n             dox,\n             ori_link: &ori_link.link,\n             link_range: ori_link.range.clone(),\n         };\n \n-        let link = ori_link.link.replace(\"`\", \"\");\n-        let no_backticks_range = range_between_backticks(&ori_link);\n-        let parts = link.split('#').collect::<Vec<_>>();\n-        let (link, extra_fragment) = if parts.len() > 2 {\n-            // A valid link can't have multiple #'s\n-            anchor_failure(self.cx, diag_info, AnchorFailure::MultipleAnchors);\n-            return None;\n-        } else if parts.len() == 2 {\n-            if parts[0].trim().is_empty() {\n-                // This is an anchor to an element of the current page, nothing to do in here!\n-                return None;\n-            }\n-            (parts[0], Some(parts[1].to_owned()))\n-        } else {\n-            (parts[0], None)\n-        };\n-\n-        // Parse and strip the disambiguator from the link, if present.\n-        let (mut path_str, disambiguator) = match Disambiguator::from_str(&link) {\n-            Ok(Some((d, path))) => (path.trim(), Some(d)),\n-            Ok(None) => (link.trim(), None),\n-            Err((err_msg, relative_range)) => {\n-                if !should_ignore_link_with_disambiguators(link) {\n-                    // Only report error if we would not have ignored this link.\n-                    // See issue #83859.\n-                    let disambiguator_range = (no_backticks_range.start + relative_range.start)\n-                        ..(no_backticks_range.start + relative_range.end);\n-                    disambiguator_error(self.cx, diag_info, disambiguator_range, &err_msg);\n+        let PreprocessingInfo { path_str, disambiguator, extra_fragment, link_text } =\n+            match preprocess_link(&ori_link)? {\n+                Ok(x) => x,\n+                Err(err) => {\n+                    match err {\n+                        PreprocessingError::Anchor(err) => anchor_failure(self.cx, diag_info, err),\n+                        PreprocessingError::Disambiguator(range, msg) => {\n+                            disambiguator_error(self.cx, diag_info, range, &msg)\n+                        }\n+                        PreprocessingError::Resolution(err, path_str, disambiguator) => {\n+                            resolution_failure(\n+                                self,\n+                                diag_info,\n+                                &path_str,\n+                                disambiguator,\n+                                smallvec![err],\n+                            );\n+                        }\n+                    }\n+                    return None;\n                 }\n-                return None;\n-            }\n-        };\n-\n-        if should_ignore_link(path_str) {\n-            return None;\n-        }\n-\n-        // We stripped `()` and `!` when parsing the disambiguator.\n-        // Add them back to be displayed, but not prefix disambiguators.\n-        let link_text =\n-            disambiguator.map(|d| d.display_for(path_str)).unwrap_or_else(|| path_str.to_owned());\n+            };\n+        let mut path_str = &*path_str;\n \n         // In order to correctly resolve intra-doc links we need to\n         // pick a base AST node to work from.  If the documentation for\n@@ -1029,39 +1115,12 @@ impl LinkCollector<'_, '_> {\n             module_id = DefId { krate, index: CRATE_DEF_INDEX };\n         }\n \n-        // Strip generics from the path.\n-        let stripped_path_string;\n-        if path_str.contains(['<', '>'].as_slice()) {\n-            stripped_path_string = match strip_generics_from_path(path_str) {\n-                Ok(path) => path,\n-                Err(err_kind) => {\n-                    debug!(\"link has malformed generics: {}\", path_str);\n-                    resolution_failure(\n-                        self,\n-                        diag_info,\n-                        path_str,\n-                        disambiguator,\n-                        smallvec![err_kind],\n-                    );\n-                    return None;\n-                }\n-            };\n-            path_str = &stripped_path_string;\n-        }\n-        // Sanity check to make sure we don't have any angle brackets after stripping generics.\n-        assert!(!path_str.contains(['<', '>'].as_slice()));\n-\n-        // The link is not an intra-doc link if it still contains spaces after stripping generics.\n-        if path_str.contains(' ') {\n-            return None;\n-        }\n-\n         let (mut res, mut fragment) = self.resolve_with_disambiguator_cached(\n             ResolutionInfo {\n                 module_id,\n                 dis: disambiguator,\n                 path_str: path_str.to_owned(),\n-                extra_fragment,\n+                extra_fragment: extra_fragment.map(String::from),\n             },\n             diag_info.clone(), // this struct should really be Copy, but Range is not :(\n             matches!(ori_link.kind, LinkType::Reference | LinkType::Shortcut),\n@@ -1438,7 +1497,7 @@ fn should_ignore_link(path_str: &str) -> bool {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n /// Disambiguators for a link.\n-crate enum Disambiguator {\n+enum Disambiguator {\n     /// `prim@`\n     ///\n     /// This is buggy, see <https://github.com/rust-lang/rust/pull/77875#discussion_r503583103>\n@@ -1467,7 +1526,7 @@ impl Disambiguator {\n     /// This returns `Ok(Some(...))` if a disambiguator was found,\n     /// `Ok(None)` if no disambiguator was found, or `Err(...)`\n     /// if there was a problem with the disambiguator.\n-    crate fn from_str(link: &str) -> Result<Option<(Self, &str)>, (String, Range<usize>)> {\n+    fn from_str(link: &str) -> Result<Option<(Self, &str)>, (String, Range<usize>)> {\n         use Disambiguator::{Kind, Namespace as NS, Primitive};\n \n         if let Some(idx) = link.find('@') {"}, {"sha": "7cba2523d1a3b938e45b20671e9976e9ac976ec4", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1ff117e987be82e9cff59350fd1810ebe21f8b26/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff117e987be82e9cff59350fd1810ebe21f8b26/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=1ff117e987be82e9cff59350fd1810ebe21f8b26", "patch": "@@ -0,0 +1,63 @@\n+use rustc_ast as ast;\n+use rustc_hir::def::Namespace::TypeNS;\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_INDEX};\n+use rustc_interface::interface;\n+\n+use std::cell::RefCell;\n+use std::mem;\n+use std::rc::Rc;\n+\n+// Letting the resolver escape at the end of the function leads to inconsistencies between the\n+// crates the TyCtxt sees and the resolver sees (because the resolver could load more crates\n+// after escaping). Hopefully `IntraLinkCrateLoader` gets all the crates we need ...\n+crate struct IntraLinkCrateLoader {\n+    current_mod: DefId,\n+    crate resolver: Rc<RefCell<interface::BoxedResolver>>,\n+}\n+\n+impl IntraLinkCrateLoader {\n+    crate fn new(resolver: Rc<RefCell<interface::BoxedResolver>>) -> Self {\n+        let crate_id = LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id();\n+        Self { current_mod: crate_id, resolver }\n+    }\n+}\n+\n+impl ast::visit::Visitor<'_> for IntraLinkCrateLoader {\n+    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+        use crate::html::markdown::markdown_links;\n+        use crate::passes::collect_intra_doc_links::preprocess_link;\n+\n+        if let Some(doc) = attr.doc_str() {\n+            for link in markdown_links(&doc.as_str()) {\n+                let path_str = if let Some(Ok(x)) = preprocess_link(&link) {\n+                    x.path_str\n+                } else {\n+                    continue;\n+                };\n+                self.resolver.borrow_mut().access(|resolver| {\n+                    let _ = resolver.resolve_str_path_error(\n+                        attr.span,\n+                        &path_str,\n+                        TypeNS,\n+                        self.current_mod,\n+                    );\n+                });\n+            }\n+        }\n+        ast::visit::walk_attribute(self, attr);\n+    }\n+\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        use rustc_ast_lowering::ResolverAstLowering;\n+\n+        if let ast::ItemKind::Mod(..) = item.kind {\n+            let new_mod =\n+                self.resolver.borrow_mut().access(|resolver| resolver.local_def_id(item.id));\n+            let old_mod = mem::replace(&mut self.current_mod, new_mod.to_def_id());\n+            ast::visit::walk_item(self, item);\n+            self.current_mod = old_mod;\n+        } else {\n+            ast::visit::walk_item(self, item);\n+        }\n+    }\n+}"}, {"sha": "d11c69f812a8dfe9ea3db2474363c188c096c5b3", "filename": "src/test/rustdoc/intra-doc/auxiliary/empty.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ff117e987be82e9cff59350fd1810ebe21f8b26/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff117e987be82e9cff59350fd1810ebe21f8b26/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty.rs?ref=1ff117e987be82e9cff59350fd1810ebe21f8b26", "patch": "@@ -0,0 +1 @@\n+// intentionally empty"}, {"sha": "d11c69f812a8dfe9ea3db2474363c188c096c5b3", "filename": "src/test/rustdoc/intra-doc/auxiliary/empty2.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ff117e987be82e9cff59350fd1810ebe21f8b26/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff117e987be82e9cff59350fd1810ebe21f8b26/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty2.rs?ref=1ff117e987be82e9cff59350fd1810ebe21f8b26", "patch": "@@ -0,0 +1 @@\n+// intentionally empty"}, {"sha": "5d8dcf8bc1d1682357b5cb982c07713c82f6c3f5", "filename": "src/test/rustdoc/intra-doc/extern-crate-only-used-in-link.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1ff117e987be82e9cff59350fd1810ebe21f8b26/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-crate-only-used-in-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ff117e987be82e9cff59350fd1810ebe21f8b26/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-crate-only-used-in-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-crate-only-used-in-link.rs?ref=1ff117e987be82e9cff59350fd1810ebe21f8b26", "patch": "@@ -1,8 +1,19 @@\n+// This test is just a little cursed.\n // aux-build:issue-66159-1.rs\n // aux-crate:priv:issue_66159_1=issue-66159-1.rs\n+// aux-build:empty.rs\n+// aux-crate:priv:empty=empty.rs\n+// aux-build:empty2.rs\n+// aux-crate:priv:empty2=empty2.rs\n // build-aux-docs\n-// compile-flags:-Z unstable-options\n+// compile-flags:-Z unstable-options --edition 2018\n \n // @has extern_crate_only_used_in_link/index.html\n // @has - '//a[@href=\"../issue_66159_1/struct.Something.html\"]' 'issue_66159_1::Something'\n //! [issue_66159_1::Something]\n+\n+// @has - '//a[@href=\"../empty/index.html\"]' 'empty'\n+//! [`empty`]\n+\n+// @has - '//a[@href=\"../empty2/index.html\"]' 'empty2'\n+//! [empty2<x>]"}]}