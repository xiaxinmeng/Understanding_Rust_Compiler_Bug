{"sha": "64ec47c9d2a75c8150d153450e7e7b7db60208dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZWM0N2M5ZDJhNzVjODE1MGQxNTM0NTBlN2U3YjdkYjYwMjA4ZGM=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-01-04T16:43:27Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-01-05T22:01:05Z"}, "message": "Final alpha stabilization of core::iter\n\nThis commit wraps up the adjustments to the iterator for recent language\nchanges.\n\n* Moves `rposition` from `ExactSizeIterator` to `IteratorExt` using a\n  `where` clause, thereby removing the `ExactSizeIterator:\n  DoubleEndedIterator` constraint.\n\n* Merges `MutableDoubleEndedIterator` into `IteratorExt`, renaming\n  `reverse_` to `reverse_in_place`.\n\n* Merges `IteratorOrdExt`, `IteratorCloneExt` and `CloneIteratorExt`\n  into `IteratorExt` using `where` clauses.\n\nMarks as `#[stable]`:\n\n* the `iter` module itself\n* `FromIterator`, `Extend`\n* `Iterator`, `IteratorExt`\n* `map`\n* `filter`\n* `filter_map`\n* `skip_while`\n* `take_while`\n* `scan`\n* `flat_map`\n* `inspect`\n* `collect`\n* `fold`\n* `all`\n* `any`\n* `find`\n* `rposition`\n* `max`, `min`\n* Various adapter types related to the above methods\n\nBecause of the trait merging, this is a:\n\n[breaking-change]", "tree": {"sha": "3de471cbed40747b7217788e4f3967ebd1841fcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3de471cbed40747b7217788e4f3967ebd1841fcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64ec47c9d2a75c8150d153450e7e7b7db60208dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64ec47c9d2a75c8150d153450e7e7b7db60208dc", "html_url": "https://github.com/rust-lang/rust/commit/64ec47c9d2a75c8150d153450e7e7b7db60208dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64ec47c9d2a75c8150d153450e7e7b7db60208dc/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03268bbf35d3ff2350d987fe7b60375839abdf2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/03268bbf35d3ff2350d987fe7b60375839abdf2e", "html_url": "https://github.com/rust-lang/rust/commit/03268bbf35d3ff2350d987fe7b60375839abdf2e"}], "stats": {"total": 708, "additions": 347, "deletions": 361}, "files": [{"sha": "4782a763dc89a425b9f2c18bd8f5bafe92390ccd", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 347, "deletions": 361, "changes": 708, "blob_url": "https://github.com/rust-lang/rust/blob/64ec47c9d2a75c8150d153450e7e7b7db60208dc/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64ec47c9d2a75c8150d153450e7e7b7db60208dc/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=64ec47c9d2a75c8150d153450e7e7b7db60208dc", "patch": "@@ -54,6 +54,8 @@\n //!\n //! This `for` loop syntax can be applied to any iterator over any type.\n \n+#![stable]\n+\n use self::MinMaxResult::*;\n \n use clone::Clone;\n@@ -79,38 +81,94 @@ use uint;\n /// it wishes, either by returning `None` infinitely, or by doing something\n /// else.\n #[lang=\"iterator\"]\n-#[unstable = \"just split up for object safety\"]\n+#[stable]\n pub trait Iterator {\n+    #[stable]\n     type Item;\n \n     /// Advance the iterator and return the next value. Return `None` when the end is reached.\n+    #[stable]\n     fn next(&mut self) -> Option<Self::Item>;\n \n     /// Returns a lower and upper bound on the remaining length of the iterator.\n     ///\n     /// An upper bound of `None` means either there is no known upper bound, or the upper bound\n     /// does not fit within a `uint`.\n     #[inline]\n+    #[stable]\n     fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n }\n \n /// Conversion from an `Iterator`\n-#[unstable = \"may be replaced by a more general conversion trait\"]\n+#[stable]\n pub trait FromIterator<A> {\n     /// Build a container with elements from an external iterator.\n     fn from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n }\n \n /// A type growable from an `Iterator` implementation\n-#[unstable = \"just renamed as part of collections reform\"]\n+#[stable]\n pub trait Extend<A> {\n     /// Extend a container with the elements yielded by an arbitrary iterator\n     fn extend<T: Iterator<Item=A>>(&mut self, iterator: T);\n }\n \n-#[unstable = \"new convention for extension traits\"]\n /// An extension trait providing numerous methods applicable to all iterators.\n+#[stable]\n pub trait IteratorExt: Iterator + Sized {\n+    /// Counts the number of elements in this iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert!(it.count() == 5);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn count(self) -> uint {\n+        self.fold(0, |cnt, _x| cnt + 1)\n+    }\n+\n+    /// Loops through the entire iterator, returning the last element of the\n+    /// iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// assert!(a.iter().last().unwrap() == &5);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn last(mut self) -> Option< <Self as Iterator>::Item> {\n+        let mut last = None;\n+        for x in self { last = Some(x); }\n+        last\n+    }\n+\n+    /// Loops through `n` iterations, returning the `n`th element of the\n+    /// iterator.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// let mut it = a.iter();\n+    /// assert!(it.nth(2).unwrap() == &3);\n+    /// assert!(it.nth(2) == None);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn nth(&mut self, mut n: uint) -> Option< <Self as Iterator>::Item> {\n+        for x in *self {\n+            if n == 0 { return Some(x) }\n+            n -= 1;\n+        }\n+        None\n+    }\n+\n     /// Chain this iterator with another, returning a new iterator that will\n     /// finish iterating over the current iterator, and then iterate\n     /// over the other specified iterator.\n@@ -169,7 +227,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn map<B, F>(self, f: F) -> Map< <Self as Iterator>::Item, B, Self, F> where\n         F: FnMut(<Self as Iterator>::Item) -> B,\n     {\n@@ -189,7 +247,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn filter<P>(self, predicate: P) -> Filter< <Self as Iterator>::Item, Self, P> where\n         P: FnMut(&<Self as Iterator>::Item) -> bool,\n     {\n@@ -209,7 +267,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn filter_map<B, F>(self, f: F) -> FilterMap< <Self as Iterator>::Item, B, Self, F> where\n         F: FnMut(<Self as Iterator>::Item) -> Option<B>,\n     {\n@@ -258,9 +316,9 @@ pub trait IteratorExt: Iterator + Sized {\n         Peekable{iter: self, peeked: None}\n     }\n \n-    /// Creates an iterator that invokes the predicate on elements until it\n-    /// returns false. Once the predicate returns false, all further elements are\n-    /// yielded.\n+    /// Creates an iterator that invokes the predicate on elements\n+    /// until it returns false. Once the predicate returns false, that\n+    /// element and all further elements are yielded.\n     ///\n     /// # Example\n     ///\n@@ -273,7 +331,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn skip_while<P>(self, predicate: P) -> SkipWhile< <Self as Iterator>::Item, Self, P> where\n         P: FnMut(&<Self as Iterator>::Item) -> bool,\n     {\n@@ -294,7 +352,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, may want to require peek\"]\n+    #[stable]\n     fn take_while<P>(self, predicate: P) -> TakeWhile< <Self as Iterator>::Item, Self, P> where\n         P: FnMut(&<Self as Iterator>::Item) -> bool,\n     {\n@@ -359,7 +417,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn scan<St, B, F>(\n         self,\n         initial_state: St,\n@@ -389,7 +447,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn flat_map<B, U, F>(self, f: F) -> FlatMap< <Self as Iterator>::Item, B, Self, U, F> where\n         U: Iterator<Item=B>,\n         F: FnMut(<Self as Iterator>::Item) -> U,\n@@ -449,7 +507,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// println!(\"{}\", sum);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn inspect<F>(self, f: F) -> Inspect< <Self as Iterator>::Item, Self, F> where\n         F: FnMut(&<Self as Iterator>::Item),\n     {\n@@ -487,7 +545,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.as_slice() == b.as_slice());\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for general conversion traits, just changed to take self by value\"]\n+    #[stable]\n     fn collect<B: FromIterator< <Self as Iterator>::Item>>(self) -> B {\n         FromIterator::from_iter(self)\n     }\n@@ -522,44 +580,6 @@ pub trait IteratorExt: Iterator + Sized {\n         (left, right)\n     }\n \n-    /// Loops through `n` iterations, returning the `n`th element of the\n-    /// iterator.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n-    /// let mut it = a.iter();\n-    /// assert!(it.nth(2).unwrap() == &3);\n-    /// assert!(it.nth(2) == None);\n-    /// ```\n-    #[inline]\n-    #[stable]\n-    fn nth(&mut self, mut n: uint) -> Option< <Self as Iterator>::Item> {\n-        for x in *self {\n-            if n == 0 { return Some(x) }\n-            n -= 1;\n-        }\n-        None\n-    }\n-\n-    /// Loops through the entire iterator, returning the last element of the\n-    /// iterator.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n-    /// assert!(a.iter().last().unwrap() == &5);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"just changed to take self by value\"]\n-    fn last(mut self) -> Option< <Self as Iterator>::Item> {\n-        let mut last = None;\n-        for x in self { last = Some(x); }\n-        last\n-    }\n-\n     /// Performs a fold operation over the entire iterator, returning the\n     /// eventual state at the end of the iteration.\n     ///\n@@ -570,7 +590,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    #[stable]\n     fn fold<B, F>(mut self, init: B, mut f: F) -> B where\n         F: FnMut(B, <Self as Iterator>::Item) -> B,\n     {\n@@ -581,21 +601,6 @@ pub trait IteratorExt: Iterator + Sized {\n         accum\n     }\n \n-    /// Counts the number of elements in this iterator.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n-    /// let mut it = a.iter();\n-    /// assert!(it.count() == 5);\n-    /// ```\n-    #[inline]\n-    #[unstable = \"just changed to take self by value\"]\n-    fn count(self) -> uint {\n-        self.fold(0, |cnt, _x| cnt + 1)\n-    }\n-\n     /// Tests whether the predicate holds true for all elements in the iterator.\n     ///\n     /// # Example\n@@ -606,7 +611,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(!a.iter().all(|x| *x > 2));\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    #[stable]\n     fn all<F>(mut self, mut f: F) -> bool where F: FnMut(<Self as Iterator>::Item) -> bool {\n         for x in self { if !f(x) { return false; } }\n         true\n@@ -624,7 +629,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert!(!it.any(|x| *x == 3));\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn any<F>(&mut self, mut f: F) -> bool where F: FnMut(<Self as Iterator>::Item) -> bool {\n         for x in *self { if f(x) { return true; } }\n         false\n@@ -634,7 +639,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// Does not consume the iterator past the first found element.\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn find<P>(&mut self, mut predicate: P) -> Option< <Self as Iterator>::Item> where\n         P: FnMut(&<Self as Iterator>::Item) -> bool,\n     {\n@@ -646,7 +651,7 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Return the index of the first element satisfying the specified predicate\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures\"]\n+    #[stable]\n     fn position<P>(&mut self, mut predicate: P) -> Option<uint> where\n         P: FnMut(<Self as Iterator>::Item) -> bool,\n     {\n@@ -660,6 +665,145 @@ pub trait IteratorExt: Iterator + Sized {\n         None\n     }\n \n+    /// Return the index of the last element satisfying the specified predicate\n+    ///\n+    /// If no element matches, None is returned.\n+    #[inline]\n+    #[stable]\n+    fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where\n+        P: FnMut(<Self as Iterator>::Item) -> bool,\n+        Self: ExactSizeIterator + DoubleEndedIterator\n+    {\n+        let len = self.len();\n+        for i in range(0, len).rev() {\n+            if predicate(self.next_back().expect(\"rposition: incorrect ExactSizeIterator\")) {\n+                return Some(i);\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Consumes the entire iterator to return the maximum element.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// assert!(a.iter().max().unwrap() == &5);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn max(self) -> Option< <Self as Iterator>::Item> where\n+        <Self as Iterator>::Item: Ord\n+    {\n+        self.fold(None, |max, x| {\n+            match max {\n+                None    => Some(x),\n+                Some(y) => Some(cmp::max(x, y))\n+            }\n+        })\n+    }\n+\n+    /// Consumes the entire iterator to return the minimum element.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let a = [1i, 2, 3, 4, 5];\n+    /// assert!(a.iter().min().unwrap() == &1);\n+    /// ```\n+    #[inline]\n+    #[stable]\n+    fn min(self) -> Option< <Self as Iterator>::Item> where\n+        <Self as Iterator>::Item: Ord\n+    {\n+        self.fold(None, |min, x| {\n+            match min {\n+                None    => Some(x),\n+                Some(y) => Some(cmp::min(x, y))\n+            }\n+        })\n+    }\n+\n+    /// `min_max` finds the minimum and maximum elements in the iterator.\n+    ///\n+    /// The return type `MinMaxResult` is an enum of three variants:\n+    ///\n+    /// - `NoElements` if the iterator is empty.\n+    /// - `OneElement(x)` if the iterator has exactly one element.\n+    /// - `MinMax(x, y)` is returned otherwise, where `x <= y`. Two\n+    ///    values are equal if and only if there is more than one\n+    ///    element in the iterator and all elements are equal.\n+    ///\n+    /// On an iterator of length `n`, `min_max` does `1.5 * n` comparisons,\n+    /// and so is faster than calling `min` and `max` separately which does `2 * n` comparisons.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::iter::MinMaxResult::{NoElements, OneElement, MinMax};\n+    ///\n+    /// let v: [int; 0] = [];\n+    /// assert_eq!(v.iter().min_max(), NoElements);\n+    ///\n+    /// let v = [1i];\n+    /// assert!(v.iter().min_max() == OneElement(&1));\n+    ///\n+    /// let v = [1i, 2, 3, 4, 5];\n+    /// assert!(v.iter().min_max() == MinMax(&1, &5));\n+    ///\n+    /// let v = [1i, 2, 3, 4, 5, 6];\n+    /// assert!(v.iter().min_max() == MinMax(&1, &6));\n+    ///\n+    /// let v = [1i, 1, 1, 1];\n+    /// assert!(v.iter().min_max() == MinMax(&1, &1));\n+    /// ```\n+    #[unstable = \"return type may change\"]\n+    fn min_max(mut self) -> MinMaxResult< <Self as Iterator>::Item> where\n+        <Self as Iterator>::Item: Ord\n+    {\n+        let (mut min, mut max) = match self.next() {\n+            None => return NoElements,\n+            Some(x) => {\n+                match self.next() {\n+                    None => return OneElement(x),\n+                    Some(y) => if x < y {(x, y)} else {(y,x)}\n+                }\n+            }\n+        };\n+\n+        loop {\n+            // `first` and `second` are the two next elements we want to look at.\n+            // We first compare `first` and `second` (#1). The smaller one is then compared to\n+            // current minimum (#2). The larger one is compared to current maximum (#3). This\n+            // way we do 3 comparisons for 2 elements.\n+            let first = match self.next() {\n+                None => break,\n+                Some(x) => x\n+            };\n+            let second = match self.next() {\n+                None => {\n+                    if first < min {\n+                        min = first;\n+                    } else if first > max {\n+                        max = first;\n+                    }\n+                    break;\n+                }\n+                Some(x) => x\n+            };\n+            if first < second {\n+                if first < min {min = first;}\n+                if max < second {max = second;}\n+            } else {\n+                if second < min {min = second;}\n+                if max < first {max = first;}\n+            }\n+        }\n+\n+        MinMax(min, max)\n+    }\n+\n     /// Return the element that gives the maximum value from the\n     /// specified function.\n     ///\n@@ -672,7 +816,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n     fn max_by<B: Ord, F>(self, mut f: F) -> Option< <Self as Iterator>::Item> where\n         F: FnMut(&<Self as Iterator>::Item) -> B,\n     {\n@@ -701,7 +845,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n-    #[unstable = \"waiting for unboxed closures, just changed to take self by value\"]\n+    #[unstable = \"may want to produce an Ordering directly; see #15311\"]\n     fn min_by<B: Ord, F>(self, mut f: F) -> Option< <Self as Iterator>::Item> where\n         F: FnMut(&<Self as Iterator>::Item) -> B,\n     {\n@@ -740,6 +884,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// Loops through the entire iterator, collecting the first component of\n     /// each item into one new container, and the second component into another.\n+    #[unstable = \"recent addition\"]\n     fn unzip<A, B, FromA, FromB>(mut self) -> (FromA, FromB) where\n         FromA: Default + Extend<A>,\n         FromB: Default + Extend<B>,\n@@ -759,56 +904,73 @@ pub trait IteratorExt: Iterator + Sized {\n         let mut ts: FromA = Default::default();\n         let mut us: FromB = Default::default();\n \n-        ts.extend(SizeHint(lo, hi));\n-        us.extend(SizeHint(lo, hi));\n+        ts.extend(SizeHint(lo, hi));\n+        us.extend(SizeHint(lo, hi));\n+\n+        for (t, u) in self {\n+            ts.extend(Some(t).into_iter());\n+            us.extend(Some(u).into_iter());\n+        }\n+\n+        (ts, us)\n+    }\n+\n+    /// Creates an iterator that clones the elements it yields. Useful for converting an\n+    /// Iterator<&T> to an Iterator<T>.\n+    #[unstable = \"recent addition\"]\n+    fn cloned<T, D>(self) -> Cloned<Self> where\n+        Self: Iterator<Item=D>,\n+        D: Deref<Target=T>,\n+        T: Clone,\n+    {\n+        Cloned { it: self }\n+    }\n+\n+    /// Repeats an iterator endlessly\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::iter::count;\n+    ///\n+    /// let a = count(1i,1i).take(1);\n+    /// let mut cy = a.cycle();\n+    /// assert_eq!(cy.next(), Some(1));\n+    /// assert_eq!(cy.next(), Some(1));\n+    /// ```\n+    #[stable]\n+    #[inline]\n+    fn cycle(self) -> Cycle<Self> where Self: Clone {\n+        Cycle{orig: self.clone(), iter: self}\n+    }\n \n-        for (t, u) in self {\n-            ts.extend(Some(t).into_iter());\n-            us.extend(Some(u).into_iter());\n+    /// Use an iterator to reverse a container in place.\n+    #[experimental = \"uncertain about placement or widespread use\"]\n+    fn reverse_in_place<'a, T: 'a>(&mut self) where\n+        Self: Iterator<Item=&'a mut T> + DoubleEndedIterator\n+    {\n+        loop {\n+            match (self.next(), self.next_back()) {\n+                (Some(x), Some(y)) => mem::swap(x, y),\n+                _ => break\n+            }\n         }\n-\n-        (ts, us)\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> IteratorExt for I where I: Iterator {}\n \n /// A range iterator able to yield elements from both ends\n ///\n /// A `DoubleEndedIterator` can be thought of as a deque in that `next()` and `next_back()` exhaust\n /// elements from the *same* range, and do not work independently of each other.\n-#[unstable = \"recently split into two traits\"]\n+#[stable]\n pub trait DoubleEndedIterator: Iterator {\n     /// Yield an element from the end of the range, returning `None` if the range is empty.\n     fn next_back(&mut self) -> Option< <Self as Iterator>::Item>;\n }\n \n-/// A double-ended iterator yielding mutable references\n-#[experimental = \"not widely used\"]\n-pub trait MutableDoubleEndedIterator {\n-    // FIXME: #5898: should be called `reverse`\n-    /// Use an iterator to reverse a container in-place\n-    fn reverse_(&mut self);\n-}\n-\n-#[experimental = \"trait is experimental\"]\n-impl<'a, T:'a, I> MutableDoubleEndedIterator for I where\n-    I: DoubleEndedIterator + Iterator<Item=&'a mut T>,\n-{\n-    // FIXME: #5898: should be called `reverse`\n-    /// Use an iterator to reverse a container in-place\n-    fn reverse_(&mut self) {\n-        loop {\n-            match (self.next(), self.next_back()) {\n-                (Some(x), Some(y)) => mem::swap(x, y),\n-                _ => break\n-            }\n-        }\n-    }\n-}\n-\n-\n /// An object implementing random access indexing by `uint`\n ///\n /// A `RandomAccessIterator` should be either infinite or a `DoubleEndedIterator`.\n@@ -832,24 +994,8 @@ pub trait RandomAccessIterator: Iterator {\n ///\n /// `Iterator::size_hint` *must* return the exact size of the iterator.\n /// Note that the size must fit in `uint`.\n-#[unstable = \"could move DoubleEndedIterator bound onto rposition with method-level where clauses\"]\n-pub trait ExactSizeIterator: DoubleEndedIterator {\n-    /// Return the index of the last element satisfying the specified predicate\n-    ///\n-    /// If no element matches, None is returned.\n-    #[inline]\n-    fn rposition<P>(&mut self, mut predicate: P) -> Option<uint> where\n-        P: FnMut(<Self as Iterator>::Item) -> bool,\n-    {\n-        let len = self.len();\n-        for i in range(0, len).rev() {\n-            if predicate(self.next_back().expect(\"rposition: incorrect ExactSizeIterator\")) {\n-                return Some(i);\n-            }\n-        }\n-        None\n-    }\n-\n+#[stable]\n+pub trait ExactSizeIterator: Iterator {\n     #[inline]\n     /// Return the exact length of the iterator.\n     fn len(&self) -> uint {\n@@ -865,21 +1011,21 @@ pub trait ExactSizeIterator: DoubleEndedIterator {\n \n // All adaptors that preserve the size of the wrapped iterator are fine\n // Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, F> ExactSizeIterator for Inspect<A, I, F> where\n     I: ExactSizeIterator + Iterator<Item=A>,\n     F: FnMut(&A),\n {}\n-#[unstable = \"trait is unstable\"]\n-impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator {}\n-#[unstable = \"trait is unstable\"]\n+#[stable]\n+impl<I> ExactSizeIterator for Rev<I> where I: ExactSizeIterator + DoubleEndedIterator {}\n+#[stable]\n impl<A, B, I, F> ExactSizeIterator for Map<A, B, I, F> where\n     I: ExactSizeIterator + Iterator<Item=A>,\n     F: FnMut(A) -> B,\n {}\n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B> ExactSizeIterator for Zip<A, B> where A: ExactSizeIterator, B: ExactSizeIterator {}\n \n /// An double-ended iterator with the direction inverted\n@@ -890,7 +1036,7 @@ pub struct Rev<T> {\n     iter: T\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -900,7 +1046,7 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next() }\n@@ -924,7 +1070,7 @@ pub struct ByRef<'a, I:'a> {\n     iter: &'a mut I,\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -934,7 +1080,7 @@ impl<'a, I> Iterator for ByRef<'a, I> where I: 'a + Iterator {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option< <I as Iterator>::Item> { self.iter.next_back() }\n@@ -1025,134 +1171,9 @@ impl_multiplicative! { uint, 1 }\n impl_multiplicative! { f32,  1.0 }\n impl_multiplicative! { f64,  1.0 }\n \n-/// A trait for iterators over elements which can be compared to one another.\n-#[unstable = \"recently renamed for new extension trait conventions\"]\n-pub trait IteratorOrdExt<A> {\n-    /// Consumes the entire iterator to return the maximum element.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n-    /// assert!(a.iter().max().unwrap() == &5);\n-    /// ```\n-    fn max(self) -> Option<A>;\n-\n-    /// Consumes the entire iterator to return the minimum element.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let a = [1i, 2, 3, 4, 5];\n-    /// assert!(a.iter().min().unwrap() == &1);\n-    /// ```\n-    fn min(self) -> Option<A>;\n-\n-    /// `min_max` finds the minimum and maximum elements in the iterator.\n-    ///\n-    /// The return type `MinMaxResult` is an enum of three variants:\n-    ///\n-    /// - `NoElements` if the iterator is empty.\n-    /// - `OneElement(x)` if the iterator has exactly one element.\n-    /// - `MinMax(x, y)` is returned otherwise, where `x <= y`. Two\n-    ///    values are equal if and only if there is more than one\n-    ///    element in the iterator and all elements are equal.\n-    ///\n-    /// On an iterator of length `n`, `min_max` does `1.5 * n` comparisons,\n-    /// and so is faster than calling `min` and `max` separately which does `2 * n` comparisons.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::iter::MinMaxResult::{NoElements, OneElement, MinMax};\n-    ///\n-    /// let v: [int; 0] = [];\n-    /// assert_eq!(v.iter().min_max(), NoElements);\n-    ///\n-    /// let v = [1i];\n-    /// assert!(v.iter().min_max() == OneElement(&1));\n-    ///\n-    /// let v = [1i, 2, 3, 4, 5];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &5));\n-    ///\n-    /// let v = [1i, 2, 3, 4, 5, 6];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &6));\n-    ///\n-    /// let v = [1i, 1, 1, 1];\n-    /// assert!(v.iter().min_max() == MinMax(&1, &1));\n-    /// ```\n-    fn min_max(self) -> MinMaxResult<A>;\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T, I> IteratorOrdExt<T> for I where I: Iterator<Item=T>, T: Ord {\n-    #[inline]\n-    fn max(self) -> Option<T> {\n-        self.fold(None, |max, x| {\n-            match max {\n-                None    => Some(x),\n-                Some(y) => Some(cmp::max(x, y))\n-            }\n-        })\n-    }\n-\n-    #[inline]\n-    fn min(self) -> Option<T> {\n-        self.fold(None, |min, x| {\n-            match min {\n-                None    => Some(x),\n-                Some(y) => Some(cmp::min(x, y))\n-            }\n-        })\n-    }\n-\n-    fn min_max(mut self) -> MinMaxResult<T> {\n-        let (mut min, mut max) = match self.next() {\n-            None => return NoElements,\n-            Some(x) => {\n-                match self.next() {\n-                    None => return OneElement(x),\n-                    Some(y) => if x < y {(x, y)} else {(y,x)}\n-                }\n-            }\n-        };\n-\n-        loop {\n-            // `first` and `second` are the two next elements we want to look at.\n-            // We first compare `first` and `second` (#1). The smaller one is then compared to\n-            // current minimum (#2). The larger one is compared to current maximum (#3). This\n-            // way we do 3 comparisons for 2 elements.\n-            let first = match self.next() {\n-                None => break,\n-                Some(x) => x\n-            };\n-            let second = match self.next() {\n-                None => {\n-                    if first < min {\n-                        min = first;\n-                    } else if first > max {\n-                        max = first;\n-                    }\n-                    break;\n-                }\n-                Some(x) => x\n-            };\n-            if first < second {\n-                if first < min {min = first;}\n-                if max < second {max = second;}\n-            } else {\n-                if second < min {min = second;}\n-                if max < first {max = first;}\n-            }\n-        }\n-\n-        MinMax(min, max)\n-    }\n-}\n-\n /// `MinMaxResult` is an enum returned by `min_max`. See `IteratorOrdExt::min_max` for more detail.\n #[derive(Clone, PartialEq, Show)]\n-#[unstable = \"waiting on namespaced enum conventions\"]\n+#[unstable = \"unclear whether such a fine-grained result is widely useful\"]\n pub enum MinMaxResult<T> {\n     /// Empty iterator\n     NoElements,\n@@ -1164,7 +1185,6 @@ pub enum MinMaxResult<T> {\n     MinMax(T, T)\n }\n \n-#[stable]\n impl<T: Clone> MinMaxResult<T> {\n     /// `into_option` creates an `Option` of type `(T,T)`. The returned `Option` has variant\n     /// `None` if and only if the `MinMaxResult` has variant `NoElements`. Otherwise variant\n@@ -1185,6 +1205,7 @@ impl<T: Clone> MinMaxResult<T> {\n     /// let r = MinMax(1i,2i);\n     /// assert_eq!(r.into_option(), Some((1,2)));\n     /// ```\n+    #[unstable = \"type is unstable\"]\n     pub fn into_option(self) -> Option<(T,T)> {\n         match self {\n             NoElements => None,\n@@ -1194,30 +1215,15 @@ impl<T: Clone> MinMaxResult<T> {\n     }\n }\n \n-/// A trait for iterators that contain cloneable elements\n-#[unstable = \"recently renamed for extension trait conventions\"]\n-pub trait IteratorCloneExt<A> {\n-    /// Creates an iterator that clones the elements it yields. Useful for converting an\n-    /// Iterator<&T> to an Iterator<T>.\n-    fn cloned(self) -> Cloned<Self>;\n-}\n-\n-#[unstable = \"trait is unstable\"]\n-impl<T, D, I> IteratorCloneExt<T> for I where\n-    T: Clone,\n-    D: Deref<Target=T>,\n-    I: Iterator<Item=D>,\n-{\n-    fn cloned(self) -> Cloned<I> {\n-        Cloned { it: self }\n-    }\n-}\n-\n /// An iterator that clones the elements of an underlying iterator\n+#[unstable = \"recent addition\"]\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[derive(Clone)]\n pub struct Cloned<I> {\n     it: I,\n }\n \n+#[stable]\n impl<T, D, I> Iterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1234,6 +1240,7 @@ impl<T, D, I> Iterator for Cloned<I> where\n     }\n }\n \n+#[stable]\n impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n@@ -1244,39 +1251,13 @@ impl<T, D, I> DoubleEndedIterator for Cloned<I> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, D, I> ExactSizeIterator for Cloned<I> where\n     T: Clone,\n     D: Deref<Target=T>,\n     I: ExactSizeIterator + Iterator<Item=D>,\n {}\n \n-#[unstable = \"recently renamed for extension trait conventions\"]\n-/// An extension trait for cloneable iterators.\n-pub trait CloneIteratorExt {\n-    /// Repeats an iterator endlessly\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::iter::{CloneIteratorExt, count};\n-    ///\n-    /// let a = count(1i,1i).take(1);\n-    /// let mut cy = a.cycle();\n-    /// assert_eq!(cy.next(), Some(1));\n-    /// assert_eq!(cy.next(), Some(1));\n-    /// ```\n-    #[stable]\n-    fn cycle(self) -> Cycle<Self>;\n-}\n-\n-impl<I> CloneIteratorExt for I where I: Iterator + Clone {\n-    #[inline]\n-    fn cycle(self) -> Cycle<I> {\n-        Cycle{orig: self.clone(), iter: self}\n-    }\n-}\n-\n /// An iterator that repeats endlessly\n #[derive(Clone, Copy)]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n@@ -1286,6 +1267,7 @@ pub struct Cycle<I> {\n     iter: I,\n }\n \n+#[stable]\n impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -1345,7 +1327,7 @@ pub struct Chain<A, B> {\n     flag: bool,\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<Item=T> {\n     type Item = T;\n \n@@ -1379,7 +1361,7 @@ impl<T, A, B> Iterator for Chain<A, B> where A: Iterator<Item=T>, B: Iterator<It\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n     A: DoubleEndedIterator + Iterator<Item=T>,\n     B: DoubleEndedIterator + Iterator<Item=T>,\n@@ -1424,7 +1406,7 @@ pub struct Zip<A, B> {\n     b: B\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, U, A, B> Iterator for Zip<A, B> where\n     A: Iterator<Item = T>,\n     B: Iterator<Item = U>,\n@@ -1460,10 +1442,10 @@ impl<T, U, A, B> Iterator for Zip<A, B> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n-    A: ExactSizeIterator + Iterator<Item=T>,\n-    B: ExactSizeIterator + Iterator<Item=U>,\n+    A: ExactSizeIterator + Iterator<Item=T> + DoubleEndedIterator,\n+    B: ExactSizeIterator + Iterator<Item=U> + DoubleEndedIterator,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<(T, U)> {\n@@ -1539,7 +1521,7 @@ impl<A, B, I, F> Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMut(A) -> B {\n     type Item = B;\n \n@@ -1555,7 +1537,7 @@ impl<A, B, I, F> Iterator for Map<A, B, I, F> where I: Iterator<Item=A>, F: FnMu\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(A) -> B,\n@@ -1606,7 +1588,7 @@ impl<A, I, P> Clone for Filter<A, I, P> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1629,7 +1611,7 @@ impl<A, I, P> Iterator for Filter<A, I, P> where I: Iterator<Item=A>, P: FnMut(&\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, P> DoubleEndedIterator for Filter<A, I, P> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     P: FnMut(&A) -> bool,\n@@ -1667,7 +1649,7 @@ impl<A, B, I, F> Clone for FilterMap<A, B, I, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     I: Iterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n@@ -1692,7 +1674,7 @@ impl<A, B, I, F> Iterator for FilterMap<A, B, I, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, F> DoubleEndedIterator for FilterMap<A, B, I, F> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(A) -> Option<B>,\n@@ -1718,7 +1700,7 @@ pub struct Enumerate<I> {\n     count: uint\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Enumerate<I> where I: Iterator {\n     type Item = (uint, <I as Iterator>::Item);\n \n@@ -1740,8 +1722,10 @@ impl<I> Iterator for Enumerate<I> where I: Iterator {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n-impl<I> DoubleEndedIterator for Enumerate<I> where I: ExactSizeIterator {\n+#[stable]\n+impl<I> DoubleEndedIterator for Enumerate<I> where\n+    I: ExactSizeIterator + DoubleEndedIterator\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, <I as Iterator>::Item)> {\n         match self.iter.next_back() {\n@@ -1779,6 +1763,7 @@ pub struct Peekable<T, I> where I: Iterator<Item=T> {\n     peeked: Option<T>,\n }\n \n+#[stable]\n impl<T, I> Iterator for Peekable<T, I> where I: Iterator<Item=T> {\n     type Item = T;\n \n@@ -1850,7 +1835,7 @@ impl<A, I, P> Clone for SkipWhile<A, I, P> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, P> Iterator for SkipWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1896,7 +1881,7 @@ impl<A, I, P> Clone for TakeWhile<A, I, P> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, P> Iterator for TakeWhile<A, I, P> where I: Iterator<Item=A>, P: FnMut(&A) -> bool {\n     type Item = A;\n \n@@ -1935,7 +1920,7 @@ pub struct Skip<I> {\n     n: uint\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Skip<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -2005,7 +1990,7 @@ pub struct Take<I> {\n     n: uint\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Take<I> where I: Iterator{\n     type Item = <I as Iterator>::Item;\n \n@@ -2054,7 +2039,7 @@ impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n \n /// An iterator to maintain state while iterating another iterator\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[unstable = \"waiting for unboxed closures\"]\n+#[stable]\n pub struct Scan<A, B, I, St, F> where I: Iterator, F: FnMut(&mut St, A) -> Option<B> {\n     iter: I,\n     f: F,\n@@ -2079,7 +2064,7 @@ impl<A, B, I, St, F> Clone for Scan<A, B, I, St, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n     I: Iterator<Item=A>,\n     F: FnMut(&mut St, A) -> Option<B>,\n@@ -2102,7 +2087,7 @@ impl<A, B, I, St, F> Iterator for Scan<A, B, I, St, F> where\n /// and yields the elements of the produced iterators\n ///\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[unstable = \"waiting for unboxed closures\"]\n+#[stable]\n pub struct FlatMap<A, B, I, U, F> where\n     I: Iterator<Item=A>,\n     U: Iterator<Item=B>,\n@@ -2131,7 +2116,7 @@ impl<A, B, I, U, F> Clone for FlatMap<A, B, I, U, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     I: Iterator<Item=A>,\n     U: Iterator<Item=B>,\n@@ -2166,7 +2151,7 @@ impl<A, B, I, U, F> Iterator for FlatMap<A, B, I, U, F> where\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, B, I, U, F> DoubleEndedIterator for FlatMap<A, B, I, U, F> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     U: DoubleEndedIterator + Iterator<Item=B>,\n@@ -2199,7 +2184,7 @@ pub struct Fuse<I> {\n     done: bool\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> Iterator for Fuse<I> where I: Iterator {\n     type Item = <I as Iterator>::Item;\n \n@@ -2228,7 +2213,7 @@ impl<I> Iterator for Fuse<I> where I: Iterator {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n     #[inline]\n     fn next_back(&mut self) -> Option< <I as Iterator>::Item> {\n@@ -2260,11 +2245,11 @@ impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     }\n }\n \n-#[experimental = \"seems marginal\"]\n impl<I> Fuse<I> {\n     /// Resets the fuse such that the next call to .next() or .next_back() will\n     /// call the underlying iterator again even if it previously returned None.\n     #[inline]\n+    #[experimental = \"seems marginal\"]\n     pub fn reset_fuse(&mut self) {\n         self.done = false\n     }\n@@ -2273,7 +2258,7 @@ impl<I> Fuse<I> {\n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n-#[unstable = \"waiting for unboxed closures\"]\n+#[stable]\n pub struct Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     iter: I,\n     f: F,\n@@ -2305,7 +2290,7 @@ impl<A, I, F> Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(&A) {\n     type Item = A;\n \n@@ -2321,7 +2306,7 @@ impl<A, I, F> Iterator for Inspect<A, I, F> where I: Iterator<Item=A>, F: FnMut(\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n     I: DoubleEndedIterator + Iterator<Item=A>,\n     F: FnMut(&A),\n@@ -2435,7 +2420,7 @@ impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A\n /// An infinite iterator starting at `start` and advancing by `step` with each\n /// iteration\n #[derive(Clone, Copy)]\n-#[unstable = \"may be renamed\"]\n+#[unstable = \"may be renamed or replaced by range notation adapaters\"]\n pub struct Counter<A> {\n     /// The current state the counter is at (next value to be yielded)\n     state: A,\n@@ -2445,12 +2430,12 @@ pub struct Counter<A> {\n \n /// Creates a new counter with the specified start/step\n #[inline]\n-#[unstable = \"may be renamed\"]\n+#[unstable = \"may be renamed or replaced by range notation adapaters\"]\n pub fn count<A>(start: A, step: A) -> Counter<A> {\n     Counter{state: start, step: step}\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n     type Item = A;\n \n@@ -2469,7 +2454,7 @@ impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n \n /// An iterator over the range [start, stop)\n #[derive(Clone, Copy)]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"will be replaced by range notation\"]\n pub struct Range<A> {\n     state: A,\n     stop: A,\n@@ -2490,6 +2475,7 @@ pub struct Range<A> {\n /// }\n /// ```\n #[inline]\n+#[unstable = \"will be replaced by range notation\"]\n pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n     Range {\n         state: start,\n@@ -2499,7 +2485,7 @@ pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n }\n \n // FIXME: #10414: Unfortunate type bound\n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"will be replaced by range notation\"]\n impl<A: Int + ToPrimitive> Iterator for Range<A> {\n     type Item = A;\n \n@@ -2549,7 +2535,7 @@ impl<A: Int + ToPrimitive> Iterator for Range<A> {\n \n /// `Int` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"will be replaced by range notation\"]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2564,23 +2550,23 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n \n /// An iterator over the range [start, stop]\n #[derive(Clone)]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub struct RangeInclusive<A> {\n     range: Range<A>,\n     done: bool,\n }\n \n /// Return an iterator over the range [start, stop]\n #[inline]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n     RangeInclusive {\n         range: range(start, stop),\n         done: false,\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     type Item = A;\n \n@@ -2615,7 +2601,7 @@ impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n@@ -2634,7 +2620,7 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n \n /// An iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[derive(Clone)]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub struct RangeStep<A> {\n     state: A,\n     stop: A,\n@@ -2644,13 +2630,13 @@ pub struct RangeStep<A> {\n \n /// Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[inline]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n     let rev = step < Int::zero();\n     RangeStep{state: start, stop: stop, step: step, rev: rev}\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n impl<A: Int> Iterator for RangeStep<A> {\n     type Item = A;\n \n@@ -2671,7 +2657,7 @@ impl<A: Int> Iterator for RangeStep<A> {\n \n /// An iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[derive(Clone)]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub struct RangeStepInclusive<A> {\n     state: A,\n     stop: A,\n@@ -2682,7 +2668,7 @@ pub struct RangeStepInclusive<A> {\n \n /// Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[inline]\n-#[unstable = \"may be refactored due to numerics reform or ops reform\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n     let rev = step < Int::zero();\n     RangeStepInclusive {\n@@ -2694,7 +2680,7 @@ pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepIncl\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[unstable = \"likely to be replaced by range notation and adapters\"]\n impl<A: Int> Iterator for RangeStepInclusive<A> {\n     type Item = A;\n \n@@ -2719,7 +2705,7 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n /// directions. The `steps_between` function provides a way to\n /// compare two Step objects (it could be provided using `step()` and `Ord`,\n /// but the implementation would be so inefficient as to be useless).\n-#[unstable = \"Trait is unstable.\"]\n+#[unstable = \"design of range notation/iteration is in flux\"]\n pub trait Step: Ord {\n     /// Change self to the next object.\n     fn step(&mut self);\n@@ -2779,7 +2765,7 @@ pub struct Repeat<A> {\n     element: A\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A: Clone> Iterator for Repeat<A> {\n     type Item = A;\n \n@@ -2789,7 +2775,7 @@ impl<A: Clone> Iterator for Repeat<A> {\n     fn size_hint(&self) -> (uint, Option<uint>) { (uint::MAX, None) }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.idx(0) }\n@@ -2855,7 +2841,7 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n ///\n /// If two sequences are equal up until the point where one ends,\n /// the shorter sequence compares less.\n-#[experimental = \"likely to be removed after cmp reform\"]\n+#[unstable = \"needs review and revision\"]\n pub mod order {\n     use cmp;\n     use cmp::{Eq, Ord, PartialOrd, PartialEq};"}]}