{"sha": "4d5aafd3a6a25967a4b0d9326bbbbc1840dbaeeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNWFhZmQzYTZhMjU5NjdhNGIwZDkzMjZiYmJiYzE4NDBkYmFlZWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-22T07:52:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-23T16:45:20Z"}, "message": "sync: Introduce new wrapper types for locking\n\nThis introduces new synchronization types which are meant to be the foundational\nbuilding blocks for sharing data among tasks. The new Mutex and RWLock types\nhave a type parameter which is the internal data that is accessed. Access to the\ndata is all performed through the guards returned, and the guards all have\nautoderef implemented for easy access.", "tree": {"sha": "32eb1279284fce0fdd5400c115bb2c3f1be79b70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32eb1279284fce0fdd5400c115bb2c3f1be79b70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d5aafd3a6a25967a4b0d9326bbbbc1840dbaeeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d5aafd3a6a25967a4b0d9326bbbbc1840dbaeeb", "html_url": "https://github.com/rust-lang/rust/commit/4d5aafd3a6a25967a4b0d9326bbbbc1840dbaeeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d5aafd3a6a25967a4b0d9326bbbbc1840dbaeeb/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae049e82f876e335b835edb674228090d84f811e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae049e82f876e335b835edb674228090d84f811e", "html_url": "https://github.com/rust-lang/rust/commit/ae049e82f876e335b835edb674228090d84f811e"}], "stats": {"total": 816, "additions": 816, "deletions": 0}, "files": [{"sha": "6ddd0d400f2eb54cb680fe21e1641b9690e5e455", "filename": "src/libsync/lock.rs", "status": "added", "additions": 816, "deletions": 0, "changes": 816, "blob_url": "https://github.com/rust-lang/rust/blob/4d5aafd3a6a25967a4b0d9326bbbbc1840dbaeeb/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d5aafd3a6a25967a4b0d9326bbbbc1840dbaeeb/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=4d5aafd3a6a25967a4b0d9326bbbbc1840dbaeeb", "patch": "@@ -0,0 +1,816 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Wrappers for safe, shared, mutable memory between tasks\n+//!\n+//! The wrappers in this module build on the primitives from `sync::raw` to\n+//! provide safe interfaces around using the primitive locks. These primitives\n+//! implement a technique called \"poisoning\" where when a task failed with a\n+//! held lock, all future attempts to use the lock will fail.\n+//!\n+//! For example, if two tasks are contending on a mutex and one of them fails\n+//! after grabbing the lock, the second task will immediately fail because the\n+//! lock is now poisoned.\n+\n+use std::task;\n+use std::ty::Unsafe;\n+\n+use raw;\n+\n+/****************************************************************************\n+ * Poisoning helpers\n+ ****************************************************************************/\n+\n+struct PoisonOnFail<'a> {\n+    flag: &'a mut bool,\n+    failed: bool,\n+}\n+\n+impl<'a> PoisonOnFail<'a> {\n+    fn check(flag: bool, name: &str) {\n+        if flag {\n+            fail!(\"Poisoned {} - another task failed inside!\", name);\n+        }\n+    }\n+\n+    fn new<'a>(flag: &'a mut bool, name: &str) -> PoisonOnFail<'a> {\n+        PoisonOnFail::check(*flag, name);\n+        PoisonOnFail {\n+            flag: flag,\n+            failed: task::failing()\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for PoisonOnFail<'a> {\n+    fn drop(&mut self) {\n+        if !self.failed && task::failing() {\n+            *self.flag = true;\n+        }\n+    }\n+}\n+\n+/****************************************************************************\n+ * Condvar\n+ ****************************************************************************/\n+\n+enum Inner<'a> {\n+    InnerMutex(raw::MutexGuard<'a>),\n+    InnerRWLock(raw::RWLockWriteGuard<'a>),\n+}\n+\n+impl<'b> Inner<'b> {\n+    fn cond<'a>(&'a self) -> &'a raw::Condvar<'b> {\n+        match *self {\n+            InnerMutex(ref m) => &m.cond,\n+            InnerRWLock(ref m) => &m.cond,\n+        }\n+    }\n+}\n+\n+/// A condition variable, a mechanism for unlock-and-descheduling and\n+/// signaling, for use with the lock types.\n+pub struct Condvar<'a> {\n+    priv name: &'static str,\n+    // n.b. Inner must be after PoisonOnFail because we must set the poison flag\n+    //      *inside* the mutex, and struct fields are destroyed top-to-bottom\n+    //      (destroy the lock guard last).\n+    priv poison: PoisonOnFail<'a>,\n+    priv inner: Inner<'a>,\n+}\n+\n+impl<'a> Condvar<'a> {\n+    /// Atomically exit the associated lock and block until a signal is sent.\n+    ///\n+    /// wait() is equivalent to wait_on(0).\n+    ///\n+    /// # Failure\n+    ///\n+    /// A task which is killed while waiting on a condition variable will wake\n+    /// up, fail, and unlock the associated lock as it unwinds.\n+    #[inline]\n+    pub fn wait(&self) { self.wait_on(0) }\n+\n+    /// Atomically exit the associated lock and block on a specified condvar\n+    /// until a signal is sent on that same condvar.\n+    ///\n+    /// The associated lock must have been initialised with an appropriate\n+    /// number of condvars. The condvar_id must be between 0 and num_condvars-1\n+    /// or else this call will fail.\n+    #[inline]\n+    pub fn wait_on(&self, condvar_id: uint) {\n+        assert!(!*self.poison.flag);\n+        self.inner.cond().wait_on(condvar_id);\n+        // This is why we need to wrap sync::condvar.\n+        PoisonOnFail::check(*self.poison.flag, self.name);\n+    }\n+\n+    /// Wake up a blocked task. Returns false if there was no blocked task.\n+    #[inline]\n+    pub fn signal(&self) -> bool { self.signal_on(0) }\n+\n+    /// Wake up a blocked task on a specified condvar (as\n+    /// sync::cond.signal_on). Returns false if there was no blocked task.\n+    #[inline]\n+    pub fn signal_on(&self, condvar_id: uint) -> bool {\n+        assert!(!*self.poison.flag);\n+        self.inner.cond().signal_on(condvar_id)\n+    }\n+\n+    /// Wake up all blocked tasks. Returns the number of tasks woken.\n+    #[inline]\n+    pub fn broadcast(&self) -> uint { self.broadcast_on(0) }\n+\n+    /// Wake up all blocked tasks on a specified condvar (as\n+    /// sync::cond.broadcast_on). Returns the number of tasks woken.\n+    #[inline]\n+    pub fn broadcast_on(&self, condvar_id: uint) -> uint {\n+        assert!(!*self.poison.flag);\n+        self.inner.cond().broadcast_on(condvar_id)\n+    }\n+}\n+\n+/****************************************************************************\n+ * Mutex\n+ ****************************************************************************/\n+\n+/// A wrapper type which provides synchronized access to the underlying data, of\n+/// type `T`. A mutex always provides exclusive access, and concurrent requests\n+/// will block while the mutex is already locked.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use sync::{Mutex, Arc};\n+///\n+/// let mutex = Arc::new(Mutex::new(1));\n+/// let mutex2 = mutex.clone();\n+///\n+/// spawn(proc() {\n+///     let mut val = mutex2.lock();\n+///     *val += 1;\n+///     val.cond.signal();\n+/// });\n+///\n+/// let mut value = mutex.lock();\n+/// while *value != 2 {\n+///     value.cond.wait();\n+/// }\n+/// ```\n+pub struct Mutex<T> {\n+    priv lock: raw::Mutex,\n+    priv failed: Unsafe<bool>,\n+    priv data: Unsafe<T>,\n+}\n+\n+/// An guard which is created by locking a mutex. Through this guard the\n+/// underlying data can be accessed.\n+pub struct MutexGuard<'a, T> {\n+    priv data: &'a mut T,\n+    /// Inner condition variable connected to the locked mutex that this guard\n+    /// was created from. This can be used for atomic-unlock-and-deschedule.\n+    cond: Condvar<'a>,\n+}\n+\n+impl<T: Send> Mutex<T> {\n+    /// Creates a new mutex to protect the user-supplied data.\n+    pub fn new(user_data: T) -> Mutex<T> {\n+        Mutex::new_with_condvars(user_data, 1)\n+    }\n+\n+    /// Create a new mutex, with a specified number of associated condvars.\n+    ///\n+    /// This will allow calling wait_on/signal_on/broadcast_on with condvar IDs\n+    /// between 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be\n+    /// allowed but any operations on the condvar will fail.)\n+    pub fn new_with_condvars(user_data: T, num_condvars: uint) -> Mutex<T> {\n+        Mutex {\n+            lock: raw::Mutex::new_with_condvars(num_condvars),\n+            failed: Unsafe::new(false),\n+            data: Unsafe::new(user_data),\n+        }\n+    }\n+\n+    /// Access the underlying mutable data with mutual exclusion from other\n+    /// tasks. The returned value is an RAII guard which will unlock the mutex\n+    /// when dropped. All concurrent tasks attempting to lock the mutex will\n+    /// block while the returned value is still alive.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Failing while inside the Mutex will unlock the Mutex while unwinding, so\n+    /// that other tasks won't block forever. It will also poison the Mutex:\n+    /// any tasks that subsequently try to access it (including those already\n+    /// blocked on the mutex) will also fail immediately.\n+    #[inline]\n+    pub fn lock<'a>(&'a self) -> MutexGuard<'a, T> {\n+        let guard = self.lock.lock();\n+\n+        // These two accesses are safe because we're guranteed at this point\n+        // that we have exclusive access to this mutex. We are indeed able to\n+        // promote ourselves from &Mutex to `&mut T`\n+        let poison = unsafe { &mut *self.failed.get() };\n+        let data = unsafe { &mut *self.data.get() };\n+\n+        MutexGuard {\n+            data: data,\n+            cond: Condvar {\n+                name: \"Mutex\",\n+                poison: PoisonOnFail::new(poison, \"Mutex\"),\n+                inner: InnerMutex(guard),\n+            },\n+        }\n+    }\n+}\n+\n+// FIXME(#13042): these should both have T: Send\n+impl<'a, T> Deref<T> for MutexGuard<'a, T> {\n+    fn deref<'a>(&'a self) -> &'a T { &*self.data }\n+}\n+impl<'a, T> DerefMut<T> for MutexGuard<'a, T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self.data }\n+}\n+\n+/****************************************************************************\n+ * R/W lock protected lock\n+ ****************************************************************************/\n+\n+/// A dual-mode reader-writer lock. The data can be accessed mutably or\n+/// immutably, and immutably-accessing tasks may run concurrently.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use sync::{RWLock, Arc};\n+///\n+/// let lock1 = Arc::new(RWLock::new(1));\n+/// let lock2 = lock1.clone();\n+///\n+/// spawn(proc() {\n+///     let mut val = lock2.write();\n+///     *val = 3;\n+///     let val = val.downgrade();\n+///     println!(\"{}\", *val);\n+/// });\n+///\n+/// let val = lock1.read();\n+/// println!(\"{}\", *val);\n+/// ```\n+pub struct RWLock<T> {\n+    priv lock: raw::RWLock,\n+    priv failed: Unsafe<bool>,\n+    priv data: Unsafe<T>,\n+}\n+\n+/// A guard which is created by locking an rwlock in write mode. Through this\n+/// guard the underlying data can be accessed.\n+pub struct RWLockWriteGuard<'a, T> {\n+    priv data: &'a mut T,\n+    /// Inner condition variable that can be used to sleep on the write mode of\n+    /// this rwlock.\n+    cond: Condvar<'a>,\n+}\n+\n+/// A guard which is created by locking an rwlock in read mode. Through this\n+/// guard the underlying data can be accessed.\n+pub struct RWLockReadGuard<'a, T> {\n+    priv data: &'a T,\n+    priv guard: raw::RWLockReadGuard<'a>,\n+}\n+\n+impl<T: Send + Share> RWLock<T> {\n+    /// Create a reader/writer lock with the supplied data.\n+    pub fn new(user_data: T) -> RWLock<T> {\n+        RWLock::new_with_condvars(user_data, 1)\n+    }\n+\n+    /// Create a reader/writer lock with the supplied data and a specified number\n+    /// of condvars (as sync::RWLock::new_with_condvars).\n+    pub fn new_with_condvars(user_data: T, num_condvars: uint) -> RWLock<T> {\n+        RWLock {\n+            lock: raw::RWLock::new_with_condvars(num_condvars),\n+            failed: Unsafe::new(false),\n+            data: Unsafe::new(user_data),\n+        }\n+    }\n+\n+    /// Access the underlying data mutably. Locks the rwlock in write mode;\n+    /// other readers and writers will block.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Failing while inside the lock will unlock the lock while unwinding, so\n+    /// that other tasks won't block forever. As Mutex.lock, it will also poison\n+    /// the lock, so subsequent readers and writers will both also fail.\n+    #[inline]\n+    pub fn write<'a>(&'a self) -> RWLockWriteGuard<'a, T> {\n+        let guard = self.lock.write();\n+\n+        // These two accesses are safe because we're guranteed at this point\n+        // that we have exclusive access to this rwlock. We are indeed able to\n+        // promote ourselves from &RWLock to `&mut T`\n+        let poison = unsafe { &mut *self.failed.get() };\n+        let data = unsafe { &mut *self.data.get() };\n+\n+        RWLockWriteGuard {\n+            data: data,\n+            cond: Condvar {\n+                name: \"RWLock\",\n+                poison: PoisonOnFail::new(poison, \"RWLock\"),\n+                inner: InnerRWLock(guard),\n+            },\n+        }\n+    }\n+\n+    /// Access the underlying data immutably. May run concurrently with other\n+    /// reading tasks.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Failing will unlock the lock while unwinding. However, unlike all other\n+    /// access modes, this will not poison the lock.\n+    pub fn read<'a>(&'a self) -> RWLockReadGuard<'a, T> {\n+        let guard = self.lock.read();\n+        PoisonOnFail::check(unsafe { *self.failed.get() }, \"RWLock\");\n+        RWLockReadGuard {\n+            guard: guard,\n+            data: unsafe { &*self.data.get() },\n+        }\n+    }\n+}\n+\n+impl<'a, T: Send + Share> RWLockWriteGuard<'a, T> {\n+    /// Consumes this write lock token, returning a new read lock token.\n+    ///\n+    /// This will allow pending readers to come into the lock.\n+    pub fn downgrade(self) -> RWLockReadGuard<'a, T> {\n+        let RWLockWriteGuard { data, cond } = self;\n+        // convert the data to read-only explicitly\n+        let data = &*data;\n+        let guard = match cond.inner {\n+            InnerMutex(..) => unreachable!(),\n+            InnerRWLock(guard) => guard.downgrade()\n+        };\n+        RWLockReadGuard { guard: guard, data: data }\n+    }\n+}\n+\n+// FIXME(#13042): these should all have T: Send + Share\n+impl<'a, T> Deref<T> for RWLockReadGuard<'a, T> {\n+    fn deref<'a>(&'a self) -> &'a T { self.data }\n+}\n+impl<'a, T> Deref<T> for RWLockWriteGuard<'a, T> {\n+    fn deref<'a>(&'a self) -> &'a T { &*self.data }\n+}\n+impl<'a, T> DerefMut<T> for RWLockWriteGuard<'a, T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T { &mut *self.data }\n+}\n+\n+/****************************************************************************\n+ * Barrier\n+ ****************************************************************************/\n+\n+/// A barrier enables multiple tasks to synchronize the beginning\n+/// of some computation.\n+///\n+/// ```rust\n+/// use sync::{Arc, Barrier};\n+///\n+/// let barrier = Arc::new(Barrier::new(10));\n+/// for _ in range(0, 10) {\n+///     let c = barrier.clone();\n+///     // The same messages will be printed together.\n+///     // You will NOT see any interleaving.\n+///     spawn(proc() {\n+///         println!(\"before wait\");\n+///         c.wait();\n+///         println!(\"after wait\");\n+///     });\n+/// }\n+/// ```\n+pub struct Barrier {\n+    priv lock: Mutex<BarrierState>,\n+    priv num_tasks: uint,\n+}\n+\n+// The inner state of a double barrier\n+struct BarrierState {\n+    count: uint,\n+    generation_id: uint,\n+}\n+\n+impl Barrier {\n+    /// Create a new barrier that can block a given number of tasks.\n+    pub fn new(num_tasks: uint) -> Barrier {\n+        Barrier {\n+            lock: Mutex::new(BarrierState {\n+                count: 0,\n+                generation_id: 0,\n+            }),\n+            num_tasks: num_tasks,\n+        }\n+    }\n+\n+    /// Block the current task until a certain number of tasks is waiting.\n+    pub fn wait(&self) {\n+        let mut lock = self.lock.lock();\n+        let local_gen = lock.generation_id;\n+        lock.count += 1;\n+        if lock.count < self.num_tasks {\n+            // We need a while loop to guard against spurious wakeups.\n+            // http://en.wikipedia.org/wiki/Spurious_wakeup\n+            while local_gen == lock.generation_id &&\n+                  lock.count < self.num_tasks {\n+                lock.cond.wait();\n+            }\n+        } else {\n+            lock.count = 0;\n+            lock.generation_id += 1;\n+            lock.cond.broadcast();\n+        }\n+    }\n+}\n+\n+/****************************************************************************\n+ * Tests\n+ ****************************************************************************/\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::comm::Empty;\n+    use std::task;\n+\n+    use arc::Arc;\n+    use super::{Mutex, Barrier, RWLock};\n+\n+    #[test]\n+    fn test_mutex_arc_condvar() {\n+        let arc = Arc::new(Mutex::new(false));\n+        let arc2 = arc.clone();\n+        let (tx, rx) = channel();\n+        task::spawn(proc() {\n+            // wait until parent gets in\n+            rx.recv();\n+            let mut lock = arc2.lock();\n+            *lock = true;\n+            lock.cond.signal();\n+        });\n+\n+        let lock = arc.lock();\n+        tx.send(());\n+        assert!(!*lock);\n+        while !*lock {\n+            lock.cond.wait();\n+        }\n+    }\n+\n+    #[test] #[should_fail]\n+    fn test_arc_condvar_poison() {\n+        let arc = Arc::new(Mutex::new(1));\n+        let arc2 = arc.clone();\n+        let (tx, rx) = channel();\n+\n+        spawn(proc() {\n+            rx.recv();\n+            let lock = arc2.lock();\n+            lock.cond.signal();\n+            // Parent should fail when it wakes up.\n+            fail!();\n+        });\n+\n+        let lock = arc.lock();\n+        tx.send(());\n+        while *lock == 1 {\n+            lock.cond.wait();\n+        }\n+    }\n+\n+    #[test] #[should_fail]\n+    fn test_mutex_arc_poison() {\n+        let arc = Arc::new(Mutex::new(1));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.lock();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.lock();\n+        assert_eq!(*lock, 1);\n+    }\n+\n+    #[test]\n+    fn test_mutex_arc_nested() {\n+        // Tests nested mutexes and access\n+        // to underlaying data.\n+        let arc = Arc::new(Mutex::new(1));\n+        let arc2 = Arc::new(Mutex::new(arc));\n+        task::spawn(proc() {\n+            let lock = arc2.lock();\n+            let lock2 = lock.deref().lock();\n+            assert_eq!(*lock2, 1);\n+        });\n+    }\n+\n+    #[test]\n+    fn test_mutex_arc_access_in_unwind() {\n+        let arc = Arc::new(Mutex::new(1i));\n+        let arc2 = arc.clone();\n+        let _ = task::try::<()>(proc() {\n+            struct Unwinder {\n+                i: Arc<Mutex<int>>,\n+            }\n+            impl Drop for Unwinder {\n+                fn drop(&mut self) {\n+                    let mut lock = self.i.lock();\n+                    *lock += 1;\n+                }\n+            }\n+            let _u = Unwinder { i: arc2 };\n+            fail!();\n+        });\n+        let lock = arc.lock();\n+        assert_eq!(*lock, 2);\n+    }\n+\n+    #[test] #[should_fail]\n+    fn test_rw_arc_poison_wr() {\n+        let arc = Arc::new(RWLock::new(1));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.write();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.read();\n+        assert_eq!(*lock, 1);\n+    }\n+    #[test] #[should_fail]\n+    fn test_rw_arc_poison_ww() {\n+        let arc = Arc::new(RWLock::new(1));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.write();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.write();\n+        assert_eq!(*lock, 1);\n+    }\n+    #[test]\n+    fn test_rw_arc_no_poison_rr() {\n+        let arc = Arc::new(RWLock::new(1));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.read();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.read();\n+        assert_eq!(*lock, 1);\n+    }\n+    #[test]\n+    fn test_rw_arc_no_poison_rw() {\n+        let arc = Arc::new(RWLock::new(1));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.read();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.write();\n+        assert_eq!(*lock, 1);\n+    }\n+    #[test]\n+    fn test_rw_arc_no_poison_dr() {\n+        let arc = Arc::new(RWLock::new(1));\n+        let arc2 = arc.clone();\n+        let _ = task::try(proc() {\n+            let lock = arc2.write().downgrade();\n+            assert_eq!(*lock, 2);\n+        });\n+        let lock = arc.write();\n+        assert_eq!(*lock, 1);\n+    }\n+\n+    #[test]\n+    fn test_rw_arc() {\n+        let arc = Arc::new(RWLock::new(0));\n+        let arc2 = arc.clone();\n+        let (tx, rx) = channel();\n+\n+        task::spawn(proc() {\n+            let mut lock = arc2.write();\n+            for _ in range(0, 10) {\n+                let tmp = *lock;\n+                *lock = -1;\n+                task::deschedule();\n+                *lock = tmp + 1;\n+            }\n+            tx.send(());\n+        });\n+\n+        // Readers try to catch the writer in the act\n+        let mut children = Vec::new();\n+        for _ in range(0, 5) {\n+            let arc3 = arc.clone();\n+            let mut builder = task::task();\n+            children.push(builder.future_result());\n+            builder.spawn(proc() {\n+                let lock = arc3.read();\n+                assert!(*lock >= 0);\n+            });\n+        }\n+\n+        // Wait for children to pass their asserts\n+        for r in children.mut_iter() {\n+            assert!(r.recv().is_ok());\n+        }\n+\n+        // Wait for writer to finish\n+        rx.recv();\n+        let lock = arc.read();\n+        assert_eq!(*lock, 10);\n+    }\n+\n+    #[test]\n+    fn test_rw_arc_access_in_unwind() {\n+        let arc = Arc::new(RWLock::new(1i));\n+        let arc2 = arc.clone();\n+        let _ = task::try::<()>(proc() {\n+            struct Unwinder {\n+                i: Arc<RWLock<int>>,\n+            }\n+            impl Drop for Unwinder {\n+                fn drop(&mut self) {\n+                    let mut lock = self.i.write();\n+                    *lock += 1;\n+                }\n+            }\n+            let _u = Unwinder { i: arc2 };\n+            fail!();\n+        });\n+        let lock = arc.read();\n+        assert_eq!(*lock, 2);\n+    }\n+\n+    #[test]\n+    fn test_rw_downgrade() {\n+        // (1) A downgrader gets in write mode and does cond.wait.\n+        // (2) A writer gets in write mode, sets state to 42, and does signal.\n+        // (3) Downgrader wakes, sets state to 31337.\n+        // (4) tells writer and all other readers to contend as it downgrades.\n+        // (5) Writer attempts to set state back to 42, while downgraded task\n+        //     and all reader tasks assert that it's 31337.\n+        let arc = Arc::new(RWLock::new(0));\n+\n+        // Reader tasks\n+        let mut reader_convos = Vec::new();\n+        for _ in range(0, 10) {\n+            let ((tx1, rx1), (tx2, rx2)) = (channel(), channel());\n+            reader_convos.push((tx1, rx2));\n+            let arcn = arc.clone();\n+            task::spawn(proc() {\n+                rx1.recv(); // wait for downgrader to give go-ahead\n+                let lock = arcn.read();\n+                assert_eq!(*lock, 31337);\n+                tx2.send(());\n+            });\n+        }\n+\n+        // Writer task\n+        let arc2 = arc.clone();\n+        let ((tx1, rx1), (tx2, rx2)) = (channel(), channel());\n+        task::spawn(proc() {\n+            rx1.recv();\n+            {\n+                let mut lock = arc2.write();\n+                assert_eq!(*lock, 0);\n+                *lock = 42;\n+                lock.cond.signal();\n+            }\n+            rx1.recv();\n+            {\n+                let mut lock = arc2.write();\n+                // This shouldn't happen until after the downgrade read\n+                // section, and all other readers, finish.\n+                assert_eq!(*lock, 31337);\n+                *lock = 42;\n+            }\n+            tx2.send(());\n+        });\n+\n+        // Downgrader (us)\n+        let mut lock = arc.write();\n+        tx1.send(()); // send to another writer who will wake us up\n+        while *lock == 0 {\n+            lock.cond.wait();\n+        }\n+        assert_eq!(*lock, 42);\n+        *lock = 31337;\n+        // send to other readers\n+        for &(ref mut rc, _) in reader_convos.mut_iter() {\n+            rc.send(())\n+        }\n+        let lock = lock.downgrade();\n+        // complete handshake with other readers\n+        for &(_, ref mut rp) in reader_convos.mut_iter() {\n+            rp.recv()\n+        }\n+        tx1.send(()); // tell writer to try again\n+        assert_eq!(*lock, 31337);\n+        drop(lock);\n+\n+        rx2.recv(); // complete handshake with writer\n+    }\n+\n+    #[cfg(test)]\n+    fn test_rw_write_cond_downgrade_read_race_helper() {\n+        // Tests that when a downgrader hands off the \"reader cloud\" lock\n+        // because of a contending reader, a writer can't race to get it\n+        // instead, which would result in readers_and_writers. This tests\n+        // the raw module rather than this one, but it's here because an\n+        // rwarc gives us extra shared state to help check for the race.\n+        let x = Arc::new(RWLock::new(true));\n+        let (tx, rx) = channel();\n+\n+        // writer task\n+        let xw = x.clone();\n+        task::spawn(proc() {\n+            let mut lock = xw.write();\n+            tx.send(()); // tell downgrader it's ok to go\n+            lock.cond.wait();\n+            // The core of the test is here: the condvar reacquire path\n+            // must involve order_lock, so that it cannot race with a reader\n+            // trying to receive the \"reader cloud lock hand-off\".\n+            *lock = false;\n+        });\n+\n+        rx.recv(); // wait for writer to get in\n+\n+        let lock = x.write();\n+        assert!(*lock);\n+        // make writer contend in the cond-reacquire path\n+        lock.cond.signal();\n+        // make a reader task to trigger the \"reader cloud lock\" handoff\n+        let xr = x.clone();\n+        let (tx, rx) = channel();\n+        task::spawn(proc() {\n+            tx.send(());\n+            drop(xr.read());\n+        });\n+        rx.recv(); // wait for reader task to exist\n+\n+        let lock = lock.downgrade();\n+        // if writer mistakenly got in, make sure it mutates state\n+        // before we assert on it\n+        for _ in range(0, 5) { task::deschedule(); }\n+        // make sure writer didn't get in.\n+        assert!(*lock);\n+    }\n+    #[test]\n+    fn test_rw_write_cond_downgrade_read_race() {\n+        // Ideally the above test case would have deschedule statements in it\n+        // that helped to expose the race nearly 100% of the time... but adding\n+        // deschedules in the intuitively-right locations made it even less\n+        // likely, and I wasn't sure why :( . This is a mediocre \"next best\"\n+        // option.\n+        for _ in range(0, 8) {\n+            test_rw_write_cond_downgrade_read_race_helper();\n+        }\n+    }\n+\n+    /************************************************************************\n+     * Barrier tests\n+     ************************************************************************/\n+    #[test]\n+    fn test_barrier() {\n+        let barrier = Arc::new(Barrier::new(10));\n+        let (tx, rx) = channel();\n+\n+        for _ in range(0, 9) {\n+            let c = barrier.clone();\n+            let tx = tx.clone();\n+            spawn(proc() {\n+                c.wait();\n+                tx.send(true);\n+            });\n+        }\n+\n+        // At this point, all spawned tasks should be blocked,\n+        // so we shouldn't get anything from the port\n+        assert!(match rx.try_recv() {\n+            Empty => true,\n+            _ => false,\n+        });\n+\n+        barrier.wait();\n+        // Now, the barrier is cleared and we should get data.\n+        for _ in range(0, 9) {\n+            rx.recv();\n+        }\n+    }\n+}\n+"}]}