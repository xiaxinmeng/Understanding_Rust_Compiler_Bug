{"sha": "510d6b8afbb6fe956c442a8cfcb838b9aea280da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMGQ2YjhhZmJiNmZlOTU2YzQ0MmE4Y2ZjYjgzOGI5YWVhMjgwZGE=", "commit": {"author": {"name": "Tatsuyuki Ishi", "email": "ishitatsuyuki@gmail.com", "date": "2017-05-13T05:21:35Z"}, "committer": {"name": "Tatsuyuki Ishi", "email": "ishitatsuyuki@gmail.com", "date": "2017-05-17T15:30:55Z"}, "message": "Move submodule initialization to bootstrap.py", "tree": {"sha": "51df18b299c36456e97a616e9d8a1f75dbe26f61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51df18b299c36456e97a616e9d8a1f75dbe26f61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/510d6b8afbb6fe956c442a8cfcb838b9aea280da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/510d6b8afbb6fe956c442a8cfcb838b9aea280da", "html_url": "https://github.com/rust-lang/rust/commit/510d6b8afbb6fe956c442a8cfcb838b9aea280da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/510d6b8afbb6fe956c442a8cfcb838b9aea280da/comments", "author": {"login": "ishitatsuyuki", "id": 12389383, "node_id": "MDQ6VXNlcjEyMzg5Mzgz", "avatar_url": "https://avatars.githubusercontent.com/u/12389383?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ishitatsuyuki", "html_url": "https://github.com/ishitatsuyuki", "followers_url": "https://api.github.com/users/ishitatsuyuki/followers", "following_url": "https://api.github.com/users/ishitatsuyuki/following{/other_user}", "gists_url": "https://api.github.com/users/ishitatsuyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/ishitatsuyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ishitatsuyuki/subscriptions", "organizations_url": "https://api.github.com/users/ishitatsuyuki/orgs", "repos_url": "https://api.github.com/users/ishitatsuyuki/repos", "events_url": "https://api.github.com/users/ishitatsuyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/ishitatsuyuki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ishitatsuyuki", "id": 12389383, "node_id": "MDQ6VXNlcjEyMzg5Mzgz", "avatar_url": "https://avatars.githubusercontent.com/u/12389383?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ishitatsuyuki", "html_url": "https://github.com/ishitatsuyuki", "followers_url": "https://api.github.com/users/ishitatsuyuki/followers", "following_url": "https://api.github.com/users/ishitatsuyuki/following{/other_user}", "gists_url": "https://api.github.com/users/ishitatsuyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/ishitatsuyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ishitatsuyuki/subscriptions", "organizations_url": "https://api.github.com/users/ishitatsuyuki/orgs", "repos_url": "https://api.github.com/users/ishitatsuyuki/repos", "events_url": "https://api.github.com/users/ishitatsuyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/ishitatsuyuki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e119a6390166c97f16e06c26232fdc9b97d5d633", "url": "https://api.github.com/repos/rust-lang/rust/commits/e119a6390166c97f16e06c26232fdc9b97d5d633", "html_url": "https://github.com/rust-lang/rust/commit/e119a6390166c97f16e06c26232fdc9b97d5d633"}], "stats": {"total": 158, "additions": 37, "deletions": 121}, "files": [{"sha": "d7a15864ef75fe158963b297049bc99387f7f6cf", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/510d6b8afbb6fe956c442a8cfcb838b9aea280da/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/510d6b8afbb6fe956c442a8cfcb838b9aea280da/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=510d6b8afbb6fe956c442a8cfcb838b9aea280da", "patch": "@@ -14,6 +14,7 @@\n import datetime\n import hashlib\n import os\n+import re\n import shutil\n import subprocess\n import sys\n@@ -297,8 +298,10 @@ def bin_root(self):\n \n     def get_toml(self, key):\n         for line in self.config_toml.splitlines():\n-            if line.startswith(key + ' ='):\n-                return self.get_string(line)\n+            match = re.match(r'^{}\\s*=(.*)$'.format(key), line)\n+            if match is not None:\n+                value = match.group(1)\n+                return self.get_string(value) or value.strip()\n         return None\n \n     def get_mk(self, key):\n@@ -329,6 +332,8 @@ def rustc(self):\n \n     def get_string(self, line):\n         start = line.find('\"')\n+        if start == -1:\n+            return None\n         end = start + 1 + line[start + 1:].find('\"')\n         return line[start + 1:end]\n \n@@ -386,7 +391,7 @@ def build_bootstrap(self):\n             args.append(\"--frozen\")\n         self.run(args, env)\n \n-    def run(self, args, env):\n+    def run(self, args, env=None):\n         proc = subprocess.Popen(args, env=env)\n         ret = proc.wait()\n         if ret != 0:\n@@ -529,6 +534,32 @@ def build_triple(self):\n \n         return \"{}-{}\".format(cputype, ostype)\n \n+    def update_submodules(self):\n+        if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n+            self.get_toml('submodules') == \"false\" or \\\n+            self.get_mk('CFG_DISABLE_MANAGE_SUBMODULES') == \"1\":\n+            return\n+\n+        print('Updating submodules')\n+        self.run([\"git\", \"-C\", self.rust_root, \"submodule\", \"-q\", \"sync\"])\n+        # FIXME: nobody does, but this won't work well with whitespace in\n+        # submodule path\n+        submodules = [s.split()[1] for s in subprocess.check_output(\n+            [\"git\", \"config\", \"--file\", os.path.join(\n+                self.rust_root, \".gitmodules\"), \"--get-regexp\", \"path\"]).splitlines()]\n+        for module in submodules:\n+            if module.endswith(b\"llvm\") and \\\n+                (self.get_toml('llvm-config') or self.get_mk('CFG_LLVM_ROOT')):\n+                continue\n+            if module.endswith(b\"jemalloc\") and \\\n+                (self.get_toml('jemalloc') or self.get_mk('CFG_JEMALLOC_ROOT')):\n+                continue\n+            self.run([\"git\", \"-C\", self.rust_root,\n+                      \"submodule\", \"update\", \"--init\", module])\n+        self.run([\"git\", \"-C\", self.rust_root, \"submodule\", \"-q\",\n+                  \"foreach\", \"git\", \"reset\", \"-q\", \"--hard\"])\n+        self.run([\"git\", \"-C\", self.rust_root, \"submodule\",\n+                  \"-q\", \"foreach\", \"git\", \"clean\", \"-qdfx\"])\n def bootstrap():\n     parser = argparse.ArgumentParser(description='Build rust')\n     parser.add_argument('--config')\n@@ -597,6 +628,8 @@ def bootstrap():\n     else:\n         rb._download_url = 'https://static.rust-lang.org'\n \n+    rb.update_submodules()\n+\n     # Fetch/build the bootstrap\n     rb.build = rb.build_triple()\n     rb.download_stage0()"}, {"sha": "ca9de43f542193364b1806fe62f8f78be35ebb07", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 118, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/510d6b8afbb6fe956c442a8cfcb838b9aea280da/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/510d6b8afbb6fe956c442a8cfcb838b9aea280da/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=510d6b8afbb6fe956c442a8cfcb838b9aea280da", "patch": "@@ -82,7 +82,7 @@ use std::env;\n use std::ffi::OsString;\n use std::fs::{self, File};\n use std::io::Read;\n-use std::path::{Component, PathBuf, Path};\n+use std::path::{PathBuf, Path};\n use std::process::Command;\n \n use build_helper::{run_silent, run_suppressed, output, mtime};\n@@ -285,129 +285,12 @@ impl Build {\n             self.verbose(&format!(\"auto-detected local-rebuild {}\", local_release));\n             self.local_rebuild = true;\n         }\n-        self.verbose(\"updating submodules\");\n-        self.update_submodules();\n         self.verbose(\"learning about cargo\");\n         metadata::build(self);\n \n         step::run(self);\n     }\n \n-    /// Updates all git submodules that we have.\n-    ///\n-    /// This will detect if any submodules are out of date an run the necessary\n-    /// commands to sync them all with upstream.\n-    fn update_submodules(&self) {\n-        struct Submodule<'a> {\n-            path: &'a Path,\n-            state: State,\n-        }\n-\n-        enum State {\n-            // The submodule may have staged/unstaged changes\n-            MaybeDirty,\n-            // Or could be initialized but never updated\n-            NotInitialized,\n-            // The submodule, itself, has extra commits but those changes haven't been commited to\n-            // the (outer) git repository\n-            OutOfSync,\n-        }\n-\n-        if !self.src_is_git || !self.config.submodules {\n-            return\n-        }\n-        let git = || {\n-            let mut cmd = Command::new(\"git\");\n-            cmd.current_dir(&self.src);\n-            return cmd\n-        };\n-        let git_submodule = || {\n-            let mut cmd = Command::new(\"git\");\n-            cmd.current_dir(&self.src).arg(\"submodule\");\n-            return cmd\n-        };\n-\n-        // FIXME: this takes a seriously long time to execute on Windows and a\n-        //        nontrivial amount of time on Unix, we should have a better way\n-        //        of detecting whether we need to run all the submodule commands\n-        //        below.\n-        let out = output(git_submodule().arg(\"status\"));\n-        let mut submodules = vec![];\n-        for line in out.lines() {\n-            // NOTE `git submodule status` output looks like this:\n-            //\n-            // -5066b7dcab7e700844b0e2ba71b8af9dc627a59b src/liblibc\n-            // +b37ef24aa82d2be3a3cc0fe89bf82292f4ca181c src/compiler-rt (remotes/origin/..)\n-            //  e058ca661692a8d01f8cf9d35939dfe3105ce968 src/jemalloc (3.6.0-533-ge058ca6)\n-            //\n-            // The first character can be '-', '+' or ' ' and denotes the `State` of the submodule\n-            // Right next to this character is the SHA-1 of the submodule HEAD\n-            // And after that comes the path to the submodule\n-            let path = Path::new(line[1..].split(' ').skip(1).next().unwrap());\n-            let state = if line.starts_with('-') {\n-                State::NotInitialized\n-            } else if line.starts_with('+') {\n-                State::OutOfSync\n-            } else if line.starts_with(' ') {\n-                State::MaybeDirty\n-            } else {\n-                panic!(\"unexpected git submodule state: {:?}\", line.chars().next());\n-            };\n-\n-            submodules.push(Submodule { path: path, state: state })\n-        }\n-\n-        self.run(git_submodule().arg(\"sync\"));\n-\n-        for submodule in submodules {\n-            // If using llvm-root then don't touch the llvm submodule.\n-            if submodule.path.components().any(|c| c == Component::Normal(\"llvm\".as_ref())) &&\n-                self.config.target_config.get(&self.config.build)\n-                    .and_then(|c| c.llvm_config.as_ref()).is_some()\n-            {\n-                continue\n-            }\n-\n-            if submodule.path.components().any(|c| c == Component::Normal(\"jemalloc\".as_ref())) &&\n-                !self.config.use_jemalloc\n-            {\n-                continue\n-            }\n-\n-            // `submodule.path` is the relative path to a submodule (from the repository root)\n-            // `submodule_path` is the path to a submodule from the cwd\n-\n-            // use `submodule.path` when e.g. executing a submodule specific command from the\n-            // repository root\n-            // use `submodule_path` when e.g. executing a normal git command for the submodule\n-            // (set via `current_dir`)\n-            let submodule_path = self.src.join(submodule.path);\n-\n-            match submodule.state {\n-                State::MaybeDirty => {\n-                    // drop staged changes\n-                    self.run(git().current_dir(&submodule_path)\n-                                  .args(&[\"reset\", \"--hard\"]));\n-                    // drops unstaged changes\n-                    self.run(git().current_dir(&submodule_path)\n-                                  .args(&[\"clean\", \"-fdx\"]));\n-                },\n-                State::NotInitialized => {\n-                    self.run(git_submodule().arg(\"init\").arg(submodule.path));\n-                    self.run(git_submodule().arg(\"update\").arg(submodule.path));\n-                },\n-                State::OutOfSync => {\n-                    // drops submodule commits that weren't reported to the (outer) git repository\n-                    self.run(git_submodule().arg(\"update\").arg(submodule.path));\n-                    self.run(git().current_dir(&submodule_path)\n-                                  .args(&[\"reset\", \"--hard\"]));\n-                    self.run(git().current_dir(&submodule_path)\n-                                  .args(&[\"clean\", \"-fdx\"]));\n-                },\n-            }\n-        }\n-    }\n-\n     /// Clear out `dir` if `input` is newer.\n     ///\n     /// After this executes, it will also ensure that `dir` exists."}]}