{"sha": "e821a6ef78b915305c4d659c813f27d4180baec0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MjFhNmVmNzhiOTE1MzA1YzRkNjU5YzgxM2YyN2Q0MTgwYmFlYzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-03T06:29:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-03T06:29:42Z"}, "message": "Auto merge of #80261 - GuillaumeGomez:attr-rework, r=jyn514\n\nrustdoc DocFragment rework\n\nKind of a follow-up of #80119.\n\nA few things are happening in this PR. I'm not sure about the impact on perf though so I'm very interested about that too (if the perf is worse, then we can just close this PR).\n\nThe idea here is mostly about reducing the memory usage by relying even more on `Symbol` instead of `String`. The only issue is that `DocFragment` has 3 modifications performed on it:\n 1. Unindenting\n 2. Collapsing similar comments into one\n 3. \"Beautifying\" (weird JS-like comments handling).\n\nTo do so, I saved the information about unindent and the \"collapse\" is now on-demand (which is why I'm not sure the perf will be better, it has to be run multiple times...).\n\nr? `@jyn514`", "tree": {"sha": "0b81ff4614f0fe616589649195ea7920c8a5f870", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b81ff4614f0fe616589649195ea7920c8a5f870"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e821a6ef78b915305c4d659c813f27d4180baec0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e821a6ef78b915305c4d659c813f27d4180baec0", "html_url": "https://github.com/rust-lang/rust/commit/e821a6ef78b915305c4d659c813f27d4180baec0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e821a6ef78b915305c4d659c813f27d4180baec0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05dfaba442258c3378070c0af41cd8b0735f7a0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/05dfaba442258c3378070c0af41cd8b0735f7a0a", "html_url": "https://github.com/rust-lang/rust/commit/05dfaba442258c3378070c0af41cd8b0735f7a0a"}, {"sha": "df2df14424b6fa3b2b2a8a8cdd6cb2307ddbb474", "url": "https://api.github.com/repos/rust-lang/rust/commits/df2df14424b6fa3b2b2a8a8cdd6cb2307ddbb474", "html_url": "https://github.com/rust-lang/rust/commit/df2df14424b6fa3b2b2a8a8cdd6cb2307ddbb474"}], "stats": {"total": 309, "additions": 145, "deletions": 164}, "files": [{"sha": "8d5ef1ed28c82abc9b7af6fea3e5e8fd2f0ab88e", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 109, "deletions": 22, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=e821a6ef78b915305c4d659c813f27d4180baec0", "patch": "@@ -122,7 +122,7 @@ impl Item {\n \n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n-    crate fn doc_value(&self) -> Option<&str> {\n+    crate fn doc_value(&self) -> Option<String> {\n         self.attrs.doc_value()\n     }\n \n@@ -469,31 +469,66 @@ crate struct DocFragment {\n     /// This allows distinguishing between the original documentation and a pub re-export.\n     /// If it is `None`, the item was not re-exported.\n     crate parent_module: Option<DefId>,\n-    crate doc: String,\n+    crate doc: Symbol,\n     crate kind: DocFragmentKind,\n+    crate need_backline: bool,\n+    crate indent: usize,\n }\n \n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n crate enum DocFragmentKind {\n     /// A doc fragment created from a `///` or `//!` doc comment.\n     SugaredDoc,\n     /// A doc fragment created from a \"raw\" `#[doc=\"\"]` attribute.\n     RawDoc,\n     /// A doc fragment created from a `#[doc(include=\"filename\")]` attribute. Contains both the\n     /// given filename and the file contents.\n-    Include { filename: String },\n+    Include { filename: Symbol },\n+}\n+\n+// The goal of this function is to apply the `DocFragment` transformations that are required when\n+// transforming into the final markdown. So the transformations in here are:\n+//\n+// * Applying the computed indent to each lines in each doc fragment (a `DocFragment` can contain\n+//   multiple lines in case of `#[doc = \"\"]`).\n+// * Adding backlines between `DocFragment`s and adding an extra one if required (stored in the\n+//   `need_backline` field).\n+fn add_doc_fragment(out: &mut String, frag: &DocFragment) {\n+    let s = frag.doc.as_str();\n+    let mut iter = s.lines().peekable();\n+    while let Some(line) = iter.next() {\n+        if line.chars().any(|c| !c.is_whitespace()) {\n+            assert!(line.len() >= frag.indent);\n+            out.push_str(&line[frag.indent..]);\n+        } else {\n+            out.push_str(line);\n+        }\n+        if iter.peek().is_some() {\n+            out.push('\\n');\n+        }\n+    }\n+    if frag.need_backline {\n+        out.push('\\n');\n+    }\n }\n \n impl<'a> FromIterator<&'a DocFragment> for String {\n     fn from_iter<T>(iter: T) -> Self\n     where\n         T: IntoIterator<Item = &'a DocFragment>,\n     {\n+        let mut prev_kind: Option<DocFragmentKind> = None;\n         iter.into_iter().fold(String::new(), |mut acc, frag| {\n-            if !acc.is_empty() {\n+            if !acc.is_empty()\n+                && prev_kind\n+                    .take()\n+                    .map(|p| matches!(p, DocFragmentKind::Include { .. }) && p != frag.kind)\n+                    .unwrap_or(false)\n+            {\n                 acc.push('\\n');\n             }\n-            acc.push_str(&frag.doc);\n+            add_doc_fragment(&mut acc, &frag);\n+            prev_kind = Some(frag.kind);\n             acc\n         })\n     }\n@@ -565,25 +600,25 @@ impl Attributes {\n     /// Reads a `MetaItem` from within an attribute, looks for whether it is a\n     /// `#[doc(include=\"file\")]`, and returns the filename and contents of the file as loaded from\n     /// its expansion.\n-    crate fn extract_include(mi: &ast::MetaItem) -> Option<(String, String)> {\n+    crate fn extract_include(mi: &ast::MetaItem) -> Option<(Symbol, Symbol)> {\n         mi.meta_item_list().and_then(|list| {\n             for meta in list {\n                 if meta.has_name(sym::include) {\n                     // the actual compiled `#[doc(include=\"filename\")]` gets expanded to\n                     // `#[doc(include(file=\"filename\", contents=\"file contents\")]` so we need to\n                     // look for that instead\n                     return meta.meta_item_list().and_then(|list| {\n-                        let mut filename: Option<String> = None;\n-                        let mut contents: Option<String> = None;\n+                        let mut filename: Option<Symbol> = None;\n+                        let mut contents: Option<Symbol> = None;\n \n                         for it in list {\n                             if it.has_name(sym::file) {\n                                 if let Some(name) = it.value_str() {\n-                                    filename = Some(name.to_string());\n+                                    filename = Some(name);\n                                 }\n                             } else if it.has_name(sym::contents) {\n                                 if let Some(docs) = it.value_str() {\n-                                    contents = Some(docs.to_string());\n+                                    contents = Some(docs);\n                                 }\n                             }\n                         }\n@@ -622,30 +657,51 @@ impl Attributes {\n         attrs: &[ast::Attribute],\n         additional_attrs: Option<(&[ast::Attribute], DefId)>,\n     ) -> Attributes {\n-        let mut doc_strings = vec![];\n+        let mut doc_strings: Vec<DocFragment> = vec![];\n         let mut sp = None;\n         let mut cfg = Cfg::True;\n         let mut doc_line = 0;\n \n+        fn update_need_backline(doc_strings: &mut Vec<DocFragment>, frag: &DocFragment) {\n+            if let Some(prev) = doc_strings.last_mut() {\n+                if matches!(prev.kind, DocFragmentKind::Include { .. })\n+                    || prev.kind != frag.kind\n+                    || prev.parent_module != frag.parent_module\n+                {\n+                    // add a newline for extra padding between segments\n+                    prev.need_backline = prev.kind == DocFragmentKind::SugaredDoc\n+                        || prev.kind == DocFragmentKind::RawDoc\n+                } else {\n+                    prev.need_backline = true;\n+                }\n+            }\n+        }\n+\n         let clean_attr = |(attr, parent_module): (&ast::Attribute, _)| {\n             if let Some(value) = attr.doc_str() {\n                 trace!(\"got doc_str={:?}\", value);\n-                let value = beautify_doc_string(value).to_string();\n+                let value = beautify_doc_string(value);\n                 let kind = if attr.is_doc_comment() {\n                     DocFragmentKind::SugaredDoc\n                 } else {\n                     DocFragmentKind::RawDoc\n                 };\n \n                 let line = doc_line;\n-                doc_line += value.lines().count();\n-                doc_strings.push(DocFragment {\n+                doc_line += value.as_str().lines().count();\n+                let frag = DocFragment {\n                     line,\n                     span: attr.span,\n                     doc: value,\n                     kind,\n                     parent_module,\n-                });\n+                    need_backline: false,\n+                    indent: 0,\n+                };\n+\n+                update_need_backline(&mut doc_strings, &frag);\n+\n+                doc_strings.push(frag);\n \n                 if sp.is_none() {\n                     sp = Some(attr.span);\n@@ -663,14 +719,18 @@ impl Attributes {\n                         } else if let Some((filename, contents)) = Attributes::extract_include(&mi)\n                         {\n                             let line = doc_line;\n-                            doc_line += contents.lines().count();\n-                            doc_strings.push(DocFragment {\n+                            doc_line += contents.as_str().lines().count();\n+                            let frag = DocFragment {\n                                 line,\n                                 span: attr.span,\n                                 doc: contents,\n                                 kind: DocFragmentKind::Include { filename },\n                                 parent_module,\n-                            });\n+                                need_backline: false,\n+                                indent: 0,\n+                            };\n+                            update_need_backline(&mut doc_strings, &frag);\n+                            doc_strings.push(frag);\n                         }\n                     }\n                 }\n@@ -721,14 +781,41 @@ impl Attributes {\n \n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n-    crate fn doc_value(&self) -> Option<&str> {\n-        self.doc_strings.first().map(|s| s.doc.as_str())\n+    crate fn doc_value(&self) -> Option<String> {\n+        let mut iter = self.doc_strings.iter();\n+\n+        let ori = iter.next()?;\n+        let mut out = String::new();\n+        add_doc_fragment(&mut out, &ori);\n+        while let Some(new_frag) = iter.next() {\n+            if matches!(ori.kind, DocFragmentKind::Include { .. })\n+                || new_frag.kind != ori.kind\n+                || new_frag.parent_module != ori.parent_module\n+            {\n+                break;\n+            }\n+            add_doc_fragment(&mut out, &new_frag);\n+        }\n+        if out.is_empty() { None } else { Some(out) }\n+    }\n+\n+    /// Return the doc-comments on this item, grouped by the module they came from.\n+    ///\n+    /// The module can be different if this is a re-export with added documentation.\n+    crate fn collapsed_doc_value_by_module_level(&self) -> FxHashMap<Option<DefId>, String> {\n+        let mut ret = FxHashMap::default();\n+\n+        for new_frag in self.doc_strings.iter() {\n+            let out = ret.entry(new_frag.parent_module).or_default();\n+            add_doc_fragment(out, &new_frag);\n+        }\n+        ret\n     }\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n     /// with newlines.\n     crate fn collapsed_doc_value(&self) -> Option<String> {\n-        if !self.doc_strings.is_empty() { Some(self.doc_strings.iter().collect()) } else { None }\n+        if self.doc_strings.is_empty() { None } else { Some(self.doc_strings.iter().collect()) }\n     }\n \n     /// Gets links as a vector"}, {"sha": "4aeca0faea76a362350e2ac0a524e962b9b6dcfb", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e821a6ef78b915305c4d659c813f27d4180baec0", "patch": "@@ -525,7 +525,7 @@ crate fn run_global_ctxt(\n     let mut krate = tcx.sess.time(\"clean_crate\", || clean::krate(&mut ctxt));\n \n     if let Some(ref m) = krate.module {\n-        if let None | Some(\"\") = m.doc_value() {\n+        if m.doc_value().map(|d| d.is_empty()).unwrap_or(true) {\n             let help = \"The following guide may be of use:\\n\\\n                 https://doc.rust-lang.org/nightly/rustdoc/how-to-write-documentation.html\";\n             tcx.struct_lint_node(\n@@ -623,6 +623,9 @@ crate fn run_global_ctxt(\n \n     ctxt.sess().abort_if_errors();\n \n+    // The main crate doc comments are always collapsed.\n+    krate.collapsed = true;\n+\n     (krate, ctxt.renderinfo.into_inner(), ctxt.render_options)\n }\n "}, {"sha": "09627be9701c9f9c0f25f52af504acb1fe49a5cc", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=e821a6ef78b915305c4d659c813f27d4180baec0", "patch": "@@ -987,7 +987,6 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n             self.collector.names.push(name);\n         }\n \n-        attrs.collapse_doc_comments();\n         attrs.unindent_doc_comments();\n         // The collapse-docs pass won't combine sugared/raw doc attributes, or included files with\n         // anything else, this will combine them for us."}, {"sha": "c1f8b12cac497315533a109957c2597f14ab9e7a", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=e821a6ef78b915305c4d659c813f27d4180baec0", "patch": "@@ -316,7 +316,7 @@ impl DocFolder for Cache {\n                             path: path.join(\"::\"),\n                             desc: item\n                                 .doc_value()\n-                                .map_or_else(|| String::new(), short_markdown_summary),\n+                                .map_or_else(String::new, |x| short_markdown_summary(&x.as_str())),\n                             parent,\n                             parent_idx: None,\n                             search_type: get_index_search_type(&item),"}, {"sha": "497cbbb4250a6f62ea68d84acb284a70f5241464", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=e821a6ef78b915305c4d659c813f27d4180baec0", "patch": "@@ -78,7 +78,7 @@ crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n                 ty: item.type_(),\n                 name: item.name.unwrap().to_string(),\n                 path: fqp[..fqp.len() - 1].join(\"::\"),\n-                desc: item.doc_value().map_or_else(|| String::new(), short_markdown_summary),\n+                desc: item.doc_value().map_or_else(String::new, |s| short_markdown_summary(&s)),\n                 parent: Some(did),\n                 parent_idx: None,\n                 search_type: get_index_search_type(&item),\n@@ -127,7 +127,7 @@ crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let crate_doc = krate\n         .module\n         .as_ref()\n-        .map(|module| module.doc_value().map_or_else(|| String::new(), short_markdown_summary))\n+        .map(|module| module.doc_value().map_or_else(String::new, |s| short_markdown_summary(&s)))\n         .unwrap_or_default();\n \n     #[derive(Serialize)]"}, {"sha": "1c713df927637f4f1c5ed5792dc5ccdba345e012", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=e821a6ef78b915305c4d659c813f27d4180baec0", "patch": "@@ -30,7 +30,6 @@ crate mod cache;\n #[cfg(test)]\n mod tests;\n \n-use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n use std::collections::{BTreeMap, VecDeque};\n@@ -198,12 +197,8 @@ impl SharedContext<'_> {\n \n     /// Based on whether the `collapse-docs` pass was run, return either the `doc_value` or the\n     /// `collapsed_doc_value` of the given item.\n-    crate fn maybe_collapsed_doc_value<'a>(&self, item: &'a clean::Item) -> Option<Cow<'a, str>> {\n-        if self.collapsed {\n-            item.collapsed_doc_value().map(|s| s.into())\n-        } else {\n-            item.doc_value().map(|s| s.into())\n-        }\n+    crate fn maybe_collapsed_doc_value<'a>(&self, item: &'a clean::Item) -> Option<String> {\n+        if self.collapsed { item.collapsed_doc_value() } else { item.doc_value() }\n     }\n }\n \n@@ -1622,7 +1617,7 @@ impl Context<'_> {\n             let short = short.to_string();\n             map.entry(short).or_default().push((\n                 myname,\n-                Some(item.doc_value().map_or_else(|| String::new(), plain_text_summary)),\n+                Some(item.doc_value().map_or_else(String::new, |s| plain_text_summary(&s))),\n             ));\n         }\n \n@@ -1880,7 +1875,7 @@ fn document_short(\n         return;\n     }\n     if let Some(s) = item.doc_value() {\n-        let mut summary_html = MarkdownSummaryLine(s, &item.links()).into_string();\n+        let mut summary_html = MarkdownSummaryLine(&s, &item.links()).into_string();\n \n         if s.contains('\\n') {\n             let link = format!(r#\" <a href=\"{}\">Read more</a>\"#, naive_assoc_href(item, link));\n@@ -2197,7 +2192,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 let stab = myitem.stability_class(cx.tcx());\n                 let add = if stab.is_some() { \" \" } else { \"\" };\n \n-                let doc_value = myitem.doc_value().unwrap_or(\"\");\n+                let doc_value = myitem.doc_value().unwrap_or_default();\n                 write!(\n                     w,\n                     \"<tr class=\\\"{stab}{add}module-item\\\">\\\n@@ -2207,7 +2202,7 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                      </tr>\",\n                     name = *myitem.name.as_ref().unwrap(),\n                     stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n-                    docs = MarkdownSummaryLine(doc_value, &myitem.links()).into_string(),\n+                    docs = MarkdownSummaryLine(&doc_value, &myitem.links()).into_string(),\n                     class = myitem.type_(),\n                     add = add,\n                     stab = stab.unwrap_or_else(String::new),"}, {"sha": "05a3a15adac800f127d2f064ea41af7a1eb1e047", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=e821a6ef78b915305c4d659c813f27d4180baec0", "patch": "@@ -235,12 +235,7 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n                 let mut tests = Tests { found_tests: 0 };\n \n                 find_testable_code(\n-                    &i.attrs\n-                        .doc_strings\n-                        .iter()\n-                        .map(|d| d.doc.as_str())\n-                        .collect::<Vec<_>>()\n-                        .join(\"\\n\"),\n+                    &i.attrs.collapsed_doc_value().unwrap_or_default(),\n                     &mut tests,\n                     ErrorCodes::No,\n                     false,"}, {"sha": "e1ba75baa0fa48ac47e6e9355716a436921a7e1e", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/05dfaba442258c3378070c0af41cd8b0735f7a0a/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05dfaba442258c3378070c0af41cd8b0735f7a0a/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=05dfaba442258c3378070c0af41cd8b0735f7a0a", "patch": "@@ -1,72 +0,0 @@\n-use crate::clean::{self, DocFragment, DocFragmentKind, Item};\n-use crate::core::DocContext;\n-use crate::fold;\n-use crate::fold::DocFolder;\n-use crate::passes::Pass;\n-\n-use std::mem::take;\n-\n-crate const COLLAPSE_DOCS: Pass = Pass {\n-    name: \"collapse-docs\",\n-    run: collapse_docs,\n-    description: \"concatenates all document attributes into one document attribute\",\n-};\n-\n-crate fn collapse_docs(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n-    let mut krate = Collapser.fold_crate(krate);\n-    krate.collapsed = true;\n-    krate\n-}\n-\n-struct Collapser;\n-\n-impl fold::DocFolder for Collapser {\n-    fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-        i.attrs.collapse_doc_comments();\n-        Some(self.fold_item_recur(i))\n-    }\n-}\n-\n-fn collapse(doc_strings: &mut Vec<DocFragment>) {\n-    let mut docs = vec![];\n-    let mut last_frag: Option<DocFragment> = None;\n-\n-    for frag in take(doc_strings) {\n-        if let Some(mut curr_frag) = last_frag.take() {\n-            let curr_kind = &curr_frag.kind;\n-            let new_kind = &frag.kind;\n-\n-            if matches!(*curr_kind, DocFragmentKind::Include { .. })\n-                || curr_kind != new_kind\n-                || curr_frag.parent_module != frag.parent_module\n-            {\n-                if *curr_kind == DocFragmentKind::SugaredDoc\n-                    || *curr_kind == DocFragmentKind::RawDoc\n-                {\n-                    // add a newline for extra padding between segments\n-                    curr_frag.doc.push('\\n');\n-                }\n-                docs.push(curr_frag);\n-                last_frag = Some(frag);\n-            } else {\n-                curr_frag.doc.push('\\n');\n-                curr_frag.doc.push_str(&frag.doc);\n-                curr_frag.span = curr_frag.span.to(frag.span);\n-                last_frag = Some(curr_frag);\n-            }\n-        } else {\n-            last_frag = Some(frag);\n-        }\n-    }\n-\n-    if let Some(frag) = last_frag.take() {\n-        docs.push(frag);\n-    }\n-    *doc_strings = docs;\n-}\n-\n-impl clean::Attributes {\n-    crate fn collapse_doc_comments(&mut self) {\n-        collapse(&mut self.doc_strings);\n-    }\n-}"}, {"sha": "6fcec6946ae7980d62804f9089acc97446387871", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=e821a6ef78b915305c4d659c813f27d4180baec0", "patch": "@@ -891,37 +891,20 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         // In the presence of re-exports, this is not the same as the module of the item.\n         // Rather than merging all documentation into one, resolve it one attribute at a time\n         // so we know which module it came from.\n-        let mut attrs = item.attrs.doc_strings.iter().peekable();\n-        while let Some(attr) = attrs.next() {\n-            // `collapse_docs` does not have the behavior we want:\n-            // we want `///` and `#[doc]` to count as the same attribute,\n-            // but currently it will treat them as separate.\n-            // As a workaround, combine all attributes with the same parent module into the same attribute.\n-            let mut combined_docs = attr.doc.clone();\n-            loop {\n-                match attrs.peek() {\n-                    Some(next) if next.parent_module == attr.parent_module => {\n-                        combined_docs.push('\\n');\n-                        combined_docs.push_str(&attrs.next().unwrap().doc);\n-                    }\n-                    _ => break,\n-                }\n-            }\n-            debug!(\"combined_docs={}\", combined_docs);\n+        for (parent_module, doc) in item.attrs.collapsed_doc_value_by_module_level() {\n+            debug!(\"combined_docs={}\", doc);\n \n-            let (krate, parent_node) = if let Some(id) = attr.parent_module {\n-                trace!(\"docs {:?} came from {:?}\", attr.doc, id);\n+            let (krate, parent_node) = if let Some(id) = parent_module {\n                 (id.krate, Some(id))\n             } else {\n-                trace!(\"no parent found for {:?}\", attr.doc);\n                 (item.def_id.krate, parent_node)\n             };\n             // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n             // This is a degenerate case and it's not supported by rustdoc.\n-            for (ori_link, link_range) in markdown_links(&combined_docs) {\n+            for (ori_link, link_range) in markdown_links(&doc) {\n                 let link = self.resolve_link(\n                     &item,\n-                    &combined_docs,\n+                    &doc,\n                     &self_name,\n                     parent_node,\n                     krate,"}, {"sha": "7ac42c759924890a0e5a3d7e8c42f908fe654e31", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=e821a6ef78b915305c4d659c813f27d4180baec0", "patch": "@@ -14,9 +14,6 @@ crate use stripper::*;\n mod non_autolinks;\n crate use self::non_autolinks::CHECK_NON_AUTOLINKS;\n \n-mod collapse_docs;\n-crate use self::collapse_docs::COLLAPSE_DOCS;\n-\n mod strip_hidden;\n crate use self::strip_hidden::STRIP_HIDDEN;\n \n@@ -84,7 +81,6 @@ crate const PASSES: &[Pass] = &[\n     CHECK_PRIVATE_ITEMS_DOC_TESTS,\n     STRIP_HIDDEN,\n     UNINDENT_COMMENTS,\n-    COLLAPSE_DOCS,\n     STRIP_PRIVATE,\n     STRIP_PRIV_IMPORTS,\n     PROPAGATE_DOC_CFG,\n@@ -99,7 +95,6 @@ crate const PASSES: &[Pass] = &[\n /// The list of passes run by default.\n crate const DEFAULT_PASSES: &[ConditionalPass] = &[\n     ConditionalPass::always(COLLECT_TRAIT_IMPLS),\n-    ConditionalPass::always(COLLAPSE_DOCS),\n     ConditionalPass::always(UNINDENT_COMMENTS),\n     ConditionalPass::always(CHECK_PRIVATE_ITEMS_DOC_TESTS),\n     ConditionalPass::new(STRIP_HIDDEN, WhenNotDocumentHidden),"}, {"sha": "1cad480d4e84705dcb4172b3ba57ec03861a3d95", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=e821a6ef78b915305c4d659c813f27d4180baec0", "patch": "@@ -68,7 +68,7 @@ fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n     let min_indent = match docs\n         .iter()\n         .map(|fragment| {\n-            fragment.doc.lines().fold(usize::MAX, |min_indent, line| {\n+            fragment.doc.as_str().lines().fold(usize::MAX, |min_indent, line| {\n                 if line.chars().all(|c| c.is_whitespace()) {\n                     min_indent\n                 } else {\n@@ -87,7 +87,7 @@ fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n     };\n \n     for fragment in docs {\n-        if fragment.doc.lines().count() == 0 {\n+        if fragment.doc.as_str().lines().count() == 0 {\n             continue;\n         }\n \n@@ -97,18 +97,6 @@ fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n             min_indent\n         };\n \n-        fragment.doc = fragment\n-            .doc\n-            .lines()\n-            .map(|line| {\n-                if line.chars().all(|c| c.is_whitespace()) {\n-                    line.to_string()\n-                } else {\n-                    assert!(line.len() >= min_indent);\n-                    line[min_indent..].to_string()\n-                }\n-            })\n-            .collect::<Vec<_>>()\n-            .join(\"\\n\");\n+        fragment.indent = min_indent;\n     }\n }"}, {"sha": "9c9924841b94889789a25d22b24a20361e272ccd", "filename": "src/librustdoc/passes/unindent_comments/tests.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments%2Ftests.rs?ref=e821a6ef78b915305c4d659c813f27d4180baec0", "patch": "@@ -1,21 +1,27 @@\n use super::*;\n use rustc_span::source_map::DUMMY_SP;\n+use rustc_span::symbol::Symbol;\n+use rustc_span::with_default_session_globals;\n \n fn create_doc_fragment(s: &str) -> Vec<DocFragment> {\n     vec![DocFragment {\n         line: 0,\n         span: DUMMY_SP,\n         parent_module: None,\n-        doc: s.to_string(),\n+        doc: Symbol::intern(s),\n         kind: DocFragmentKind::SugaredDoc,\n+        need_backline: false,\n+        indent: 0,\n     }]\n }\n \n #[track_caller]\n fn run_test(input: &str, expected: &str) {\n-    let mut s = create_doc_fragment(input);\n-    unindent_fragments(&mut s);\n-    assert_eq!(s[0].doc, expected);\n+    with_default_session_globals(|| {\n+        let mut s = create_doc_fragment(input);\n+        unindent_fragments(&mut s);\n+        assert_eq!(&s.iter().collect::<String>(), expected);\n+    });\n }\n \n #[test]"}, {"sha": "75acdc5ab5f262ccdb5968e6b6bc3e87188eb562", "filename": "src/test/rustdoc-ui/invalid-syntax.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e821a6ef78b915305c4d659c813f27d4180baec0/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-syntax.stderr?ref=e821a6ef78b915305c4d659c813f27d4180baec0", "patch": "@@ -127,8 +127,10 @@ LL | /// ```text\n warning: could not parse code block as Rust code\n   --> $DIR/invalid-syntax.rs:92:9\n    |\n-LL | ///     \\____/\n-   |         ^^^^^^\n+LL |   ///     \\____/\n+   |  _________^\n+LL | | ///\n+   | |_\n    |\n    = note: error from rustc: unknown start of token: \\\n "}]}