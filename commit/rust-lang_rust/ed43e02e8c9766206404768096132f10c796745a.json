{"sha": "ed43e02e8c9766206404768096132f10c796745a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNDNlMDJlOGM5NzY2MjA2NDA0NzY4MDk2MTMyZjEwYzc5Njc0NWE=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-08-23T19:59:46Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-08-23T21:15:52Z"}, "message": "2229: Update signature for truncate function", "tree": {"sha": "385bee83da9403ddd2ac41a7b3a84a2b4c88d52c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/385bee83da9403ddd2ac41a7b3a84a2b4c88d52c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed43e02e8c9766206404768096132f10c796745a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed43e02e8c9766206404768096132f10c796745a", "html_url": "https://github.com/rust-lang/rust/commit/ed43e02e8c9766206404768096132f10c796745a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed43e02e8c9766206404768096132f10c796745a/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9583fd1bdd0127328e25e5b8c24dff575ec2c86b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9583fd1bdd0127328e25e5b8c24dff575ec2c86b", "html_url": "https://github.com/rust-lang/rust/commit/9583fd1bdd0127328e25e5b8c24dff575ec2c86b"}], "stats": {"total": 118, "additions": 48, "deletions": 70}, "files": [{"sha": "d3d8e73e19a3ba87516897fecd3037b9b0a3d33d", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 48, "deletions": 70, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ed43e02e8c9766206404768096132f10c796745a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed43e02e8c9766206404768096132f10c796745a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=ed43e02e8c9766206404768096132f10c796745a", "patch": "@@ -489,7 +489,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut root_var_min_capture_list =\n             typeck_results.closure_min_captures.remove(&closure_def_id).unwrap_or_default();\n \n-        for (place, capture_info) in capture_information.into_iter() {\n+        for (mut place, capture_info) in capture_information.into_iter() {\n             let var_hir_id = match place.base {\n                 PlaceBase::Upvar(upvar_id) => upvar_id.var_path.hir_id,\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n@@ -530,14 +530,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                         // Truncate the descendant (already in min_captures) to be same as the ancestor to handle any\n                         // possible change in capture mode.\n-                        let (_, descendant_capture_kind) = truncate_place_to_len(\n-                            possible_descendant.place,\n-                            possible_descendant.info.capture_kind,\n+                        truncate_place_to_len_and_update_capture_kind(\n+                            &mut possible_descendant.place,\n+                            &mut possible_descendant.info.capture_kind,\n                             place.projections.len(),\n                         );\n \n-                        possible_descendant.info.capture_kind = descendant_capture_kind;\n-\n                         updated_capture_info =\n                             determine_capture_info(updated_capture_info, possible_descendant.info);\n \n@@ -561,14 +559,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                             // Truncate the descendant (current place) to be same as the ancestor to handle any\n                             // possible change in capture mode.\n-                            let (_, descendant_capture_kind) = truncate_place_to_len(\n-                                place.clone(),\n-                                updated_capture_info.capture_kind,\n+                            truncate_place_to_len_and_update_capture_kind(\n+                                &mut place,\n+                                &mut updated_capture_info.capture_kind,\n                                 possible_ancestor.place.projections.len(),\n                             );\n \n-                            updated_capture_info.capture_kind = descendant_capture_kind;\n-\n                             possible_ancestor.info = determine_capture_info(\n                                 possible_ancestor.info,\n                                 updated_capture_info,\n@@ -1476,7 +1472,7 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     place: &Place<'tcx>,\n-    curr_borrow_kind: ty::UpvarCapture<'tcx>,\n+    mut curr_borrow_kind: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n     let pos = place.projections.iter().enumerate().position(|(i, p)| {\n         let ty = place.ty_before_projection(i);\n@@ -1508,13 +1504,13 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n         }\n     });\n \n-    let place = place.clone();\n+    let mut place = place.clone();\n \n     if let Some(pos) = pos {\n-        truncate_place_to_len(place, curr_borrow_kind, pos)\n-    } else {\n-        (place, curr_borrow_kind)\n+        truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_borrow_kind, pos);\n     }\n+\n+    (place, curr_borrow_kind)\n }\n \n /// Returns a Ty that applies the specified capture kind on the provided capture Ty\n@@ -1841,31 +1837,28 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n ///   them completely.\n /// - No projections are applied on top of Union ADTs, since these require unsafe blocks.\n fn restrict_precision_for_unsafe(\n-    place: Place<'tcx>,\n-    curr_mode: ty::UpvarCapture<'tcx>,\n+    mut place: Place<'tcx>,\n+    mut curr_mode: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n-    if place.projections.is_empty() {\n-        // Nothing to do here\n-        return (place, curr_mode);\n-    }\n-\n     if place.base_ty.is_unsafe_ptr() {\n-        return truncate_place_to_len(place, curr_mode, 0);\n+        truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, 0);\n     }\n \n     if place.base_ty.is_union() {\n-        return truncate_place_to_len(place, curr_mode, 0);\n+        truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, 0);\n     }\n \n     for (i, proj) in place.projections.iter().enumerate() {\n         if proj.ty.is_unsafe_ptr() {\n             // Don't apply any projections on top of an unsafe ptr.\n-            return truncate_place_to_len(place, curr_mode, i + 1);\n+            truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, i + 1);\n+            break;\n         }\n \n         if proj.ty.is_union() {\n             // Don't capture preicse fields of a union.\n-            return truncate_place_to_len(place, curr_mode, i + 1);\n+            truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, i + 1);\n+            break;\n         }\n     }\n \n@@ -1880,7 +1873,7 @@ fn restrict_capture_precision<'tcx>(\n     place: Place<'tcx>,\n     curr_mode: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n-    let (place, curr_mode) = restrict_precision_for_unsafe(place, curr_mode);\n+    let (mut place, mut curr_mode) = restrict_precision_for_unsafe(place, curr_mode);\n \n     if place.projections.is_empty() {\n         // Nothing to do here\n@@ -1891,7 +1884,8 @@ fn restrict_capture_precision<'tcx>(\n         match proj.kind {\n             ProjectionKind::Index => {\n                 // Arrays are completely captured, so we drop Index projections\n-                return truncate_place_to_len(place, curr_mode, i);\n+                truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, i);\n+                return (place, curr_mode);\n             }\n             ProjectionKind::Deref => {}\n             ProjectionKind::Field(..) => {} // ignore\n@@ -1906,8 +1900,8 @@ fn restrict_capture_precision<'tcx>(\n /// (or if closure attempts to move data that it doesn\u2019t own).\n /// Note: When taking ownership, only capture data found on the stack.\n fn adjust_for_move_closure<'tcx>(\n-    place: Place<'tcx>,\n-    kind: ty::UpvarCapture<'tcx>,\n+    mut place: Place<'tcx>,\n+    mut kind: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n     let contains_deref_of_ref = place.deref_tys().any(|ty| ty.is_ref());\n     let first_deref = place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n@@ -1917,52 +1911,38 @@ fn adjust_for_move_closure<'tcx>(\n \n         // If there's any Deref and the data needs to be moved into the closure body,\n         // or it's a Deref of a Box, truncate the path to the first deref\n-        _ if first_deref.is_some() => {\n-            let place = match first_deref {\n-                Some(idx) => {\n-                    let (place, _) = truncate_place_to_len(place, kind, idx);\n-                    place\n-                }\n-                None => place,\n-            };\n+        _ => {\n+            if let Some(idx) = first_deref {\n+                truncate_place_to_len_and_update_capture_kind(&mut place, &mut kind, idx);\n+            }\n \n             // AMAN: I think we don't need the span inside the ByValue anymore\n             //       we have more detailed span in CaptureInfo\n             (place, ty::UpvarCapture::ByValue(None))\n         }\n-\n-        _ => (place, ty::UpvarCapture::ByValue(None)),\n     }\n }\n \n /// Adjust closure capture just that if taking ownership of data, only move data\n /// from enclosing stack frame.\n fn adjust_for_non_move_closure<'tcx>(\n-    place: Place<'tcx>,\n+    mut place: Place<'tcx>,\n     mut kind: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n     let contains_deref =\n         place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n \n     match kind {\n-        ty::UpvarCapture::ByValue(..) if contains_deref.is_some() => {\n-            let place = match contains_deref {\n-                Some(idx) => {\n-                    let (place, new_kind) = truncate_place_to_len(place, kind, idx);\n-\n-                    kind = new_kind;\n-                    place\n-                }\n-                // Because of the if guard on the match on `kind`, we should never get here.\n-                None => unreachable!(),\n-            };\n-\n-            (place, kind)\n+        ty::UpvarCapture::ByValue(..) => {\n+            if let Some(idx) = contains_deref {\n+                truncate_place_to_len_and_update_capture_kind(&mut place, &mut kind, idx);\n+            }\n         }\n \n-        ty::UpvarCapture::ByValue(..) => (place, kind),\n-        ty::UpvarCapture::ByRef(..) => (place, kind),\n+        ty::UpvarCapture::ByRef(..) => {}\n     }\n+\n+    (place, kind)\n }\n \n fn construct_place_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n@@ -2157,15 +2137,13 @@ fn determine_capture_info(\n ///\n /// Note: Capture kind changes from `MutBorrow` to `UniqueImmBorrow` if the truncated part of the `place`\n /// contained `Deref` of `&mut`.\n-fn truncate_place_to_len(\n-    mut place: Place<'tcx>,\n-    curr_mode: ty::UpvarCapture<'tcx>,\n+fn truncate_place_to_len_and_update_capture_kind(\n+    place: &mut Place<'tcx>,\n+    curr_mode: &mut ty::UpvarCapture<'tcx>,\n     len: usize,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+) {\n     let is_mut_ref = |ty: Ty<'_>| matches!(ty.kind(), ty::Ref(.., hir::Mutability::Mut));\n \n-    let mut capture_kind = curr_mode;\n-\n     // If the truncated part of the place contains `Deref` of a `&mut` then convert MutBorrow ->\n     // UniqueImmBorrow\n     // Note that if the place contained Deref of a raw pointer it would've not been MutBorrow, so\n@@ -2176,7 +2154,7 @@ fn truncate_place_to_len(\n                 if place.projections[i].kind == ProjectionKind::Deref\n                     && is_mut_ref(place.ty_before_projection(i))\n                 {\n-                    capture_kind = ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n+                    *curr_mode = ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n                         kind: ty::BorrowKind::UniqueImmBorrow,\n                         region,\n                     });\n@@ -2190,8 +2168,6 @@ fn truncate_place_to_len(\n     }\n \n     place.projections.truncate(len);\n-\n-    (place, capture_kind)\n }\n \n /// Determines the Ancestry relationship of Place A relative to Place B\n@@ -2256,8 +2232,8 @@ fn determine_place_ancestry_relation(\n /// }\n /// ```\n fn truncate_capture_for_optimization<'tcx>(\n-    place: Place<'tcx>,\n-    curr_mode: ty::UpvarCapture<'tcx>,\n+    mut place: Place<'tcx>,\n+    mut curr_mode: ty::UpvarCapture<'tcx>,\n ) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n     let is_shared_ref = |ty: Ty<'_>| matches!(ty.kind(), ty::Ref(.., hir::Mutability::Not));\n \n@@ -2269,10 +2245,12 @@ fn truncate_capture_for_optimization<'tcx>(\n     match idx {\n         // If that pointer is a shared reference, then we don't need those fields.\n         Some(idx) if is_shared_ref(place.ty_before_projection(idx)) => {\n-            truncate_place_to_len(place, curr_mode, idx + 1)\n+            truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, idx + 1)\n         }\n-        None | Some(_) => (place, curr_mode),\n+        None | Some(_) => {}\n     }\n+\n+    (place, curr_mode)\n }\n \n /// Precise capture is enabled if the feature gate `capture_disjoint_fields` is enabled or if"}]}