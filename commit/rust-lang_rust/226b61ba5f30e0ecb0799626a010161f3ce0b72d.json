{"sha": "226b61ba5f30e0ecb0799626a010161f3ce0b72d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNmI2MWJhNWYzMGUwZWNiMDc5OTYyNmEwMTAxNjFmM2NlMGI3MmQ=", "commit": {"author": {"name": "Zack Corr", "email": "zack@z0w0.me", "date": "2013-01-16T11:59:37Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-02-16T02:04:10Z"}, "message": "rustpkg: Add package script parsing", "tree": {"sha": "ed15c6860e9e94096eb2078df4d692f4d88f6b12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed15c6860e9e94096eb2078df4d692f4d88f6b12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/226b61ba5f30e0ecb0799626a010161f3ce0b72d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/226b61ba5f30e0ecb0799626a010161f3ce0b72d", "html_url": "https://github.com/rust-lang/rust/commit/226b61ba5f30e0ecb0799626a010161f3ce0b72d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/226b61ba5f30e0ecb0799626a010161f3ce0b72d/comments", "author": {"login": "z0w0", "id": 676417, "node_id": "MDQ6VXNlcjY3NjQxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/676417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/z0w0", "html_url": "https://github.com/z0w0", "followers_url": "https://api.github.com/users/z0w0/followers", "following_url": "https://api.github.com/users/z0w0/following{/other_user}", "gists_url": "https://api.github.com/users/z0w0/gists{/gist_id}", "starred_url": "https://api.github.com/users/z0w0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/z0w0/subscriptions", "organizations_url": "https://api.github.com/users/z0w0/orgs", "repos_url": "https://api.github.com/users/z0w0/repos", "events_url": "https://api.github.com/users/z0w0/events{/privacy}", "received_events_url": "https://api.github.com/users/z0w0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71d34a8872491f37011aa14c866a95165fc45f99", "url": "https://api.github.com/repos/rust-lang/rust/commits/71d34a8872491f37011aa14c866a95165fc45f99", "html_url": "https://github.com/rust-lang/rust/commit/71d34a8872491f37011aa14c866a95165fc45f99"}], "stats": {"total": 456, "additions": 446, "deletions": 10}, "files": [{"sha": "6169ac24c0534aec85312c382ab5961a99478986", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/226b61ba5f30e0ecb0799626a010161f3ce0b72d/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/226b61ba5f30e0ecb0799626a010161f3ce0b72d/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=226b61ba5f30e0ecb0799626a010161f3ce0b72d", "patch": "@@ -169,6 +169,7 @@ pub mod reflect;\n pub mod condition;\n pub mod logging;\n pub mod util;\n+pub mod semver;\n \n \n /* Reexported core operators */"}, {"sha": "5a739772d1e68c9c92192cd7736d9cf7c68072f3", "filename": "src/libcore/semver.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/226b61ba5f30e0ecb0799626a010161f3ce0b72d/src%2Flibcore%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b61ba5f30e0ecb0799626a010161f3ce0b72d/src%2Flibcore%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsemver.rs?ref=226b61ba5f30e0ecb0799626a010161f3ce0b72d", "patch": "@@ -0,0 +1,227 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Semver parsing and logic\n+\n+use io;\n+use io::{ReaderUtil};\n+use option::{Option, Some, None};\n+use uint;\n+use str;\n+use to_str::ToStr;\n+use char;\n+\n+pub struct Version {\n+    major: uint,\n+    minor: uint,\n+    patch: uint,\n+    tag: Option<~str>,\n+}\n+\n+impl Version: ToStr {\n+    #[inline(always)]\n+    pure fn to_str() -> ~str {\n+        let suffix = match copy self.tag {\n+            Some(tag) => ~\"-\" + tag,\n+            None => ~\"\"\n+        };\n+\n+        fmt!(\"%u.%u.%u%s\", self.major, self.minor, self.patch, suffix)\n+    }\n+}\n+\n+fn read_whitespace(rdr: io::Reader, ch: char) -> char {\n+    let mut nch = ch;\n+\n+    while char::is_whitespace(nch) {\n+        nch = rdr.read_char();\n+    }\n+\n+    nch\n+}\n+\n+fn parse_reader(rdr: io::Reader) -> Option<(Version, char)> {\n+    fn read_digits(rdr: io::Reader, ch: char) -> Option<(uint, char)> {\n+        let mut buf = ~\"\";\n+        let mut nch = ch;\n+\n+        while nch != -1 as char {\n+            match nch {\n+              '0' .. '9' => buf += str::from_char(nch),\n+              _ => break\n+            }\n+\n+            nch = rdr.read_char();\n+        }\n+\n+        do uint::from_str(buf).chain_ref |&i| {\n+            Some((i, nch))\n+        }\n+    }\n+\n+    fn read_tag(rdr: io::Reader) -> Option<(~str, char)> {\n+        let mut ch = rdr.read_char();\n+        let mut buf = ~\"\";\n+\n+        while ch != -1 as char {\n+            match ch {\n+                '0' .. '9' | 'A' .. 'Z' | 'a' .. 'z' | '-' => {\n+                    buf += str::from_char(ch);\n+                }\n+                _ => break\n+            }\n+\n+            ch = rdr.read_char();\n+        }\n+\n+        if buf == ~\"\" { return None; }\n+        else { Some((buf, ch)) }\n+    }\n+\n+    let ch = read_whitespace(rdr, rdr.read_char());\n+    let (major, ch) = match read_digits(rdr, ch) {\n+        None => return None,\n+        Some(item) => item\n+    };\n+\n+    if ch != '.' { return None; }\n+\n+    let (minor, ch) = match read_digits(rdr, rdr.read_char()) {\n+        None => return None,\n+        Some(item) => item\n+    };\n+\n+    if ch != '.' { return None; }\n+\n+    let (patch, ch) = match read_digits(rdr, rdr.read_char()) {\n+        None => return None,\n+        Some(item) => item\n+    };\n+    let (tag, ch) = if ch == '-' {\n+        match read_tag(rdr) {\n+            None => return None,\n+            Some((tag, ch)) => (Some(tag), ch)\n+        }\n+    } else {\n+        (None, ch)\n+    };\n+\n+    Some((Version { major: major, minor: minor, patch: patch, tag: tag },\n+          ch))\n+}\n+\n+pub fn parse(s: ~str) -> Option<Version> {\n+    do io::with_str_reader(s) |rdr| {\n+        do parse_reader(rdr).chain_ref |&item| {\n+            let (version, ch) = item;\n+\n+            if read_whitespace(rdr, ch) != -1 as char {\n+                None\n+            } else {\n+                Some(version)\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_parse() {\n+    assert parse(\"\") == None;\n+    assert parse(\"  \") == None;\n+    assert parse(\"1\") == None;\n+    assert parse(\"1.2\") == None;\n+    assert parse(\"1.2\") == None;\n+    assert parse(\"1\") == None;\n+    assert parse(\"1.2\") == None;\n+    assert parse(\"1.2.3-\") == None;\n+    assert parse(\"a.b.c\") == None;\n+    assert parse(\"1.2.3 abc\") == None;\n+\n+    assert parse(\"1.2.3\") == Some({\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        tag: None,\n+    });\n+    assert parse(\"  1.2.3  \") == Some({\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        tag: None,\n+    });\n+    assert parse(\"1.2.3-alpha1\") == Some({\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        tag: Some(\"alpha1\")\n+    });\n+    assert parse(\"  1.2.3-alpha1  \") == Some({\n+        major: 1u,\n+        minor: 2u,\n+        patch: 3u,\n+        tag: Some(\"alpha1\")\n+    });\n+}\n+\n+#[test]\n+fn test_eq() {\n+    assert parse(\"1.2.3\")        == parse(\"1.2.3\");\n+    assert parse(\"1.2.3-alpha1\") == parse(\"1.2.3-alpha1\");\n+}\n+\n+#[test]\n+fn test_ne() {\n+    assert parse(\"0.0.0\")       != parse(\"0.0.1\");\n+    assert parse(\"0.0.0\")       != parse(\"0.1.0\");\n+    assert parse(\"0.0.0\")       != parse(\"1.0.0\");\n+    assert parse(\"1.2.3-alpha\") != parse(\"1.2.3-beta\");\n+}\n+\n+#[test]\n+fn test_lt() {\n+    assert parse(\"0.0.0\")        < parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.0.0\")        < parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.2.0\")        < parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.2.3\")        < parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.2.3-alpha1\") < parse(\"1.2.3-alpha2\");\n+\n+    assert !(parse(\"1.2.3-alpha2\") < parse(\"1.2.3-alpha2\"));\n+}\n+\n+#[test]\n+fn test_le() {\n+    assert parse(\"0.0.0\")        <= parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.0.0\")        <= parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.2.0\")        <= parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.2.3\")        <= parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.2.3-alpha1\") <= parse(\"1.2.3-alpha2\");\n+    assert parse(\"1.2.3-alpha2\") <= parse(\"1.2.3-alpha2\");\n+}\n+\n+#[test]\n+fn test_gt() {\n+    assert parse(\"1.2.3-alpha2\") > parse(\"0.0.0\");\n+    assert parse(\"1.2.3-alpha2\") > parse(\"1.0.0\");\n+    assert parse(\"1.2.3-alpha2\") > parse(\"1.2.0\");\n+    assert parse(\"1.2.3-alpha2\") > parse(\"1.2.3\");\n+    assert parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha1\");\n+\n+    assert !(parse(\"1.2.3-alpha2\") > parse(\"1.2.3-alpha2\"));\n+}\n+\n+#[test]\n+fn test_ge() {\n+    assert parse(\"1.2.3-alpha2\") >= parse(\"0.0.0\");\n+    assert parse(\"1.2.3-alpha2\") >= parse(\"1.0.0\");\n+    assert parse(\"1.2.3-alpha2\") >= parse(\"1.2.0\");\n+    assert parse(\"1.2.3-alpha2\") >= parse(\"1.2.3\");\n+    assert parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha1\");\n+    assert parse(\"1.2.3-alpha2\") >= parse(\"1.2.3-alpha2\");\n+}"}, {"sha": "6dd238b3d5c060ddfe3030b4b32d1bfc5ad4f3bd", "filename": "src/librustpkg/api.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/226b61ba5f30e0ecb0799626a010161f3ce0b72d/src%2Flibrustpkg%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b61ba5f30e0ecb0799626a010161f3ce0b72d/src%2Flibrustpkg%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fapi.rs?ref=226b61ba5f30e0ecb0799626a010161f3ce0b72d", "patch": "@@ -9,7 +9,7 @@ pub struct Crate {\n pub impl Crate {\n     fn flag(flag: ~str) -> Crate {\n         Crate {\n-            flags: vec::append(self.flags, flag),\n+            flags: vec::append(copy self.flags, ~[flag]),\n             .. copy self\n         }\n     }\n@@ -18,3 +18,7 @@ pub impl Crate {\n pub fn build(_targets: ~[Crate]) {\n     // TODO: magic\n }\n+\n+pub mod util {\n+    \n+}"}, {"sha": "e847a8935f6de63418eb653c9221444484e1358e", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 161, "deletions": 9, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/226b61ba5f30e0ecb0799626a010161f3ce0b72d/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/226b61ba5f30e0ecb0799626a010161f3ce0b72d/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=226b61ba5f30e0ecb0799626a010161f3ce0b72d", "patch": "@@ -17,33 +17,180 @@\n \n #[crate_type = \"lib\"];\n #[no_core];\n+#[allow(vecs_implicitly_copyable,\n+        non_implicitly_copyable_typarams)];\n \n extern mod core(vers = \"0.6\");\n extern mod std(vers = \"0.6\");\n extern mod rustc(vers = \"0.6\");\n extern mod syntax(vers = \"0.6\");\n \n use core::*;\n+use io::{ReaderUtil, WriterUtil};\n use std::getopts;\n-use getopts::{optflag, optopt, opt_present};\n use rustc::metadata::{filesearch};\n+use syntax::{ast, codemap, parse, visit, attr};\n+use semver::Version;\n \n mod api;\n mod usage;\n mod util;\n \n-use util::*;\n+struct PackageScript {\n+    id: ~str,\n+    name: ~str,\n+    vers: Version\n+}\n+\n+impl PackageScript {\n+    static fn parse(parent: Path) -> PackageScript {\n+        let script = parent.push(~\"package.rs\");\n+\n+        if !os::path_exists(&script) {\n+            fail ~\"no package.rs file\";\n+        }\n+\n+        let sess = parse::new_parse_sess(None);\n+        let crate = parse::parse_crate_from_file(&script, ~[], sess);\n+        let mut id = None;\n+        let mut vers = None;\n+\n+        fn load_pkg_attr(mis: ~[@ast::meta_item]) -> (Option<~str>,\n+                                                      Option<~str>) {\n+            let mut id = None;\n+            let mut vers = None;\n+\n+            for mis.each |a| {\n+                match a.node {\n+                    ast::meta_name_value(v, ast::spanned {\n+                                                node: ast::lit_str(s),\n+                                                span: _}) => {\n+                        match v {\n+                            ~\"id\" => id = Some(*s),\n+                            ~\"vers\" => vers = Some(*s),\n+                            _ => ()\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            (id, vers)\n+        }\n+\n+        for crate.node.attrs.each |a| {\n+            match a.node.value.node {\n+                ast::meta_list(v, mis) => {\n+                    match v {\n+                        ~\"pkg\" => {\n+                            let (i, v) = load_pkg_attr(mis);\n+\n+                            id = i;\n+                            vers = v;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        if id.is_none() || vers.is_none() {\n+            fail ~\"id or vers isn't defined in a pkg attribute in package.rs\";\n+        }\n+\n+        let id = id.get();\n+        let vers = vers.get();\n+\n+        PackageScript {\n+            id: id,\n+            name: util::parse_id(id),\n+            vers: util::parse_vers(vers)\n+        }\n+    }\n+\n+    fn hash() -> ~str {\n+        let hasher = hash::default_state();\n+\n+        hasher.write_str(self.id + self.vers.to_str());\n+\n+        self.name + hasher.result_str() + self.vers.to_str()\n+    }\n+\n+    fn work_dir() -> Path {\n+        util::root().push(self.hash())\n+    }\n+}\n+\n+struct Ctx {\n+    cmd: ~str,\n+    args: ~[~str],\n+    cfgs: ~[~str],\n+    prefer: bool\n+}\n+\n+impl Ctx {\n+    fn run() {\n+        match self.cmd {\n+            ~\"build\" => self.build(),\n+            ~\"clean\" => self.clean(),\n+            ~\"install\" => self.install(),\n+            ~\"prefer\" => self.prefer(),\n+            ~\"test\" => self.test(),\n+            ~\"uninstall\" => self.uninstall(),\n+            ~\"unprefer\" => self.unprefer(),\n+            _ => fail ~\"reached an unhandled command\"\n+        }\n+    }\n+\n+    fn build() {\n+        let script = PackageScript::parse(os::getcwd());\n+\n+        io::println(fmt!(\"build: %s (v%s)\", script.id, script.vers.to_str()));\n+    }\n+\n+    fn clean() {\n+\n+    }\n+\n+    fn install() {\n+\n+    }\n+\n+    fn prefer() {\n+\n+    }\n+\n+    fn test() {\n+\n+    }\n+\n+    fn uninstall() {\n+\n+    }\n+\n+    fn unprefer() {\n+\n+    }\n+}\n \n pub fn main() {\n     let args = os::args();\n-    let opts = ~[optflag(~\"h\"), optflag(~\"help\")];\n+    let opts = ~[getopts::optflag(~\"h\"), getopts::optflag(~\"help\"),\n+                 getopts::optmulti(~\"c\"), getopts::optmulti(~\"cfg\"),\n+                 getopts::optmulti(~\"p\"), getopts::optmulti(~\"prefer\")];\n     let matches = &match getopts::getopts(args, opts) {\n         result::Ok(m) => m,\n         result::Err(f) => {\n             fail fmt!(\"%s\", getopts::fail_str(f));\n         }\n     };\n-    let help = opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\");\n+    let help = getopts::opt_present(matches, ~\"h\") ||\n+               getopts::opt_present(matches, ~\"help\");\n+    let cfgs = vec::append(getopts::opt_strs(matches, ~\"cfg\"),\n+                           getopts::opt_strs(matches, ~\"c\"));\n+    let prefer = getopts::opt_present(matches, ~\"p\") ||\n+                 getopts::opt_present(matches, ~\"prefer\");\n     let mut args = copy matches.free;\n \n     args.shift();\n@@ -52,12 +199,12 @@ pub fn main() {\n         return usage::general();\n     }\n \n-    let cmd = copy args[0];\n+    let cmd = args.shift();\n \n-    if !is_cmd(cmd) {\n+    if !util::is_cmd(cmd) {\n         return usage::general();\n     } else if help {\n-        match cmd {\n+        return match cmd {\n             ~\"build\" => usage::build(),\n             ~\"clean\" => usage::clean(),\n             ~\"install\" => usage::install(),\n@@ -66,10 +213,15 @@ pub fn main() {\n             ~\"uninstall\" => usage::uninstall(),\n             ~\"unprefer\" => usage::unprefer(),\n             _ => usage::general()\n-        }\n+        };\n     }\n \n-    Ctx { cmd: cmd, args: args }\n+    Ctx {\n+        cmd: cmd,\n+        args: args,\n+        cfgs: cfgs,\n+        prefer: prefer\n+    }.run();\n }\n \n pub use Crate = api::Crate;"}, {"sha": "0f2aea5a33bc59007ad3068e3b1aab98df045b51", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/226b61ba5f30e0ecb0799626a010161f3ce0b72d/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226b61ba5f30e0ecb0799626a010161f3ce0b72d/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=226b61ba5f30e0ecb0799626a010161f3ce0b72d", "patch": "@@ -1,6 +1,58 @@\n+use core::*;\n+use rustc::metadata::filesearch;\n+use semver::Version;\n+use std::net::url;\n+\n+pub fn root() -> Path {\n+    match filesearch::get_rustpkg_root() {\n+        result::Ok(path) => path,\n+        result::Err(err) => fail err\n+    }\n+}\n+\n pub fn is_cmd(cmd: ~str) -> bool {\n     let cmds = &[~\"build\", ~\"clean\", ~\"install\", ~\"prefer\", ~\"test\",\n                  ~\"uninstall\", ~\"unprefer\"];\n \n     vec::contains(cmds, &cmd)\n }\n+\n+pub fn parse_id(id: ~str) -> ~str {\n+    let parts = str::split_char(id, '.');\n+\n+    for parts.each |&part| {\n+        for str::chars(part).each |&char| {\n+            if char::is_whitespace(char) {\n+                fail ~\"could not parse id: contains whitespace\";\n+            } else if char::is_uppercase(char) {\n+                fail ~\"could not parse id: should be all lowercase\";\n+            }\n+        }\n+    }\n+\n+    parts.last()\n+}\n+\n+pub fn parse_vers(vers: ~str) -> Version {\n+    match semver::parse(vers) {\n+        Some(vers) => vers,\n+        None => fail ~\"could not parse version: invalid\"\n+    }\n+}\n+\n+#[test]\n+fn test_is_cmd() {\n+    assert is_cmd(~\"build\");\n+    assert is_cmd(~\"clean\");\n+    assert is_cmd(~\"install\");\n+    assert is_cmd(~\"prefer\");\n+    assert is_cmd(~\"test\");\n+    assert is_cmd(~\"uninstall\");\n+    assert is_cmd(~\"unprefer\");\n+}\n+\n+#[test]\n+fn test_parse_id() {\n+    assert parse_id(~\"org.mozilla.servo\").get() == ~\"servo\";\n+    assert parse_id(~\"org. mozilla.servo 2131\").is_err();\n+}"}]}