{"sha": "dca8ddeade657e00236b2d0de2561f2fc175d6ae", "node_id": "C_kwDOAAsO6NoAKGRjYThkZGVhZGU2NTdlMDAyMzZiMmQwZGUyNTYxZjJmYzE3NWQ2YWU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-13T17:15:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-13T17:15:14Z"}, "message": "Rollup merge of #91846 - camelid:doctest-cleanup, r=GuillaumeGomez\n\nrustdoc: Reduce number of arguments for `run_test` a bit\n\n- rustdoc: Coalesce some `run_test` args as one `LangString` arg\n- Rename `TestOptions` to `GlobalTestOptions`\n- doctest: Rename `options` to `rustdoc_options`", "tree": {"sha": "c64f02ef1eb6c82199b540527e3df36df929ad6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c64f02ef1eb6c82199b540527e3df36df929ad6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dca8ddeade657e00236b2d0de2561f2fc175d6ae", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJht3+iCRBK7hj4Ov3rIwAAjG0IADcK9/AuSMS4aT7L9b9HFOfc\nOzIu/LGsGgrgsgIMPlBvl1N1DYutZgHxCmum0V6ZTwouwrL+svRH7JWczoA5ZvWy\ng3g9BGofc5ijZ7a76ROp8C1HfGcPoiBQoDX0N9wzNaYd58JCcSre8LfAifjVooix\nS8ca7Oqg+acT4cPxR+/941yRqOC/EZ00HiuKpyu6+gYEX3EHhYaVt23Bb/ZcRfgT\nEnQwTEgR2pX4T5TS5IUIi+JIQ/UMF+nmFAa+1RJWkFr33iWtgDAIF49RzFGc5o6f\nQm/rx+6gidwT4qFPxkL6EY6GfVzuOz2V/VnQCrVMs+ujwytW16VDcFbor71uzkg=\n=hILw\n-----END PGP SIGNATURE-----\n", "payload": "tree c64f02ef1eb6c82199b540527e3df36df929ad6f\nparent e354f0ce87d73e1766ca0a66532b3ed2d413bc98\nparent 9afa190c446d4fc9c4b73eae11f67af46584cf98\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1639415714 +0100\ncommitter GitHub <noreply@github.com> 1639415714 +0100\n\nRollup merge of #91846 - camelid:doctest-cleanup, r=GuillaumeGomez\n\nrustdoc: Reduce number of arguments for `run_test` a bit\n\n- rustdoc: Coalesce some `run_test` args as one `LangString` arg\n- Rename `TestOptions` to `GlobalTestOptions`\n- doctest: Rename `options` to `rustdoc_options`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dca8ddeade657e00236b2d0de2561f2fc175d6ae", "html_url": "https://github.com/rust-lang/rust/commit/dca8ddeade657e00236b2d0de2561f2fc175d6ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dca8ddeade657e00236b2d0de2561f2fc175d6ae/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e354f0ce87d73e1766ca0a66532b3ed2d413bc98", "url": "https://api.github.com/repos/rust-lang/rust/commits/e354f0ce87d73e1766ca0a66532b3ed2d413bc98", "html_url": "https://github.com/rust-lang/rust/commit/e354f0ce87d73e1766ca0a66532b3ed2d413bc98"}, {"sha": "9afa190c446d4fc9c4b73eae11f67af46584cf98", "url": "https://api.github.com/repos/rust-lang/rust/commits/9afa190c446d4fc9c4b73eae11f67af46584cf98", "html_url": "https://github.com/rust-lang/rust/commit/9afa190c446d4fc9c4b73eae11f67af46584cf98"}], "stats": {"total": 133, "additions": 64, "deletions": 69}, "files": [{"sha": "ac24543929b663df349edbbb7c9e59bbb8f982dc", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/dca8ddeade657e00236b2d0de2561f2fc175d6ae/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca8ddeade657e00236b2d0de2561f2fc175d6ae/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=dca8ddeade657e00236b2d0de2561f2fc175d6ae", "patch": "@@ -29,20 +29,21 @@ use std::sync::atomic::{AtomicUsize, Ordering};\n use std::sync::{Arc, Mutex};\n \n use crate::clean::{types::AttributesExt, Attributes};\n-use crate::config::Options;\n+use crate::config::Options as RustdocOptions;\n use crate::html::markdown::{self, ErrorCodes, Ignore, LangString};\n use crate::lint::init_lints;\n use crate::passes::span_of_attrs;\n \n+/// Options that apply to all doctests in a crate or Markdown file (for `rustdoc foo.md`).\n #[derive(Clone, Default)]\n-crate struct TestOptions {\n+crate struct GlobalTestOptions {\n     /// Whether to disable the default `extern crate my_crate;` when creating doctests.\n     crate no_crate_inject: bool,\n     /// Additional crate-level attributes to add to doctests.\n     crate attrs: Vec<String>,\n }\n \n-crate fn run(options: Options) -> Result<(), ErrorReported> {\n+crate fn run(options: RustdocOptions) -> Result<(), ErrorReported> {\n     let input = config::Input::File(options.input.clone());\n \n     let invalid_codeblock_attributes_name = crate::lint::INVALID_CODEBLOCK_ATTRIBUTES.name;\n@@ -214,10 +215,10 @@ crate fn run_tests(mut test_args: Vec<String>, nocapture: bool, tests: Vec<test:\n }\n \n // Look for `#![doc(test(no_crate_inject))]`, used by crates in the std facade.\n-fn scrape_test_config(attrs: &[ast::Attribute]) -> TestOptions {\n+fn scrape_test_config(attrs: &[ast::Attribute]) -> GlobalTestOptions {\n     use rustc_ast_pretty::pprust;\n \n-    let mut opts = TestOptions { no_crate_inject: false, attrs: Vec::new() };\n+    let mut opts = GlobalTestOptions { no_crate_inject: false, attrs: Vec::new() };\n \n     let test_attrs: Vec<_> = attrs\n         .iter()\n@@ -292,66 +293,63 @@ fn run_test(\n     test: &str,\n     crate_name: &str,\n     line: usize,\n-    options: Options,\n-    should_panic: bool,\n+    rustdoc_options: RustdocOptions,\n+    mut lang_string: LangString,\n     no_run: bool,\n-    as_test_harness: bool,\n     runtool: Option<String>,\n     runtool_args: Vec<String>,\n     target: TargetTriple,\n-    compile_fail: bool,\n-    mut error_codes: Vec<String>,\n-    opts: &TestOptions,\n+    opts: &GlobalTestOptions,\n     edition: Edition,\n     outdir: DirState,\n     path: PathBuf,\n     test_id: &str,\n     report_unused_externs: impl Fn(UnusedExterns),\n ) -> Result<(), TestFailure> {\n     let (test, line_offset, supports_color) =\n-        make_test(test, Some(crate_name), as_test_harness, opts, edition, Some(test_id));\n+        make_test(test, Some(crate_name), lang_string.test_harness, opts, edition, Some(test_id));\n \n     let output_file = outdir.path().join(\"rust_out\");\n \n-    let rustc_binary = options\n+    let rustc_binary = rustdoc_options\n         .test_builder\n         .as_deref()\n         .unwrap_or_else(|| rustc_interface::util::rustc_path().expect(\"found rustc\"));\n     let mut compiler = Command::new(&rustc_binary);\n     compiler.arg(\"--crate-type\").arg(\"bin\");\n-    for cfg in &options.cfgs {\n+    for cfg in &rustdoc_options.cfgs {\n         compiler.arg(\"--cfg\").arg(&cfg);\n     }\n-    if let Some(sysroot) = options.maybe_sysroot {\n+    if let Some(sysroot) = rustdoc_options.maybe_sysroot {\n         compiler.arg(\"--sysroot\").arg(sysroot);\n     }\n     compiler.arg(\"--edition\").arg(&edition.to_string());\n     compiler.env(\"UNSTABLE_RUSTDOC_TEST_PATH\", path);\n     compiler.env(\"UNSTABLE_RUSTDOC_TEST_LINE\", format!(\"{}\", line as isize - line_offset as isize));\n     compiler.arg(\"-o\").arg(&output_file);\n-    if as_test_harness {\n+    if lang_string.test_harness {\n         compiler.arg(\"--test\");\n     }\n-    if options.json_unused_externs && !compile_fail {\n+    if rustdoc_options.json_unused_externs && !lang_string.compile_fail {\n         compiler.arg(\"--error-format=json\");\n         compiler.arg(\"--json\").arg(\"unused-externs\");\n         compiler.arg(\"-Z\").arg(\"unstable-options\");\n         compiler.arg(\"-W\").arg(\"unused_crate_dependencies\");\n     }\n-    for lib_str in &options.lib_strs {\n+    for lib_str in &rustdoc_options.lib_strs {\n         compiler.arg(\"-L\").arg(&lib_str);\n     }\n-    for extern_str in &options.extern_strs {\n+    for extern_str in &rustdoc_options.extern_strs {\n         compiler.arg(\"--extern\").arg(&extern_str);\n     }\n     compiler.arg(\"-Ccodegen-units=1\");\n-    for codegen_options_str in &options.codegen_options_strs {\n+    for codegen_options_str in &rustdoc_options.codegen_options_strs {\n         compiler.arg(\"-C\").arg(&codegen_options_str);\n     }\n-    for debugging_option_str in &options.debugging_opts_strs {\n+    for debugging_option_str in &rustdoc_options.debugging_opts_strs {\n         compiler.arg(\"-Z\").arg(&debugging_option_str);\n     }\n-    if no_run && !compile_fail && options.persist_doctests.is_none() {\n+    if no_run && !lang_string.compile_fail && rustdoc_options.persist_doctests.is_none() {\n         compiler.arg(\"--emit=metadata\");\n     }\n     compiler.arg(\"--target\").arg(match target {\n@@ -360,7 +358,7 @@ fn run_test(\n             path.to_str().expect(\"target path must be valid unicode\").to_string()\n         }\n     });\n-    if let ErrorOutputType::HumanReadable(kind) = options.error_format {\n+    if let ErrorOutputType::HumanReadable(kind) = rustdoc_options.error_format {\n         let (short, color_config) = kind.unzip();\n \n         if short {\n@@ -418,20 +416,20 @@ fn run_test(\n \n     let out = out_lines.join(\"\\n\");\n     let _bomb = Bomb(&out);\n-    match (output.status.success(), compile_fail) {\n+    match (output.status.success(), lang_string.compile_fail) {\n         (true, true) => {\n             return Err(TestFailure::UnexpectedCompilePass);\n         }\n         (true, false) => {}\n         (false, true) => {\n-            if !error_codes.is_empty() {\n+            if !lang_string.error_codes.is_empty() {\n                 // We used to check if the output contained \"error[{}]: \" but since we added the\n                 // colored output, we can't anymore because of the color escape characters before\n                 // the \":\".\n-                error_codes.retain(|err| !out.contains(&format!(\"error[{}]\", err)));\n+                lang_string.error_codes.retain(|err| !out.contains(&format!(\"error[{}]\", err)));\n \n-                if !error_codes.is_empty() {\n-                    return Err(TestFailure::MissingErrorCodes(error_codes));\n+                if !lang_string.error_codes.is_empty() {\n+                    return Err(TestFailure::MissingErrorCodes(lang_string.error_codes));\n                 }\n             }\n         }\n@@ -454,11 +452,11 @@ fn run_test(\n     } else {\n         cmd = Command::new(output_file);\n     }\n-    if let Some(run_directory) = options.test_run_directory {\n+    if let Some(run_directory) = rustdoc_options.test_run_directory {\n         cmd.current_dir(run_directory);\n     }\n \n-    let result = if options.nocapture {\n+    let result = if rustdoc_options.nocapture {\n         cmd.status().map(|status| process::Output {\n             status,\n             stdout: Vec::new(),\n@@ -470,9 +468,9 @@ fn run_test(\n     match result {\n         Err(e) => return Err(TestFailure::ExecutionError(e)),\n         Ok(out) => {\n-            if should_panic && out.status.success() {\n+            if lang_string.should_panic && out.status.success() {\n                 return Err(TestFailure::UnexpectedRunPass);\n-            } else if !should_panic && !out.status.success() {\n+            } else if !lang_string.should_panic && !out.status.success() {\n                 return Err(TestFailure::ExecutionFailure(out));\n             }\n         }\n@@ -487,7 +485,7 @@ crate fn make_test(\n     s: &str,\n     crate_name: Option<&str>,\n     dont_insert_main: bool,\n-    opts: &TestOptions,\n+    opts: &GlobalTestOptions,\n     edition: Edition,\n     test_id: Option<&str>,\n ) -> (String, usize, bool) {\n@@ -804,11 +802,11 @@ crate struct Collector {\n     // the `names` vector of that test will be `[\"Title\", \"Subtitle\"]`.\n     names: Vec<String>,\n \n-    options: Options,\n+    rustdoc_options: RustdocOptions,\n     use_headers: bool,\n     enable_per_target_ignores: bool,\n     crate_name: Symbol,\n-    opts: TestOptions,\n+    opts: GlobalTestOptions,\n     position: Span,\n     source_map: Option<Lrc<SourceMap>>,\n     filename: Option<PathBuf>,\n@@ -820,17 +818,17 @@ crate struct Collector {\n impl Collector {\n     crate fn new(\n         crate_name: Symbol,\n-        options: Options,\n+        rustdoc_options: RustdocOptions,\n         use_headers: bool,\n-        opts: TestOptions,\n+        opts: GlobalTestOptions,\n         source_map: Option<Lrc<SourceMap>>,\n         filename: Option<PathBuf>,\n         enable_per_target_ignores: bool,\n     ) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             names: Vec::new(),\n-            options,\n+            rustdoc_options,\n             use_headers,\n             enable_per_target_ignores,\n             crate_name,\n@@ -884,14 +882,14 @@ impl Tester for Collector {\n         let name = self.generate_name(line, &filename);\n         let crate_name = self.crate_name.to_string();\n         let opts = self.opts.clone();\n-        let edition = config.edition.unwrap_or(self.options.edition);\n-        let options = self.options.clone();\n-        let runtool = self.options.runtool.clone();\n-        let runtool_args = self.options.runtool_args.clone();\n-        let target = self.options.target.clone();\n+        let edition = config.edition.unwrap_or(self.rustdoc_options.edition);\n+        let rustdoc_options = self.rustdoc_options.clone();\n+        let runtool = self.rustdoc_options.runtool.clone();\n+        let runtool_args = self.rustdoc_options.runtool_args.clone();\n+        let target = self.rustdoc_options.target.clone();\n         let target_str = target.to_string();\n         let unused_externs = self.unused_extern_reports.clone();\n-        let no_run = config.no_run || options.no_run;\n+        let no_run = config.no_run || rustdoc_options.no_run;\n         if !config.compile_fail {\n             self.compiling_test_count.fetch_add(1, Ordering::SeqCst);\n         }\n@@ -925,7 +923,7 @@ impl Tester for Collector {\n                 self.visited_tests.entry((file.clone(), line)).and_modify(|v| *v += 1).or_insert(0)\n             },\n         );\n-        let outdir = if let Some(mut path) = options.persist_doctests.clone() {\n+        let outdir = if let Some(mut path) = rustdoc_options.persist_doctests.clone() {\n             path.push(&test_id);\n \n             std::fs::create_dir_all(&path)\n@@ -965,15 +963,12 @@ impl Tester for Collector {\n                     &test,\n                     &crate_name,\n                     line,\n-                    options,\n-                    config.should_panic,\n+                    rustdoc_options,\n+                    config,\n                     no_run,\n-                    config.test_harness,\n                     runtool,\n                     runtool_args,\n                     target,\n-                    config.compile_fail,\n-                    config.error_codes,\n                     &opts,\n                     edition,\n                     outdir,"}, {"sha": "360d2259ea3d2ea799a833687fd57402e9a121ba", "filename": "src/librustdoc/doctest/tests.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dca8ddeade657e00236b2d0de2561f2fc175d6ae/src%2Flibrustdoc%2Fdoctest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca8ddeade657e00236b2d0de2561f2fc175d6ae/src%2Flibrustdoc%2Fdoctest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest%2Ftests.rs?ref=dca8ddeade657e00236b2d0de2561f2fc175d6ae", "patch": "@@ -1,10 +1,10 @@\n-use super::{make_test, TestOptions};\n+use super::{make_test, GlobalTestOptions};\n use rustc_span::edition::DEFAULT_EDITION;\n \n #[test]\n fn make_test_basic() {\n     //basic use: wraps with `fn main`, adds `#![allow(unused)]`\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n fn main() {\n@@ -19,7 +19,7 @@ assert_eq!(2+2, 4);\n fn make_test_crate_name_no_use() {\n     // If you give a crate name but *don't* use it within the test, it won't bother inserting\n     // the `extern crate` statement.\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n fn main() {\n@@ -34,7 +34,7 @@ assert_eq!(2+2, 4);\n fn make_test_crate_name() {\n     // If you give a crate name and use it within the test, it will insert an `extern crate`\n     // statement before `fn main`.\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"use asdf::qwop;\n assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n@@ -52,7 +52,7 @@ assert_eq!(2+2, 4);\n fn make_test_no_crate_inject() {\n     // Even if you do use the crate within the test, setting `opts.no_crate_inject` will skip\n     // adding it anyway.\n-    let opts = TestOptions { no_crate_inject: true, attrs: vec![] };\n+    let opts = GlobalTestOptions { no_crate_inject: true, attrs: vec![] };\n     let input = \"use asdf::qwop;\n assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n@@ -70,7 +70,7 @@ fn make_test_ignore_std() {\n     // Even if you include a crate name, and use it in the doctest, we still won't include an\n     // `extern crate` statement if the crate is \"std\" -- that's included already by the\n     // compiler!\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"use std::*;\n assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n@@ -87,7 +87,7 @@ assert_eq!(2+2, 4);\n fn make_test_manual_extern_crate() {\n     // When you manually include an `extern crate` statement in your doctest, `make_test`\n     // assumes you've included one for your own crate too.\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"extern crate asdf;\n use asdf::qwop;\n assert_eq!(2+2, 4);\";\n@@ -104,7 +104,7 @@ assert_eq!(2+2, 4);\n \n #[test]\n fn make_test_manual_extern_crate_with_macro_use() {\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"#[macro_use] extern crate asdf;\n use asdf::qwop;\n assert_eq!(2+2, 4);\";\n@@ -123,7 +123,7 @@ assert_eq!(2+2, 4);\n fn make_test_opts_attrs() {\n     // If you supplied some doctest attributes with `#![doc(test(attr(...)))]`, it will use\n     // those instead of the stock `#![allow(unused)]`.\n-    let mut opts = TestOptions::default();\n+    let mut opts = GlobalTestOptions::default();\n     opts.attrs.push(\"feature(sick_rad)\".to_string());\n     let input = \"use asdf::qwop;\n assert_eq!(2+2, 4);\";\n@@ -155,7 +155,7 @@ assert_eq!(2+2, 4);\n fn make_test_crate_attrs() {\n     // Including inner attributes in your doctest will apply them to the whole \"crate\", pasting\n     // them outside the generated main function.\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"#![feature(sick_rad)]\n assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n@@ -171,7 +171,7 @@ assert_eq!(2+2, 4);\n #[test]\n fn make_test_with_main() {\n     // Including your own `fn main` wrapper lets the test use it verbatim.\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"fn main() {\n     assert_eq!(2+2, 4);\n }\";\n@@ -187,7 +187,7 @@ fn main() {\n #[test]\n fn make_test_fake_main() {\n     // ... but putting it in a comment will still provide a wrapper.\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"//Ceci n'est pas une `fn main`\n assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n@@ -203,7 +203,7 @@ assert_eq!(2+2, 4);\n #[test]\n fn make_test_dont_insert_main() {\n     // Even with that, if you set `dont_insert_main`, it won't create the `fn main` wrapper.\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"//Ceci n'est pas une `fn main`\n assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n@@ -216,7 +216,7 @@ assert_eq!(2+2, 4);\"\n \n #[test]\n fn make_test_issues_21299_33731() {\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n \n     let input = \"// fn main\n assert_eq!(2+2, 4);\";\n@@ -248,7 +248,7 @@ assert_eq!(asdf::foo, 4);\n \n #[test]\n fn make_test_main_in_macro() {\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"#[macro_use] extern crate my_crate;\n test_wrapper! {\n     fn main() {}\n@@ -267,7 +267,7 @@ test_wrapper! {\n #[test]\n fn make_test_returns_result() {\n     // creates an inner function and unwraps it\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"use std::io;\n let mut input = String::new();\n io::stdin().read_line(&mut input)?;\n@@ -287,7 +287,7 @@ Ok::<(), io:Error>(())\n #[test]\n fn make_test_named_wrapper() {\n     // creates an inner function with a specific name\n-    let opts = TestOptions::default();\n+    let opts = GlobalTestOptions::default();\n     let input = \"assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n fn main() { #[allow(non_snake_case)] fn _doctest_main__some_unique_name() {"}, {"sha": "906b8f8a245709656d2e657c573de12397913eba", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dca8ddeade657e00236b2d0de2561f2fc175d6ae/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dca8ddeade657e00236b2d0de2561f2fc175d6ae/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=dca8ddeade657e00236b2d0de2561f2fc175d6ae", "patch": "@@ -7,7 +7,7 @@ use rustc_span::source_map::DUMMY_SP;\n use rustc_span::Symbol;\n \n use crate::config::{Options, RenderOptions};\n-use crate::doctest::{Collector, TestOptions};\n+use crate::doctest::{Collector, GlobalTestOptions};\n use crate::html::escape::Escape;\n use crate::html::markdown;\n use crate::html::markdown::{\n@@ -129,7 +129,7 @@ crate fn render<P: AsRef<Path>>(\n crate fn test(options: Options) -> Result<(), String> {\n     let input_str = read_to_string(&options.input)\n         .map_err(|err| format!(\"{}: {}\", options.input.display(), err))?;\n-    let mut opts = TestOptions::default();\n+    let mut opts = GlobalTestOptions::default();\n     opts.no_crate_inject = true;\n     let mut collector = Collector::new(\n         Symbol::intern(&options.input.display().to_string()),"}]}