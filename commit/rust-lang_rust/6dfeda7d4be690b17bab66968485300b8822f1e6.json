{"sha": "6dfeda7d4be690b17bab66968485300b8822f1e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZmVkYTdkNGJlNjkwYjE3YmFiNjY5Njg0ODUzMDBiODgyMmYxZTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-18T15:23:14Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-18T15:35:51Z"}, "message": "Rather than storing the relations between free-regions in a global\ntable, introduce a `FreeRegionMap` data structure. regionck computes the\n`FreeRegionMap` for each fn and stores the result into the tcx so that\nborrowck can use it (this could perhaps be refactored to have borrowck\nrecompute the map, but it's a bid tedious to recompute due to the\ninteraction of closures and free fns). The main reason to do this is\nbecause of #22779 -- using a global table was incorrect because when\nvalidating impl method signatures, we want to use the free region\nrelationships from the *trait*, not the impl.\n\nFixes #22779.", "tree": {"sha": "77ae6540ec3e107f5bff036679a52ee0a6dddbdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77ae6540ec3e107f5bff036679a52ee0a6dddbdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dfeda7d4be690b17bab66968485300b8822f1e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dfeda7d4be690b17bab66968485300b8822f1e6", "html_url": "https://github.com/rust-lang/rust/commit/6dfeda7d4be690b17bab66968485300b8822f1e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dfeda7d4be690b17bab66968485300b8822f1e6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcf637b19f1a94dcf1748b8b29fca100f150eb0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcf637b19f1a94dcf1748b8b29fca100f150eb0a", "html_url": "https://github.com/rust-lang/rust/commit/fcf637b19f1a94dcf1748b8b29fca100f150eb0a"}], "stats": {"total": 677, "additions": 444, "deletions": 233}, "files": [{"sha": "cdc6368c1e60988a5b04982265c530ee69aca56a", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -104,8 +104,10 @@ pub mod middle {\n     pub mod entry;\n     pub mod expr_use_visitor;\n     pub mod fast_reject;\n+    pub mod free_region;\n     pub mod intrinsicck;\n     pub mod infer;\n+    pub mod implicator;\n     pub mod lang_items;\n     pub mod liveness;\n     pub mod mem_categorization;"}, {"sha": "0c8a956f686a215f536d2dba73f7716ab461bf05", "filename": "src/librustc/middle/free_region.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This file defines\n+\n+use middle::implicator::Implication;\n+use middle::ty::{self, FreeRegion};\n+use util::common::can_reach;\n+use util::nodemap::FnvHashMap;\n+use util::ppaux::Repr;\n+\n+#[derive(Clone)]\n+pub struct FreeRegionMap {\n+    /// `free_region_map` maps from a free region `a` to a list of\n+    /// free regions `bs` such that `a <= b for all b in bs`\n+    map: FnvHashMap<FreeRegion, Vec<FreeRegion>>,\n+}\n+\n+impl FreeRegionMap {\n+    pub fn new() -> FreeRegionMap {\n+        FreeRegionMap { map: FnvHashMap() }\n+    }\n+\n+    pub fn relate_free_regions_from_implications<'tcx>(&mut self,\n+                                                       tcx: &ty::ctxt<'tcx>,\n+                                                       implications: &[Implication<'tcx>])\n+    {\n+        for implication in implications {\n+            debug!(\"implication: {}\", implication.repr(tcx));\n+            match *implication {\n+                Implication::RegionSubRegion(_, ty::ReFree(free_a), ty::ReFree(free_b)) => {\n+                    self.relate_free_regions(free_a, free_b);\n+                }\n+                Implication::RegionSubRegion(..) |\n+                Implication::RegionSubClosure(..) |\n+                Implication::RegionSubGeneric(..) |\n+                Implication::Predicate(..) => {\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn relate_free_regions_from_predicates<'tcx>(&mut self,\n+                                                     tcx: &ty::ctxt<'tcx>,\n+                                                     predicates: &[ty::Predicate<'tcx>]) {\n+        debug!(\"relate_free_regions_from_predicates(predicates={})\", predicates.repr(tcx));\n+        for predicate in predicates {\n+            match *predicate {\n+                ty::Predicate::Projection(..) |\n+                ty::Predicate::Trait(..) |\n+                ty::Predicate::Equate(..) |\n+                ty::Predicate::TypeOutlives(..) => {\n+                    // No region bounds here\n+                }\n+                ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n+                    match (r_a, r_b) {\n+                        (ty::ReFree(fr_a), ty::ReFree(fr_b)) => {\n+                            // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n+                            self.relate_free_regions(fr_b, fr_a);\n+                        }\n+                        _ => {\n+                            // All named regions are instantiated with free regions.\n+                            tcx.sess.bug(\n+                                &format!(\"record_region_bounds: non free region: {} / {}\",\n+                                         r_a.repr(tcx),\n+                                         r_b.repr(tcx)));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n+        let mut sups = self.map.entry(sub).or_insert(Vec::new());\n+        if !sups.contains(&sup) {\n+            sups.push(sup);\n+        }\n+    }\n+\n+    /// Determines whether two free regions have a subregion relationship\n+    /// by walking the graph encoded in `map`.  Note that\n+    /// it is possible that `sub != sup` and `sub <= sup` and `sup <= sub`\n+    /// (that is, the user can give two different names to the same lifetime).\n+    pub fn sub_free_region(&self, sub: FreeRegion, sup: FreeRegion) -> bool {\n+        can_reach(&self.map, sub, sup)\n+    }\n+\n+    /// Determines whether one region is a subregion of another.  This is intended to run *after\n+    /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n+    pub fn is_subregion_of(&self,\n+                           tcx: &ty::ctxt,\n+                           sub_region: ty::Region,\n+                           super_region: ty::Region)\n+                           -> bool {\n+        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?})\",\n+               sub_region, super_region);\n+\n+        sub_region == super_region || {\n+            match (sub_region, super_region) {\n+                (ty::ReEmpty, _) |\n+                (_, ty::ReStatic) =>\n+                    true,\n+\n+                (ty::ReScope(sub_scope), ty::ReScope(super_scope)) =>\n+                    tcx.region_maps.is_subscope_of(sub_scope, super_scope),\n+\n+                (ty::ReScope(sub_scope), ty::ReFree(ref fr)) =>\n+                    tcx.region_maps.is_subscope_of(sub_scope, fr.scope.to_code_extent()),\n+\n+                (ty::ReFree(sub_fr), ty::ReFree(super_fr)) =>\n+                    self.sub_free_region(sub_fr, super_fr),\n+\n+                _ =>\n+                    false,\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "0d6a1df7237883d8da6eefb3829a3b3110dd4fd2", "filename": "src/librustc/middle/implicator.rs", "status": "renamed", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -10,11 +10,10 @@\n \n // #![warn(deprecated_mode)]\n \n-use astconv::object_region_bounds;\n use middle::infer::{InferCtxt, GenericKind};\n use middle::subst::Substs;\n use middle::traits;\n-use middle::ty::{self, ToPolyTraitRef, Ty};\n+use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty_fold::{TypeFoldable, TypeFolder};\n \n use std::rc::Rc;\n@@ -423,6 +422,39 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n     }\n }\n \n+/// Given an object type like `SomeTrait+Send`, computes the lifetime\n+/// bounds that must hold on the elided self type. These are derived\n+/// from the declarations of `SomeTrait`, `Send`, and friends -- if\n+/// they declare `trait SomeTrait : 'static`, for example, then\n+/// `'static` would appear in the list. The hard work is done by\n+/// `ty::required_region_bounds`, see that for more information.\n+pub fn object_region_bounds<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    principal: &ty::PolyTraitRef<'tcx>,\n+    others: ty::BuiltinBounds)\n+    -> Vec<ty::Region>\n+{\n+    // Since we don't actually *know* the self type for an object,\n+    // this \"open(err)\" serves as a kind of dummy standin -- basically\n+    // a skolemized type.\n+    let open_ty = ty::mk_infer(tcx, ty::FreshTy(0));\n+\n+    // Note that we preserve the overall binding levels here.\n+    assert!(!open_ty.has_escaping_regions());\n+    let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n+    let trait_refs = vec!(ty::Binder(Rc::new(ty::TraitRef::new(principal.0.def_id, substs))));\n+\n+    let param_bounds = ty::ParamBounds {\n+        region_bounds: Vec::new(),\n+        builtin_bounds: others,\n+        trait_bounds: trait_refs,\n+        projection_bounds: Vec::new(), // not relevant to computing region bounds\n+    };\n+\n+    let predicates = ty::predicates(tcx, open_ty, &param_bounds);\n+    ty::required_region_bounds(tcx, open_ty, predicates)\n+}\n+\n impl<'tcx> Repr<'tcx> for Implication<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {", "previous_filename": "src/librustc_typeck/check/implicator.rs"}, {"sha": "63e4a5c8a2a4aed77adb22daf7868afc5134a85b", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -22,6 +22,7 @@ pub use middle::ty::IntVarValue;\n pub use self::freshen::TypeFreshener;\n pub use self::region_inference::GenericKind;\n \n+use middle::free_region::FreeRegionMap;\n use middle::subst;\n use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, UnconstrainedNumeric};\n@@ -855,8 +856,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.region_vars.new_bound(debruijn)\n     }\n \n-    pub fn resolve_regions_and_report_errors(&self, subject_node_id: ast::NodeId) {\n-        let errors = self.region_vars.resolve_regions(subject_node_id);\n+    pub fn resolve_regions_and_report_errors(&self,\n+                                             free_regions: &FreeRegionMap,\n+                                             subject_node_id: ast::NodeId) {\n+        let errors = self.region_vars.resolve_regions(free_regions, subject_node_id);\n         self.report_region_errors(&errors); // see error_reporting.rs\n     }\n "}, {"sha": "9de362fe360a625d2b2db0aaa7c41ff8ac8072cb", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 68, "deletions": 47, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -21,6 +21,7 @@ use self::Classification::*;\n use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n \n use rustc_data_structures::graph::{self, Direction, NodeIndex};\n+use middle::free_region::FreeRegionMap;\n use middle::region;\n use middle::ty::{self, Ty};\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n@@ -711,19 +712,19 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// fixed-point iteration to find region values which satisfy all\n     /// constraints, assuming such values can be found; if they cannot,\n     /// errors are reported.\n-    pub fn resolve_regions(&self, subject_node: ast::NodeId) -> Vec<RegionResolutionError<'tcx>> {\n+    pub fn resolve_regions(&self,\n+                           free_regions: &FreeRegionMap,\n+                           subject_node: ast::NodeId)\n+                           -> Vec<RegionResolutionError<'tcx>>\n+    {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = vec!();\n-        let v = self.infer_variable_values(&mut errors, subject_node);\n+        let v = self.infer_variable_values(free_regions, &mut errors, subject_node);\n         *self.values.borrow_mut() = Some(v);\n         errors\n     }\n \n-    fn is_subregion_of(&self, sub: Region, sup: Region) -> bool {\n-        self.tcx.region_maps.is_subregion_of(sub, sup)\n-    }\n-\n-    fn lub_concrete_regions(&self, a: Region, b: Region) -> Region {\n+    fn lub_concrete_regions(&self, free_regions: &FreeRegionMap, a: Region, b: Region) -> Region {\n         match (a, b) {\n           (ReLateBound(..), _) |\n           (_, ReLateBound(..)) |\n@@ -781,7 +782,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           }\n \n           (ReFree(ref a_fr), ReFree(ref b_fr)) => {\n-             self.lub_free_regions(a_fr, b_fr)\n+             self.lub_free_regions(free_regions, a_fr, b_fr)\n           }\n \n           // For these types, we cannot define any additional\n@@ -796,23 +797,25 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// Computes a region that encloses both free region arguments. Guarantee that if the same two\n     /// regions are given as argument, in any order, a consistent result is returned.\n     fn lub_free_regions(&self,\n+                        free_regions: &FreeRegionMap,\n                         a: &FreeRegion,\n                         b: &FreeRegion)\n                         -> ty::Region\n     {\n         return match a.cmp(b) {\n-            Less => helper(self, a, b),\n-            Greater => helper(self, b, a),\n+            Less => helper(self, free_regions, a, b),\n+            Greater => helper(self, free_regions, b, a),\n             Equal => ty::ReFree(*a)\n         };\n \n-        fn helper(this: &RegionVarBindings,\n+        fn helper(_this: &RegionVarBindings,\n+                  free_regions: &FreeRegionMap,\n                   a: &FreeRegion,\n                   b: &FreeRegion) -> ty::Region\n         {\n-            if this.tcx.region_maps.sub_free_region(*a, *b) {\n+            if free_regions.sub_free_region(*a, *b) {\n                 ty::ReFree(*b)\n-            } else if this.tcx.region_maps.sub_free_region(*b, *a) {\n+            } else if free_regions.sub_free_region(*b, *a) {\n                 ty::ReFree(*a)\n             } else {\n                 ty::ReStatic\n@@ -821,6 +824,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn glb_concrete_regions(&self,\n+                            free_regions: &FreeRegionMap,\n                             a: Region,\n                             b: Region)\n                             -> RelateResult<'tcx, Region>\n@@ -878,7 +882,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n \n             (ReFree(ref a_fr), ReFree(ref b_fr)) => {\n-                self.glb_free_regions(a_fr, b_fr)\n+                self.glb_free_regions(free_regions, a_fr, b_fr)\n             }\n \n             // For these types, we cannot define any additional\n@@ -898,23 +902,25 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// if the same two regions are given as argument, in any order, a consistent result is\n     /// returned.\n     fn glb_free_regions(&self,\n+                        free_regions: &FreeRegionMap,\n                         a: &FreeRegion,\n                         b: &FreeRegion)\n                         -> RelateResult<'tcx, ty::Region>\n     {\n         return match a.cmp(b) {\n-            Less => helper(self, a, b),\n-            Greater => helper(self, b, a),\n+            Less => helper(self, free_regions, a, b),\n+            Greater => helper(self, free_regions, b, a),\n             Equal => Ok(ty::ReFree(*a))\n         };\n \n         fn helper<'a, 'tcx>(this: &RegionVarBindings<'a, 'tcx>,\n+                            free_regions: &FreeRegionMap,\n                             a: &FreeRegion,\n                             b: &FreeRegion) -> RelateResult<'tcx, ty::Region>\n         {\n-            if this.tcx.region_maps.sub_free_region(*a, *b) {\n+            if free_regions.sub_free_region(*a, *b) {\n                 Ok(ty::ReFree(*a))\n-            } else if this.tcx.region_maps.sub_free_region(*b, *a) {\n+            } else if free_regions.sub_free_region(*b, *a) {\n                 Ok(ty::ReFree(*b))\n             } else {\n                 this.intersect_scopes(ty::ReFree(*a), ty::ReFree(*b),\n@@ -970,6 +976,7 @@ type RegionGraph = graph::Graph<(), Constraint>;\n \n impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn infer_variable_values(&self,\n+                             free_regions: &FreeRegionMap,\n                              errors: &mut Vec<RegionResolutionError<'tcx>>,\n                              subject: ast::NodeId) -> Vec<VarValue>\n     {\n@@ -980,12 +987,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         debug!(\"----() End constraint listing {:?}---\", self.dump_constraints());\n         graphviz::maybe_print_constraints_for(self, subject);\n \n-        self.expansion(&mut var_data);\n-        self.contraction(&mut var_data);\n+        self.expansion(free_regions, &mut var_data);\n+        self.contraction(free_regions, &mut var_data);\n         let values =\n-            self.extract_values_and_collect_conflicts(&var_data[..],\n+            self.extract_values_and_collect_conflicts(free_regions,\n+                                                      &var_data[..],\n                                                       errors);\n-        self.collect_concrete_region_errors(&values, errors);\n+        self.collect_concrete_region_errors(free_regions, &values, errors);\n         values\n     }\n \n@@ -1009,7 +1017,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n     }\n \n-    fn expansion(&self, var_data: &mut [VarData]) {\n+    fn expansion(&self, free_regions: &FreeRegionMap, var_data: &mut [VarData]) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n             debug!(\"expansion: constraint={} origin={}\",\n                    constraint.repr(self.tcx),\n@@ -1020,14 +1028,14 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n                 let b_data = &mut var_data[b_vid.index as usize];\n-                self.expand_node(a_region, b_vid, b_data)\n+                self.expand_node(free_regions, a_region, b_vid, b_data)\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n                 match var_data[a_vid.index as usize].value {\n                   NoValue | ErrorValue => false,\n                   Value(a_region) => {\n                     let b_node = &mut var_data[b_vid.index as usize];\n-                    self.expand_node(a_region, b_vid, b_node)\n+                    self.expand_node(free_regions, a_region, b_vid, b_node)\n                   }\n                 }\n               }\n@@ -1040,6 +1048,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn expand_node(&self,\n+                   free_regions: &FreeRegionMap,\n                    a_region: Region,\n                    b_vid: RegionVid,\n                    b_data: &mut VarData)\n@@ -1072,7 +1081,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           }\n \n           Value(cur_region) => {\n-            let lub = self.lub_concrete_regions(a_region, cur_region);\n+            let lub = self.lub_concrete_regions(free_regions, a_region, cur_region);\n             if lub == cur_region {\n                 return false;\n             }\n@@ -1093,6 +1102,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn contraction(&self,\n+                   free_regions: &FreeRegionMap,\n                    var_data: &mut [VarData]) {\n         self.iterate_until_fixed_point(\"Contraction\", |constraint| {\n             debug!(\"contraction: constraint={} origin={}\",\n@@ -1111,19 +1121,20 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                   NoValue | ErrorValue => false,\n                   Value(b_region) => {\n                     let a_data = &mut var_data[a_vid.index as usize];\n-                    self.contract_node(a_vid, a_data, b_region)\n+                    self.contract_node(free_regions, a_vid, a_data, b_region)\n                   }\n                 }\n               }\n               ConstrainVarSubReg(a_vid, b_region) => {\n                 let a_data = &mut var_data[a_vid.index as usize];\n-                self.contract_node(a_vid, a_data, b_region)\n+                self.contract_node(free_regions, a_vid, a_data, b_region)\n               }\n             }\n         })\n     }\n \n     fn contract_node(&self,\n+                     free_regions: &FreeRegionMap,\n                      a_vid: RegionVid,\n                      a_data: &mut VarData,\n                      b_region: Region)\n@@ -1143,19 +1154,23 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n             Value(a_region) => {\n                 match a_data.classification {\n-                    Expanding => check_node(self, a_vid, a_data, a_region, b_region),\n-                    Contracting => adjust_node(self, a_vid, a_data, a_region, b_region),\n+                    Expanding =>\n+                        check_node(self, free_regions, a_vid, a_data, a_region, b_region),\n+                    Contracting =>\n+                        adjust_node(self, free_regions, a_vid, a_data, a_region, b_region),\n                 }\n             }\n         };\n \n         fn check_node(this: &RegionVarBindings,\n+                      free_regions: &FreeRegionMap,\n                       a_vid: RegionVid,\n                       a_data: &mut VarData,\n                       a_region: Region,\n                       b_region: Region)\n-                      -> bool {\n-            if !this.is_subregion_of(a_region, b_region) {\n+                      -> bool\n+        {\n+            if !free_regions.is_subregion_of(this.tcx, a_region, b_region) {\n                 debug!(\"Setting {:?} to ErrorValue: {} not subregion of {}\",\n                        a_vid,\n                        a_region.repr(this.tcx),\n@@ -1166,12 +1181,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n \n         fn adjust_node(this: &RegionVarBindings,\n+                       free_regions: &FreeRegionMap,\n                        a_vid: RegionVid,\n                        a_data: &mut VarData,\n                        a_region: Region,\n                        b_region: Region)\n                        -> bool {\n-            match this.glb_concrete_regions(a_region, b_region) {\n+            match this.glb_concrete_regions(free_regions, a_region, b_region) {\n                 Ok(glb) => {\n                     if glb == a_region {\n                         false\n@@ -1197,14 +1213,15 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn collect_concrete_region_errors(&self,\n+                                      free_regions: &FreeRegionMap,\n                                       values: &Vec<VarValue>,\n                                       errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n         let mut reg_reg_dups = FnvHashSet();\n         for verify in &*self.verifys.borrow() {\n             match *verify {\n                 VerifyRegSubReg(ref origin, sub, sup) => {\n-                    if self.is_subregion_of(sub, sup) {\n+                    if free_regions.is_subregion_of(self.tcx, sub, sup) {\n                         continue;\n                     }\n \n@@ -1222,7 +1239,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     let sub = normalize(values, sub);\n                     if sups.iter()\n                            .map(|&sup| normalize(values, sup))\n-                           .any(|sup| self.is_subregion_of(sub, sup))\n+                           .any(|sup| free_regions.is_subregion_of(self.tcx, sub, sup))\n                     {\n                         continue;\n                     }\n@@ -1239,6 +1256,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n     fn extract_values_and_collect_conflicts(\n         &self,\n+        free_regions: &FreeRegionMap,\n         var_data: &[VarData],\n         errors: &mut Vec<RegionResolutionError<'tcx>>)\n         -> Vec<VarValue>\n@@ -1304,12 +1322,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     match var_data[idx].classification {\n                         Expanding => {\n                             self.collect_error_for_expanding_node(\n-                                graph, var_data, &mut dup_vec,\n+                                free_regions, graph, var_data, &mut dup_vec,\n                                 node_vid, errors);\n                         }\n                         Contracting => {\n                             self.collect_error_for_contracting_node(\n-                                graph, var_data, &mut dup_vec,\n+                                free_regions, graph, var_data, &mut dup_vec,\n                                 node_vid, errors);\n                         }\n                     }\n@@ -1355,13 +1373,13 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         return graph;\n     }\n \n-    fn collect_error_for_expanding_node(\n-        &self,\n-        graph: &RegionGraph,\n-        var_data: &[VarData],\n-        dup_vec: &mut [u32],\n-        node_idx: RegionVid,\n-        errors: &mut Vec<RegionResolutionError<'tcx>>)\n+    fn collect_error_for_expanding_node(&self,\n+                                        free_regions: &FreeRegionMap,\n+                                        graph: &RegionGraph,\n+                                        var_data: &[VarData],\n+                                        dup_vec: &mut [u32],\n+                                        node_idx: RegionVid,\n+                                        errors: &mut Vec<RegionResolutionError<'tcx>>)\n     {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n@@ -1394,8 +1412,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         for lower_bound in &lower_bounds {\n             for upper_bound in &upper_bounds {\n-                if !self.is_subregion_of(lower_bound.region,\n-                                         upper_bound.region) {\n+                if !free_regions.is_subregion_of(self.tcx,\n+                                                 lower_bound.region,\n+                                                 upper_bound.region) {\n                     debug!(\"pushing SubSupConflict sub: {:?} sup: {:?}\",\n                            lower_bound.region, upper_bound.region);\n                     errors.push(SubSupConflict(\n@@ -1420,6 +1439,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n     fn collect_error_for_contracting_node(\n         &self,\n+        free_regions: &FreeRegionMap,\n         graph: &RegionGraph,\n         var_data: &[VarData],\n         dup_vec: &mut [u32],\n@@ -1438,7 +1458,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         for upper_bound_1 in &upper_bounds {\n             for upper_bound_2 in &upper_bounds {\n-                match self.glb_concrete_regions(upper_bound_1.region,\n+                match self.glb_concrete_regions(free_regions,\n+                                                upper_bound_1.region,\n                                                 upper_bound_2.region) {\n                   Ok(_) => {}\n                   Err(_) => {"}, {"sha": "2c510b5f1d3b5d79d7b313dc67851cc15c0b0fa2", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 83, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -17,9 +17,8 @@\n //! `middle/typeck/infer/region_inference.rs`\n \n use session::Session;\n-use middle::ty::{self, Ty, FreeRegion};\n+use middle::ty::{self, Ty};\n use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n-use util::common::can_reach;\n \n use std::cell::RefCell;\n use syntax::codemap::{self, Span};\n@@ -234,14 +233,6 @@ pub struct RegionMaps {\n     /// which that variable is declared.\n     var_map: RefCell<NodeMap<CodeExtent>>,\n \n-    /// `free_region_map` maps from a free region `a` to a list of\n-    /// free regions `bs` such that `a <= b for all b in bs`\n-    ///\n-    /// NB. the free region map is populated during type check as we\n-    /// check each function. See the function `relate_free_regions`\n-    /// for more information.\n-    free_region_map: RefCell<FnvHashMap<FreeRegion, Vec<FreeRegion>>>,\n-\n     /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n     /// larger than the default. The map goes from the expression id\n     /// to the cleanup scope id. For rvalues not present in this\n@@ -390,13 +381,6 @@ impl RegionMaps {\n             e(child, parent)\n         }\n     }\n-    pub fn each_encl_free_region<E>(&self, mut e:E) where E: FnMut(&FreeRegion, &FreeRegion) {\n-        for (child, parents) in self.free_region_map.borrow().iter() {\n-            for parent in parents.iter() {\n-                e(child, parent)\n-            }\n-        }\n-    }\n     pub fn each_rvalue_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, &CodeExtent) {\n         for (child, parent) in self.rvalue_scopes.borrow().iter() {\n             e(child, parent)\n@@ -408,21 +392,6 @@ impl RegionMaps {\n         }\n     }\n \n-    pub fn relate_free_regions(&self, sub: FreeRegion, sup: FreeRegion) {\n-        match self.free_region_map.borrow_mut().get_mut(&sub) {\n-            Some(sups) => {\n-                if !sups.iter().any(|x| x == &sup) {\n-                    sups.push(sup);\n-                }\n-                return;\n-            }\n-            None => {}\n-        }\n-\n-        debug!(\"relate_free_regions(sub={:?}, sup={:?})\", sub, sup);\n-        self.free_region_map.borrow_mut().insert(sub, vec!(sup));\n-    }\n-\n     /// Records that `sub_fn` is defined within `sup_fn`. These ids\n     /// should be the id of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n@@ -567,56 +536,6 @@ impl RegionMaps {\n         return true;\n     }\n \n-    /// Determines whether two free regions have a subregion relationship\n-    /// by walking the graph encoded in `free_region_map`.  Note that\n-    /// it is possible that `sub != sup` and `sub <= sup` and `sup <= sub`\n-    /// (that is, the user can give two different names to the same lifetime).\n-    pub fn sub_free_region(&self, sub: FreeRegion, sup: FreeRegion) -> bool {\n-        can_reach(&*self.free_region_map.borrow(), sub, sup)\n-    }\n-\n-    /// Determines whether one region is a subregion of another.  This is intended to run *after\n-    /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n-    pub fn is_subregion_of(&self,\n-                           sub_region: ty::Region,\n-                           super_region: ty::Region)\n-                           -> bool {\n-        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?})\",\n-               sub_region, super_region);\n-\n-        sub_region == super_region || {\n-            match (sub_region, super_region) {\n-                (ty::ReEmpty, _) |\n-                (_, ty::ReStatic) => {\n-                    true\n-                }\n-\n-                (ty::ReScope(sub_scope), ty::ReScope(super_scope)) => {\n-                    self.is_subscope_of(sub_scope, super_scope)\n-                }\n-\n-                (ty::ReScope(sub_scope), ty::ReFree(ref fr)) => {\n-                    self.is_subscope_of(sub_scope, fr.scope.to_code_extent())\n-                }\n-\n-                (ty::ReFree(sub_fr), ty::ReFree(super_fr)) => {\n-                    self.sub_free_region(sub_fr, super_fr)\n-                }\n-\n-                (ty::ReEarlyBound(data_a), ty::ReEarlyBound(data_b)) => {\n-                    // This case is used only to make sure that explicitly-\n-                    // specified `Self` types match the real self type in\n-                    // implementations. Yuck.\n-                    data_a == data_b\n-                }\n-\n-                _ => {\n-                    false\n-                }\n-            }\n-        }\n-    }\n-\n     /// Finds the nearest common ancestor (if any) of two scopes.  That is, finds the smallest\n     /// scope which is greater than or equal to both `scope_a` and `scope_b`.\n     pub fn nearest_common_ancestor(&self,\n@@ -1291,7 +1210,6 @@ pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n     let maps = RegionMaps {\n         scope_map: RefCell::new(FnvHashMap()),\n         var_map: RefCell::new(NodeMap()),\n-        free_region_map: RefCell::new(FnvHashMap()),\n         rvalue_scopes: RefCell::new(NodeMap()),\n         terminating_scopes: RefCell::new(FnvHashSet()),\n         fn_tree: RefCell::new(NodeMap()),"}, {"sha": "b221c4bb685a8e501f40d48d806ff526964cedb6", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -15,6 +15,7 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n \n+use middle::free_region::FreeRegionMap;\n use middle::subst;\n use middle::ty::{self, HasProjectionTypes, Ty};\n use middle::ty_fold::TypeFoldable;\n@@ -424,7 +425,8 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n         }\n     };\n \n-    infcx.resolve_regions_and_report_errors(body_id);\n+    let free_regions = FreeRegionMap::new();\n+    infcx.resolve_regions_and_report_errors(&free_regions, body_id);\n     let predicates = match infcx.fully_resolve(&predicates) {\n         Ok(predicates) => predicates,\n         Err(fixup_err) => {"}, {"sha": "07c80b13b111820207b192248b34bb35fd8aed10", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 42, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -45,12 +45,14 @@ use middle::check_const;\n use middle::const_eval;\n use middle::def::{self, DefMap, ExportMap};\n use middle::dependency_format;\n+use middle::free_region::FreeRegionMap;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::mem_categorization as mc;\n use middle::region;\n use middle::resolve_lifetime;\n use middle::infer;\n use middle::pat_util;\n+use middle::region::RegionMaps;\n use middle::stability;\n use middle::subst::{self, ParamSpace, Subst, Substs, VecPerParamSpace};\n use middle::traits;\n@@ -620,7 +622,14 @@ pub struct ctxt<'tcx> {\n \n     pub named_region_map: resolve_lifetime::NamedRegionMap,\n \n-    pub region_maps: middle::region::RegionMaps,\n+    pub region_maps: RegionMaps,\n+\n+    // For each fn declared in the local crate, type check stores the\n+    // free-region relationships that were deduced from its where\n+    // clauses and parameter types. These are then read-again by\n+    // borrowck. (They are not used during trans, and hence are not\n+    // serialized or needed for cross-crate fns.)\n+    free_region_maps: RefCell<NodeMap<FreeRegionMap>>,\n \n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n@@ -795,6 +804,15 @@ impl<'tcx> ctxt<'tcx> {\n     pub fn node_type_insert(&self, id: NodeId, ty: Ty<'tcx>) {\n         self.node_types.borrow_mut().insert(id, ty);\n     }\n+\n+    pub fn store_free_region_map(&self, id: NodeId, map: FreeRegionMap) {\n+        self.free_region_maps.borrow_mut()\n+                             .insert(id, map);\n+    }\n+\n+    pub fn free_region_map(&self, id: NodeId) -> FreeRegionMap {\n+        self.free_region_maps.borrow()[&id].clone()\n+    }\n }\n \n // Flags that we track on types. These flags are propagated upwards\n@@ -2546,7 +2564,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      named_region_map: resolve_lifetime::NamedRegionMap,\n                      map: ast_map::Map<'tcx>,\n                      freevars: RefCell<FreevarMap>,\n-                     region_maps: middle::region::RegionMaps,\n+                     region_maps: RegionMaps,\n                      lang_items: middle::lang_items::LanguageItems,\n                      stability: stability::Index) -> ctxt<'tcx>\n {\n@@ -2561,11 +2579,12 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         region_interner: RefCell::new(FnvHashMap()),\n         types: common_types,\n         named_region_map: named_region_map,\n+        region_maps: region_maps,\n+        free_region_maps: RefCell::new(FnvHashMap()),\n         item_variance_map: RefCell::new(DefIdMap()),\n         variance_computed: Cell::new(false),\n         sess: s,\n         def_map: def_map,\n-        region_maps: region_maps,\n         node_types: RefCell::new(FnvHashMap()),\n         item_substs: RefCell::new(NodeMap()),\n         impl_trait_refs: RefCell::new(NodeMap()),\n@@ -6537,14 +6556,6 @@ pub fn construct_parameter_environment<'a,'tcx>(\n     let bounds = liberate_late_bound_regions(tcx, free_id_outlive, &ty::Binder(bounds));\n     let predicates = bounds.predicates.into_vec();\n \n-    //\n-    // Compute region bounds. For now, these relations are stored in a\n-    // global table on the tcx, so just enter them there. I'm not\n-    // crazy about this scheme, but it's convenient, at least.\n-    //\n-\n-    record_region_bounds(tcx, &*predicates);\n-\n     debug!(\"construct_parameter_environment: free_id={:?} free_subst={:?} predicates={:?}\",\n            free_id,\n            free_substs.repr(tcx),\n@@ -6573,37 +6584,7 @@ pub fn construct_parameter_environment<'a,'tcx>(\n     };\n \n     let cause = traits::ObligationCause::misc(span, free_id);\n-    return traits::normalize_param_env_or_error(unnormalized_env, cause);\n-\n-    fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>, predicates: &[ty::Predicate<'tcx>]) {\n-        debug!(\"record_region_bounds(predicates={:?})\", predicates.repr(tcx));\n-\n-        for predicate in predicates {\n-            match *predicate {\n-                Predicate::Projection(..) |\n-                Predicate::Trait(..) |\n-                Predicate::Equate(..) |\n-                Predicate::TypeOutlives(..) => {\n-                    // No region bounds here\n-                }\n-                Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n-                    match (r_a, r_b) {\n-                        (ty::ReFree(fr_a), ty::ReFree(fr_b)) => {\n-                            // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n-                            tcx.region_maps.relate_free_regions(fr_b, fr_a);\n-                        }\n-                        _ => {\n-                            // All named regions are instantiated with free regions.\n-                            tcx.sess.bug(\n-                                &format!(\"record_region_bounds: non free region: {} / {}\",\n-                                         r_a.repr(tcx),\n-                                         r_b.repr(tcx)));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n+    traits::normalize_param_env_or_error(unnormalized_env, cause)\n }\n \n impl BorrowKind {"}, {"sha": "aedc0d23cfe1ddee4e21deda1fa07dce51be08de", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 43, "deletions": 7, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -27,9 +27,11 @@ use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n+use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::region;\n use rustc::middle::ty::{self, Ty};\n use rustc::util::ppaux::{note_and_explain_region, Repr, UserString};\n+use std::mem;\n use std::rc::Rc;\n use std::string::String;\n use syntax::ast;\n@@ -56,7 +58,20 @@ pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator\n impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n                 b: &'v Block, s: Span, id: ast::NodeId) {\n-        borrowck_fn(self, fk, fd, b, s, id);\n+        match fk {\n+            visit::FkItemFn(..) |\n+            visit::FkMethod(..) => {\n+                let new_free_region_map = self.tcx.free_region_map(id);\n+                let old_free_region_map =\n+                    mem::replace(&mut self.free_region_map, new_free_region_map);\n+                borrowck_fn(self, fk, fd, b, s, id);\n+                self.free_region_map = old_free_region_map;\n+            }\n+\n+            visit::FkFnBlock => {\n+                borrowck_fn(self, fk, fd, b, s, id);\n+            }\n+        }\n     }\n \n     fn visit_item(&mut self, item: &ast::Item) {\n@@ -67,6 +82,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n pub fn check_crate(tcx: &ty::ctxt) {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n+        free_region_map: FreeRegionMap::new(),\n         stats: BorrowStats {\n             loaned_paths_same: 0,\n             loaned_paths_imm: 0,\n@@ -129,11 +145,13 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     let cfg = cfg::CFG::new(this.tcx, body);\n     let AnalysisData { all_loans,\n                        loans: loan_dfcx,\n-                       move_data:flowed_moves } =\n+                       move_data: flowed_moves } =\n         build_borrowck_dataflow_data(this, fk, decl, &cfg, body, sp, id);\n \n     move_data::fragments::instrument_move_fragments(&flowed_moves.move_data,\n-                                                    this.tcx, sp, id);\n+                                                    this.tcx,\n+                                                    sp,\n+                                                    id);\n \n     check_loans::check_loans(this,\n                              &loan_dfcx,\n@@ -152,7 +170,9 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                           cfg: &cfg::CFG,\n                                           body: &ast::Block,\n                                           sp: Span,\n-                                          id: ast::NodeId) -> AnalysisData<'a, 'tcx> {\n+                                          id: ast::NodeId)\n+                                          -> AnalysisData<'a, 'tcx>\n+{\n     // Check the body of fn items.\n     let id_range = ast_util::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n     let (all_loans, move_data) =\n@@ -203,10 +223,13 @@ impl<'a> FnPartsWithCFG<'a> {\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     tcx: &'a ty::ctxt<'tcx>,\n-    input: FnPartsWithCFG<'a>) -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>) {\n+    input: FnPartsWithCFG<'a>)\n+    -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>)\n+{\n \n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n+        free_region_map: FreeRegionMap::new(),\n         stats: BorrowStats {\n             loaned_paths_same: 0,\n             loaned_paths_imm: 0,\n@@ -234,6 +257,18 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n \n+    // Hacky. As we visit various fns, we have to load up the\n+    // free-region map for each one. This map is computed by during\n+    // typeck for each fn item and stored -- closures just use the map\n+    // from the fn item that encloses them. Since we walk the fns in\n+    // order, we basically just overwrite this field as we enter a fn\n+    // item and restore it afterwards in a stack-like fashion. Then\n+    // the borrow checking code can assume that `free_region_map` is\n+    // always the correct map for the current fn. Feels like it'd be\n+    // better to just recompute this, rather than store it, but it's a\n+    // bit of a pain to factor that code out at the moment.\n+    free_region_map: FreeRegionMap,\n+\n     // Statistics:\n     stats: BorrowStats\n }\n@@ -518,8 +553,9 @@ pub enum MovedValueUseKind {\n \n impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region)\n-                           -> bool {\n-        self.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n+                           -> bool\n+    {\n+        self.free_region_map.is_subregion_of(self.tcx, r_sub, r_sup)\n     }\n \n     pub fn report(&self, err: BckError<'tcx>) {"}, {"sha": "7d48033483a71636852698b955008fb660f8804c", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -51,6 +51,7 @@\n use middle::astconv_util::{prim_ty_to_ty, check_path_args, NO_TPS, NO_REGIONS};\n use middle::const_eval;\n use middle::def;\n+use middle::implicator::object_region_bounds;\n use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n@@ -2076,39 +2077,6 @@ fn compute_object_lifetime_bound<'tcx>(\n     return r;\n }\n \n-/// Given an object type like `SomeTrait+Send`, computes the lifetime\n-/// bounds that must hold on the elided self type. These are derived\n-/// from the declarations of `SomeTrait`, `Send`, and friends -- if\n-/// they declare `trait SomeTrait : 'static`, for example, then\n-/// `'static` would appear in the list. The hard work is done by\n-/// `ty::required_region_bounds`, see that for more information.\n-pub fn object_region_bounds<'tcx>(\n-    tcx: &ty::ctxt<'tcx>,\n-    principal: &ty::PolyTraitRef<'tcx>,\n-    others: ty::BuiltinBounds)\n-    -> Vec<ty::Region>\n-{\n-    // Since we don't actually *know* the self type for an object,\n-    // this \"open(err)\" serves as a kind of dummy standin -- basically\n-    // a skolemized type.\n-    let open_ty = ty::mk_infer(tcx, ty::FreshTy(0));\n-\n-    // Note that we preserve the overall binding levels here.\n-    assert!(!open_ty.has_escaping_regions());\n-    let substs = tcx.mk_substs(principal.0.substs.with_self_ty(open_ty));\n-    let trait_refs = vec!(ty::Binder(Rc::new(ty::TraitRef::new(principal.0.def_id, substs))));\n-\n-    let param_bounds = ty::ParamBounds {\n-        region_bounds: Vec::new(),\n-        builtin_bounds: others,\n-        trait_bounds: trait_refs,\n-        projection_bounds: Vec::new(), // not relevant to computing region bounds\n-    };\n-\n-    let predicates = ty::predicates(tcx, open_ty, &param_bounds);\n-    ty::required_region_bounds(tcx, open_ty, predicates)\n-}\n-\n pub struct PartitionedBounds<'a> {\n     pub builtin_bounds: ty::BuiltinBounds,\n     pub trait_bounds: Vec<&'a ast::PolyTraitRef>,"}, {"sha": "c4ee7e79570da570d57deabf1d08e16e42c52ddc", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::free_region::FreeRegionMap;\n use middle::infer;\n use middle::traits;\n use middle::ty::{self};\n@@ -354,9 +355,19 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         Ok(_) => {}\n     }\n \n-    // Finally, resolve all regions. This catches wily misuses of lifetime\n-    // parameters.\n-    infcx.resolve_regions_and_report_errors(impl_m_body_id);\n+    // Finally, resolve all regions. This catches wily misuses of\n+    // lifetime parameters. We have to build up a plausible lifetime\n+    // environment based on what we find in the trait. We could also\n+    // include the obligations derived from the method argument types,\n+    // but I don't think it's necessary -- after all, those are still\n+    // in effect when type-checking the body, and all the\n+    // where-clauses in the header etc should be implied by the trait\n+    // anyway, so it shouldn't be needed there either. Anyway, we can\n+    // always add more relations later (it's backwards compat).\n+    let mut free_regions = FreeRegionMap::new();\n+    free_regions.relate_free_regions_from_predicates(tcx, &trait_param_env.caller_bounds);\n+\n+    infcx.resolve_regions_and_report_errors(&free_regions, impl_m_body_id);\n \n     fn check_region_bounds_on_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                 span: Span,"}, {"sha": "001c0a6ae478f70cf6895009fd1425b65bcbc9bd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -132,7 +132,6 @@ pub mod dropck;\n pub mod _match;\n pub mod vtable;\n pub mod writeback;\n-pub mod implicator;\n pub mod regionck;\n pub mod coercion;\n pub mod demand;"}, {"sha": "2e8c5730e67cb01b7c3c8c6a76d0525113f43d3f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -85,8 +85,9 @@\n use astconv::AstConv;\n use check::dropck;\n use check::FnCtxt;\n-use check::implicator;\n use check::vtable;\n+use middle::free_region::FreeRegionMap;\n+use middle::implicator;\n use middle::mem_categorization as mc;\n use middle::region::CodeExtent;\n use middle::subst::Substs;\n@@ -124,6 +125,8 @@ pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n \n pub fn regionck_item(fcx: &FnCtxt, item: &ast::Item) {\n     let mut rcx = Rcx::new(fcx, RepeatingScope(item.id), item.id, Subject(item.id));\n+    let tcx = fcx.tcx();\n+    rcx.free_region_map.relate_free_regions_from_predicates(tcx, &fcx.inh.param_env.caller_bounds);\n     rcx.visit_region_obligations(item.id);\n     rcx.resolve_regions_and_report_errors();\n }\n@@ -135,12 +138,21 @@ pub fn regionck_fn(fcx: &FnCtxt,\n                    blk: &ast::Block) {\n     debug!(\"regionck_fn(id={})\", fn_id);\n     let mut rcx = Rcx::new(fcx, RepeatingScope(blk.id), blk.id, Subject(fn_id));\n+\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n         rcx.visit_fn_body(fn_id, decl, blk, fn_span);\n     }\n \n+    let tcx = fcx.tcx();\n+    rcx.free_region_map.relate_free_regions_from_predicates(tcx, &fcx.inh.param_env.caller_bounds);\n+\n     rcx.resolve_regions_and_report_errors();\n+\n+    // For the top-level fn, store the free-region-map. We don't store\n+    // any map for closures; they just share the same map as the\n+    // function that created them.\n+    fcx.tcx().store_free_region_map(fn_id, rcx.free_region_map);\n }\n \n /// Checks that the types in `component_tys` are well-formed. This will add constraints into the\n@@ -167,6 +179,8 @@ pub struct Rcx<'a, 'tcx: 'a> {\n \n     region_bound_pairs: Vec<(ty::Region, GenericKind<'tcx>)>,\n \n+    free_region_map: FreeRegionMap,\n+\n     // id of innermost fn body id\n     body_id: ast::NodeId,\n \n@@ -191,7 +205,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n               repeating_scope: initial_repeating_scope,\n               body_id: initial_body_id,\n               subject: subject,\n-              region_bound_pairs: Vec::new()\n+              region_bound_pairs: Vec::new(),\n+              free_region_map: FreeRegionMap::new(),\n         }\n     }\n \n@@ -277,13 +292,16 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             }\n         };\n \n-        let len = self.region_bound_pairs.len();\n+        let old_region_bounds_pairs_len = self.region_bound_pairs.len();\n+\n         let old_body_id = self.set_body_id(body.id);\n         self.relate_free_regions(&fn_sig[..], body.id, span);\n         link_fn_args(self, CodeExtent::from_node_id(body.id), &fn_decl.inputs[..]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n-        self.region_bound_pairs.truncate(len);\n+\n+        self.region_bound_pairs.truncate(old_region_bounds_pairs_len);\n+\n         self.set_body_id(old_body_id);\n     }\n \n@@ -340,14 +358,16 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             let body_scope = ty::ReScope(body_scope);\n             let implications = implicator::implications(self.fcx.infcx(), self.fcx, body_id,\n                                                         ty, body_scope, span);\n+\n+            // Record any relations between free regions that we observe into the free-region-map.\n+            self.free_region_map.relate_free_regions_from_implications(tcx, &implications);\n+\n+            // But also record other relationships, such as `T:'x`,\n+            // that don't go into the free-region-map but which we use\n+            // here.\n             for implication in implications {\n                 debug!(\"implication: {}\", implication.repr(tcx));\n                 match implication {\n-                    implicator::Implication::RegionSubRegion(_,\n-                                                             ty::ReFree(free_a),\n-                                                             ty::ReFree(free_b)) => {\n-                        tcx.region_maps.relate_free_regions(free_a, free_b);\n-                    }\n                     implicator::Implication::RegionSubRegion(_,\n                                                              ty::ReFree(free_a),\n                                                              ty::ReInfer(ty::ReVar(vid_b))) => {\n@@ -388,7 +408,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             }\n         };\n \n-        self.fcx.infcx().resolve_regions_and_report_errors(subject_node_id);\n+        self.fcx.infcx().resolve_regions_and_report_errors(&self.free_region_map,\n+                                                           subject_node_id);\n     }\n }\n "}, {"sha": "23959d578bf0320a2013f979e88c8cb8536a15d8", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -68,6 +68,7 @@ use astconv::{self, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n use middle::def;\n use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n+use middle::free_region::FreeRegionMap;\n use middle::region;\n use middle::resolve_lifetime;\n use middle::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n@@ -2158,7 +2159,16 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n                 format!(\"mismatched self type: expected `{}`\",\n                         ppaux::ty_to_string(tcx, required_type))\n         }));\n-        infcx.resolve_regions_and_report_errors(body_id);\n+\n+        // We could conceviably add more free-reion relations here,\n+        // but since this code is just concerned with checking that\n+        // the `&Self` types etc match up, it's not really necessary.\n+        // It would just allow people to be more approximate in some\n+        // cases. In any case, we can do it later as we feel the need;\n+        // I'd like this function to go away eventually.\n+        let free_regions = FreeRegionMap::new();\n+\n+        infcx.resolve_regions_and_report_errors(&free_regions, body_id);\n     }\n \n     fn liberate_early_bound_regions<'tcx,T>("}, {"sha": "5bcc6be4c3d3b05c39a7a91554253a2216c65d2d", "filename": "src/test/compile-fail/region-bound-extra-bound-in-impl.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Ftest%2Fcompile-fail%2Fregion-bound-extra-bound-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Ftest%2Fcompile-fail%2Fregion-bound-extra-bound-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-bound-extra-bound-in-impl.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #22779. An extra where clause was\n+// permitted on the impl that is not present on the trait.\n+\n+trait Tr<'a, T> {\n+    fn renew<'b: 'a>(self) -> &'b mut [T];\n+}\n+\n+impl<'a, T> Tr<'a, T> for &'a mut [T] {\n+    fn renew<'b: 'a>(self) -> &'b mut [T] where 'a: 'b {\n+        //~^ ERROR lifetime bound not satisfied\n+        &mut self[..]\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "c1df057b396095784fcabb52c6c7d5d92880bfae", "filename": "src/test/compile-fail/region-bound-extra-bound-in-inherent-impl.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Ftest%2Fcompile-fail%2Fregion-bound-extra-bound-in-inherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Ftest%2Fcompile-fail%2Fregion-bound-extra-bound-in-inherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-bound-extra-bound-in-inherent-impl.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test related to #22779. In this case, the impl is an inherent impl,\n+// so it doesn't have to match any trait, so no error results.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+struct MySlice<'a, T:'a>(&'a mut [T]);\n+\n+impl<'a, T> MySlice<'a, T> {\n+    fn renew<'b: 'a>(self) -> &'b mut [T] where 'a: 'b {\n+        &mut self.0[..]\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "3115e5a9a437645d0c53ac8fa4e8b4363e27c24c", "filename": "src/test/compile-fail/region-bound-same-bounds-in-trait-and-impl.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Ftest%2Fcompile-fail%2Fregion-bound-same-bounds-in-trait-and-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Ftest%2Fcompile-fail%2Fregion-bound-same-bounds-in-trait-and-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-bound-same-bounds-in-trait-and-impl.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test related to #22779, but where the `'a:'b` relation\n+// appears in the trait too. No error here.\n+\n+#![feature(rustc_attrs)]\n+\n+trait Tr<'a, T> {\n+    fn renew<'b: 'a>(self) -> &'b mut [T] where 'a: 'b;\n+}\n+\n+impl<'a, T> Tr<'a, T> for &'a mut [T] {\n+    fn renew<'b: 'a>(self) -> &'b mut [T] where 'a: 'b {\n+        &mut self[..]\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "abffd33e3f83e857a192aa63a1264621be8f52a5", "filename": "src/test/compile-fail/regions-bound-missing-bound-in-impl.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dfeda7d4be690b17bab66968485300b8822f1e6/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs?ref=6dfeda7d4be690b17bab66968485300b8822f1e6", "patch": "@@ -50,7 +50,9 @@ impl<'a, 't> Foo<'a, 't> for &'a isize {\n     fn okay_bound<'b,'c,'e:'b+'c>(self, b: Inv<'b>, c: Inv<'c>, e: Inv<'e>) {\n     }\n \n-    fn another_bound<'x: 't>(self, x: Inv<'x>, y: Inv<'t>) {}\n+    fn another_bound<'x: 't>(self, x: Inv<'x>, y: Inv<'t>) {\n+        //~^ ERROR lifetime bound not satisfied\n+    }\n }\n \n fn main() { }"}]}