{"sha": "72d8e7e69abca9f27fb3ea386a6879324741e152", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyZDhlN2U2OWFiY2E5ZjI3ZmIzZWEzODZhNjg3OTMyNDc0MWUxNTI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T15:00:36Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T15:01:34Z"}, "message": "Use TraitId in TraitRef", "tree": {"sha": "55d2afdba12adaff0e7c329b6d0dfc79efb6db73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55d2afdba12adaff0e7c329b6d0dfc79efb6db73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72d8e7e69abca9f27fb3ea386a6879324741e152", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72d8e7e69abca9f27fb3ea386a6879324741e152", "html_url": "https://github.com/rust-lang/rust/commit/72d8e7e69abca9f27fb3ea386a6879324741e152", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72d8e7e69abca9f27fb3ea386a6879324741e152/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6560e4ff2eae4e54384896d6ae100f1d2df20518", "url": "https://api.github.com/repos/rust-lang/rust/commits/6560e4ff2eae4e54384896d6ae100f1d2df20518", "html_url": "https://github.com/rust-lang/rust/commit/6560e4ff2eae4e54384896d6ae100f1d2df20518"}], "stats": {"total": 136, "additions": 68, "deletions": 68}, "files": [{"sha": "7b5d78543a71c7ed53bebd002930c602f9b454ac", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72d8e7e69abca9f27fb3ea386a6879324741e152/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72d8e7e69abca9f27fb3ea386a6879324741e152/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=72d8e7e69abca9f27fb3ea386a6879324741e152", "patch": "@@ -741,7 +741,7 @@ impl Trait {\n     }\n \n     pub fn trait_ref(self, db: &impl HirDatabase) -> TraitRef {\n-        TraitRef::for_trait(db, self)\n+        TraitRef::for_trait(db, self.id)\n     }\n \n     pub fn is_auto(self, db: &impl DefDatabase) -> bool {"}, {"sha": "3711068faf696a7120fd3d584e2501423147a529", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/72d8e7e69abca9f27fb3ea386a6879324741e152/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72d8e7e69abca9f27fb3ea386a6879324741e152/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=72d8e7e69abca9f27fb3ea386a6879324741e152", "patch": "@@ -26,7 +26,7 @@ use ra_db::{impl_intern_key, salsa};\n \n use crate::{\n     db::HirDatabase, expr::ExprId, util::make_mut_slice, Adt, Crate, FloatTy, IntTy, Mutability,\n-    Name, Trait, Uncertain,\n+    Name, Uncertain,\n };\n use display::{HirDisplay, HirFormatter};\n \n@@ -445,7 +445,7 @@ impl Deref for Substs {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct TraitRef {\n     /// FIXME name?\n-    pub trait_: Trait,\n+    pub trait_: TraitId,\n     pub substs: Substs,\n }\n \n@@ -676,7 +676,7 @@ impl Ty {\n     }\n \n     /// If this is an `impl Trait` or `dyn Trait`, returns that trait.\n-    pub fn inherent_trait(&self) -> Option<Trait> {\n+    pub fn inherent_trait(&self) -> Option<TraitId> {\n         match self {\n             Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n                 predicates.iter().find_map(|pred| match pred {\n@@ -988,7 +988,10 @@ impl HirDisplay for Ty {\n                             write!(\n                                 f,\n                                 \"{}\",\n-                                trait_ref.trait_.name(f.db).unwrap_or_else(Name::missing)\n+                                f.db.trait_data(trait_ref.trait_)\n+                                    .name\n+                                    .clone()\n+                                    .unwrap_or_else(Name::missing)\n                             )?;\n                             if trait_ref.substs.len() > 1 {\n                                 write!(f, \"<\")?;\n@@ -1049,7 +1052,7 @@ impl TraitRef {\n         } else {\n             write!(f, \": \")?;\n         }\n-        write!(f, \"{}\", self.trait_.name(f.db).unwrap_or_else(Name::missing))?;\n+        write!(f, \"{}\", f.db.trait_data(self.trait_).name.clone().unwrap_or_else(Name::missing))?;\n         if self.substs.len() > 1 {\n             write!(f, \"<\")?;\n             f.write_joined(&self.substs[1..], \", \")?;"}, {"sha": "202fff4f3737538d4f93cb8c5a629a1de1660003", "filename": "crates/ra_hir/src/ty/infer/path.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/72d8e7e69abca9f27fb3ea386a6879324741e152/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72d8e7e69abca9f27fb3ea386a6879324741e152/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs?ref=72d8e7e69abca9f27fb3ea386a6879324741e152", "patch": "@@ -143,24 +143,27 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n         let trait_ = trait_ref.trait_;\n-        let item = trait_.items(self.db).iter().copied().find_map(|item| match item {\n-            AssocItem::Function(func) => {\n-                if segment.name == func.name(self.db) {\n-                    Some(AssocItem::Function(func))\n-                } else {\n-                    None\n-                }\n-            }\n+        let item =\n+            self.db.trait_data(trait_).items.iter().map(|(_name, id)| (*id).into()).find_map(\n+                |item| match item {\n+                    AssocItem::Function(func) => {\n+                        if segment.name == func.name(self.db) {\n+                            Some(AssocItem::Function(func))\n+                        } else {\n+                            None\n+                        }\n+                    }\n \n-            AssocItem::Const(konst) => {\n-                if konst.name(self.db).map_or(false, |n| n == segment.name) {\n-                    Some(AssocItem::Const(konst))\n-                } else {\n-                    None\n-                }\n-            }\n-            AssocItem::TypeAlias(_) => None,\n-        })?;\n+                    AssocItem::Const(konst) => {\n+                        if konst.name(self.db).map_or(false, |n| n == segment.name) {\n+                            Some(AssocItem::Const(konst))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    AssocItem::TypeAlias(_) => None,\n+                },\n+            )?;\n         let def = match item {\n             AssocItem::Function(f) => ValueNs::FunctionId(f.id),\n             AssocItem::Const(c) => ValueNs::ConstId(c.id),\n@@ -212,7 +215,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             .fill_with_params()\n                             .build();\n                         self.obligations.push(super::Obligation::Trait(TraitRef {\n-                            trait_: t,\n+                            trait_: t.id,\n                             substs: trait_substs,\n                         }));\n                         Some(substs)"}, {"sha": "a7149614d4c0deda63a562dd796f0cf12998a1a9", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/72d8e7e69abca9f27fb3ea386a6879324741e152/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72d8e7e69abca9f27fb3ea386a6879324741e152/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=72d8e7e69abca9f27fb3ea386a6879324741e152", "patch": "@@ -15,7 +15,7 @@ use hir_def::{\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n     AdtId, AstItemDef, EnumVariantId, FunctionId, GenericDefId, HasModule, LocalStructFieldId,\n-    Lookup, StructId, VariantId,\n+    Lookup, StructId, TraitId, VariantId,\n };\n use ra_arena::map::ArenaMap;\n use ra_db::CrateId;\n@@ -172,7 +172,7 @@ impl Ty {\n                     let segment = &remaining_segments[0];\n                     let associated_ty = associated_type_by_name_including_super_traits(\n                         db,\n-                        trait_ref.trait_.id,\n+                        trait_ref.trait_,\n                         &segment.name,\n                     );\n                     match associated_ty {\n@@ -263,7 +263,7 @@ impl Ty {\n             GenericPredicate::Implemented(tr) if tr.self_ty() == &self_ty => Some(tr.trait_),\n             _ => None,\n         });\n-        let traits = traits_from_env.flat_map(|t| all_super_traits(db, t.id)).map(Trait::from);\n+        let traits = traits_from_env.flat_map(|t| all_super_traits(db, t)).map(Trait::from);\n         for t in traits {\n             if let Some(associated_ty) = db.trait_data(t.id).associated_type_by_name(&segment.name)\n             {\n@@ -423,7 +423,7 @@ impl TraitRef {\n         if let Some(self_ty) = explicit_self_ty {\n             make_mut_slice(&mut substs.0)[0] = self_ty;\n         }\n-        TraitRef { trait_: resolved, substs }\n+        TraitRef { trait_: resolved.id, substs }\n     }\n \n     pub(crate) fn from_hir(\n@@ -450,8 +450,8 @@ impl TraitRef {\n         substs_from_path_segment(db, resolver, segment, Some(resolved.id.into()), !has_self_param)\n     }\n \n-    pub(crate) fn for_trait(db: &impl HirDatabase, trait_: Trait) -> TraitRef {\n-        let substs = Substs::identity(&db.generic_params(trait_.id.into()));\n+    pub(crate) fn for_trait(db: &impl HirDatabase, trait_: TraitId) -> TraitRef {\n+        let substs = Substs::identity(&db.generic_params(trait_.into()));\n         TraitRef { trait_, substs }\n     }\n \n@@ -510,7 +510,7 @@ fn assoc_type_bindings_from_type_bound<'a>(\n         .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n         .map(move |(name, type_ref)| {\n             let associated_ty =\n-                associated_type_by_name_including_super_traits(db, trait_ref.trait_.id, &name);\n+                associated_type_by_name_including_super_traits(db, trait_ref.trait_, &name);\n             let associated_ty = match associated_ty {\n                 None => return GenericPredicate::Error,\n                 Some(t) => t,"}, {"sha": "f1bc638eec4fd5847140fb1d2e0cb771885d7306", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/72d8e7e69abca9f27fb3ea386a6879324741e152/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72d8e7e69abca9f27fb3ea386a6879324741e152/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=72d8e7e69abca9f27fb3ea386a6879324741e152", "patch": "@@ -68,7 +68,7 @@ impl CrateImplBlocks {\n                         if let Some(tr) =\n                             TraitRef::from_hir(db, &resolver, &trait_ref, Some(target_ty))\n                         {\n-                            res.impls_by_trait.entry(tr.trait_.id).or_default().push(impl_id);\n+                            res.impls_by_trait.entry(tr.trait_).or_default().push(impl_id);\n                         }\n                     }\n                     None => {\n@@ -249,13 +249,11 @@ fn iterate_trait_method_candidates<T>(\n     let traits_from_env = env\n         .trait_predicates_for_self_ty(&ty.value)\n         .map(|tr| tr.trait_)\n-        .flat_map(|t| all_super_traits(db, t.id))\n-        .map(Trait::from);\n-    let traits = inherent_trait\n-        .chain(traits_from_env)\n-        .chain(resolver.traits_in_scope(db).into_iter().map(Trait::from));\n+        .flat_map(|t| all_super_traits(db, t));\n+    let traits =\n+        inherent_trait.chain(traits_from_env).chain(resolver.traits_in_scope(db).into_iter());\n     'traits: for t in traits {\n-        let data = db.trait_data(t.id);\n+        let data = db.trait_data(t);\n \n         // we'll be lazy about checking whether the type implements the\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n@@ -330,7 +328,7 @@ pub(crate) fn implements_trait(\n     db: &impl HirDatabase,\n     resolver: &Resolver,\n     krate: Crate,\n-    trait_: Trait,\n+    trait_: TraitId,\n ) -> bool {\n     if ty.value.inherent_trait() == Some(trait_) {\n         // FIXME this is a bit of a hack, since Chalk should say the same thing\n@@ -373,11 +371,11 @@ impl Ty {\n fn generic_implements_goal(\n     db: &impl HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    trait_: Trait,\n+    trait_: TraitId,\n     self_ty: Canonical<Ty>,\n ) -> Canonical<InEnvironment<super::Obligation>> {\n     let num_vars = self_ty.num_vars;\n-    let substs = super::Substs::build_for_def(db, trait_.id)\n+    let substs = super::Substs::build_for_def(db, trait_)\n         .push(self_ty.value)\n         .fill_with_bound_vars(num_vars as u32)\n         .build();"}, {"sha": "02d37deadd7d38e0be1f2dc7c85600abe8c6ff7f", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/72d8e7e69abca9f27fb3ea386a6879324741e152/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72d8e7e69abca9f27fb3ea386a6879324741e152/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=72d8e7e69abca9f27fb3ea386a6879324741e152", "patch": "@@ -9,7 +9,9 @@ use chalk_ir::{\n };\n use chalk_rust_ir::{AssociatedTyDatum, AssociatedTyValue, ImplDatum, StructDatum, TraitDatum};\n \n-use hir_def::{lang_item::LangItemTarget, ContainerId, GenericDefId, Lookup, TraitId, TypeAliasId};\n+use hir_def::{\n+    lang_item::LangItemTarget, AstItemDef, ContainerId, GenericDefId, Lookup, TraitId, TypeAliasId,\n+};\n use hir_expand::name;\n \n use ra_db::salsa::{InternId, InternKey};\n@@ -19,7 +21,7 @@ use crate::{\n     db::HirDatabase,\n     ty::display::HirDisplay,\n     ty::{ApplicationTy, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk},\n-    Crate, ImplBlock, Trait, TypeAlias,\n+    Crate, ImplBlock, TypeAlias,\n };\n \n /// This represents a trait whose name we could not resolve.\n@@ -167,15 +169,15 @@ impl ToChalk for TraitRef {\n     }\n }\n \n-impl ToChalk for Trait {\n+impl ToChalk for TraitId {\n     type Chalk = chalk_ir::TraitId;\n \n     fn to_chalk(self, _db: &impl HirDatabase) -> chalk_ir::TraitId {\n-        chalk_ir::TraitId(id_to_chalk(self.id))\n+        chalk_ir::TraitId(id_to_chalk(self))\n     }\n \n-    fn from_chalk(_db: &impl HirDatabase, trait_id: chalk_ir::TraitId) -> Trait {\n-        Trait { id: id_from_chalk(trait_id.0) }\n+    fn from_chalk(_db: &impl HirDatabase, trait_id: chalk_ir::TraitId) -> TraitId {\n+        id_from_chalk(trait_id.0)\n     }\n }\n \n@@ -443,10 +445,10 @@ where\n         if trait_id == UNKNOWN_TRAIT {\n             return Vec::new();\n         }\n-        let trait_: Trait = from_chalk(self.db, trait_id);\n+        let trait_: TraitId = from_chalk(self.db, trait_id);\n         let mut result: Vec<_> = self\n             .db\n-            .impls_for_trait(self.krate, trait_)\n+            .impls_for_trait(self.krate, trait_.into())\n             .iter()\n             .copied()\n             .map(Impl::ImplBlock)\n@@ -459,7 +461,7 @@ where\n                 [super::FnTrait::FnOnce, super::FnTrait::FnMut, super::FnTrait::Fn].iter()\n             {\n                 if let Some(actual_trait) = get_fn_trait(self.db, self.krate, fn_trait) {\n-                    if trait_.id == actual_trait {\n+                    if trait_ == actual_trait {\n                         let impl_ = super::ClosureFnTraitImplData { def, expr, fn_trait };\n                         result.push(Impl::ClosureFnTraitImpl(impl_).to_chalk(self.db));\n                     }\n@@ -516,7 +518,7 @@ pub(crate) fn associated_ty_data_query(\n         where_clauses: vec![],\n     };\n     let datum = AssociatedTyDatum {\n-        trait_id: Trait::from(trait_).to_chalk(db),\n+        trait_id: trait_.to_chalk(db),\n         id,\n         name: lalrpop_intern::intern(&db.type_alias_data(type_alias).name.to_string()),\n         binders: make_binders(bound_data, generic_params.count_params_including_parent()),\n@@ -548,29 +550,23 @@ pub(crate) fn trait_datum_query(\n             associated_ty_ids: vec![],\n         });\n     }\n-    let trait_: Trait = from_chalk(db, trait_id);\n-    debug!(\"trait {:?} = {:?}\", trait_id, trait_.name(db));\n-    let generic_params = db.generic_params(trait_.id.into());\n+    let trait_: TraitId = from_chalk(db, trait_id);\n+    let trait_data = db.trait_data(trait_);\n+    debug!(\"trait {:?} = {:?}\", trait_id, trait_data.name);\n+    let generic_params = db.generic_params(trait_.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let flags = chalk_rust_ir::TraitFlags {\n-        auto: trait_.is_auto(db),\n-        upstream: trait_.module(db).krate() != krate,\n+        auto: trait_data.auto,\n+        upstream: trait_.module(db).krate != krate.crate_id,\n         non_enumerable: true,\n         coinductive: false, // only relevant for Chalk testing\n         // FIXME set these flags correctly\n         marker: false,\n         fundamental: false,\n     };\n-    let where_clauses = convert_where_clauses(db, trait_.id.into(), &bound_vars);\n-    let associated_ty_ids = trait_\n-        .items(db)\n-        .into_iter()\n-        .filter_map(|trait_item| match trait_item {\n-            crate::AssocItem::TypeAlias(type_alias) => Some(type_alias.id),\n-            _ => None,\n-        })\n-        .map(|type_alias| type_alias.to_chalk(db))\n-        .collect();\n+    let where_clauses = convert_where_clauses(db, trait_.into(), &bound_vars);\n+    let associated_ty_ids =\n+        trait_data.associated_types().map(|type_alias| type_alias.to_chalk(db)).collect();\n     let trait_datum_bound = chalk_rust_ir::TraitDatumBound { where_clauses };\n     let trait_datum = TraitDatum {\n         id: trait_id,\n@@ -661,7 +657,7 @@ fn impl_block_datum(\n     };\n \n     let impl_datum_bound = chalk_rust_ir::ImplDatumBound { trait_ref, where_clauses };\n-    let trait_data = db.trait_data(trait_.id);\n+    let trait_data = db.trait_data(trait_);\n     let associated_ty_value_ids = impl_block\n         .items(db)\n         .into_iter()\n@@ -785,7 +781,7 @@ fn type_alias_associated_ty_value(\n         .expect(\"assoc ty value should not exist\") // we don't return any assoc ty values if the impl'd trait can't be resolved\n         .trait_;\n     let assoc_ty = db\n-        .trait_data(trait_.id)\n+        .trait_data(trait_)\n         .associated_type_by_name(&type_alias.name(db))\n         .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n     let generic_params = db.generic_params(impl_block.id.into());"}]}