{"sha": "2203ec38cb7fc83122be94c4c269f775e6dedb67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyMDNlYzM4Y2I3ZmM4MzEyMmJlOTRjNGMyNjlmNzc1ZTZkZWRiNjc=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-29T12:48:26Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-29T12:48:26Z"}, "message": "Use opt.take() instead of mem::replace(opt, None)", "tree": {"sha": "99c710b89eae00e9b6a9a00db8238242937822c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99c710b89eae00e9b6a9a00db8238242937822c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2203ec38cb7fc83122be94c4c269f775e6dedb67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2203ec38cb7fc83122be94c4c269f775e6dedb67", "html_url": "https://github.com/rust-lang/rust/commit/2203ec38cb7fc83122be94c4c269f775e6dedb67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2203ec38cb7fc83122be94c4c269f775e6dedb67/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e88b7363b7858960ccfd87326ece9d00bf4d973", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e88b7363b7858960ccfd87326ece9d00bf4d973", "html_url": "https://github.com/rust-lang/rust/commit/4e88b7363b7858960ccfd87326ece9d00bf4d973"}], "stats": {"total": 13, "additions": 5, "deletions": 8}, "files": [{"sha": "fc3353e339b4d77a27dbad8f0ce933cc656b44bc", "filename": "src/librustc/ty/steal.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2203ec38cb7fc83122be94c4c269f775e6dedb67/src%2Flibrustc%2Fty%2Fsteal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2203ec38cb7fc83122be94c4c269f775e6dedb67/src%2Flibrustc%2Fty%2Fsteal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsteal.rs?ref=2203ec38cb7fc83122be94c4c269f775e6dedb67", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use rustc_data_structures::sync::{RwLock, ReadGuard, MappedReadGuard};\n-use std::mem;\n \n /// The `Steal` struct is intended to used as the value for a query.\n /// Specifically, we sometimes have queries (*cough* MIR *cough*)\n@@ -51,7 +50,7 @@ impl<T> Steal<T> {\n \n     pub fn steal(&self) -> T {\n         let value_ref = &mut *self.value.try_write().expect(\"stealing value which is locked\");\n-        let value = mem::replace(value_ref, None);\n+        let value = value_ref.take();\n         value.expect(\"attempt to read from stolen value\")\n     }\n }"}, {"sha": "9dbf0ea9f438cb19b5b5ff4970ddf45b604e73a8", "filename": "src/librustc_data_structures/tiny_list.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2203ec38cb7fc83122be94c4c269f775e6dedb67/src%2Flibrustc_data_structures%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2203ec38cb7fc83122be94c4c269f775e6dedb67/src%2Flibrustc_data_structures%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list.rs?ref=2203ec38cb7fc83122be94c4c269f775e6dedb67", "patch": "@@ -22,8 +22,6 @@\n //! If you expect to store more than 1 element in the common case, steer clear\n //! and use a `Vec<T>`, `Box<[T]>`, or a `SmallVec<T>`.\n \n-use std::mem;\n-\n #[derive(Clone, Hash, Debug, PartialEq)]\n pub struct TinyList<T: PartialEq> {\n     head: Option<Element<T>>\n@@ -52,15 +50,15 @@ impl<T: PartialEq> TinyList<T> {\n     pub fn insert(&mut self, data: T) {\n         self.head = Some(Element {\n             data,\n-            next: mem::replace(&mut self.head, None).map(Box::new),\n+            next: self.head.take().map(Box::new)\n         });\n     }\n \n     #[inline]\n     pub fn remove(&mut self, data: &T) -> bool {\n         self.head = match self.head {\n             Some(ref mut head) if head.data == *data => {\n-                mem::replace(&mut head.next, None).map(|x| *x)\n+                head.next.take().map(|x| *x)\n             }\n             Some(ref mut head) => return head.remove_next(data),\n             None => return false,\n@@ -100,7 +98,7 @@ impl<T: PartialEq> Element<T> {\n             if next.data != *data {\n                 return next.remove_next(data)\n             } else {\n-                mem::replace(&mut next.next, None)\n+                next.next.take()\n             }\n         } else {\n             return false"}, {"sha": "abbdf6d10057b6e405db6d25a42603749737ab77", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2203ec38cb7fc83122be94c4c269f775e6dedb67/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2203ec38cb7fc83122be94c4c269f775e6dedb67/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=2203ec38cb7fc83122be94c4c269f775e6dedb67", "patch": "@@ -831,7 +831,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         }\n \n         let static_candidates = mem::replace(&mut self.static_candidates, vec![]);\n-        let private_candidate = mem::replace(&mut self.private_candidate, None);\n+        let private_candidate = self.private_candidate.take();\n         let unsatisfied_predicates = mem::replace(&mut self.unsatisfied_predicates, vec![]);\n \n         // things failed, so lets look at all traits, for diagnostic purposes now:"}]}