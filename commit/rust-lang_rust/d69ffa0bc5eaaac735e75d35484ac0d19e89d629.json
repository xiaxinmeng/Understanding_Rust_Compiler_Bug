{"sha": "d69ffa0bc5eaaac735e75d35484ac0d19e89d629", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2OWZmYTBiYzVlYWFhYzczNWU3NWQzNTQ4NGFjMGQxOWU4OWQ2Mjk=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-13T18:19:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-13T18:19:53Z"}, "message": "Merge pull request #21 from oli-obk/function_pointers2\n\nFunction pointers", "tree": {"sha": "6b37c9f6907bae117136b50b1e26f1a9fb745916", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b37c9f6907bae117136b50b1e26f1a9fb745916"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d69ffa0bc5eaaac735e75d35484ac0d19e89d629", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d69ffa0bc5eaaac735e75d35484ac0d19e89d629", "html_url": "https://github.com/rust-lang/rust/commit/d69ffa0bc5eaaac735e75d35484ac0d19e89d629", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f2219becbb48e3ae65a3176e353b8e1112ba2e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f2219becbb48e3ae65a3176e353b8e1112ba2e9", "html_url": "https://github.com/rust-lang/rust/commit/2f2219becbb48e3ae65a3176e353b8e1112ba2e9"}, {"sha": "fe9b4550061b7593a5324ed2cbcc8e86bf6d986b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe9b4550061b7593a5324ed2cbcc8e86bf6d986b", "html_url": "https://github.com/rust-lang/rust/commit/fe9b4550061b7593a5324ed2cbcc8e86bf6d986b"}], "stats": {"total": 342, "additions": 247, "deletions": 95}, "files": [{"sha": "49fd8564be639441eec531fb801d21fdc239c98b", "filename": "src/error.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=d69ffa0bc5eaaac735e75d35484ac0d19e89d629", "patch": "@@ -6,6 +6,7 @@ use memory::Pointer;\n #[derive(Clone, Debug)]\n pub enum EvalError {\n     DanglingPointerDeref,\n+    InvalidFunctionPointer,\n     InvalidBool,\n     InvalidDiscriminant,\n     PointerOutOfBounds {\n@@ -19,6 +20,8 @@ pub enum EvalError {\n     ReadUndefBytes,\n     InvalidBoolOp(mir::BinOp),\n     Unimplemented(String),\n+    DerefFunctionPointer,\n+    ExecuteMemory,\n }\n \n pub type EvalResult<T> = Result<T, EvalError>;\n@@ -28,6 +31,8 @@ impl Error for EvalError {\n         match *self {\n             EvalError::DanglingPointerDeref =>\n                 \"dangling pointer was dereferenced\",\n+            EvalError::InvalidFunctionPointer =>\n+                \"tried to use a pointer as a function pointer\",\n             EvalError::InvalidBool =>\n                 \"invalid boolean value read\",\n             EvalError::InvalidDiscriminant =>\n@@ -45,6 +50,10 @@ impl Error for EvalError {\n             EvalError::InvalidBoolOp(_) =>\n                 \"invalid boolean operation\",\n             EvalError::Unimplemented(ref msg) => msg,\n+            EvalError::DerefFunctionPointer =>\n+                \"tried to dereference a function pointer\",\n+            EvalError::ExecuteMemory =>\n+                \"tried to treat a memory pointer as a function pointer\",\n         }\n     }\n "}, {"sha": "1b0b416e0e12c1097500479fbfecf59a0487c9cf", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 116, "deletions": 85, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=d69ffa0bc5eaaac735e75d35484ac0d19e89d629", "patch": "@@ -6,7 +6,7 @@ use rustc::traits::{self, ProjectionMode};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::layout::{self, Layout, Size};\n use rustc::ty::subst::{self, Subst, Substs};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, BareFnTy};\n use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::indexed_vec::Idx;\n use std::cell::RefCell;\n@@ -15,7 +15,7 @@ use std::rc::Rc;\n use std::{iter, mem};\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::{self, DUMMY_SP};\n+use syntax::codemap::{self, DUMMY_SP, Span};\n \n use error::{EvalError, EvalResult};\n use memory::{Memory, Pointer};\n@@ -40,7 +40,7 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     mir_cache: RefCell<DefIdMap<Rc<mir::Mir<'tcx>>>>,\n \n     /// The virtual memory system.\n-    memory: Memory,\n+    memory: Memory<'tcx>,\n \n     /// Precomputed statics, constants and promoteds\n     statics: HashMap<ConstantId<'tcx>, Pointer>,\n@@ -283,6 +283,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn load_mir(&self, def_id: DefId) -> CachedMir<'a, 'tcx> {\n+        use rustc_trans::back::symbol_names::def_id_to_string;\n         match self.tcx.map.as_local_node_id(def_id) {\n             Some(node_id) => CachedMir::Ref(self.mir_map.map.get(&node_id).unwrap()),\n             None => {\n@@ -293,7 +294,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let cs = &self.tcx.sess.cstore;\n                 let mir = cs.maybe_get_item_mir(self.tcx, def_id).unwrap_or_else(|| {\n-                    panic!(\"no mir for {:?}\", def_id);\n+                    panic!(\"no mir for `{}`\", def_id_to_string(self.tcx, def_id));\n                 });\n                 let cached = Rc::new(mir);\n                 mir_cache.insert(def_id, cached.clone());\n@@ -429,84 +430,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let func_ty = self.operand_ty(func);\n                 match func_ty.sty {\n+                    ty::TyFnPtr(bare_fn_ty) => {\n+                        let ptr = self.eval_operand(func)?;\n+                        assert_eq!(ptr.offset, 0);\n+                        let fn_ptr = self.memory.read_ptr(ptr)?;\n+                        let (def_id, substs) = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                        self.eval_fn_call(def_id, substs, bare_fn_ty, return_ptr, args,\n+                                          terminator.source_info.span)?\n+                    },\n                     ty::TyFnDef(def_id, substs, fn_ty) => {\n-                        use syntax::abi::Abi;\n-                        match fn_ty.abi {\n-                            Abi::RustIntrinsic => {\n-                                let name = self.tcx.item_name(def_id).as_str();\n-                                match fn_ty.sig.0.output {\n-                                    ty::FnConverging(ty) => {\n-                                        let size = self.type_size(ty);\n-                                        let ret = return_ptr.unwrap();\n-                                        self.call_intrinsic(&name, substs, args, ret, size)?\n-                                    }\n-                                    ty::FnDiverging => unimplemented!(),\n-                                }\n-                            }\n-\n-                            Abi::C => {\n-                                match fn_ty.sig.0.output {\n-                                    ty::FnConverging(ty) => {\n-                                        let size = self.type_size(ty);\n-                                        self.call_c_abi(def_id, args, return_ptr.unwrap(), size)?\n-                                    }\n-                                    ty::FnDiverging => unimplemented!(),\n-                                }\n-                            }\n-\n-                            Abi::Rust | Abi::RustCall => {\n-                                // TODO(solson): Adjust the first argument when calling a Fn or\n-                                // FnMut closure via FnOnce::call_once.\n-\n-                                // Only trait methods can have a Self parameter.\n-                                let (resolved_def_id, resolved_substs) = if substs.self_ty().is_some() {\n-                                    self.trait_method(def_id, substs)\n-                                } else {\n-                                    (def_id, substs)\n-                                };\n-\n-                                let mut arg_srcs = Vec::new();\n-                                for arg in args {\n-                                    let src = self.eval_operand(arg)?;\n-                                    let src_ty = self.operand_ty(arg);\n-                                    arg_srcs.push((src, src_ty));\n-                                }\n-\n-                                if fn_ty.abi == Abi::RustCall && !args.is_empty() {\n-                                    arg_srcs.pop();\n-                                    let last_arg = args.last().unwrap();\n-                                    let last = self.eval_operand(last_arg)?;\n-                                    let last_ty = self.operand_ty(last_arg);\n-                                    let last_layout = self.type_layout(last_ty);\n-                                    match (&last_ty.sty, last_layout) {\n-                                        (&ty::TyTuple(fields),\n-                                         &Layout::Univariant { ref variant, .. }) => {\n-                                            let offsets = iter::once(0)\n-                                                .chain(variant.offset_after_field.iter()\n-                                                    .map(|s| s.bytes()));\n-                                            for (offset, ty) in offsets.zip(fields) {\n-                                                let src = last.offset(offset as isize);\n-                                                arg_srcs.push((src, ty));\n-                                            }\n-                                        }\n-                                        ty => panic!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n-                                    }\n-                                }\n-\n-                                let mir = self.load_mir(resolved_def_id);\n-                                self.push_stack_frame(\n-                                    def_id, terminator.source_info.span, mir, resolved_substs,\n-                                    return_ptr\n-                                );\n-\n-                                for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n-                                    let dest = self.frame().locals[i];\n-                                    self.move_(src, dest, src_ty)?;\n-                                }\n-                            }\n-\n-                            abi => return Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", abi))),\n-                        }\n+                        self.eval_fn_call(def_id, substs, fn_ty, return_ptr, args,\n+                                          terminator.source_info.span)?\n                     }\n \n                     _ => return Err(EvalError::Unimplemented(format!(\"can't handle callee of type {:?}\", func_ty))),\n@@ -538,6 +472,93 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n+    pub fn eval_fn_call(\n+        &mut self,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+        fn_ty: &'tcx BareFnTy,\n+        return_ptr: Option<Pointer>,\n+        args: &[mir::Operand<'tcx>],\n+        span: Span,\n+    ) -> EvalResult<()> {\n+        use syntax::abi::Abi;\n+        match fn_ty.abi {\n+            Abi::RustIntrinsic => {\n+                let name = self.tcx.item_name(def_id).as_str();\n+                match fn_ty.sig.0.output {\n+                    ty::FnConverging(ty) => {\n+                        let size = self.type_size(ty);\n+                        let ret = return_ptr.unwrap();\n+                        self.call_intrinsic(&name, substs, args, ret, size)\n+                    }\n+                    ty::FnDiverging => unimplemented!(),\n+                }\n+            }\n+\n+            Abi::C => {\n+                match fn_ty.sig.0.output {\n+                    ty::FnConverging(ty) => {\n+                        let size = self.type_size(ty);\n+                        self.call_c_abi(def_id, args, return_ptr.unwrap(), size)\n+                    }\n+                    ty::FnDiverging => unimplemented!(),\n+                }\n+            }\n+\n+            Abi::Rust | Abi::RustCall => {\n+                // TODO(solson): Adjust the first argument when calling a Fn or\n+                // FnMut closure via FnOnce::call_once.\n+\n+                // Only trait methods can have a Self parameter.\n+                let (resolved_def_id, resolved_substs) = if substs.self_ty().is_some() {\n+                    self.trait_method(def_id, substs)\n+                } else {\n+                    (def_id, substs)\n+                };\n+\n+                let mut arg_srcs = Vec::new();\n+                for arg in args {\n+                    let src = self.eval_operand(arg)?;\n+                    let src_ty = self.operand_ty(arg);\n+                    arg_srcs.push((src, src_ty));\n+                }\n+\n+                if fn_ty.abi == Abi::RustCall && !args.is_empty() {\n+                    arg_srcs.pop();\n+                    let last_arg = args.last().unwrap();\n+                    let last = self.eval_operand(last_arg)?;\n+                    let last_ty = self.operand_ty(last_arg);\n+                    let last_layout = self.type_layout(last_ty);\n+                    match (&last_ty.sty, last_layout) {\n+                        (&ty::TyTuple(fields),\n+                         &Layout::Univariant { ref variant, .. }) => {\n+                            let offsets = iter::once(0)\n+                                .chain(variant.offset_after_field.iter()\n+                                    .map(|s| s.bytes()));\n+                            for (offset, ty) in offsets.zip(fields) {\n+                                let src = last.offset(offset as isize);\n+                                arg_srcs.push((src, ty));\n+                            }\n+                        }\n+                        ty => panic!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n+                    }\n+                }\n+\n+                let mir = self.load_mir(resolved_def_id);\n+                self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr);\n+\n+                for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n+                    let dest = self.frame().locals[i];\n+                    self.move_(src, dest, src_ty)?;\n+                }\n+\n+                Ok(())\n+            }\n+\n+            abi => Err(EvalError::Unimplemented(format!(\"can't handle function with {:?} ABI\", abi))),\n+        }\n+    }\n+\n     fn drop(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n         if !self.type_needs_drop(ty) {\n             debug!(\"no need to drop {:?}\", ty);\n@@ -1033,12 +1054,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Cast(kind, ref operand, dest_ty) => {\n-                let src = self.eval_operand(operand)?;\n-                let src_ty = self.operand_ty(operand);\n-\n                 use rustc::mir::repr::CastKind::*;\n                 match kind {\n                     Unsize => {\n+                        let src = self.eval_operand(operand)?;\n+                        let src_ty = self.operand_ty(operand);\n                         self.move_(src, dest, src_ty)?;\n                         let src_pointee_ty = pointee_type(src_ty).unwrap();\n                         let dest_pointee_ty = pointee_type(dest_ty).unwrap();\n@@ -1054,6 +1074,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n \n                     Misc => {\n+                        let src = self.eval_operand(operand)?;\n+                        let src_ty = self.operand_ty(operand);\n                         // FIXME(solson): Wrong for almost everything.\n                         warn!(\"misc cast from {:?} to {:?}\", src_ty, dest_ty);\n                         let dest_size = self.type_size(dest_ty);\n@@ -1072,6 +1094,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         }\n                     }\n \n+                    ReifyFnPointer => match self.operand_ty(operand).sty {\n+                        ty::TyFnDef(def_id, substs, _) => {\n+                            let fn_ptr = self.memory.create_fn_ptr(def_id, substs);\n+                            self.memory.write_ptr(dest, fn_ptr)?;\n+                        },\n+                        ref other => panic!(\"reify fn pointer on {:?}\", other),\n+                    },\n+\n                     _ => return Err(EvalError::Unimplemented(format!(\"can't handle cast: {:?}\", rvalue))),\n                 }\n             }\n@@ -1159,7 +1189,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value { ref value } => Ok(self.const_to_ptr(value)?),\n                     Item { def_id, substs } => {\n                         if let ty::TyFnDef(..) = ty.sty {\n-                            Err(EvalError::Unimplemented(\"unimplemented: mentions of function items\".to_string()))\n+                            // function items are zero sized\n+                            Ok(self.memory.allocate(0))\n                         } else {\n                             let cid = ConstantId {\n                                 def_id: def_id,"}, {"sha": "8603054d124c25fb57e89191f3516314959ddb1b", "filename": "src/interpreter/stepper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/src%2Finterpreter%2Fstepper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/src%2Finterpreter%2Fstepper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstepper.rs?ref=d69ffa0bc5eaaac735e75d35484ac0d19e89d629", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n             mir::Literal::Value { .. } => {}\n             mir::Literal::Item { def_id, substs } => {\n                 if let ty::TyFnDef(..) = constant.ty.sty {\n-                    // No need to do anything here, even if function pointers are implemented,\n+                    // No need to do anything here,\n                     // because the type is the actual function, not the signature of the function.\n                     // Thus we can simply create a zero sized allocation in `evaluate_operand`\n                 } else {"}, {"sha": "4bc5a07e3c2f93213604fe3151cea87df9bf4495", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d69ffa0bc5eaaac735e75d35484ac0d19e89d629", "patch": "@@ -13,6 +13,7 @@\n #[macro_use] extern crate rustc;\n extern crate rustc_data_structures;\n extern crate rustc_mir;\n+extern crate rustc_trans;\n extern crate syntax;\n #[macro_use] extern crate log;\n extern crate log_settings;"}, {"sha": "35ee99eab9702a7e5cf684c7fe6e8d3cfa6abdab", "filename": "src/memory.rs", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=d69ffa0bc5eaaac735e75d35484ac0d19e89d629", "patch": "@@ -3,6 +3,9 @@ use std::collections::Bound::{Included, Excluded};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{fmt, iter, mem, ptr};\n \n+use rustc::hir::def_id::DefId;\n+use rustc::ty::subst::Substs;\n+\n use error::{EvalError, EvalResult};\n use primval::PrimVal;\n \n@@ -42,22 +45,40 @@ impl Pointer {\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub struct Memory {\n+pub struct Memory<'tcx> {\n+    /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations)\n     alloc_map: HashMap<AllocId, Allocation>,\n+    /// Function \"allocations\". They exist solely so pointers have something to point to, and\n+    /// we can figure out what they point to.\n+    functions: HashMap<AllocId, (DefId, &'tcx Substs<'tcx>)>,\n     next_id: AllocId,\n     pub pointer_size: usize,\n }\n \n-impl Memory {\n+impl<'tcx> Memory<'tcx> {\n     // FIXME: pass tcx.data_layout (This would also allow it to use primitive type alignments to diagnose unaligned memory accesses.)\n     pub fn new(pointer_size: usize) -> Self {\n         Memory {\n             alloc_map: HashMap::new(),\n+            functions: HashMap::new(),\n             next_id: AllocId(0),\n             pointer_size: pointer_size,\n         }\n     }\n \n+    // FIXME: never create two pointers to the same def_id + substs combination\n+    // maybe re-use the statics cache of the EvalContext?\n+    pub fn create_fn_ptr(&mut self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Pointer {\n+        let id = self.next_id;\n+        debug!(\"creating fn ptr: {}\", id);\n+        self.next_id.0 += 1;\n+        self.functions.insert(id, (def_id, substs));\n+        Pointer {\n+            alloc_id: id,\n+            offset: 0,\n+        }\n+    }\n+\n     pub fn allocate(&mut self, size: usize) -> Pointer {\n         let alloc = Allocation {\n             bytes: vec![0; size],\n@@ -119,11 +140,34 @@ impl Memory {\n     ////////////////////////////////////////////////////////////////////////////////\n \n     pub fn get(&self, id: AllocId) -> EvalResult<&Allocation> {\n-        self.alloc_map.get(&id).ok_or(EvalError::DanglingPointerDeref)\n+        match self.alloc_map.get(&id) {\n+            Some(alloc) => Ok(alloc),\n+            None => match self.functions.get(&id) {\n+                Some(_) => Err(EvalError::DerefFunctionPointer),\n+                None => Err(EvalError::DanglingPointerDeref),\n+            }\n+        }\n     }\n \n     pub fn get_mut(&mut self, id: AllocId) -> EvalResult<&mut Allocation> {\n-        self.alloc_map.get_mut(&id).ok_or(EvalError::DanglingPointerDeref)\n+        match self.alloc_map.get_mut(&id) {\n+            Some(alloc) => Ok(alloc),\n+            None => match self.functions.get(&id) {\n+                Some(_) => Err(EvalError::DerefFunctionPointer),\n+                None => Err(EvalError::DanglingPointerDeref),\n+            }\n+        }\n+    }\n+\n+    pub fn get_fn(&self, id: AllocId) -> EvalResult<(DefId, &'tcx Substs<'tcx>)> {\n+        debug!(\"reading fn ptr: {}\", id);\n+        match self.functions.get(&id) {\n+            Some(&fn_id) => Ok(fn_id),\n+            None => match self.alloc_map.get(&id) {\n+                Some(_) => Err(EvalError::ExecuteMemory),\n+                None => Err(EvalError::InvalidFunctionPointer),\n+            }\n+        }\n     }\n \n     /// Print an allocation and all allocations it points to, recursively.\n@@ -138,12 +182,18 @@ impl Memory {\n             print!(\"{}\", prefix);\n             let mut relocations = vec![];\n \n-            let alloc = match self.alloc_map.get(&id) {\n-                Some(a) => a,\n-                None => {\n+            let alloc = match (self.alloc_map.get(&id), self.functions.get(&id)) {\n+                (Some(a), None) => a,\n+                (None, Some(_)) => {\n+                    // FIXME: print function name\n+                    println!(\"function pointer\");\n+                    continue;\n+                },\n+                (None, None) => {\n                     println!(\"(deallocated)\");\n                     continue;\n-                }\n+                },\n+                (Some(_), Some(_)) => unreachable!(),\n             };\n \n             for i in 0..alloc.bytes.len() {"}, {"sha": "52c7c2b8f9d5541e67e96dd8eee64e24e526d359", "filename": "tests/compile-fail/deref_fn_ptr.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/tests%2Fcompile-fail%2Fderef_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/tests%2Fcompile-fail%2Fderef_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fderef_fn_ptr.rs?ref=d69ffa0bc5eaaac735e75d35484ac0d19e89d629", "patch": "@@ -0,0 +1,13 @@\n+#![feature(custom_attribute)]\n+#![allow(dead_code, unused_attributes)]\n+\n+fn f() {}\n+\n+#[miri_run]\n+fn deref_fn_ptr() -> i32 {\n+    unsafe {\n+        *std::mem::transmute::<fn(), *const i32>(f) //~ ERROR: tried to dereference a function pointer\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4e06fd8db8ded6ecd8d4049a690715c148473182", "filename": "tests/compile-fail/execute_memory.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/tests%2Fcompile-fail%2Fexecute_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/tests%2Fcompile-fail%2Fexecute_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fexecute_memory.rs?ref=d69ffa0bc5eaaac735e75d35484ac0d19e89d629", "patch": "@@ -0,0 +1,14 @@\n+#![feature(custom_attribute, box_syntax)]\n+#![allow(dead_code, unused_attributes)]\n+\n+#[miri_run]\n+fn deref_fn_ptr() {\n+    //FIXME: this span is wrong\n+    let x = box 42; //~ ERROR: tried to treat a memory pointer as a function pointer\n+    unsafe {\n+        let f = std::mem::transmute::<Box<i32>, fn()>(x);\n+        f()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "7752650ade8873f3dcf1c103ff5dfe5e18985c94", "filename": "tests/compile-fail/unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/tests%2Fcompile-fail%2Funimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/tests%2Fcompile-fail%2Funimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funimplemented.rs?ref=d69ffa0bc5eaaac735e75d35484ac0d19e89d629", "patch": "@@ -1,7 +1,7 @@\n #![feature(custom_attribute)]\n #![allow(dead_code, unused_attributes)]\n \n-//error-pattern:unimplemented: mentions of function items\n+//error-pattern:begin_panic_fmt\n \n \n #[miri_run]"}, {"sha": "55a6f9fbeac46266a9f24cfefb36fce7d428c324", "filename": "tests/run-pass/function_pointers.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/tests%2Frun-pass%2Ffunction_pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/tests%2Frun-pass%2Ffunction_pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffunction_pointers.rs?ref=d69ffa0bc5eaaac735e75d35484ac0d19e89d629", "patch": "@@ -0,0 +1,17 @@\n+#![feature(custom_attribute)]\n+#![allow(dead_code, unused_attributes)]\n+\n+fn f() -> i32 {\n+    42\n+}\n+\n+fn return_fn_ptr() -> fn() -> i32 {\n+    f\n+}\n+\n+#[miri_run]\n+fn call_fn_ptr() -> i32 {\n+    return_fn_ptr()()\n+}\n+\n+fn main() {}"}, {"sha": "d4f1d4023ba7f51e0d70e811ae008ab533747f3c", "filename": "tests/run-pass/zst.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/tests%2Frun-pass%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69ffa0bc5eaaac735e75d35484ac0d19e89d629/tests%2Frun-pass%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fzst.rs?ref=d69ffa0bc5eaaac735e75d35484ac0d19e89d629", "patch": "@@ -0,0 +1,17 @@\n+#![feature(custom_attribute)]\n+#![allow(dead_code, unused_attributes)]\n+\n+struct A;\n+\n+#[miri_run]\n+fn zst_ret() -> A {\n+    A\n+}\n+\n+#[miri_run]\n+fn use_zst() -> A {\n+    let a = A;\n+    a\n+}\n+\n+fn main() {}"}]}