{"sha": "c14b615534ebcd5667f594c86d18eebff6afc7cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNGI2MTU1MzRlYmNkNTY2N2Y1OTRjODZkMThlZWJmZjZhZmM3Y2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-16T16:03:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-16T16:03:22Z"}, "message": "Auto merge of #30533 - nikomatsakis:fulfillment-tree, r=aturon\n\nThis PR introduces an `ObligationForest` data structure that the fulfillment context can use to track what's going on, instead of the current flat vector. This enables a number of improvements:\n\n1. transactional support, at least for pushing new obligations\n2. remove the \"errors will be reported\" hack -- instead, we only add types to the global cache once their entire subtree has been proven safe. Before, we never knew when this point was reached because we didn't track the subtree.\n   - this in turn allows us to limit coinductive reasoning to structural traits, which sidesteps #29859\n3. keeping the backtrace should allow for an improved error message, where we give the user full context\n    - we can also remove chained obligation causes\n\nThis PR is not 100% complete. In particular:\n\n- [x] Currently, types that embed themselves like `struct Foo { f: Foo }` give an overflow when evaluating whether `Foo: Sized`. This is not a very user-friendly error message, and this is a common beginner error. I plan to special-case this scenario, I think.\n- [x] I should do some perf. measurements. (Update: 2% regression.)\n- [x] More tests targeting #29859\n- [ ] The transactional support is not fully integrated, though that should be easy enough.\n- [ ] The error messages are not taking advantage of the backtrace.\n\nI'd certainly like to do 1 through 3 before landing, but 4 and 5 could come as separate PRs.\n\nr? @aturon // good way to learn more about this part of the trait system\nf? @arielb1 // already knows this part of the trait system :)", "tree": {"sha": "461d05b42c7c14159cc6e50659fe46a05c298a60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/461d05b42c7c14159cc6e50659fe46a05c298a60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c14b615534ebcd5667f594c86d18eebff6afc7cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c14b615534ebcd5667f594c86d18eebff6afc7cb", "html_url": "https://github.com/rust-lang/rust/commit/c14b615534ebcd5667f594c86d18eebff6afc7cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c14b615534ebcd5667f594c86d18eebff6afc7cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dda25f2221cc7dd68ed28254665dc7d25e2648ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/dda25f2221cc7dd68ed28254665dc7d25e2648ed", "html_url": "https://github.com/rust-lang/rust/commit/dda25f2221cc7dd68ed28254665dc7d25e2648ed"}, {"sha": "4fbb71fda1a0e723a34e355037d3491bbb14dd2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fbb71fda1a0e723a34e355037d3491bbb14dd2f", "html_url": "https://github.com/rust-lang/rust/commit/4fbb71fda1a0e723a34e355037d3491bbb14dd2f"}], "stats": {"total": 1823, "additions": 1467, "deletions": 356}, "files": [{"sha": "aa2f60f71f979765af701a1a13826d3533480432", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -679,6 +679,43 @@ There's no easy fix for this, generally code will need to be refactored so that\n you no longer need to derive from `Super<Self>`.\n \"####,\n \n+E0072: r##\"\n+When defining a recursive struct or enum, any use of the type being defined\n+from inside the definition must occur behind a pointer (like `Box` or `&`).\n+This is because structs and enums must have a well-defined size, and without\n+the pointer the size of the type would need to be unbounded.\n+\n+Consider the following erroneous definition of a type for a list of bytes:\n+\n+```\n+// error, invalid recursive struct type\n+struct ListNode {\n+    head: u8,\n+    tail: Option<ListNode>,\n+}\n+```\n+\n+This type cannot have a well-defined size, because it needs to be arbitrarily\n+large (since we would be able to nest `ListNode`s to any depth). Specifically,\n+\n+```plain\n+size of `ListNode` = 1 byte for `head`\n+                   + 1 byte for the discriminant of the `Option`\n+                   + size of `ListNode`\n+```\n+\n+One way to fix this is by wrapping `ListNode` in a `Box`, like so:\n+\n+```\n+struct ListNode {\n+    head: u8,\n+    tail: Option<Box<ListNode>>,\n+}\n+```\n+\n+This works because `Box` is a pointer, so its size is well-known.\n+\"##,\n+\n E0109: r##\"\n You tried to give a type parameter to a type which doesn't need it. Erroneous\n code example:"}, {"sha": "5822b3dc5e954b0be1642966a045a18159d9fa96", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -125,7 +125,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n             None => self.tcx.empty_parameter_environment()\n         };\n \n-        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env), false);\n+        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env));\n \n         f(&mut euv::ExprUseVisitor::new(self, &infcx))\n     }\n@@ -280,7 +280,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     fn check_static_type(&self, e: &hir::Expr) {\n         let ty = self.tcx.node_id_to_type(e.id);\n-        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None, false);\n+        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n         let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n         fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);"}, {"sha": "8e5c5788201cccb8e45e9928050d7dc4be9d4c29", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -1095,8 +1095,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                         //FIXME: (@jroesch) this code should be floated up as well\n                         let infcx = infer::new_infer_ctxt(cx.tcx,\n                                                           &cx.tcx.tables,\n-                                                          Some(cx.param_env.clone()),\n-                                                          false);\n+                                                          Some(cx.param_env.clone()));\n                         if infcx.type_moves_by_default(pat_ty, pat.span) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }\n@@ -1128,8 +1127,7 @@ fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n \n     let infcx = infer::new_infer_ctxt(cx.tcx,\n                                       &cx.tcx.tables,\n-                                      Some(checker.cx.param_env.clone()),\n-                                      false);\n+                                      Some(checker.cx.param_env.clone()));\n \n     let mut visitor = ExprUseVisitor::new(&mut checker, &infcx);\n     visitor.walk_expr(guard);"}, {"sha": "5ead8fb95f8eb98508c283cdfe0e4889e61ac55b", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -44,8 +44,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n             let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n             let infcx = infer::new_infer_ctxt(self.tcx,\n                                               &self.tcx.tables,\n-                                              Some(param_env.clone()),\n-                                              false);\n+                                              Some(param_env.clone()));\n             let mut delegate = RvalueContextDelegate { tcx: self.tcx, param_env: &param_env };\n             let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n             euv.walk_fn(fd, b);"}, {"sha": "ab421b27c087dccd7b11a755a1d3abddf380e6a9", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -1262,7 +1262,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                                               substs: trait_substs });\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n \n     let mut selcx = traits::SelectionContext::new(&infcx);\n     let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),"}, {"sha": "15e368812f25d99a9ec729c68beafeeacd88eeea", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -354,16 +354,9 @@ pub fn fixup_err_to_string(f: FixupError) -> String {\n     }\n }\n \n-/// errors_will_be_reported is required to proxy to the fulfillment context\n-/// FIXME -- a better option would be to hold back on modifying\n-/// the global cache until we know that all dependent obligations\n-/// are also satisfied. In that case, we could actually remove\n-/// this boolean flag, and we'd also avoid the problem of squelching\n-/// duplicate errors that occur across fns.\n pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n                                 tables: &'a RefCell<ty::Tables<'tcx>>,\n-                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>,\n-                                errors_will_be_reported: bool)\n+                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>)\n                                 -> InferCtxt<'a, 'tcx> {\n     InferCtxt {\n         tcx: tcx,\n@@ -373,7 +366,7 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n         float_unification_table: RefCell::new(UnificationTable::new()),\n         region_vars: RegionVarBindings::new(tcx),\n         parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment()),\n-        fulfillment_cx: RefCell::new(traits::FulfillmentContext::new(errors_will_be_reported)),\n+        fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n         reported_trait_errors: RefCell::new(FnvHashSet()),\n         normalize: false,\n         err_count_on_creation: tcx.sess.err_count()\n@@ -383,7 +376,7 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n pub fn normalizing_infer_ctxt<'a, 'tcx>(tcx: &'a ty::ctxt<'tcx>,\n                                         tables: &'a RefCell<ty::Tables<'tcx>>)\n                                         -> InferCtxt<'a, 'tcx> {\n-    let mut infcx = new_infer_ctxt(tcx, tables, None, false);\n+    let mut infcx = new_infer_ctxt(tcx, tables, None);\n     infcx.normalize = true;\n     infcx\n }\n@@ -522,7 +515,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n         return value;\n     }\n \n-    let infcx = new_infer_ctxt(tcx, &tcx.tables, None, true);\n+    let infcx = new_infer_ctxt(tcx, &tcx.tables, None);\n     let mut selcx = traits::SelectionContext::new(&infcx);\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: result, obligations } ="}, {"sha": "d09bbc37fe4688d4e015038f0921a6547f34baa1", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 141, "deletions": 2, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -182,7 +182,8 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n /// if the program type checks or not -- and they are unusual\n /// occurrences in any case.\n pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n-                                          obligation: &Obligation<'tcx, T>)\n+                                          obligation: &Obligation<'tcx, T>,\n+                                          suggest_increasing_limit: bool)\n                                           -> !\n     where T: fmt::Display + TypeFoldable<'tcx>\n {\n@@ -192,7 +193,9 @@ pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                    \"overflow evaluating the requirement `{}`\",\n                                    predicate);\n \n-    suggest_new_overflow_limit(infcx.tcx, &mut err, obligation.cause.span);\n+    if suggest_increasing_limit {\n+        suggest_new_overflow_limit(infcx.tcx, &mut err, obligation.cause.span);\n+    }\n \n     note_obligation_cause(infcx, &mut err, obligation);\n \n@@ -201,6 +204,142 @@ pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n     unreachable!();\n }\n \n+/// Reports that a cycle was detected which led to overflow and halts\n+/// compilation. This is equivalent to `report_overflow_error` except\n+/// that we can give a more helpful error message (and, in particular,\n+/// we do not suggest increasing the overflow limit, which is not\n+/// going to help).\n+pub fn report_overflow_error_cycle<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                             cycle: &Vec<PredicateObligation<'tcx>>)\n+                                             -> !\n+{\n+    assert!(cycle.len() > 1);\n+\n+    debug!(\"report_overflow_error_cycle(cycle length = {})\", cycle.len());\n+\n+    let cycle = infcx.resolve_type_vars_if_possible(cycle);\n+\n+    debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n+\n+    assert_eq!(&cycle[0].predicate, &cycle.last().unwrap().predicate);\n+\n+    try_report_overflow_error_type_of_infinite_size(infcx, &cycle);\n+    report_overflow_error(infcx, &cycle[0], false);\n+}\n+\n+/// If a cycle results from evaluated whether something is Sized, that\n+/// is a particular special case that always results from a struct or\n+/// enum definition that lacks indirection (e.g., `struct Foo { x: Foo\n+/// }`). We wish to report a targeted error for this case.\n+pub fn try_report_overflow_error_type_of_infinite_size<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    cycle: &[PredicateObligation<'tcx>])\n+{\n+    let sized_trait = match infcx.tcx.lang_items.sized_trait() {\n+        Some(v) => v,\n+        None => return,\n+    };\n+    let top_is_sized = {\n+        match cycle[0].predicate {\n+            ty::Predicate::Trait(ref data) => data.def_id() == sized_trait,\n+            _ => false,\n+        }\n+    };\n+    if !top_is_sized {\n+        return;\n+    }\n+\n+    // The only way to have a type of infinite size is to have,\n+    // somewhere, a struct/enum type involved. Identify all such types\n+    // and report the cycle to the user.\n+\n+    let struct_enum_tys: Vec<_> =\n+        cycle.iter()\n+             .flat_map(|obligation| match obligation.predicate {\n+                 ty::Predicate::Trait(ref data) => {\n+                     assert_eq!(data.def_id(), sized_trait);\n+                     let self_ty = data.skip_binder().trait_ref.self_ty(); // (*)\n+                     // (*) ok to skip binder because this is just\n+                     // error reporting and regions don't really\n+                     // matter\n+                     match self_ty.sty {\n+                         ty::TyEnum(..) | ty::TyStruct(..) => Some(self_ty),\n+                         _ => None,\n+                     }\n+                 }\n+                 _ => {\n+                     infcx.tcx.sess.span_bug(obligation.cause.span,\n+                                             &format!(\"Sized cycle involving non-trait-ref: {:?}\",\n+                                                      obligation.predicate));\n+                 }\n+             })\n+             .collect();\n+\n+    assert!(!struct_enum_tys.is_empty());\n+\n+    // This is a bit tricky. We want to pick a \"main type\" in the\n+    // listing that is local to the current crate, so we can give a\n+    // good span to the user. But it might not be the first one in our\n+    // cycle list. So find the first one that is local and then\n+    // rotate.\n+    let (main_index, main_def_id) =\n+        struct_enum_tys.iter()\n+                       .enumerate()\n+                       .filter_map(|(index, ty)| match ty.sty {\n+                           ty::TyEnum(adt_def, _) | ty::TyStruct(adt_def, _)\n+                               if adt_def.did.is_local() =>\n+                               Some((index, adt_def.did)),\n+                           _ =>\n+                               None,\n+                       })\n+                       .next()\n+                       .unwrap(); // should always be SOME local type involved!\n+\n+    // Rotate so that the \"main\" type is at index 0.\n+    let struct_enum_tys: Vec<_> =\n+        struct_enum_tys.iter()\n+                       .cloned()\n+                       .skip(main_index)\n+                       .chain(struct_enum_tys.iter().cloned().take(main_index))\n+                       .collect();\n+\n+    let tcx = infcx.tcx;\n+    let mut err = recursive_type_with_infinite_size_error(tcx, main_def_id);\n+    let len = struct_enum_tys.len();\n+    if len > 2 {\n+        let span = tcx.map.span_if_local(main_def_id).unwrap();\n+        err.fileline_note(span,\n+                          &format!(\"type `{}` is embedded within `{}`...\",\n+                                   struct_enum_tys[0],\n+                                   struct_enum_tys[1]));\n+        for &next_ty in &struct_enum_tys[1..len-1] {\n+            err.fileline_note(span,\n+                              &format!(\"...which in turn is embedded within `{}`...\", next_ty));\n+        }\n+        err.fileline_note(span,\n+                          &format!(\"...which in turn is embedded within `{}`, \\\n+                                    completing the cycle.\",\n+                                   struct_enum_tys[len-1]));\n+    }\n+    err.emit();\n+    infcx.tcx.sess.abort_if_errors();\n+    unreachable!();\n+}\n+\n+pub fn recursive_type_with_infinite_size_error<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                                     type_def_id: DefId)\n+                                                     -> DiagnosticBuilder<'tcx>\n+{\n+    assert!(type_def_id.is_local());\n+    let span = tcx.map.span_if_local(type_def_id).unwrap();\n+    let mut err = struct_span_err!(tcx.sess, span, E0072, \"recursive type `{}` has infinite size\",\n+                                   tcx.item_path_str(type_def_id));\n+    err.fileline_help(span, &format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+                                      at some point to make `{}` representable\",\n+                                     tcx.item_path_str(type_def_id)));\n+    err\n+}\n+\n pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                         obligation: &PredicateObligation<'tcx>,\n                                         error: &SelectionError<'tcx>)"}, {"sha": "6ef8404cf079a7ce9ef61f499c9bf8dd8ef4f5ee", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 291, "deletions": 193, "changes": 484, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -10,19 +10,22 @@\n \n use middle::infer::InferCtxt;\n use middle::ty::{self, Ty, TypeFoldable};\n-\n+use rustc_data_structures::obligation_forest::{Backtrace, ObligationForest, Error};\n+use std::iter;\n use syntax::ast;\n use util::common::ErrorReported;\n-use util::nodemap::{FnvHashSet, NodeMap};\n+use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n use super::is_object_safe;\n use super::FulfillmentError;\n+use super::FulfillmentErrorCode;\n use super::ObligationCause;\n use super::PredicateObligation;\n use super::project;\n+use super::report_overflow_error_cycle;\n use super::select::SelectionContext;\n use super::Unimplemented;\n use super::util::predicate_for_builtin_bound;\n@@ -57,12 +60,7 @@ pub struct FulfillmentContext<'tcx> {\n \n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n-    predicates: Vec<PredicateObligation<'tcx>>,\n-\n-    // Remembers the count of trait obligations that we have already\n-    // attempted to select. This is used to avoid repeating work\n-    // when `select_new_obligations` is called.\n-    attempted_mark: usize,\n+    predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n \n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n@@ -89,8 +87,6 @@ pub struct FulfillmentContext<'tcx> {\n     // obligations (otherwise, it's easy to fail to walk to a\n     // particular node-id).\n     region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n-\n-    pub errors_will_be_reported: bool,\n }\n \n #[derive(Clone)]\n@@ -100,31 +96,19 @@ pub struct RegionObligation<'tcx> {\n     pub cause: ObligationCause<'tcx>,\n }\n \n+#[derive(Clone, Debug)]\n+pub struct PendingPredicateObligation<'tcx> {\n+    pub obligation: PredicateObligation<'tcx>,\n+    pub stalled_on: Vec<Ty<'tcx>>,\n+}\n+\n impl<'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n-    ///\n-    /// `errors_will_be_reported` indicates whether ALL errors that\n-    /// are generated by this fulfillment context will be reported to\n-    /// the end user. This is used to inform caching, because it\n-    /// allows us to conclude that traits that resolve successfully\n-    /// will in fact always resolve successfully (in particular, it\n-    /// guarantees that if some dependent obligation encounters a\n-    /// problem, compilation will be aborted).  If you're not sure of\n-    /// the right value here, pass `false`, as that is the more\n-    /// conservative option.\n-    ///\n-    /// FIXME -- a better option would be to hold back on modifying\n-    /// the global cache until we know that all dependent obligations\n-    /// are also satisfied. In that case, we could actually remove\n-    /// this boolean flag, and we'd also avoid the problem of squelching\n-    /// duplicate errors that occur across fns.\n-    pub fn new(errors_will_be_reported: bool) -> FulfillmentContext<'tcx> {\n+    pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             duplicate_set: FulfilledPredicates::new(),\n-            predicates: Vec::new(),\n-            attempted_mark: 0,\n+            predicates: ObligationForest::new(),\n             region_obligations: NodeMap(),\n-            errors_will_be_reported: errors_will_be_reported,\n         }\n     }\n \n@@ -198,7 +182,11 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         }\n \n         debug!(\"register_predicate({:?})\", obligation);\n-        self.predicates.push(obligation);\n+        let obligation = PendingPredicateObligation {\n+            obligation: obligation,\n+            stalled_on: vec![]\n+        };\n+        self.predicates.push_root(obligation);\n     }\n \n     pub fn region_obligations(&self,\n@@ -216,134 +204,103 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                                    -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         try!(self.select_where_possible(infcx));\n-\n-        // Anything left is ambiguous.\n-        let errors: Vec<FulfillmentError> =\n-            self.predicates\n-            .iter()\n-            .map(|o| FulfillmentError::new((*o).clone(), CodeAmbiguity))\n-            .collect();\n-\n+        let errors: Vec<_> =\n+            self.predicates.to_errors(CodeAmbiguity)\n+                           .into_iter()\n+                           .map(|e| to_fulfillment_error(e))\n+                           .collect();\n         if errors.is_empty() {\n             Ok(())\n         } else {\n             Err(errors)\n         }\n     }\n \n-    /// Attempts to select obligations that were registered since the call to a selection routine.\n-    /// This is used by the type checker to eagerly attempt to resolve obligations in hopes of\n-    /// gaining type information. It'd be equally valid to use `select_where_possible` but it\n-    /// results in `O(n^2)` performance (#18208).\n-    pub fn select_new_obligations<'a>(&mut self,\n-                                      infcx: &InferCtxt<'a,'tcx>)\n-                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n-    {\n-        let mut selcx = SelectionContext::new(infcx);\n-        self.select(&mut selcx, true)\n-    }\n-\n     pub fn select_where_possible<'a>(&mut self,\n                                      infcx: &InferCtxt<'a,'tcx>)\n                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx);\n-        self.select(&mut selcx, false)\n+        self.select(&mut selcx)\n     }\n \n-    pub fn pending_obligations(&self) -> &[PredicateObligation<'tcx>] {\n-        &self.predicates\n+    pub fn pending_obligations(&self) -> Vec<PendingPredicateObligation<'tcx>> {\n+        self.predicates.pending_obligations()\n     }\n \n     fn is_duplicate_or_add(&mut self,\n                            tcx: &ty::ctxt<'tcx>,\n                            predicate: &ty::Predicate<'tcx>)\n                            -> bool {\n-        // This is a kind of dirty hack to allow us to avoid \"rederiving\"\n-        // things that we have already proven in other methods.\n-        //\n-        // The idea is that any predicate that doesn't involve type\n-        // parameters and which only involves the 'static region (and\n-        // no other regions) is universally solvable, since impls are global.\n-        //\n-        // This is particularly important since even if we have a\n-        // cache hit in the selection context, we still wind up\n-        // evaluating the 'nested obligations'.  This cache lets us\n-        // skip those.\n-\n-        if self.errors_will_be_reported && predicate.is_global() {\n-            tcx.fulfilled_predicates.borrow_mut().is_duplicate_or_add(predicate)\n-        } else {\n-            self.duplicate_set.is_duplicate_or_add(predicate)\n+        // For \"global\" predicates -- that is, predicates that don't\n+        // involve type parameters, inference variables, or regions\n+        // other than 'static -- we can check the cache in the tcx,\n+        // which allows us to leverage work from other threads. Note\n+        // that we don't add anything to this cache yet (unlike the\n+        // local cache).  This is because the tcx cache maintains the\n+        // invariant that it only contains things that have been\n+        // proven, and we have not yet proven that `predicate` holds.\n+        if predicate.is_global() && tcx.fulfilled_predicates.borrow().is_duplicate(predicate) {\n+            return true;\n         }\n+\n+        // If `predicate` is not global, or not present in the tcx\n+        // cache, we can still check for it in our local cache and add\n+        // it if not present. Note that if we find this predicate in\n+        // the local cache we can stop immediately, without reporting\n+        // any errors, even though we don't know yet if it is\n+        // true. This is because, while we don't yet know if the\n+        // predicate holds, we know that this same fulfillment context\n+        // already is in the process of finding out.\n+        self.duplicate_set.is_duplicate_or_add(predicate)\n     }\n \n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n     fn select<'a>(&mut self,\n-                  selcx: &mut SelectionContext<'a, 'tcx>,\n-                  only_new_obligations: bool)\n+                  selcx: &mut SelectionContext<'a, 'tcx>)\n                   -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n-        debug!(\"select({} obligations, only_new_obligations={}) start\",\n-               self.predicates.len(),\n-               only_new_obligations);\n+        debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n \n         let mut errors = Vec::new();\n \n         loop {\n-            let count = self.predicates.len();\n-\n-            debug!(\"select_where_possible({} obligations) iteration\",\n-                   count);\n+            debug!(\"select_where_possible: starting another iteration\");\n \n-            let mut new_obligations = Vec::new();\n-\n-            // If we are only attempting obligations we haven't seen yet,\n-            // then set `skip` to the number of obligations we've already\n-            // seen.\n-            let mut skip = if only_new_obligations {\n-                self.attempted_mark\n-            } else {\n-                0\n+            // Process pending obligations.\n+            let outcome = {\n+                let region_obligations = &mut self.region_obligations;\n+                self.predicates.process_obligations(\n+                    |obligation, backtrace| process_predicate(selcx,\n+                                                              obligation,\n+                                                              backtrace,\n+                                                              region_obligations))\n             };\n \n-            // First pass: walk each obligation, retaining\n-            // only those that we cannot yet process.\n-            {\n-                let region_obligations = &mut self.region_obligations;\n-                self.predicates.retain(|predicate| {\n-                    // Hack: Retain does not pass in the index, but we want\n-                    // to avoid processing the first `start_count` entries.\n-                    let processed =\n-                        if skip == 0 {\n-                            process_predicate(selcx, predicate,\n-                                              &mut new_obligations, &mut errors, region_obligations)\n-                        } else {\n-                            skip -= 1;\n-                            false\n-                        };\n-                    !processed\n-                });\n+            debug!(\"select_where_possible: outcome={:?}\", outcome);\n+\n+            // these are obligations that were proven to be true.\n+            for pending_obligation in outcome.completed {\n+                let predicate = &pending_obligation.obligation.predicate;\n+                if predicate.is_global() {\n+                    selcx.tcx().fulfilled_predicates.borrow_mut()\n+                                                    .is_duplicate_or_add(predicate);\n+                }\n             }\n \n-            self.attempted_mark = self.predicates.len();\n+            errors.extend(\n+                outcome.errors.into_iter()\n+                              .map(|e| to_fulfillment_error(e)));\n \n-            if self.predicates.len() == count {\n-                // Nothing changed.\n+            // If nothing new was added, no need to keep looping.\n+            if outcome.stalled {\n                 break;\n             }\n-\n-            // Now go through all the successful ones,\n-            // registering any nested obligations for the future.\n-            for new_obligation in new_obligations {\n-                self.register_predicate_obligation(selcx.infcx(), new_obligation);\n-            }\n         }\n \n-        debug!(\"select({} obligations, {} errors) done\",\n-               self.predicates.len(),\n-               errors.len());\n+        debug!(\"select({} predicates remaining, {} errors) done\",\n+               self.predicates.len(), errors.len());\n \n         if errors.is_empty() {\n             Ok(())\n@@ -353,69 +310,168 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     }\n }\n \n+/// Like `process_predicate1`, but wrap result into a pending predicate.\n fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                              obligation: &PredicateObligation<'tcx>,\n-                              new_obligations: &mut Vec<PredicateObligation<'tcx>>,\n-                              errors: &mut Vec<FulfillmentError<'tcx>>,\n+                              pending_obligation: &mut PendingPredicateObligation<'tcx>,\n+                              backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n-                              -> bool\n+                              -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n+                                        FulfillmentErrorCode<'tcx>>\n {\n-    /*!\n-     * Processes a predicate obligation and modifies the appropriate\n-     * output array with the successful/error result.  Returns `false`\n-     * if the predicate could not be processed due to insufficient\n-     * type inference.\n-     */\n+    match process_predicate1(selcx, pending_obligation, backtrace, region_obligations) {\n+        Ok(Some(v)) => {\n+            // FIXME the right thing to do here, I think, is to permit\n+            // DAGs. That is, we should detect whenever this predicate\n+            // has appeared somewhere in the current tree./ If it's a\n+            // parent, that's a cycle, and we should either error out\n+            // or consider it ok. But if it's NOT a parent, we can\n+            // ignore it, since it will be proven (or not) separately.\n+            // However, this is a touch tricky, so I'm doing something\n+            // a bit hackier for now so that the `huge-struct.rs` passes.\n+\n+            let retain_vec: Vec<_> = {\n+                let mut dedup = FnvHashSet();\n+                v.iter()\n+                 .map(|o| {\n+                     // Screen out obligations that we know globally\n+                     // are true. This should really be the DAG check\n+                     // mentioned above.\n+                     if\n+                         o.predicate.is_global() &&\n+                         selcx.tcx().fulfilled_predicates.borrow().is_duplicate(&o.predicate)\n+                     {\n+                         return false;\n+                     }\n+\n+                     // If we see two siblings that are exactly the\n+                     // same, no need to add them twice.\n+                     if !dedup.insert(&o.predicate) {\n+                         return false;\n+                     }\n+\n+                     true\n+                 })\n+                 .collect()\n+            };\n+\n+            let pending_predicate_obligations =\n+                v.into_iter()\n+                 .zip(retain_vec)\n+                 .flat_map(|(o, retain)| {\n+                     if retain {\n+                         Some(PendingPredicateObligation {\n+                             obligation: o,\n+                             stalled_on: vec![]\n+                         })\n+                     } else {\n+                         None\n+                     }\n+                 })\n+                .collect();\n+\n+            Ok(Some(pending_predicate_obligations))\n+        }\n+        Ok(None) => Ok(None),\n+        Err(e) => Err(e)\n+    }\n+}\n+\n+/// Processes a predicate obligation and returns either:\n+/// - `Ok(Some(v))` if the predicate is true, presuming that `v` are also true\n+/// - `Ok(None)` if we don't have enough info to be sure\n+/// - `Err` if the predicate does not hold\n+fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+                               pending_obligation: &mut PendingPredicateObligation<'tcx>,\n+                               backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n+                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n+                               -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n+                                         FulfillmentErrorCode<'tcx>>\n+{\n+    // if we were stalled on some unresolved variables, first check\n+    // whether any of them have been resolved; if not, don't bother\n+    // doing more work yet\n+    if !pending_obligation.stalled_on.is_empty() {\n+        if pending_obligation.stalled_on.iter().all(|&ty| {\n+            let resolved_ty = selcx.infcx().resolve_type_vars_if_possible(&ty);\n+            resolved_ty == ty // nothing changed here\n+        }) {\n+            debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n+                   selcx.infcx().resolve_type_vars_if_possible(&pending_obligation.obligation),\n+                   pending_obligation.stalled_on);\n+            return Ok(None);\n+        }\n+        pending_obligation.stalled_on = vec![];\n+    }\n+\n+    let obligation = &pending_obligation.obligation;\n+\n+    // If we exceed the recursion limit, take a moment to look for a\n+    // cycle so we can give a better error report from here, where we\n+    // have more context.\n+    let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n+    if obligation.recursion_depth >= recursion_limit {\n+        if let Some(cycle) = scan_for_cycle(obligation, &backtrace) {\n+            report_overflow_error_cycle(selcx.infcx(), &cycle);\n+        }\n+    }\n \n     match obligation.predicate {\n         ty::Predicate::Trait(ref data) => {\n+            if coinductive_match(selcx, obligation, data, &backtrace) {\n+                return Ok(Some(vec![]));\n+            }\n+\n             let trait_obligation = obligation.with(data.clone());\n             match selcx.select(&trait_obligation) {\n-                Ok(None) => {\n-                    false\n+                Ok(Some(vtable)) => {\n+                    Ok(Some(vtable.nested_obligations()))\n                 }\n-                Ok(Some(s)) => {\n-                    new_obligations.append(&mut s.nested_obligations());\n-                    true\n+                Ok(None) => {\n+                    // This is a bit subtle: for the most part, the\n+                    // only reason we can fail to make progress on\n+                    // trait selection is because we don't have enough\n+                    // information about the types in the trait. One\n+                    // exception is that we sometimes haven't decided\n+                    // what kind of closure a closure is. *But*, in\n+                    // that case, it turns out, the type of the\n+                    // closure will also change, because the closure\n+                    // also includes references to its upvars as part\n+                    // of its type, and those types are resolved at\n+                    // the same time.\n+                    pending_obligation.stalled_on =\n+                        data.skip_binder() // ok b/c this check doesn't care about regions\n+                        .input_types()\n+                        .iter()\n+                        .map(|t| selcx.infcx().resolve_type_vars_if_possible(t))\n+                        .filter(|t| t.has_infer_types())\n+                        .flat_map(|t| t.walk())\n+                        .filter(|t| match t.sty { ty::TyInfer(_) => true, _ => false })\n+                        .collect();\n+\n+                    debug!(\"process_predicate: pending obligation {:?} now stalled on {:?}\",\n+                           selcx.infcx().resolve_type_vars_if_possible(obligation),\n+                           pending_obligation.stalled_on);\n+\n+                    Ok(None)\n                 }\n                 Err(selection_err) => {\n-                    debug!(\"predicate: {:?} error: {:?}\",\n-                           obligation,\n-                           selection_err);\n-                    errors.push(\n-                        FulfillmentError::new(\n-                            obligation.clone(),\n-                            CodeSelectionError(selection_err)));\n-                    true\n+                    Err(CodeSelectionError(selection_err))\n                 }\n             }\n         }\n \n         ty::Predicate::Equate(ref binder) => {\n             match selcx.infcx().equality_predicate(obligation.cause.span, binder) {\n-                Ok(()) => { }\n-                Err(_) => {\n-                    errors.push(\n-                        FulfillmentError::new(\n-                            obligation.clone(),\n-                            CodeSelectionError(Unimplemented)));\n-                }\n+                Ok(()) => Ok(Some(Vec::new())),\n+                Err(_) => Err(CodeSelectionError(Unimplemented)),\n             }\n-            true\n         }\n \n         ty::Predicate::RegionOutlives(ref binder) => {\n             match selcx.infcx().region_outlives_predicate(obligation.cause.span, binder) {\n-                Ok(()) => { }\n-                Err(_) => {\n-                    errors.push(\n-                        FulfillmentError::new(\n-                            obligation.clone(),\n-                            CodeSelectionError(Unimplemented)));\n-                }\n+                Ok(()) => Ok(Some(Vec::new())),\n+                Err(_) => Err(CodeSelectionError(Unimplemented)),\n             }\n-\n-            true\n         }\n \n         ty::Predicate::TypeOutlives(ref binder) => {\n@@ -431,17 +487,15 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                         // If so, this obligation is an error (for now). Eventually we should be\n                         // able to support additional cases here, like `for<'a> &'a str: 'a`.\n                         None => {\n-                            errors.push(\n-                                FulfillmentError::new(\n-                                    obligation.clone(),\n-                                    CodeSelectionError(Unimplemented)))\n+                            Err(CodeSelectionError(Unimplemented))\n                         }\n                         // Otherwise, we have something of the form\n                         // `for<'a> T: 'a where 'a not in T`, which we can treat as `T: 'static`.\n                         Some(t_a) => {\n                             register_region_obligation(t_a, ty::ReStatic,\n                                                        obligation.cause.clone(),\n                                                        region_obligations);\n+                            Ok(Some(vec![]))\n                         }\n                     }\n                 }\n@@ -450,57 +504,93 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                     register_region_obligation(t_a, r_b,\n                                                obligation.cause.clone(),\n                                                region_obligations);\n+                    Ok(Some(vec![]))\n                 }\n             }\n-            true\n         }\n \n         ty::Predicate::Projection(ref data) => {\n             let project_obligation = obligation.with(data.clone());\n-            let result = project::poly_project_and_unify_type(selcx, &project_obligation);\n-            debug!(\"process_predicate: poly_project_and_unify_type({:?}) returned {:?}\",\n-                   project_obligation,\n-                   result);\n-            match result {\n-                Ok(Some(obligations)) => {\n-                    new_obligations.extend(obligations);\n-                    true\n-                }\n-                Ok(None) => {\n-                    false\n-                }\n-                Err(err) => {\n-                    errors.push(\n-                        FulfillmentError::new(\n-                            obligation.clone(),\n-                            CodeProjectionError(err)));\n-                    true\n-                }\n+            match project::poly_project_and_unify_type(selcx, &project_obligation) {\n+                Ok(v) => Ok(v),\n+                Err(e) => Err(CodeProjectionError(e))\n             }\n         }\n \n         ty::Predicate::ObjectSafe(trait_def_id) => {\n             if !is_object_safe(selcx.tcx(), trait_def_id) {\n-                errors.push(FulfillmentError::new(\n-                    obligation.clone(),\n-                    CodeSelectionError(Unimplemented)));\n+                Err(CodeSelectionError(Unimplemented))\n+            } else {\n+                Ok(Some(Vec::new()))\n             }\n-            true\n         }\n \n         ty::Predicate::WellFormed(ty) => {\n-            match ty::wf::obligations(selcx.infcx(), obligation.cause.body_id,\n-                                      ty, obligation.cause.span) {\n-                Some(obligations) => {\n-                    new_obligations.extend(obligations);\n-                    true\n-                }\n-                None => {\n-                    false\n+            Ok(ty::wf::obligations(selcx.infcx(), obligation.cause.body_id,\n+                                   ty, obligation.cause.span))\n+        }\n+    }\n+}\n+\n+/// For defaulted traits, we use a co-inductive strategy to solve, so\n+/// that recursion is ok. This routine returns true if the top of the\n+/// stack (`top_obligation` and `top_data`):\n+/// - is a defaulted trait, and\n+/// - it also appears in the backtrace at some position `X`; and,\n+/// - all the predicates at positions `X..` between `X` an the top are\n+///   also defaulted traits.\n+fn coinductive_match<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+                              top_obligation: &PredicateObligation<'tcx>,\n+                              top_data: &ty::PolyTraitPredicate<'tcx>,\n+                              backtrace: &Backtrace<PendingPredicateObligation<'tcx>>)\n+                              -> bool\n+{\n+    if selcx.tcx().trait_has_default_impl(top_data.def_id()) {\n+        debug!(\"coinductive_match: top_data={:?}\", top_data);\n+        for bt_obligation in backtrace.clone() {\n+            debug!(\"coinductive_match: bt_obligation={:?}\", bt_obligation);\n+\n+            // *Everything* in the backtrace must be a defaulted trait.\n+            match bt_obligation.obligation.predicate {\n+                ty::Predicate::Trait(ref data) => {\n+                    if !selcx.tcx().trait_has_default_impl(data.def_id()) {\n+                        debug!(\"coinductive_match: trait does not have default impl\");\n+                        break;\n+                    }\n                 }\n+                _ => { break; }\n+            }\n+\n+            // And we must find a recursive match.\n+            if bt_obligation.obligation.predicate == top_obligation.predicate {\n+                debug!(\"coinductive_match: found a match in the backtrace\");\n+                return true;\n             }\n         }\n     }\n+\n+    false\n+}\n+\n+fn scan_for_cycle<'a,'tcx>(top_obligation: &PredicateObligation<'tcx>,\n+                           backtrace: &Backtrace<PendingPredicateObligation<'tcx>>)\n+                           -> Option<Vec<PredicateObligation<'tcx>>>\n+{\n+    let mut map = FnvHashMap();\n+    let all_obligations =\n+        || iter::once(top_obligation)\n+               .chain(backtrace.clone()\n+                               .map(|p| &p.obligation));\n+    for (index, bt_obligation) in all_obligations().enumerate() {\n+        if let Some(&start) = map.get(&bt_obligation.predicate) {\n+            // Found a cycle starting at position `start` and running\n+            // until the current position (`index`).\n+            return Some(all_obligations().skip(start).take(index - start + 1).cloned().collect());\n+        } else {\n+            map.insert(bt_obligation.predicate.clone(), index);\n+        }\n+    }\n+    None\n }\n \n fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n@@ -536,3 +626,11 @@ impl<'tcx> FulfilledPredicates<'tcx> {\n         !self.set.insert(key.clone())\n     }\n }\n+\n+fn to_fulfillment_error<'tcx>(\n+    error: Error<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>>)\n+    -> FulfillmentError<'tcx>\n+{\n+    let obligation = error.backtrace.into_iter().next().unwrap().obligation;\n+    FulfillmentError::new(obligation, error.error)\n+}"}, {"sha": "8fecffcea9fe446269f7b927bea4bbb32c41070e", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -28,8 +28,10 @@ use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n \n pub use self::error_reporting::TraitErrorKey;\n+pub use self::error_reporting::recursive_type_with_infinite_size_error;\n pub use self::error_reporting::report_fulfillment_errors;\n pub use self::error_reporting::report_overflow_error;\n+pub use self::error_reporting::report_overflow_error_cycle;\n pub use self::error_reporting::report_selection_error;\n pub use self::error_reporting::report_object_safety_error;\n pub use self::coherence::orphan_check;\n@@ -356,7 +358,7 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n         // this function's result remains infallible, we must confirm\n         // that guess. While imperfect, I believe this is sound.\n \n-        let mut fulfill_cx = FulfillmentContext::new(false);\n+        let mut fulfill_cx = FulfillmentContext::new();\n \n         // We can use a dummy node-id here because we won't pay any mind\n         // to region obligations that arise (there shouldn't really be any\n@@ -434,8 +436,9 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(elaborated_env), false);\n-    let predicates = match fully_normalize(&infcx, cause,\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(elaborated_env));\n+    let predicates = match fully_normalize(&infcx,\n+                                           cause,\n                                            &infcx.parameter_environment.caller_bounds) {\n         Ok(predicates) => predicates,\n         Err(errors) => {\n@@ -444,6 +447,9 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n         }\n     };\n \n+    debug!(\"normalize_param_env_or_error: normalized predicates={:?}\",\n+           predicates);\n+\n     let free_regions = FreeRegionMap::new();\n     infcx.resolve_regions_and_report_errors(&free_regions, body_id);\n     let predicates = match infcx.fully_resolve(&predicates) {\n@@ -462,6 +468,9 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n         }\n     };\n \n+    debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n+           predicates);\n+\n     infcx.parameter_environment.with_caller_bounds(predicates)\n }\n \n@@ -471,7 +480,7 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                   -> Result<T, Vec<FulfillmentError<'tcx>>>\n     where T : TypeFoldable<'tcx>\n {\n-    debug!(\"normalize_param_env(value={:?})\", value);\n+    debug!(\"fully_normalize(value={:?})\", value);\n \n     let mut selcx = &mut SelectionContext::new(infcx);\n     // FIXME (@jroesch) ISSUE 26721\n@@ -487,20 +496,28 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     //\n     // I think we should probably land this refactor and then come\n     // back to this is a follow-up patch.\n-    let mut fulfill_cx = FulfillmentContext::new(false);\n+    let mut fulfill_cx = FulfillmentContext::new();\n \n     let Normalized { value: normalized_value, obligations } =\n         project::normalize(selcx, cause, value);\n-    debug!(\"normalize_param_env: normalized_value={:?} obligations={:?}\",\n+    debug!(\"fully_normalize: normalized_value={:?} obligations={:?}\",\n            normalized_value,\n            obligations);\n     for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n     }\n \n-    try!(fulfill_cx.select_all_or_error(infcx));\n+    debug!(\"fully_normalize: select_all_or_error start\");\n+    match fulfill_cx.select_all_or_error(infcx) {\n+        Ok(()) => { }\n+        Err(e) => {\n+            debug!(\"fully_normalize: error={:?}\", e);\n+            return Err(e);\n+        }\n+    }\n+    debug!(\"fully_normalize: select_all_or_error complete\");\n     let resolved_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n-    debug!(\"normalize_param_env: resolved_value={:?}\", resolved_value);\n+    debug!(\"fully_normalize: resolved_value={:?}\", resolved_value);\n     Ok(resolved_value)\n }\n "}, {"sha": "c363425db85b09e68dcad9ab8d8a76c40dde9758", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -479,7 +479,7 @@ fn project_type<'cx,'tcx>(\n     let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n     if obligation.recursion_depth >= recursion_limit {\n         debug!(\"project: overflow!\");\n-        report_overflow_error(selcx.infcx(), &obligation);\n+        report_overflow_error(selcx.infcx(), &obligation, true);\n     }\n \n     let obligation_trait_ref ="}, {"sha": "75992b6849b017193adc53aacfe73e92c4b684fa", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -711,7 +711,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // not update) the cache.\n         let recursion_limit = self.infcx.tcx.sess.recursion_limit.get();\n         if stack.obligation.recursion_depth >= recursion_limit {\n-            report_overflow_error(self.infcx(), &stack.obligation);\n+            report_overflow_error(self.infcx(), &stack.obligation, true);\n         }\n \n         // Check the cache. Note that we skolemize the trait-ref\n@@ -2124,6 +2124,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                            nested: ty::Binder<Vec<Ty<'tcx>>>)\n                            -> VtableBuiltinData<PredicateObligation<'tcx>>\n     {\n+        debug!(\"vtable_builtin_data(obligation={:?}, bound={:?}, nested={:?})\",\n+               obligation, bound, nested);\n+\n         let trait_def = match self.tcx().lang_items.from_builtin_kind(bound) {\n             Ok(def_id) => def_id,\n             Err(_) => {"}, {"sha": "03145951367f9bb6b7614bffad966ddcd6aa5dd0", "filename": "src/librustc/middle/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Futil.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n         let tcx = self.tcx;\n \n         // FIXME: (@jroesch) float this code up\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(self.clone()), false);\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(self.clone()));\n \n         let adt = match self_type.sty {\n             ty::TyStruct(struct_def, substs) => {\n@@ -655,7 +655,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                        -> bool\n     {\n         let tcx = param_env.tcx;\n-        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env.clone()), false);\n+        let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env.clone()));\n \n         let is_impld = traits::type_known_to_meet_builtin_bound(&infcx,\n                                                                 self, bound, span);"}, {"sha": "5e8495ceddd970c7fcf4e7363ddc202ec29e8645", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -202,7 +202,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     debug!(\"check_loans(body id={})\", body.id);\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = infer::new_infer_ctxt(bccx.tcx, &bccx.tcx.tables, Some(param_env), false);\n+    let infcx = infer::new_infer_ctxt(bccx.tcx, &bccx.tcx.tables, Some(param_env));\n \n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,"}, {"sha": "8cf10cb9b05a030b8a41f7739a75f493170d1434", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -55,7 +55,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = infer::new_infer_ctxt(bccx.tcx, &bccx.tcx.tables, Some(param_env), false);\n+    let infcx = infer::new_infer_ctxt(bccx.tcx, &bccx.tcx.tables, Some(param_env));\n     {\n         let mut euv = euv::ExprUseVisitor::new(&mut glcx, &infcx);\n         euv.walk_fn(decl, body);\n@@ -525,7 +525,7 @@ struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let infcx = infer::new_infer_ctxt(self.bccx.tcx, &self.bccx.tcx.tables, None, false);\n+            let infcx = infer::new_infer_ctxt(self.bccx.tcx, &self.bccx.tcx.tables, None);\n             let mc = mc::MemCategorizationContext::new(&infcx);\n             let base_cmt = mc.cat_expr(&**base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);"}, {"sha": "1fbbdf17455b27872b1297bc3b8982348e92ff01", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -24,17 +24,21 @@\n       html_favicon_url = \"https://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n-#![feature(rustc_private, staged_api)]\n #![feature(hashmap_hasher)]\n+#![feature(nonzero)]\n+#![feature(rustc_private)]\n+#![feature(staged_api)]\n \n #![cfg_attr(test, feature(test))]\n \n+extern crate core;\n #[macro_use] extern crate log;\n extern crate serialize as rustc_serialize; // used by deriving\n \n pub mod bitvec;\n pub mod graph;\n pub mod ivar;\n+pub mod obligation_forest;\n pub mod snapshot_vec;\n pub mod transitive_relation;\n pub mod unify;"}, {"sha": "1ffe07bb43b4e12565d079c817c94aae20a2cf46", "filename": "src/librustc_data_structures/obligation_forest/README.md", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -0,0 +1,80 @@\n+The `ObligationForest` is a utility data structure used in trait\n+matching to track the set of outstanding obligations (those not yet\n+resolved to success or error). It also tracks the \"backtrace\" of each\n+pending obligation (why we are trying to figure this out in the first\n+place).\n+\n+### External view\n+\n+`ObligationForest` supports two main public operations (there are a\n+few others not discussed here):\n+\n+1. Add a new root obligation (`push_root`).\n+2. Process the pending obligations (`process_obligations`).\n+\n+When a new obligation `N` is added, it becomes the root of an\n+obligation tree. This tree is a singleton to start, so `N` is both the\n+root and the only leaf. Each time the `process_obligations` method is\n+called, it will invoke its callback with every pending obligation (so\n+that will include `N`, the first time). The callback shoud process the\n+obligation `O` that it is given and return one of three results:\n+\n+- `Ok(None)` -> ambiguous result. Obligation was neither a success\n+  nor a failure. It is assumed that further attempts to process the\n+  obligation will yield the same result unless something in the\n+  surrounding environment changes.\n+- `Ok(Some(C))` - the obligation was *shallowly successful*. The\n+  vector `C` is a list of subobligations. The meaning of this is that\n+  `O` was successful on the assumption that all the obligations in `C`\n+  are also successful. Therefore, `O` is only considered a \"true\"\n+  success if `C` is empty. Otherwise, `O` is put into a suspended\n+  state and the obligations in `C` become the new pending\n+  obligations. They will be processed the next time you call\n+  `process_obligations`.\n+- `Err(E)` -> obligation failed with error `E`. We will collect this\n+  error and return it from `process_obligations`, along with the\n+  \"backtrace\" of obligations (that is, the list of obligations up to\n+  and including the root of the failed obligation). No further\n+  obligations from that same tree will be processed, since the tree is\n+  now considered to be in error.\n+\n+When the call to `process_obligations` completes, you get back an `Outcome`,\n+which includes three bits of information:\n+\n+- `completed`: a list of obligations where processing was fully\n+  completed without error (meaning that all transitive subobligations\n+  have also been completed). So, for example, if the callback from\n+  `process_obligations` returns `Ok(Some(C))` for some obligation `O`,\n+  then `O` will be considered completed right away if `C` is the\n+  empty vector. Otherwise it will only be considered completed once\n+  all the obligations in `C` have been found completed.\n+- `errors`: a list of errors that occurred and associated backtraces\n+  at the time of error, which can be used to give context to the user.\n+- `stalled`: if true, then none of the existing obligations were\n+  *shallowly successful* (that is, no callback returned `Ok(Some(_))`).\n+  This implies that all obligations were either errors or returned an\n+  ambiguous result, which means that any further calls to\n+  `process_obligations` would simply yield back further ambiguous\n+  results. This is used by the `FulfillmentContext` to decide when it\n+  has reached a steady state.\n+  \n+#### Snapshots\n+\n+The `ObligationForest` supports a limited form of snapshots; see\n+`start_snapshot`; `commit_snapshot`; and `rollback_snapshot`. In\n+particular, you can use a snapshot to roll back new root\n+obligations. However, it is an error to attempt to\n+`process_obligations` during a snapshot.\n+\n+### Implementation details\n+\n+For the most part, comments specific to the implementation are in the\n+code.  This file only contains a very high-level overview. Basically,\n+the forest is stored in a vector. Each element of the vector is a node\n+in some tree. Each node in the vector has the index of an (optional)\n+parent and (for convenience) its root (which may be itself). It also\n+has a current state, described by `NodeState`. After each\n+processing step, we compress the vector to remove completed and error\n+nodes, which aren't needed anymore.\n+\n+  "}, {"sha": "0d92a2b158f82496ac10e5e16edde3ccacf23ae0", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "added", "additions": 462, "deletions": 0, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -0,0 +1,462 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The `ObligationForest` is a utility data structure used in trait\n+//! matching to track the set of outstanding obligations (those not\n+//! yet resolved to success or error). It also tracks the \"backtrace\"\n+//! of each pending obligation (why we are trying to figure this out\n+//! in the first place). See README.md for a general overview of how\n+//! to use this class.\n+\n+use std::fmt::Debug;\n+use std::mem;\n+\n+mod node_index;\n+\n+#[cfg(test)]\n+mod test;\n+\n+pub struct ObligationForest<O> {\n+    /// The list of obligations. In between calls to\n+    /// `process_obligations`, this list only contains nodes in the\n+    /// `Pending` or `Success` state (with a non-zero number of\n+    /// incomplete children). During processing, some of those nodes\n+    /// may be changed to the error state, or we may find that they\n+    /// are completed (That is, `num_incomplete_children` drops to 0).\n+    /// At the end of processing, those nodes will be removed by a\n+    /// call to `compress`.\n+    ///\n+    /// At all times we maintain the invariant that every node appears\n+    /// at a higher index than its parent. This is needed by the\n+    /// backtrace iterator (which uses `split_at`).\n+    nodes: Vec<Node<O>>,\n+    snapshots: Vec<usize>\n+}\n+\n+pub struct Snapshot {\n+    len: usize,\n+}\n+\n+pub use self::node_index::NodeIndex;\n+\n+struct Node<O> {\n+    state: NodeState<O>,\n+    parent: Option<NodeIndex>,\n+    root: NodeIndex, // points to the root, which may be the current node\n+}\n+\n+/// The state of one node in some tree within the forest. This\n+/// represents the current state of processing for the obligation (of\n+/// type `O`) associated with this node.\n+#[derive(Debug)]\n+enum NodeState<O> {\n+    /// Obligation not yet resolved to success or error.\n+    Pending { obligation: O },\n+\n+    /// Obligation resolved to success; `num_incomplete_children`\n+    /// indicates the number of children still in an \"incomplete\"\n+    /// state. Incomplete means that either the child is still\n+    /// pending, or it has children which are incomplete. (Basically,\n+    /// there is pending work somewhere in the subtree of the child.)\n+    ///\n+    /// Once all children have completed, success nodes are removed\n+    /// from the vector by the compression step.\n+    Success { obligation: O, num_incomplete_children: usize },\n+\n+    /// This obligation was resolved to an error. Error nodes are\n+    /// removed from the vector by the compression step.\n+    Error,\n+}\n+\n+#[derive(Debug)]\n+pub struct Outcome<O,E> {\n+    /// Obligations that were completely evaluated, including all\n+    /// (transitive) subobligations.\n+    pub completed: Vec<O>,\n+\n+    /// Backtrace of obligations that were found to be in error.\n+    pub errors: Vec<Error<O,E>>,\n+\n+    /// If true, then we saw no successful obligations, which means\n+    /// there is no point in further iteration. This is based on the\n+    /// assumption that when trait matching returns `Err` or\n+    /// `Ok(None)`, those results do not affect environmental\n+    /// inference state. (Note that if we invoke `process_obligations`\n+    /// with no pending obligations, stalled will be true.)\n+    pub stalled: bool,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct Error<O,E> {\n+    pub error: E,\n+    pub backtrace: Vec<O>,\n+}\n+\n+impl<O: Debug> ObligationForest<O> {\n+    pub fn new() -> ObligationForest<O> {\n+        ObligationForest {\n+            nodes: vec![],\n+            snapshots: vec![]\n+        }\n+    }\n+\n+    /// Return the total number of nodes in the forest that have not\n+    /// yet been fully resolved.\n+    pub fn len(&self) -> usize {\n+        self.nodes.len()\n+    }\n+\n+    pub fn start_snapshot(&mut self) -> Snapshot {\n+        self.snapshots.push(self.nodes.len());\n+        Snapshot { len: self.snapshots.len() }\n+    }\n+\n+    pub fn commit_snapshot(&mut self, snapshot: Snapshot) {\n+        assert_eq!(snapshot.len, self.snapshots.len());\n+        let nodes_len = self.snapshots.pop().unwrap();\n+        assert!(self.nodes.len() >= nodes_len);\n+    }\n+\n+    pub fn rollback_snapshot(&mut self, snapshot: Snapshot) {\n+        // Check that we are obeying stack discipline.\n+        assert_eq!(snapshot.len, self.snapshots.len());\n+        let nodes_len = self.snapshots.pop().unwrap();\n+\n+        // The only action permitted while in a snapshot is to push\n+        // new root obligations. Because no processing will have been\n+        // done, those roots should still be in the pending state.\n+        debug_assert!(self.nodes[nodes_len..].iter().all(|n| match n.state {\n+            NodeState::Pending { .. } => true,\n+            _ => false,\n+        }));\n+\n+        self.nodes.truncate(nodes_len);\n+    }\n+\n+    pub fn in_snapshot(&self) -> bool {\n+        !self.snapshots.is_empty()\n+    }\n+\n+    /// Adds a new tree to the forest.\n+    ///\n+    /// This CAN be done during a snapshot.\n+    pub fn push_root(&mut self, obligation: O) {\n+        let index = NodeIndex::new(self.nodes.len());\n+        self.nodes.push(Node::new(index, None, obligation));\n+    }\n+\n+    /// Convert all remaining obligations to the given error.\n+    ///\n+    /// This cannot be done during a snapshot.\n+    pub fn to_errors<E:Clone>(&mut self, error: E) -> Vec<Error<O,E>> {\n+        assert!(!self.in_snapshot());\n+        let mut errors = vec![];\n+        for index in 0..self.nodes.len() {\n+            debug_assert!(!self.nodes[index].is_popped());\n+            self.inherit_error(index);\n+            if let NodeState::Pending { .. } = self.nodes[index].state {\n+                let backtrace = self.backtrace(index);\n+                errors.push(Error { error: error.clone(), backtrace: backtrace });\n+            }\n+        }\n+        let successful_obligations = self.compress();\n+        assert!(successful_obligations.is_empty());\n+        errors\n+    }\n+\n+    /// Returns the set of obligations that are in a pending state.\n+    pub fn pending_obligations(&self) -> Vec<O> where O: Clone {\n+        self.nodes.iter()\n+                  .filter_map(|n| match n.state {\n+                      NodeState::Pending { ref obligation } => Some(obligation),\n+                      _ => None,\n+                  })\n+                  .cloned()\n+                  .collect()\n+    }\n+\n+    /// Process the obligations.\n+    ///\n+    /// This CANNOT be unrolled (presently, at least).\n+    pub fn process_obligations<E,F>(&mut self, mut action: F) -> Outcome<O,E>\n+        where E: Debug, F: FnMut(&mut O, Backtrace<O>) -> Result<Option<Vec<O>>, E>\n+    {\n+        debug!(\"process_obligations(len={})\", self.nodes.len());\n+        assert!(!self.in_snapshot()); // cannot unroll this action\n+\n+        let mut errors = vec![];\n+        let mut stalled = true;\n+\n+        // We maintain the invariant that the list is in pre-order, so\n+        // parents occur before their children. Also, whenever an\n+        // error occurs, we propagate it from the child all the way to\n+        // the root of the tree. Together, these two facts mean that\n+        // when we visit a node, we can check if its root is in error,\n+        // and we will find out if any prior node within this forest\n+        // encountered an error.\n+\n+        for index in 0..self.nodes.len() {\n+            debug_assert!(!self.nodes[index].is_popped());\n+            self.inherit_error(index);\n+\n+            debug!(\"process_obligations: node {} == {:?}\",\n+                   index, self.nodes[index].state);\n+\n+            let result = {\n+                let parent = self.nodes[index].parent;\n+                let (prefix, suffix) = self.nodes.split_at_mut(index);\n+                let backtrace = Backtrace::new(prefix, parent);\n+                match suffix[0].state {\n+                    NodeState::Error |\n+                    NodeState::Success { .. } =>\n+                        continue,\n+                    NodeState::Pending { ref mut obligation } =>\n+                        action(obligation, backtrace),\n+                }\n+            };\n+\n+            debug!(\"process_obligations: node {} got result {:?}\", index, result);\n+\n+            match result {\n+                Ok(None) => {\n+                    // no change in state\n+                }\n+                Ok(Some(children)) => {\n+                    // if we saw a Some(_) result, we are not (yet) stalled\n+                    stalled = false;\n+                    self.success(index, children);\n+                }\n+                Err(err) => {\n+                    let backtrace = self.backtrace(index);\n+                    errors.push(Error { error: err, backtrace: backtrace });\n+                }\n+            }\n+        }\n+\n+        // Now we have to compress the result\n+        let successful_obligations = self.compress();\n+\n+        debug!(\"process_obligations: complete\");\n+\n+        Outcome {\n+            completed: successful_obligations,\n+            errors: errors,\n+            stalled: stalled,\n+        }\n+    }\n+\n+    /// Indicates that node `index` has been processed successfully,\n+    /// yielding `children` as the derivative work. If children is an\n+    /// empty vector, this will update the ref count on the parent of\n+    /// `index` to indicate that a child has completed\n+    /// successfully. Otherwise, adds new nodes to represent the child\n+    /// work.\n+    fn success(&mut self, index: usize, children: Vec<O>) {\n+        debug!(\"success(index={}, children={:?})\", index, children);\n+\n+        let num_incomplete_children = children.len();\n+\n+        if num_incomplete_children == 0 {\n+            // if there is no work left to be done, decrement parent's ref count\n+            self.update_parent(index);\n+        } else {\n+            // create child work\n+            let root_index = self.nodes[index].root;\n+            let node_index = NodeIndex::new(index);\n+            self.nodes.extend(\n+                children.into_iter()\n+                        .map(|o| Node::new(root_index, Some(node_index), o)));\n+        }\n+\n+        // change state from `Pending` to `Success`, temporarily swapping in `Error`\n+        let state = mem::replace(&mut self.nodes[index].state, NodeState::Error);\n+        self.nodes[index].state = match state {\n+            NodeState::Pending { obligation } =>\n+                NodeState::Success { obligation: obligation,\n+                                     num_incomplete_children: num_incomplete_children },\n+            NodeState::Success { .. } |\n+            NodeState::Error =>\n+                unreachable!()\n+        };\n+    }\n+\n+    /// Decrements the ref count on the parent of `child`; if the\n+    /// parent's ref count then reaches zero, proceeds recursively.\n+    fn update_parent(&mut self, child: usize) {\n+        debug!(\"update_parent(child={})\", child);\n+        if let Some(parent) = self.nodes[child].parent {\n+            let parent = parent.get();\n+            match self.nodes[parent].state {\n+                NodeState::Success { ref mut num_incomplete_children, .. } => {\n+                    *num_incomplete_children -= 1;\n+                    if *num_incomplete_children > 0 {\n+                        return;\n+                    }\n+                }\n+                _ => unreachable!(),\n+            }\n+            self.update_parent(parent);\n+        }\n+    }\n+\n+    /// If the root of `child` is in an error state, places `child`\n+    /// into an error state. This is used during processing so that we\n+    /// skip the remaining obligations from a tree once some other\n+    /// node in the tree is found to be in error.\n+    fn inherit_error(&mut self, child: usize) {\n+        let root = self.nodes[child].root.get();\n+        if let NodeState::Error = self.nodes[root].state {\n+            self.nodes[child].state = NodeState::Error;\n+        }\n+    }\n+\n+    /// Returns a vector of obligations for `p` and all of its\n+    /// ancestors, putting them into the error state in the process.\n+    /// The fact that the root is now marked as an error is used by\n+    /// `inherit_error` above to propagate the error state to the\n+    /// remainder of the tree.\n+    fn backtrace(&mut self, mut p: usize) -> Vec<O> {\n+        let mut trace = vec![];\n+        loop {\n+            let state = mem::replace(&mut self.nodes[p].state, NodeState::Error);\n+            match state {\n+                NodeState::Pending { obligation } |\n+                NodeState::Success { obligation, .. } => {\n+                    trace.push(obligation);\n+                }\n+                NodeState::Error => {\n+                    // we should not encounter an error, because if\n+                    // there was an error in the ancestors, it should\n+                    // have been propagated down and we should never\n+                    // have tried to process this obligation\n+                    panic!(\"encountered error in node {:?} when collecting stack trace\", p);\n+                }\n+            }\n+\n+            // loop to the parent\n+            match self.nodes[p].parent {\n+                Some(q) => { p = q.get(); }\n+                None => { return trace; }\n+            }\n+        }\n+    }\n+\n+    /// Compresses the vector, removing all popped nodes. This adjusts\n+    /// the indices and hence invalidates any outstanding\n+    /// indices. Cannot be used during a transaction.\n+    fn compress(&mut self) -> Vec<O> {\n+        assert!(!self.in_snapshot()); // didn't write code to unroll this action\n+        let mut rewrites: Vec<_> = (0..self.nodes.len()).collect();\n+\n+        // Finish propagating error state. Note that in this case we\n+        // only have to check immediate parents, rather than all\n+        // ancestors, because all errors have already occurred that\n+        // are going to occur.\n+        let nodes_len = self.nodes.len();\n+        for i in 0..nodes_len {\n+            if !self.nodes[i].is_popped() {\n+                self.inherit_error(i);\n+            }\n+        }\n+\n+        // Now go through and move all nodes that are either\n+        // successful or which have an error over into to the end of\n+        // the list, preserving the relative order of the survivors\n+        // (which is important for the `inherit_error` logic).\n+        let mut dead = 0;\n+        for i in 0..nodes_len {\n+            if self.nodes[i].is_popped() {\n+                dead += 1;\n+            } else if dead > 0 {\n+                self.nodes.swap(i, i - dead);\n+                rewrites[i] -= dead;\n+            }\n+        }\n+\n+        // Pop off all the nodes we killed and extract the success\n+        // stories.\n+        let successful =\n+            (0 .. dead).map(|_| self.nodes.pop().unwrap())\n+                       .flat_map(|node| match node.state {\n+                           NodeState::Error => None,\n+                           NodeState::Pending { .. } => unreachable!(),\n+                           NodeState::Success { obligation, num_incomplete_children } => {\n+                               assert_eq!(num_incomplete_children, 0);\n+                               Some(obligation)\n+                           }\n+                       })\n+                       .collect();\n+\n+        // Adjust the parent indices, since we compressed things.\n+        for node in &mut self.nodes {\n+            if let Some(ref mut index) = node.parent {\n+                let new_index = rewrites[index.get()];\n+                debug_assert!(new_index < (nodes_len - dead));\n+                *index = NodeIndex::new(new_index);\n+            }\n+\n+            node.root = NodeIndex::new(rewrites[node.root.get()]);\n+        }\n+\n+        successful\n+    }\n+}\n+\n+impl<O> Node<O> {\n+    fn new(root: NodeIndex, parent: Option<NodeIndex>, obligation: O) -> Node<O> {\n+        Node {\n+            parent: parent,\n+            state: NodeState::Pending { obligation: obligation },\n+            root: root\n+        }\n+    }\n+\n+    fn is_popped(&self) -> bool {\n+        match self.state {\n+            NodeState::Pending { .. } => false,\n+            NodeState::Success { num_incomplete_children, .. } => num_incomplete_children == 0,\n+            NodeState::Error => true,\n+        }\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub struct Backtrace<'b, O: 'b> {\n+    nodes: &'b [Node<O>],\n+    pointer: Option<NodeIndex>,\n+}\n+\n+impl<'b, O> Backtrace<'b, O> {\n+    fn new(nodes: &'b [Node<O>], pointer: Option<NodeIndex>) -> Backtrace<'b, O> {\n+        Backtrace { nodes: nodes, pointer: pointer }\n+    }\n+}\n+\n+impl<'b, O> Iterator for Backtrace<'b, O> {\n+    type Item = &'b O;\n+\n+    fn next(&mut self) -> Option<&'b O> {\n+        debug!(\"Backtrace: self.pointer = {:?}\", self.pointer);\n+        if let Some(p) = self.pointer {\n+            self.pointer = self.nodes[p.get()].parent;\n+            match self.nodes[p.get()].state {\n+                NodeState::Pending { ref obligation } |\n+                NodeState::Success { ref obligation, .. } => {\n+                    Some(obligation)\n+                }\n+                NodeState::Error => {\n+                    panic!(\"Backtrace encountered an error.\");\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "465cee0b60cc0d4391e85bd58c080037ce498524", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::nonzero::NonZero;\n+use std::u32;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct NodeIndex {\n+    index: NonZero<u32>\n+}\n+\n+impl NodeIndex {\n+    pub fn new(value: usize) -> NodeIndex {\n+        assert!(value < (u32::MAX as usize));\n+        unsafe {\n+            NodeIndex { index: NonZero::new((value as u32) + 1) }\n+        }\n+    }\n+\n+    pub fn get(self) -> usize {\n+        (*self.index - 1) as usize\n+    }\n+}\n+"}, {"sha": "519b282a6a8c7a0f523a1ea81a9886e50572bb6d", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -0,0 +1,206 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::{ObligationForest, Outcome, Error};\n+\n+#[test]\n+fn push_pop() {\n+    let mut forest = ObligationForest::new();\n+    forest.push_root(\"A\");\n+    forest.push_root(\"B\");\n+    forest.push_root(\"C\");\n+\n+    // first round, B errors out, A has subtasks, and C completes, creating this:\n+    //      A |-> A.1\n+    //        |-> A.2\n+    //        |-> A.3\n+    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n+        match *obligation {\n+            \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+            \"B\" => Err(\"B is for broken\"),\n+            \"C\" => Ok(Some(vec![])),\n+            _ => unreachable!(),\n+        }\n+    });\n+    assert_eq!(ok, vec![\"C\"]);\n+    assert_eq!(err, vec![Error {error: \"B is for broken\",\n+                                backtrace: vec![\"B\"]}]);\n+\n+    // second round: two delays, one success, creating an uneven set of subtasks:\n+    //      A |-> A.1\n+    //        |-> A.2\n+    //        |-> A.3 |-> A.3.i\n+    //      D |-> D.1\n+    //        |-> D.2\n+    forest.push_root(\"D\");\n+    let Outcome { completed: ok, errors: err, .. }: Outcome<&'static str, ()> =\n+        forest.process_obligations(|obligation, _| {\n+            match *obligation {\n+                \"A.1\" => Ok(None),\n+                \"A.2\" => Ok(None),\n+                \"A.3\" => Ok(Some(vec![\"A.3.i\"])),\n+                \"D\" => Ok(Some(vec![\"D.1\", \"D.2\"])),\n+                _ => unreachable!(),\n+            }\n+        });\n+    assert_eq!(ok, Vec::<&'static str>::new());\n+    assert_eq!(err, Vec::new());\n+\n+\n+    // third round: ok in A.1 but trigger an error in A.2. Check that it\n+    // propagates to A.3.i, but not D.1 or D.2.\n+    //      D |-> D.1 |-> D.1.i\n+    //        |-> D.2 |-> D.2.i\n+    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n+        match *obligation {\n+            \"A.1\" => Ok(Some(vec![])),\n+            \"A.2\" => Err(\"A is for apple\"),\n+            \"D.1\" => Ok(Some(vec![\"D.1.i\"])),\n+            \"D.2\" => Ok(Some(vec![\"D.2.i\"])),\n+            _ => unreachable!(),\n+        }\n+    });\n+    assert_eq!(ok, vec![\"A.1\"]);\n+    assert_eq!(err, vec![Error { error: \"A is for apple\",\n+                                 backtrace: vec![\"A.2\", \"A\"] }]);\n+\n+    // fourth round: error in D.1.i that should propagate to D.2.i\n+    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation, _| {\n+        match *obligation {\n+            \"D.1.i\" => Err(\"D is for dumb\"),\n+            _ => panic!(\"unexpected obligation {:?}\", obligation),\n+        }\n+    });\n+    assert_eq!(ok, Vec::<&'static str>::new());\n+    assert_eq!(err, vec![Error { error: \"D is for dumb\",\n+                                 backtrace: vec![\"D.1.i\", \"D.1\", \"D\"] }]);\n+}\n+\n+// Test that if a tree with grandchildren succeeds, everything is\n+// reported as expected:\n+// A\n+//   A.1\n+//   A.2\n+//      A.2.i\n+//      A.2.ii\n+//   A.3\n+#[test]\n+fn success_in_grandchildren() {\n+    let mut forest = ObligationForest::new();\n+    forest.push_root(\"A\");\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations::<(),_>(|obligation, _| {\n+            match *obligation {\n+                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+                _ => unreachable!(),\n+            }\n+        });\n+    assert!(ok.is_empty());\n+    assert!(err.is_empty());\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations::<(),_>(|obligation, _| {\n+            match *obligation {\n+                \"A.1\" => Ok(Some(vec![])),\n+                \"A.2\" => Ok(Some(vec![\"A.2.i\", \"A.2.ii\"])),\n+                \"A.3\" => Ok(Some(vec![])),\n+                _ => unreachable!(),\n+            }\n+        });\n+    assert_eq!(ok, vec![\"A.3\", \"A.1\"]);\n+    assert!(err.is_empty());\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations::<(),_>(|obligation, _| {\n+            match *obligation {\n+                \"A.2.i\" => Ok(Some(vec![\"A.2.i.a\"])),\n+                \"A.2.ii\" => Ok(Some(vec![])),\n+                _ => unreachable!(),\n+            }\n+        });\n+    assert_eq!(ok, vec![\"A.2.ii\"]);\n+    assert!(err.is_empty());\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations::<(),_>(|obligation, _| {\n+            match *obligation {\n+                \"A.2.i.a\" => Ok(Some(vec![])),\n+                _ => unreachable!(),\n+            }\n+        });\n+    assert_eq!(ok, vec![\"A.2.i.a\", \"A.2.i\", \"A.2\", \"A\"]);\n+    assert!(err.is_empty());\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations::<(),_>(|_, _| unreachable!());\n+    assert!(ok.is_empty());\n+    assert!(err.is_empty());\n+}\n+\n+#[test]\n+fn to_errors_no_throw() {\n+    // check that converting multiple children with common parent (A)\n+    // only yields one of them (and does not panic, in particular).\n+    let mut forest = ObligationForest::new();\n+    forest.push_root(\"A\");\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations::<(),_>(|obligation, _| {\n+            match *obligation {\n+                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+                _ => unreachable!(),\n+            }\n+        });\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err.len(), 0);\n+    let errors = forest.to_errors(());\n+    assert_eq!(errors.len(), 1);\n+}\n+\n+#[test]\n+fn backtrace() {\n+    // check that converting multiple children with common parent (A)\n+    // only yields one of them (and does not panic, in particular).\n+    let mut forest: ObligationForest<&'static str> = ObligationForest::new();\n+    forest.push_root(\"A\");\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n+            assert!(backtrace.next().is_none());\n+            match *obligation {\n+                \"A\" => Ok(Some(vec![\"A.1\"])),\n+                _ => unreachable!(),\n+            }\n+        });\n+    assert!(ok.is_empty());\n+    assert!(err.is_empty());\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n+            assert!(backtrace.next().unwrap() == &\"A\");\n+            assert!(backtrace.next().is_none());\n+            match *obligation {\n+                \"A.1\" => Ok(Some(vec![\"A.1.i\"])),\n+                _ => unreachable!(),\n+            }\n+        });\n+    assert!(ok.is_empty());\n+    assert!(err.is_empty());\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations::<(),_>(|obligation, mut backtrace| {\n+            assert!(backtrace.next().unwrap() == &\"A.1\");\n+            assert!(backtrace.next().unwrap() == &\"A\");\n+            assert!(backtrace.next().is_none());\n+            match *obligation {\n+                \"A.1.i\" => Ok(None),\n+                _ => unreachable!(),\n+            }\n+        });\n+    assert_eq!(ok.len(), 0);\n+    assert!(err.is_empty());\n+}"}, {"sha": "b19628baa88be5b5300d092d81d30fd68fcfcf00", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -139,7 +139,7 @@ fn test_env<F>(source_string: &str,\n                                lang_items,\n                                stability::Index::new(krate),\n                                |tcx| {\n-                                   let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n+                                   let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n                                    body(Env { infcx: &infcx });\n                                    let free_regions = FreeRegionMap::new();\n                                    infcx.resolve_regions_and_report_errors(&free_regions,"}, {"sha": "8985b1e56bc0097a2679137adc5c81b7c74046d4", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -869,7 +869,7 @@ impl LateLintPass for UnconditionalRecursion {\n                     let node_id = tcx.map.as_local_node_id(method.def_id).unwrap();\n \n                     let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n-                    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env), false);\n+                    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n                     let mut selcx = traits::SelectionContext::new(&infcx);\n                     match selcx.select(&obligation) {\n                         // The method comes from a `T: Trait` bound."}, {"sha": "3886a6b83ac9a00add3f742a137264a38a4a2049", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -143,7 +143,7 @@ impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n \n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n \n-        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env), true);\n+        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env));\n \n         match build_mir(Cx::new(&infcx), implicit_arg_tys, id, span, decl, body) {\n             Ok(mut mir) => {"}, {"sha": "3b7cb2bd4b4667423fc5651e768104bee8b87e94", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -141,6 +141,7 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n         fulfillment_cx\n         .pending_obligations()\n         .iter()\n+        .map(|obligation| &obligation.obligation)\n         .filter_map(|obligation| {\n             debug!(\"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n                    obligation.predicate);\n@@ -168,6 +169,7 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n         fulfillment_cx\n         .pending_obligations()\n         .iter()\n+        .map(|obligation| &obligation.obligation)\n         .filter_map(|obligation| {\n             let opt_trait_ref = match obligation.predicate {\n                 ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref()),"}, {"sha": "d5f242201892512ce71f85fe74d496b279a8834d", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -42,7 +42,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n            impl_trait_ref);\n \n-    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, true);\n+    let mut infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n     let mut fulfillment_cx = infcx.fulfillment_cx.borrow_mut();\n \n     let trait_to_impl_substs = &impl_trait_ref.substs;\n@@ -416,7 +416,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, true);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n     let mut fulfillment_cx = infcx.fulfillment_cx.borrow_mut();\n \n     // The below is for the most part highly similar to the procedure"}, {"sha": "deda0b818ee06d4e90f7af1386de524addf182d4", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -83,7 +83,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     // check that the impl type can be made to match the trait type.\n \n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(impl_param_env), true);\n+    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, Some(impl_param_env));\n \n     let named_type = tcx.lookup_item_type(self_type_did).ty;\n     let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);"}, {"sha": "d462e2b45b28121d44d85cfe1d200197c2331834", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -261,7 +261,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // FIXME(#18653) -- Try to resolve obligations, giving us more\n     // typing information, which can sometimes be needed to avoid\n     // pathological region inference failures.\n-    fcx.select_new_obligations();\n+    fcx.select_obligations_where_possible();\n \n     // Insert any adjustments needed (always an autoref of some mutability).\n     match self_expr {"}, {"sha": "a6fb4de8e2b5b3e1dd92915ca344bea88cf3ac43", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n            -> Inherited<'a, 'tcx> {\n \n         Inherited {\n-            infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env), true),\n+            infcx: infer::new_infer_ctxt(tcx, tables, Some(param_env)),\n             locals: RefCell::new(NodeMap()),\n             tables: tables,\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n@@ -1235,15 +1235,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return ty;\n         }\n \n-        // If not, try resolving any new fcx obligations that have cropped up.\n-        self.select_new_obligations();\n-        ty = self.infcx().resolve_type_vars_if_possible(&ty);\n-        if !ty.has_infer_types() {\n-            debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n-            return ty;\n-        }\n-\n-        // If not, try resolving *all* pending obligations as much as\n+        // If not, try resolving pending obligations as much as\n         // possible. This can help substantially when there are\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n@@ -2029,22 +2021,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n         }\n     }\n-\n-    /// Try to select any fcx obligation that we haven't tried yet, in an effort\n-    /// to improve inference. You could just call\n-    /// `select_obligations_where_possible` except that it leads to repeated\n-    /// work.\n-    fn select_new_obligations(&self) {\n-        match\n-            self.inh.infcx.fulfillment_cx\n-            .borrow_mut()\n-            .select_new_obligations(self.infcx())\n-        {\n-            Ok(()) => { }\n-            Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n-        }\n-    }\n-\n }\n \n impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n@@ -2496,7 +2472,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // an \"opportunistic\" vtable resolution of any trait bounds on\n         // the call. This helps coercions.\n         if check_blocks {\n-            fcx.select_new_obligations();\n+            fcx.select_obligations_where_possible();\n         }\n \n         // For variadic functions, we don't have a declared type for all of\n@@ -4126,7 +4102,7 @@ fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub fn check_representable(tcx: &ty::ctxt,\n                            sp: Span,\n                            item_id: ast::NodeId,\n-                           designation: &str) -> bool {\n+                           _designation: &str) -> bool {\n     let rty = tcx.node_id_to_type(item_id);\n \n     // Check that it is possible to represent this type. This call identifies\n@@ -4136,9 +4112,8 @@ pub fn check_representable(tcx: &ty::ctxt,\n     // caught by case 1.\n     match rty.is_representable(tcx, sp) {\n         Representability::SelfRecursive => {\n-            struct_span_err!(tcx.sess, sp, E0072, \"invalid recursive {} type\", designation)\n-                .fileline_help(sp, \"wrap the inner value in a box to make it representable\")\n-                .emit();\n+            let item_def_id = tcx.map.local_def_id(item_id);\n+            traits::recursive_type_with_infinite_size_error(tcx, item_def_id).emit();\n             return false\n         }\n         Representability::Representable | Representability::ContainsRecursive => (),"}, {"sha": "7e63fd47d61e15c61bd8163320ecad34dedceaab", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -384,7 +384,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n                    source, target);\n \n-            let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env), true);\n+            let infcx = new_infer_ctxt(tcx, &tcx.tables, Some(param_env));\n \n             let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>, mt_b: ty::TypeAndMut<'tcx>,\n                                mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n@@ -528,7 +528,7 @@ fn enforce_trait_manually_implementable(tcx: &ty::ctxt, sp: Span, trait_def_id:\n \n pub fn check_coherence(crate_context: &CrateCtxt) {\n     let _task = crate_context.tcx.dep_graph.in_task(DepNode::Coherence);\n-    let infcx = new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None, true);\n+    let infcx = new_infer_ctxt(crate_context.tcx, &crate_context.tcx.tables, None);\n     CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: infcx,"}, {"sha": "470e954781f8bbb6377fe9c84e63cb23af1ebe0e", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -127,7 +127,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                    impl1_def_id,\n                    impl2_def_id);\n \n-            let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None, false);\n+            let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, None);\n             if let Some(trait_ref) = traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n                 self.report_overlap_error(impl1_def_id, impl2_def_id, trait_ref);\n             }"}, {"sha": "55a1021f0fb9418ca3357292b586d25ec4b27881", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -869,43 +869,6 @@ fn main() {\n ```\n \"##,\n \n-E0072: r##\"\n-When defining a recursive struct or enum, any use of the type being defined\n-from inside the definition must occur behind a pointer (like `Box` or `&`).\n-This is because structs and enums must have a well-defined size, and without\n-the pointer the size of the type would need to be unbounded.\n-\n-Consider the following erroneous definition of a type for a list of bytes:\n-\n-```\n-// error, invalid recursive struct type\n-struct ListNode {\n-    head: u8,\n-    tail: Option<ListNode>,\n-}\n-```\n-\n-This type cannot have a well-defined size, because it needs to be arbitrarily\n-large (since we would be able to nest `ListNode`s to any depth). Specifically,\n-\n-```plain\n-size of `ListNode` = 1 byte for `head`\n-                   + 1 byte for the discriminant of the `Option`\n-                   + size of `ListNode`\n-```\n-\n-One way to fix this is by wrapping `ListNode` in a `Box`, like so:\n-\n-```\n-struct ListNode {\n-    head: u8,\n-    tail: Option<Box<ListNode>>,\n-}\n-```\n-\n-This works because `Box` is a pointer, so its size is well-known.\n-\"##,\n-\n E0073: r##\"\n You cannot define a struct (or enum) `Foo` that requires an instance of `Foo`\n in order to make a new `Foo` value. This is because there would be no way a"}, {"sha": "acffbeabb24c13bd68e4efe4b390231922b3725a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -193,7 +193,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n {\n     let result = match maybe_infcx {\n         None => {\n-            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n+            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n             infer::mk_eqty(&infcx, t1_is_expected, TypeOrigin::Misc(span), t1, t2)\n         }\n         Some(infcx) => {"}, {"sha": "bfe9d7403399d10cf1dbc705c3de3c5d8ceba898", "filename": "src/test/compile-fail/bad-sized.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -13,5 +13,6 @@ trait Trait {}\n pub fn main() {\n     let x: Vec<Trait + Sized> = Vec::new();\n     //~^ ERROR the trait `core::marker::Sized` is not implemented\n-    //~^^ ERROR the trait `core::marker::Sized` is not implemented\n+    //~| ERROR the trait `core::marker::Sized` is not implemented\n+    //~| ERROR the trait `core::marker::Sized` is not implemented\n }"}, {"sha": "c9a7f731aea08a0f2f6ce427977d2751d9f18ab3", "filename": "src/test/compile-fail/infinite-tag-type-recursion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-// error-pattern: invalid recursive enum type\n-\n enum mlist { cons(isize, mlist), nil, }\n+//~^ ERROR recursive type `mlist` has infinite size\n \n fn main() { let a = mlist::cons(10, mlist::cons(11, mlist::nil)); }"}, {"sha": "260cc366fae08a1cca39a36b4654568e904479c8", "filename": "src/test/compile-fail/issue-17431-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-17431-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-17431-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-1.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct Foo { foo: Option<Option<Foo>> }\n-//~^ ERROR invalid recursive struct type\n+//~^ ERROR recursive type `Foo` has infinite size\n \n impl Foo { fn bar(&self) {} }\n "}, {"sha": "edbc8c82432e0331b38cdae55603dfbddeff877b", "filename": "src/test/compile-fail/issue-17431-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-17431-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-17431-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-2.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -9,10 +9,9 @@\n // except according to those terms.\n \n struct Baz { q: Option<Foo> }\n-//~^ ERROR invalid recursive struct type\n \n struct Foo { q: Option<Baz> }\n-//~^ ERROR invalid recursive struct type\n+//~^ ERROR recursive type `Foo` has infinite size\n \n impl Foo { fn bar(&self) {} }\n "}, {"sha": "9ba085591f08bb3f8dd877d1f02e6294e19800d5", "filename": "src/test/compile-fail/issue-17431-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-17431-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-17431-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-3.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -11,7 +11,7 @@\n use std::sync::Mutex;\n \n struct Foo { foo: Mutex<Option<Foo>> }\n-//~^ ERROR invalid recursive struct type\n+//~^ ERROR recursive type `Foo` has infinite size\n \n impl Foo { fn bar(&self) {} }\n "}, {"sha": "665c3cf8fe6391cbe2d92f789b1c305bcf7193ae", "filename": "src/test/compile-fail/issue-17431-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-17431-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-17431-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-4.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -11,7 +11,7 @@\n use std::marker;\n \n struct Foo<T> { foo: Option<Option<Foo<T>>>, marker: marker::PhantomData<T> }\n-//~^ ERROR invalid recursive struct type\n+//~^ ERROR recursive type `Foo` has infinite size\n \n impl<T> Foo<T> { fn bar(&self) {} }\n "}, {"sha": "85ed4d5d634dbf09bbe419c7f534d8f7800b0952", "filename": "src/test/compile-fail/issue-17431-5.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-17431-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-17431-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-5.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -11,8 +11,9 @@\n use std::marker;\n \n struct Foo { foo: Bar<Foo> }\n+\n struct Bar<T> { x: Bar<Foo> , marker: marker::PhantomData<T> }\n-//~^ ERROR invalid recursive struct type\n+//~^ ERROR recursive type `Bar` has infinite size\n \n impl Foo { fn foo(&self) {} }\n "}, {"sha": "4c1e82c3d6ae48b533e25100ef24e681fd66f3bd", "filename": "src/test/compile-fail/issue-17431-6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-17431-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-17431-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-6.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -11,7 +11,7 @@\n use std::sync::Mutex;\n \n enum Foo { X(Mutex<Option<Foo>>) }\n-//~^ ERROR invalid recursive enum type\n+//~^ ERROR recursive type `Foo` has infinite size\n \n impl Foo { fn bar(self) {} }\n "}, {"sha": "71b85da29fc717cd4f588f73a462624763a69515", "filename": "src/test/compile-fail/issue-17431-7.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-17431-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-17431-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17431-7.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n enum Foo { Voo(Option<Option<Foo>>) }\n-//~^ ERROR invalid recursive enum type\n+//~^ ERROR recursive type `Foo` has infinite size\n \n impl Foo { fn bar(&self) {} }\n "}, {"sha": "09044b5b5055ddad3fb8a855d52719033e399842", "filename": "src/test/compile-fail/issue-20261.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    for (ref i,) in [].iter() { //~ ERROR: type mismatch resolving\n+    for (ref i,) in [].iter() { //~ ERROR mismatched types\n         i.clone();\n         //~^ ERROR: the type of this value must be known in this context\n     }"}, {"sha": "28080ae09e51bb87d82a608986c753e81a78fd24", "filename": "src/test/compile-fail/issue-26548.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: overflow representing the type `S`\n-\n-trait Mirror { type It; }\n-impl<T> Mirror for T { type It = Self; }\n+trait Mirror { type It: ?Sized; }\n+impl<T: ?Sized> Mirror for T { type It = Self; }\n struct S(Option<<S as Mirror>::It>);\n+//~^ ERROR recursive type `S` has infinite size\n \n fn main() {\n     let _s = S(None);"}, {"sha": "6de28cbbf357ca3c109f04e0d80be7dc658b01c4", "filename": "src/test/compile-fail/issue-2718-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2718-a.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -16,7 +16,7 @@ mod pingpong {\n     use send_packet;\n     pub type ping = send_packet<pong>;\n     pub struct pong(send_packet<ping>);\n-    //~^ ERROR invalid recursive struct type\n+    //~^ ERROR recursive type `pingpong::pong` has infinite size\n }\n \n fn main() {}"}, {"sha": "d3c15763eb00e57ca85b1877706bfca6f95f1af3", "filename": "src/test/compile-fail/issue-3008-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -10,7 +10,7 @@\n \n enum foo { foo_(bar) }\n enum bar { bar_none, bar_some(bar) }\n-//~^ ERROR invalid recursive enum type\n+//~^ ERROR recursive type `bar` has infinite size\n \n fn main() {\n }"}, {"sha": "e6cc29634a1e8ebaf696f54192e82775336323a2", "filename": "src/test/compile-fail/issue-3008-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -12,7 +12,7 @@\n \n enum foo { foo_(bar) }\n struct bar { x: bar }\n-//~^ ERROR invalid recursive struct type\n+//~^ ERROR E0072\n \n fn main() {\n }"}, {"sha": "66bfab003e9cf2640c10ec0b99c0c63870d3b963", "filename": "src/test/compile-fail/issue-3008-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-3008-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-3008-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-3.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -12,7 +12,7 @@ use std::marker;\n \n enum E1 { V1(E2<E1>), }\n enum E2<T> { V2(E2<E1>, marker::PhantomData<T>), }\n-//~^ ERROR invalid recursive enum type\n+//~^ ERROR recursive type `E2` has infinite size\n \n impl E1 { fn foo(&self) {} }\n "}, {"sha": "d96b1a1cbe35b1cd4f08bf56fa391ea88b25f733", "filename": "src/test/compile-fail/issue-3779.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3779.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S {\n-    //~^ ERROR invalid recursive struct type\n+struct S { //~ ERROR E0072\n     element: Option<S>\n }\n "}, {"sha": "87b7b73d57dbd41b18b560199588bb21b0339b64", "filename": "src/test/compile-fail/issue-7364.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -17,6 +17,5 @@ use std::cell::RefCell;\n static boxed: Box<RefCell<isize>> = box RefCell::new(0);\n //~^ ERROR allocations are not allowed in statics\n //~| ERROR the trait `core::marker::Sync` is not implemented for the type\n-//~| ERROR the trait `core::marker::Sync` is not implemented for the type\n \n fn main() { }"}, {"sha": "aec40c1a73a806f488acac21c3077c4da8d7c803", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -27,14 +27,12 @@ fn f<T>(val: T) {\n     let t: S<T> = S(marker::PhantomData);\n     let a = &t as &Gettable<T>;\n     //~^ ERROR the trait `core::marker::Send` is not implemented\n-    //~^^ ERROR the trait `core::marker::Copy` is not implemented\n }\n \n fn g<T>(val: T) {\n     let t: S<T> = S(marker::PhantomData);\n     let a: &Gettable<T> = &t;\n     //~^ ERROR the trait `core::marker::Send` is not implemented\n-    //~^^ ERROR the trait `core::marker::Copy` is not implemented\n }\n \n fn foo<'a>() {"}, {"sha": "731c1edbfc00b7fdf0f70f0b9c1f1cc26b9bbe57", "filename": "src/test/compile-fail/lint-ctypes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -13,8 +13,8 @@\n \n extern crate libc;\n \n-trait Mirror { type It; }\n-impl<T> Mirror for T { type It = Self; }\n+trait Mirror { type It: ?Sized; }\n+impl<T: ?Sized> Mirror for T { type It = Self; }\n #[repr(C)]\n pub struct StructWithProjection(*mut <StructWithProjection as Mirror>::It);\n #[repr(C)]"}, {"sha": "db19132b2c454738a19133d13e563fed724d4ba8", "filename": "src/test/compile-fail/mut-not-freeze.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-not-freeze.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -16,5 +16,4 @@ fn main() {\n     let x = RefCell::new(0);\n     f(x);\n     //~^ ERROR `core::marker::Sync` is not implemented\n-    //~^^ ERROR `core::marker::Sync` is not implemented\n }"}, {"sha": "922d70b8013dc73f1ae93ef69365ca54e8e81307", "filename": "src/test/compile-fail/not-panic-safe-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -18,7 +18,6 @@ use std::cell::RefCell;\n fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<Rc<RefCell<i32>>>(); //~ ERROR: is not implemented\n-    //~^ ERROR: is not implemented\n+    assert::<Rc<RefCell<i32>>>(); //~ ERROR E0277\n }\n "}, {"sha": "50a69543f7d04fbfaa77a0d4cea3ef2d46f6457e", "filename": "src/test/compile-fail/not-panic-safe-3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -19,5 +19,4 @@ fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n     assert::<Arc<RefCell<i32>>>(); //~ ERROR: is not implemented\n-    //~^ ERROR: is not implemented\n }"}, {"sha": "c50e4b9d87e063cd295e971d841d66b5be2914da", "filename": "src/test/compile-fail/not-panic-safe-4.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -17,6 +17,5 @@ use std::cell::RefCell;\n fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<&RefCell<i32>>(); //~ ERROR: is not implemented\n-    //~^ ERROR is not implemented\n+    assert::<&RefCell<i32>>(); //~ ERROR E0277\n }"}, {"sha": "0fc912dc95fab8eeeb43b991b875643610404c65", "filename": "src/test/compile-fail/not-panic-safe-6.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -17,7 +17,6 @@ use std::cell::RefCell;\n fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<*mut RefCell<i32>>(); //~ ERROR: is not implemented\n-    //~^ ERROR is not implemented\n+    assert::<*mut RefCell<i32>>(); //~ ERROR E0277\n }\n "}, {"sha": "8e3161ef884be5b83410291364cc2678c9b8ddf0", "filename": "src/test/compile-fail/object-safety-generics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-generics.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -28,6 +28,7 @@ fn make_bar<T:Bar>(t: &T) -> &Bar {\n }\n \n fn make_bar_explicit<T:Bar>(t: &T) -> &Bar {\n+    //~^ ERROR E0038\n     t as &Bar\n }\n "}, {"sha": "b839902c6832ab16eeeaa9c77ef57513348d8966", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -17,12 +17,11 @@ pub fn main() {\n \n     // Bool => does not implement iterator.\n     for i in false..true {}\n-    //~^ ERROR the trait\n-    //~^^ ERROR the trait\n-    //~^^^ ERROR the trait\n+    //~^ ERROR E0277\n \n     // Unsized type.\n     let arr: &[_] = &[1, 2, 3];\n     let range = *arr..;\n     //~^ ERROR the trait `core::marker::Sized` is not implemented\n+    //~| ERROR the trait `core::marker::Sized` is not implemented\n }"}, {"sha": "3221ae4629643a68ffa2c2ebee619bf11117ce17", "filename": "src/test/compile-fail/recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -19,8 +19,8 @@ impl<T:Dot> Dot for Cons<T> {\n     self.head * other.head + self.tail.dot(other.tail)\n   }\n }\n-fn test<T:Dot> (n:isize, i:isize, first:T, second:T) ->isize {\n-  match n {    0 => {first.dot(second)} //~ ERROR overflow\n+fn test<T:Dot> (n:isize, i:isize, first:T, second:T) ->isize { //~ ERROR recursion limit\n+  match n {    0 => {first.dot(second)}\n       // FIXME(#4287) Error message should be here. It should be\n       // a type error to instantiate `test` at a type other than T.\n     _ => {test (n-1, i+1, Cons {head:2*i+1, tail:first}, Cons{head:i*i, tail:second})}"}, {"sha": "555755cdb96eadfbb7dd664a0cbfeba20865e7af", "filename": "src/test/compile-fail/recursive-enum.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Frecursive-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Frecursive-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursive-enum.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: invalid recursive enum type\n-\n enum list<T> { cons(T, list<T>), nil }\n+//~^ ERROR recursive type `list` has infinite size\n \n fn main() {}"}, {"sha": "bb1ab2eafb355efc4d0871172a0e544b41a471ae", "filename": "src/test/compile-fail/sized-cycle-note.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsized-cycle-note.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test the error message resulting from a cycle in solving `Foo:\n+// Sized`. The specifics of the message will of course but the main\n+// thing we want to preserve is that:\n+//\n+// 1. the message should appear attached to one of the structs\n+//    defined in this file;\n+// 2. it should elaborate the steps that led to the cycle.\n+\n+struct Baz { q: Option<Foo> }\n+\n+struct Foo { q: Option<Baz> }\n+//~^ ERROR recursive type `Foo` has infinite size\n+//~| type `Foo` is embedded within `core::option::Option<Foo>`...\n+//~| ...which in turn is embedded within `core::option::Option<Foo>`...\n+//~| ...which in turn is embedded within `Baz`...\n+//~| ...which in turn is embedded within `core::option::Option<Baz>`...\n+//~| ...which in turn is embedded within `Foo`, completing the cycle.\n+\n+impl Foo { fn bar(&self) {} }\n+\n+fn main() {}"}, {"sha": "520691fbecc481b34985c4bb65c40cd6074609a1", "filename": "src/test/compile-fail/trait-bounds-on-structs-and-enums-locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-on-structs-and-enums-locals.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -22,6 +22,6 @@ fn main() {\n         x: 3\n     };\n \n-    let baz: Foo<usize> = panic!();\n+    let baz: Foo<usize> = loop { };\n     //~^ ERROR not implemented\n }"}, {"sha": "0cfcf6bb3f907084617231fcb3b29e923453eee5", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -21,5 +21,7 @@ fn main() {\n     (box 10 as Box<bar>).dup();\n     //~^ ERROR E0038\n     //~| ERROR E0038\n+    //~| ERROR E0038\n+    //~| ERROR E0038\n     //~| ERROR E0277\n }"}, {"sha": "1362f8ac0aef5dd19627fd5b1a804a7b3927ac3b", "filename": "src/test/compile-fail/traits-inductive-overflow-supertrait-oibit.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-supertrait-oibit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-supertrait-oibit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-supertrait-oibit.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// OIBIT-based version of #29859, supertrait version. Test that using\n+// a simple OIBIT `..` impl alone still doesn't allow arbitary bounds\n+// to be synthesized.\n+\n+#![feature(optin_builtin_traits)]\n+\n+trait Magic: Copy {}\n+impl Magic for .. {}\n+\n+fn copy<T: Magic>(x: T) -> (T, T) { (x, x) }\n+\n+#[derive(Debug)]\n+struct NoClone;\n+\n+fn main() {\n+    let (a, b) = copy(NoClone); //~ ERROR E0277\n+    println!(\"{:?} {:?}\", a, b);\n+}"}, {"sha": "c717ae9639fa9e9382cc7b81c2a892a2f8df0016", "filename": "src/test/compile-fail/traits-inductive-overflow-supertrait.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-supertrait.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #29859, supertrait version. This example\n+// allowed arbitrary trait bounds to be synthesized.\n+\n+trait Magic: Copy {}\n+impl<T: Magic> Magic for T {}\n+\n+fn copy<T: Magic>(x: T) -> (T, T) { (x, x) }\n+\n+#[derive(Debug)]\n+struct NoClone;\n+\n+fn main() {\n+    let (a, b) = copy(NoClone); //~ ERROR E0275\n+    println!(\"{:?} {:?}\", a, b);\n+}"}, {"sha": "c622dca2b4df6ddf960adc9e737103a9f7e19755", "filename": "src/test/compile-fail/traits-inductive-overflow-two-traits.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-two-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-two-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-two-traits.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #29859, initial version. This example allowed\n+// arbitrary trait bounds to be synthesized.\n+\n+// Trait that you want all types to implement.\n+use std::marker::{Sync as Trait};\n+\n+pub trait Magic {\n+    type X: Trait;\n+}\n+impl<T: Magic> Magic for T {\n+    type X = Self;\n+}\n+\n+fn check<T: Trait>() {}\n+\n+fn wizard<T: Magic>() { check::<<T as Magic>::X>(); }\n+\n+fn main() {\n+    wizard::<*mut ()>(); //~ ERROR E0275\n+    // check::<*mut ()>();\n+}"}, {"sha": "4bb739800df368821aacde032015d05231cc3ea8", "filename": "src/test/compile-fail/type-recursive.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14b615534ebcd5667f594c86d18eebff6afc7cb/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-recursive.rs?ref=c14b615534ebcd5667f594c86d18eebff6afc7cb", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:invalid recursive struct type\n-struct t1 {\n+struct t1 { //~ ERROR E0072\n     foo: isize,\n     foolish: t1\n }"}]}