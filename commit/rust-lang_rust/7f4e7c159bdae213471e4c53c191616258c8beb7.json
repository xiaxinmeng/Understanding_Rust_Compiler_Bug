{"sha": "7f4e7c159bdae213471e4c53c191616258c8beb7", "node_id": "C_kwDOAAsO6NoAKDdmNGU3YzE1OWJkYWUyMTM0NzFlNGM1M2MxOTE2MTYyNThjOGJlYjc", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-10T23:30:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-10T23:30:18Z"}, "message": "Rollup merge of #103146 - joboet:cleanup_pthread_condvar, r=Mark-Simulacrum\n\nCleanup timeouts in pthread condvar", "tree": {"sha": "f23d9b8626edbb5508c175ec446218fbbc0eca8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f23d9b8626edbb5508c175ec446218fbbc0eca8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f4e7c159bdae213471e4c53c191616258c8beb7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjlRaKCRBK7hj4Ov3rIwAAOKEIAA3+1kMj2VktmgJYBnWvofk9\nwcZcVWFbXFkmos/pILDC0qneIXmzcZllbVXwGx4zj57vDGmQqimJTKi3FqD3Lm+o\nu8z6/nw7efpzaODDfyD6cuZJnqRxhC+6k1pyOV68eySNGAeSzvDHxlhyfKDnQCO9\n6s8y4JTyxXCpQTLlyO44LetovHfpnH+hmUqOOiqDwcYd8kXJfFIykNpln8+dDswu\n9R/z1Zc2geKU3NzR8bFTOYt68o3MDn9ntclcRgyl8br9pGl/guy69MSacm8+9Qq0\nZisxXVy519QEAm4dzOkd7Ay0Zs+UCkQ42FvbpxXszs1Ub7jwT8jfeHI/Jf4SVCE=\n=2OuT\n-----END PGP SIGNATURE-----\n", "payload": "tree f23d9b8626edbb5508c175ec446218fbbc0eca8c\nparent c6fcdb690609769a240fc8ab0de0ce68d5ea7dba\nparent da0a54277aed2127993541292bd3a923f3c61081\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1670715018 +0100\ncommitter GitHub <noreply@github.com> 1670715018 +0100\n\nRollup merge of #103146 - joboet:cleanup_pthread_condvar, r=Mark-Simulacrum\n\nCleanup timeouts in pthread condvar\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f4e7c159bdae213471e4c53c191616258c8beb7", "html_url": "https://github.com/rust-lang/rust/commit/7f4e7c159bdae213471e4c53c191616258c8beb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f4e7c159bdae213471e4c53c191616258c8beb7/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6fcdb690609769a240fc8ab0de0ce68d5ea7dba", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6fcdb690609769a240fc8ab0de0ce68d5ea7dba", "html_url": "https://github.com/rust-lang/rust/commit/c6fcdb690609769a240fc8ab0de0ce68d5ea7dba"}, {"sha": "da0a54277aed2127993541292bd3a923f3c61081", "url": "https://api.github.com/repos/rust-lang/rust/commits/da0a54277aed2127993541292bd3a923f3c61081", "html_url": "https://github.com/rust-lang/rust/commit/da0a54277aed2127993541292bd3a923f3c61081"}], "stats": {"total": 100, "additions": 34, "deletions": 66}, "files": [{"sha": "6be1abc2b080a0164d772b5f6eed32b7f2bc9b9d", "filename": "library/std/src/sys/unix/locks/pthread_condvar.rs", "status": "modified", "additions": 30, "deletions": 63, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7f4e7c159bdae213471e4c53c191616258c8beb7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f4e7c159bdae213471e4c53c191616258c8beb7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs?ref=7f4e7c159bdae213471e4c53c191616258c8beb7", "patch": "@@ -2,6 +2,7 @@ use crate::cell::UnsafeCell;\n use crate::ptr;\n use crate::sync::atomic::{AtomicPtr, Ordering::Relaxed};\n use crate::sys::locks::{pthread_mutex, Mutex};\n+use crate::sys::time::TIMESPEC_MAX;\n use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n use crate::time::Duration;\n \n@@ -12,13 +13,6 @@ pub struct Condvar {\n     mutex: AtomicPtr<libc::pthread_mutex_t>,\n }\n \n-const TIMESPEC_MAX: libc::timespec =\n-    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n-\n-fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n-    if value > <libc::time_t>::MAX as u64 { <libc::time_t>::MAX } else { value as libc::time_t }\n-}\n-\n #[inline]\n fn raw(c: &Condvar) -> *mut libc::pthread_cond_t {\n     c.inner.0.get()\n@@ -133,26 +127,15 @@ impl Condvar {\n         target_os = \"horizon\"\n     )))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        use crate::mem;\n+        use crate::sys::time::Timespec;\n \n         let mutex = pthread_mutex::raw(mutex);\n         self.verify(mutex);\n \n-        let mut now: libc::timespec = mem::zeroed();\n-        let r = libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now);\n-        assert_eq!(r, 0);\n-\n-        // Nanosecond calculations can't overflow because both values are below 1e9.\n-        let nsec = dur.subsec_nanos() + now.tv_nsec as u32;\n-\n-        let sec = saturating_cast_to_time_t(dur.as_secs())\n-            .checked_add((nsec / 1_000_000_000) as libc::time_t)\n-            .and_then(|s| s.checked_add(now.tv_sec));\n-        let nsec = nsec % 1_000_000_000;\n-\n-        let timeout =\n-            sec.map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec as _ }).unwrap_or(TIMESPEC_MAX);\n-\n+        let timeout = Timespec::now(libc::CLOCK_MONOTONIC)\n+            .checked_add_duration(&dur)\n+            .and_then(|t| t.to_timespec())\n+            .unwrap_or(TIMESPEC_MAX);\n         let r = libc::pthread_cond_timedwait(raw(self), mutex, &timeout);\n         assert!(r == libc::ETIMEDOUT || r == 0);\n         r == 0\n@@ -169,57 +152,41 @@ impl Condvar {\n         target_os = \"espidf\",\n         target_os = \"horizon\"\n     ))]\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        use crate::sys::time::SystemTime;\n         use crate::time::Instant;\n \n         let mutex = pthread_mutex::raw(mutex);\n         self.verify(mutex);\n \n-        // 1000 years\n-        let max_dur = Duration::from_secs(1000 * 365 * 86400);\n-\n-        if dur > max_dur {\n-            // OSX implementation of `pthread_cond_timedwait` is buggy\n-            // with super long durations. When duration is greater than\n-            // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n-            // in macOS Sierra return error 316.\n-            //\n-            // This program demonstrates the issue:\n-            // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n-            //\n-            // To work around this issue, and possible bugs of other OSes, timeout\n-            // is clamped to 1000 years, which is allowable per the API of `wait_timeout`\n-            // because of spurious wakeups.\n-\n-            dur = max_dur;\n-        }\n-\n-        // First, figure out what time it currently is, in both system and\n-        // stable time.  pthread_cond_timedwait uses system time, but we want to\n-        // report timeout based on stable time.\n-        let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n-        let stable_now = Instant::now();\n-        let r = libc::gettimeofday(&mut sys_now, ptr::null_mut());\n-        assert_eq!(r, 0, \"unexpected error: {:?}\", crate::io::Error::last_os_error());\n-\n-        let nsec = dur.subsec_nanos() as libc::c_long + (sys_now.tv_usec * 1000) as libc::c_long;\n-        let extra = (nsec / 1_000_000_000) as libc::time_t;\n-        let nsec = nsec % 1_000_000_000;\n-        let seconds = saturating_cast_to_time_t(dur.as_secs());\n-\n-        let timeout = sys_now\n-            .tv_sec\n-            .checked_add(extra)\n-            .and_then(|s| s.checked_add(seconds))\n-            .map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec })\n+        // OSX implementation of `pthread_cond_timedwait` is buggy\n+        // with super long durations. When duration is greater than\n+        // 0x100_0000_0000_0000 seconds, `pthread_cond_timedwait`\n+        // in macOS Sierra returns error 316.\n+        //\n+        // This program demonstrates the issue:\n+        // https://gist.github.com/stepancheg/198db4623a20aad2ad7cddb8fda4a63c\n+        //\n+        // To work around this issue, and possible bugs of other OSes, timeout\n+        // is clamped to 1000 years, which is allowable per the API of `wait_timeout`\n+        // because of spurious wakeups.\n+        let dur = Duration::min(dur, Duration::from_secs(1000 * 365 * 86400));\n+\n+        // pthread_cond_timedwait uses system time, but we want to report timeout\n+        // based on stable time.\n+        let now = Instant::now();\n+\n+        let timeout = SystemTime::now()\n+            .t\n+            .checked_add_duration(&dur)\n+            .and_then(|t| t.to_timespec())\n             .unwrap_or(TIMESPEC_MAX);\n \n-        // And wait!\n         let r = libc::pthread_cond_timedwait(raw(self), mutex, &timeout);\n         debug_assert!(r == libc::ETIMEDOUT || r == 0);\n \n         // ETIMEDOUT is not a totally reliable method of determining timeout due\n         // to clock shifts, so do the check ourselves\n-        stable_now.elapsed() < dur\n+        now.elapsed() < dur\n     }\n }"}, {"sha": "c400c7715676f7856d47e3be8ed83e0c839cd340", "filename": "library/std/src/sys/unix/thread_parker/pthread.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f4e7c159bdae213471e4c53c191616258c8beb7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f4e7c159bdae213471e4c53c191616258c8beb7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker%2Fpthread.rs?ref=7f4e7c159bdae213471e4c53c191616258c8beb7", "patch": "@@ -6,6 +6,7 @@ use crate::pin::Pin;\n use crate::ptr::addr_of_mut;\n use crate::sync::atomic::AtomicUsize;\n use crate::sync::atomic::Ordering::SeqCst;\n+use crate::sys::time::TIMESPEC_MAX;\n use crate::time::Duration;\n \n const EMPTY: usize = 0;\n@@ -32,9 +33,6 @@ unsafe fn wait(cond: *mut libc::pthread_cond_t, lock: *mut libc::pthread_mutex_t\n     debug_assert_eq!(r, 0);\n }\n \n-const TIMESPEC_MAX: libc::timespec =\n-    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n-\n unsafe fn wait_timeout(\n     cond: *mut libc::pthread_cond_t,\n     lock: *mut libc::pthread_mutex_t,"}, {"sha": "2daad981b73e9a94af6e3b3f779b029d4026076e", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f4e7c159bdae213471e4c53c191616258c8beb7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f4e7c159bdae213471e4c53c191616258c8beb7/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=7f4e7c159bdae213471e4c53c191616258c8beb7", "patch": "@@ -5,6 +5,9 @@ pub use self::inner::Instant;\n \n const NSEC_PER_SEC: u64 = 1_000_000_000;\n pub const UNIX_EPOCH: SystemTime = SystemTime { t: Timespec::zero() };\n+#[allow(dead_code)] // Used for pthread condvar timeouts\n+pub const TIMESPEC_MAX: libc::timespec =\n+    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[repr(transparent)]"}]}