{"sha": "7bac5963b9d5f50b5652c071432445c0740ddef4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYWM1OTYzYjlkNWY1MGI1NjUyYzA3MTQzMjQ0NWMwNzQwZGRlZjQ=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-15T02:39:51Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-15T02:39:51Z"}, "message": "Handle recursive calls without recursing in miri.", "tree": {"sha": "e5ef3a33bd6afea1276088a6967e8244647e7623", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5ef3a33bd6afea1276088a6967e8244647e7623"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bac5963b9d5f50b5652c071432445c0740ddef4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bac5963b9d5f50b5652c071432445c0740ddef4", "html_url": "https://github.com/rust-lang/rust/commit/7bac5963b9d5f50b5652c071432445c0740ddef4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bac5963b9d5f50b5652c071432445c0740ddef4/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66eb109070a824057e61571bc2b2714cad6a65d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/66eb109070a824057e61571bc2b2714cad6a65d0", "html_url": "https://github.com/rust-lang/rust/commit/66eb109070a824057e61571bc2b2714cad6a65d0"}], "stats": {"total": 147, "additions": 79, "deletions": 68}, "files": [{"sha": "b602857e911f3f0276e60c915b04d459204503c6", "filename": "src/interpreter.rs", "status": "modified", "additions": 79, "deletions": 68, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/7bac5963b9d5f50b5652c071432445c0740ddef4/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bac5963b9d5f50b5652c071432445c0740ddef4/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=7bac5963b9d5f50b5652c071432445c0740ddef4", "patch": "@@ -67,6 +67,9 @@ struct Frame<'a, 'tcx: 'a> {\n     /// The MIR for the function called on this frame.\n     mir: CachedMir<'a, 'tcx>,\n \n+    /// The block in the MIR this frame will execute once a fn call returns back to this frame.\n+    next_block: mir::BasicBlock,\n+\n     /// A pointer for writing the return value of the current call, if it's not a diverging call.\n     return_ptr: Option<Pointer>,\n \n@@ -113,7 +116,7 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n             mir_cache: RefCell::new(DefIdMap()),\n             memory: Memory::new(),\n             stack: Vec::new(),\n-            substs_stack: vec![tcx.mk_substs(Substs::empty())],\n+            substs_stack: Vec::new(),\n         }\n     }\n \n@@ -143,6 +146,7 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n \n         self.stack.push(Frame {\n             mir: mir.clone(),\n+            next_block: mir::START_BLOCK,\n             return_ptr: return_ptr,\n             locals: locals,\n             var_offset: num_args,\n@@ -176,95 +180,96 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         }\n     }\n \n-    fn call(&mut self, mir: CachedMir<'a, 'tcx>, args: &[mir::Operand<'tcx>],\n-            return_ptr: Option<Pointer>) -> EvalResult<()> {\n-        try!(self.push_stack_frame(mir.clone(), args, return_ptr));\n-        let mut current_block = mir::START_BLOCK;\n+    fn run(&mut self) -> EvalResult<()> {\n+        'outer: while !self.stack.is_empty() {\n+            let mut current_block = self.current_frame().next_block;\n \n-        loop {\n-            if TRACE_EXECUTION { println!(\"Entering block: {:?}\", current_block); }\n-            let block_data = mir.basic_block_data(current_block);\n+            loop {\n+                if TRACE_EXECUTION { println!(\"Entering block: {:?}\", current_block); }\n+                let current_mir = self.current_frame().mir.clone(); // Cloning a reference.\n+                let block_data = current_mir.basic_block_data(current_block);\n \n-            for stmt in &block_data.statements {\n-                if TRACE_EXECUTION { println!(\"{:?}\", stmt); }\n-                let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n-                try!(self.eval_assignment(lvalue, rvalue));\n-            }\n+                for stmt in &block_data.statements {\n+                    if TRACE_EXECUTION { println!(\"{:?}\", stmt); }\n+                    let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n+                    try!(self.eval_assignment(lvalue, rvalue));\n+                }\n \n-            if TRACE_EXECUTION { println!(\"{:?}\", block_data.terminator()); }\n+                if TRACE_EXECUTION { println!(\"{:?}\", block_data.terminator()); }\n \n-            use rustc::mir::repr::Terminator::*;\n-            match *block_data.terminator() {\n-                Return => break,\n+                use rustc::mir::repr::Terminator::*;\n+                match *block_data.terminator() {\n+                    Return => break,\n \n-                Goto { target } => current_block = target,\n+                    Goto { target } => current_block = target,\n \n-                If { ref cond, targets: (then_target, else_target) } => {\n-                    let (cond_ptr, _) = try!(self.eval_operand(cond));\n-                    let cond_val = try!(self.memory.read_bool(cond_ptr));\n-                    current_block = if cond_val { then_target } else { else_target };\n-                }\n+                    If { ref cond, targets: (then_target, else_target) } => {\n+                        let (cond_ptr, _) = try!(self.eval_operand(cond));\n+                        let cond_val = try!(self.memory.read_bool(cond_ptr));\n+                        current_block = if cond_val { then_target } else { else_target };\n+                    }\n \n-                SwitchInt { ref discr, ref values, ref targets, .. } => {\n-                    let (discr_ptr, discr_repr) = try!(self.eval_lvalue(discr));\n-                    let discr_val = try!(self.memory.read_primval(discr_ptr, &discr_repr));\n+                    SwitchInt { ref discr, ref values, ref targets, .. } => {\n+                        let (discr_ptr, discr_repr) = try!(self.eval_lvalue(discr));\n+                        let discr_val = try!(self.memory.read_primval(discr_ptr, &discr_repr));\n \n-                    // Branch to the `otherwise` case by default, if no match is found.\n-                    current_block = targets[targets.len() - 1];\n+                        // Branch to the `otherwise` case by default, if no match is found.\n+                        current_block = targets[targets.len() - 1];\n \n-                    for (index, val_const) in values.iter().enumerate() {\n-                        let ptr = try!(self.const_to_ptr(val_const));\n-                        let val = try!(self.memory.read_primval(ptr, &discr_repr));\n-                        if discr_val == val {\n-                            current_block = targets[index];\n-                            break;\n+                        for (index, val_const) in values.iter().enumerate() {\n+                            let ptr = try!(self.const_to_ptr(val_const));\n+                            let val = try!(self.memory.read_primval(ptr, &discr_repr));\n+                            if discr_val == val {\n+                                current_block = targets[index];\n+                                break;\n+                            }\n                         }\n                     }\n-                }\n \n-                Switch { ref discr, ref targets, .. } => {\n-                    let (adt_ptr, adt_repr) = try!(self.eval_lvalue(discr));\n-                    let discr_repr = match adt_repr {\n-                        Repr::Sum { ref discr, .. } => discr,\n-                        _ => panic!(\"attmpted to switch on non-sum type\"),\n-                    };\n-                    let discr_val = try!(self.memory.read_primval(adt_ptr, &discr_repr));\n-                    current_block = targets[discr_val.to_int() as usize];\n-                }\n+                    Switch { ref discr, ref targets, .. } => {\n+                        let (adt_ptr, adt_repr) = try!(self.eval_lvalue(discr));\n+                        let discr_repr = match adt_repr {\n+                            Repr::Sum { ref discr, .. } => discr,\n+                            _ => panic!(\"attmpted to switch on non-sum type\"),\n+                        };\n+                        let discr_val = try!(self.memory.read_primval(adt_ptr, &discr_repr));\n+                        current_block = targets[discr_val.to_int() as usize];\n+                    }\n \n-                Call { ref func, ref args, ref destination, .. } => {\n-                    let ptr = match *destination {\n-                        Some((ref lv, _)) => Some(try!(self.eval_lvalue(lv)).0),\n-                        None => None,\n-                    };\n-                    let func_ty = self.current_frame().mir.operand_ty(self.tcx, func);\n-\n-                    match func_ty.sty {\n-                        ty::TyFnDef(def_id, substs, _) => {\n-                            self.substs_stack.push(substs);\n-                            let mir = self.load_mir(def_id);\n-                            try!(self.call(mir, args, ptr));\n+                    Call { ref func, ref args, ref destination, .. } => {\n+                        let mut return_ptr = None;\n+                        if let Some((ref lv, target)) = *destination {\n+                            self.current_frame_mut().next_block = target;\n+                            return_ptr = Some(try!(self.eval_lvalue(lv)).0)\n                         }\n \n-                        _ => panic!(\"can't handle callee of type {:?}\", func_ty),\n+                        let func_ty = self.current_frame().mir.operand_ty(self.tcx, func);\n+\n+                        match func_ty.sty {\n+                            ty::TyFnDef(def_id, substs, _) => {\n+                                let mir = self.load_mir(def_id);\n+                                self.substs_stack.push(substs);\n+                                try!(self.push_stack_frame(mir, args, return_ptr));\n+                                continue 'outer;\n+                            }\n+\n+                            _ => panic!(\"can't handle callee of type {:?}\", func_ty),\n+                        }\n                     }\n \n-                    if let Some((_, target)) = *destination {\n+                    Drop { target, .. } => {\n+                        // TODO: Handle destructors and dynamic drop.\n                         current_block = target;\n                     }\n-                }\n \n-                Drop { target, .. } => {\n-                    // TODO: Handle destructors and dynamic drop.\n-                    current_block = target;\n+                    Resume => unimplemented!(),\n                 }\n-\n-                Resume => unimplemented!(),\n             }\n+\n+            self.pop_stack_frame();\n+            self.substs_stack.pop();\n         }\n \n-        self.pop_stack_frame();\n-        self.substs_stack.pop();\n         Ok(())\n     }\n \n@@ -454,7 +459,8 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n     // TODO(tsion): Cache these outputs.\n     fn ty_to_repr(&self, ty: ty::Ty<'tcx>) -> Repr {\n         use syntax::ast::IntTy;\n-        let substs = self.substs_stack.last().unwrap();\n+        let substs = self.substs_stack.last().map(|&s| s)\n+            .unwrap_or_else(|| self.tcx.mk_substs(Substs::empty()));\n \n         match ty.subst(self.tcx, substs).sty {\n             ty::TyBool => Repr::Bool,\n@@ -509,6 +515,10 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n     fn current_frame(&self) -> &Frame<'a, 'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n+\n+    fn current_frame_mut(&mut self) -> &mut Frame<'a, 'tcx> {\n+        self.stack.last_mut().expect(\"no call frames exist\")\n+    }\n }\n \n pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>) {\n@@ -528,7 +538,8 @@ pub fn interpret_start_points<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>)\n                     }\n                     ty::FnDiverging => None,\n                 };\n-                miri.call(CachedMir::Ref(mir), &[], return_ptr).unwrap();\n+                miri.push_stack_frame(CachedMir::Ref(mir), &[], return_ptr).unwrap();\n+                miri.run().unwrap();\n \n                 if let Some(ret) = return_ptr {\n                     println!(\"Returned: {:?}\\n\", miri.memory.get(ret.alloc_id).unwrap());"}]}