{"sha": "3d59ac3a1989c2d233b04cc8adc9b058690c2544", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNTlhYzNhMTk4OWMyZDIzM2IwNGNjOGFkYzliMDU4NjkwYzI1NDQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-22T01:43:30Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-22T02:13:55Z"}, "message": "De-mode vec::map, vec::eachi, vec::rev_each, vec::rev_eachi", "tree": {"sha": "c23ae510c35a35277d2807f9761aa7135356243b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c23ae510c35a35277d2807f9761aa7135356243b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d59ac3a1989c2d233b04cc8adc9b058690c2544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d59ac3a1989c2d233b04cc8adc9b058690c2544", "html_url": "https://github.com/rust-lang/rust/commit/3d59ac3a1989c2d233b04cc8adc9b058690c2544", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d59ac3a1989c2d233b04cc8adc9b058690c2544/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3c31a07d742478babfc7cda9d21ea6173ac2f6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c31a07d742478babfc7cda9d21ea6173ac2f6d", "html_url": "https://github.com/rust-lang/rust/commit/f3c31a07d742478babfc7cda9d21ea6173ac2f6d"}], "stats": {"total": 835, "additions": 408, "deletions": 427}, "files": [{"sha": "4a01617c9ce600606c83852610e51569d3e32e6e", "filename": "doc/tutorial.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -426,7 +426,7 @@ annotation:\n ~~~~\n // The type of this vector will be inferred based on its use.\n let x = [];\n-# vec::map(x, fn&(&&_y:int) -> int { _y });\n+# vec::map(x, fn&(_y: &int) -> int { *_y });\n // Explicitly say this is a vector of zero integers.\n let y: [int * 0] = [];\n ~~~~\n@@ -1242,7 +1242,7 @@ for crayons.each |crayon| {\n }\n \n // Map vector elements\n-let crayon_names = crayons.map(|v| crayon_to_str(v));\n+let crayon_names = crayons.map(|v| crayon_to_str(*v));\n let favorite_crayon_name = crayon_names[0];\n \n // Remove whitespace from before and after the string\n@@ -1298,7 +1298,7 @@ access local variables in the enclosing scope.\n \n ~~~~\n let mut max = 0;\n-(~[1, 2, 3]).map(|x| if x > max { max = x });\n+(~[1, 2, 3]).map(|x| if *x > max { max = *x });\n ~~~~\n \n Stack closures are very efficient because their environment is"}, {"sha": "acb49051d638bbc41e9caca7ae3d0fa243a43502", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -195,17 +195,17 @@ fn is_uuid(id: ~str) -> bool {\n \n             match i {\n                 0u => {\n-                    if str::len(part) == 8u {\n+                    if part.len() == 8u {\n                         correct += 1u;\n                     }\n                 }\n                 1u | 2u | 3u => {\n-                    if str::len(part) == 4u {\n+                    if part.len() == 4u {\n                         correct += 1u;\n                     }\n                 }\n                 4u => {\n-                    if str::len(part) == 12u {\n+                    if part.len() == 12u {\n                         correct += 1u;\n                     }\n                 }"}, {"sha": "481b27c566e81f1ecaf62f3ab35c6095485f5dad", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -437,13 +437,12 @@ impl<T: Copy> DList<T> {\n     /// Get data at the list's tail, failing if empty. O(1).\n     pure fn tail() -> T { self.tail_n().data }\n     /// Get the elements of the list as a vector. O(n).\n-    pure fn to_vec() -> ~[mut T] {\n-        let mut v = ~[mut];\n+    pure fn to_vec() -> ~[T] {\n+        let mut v = vec::with_capacity(self.size);\n         unsafe {\n-            vec::reserve(v, self.size);\n             // Take this out of the unchecked when iter's functions are pure\n             for self.eachi |index,data| {\n-                v[index] = data;\n+                v[index] = *data;\n             }\n         }\n         move v"}, {"sha": "210ddd483e6430f0b4b3ea54345444c371fe3f5a", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -117,7 +117,7 @@ priv impl<A> DVec<A> {\n impl<A> DVec<A> {\n     /// Reserves space for N elements\n     fn reserve(count: uint) {\n-        vec::reserve(self.data, count)\n+        vec::reserve(&mut self.data, count)\n     }\n \n     /**\n@@ -243,7 +243,7 @@ impl<A: Copy> DVec<A> {\n         do self.swap |v| {\n             let mut v <- v;\n             let new_len = vec::len(v) + to_idx - from_idx;\n-            vec::reserve(v, new_len);\n+            vec::reserve(&mut v, new_len);\n             let mut i = from_idx;\n             while i < to_idx {\n                 vec::push(v, ts[i]);\n@@ -313,9 +313,9 @@ impl<A: Copy> DVec<A> {\n      */\n     fn grow_set_elt(idx: uint, initval: A, val: A) {\n         do self.swap |v| {\n-            let mut v = vec::to_mut(move v);\n+            let mut v = move v;\n             vec::grow_set(v, idx, initval, val);\n-            move vec::from_mut(v)\n+            move v\n         }\n     }\n \n@@ -334,14 +334,28 @@ impl<A: Copy> DVec<A> {\n \n     /// Iterates over the elements in reverse order\n     #[inline(always)]\n-    fn reach(f: fn(A) -> bool) {\n-        do self.swap |v| { vec::reach(v, f); move v }\n+    fn rev_each(f: fn(v: &A) -> bool) {\n+        do self.swap |v| {\n+            // FIXME(#2263)---we should be able to write\n+            // `vec::rev_each(v, f);` but we cannot write now\n+            for vec::rev_each(v) |e| {\n+                if !f(e) { break; }\n+            }\n+            move v\n+        }\n     }\n \n     /// Iterates over the elements and indices in reverse order\n     #[inline(always)]\n-    fn reachi(f: fn(uint, A) -> bool) {\n-        do self.swap |v| { vec::reachi(v, f); move v }\n+    fn rev_eachi(f: fn(uint, v: &A) -> bool) {\n+        do self.swap |v| {\n+            // FIXME(#2263)---we should be able to write\n+            // `vec::rev_eachi(v, f);` but we cannot write now\n+            for vec::rev_eachi(v) |i, e| {\n+                if !f(i, e) { break; }\n+            }\n+            move v\n+        }\n     }\n }\n "}, {"sha": "c4fd5678ac286c2b33be42a9c8585ff7e3b0e175", "filename": "src/libcore/io.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -52,14 +52,13 @@ trait ReaderUtil {\n \n impl<T: Reader> T : ReaderUtil {\n     fn read_bytes(len: uint) -> ~[u8] {\n-        let mut buf = ~[mut];\n-        vec::reserve(buf, len);\n+        let mut buf = vec::with_capacity(len);\n         unsafe { vec::raw::set_len(buf, len); }\n \n         let count = self.read(buf, len);\n \n         unsafe { vec::raw::set_len(buf, count); }\n-        vec::from_mut(move buf)\n+        move buf\n     }\n     fn read_line() -> ~str {\n         let mut buf = ~[];\n@@ -696,7 +695,7 @@ impl BytesWriter: Writer {\n             let buf_len = buf.len();\n \n             let count = uint::max(buf_len, self.pos + v_len);\n-            vec::reserve(buf, count);\n+            vec::reserve(&mut buf, count);\n             unsafe { vec::raw::set_len(buf, count); }\n \n             let view = vec::mut_view(buf, self.pos, count);\n@@ -910,7 +909,7 @@ mod tests {\n                     assert(vec::len(res) == len);\n                 }\n                 assert(vec::slice(ivals, 0u, vec::len(res)) ==\n-                       vec::map(res, |x| x as int));\n+                       vec::map(res, |x| *x as int));\n             }\n         }\n         let mut i = 0u;"}, {"sha": "b2bb53d395f5b7bc04e2f07788e4308d9f3e5c5b", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -12,7 +12,7 @@ impl<A> IMPL_T<A>: iter::BaseIter<A> {\n }\n \n impl<A> IMPL_T<A>: iter::ExtendedIter<A> {\n-    pure fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n+    pure fn eachi(blk: fn(uint, v: &A) -> bool) { iter::eachi(self, blk) }\n     pure fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n     pure fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n     pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B {\n@@ -32,7 +32,7 @@ impl<A: Copy> IMPL_T<A>: iter::CopyableIter<A> {\n     pure fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n-    pure fn map_to_vec<B>(op: fn(A) -> B) -> ~[B] {\n+    pure fn map_to_vec<B>(op: fn(v: &A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n     pure fn to_vec() -> ~[A] { iter::to_vec(self) }"}, {"sha": "c22d3c6e6645b01984850ad918689bc8de1fc6f2", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -15,7 +15,7 @@ trait BaseIter<A> {\n }\n \n trait ExtendedIter<A> {\n-    pure fn eachi(blk: fn(uint, A) -> bool);\n+    pure fn eachi(blk: fn(uint, v: &A) -> bool);\n     pure fn all(blk: fn(A) -> bool) -> bool;\n     pure fn any(blk: fn(A) -> bool) -> bool;\n     pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B;\n@@ -36,7 +36,7 @@ trait TimesIx{\n \n trait CopyableIter<A:Copy> {\n     pure fn filter_to_vec(pred: fn(A) -> bool) -> ~[A];\n-    pure fn map_to_vec<B>(op: fn(A) -> B) -> ~[B];\n+    pure fn map_to_vec<B>(op: fn(v: &A) -> B) -> ~[B];\n     pure fn to_vec() -> ~[A];\n     pure fn find(p: fn(A) -> bool) -> Option<A>;\n }\n@@ -66,10 +66,10 @@ trait Buildable<A> {\n                                 builder: fn(push: pure fn(+A))) -> self;\n }\n \n-pure fn eachi<A,IA:BaseIter<A>>(self: IA, blk: fn(uint, A) -> bool) {\n+pure fn eachi<A,IA:BaseIter<A>>(self: IA, blk: fn(uint, v: &A) -> bool) {\n     let mut i = 0u;\n     for self.each |a| {\n-        if !blk(i, *a) { break; }\n+        if !blk(i, a) { break; }\n         i += 1u;\n     }\n }\n@@ -97,11 +97,11 @@ pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(self: IA,\n     }\n }\n \n-pure fn map_to_vec<A:Copy,B,IA:BaseIter<A>>(self: IA, op: fn(A) -> B)\n+pure fn map_to_vec<A:Copy,B,IA:BaseIter<A>>(self: IA, op: fn(v: &A) -> B)\n     -> ~[B] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n-            push(op(*a));\n+            push(op(a));\n         }\n     }\n }"}, {"sha": "3543471ea68a06061a8007138907c474cd0ed336", "filename": "src/libcore/os.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -637,7 +637,7 @@ fn list_dir(p: &Path) -> ~[~str] {\n  * This version prepends each entry with the directory.\n  */\n fn list_dir_path(p: &Path) -> ~[~Path] {\n-    os::list_dir(p).map(|f| ~p.push(f))\n+    os::list_dir(p).map(|f| ~p.push(*f))\n }\n \n /// Removes a directory at the specified path\n@@ -721,9 +721,8 @@ fn copy_file(from: &Path, to: &Path) -> bool {\n             fclose(istream);\n             return false;\n         }\n-        let mut buf : ~[mut u8] = ~[mut];\n         let bufsize = 8192u;\n-        vec::reserve(buf, bufsize);\n+        let mut buf = vec::with_capacity::<u8>(bufsize);\n         let mut done = false;\n         let mut ok = true;\n         while !done {"}, {"sha": "720110c0e10fe96346e8fc89e3bcd656c222c6f3", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -269,8 +269,7 @@ impl<T: Copy, E: Copy> Result<T, E> {\n fn map_vec<T,U:Copy,V:Copy>(\n     ts: &[T], op: fn((&T)) -> Result<V,U>) -> Result<~[V],U> {\n \n-    let mut vs: ~[V] = ~[];\n-    vec::reserve(vs, vec::len(ts));\n+    let mut vs: ~[V] = vec::with_capacity(vec::len(ts));\n     for vec::each(ts) |t| {\n         match op(t) {\n           Ok(v) => vec::push(vs, v),\n@@ -306,8 +305,7 @@ fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n \n     assert vec::same_length(ss, ts);\n     let n = vec::len(ts);\n-    let mut vs = ~[];\n-    vec::reserve(vs, n);\n+    let mut vs = vec::with_capacity(n);\n     let mut i = 0u;\n     while i < n {\n         match op(ss[i],ts[i]) {"}, {"sha": "bc0a321360efb7efeadea1362740fad61650618a", "filename": "src/libcore/str.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -669,8 +669,8 @@ pure fn lines(s: &str) -> ~[~str] { split_char(s, '\\n') }\n  */\n pure fn lines_any(s: &str) -> ~[~str] {\n     vec::map(lines(s), |s| {\n-        let l = len(s);\n-        let mut cp = copy s;\n+        let l = len(*s);\n+        let mut cp = copy *s;\n         if l > 0u && s[l - 1u] == '\\r' as u8 {\n             unsafe { raw::set_len(&mut cp, l - 1u); }\n         }\n@@ -1984,7 +1984,7 @@ pure fn as_buf<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n fn reserve(s: &const ~str, n: uint) {\n     unsafe {\n         let v: *mut ~[u8] = cast::transmute(copy s);\n-        vec::reserve(*v, n + 1);\n+        vec::reserve(&mut *v, n + 1);\n     }\n }\n \n@@ -2077,10 +2077,8 @@ mod raw {\n \n     /// Create a Rust string from a *u8 buffer of the given length\n     unsafe fn from_buf_len(buf: *const u8, len: uint) -> ~str {\n-        let mut v: ~[mut u8] = ~[mut];\n-        vec::reserve(v, len + 1u);\n-        vec::as_imm_buf(v, |vbuf, _len| {\n-            let vbuf = ::cast::transmute_mut_unsafe(vbuf);\n+        let mut v: ~[u8] = vec::with_capacity(len + 1);\n+        vec::as_mut_buf(v, |vbuf, _len| {\n             ptr::memcpy(vbuf, buf as *u8, len)\n         });\n         vec::raw::set_len(v, len);\n@@ -2132,8 +2130,7 @@ mod raw {\n             assert (begin <= end);\n             assert (end <= n);\n \n-            let mut v = ~[];\n-            vec::reserve(v, end - begin + 1u);\n+            let mut v = vec::with_capacity(end - begin + 1u);\n             unsafe {\n                 do vec::as_imm_buf(v) |vbuf, _vlen| {\n                     let vbuf = ::cast::transmute_mut_unsafe(vbuf);"}, {"sha": "1e3d0530fb3a6ad2329778797a61669b9167f3bd", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 93, "deletions": 117, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -19,6 +19,7 @@ export len;\n export from_fn;\n export from_elem;\n export from_slice;\n+export with_capacity;\n export build, build_sized, build_sized_opt;\n export to_mut;\n export from_mut;\n@@ -76,7 +77,7 @@ export zip, zip_slice;\n export swap;\n export reverse;\n export reversed;\n-export each, each_mut, each_const, eachi, reach, reachi;\n+export each, each_mut, each_const, eachi, rev_each, rev_eachi;\n export iter2;\n export permute;\n export windowed;\n@@ -135,12 +136,14 @@ pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n  * * v - A vector\n  * * n - The number of elements to reserve space for\n  */\n-fn reserve<T>(&v: ~[const T], n: uint) {\n+fn reserve<T>(+v: &mut ~[T], +n: uint) {\n     // Only make the (slow) call into the runtime if we have to\n-    if capacity(v) < n {\n-        let ptr = ptr::addr_of(v) as **raw::VecRepr;\n-        rustrt::vec_reserve_shared(sys::get_type_desc::<T>(),\n-                                   ptr, n as size_t);\n+    if capacity(*v) < n {\n+        unsafe {\n+            let ptr: **raw::VecRepr = cast::transmute(v);\n+            rustrt::vec_reserve_shared(sys::get_type_desc::<T>(),\n+                                       ptr, n as size_t);\n+        }\n     }\n }\n \n@@ -159,7 +162,7 @@ fn reserve<T>(&v: ~[const T], n: uint) {\n  * * v - A vector\n  * * n - The number of elements to reserve space for\n  */\n-fn reserve_at_least<T>(&v: ~[const T], n: uint) {\n+fn reserve_at_least<T>(v: &mut ~[T], n: uint) {\n     reserve(v, uint::next_power_of_two(n));\n }\n \n@@ -185,8 +188,7 @@ pure fn len<T>(&&v: &[const T]) -> uint {\n  * to the value returned by the function `op`.\n  */\n pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n-    let mut v = ~[];\n-    unsafe{reserve(v, n_elts);}\n+    let mut v = with_capacity(n_elts);\n     let mut i: uint = 0u;\n     while i < n_elts unsafe { raw::set(v, i, op(i)); i += 1u; }\n     unsafe { raw::set_len(v, n_elts); }\n@@ -200,8 +202,7 @@ pure fn from_fn<T>(n_elts: uint, op: iter::InitOp<T>) -> ~[T] {\n  * to the value `t`.\n  */\n pure fn from_elem<T: Copy>(n_elts: uint, t: T) -> ~[T] {\n-    let mut v = ~[];\n-    unsafe{reserve(v, n_elts)}\n+    let mut v = with_capacity(n_elts);\n     let mut i: uint = 0u;\n     unsafe { // because unsafe::set is unsafe\n         while i < n_elts { raw::set(v, i, t); i += 1u; }\n@@ -215,6 +216,12 @@ pure fn from_slice<T: Copy>(t: &[T]) -> ~[T] {\n     from_fn(t.len(), |i| t[i])\n }\n \n+pure fn with_capacity<T>(capacity: uint) -> ~[T] {\n+    let mut vec = ~[];\n+    unsafe { reserve(&mut vec, capacity); }\n+    return move vec;\n+}\n+\n /**\n  * Builds a vector by calling a provided function with an argument\n  * function that pushes an element to the back of a vector.\n@@ -229,8 +236,7 @@ pure fn from_slice<T: Copy>(t: &[T]) -> ~[T] {\n  */\n #[inline(always)]\n pure fn build_sized<A>(size: uint, builder: fn(push: pure fn(+A))) -> ~[A] {\n-    let mut vec = ~[];\n-    unsafe { reserve(vec, size); }\n+    let mut vec = with_capacity(size);\n     builder(|+x| unsafe { push(vec, move x) });\n     move vec\n }\n@@ -422,7 +428,7 @@ fn rsplit<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     if (ln == 0u) { return ~[] }\n \n     let mut end = ln;\n-    let mut result = ~[mut ];\n+    let mut result = ~[];\n     while end > 0u {\n         match rposition_between(v, 0u, end, f) {\n           None => break,\n@@ -434,7 +440,7 @@ fn rsplit<T: Copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     }\n     push(result, slice(v, 0u, end));\n     reverse(result);\n-    return from_mut(move result);\n+    return move result;\n }\n \n /**\n@@ -447,7 +453,7 @@ fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n \n     let mut end = ln;\n     let mut count = n;\n-    let mut result = ~[mut ];\n+    let mut result = ~[];\n     while end > 0u && count > 0u {\n         match rposition_between(v, 0u, end, f) {\n           None => break,\n@@ -461,7 +467,7 @@ fn rsplitn<T: Copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     }\n     push(result, slice(v, 0u, end));\n     reverse(result);\n-    move from_mut(move result)\n+    move result\n }\n \n // Mutators\n@@ -561,7 +567,7 @@ fn swap_remove<T>(&v: ~[const T], index: uint) -> T {\n \n /// Append an element to a vector\n #[inline(always)]\n-fn push<T>(&v: ~[const T], +initval: T) {\n+fn push<T>(&v: ~[T], +initval: T) {\n     unsafe {\n         let repr: **raw::VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n         let fill = (**repr).unboxed.fill;\n@@ -576,7 +582,7 @@ fn push<T>(&v: ~[const T], +initval: T) {\n \n // This doesn't bother to make sure we have space.\n #[inline(always)] // really pretty please\n-unsafe fn push_fast<T>(&v: ~[const T], +initval: T) {\n+unsafe fn push_fast<T>(&v: ~[T], +initval: T) {\n     let repr: **raw::VecRepr = ::cast::reinterpret_cast(&addr_of(v));\n     let fill = (**repr).unboxed.fill;\n     (**repr).unboxed.fill += sys::size_of::<T>();\n@@ -586,23 +592,23 @@ unsafe fn push_fast<T>(&v: ~[const T], +initval: T) {\n }\n \n #[inline(never)]\n-fn push_slow<T>(&v: ~[const T], +initval: T) {\n-    reserve_at_least(v, v.len() + 1u);\n+fn push_slow<T>(&v: ~[T], +initval: T) {\n+    reserve_at_least(&mut v, v.len() + 1u);\n     unsafe { push_fast(v, move initval) }\n }\n \n #[inline(always)]\n-fn push_all<T: Copy>(&v: ~[const T], rhs: &[const T]) {\n-    reserve(v, v.len() + rhs.len());\n+fn push_all<T: Copy>(&v: ~[T], rhs: &[const T]) {\n+    reserve(&mut v, v.len() + rhs.len());\n \n     for uint::range(0u, rhs.len()) |i| {\n         push(v, unsafe { raw::get(rhs, i) })\n     }\n }\n \n #[inline(always)]\n-fn push_all_move<T>(&v: ~[const T], -rhs: ~[const T]) {\n-    reserve(v, v.len() + rhs.len());\n+fn push_all_move<T>(&v: ~[T], -rhs: ~[const T]) {\n+    reserve(&mut v, v.len() + rhs.len());\n     unsafe {\n         do as_imm_buf(rhs) |p, len| {\n             for uint::range(0, len) |i| {\n@@ -681,23 +687,8 @@ pure fn append_one<T>(+lhs: ~[T], +x: T) -> ~[T] {\n }\n \n #[inline(always)]\n-pure fn append_mut<T: Copy>(lhs: &[mut T], rhs: &[const T]) -> ~[mut T] {\n-    let mut v = ~[mut];\n-    let mut i = 0u;\n-    while i < lhs.len() {\n-        unsafe { // This is impure, but it appears pure to the caller.\n-            push(v, lhs[i]);\n-        }\n-        i += 1u;\n-    }\n-    i = 0u;\n-    while i < rhs.len() {\n-        unsafe { // This is impure, but it appears pure to the caller.\n-            push(v, rhs[i]);\n-        }\n-        i += 1u;\n-    }\n-    move v\n+pure fn append_mut<T: Copy>(+lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n+    to_mut(append(from_mut(lhs), rhs))\n }\n \n /**\n@@ -709,8 +700,8 @@ pure fn append_mut<T: Copy>(lhs: &[mut T], rhs: &[const T]) -> ~[mut T] {\n  * * n - The number of elements to add\n  * * initval - The value for the new elements\n  */\n-fn grow<T: Copy>(&v: ~[const T], n: uint, initval: T) {\n-    reserve_at_least(v, len(v) + n);\n+fn grow<T: Copy>(&v: ~[T], n: uint, initval: T) {\n+    reserve_at_least(&mut v, len(v) + n);\n     let mut i: uint = 0u;\n \n     while i < n { push(v, initval); i += 1u; }\n@@ -729,8 +720,8 @@ fn grow<T: Copy>(&v: ~[const T], n: uint, initval: T) {\n  * * init_op - A function to call to retreive each appended element's\n  *             value\n  */\n-fn grow_fn<T>(&v: ~[const T], n: uint, op: iter::InitOp<T>) {\n-    reserve_at_least(v, len(v) + n);\n+fn grow_fn<T>(&v: ~[T], n: uint, op: iter::InitOp<T>) {\n+    reserve_at_least(&mut v, len(v) + n);\n     let mut i: uint = 0u;\n     while i < n { push(v, op(i)); i += 1u; }\n }\n@@ -743,18 +734,17 @@ fn grow_fn<T>(&v: ~[const T], n: uint, op: iter::InitOp<T>) {\n  * of the vector, expands the vector by replicating `initval` to fill the\n  * intervening space.\n  */\n-fn grow_set<T: Copy>(&v: ~[mut T], index: uint, initval: T, val: T) {\n+fn grow_set<T: Copy>(&v: ~[T], index: uint, initval: T, val: T) {\n     if index >= len(v) { grow(v, index - len(v) + 1u, initval); }\n     v[index] = val;\n }\n \n // Functional utilities\n \n /// Apply a function to each element of a vector and return the results\n-pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> ~[U] {\n-    let mut result = ~[];\n-    unsafe{reserve(result, len(v));}\n-    for each(v) |elem| { unsafe { push(result, f(*elem)); } }\n+pure fn map<T, U>(v: &[T], f: fn(v: &T) -> U) -> ~[U] {\n+    let mut result = with_capacity(len(v));\n+    for each(v) |elem| { unsafe { push(result, f(elem)); } }\n     move result\n }\n \n@@ -767,11 +757,12 @@ fn map_consume<T, U>(+v: ~[T], f: fn(+T) -> U) -> ~[U] {\n }\n \n /// Apply a function to each element of a vector and return the results\n-pure fn mapi<T, U>(v: &[T], f: fn(uint, T) -> U) -> ~[U] {\n-    let mut result = ~[];\n-    unsafe{reserve(result, len(v));}\n-    for eachi(v) |i, elem| { unsafe { push(result, f(i, elem)); } }\n-    move result\n+pure fn mapi<T, U>(v: &[T], f: fn(uint, v: &T) -> U) -> ~[U] {\n+    let mut i = 0;\n+    do map(v) |e| {\n+        i += 1;\n+        f(i - 1, e)\n+    }\n }\n \n /**\n@@ -865,8 +856,8 @@ pure fn foldl<T: Copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n /// Reduce a vector from right to left\n pure fn foldr<T, U: Copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n     let mut accum = z;\n-    for reach(v) |elt| {\n-        accum = p(elt, accum);\n+    for rev_each(v) |elt| {\n+        accum = p(*elt, accum);\n     }\n     return accum;\n }\n@@ -914,7 +905,7 @@ pure fn all<T>(v: &[T], f: fn(T) -> bool) -> bool {\n  * If the vector contains no elements then true is returned.\n  */\n pure fn alli<T>(v: &[T], f: fn(uint, T) -> bool) -> bool {\n-    for eachi(v) |i, elem| { if !f(i, elem) { return false; } }\n+    for eachi(v) |i, elem| { if !f(i, *elem) { return false; } }\n     return true;\n }\n \n@@ -1120,13 +1111,13 @@ pure fn zip_slice<T: Copy, U: Copy>(v: &[const T], u: &[const U])\n pure fn zip<T, U>(+v: ~[const T], +u: ~[const U]) -> ~[(T, U)] {\n     let mut v = move v, u = move u, i = len(v);\n     assert i == len(u);\n-    let mut w = ~[mut];\n+    let mut w = with_capacity(i);\n     while i > 0 {\n         unsafe { push(w, (pop(v),pop(u))); }\n         i -= 1;\n     }\n     unsafe { reverse(w); }\n-    from_mut(move w)\n+    move w\n }\n \n /**\n@@ -1222,17 +1213,11 @@ pure fn each_const<T>(v: &[const T], f: fn(elem: &const T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn eachi<T>(v: &[T], f: fn(uint, T) -> bool) {\n-    do vec::as_imm_buf(v) |p, n| {\n-        let mut i = 0u;\n-        let mut p = p;\n-        while i < n {\n-            unsafe {\n-                if !f(i, *p) { break; }\n-                p = ptr::offset(p, 1u);\n-            }\n-            i += 1u;\n-        }\n+pure fn eachi<T>(v: &r/[T], f: fn(uint, v: &r/T) -> bool) {\n+    let mut i = 0;\n+    for each(v) |p| {\n+        if !f(i, p) { return; }\n+        i += 1;\n     }\n }\n \n@@ -1242,16 +1227,8 @@ pure fn eachi<T>(v: &[T], f: fn(uint, T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn reach<T>(v: &[T], blk: fn(T) -> bool) {\n-    do vec::as_imm_buf(v) |p, n| {\n-        let mut i = 1;\n-        while i <= n {\n-            unsafe {\n-                if !blk(*ptr::offset(p, n-i)) { break; }\n-            }\n-            i += 1;\n-        }\n-    }\n+pure fn rev_each<T>(v: &r/[T], blk: fn(v: &r/T) -> bool) {\n+    rev_eachi(v, |_i, v| blk(v))\n }\n \n /**\n@@ -1260,14 +1237,12 @@ pure fn reach<T>(v: &[T], blk: fn(T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn reachi<T>(v: &[T], blk: fn(uint, T) -> bool) {\n-    do vec::as_imm_buf(v) |p, n| {\n-        let mut i = 1;\n-        while i <= n {\n-            unsafe {\n-                if !blk(n-i, *ptr::offset(p, n-i)) { break; }\n-            }\n-            i += 1;\n+pure fn rev_eachi<T>(v: &r/[T], blk: fn(i: uint, v: &r/T) -> bool) {\n+    let mut i = v.len();\n+    while i > 0 {\n+        i -= 1;\n+        if !blk(i, &v[i]) {\n+            return;\n         }\n     }\n }\n@@ -1559,15 +1534,16 @@ mod traits {\n     impl<T: Copy> ~[mut T]: Add<&[const T],~[mut T]> {\n         #[inline(always)]\n         pure fn add(rhs: &[const T]) -> ~[mut T] {\n-            append_mut(self, rhs)\n+            append_mut(copy self, rhs)\n         }\n     }\n+\n     #[cfg(stage1)]\n     #[cfg(stage2)]\n     impl<T: Copy> ~[mut T] : Add<&[const T],~[mut T]> {\n         #[inline(always)]\n         pure fn add(rhs: & &[const T]) -> ~[mut T] {\n-            append_mut(self, (*rhs))\n+            append_mut(copy self, (*rhs))\n         }\n     }\n }\n@@ -1624,8 +1600,8 @@ impl<T: Copy> &[const T]: CopyableVector<T> {\n \n trait ImmutableVector<T> {\n     pure fn foldr<U: Copy>(z: U, p: fn(T, U) -> U) -> U;\n-    pure fn map<U>(f: fn(T) -> U) -> ~[U];\n-    pure fn mapi<U>(f: fn(uint, T) -> U) -> ~[U];\n+    pure fn map<U>(f: fn(v: &T) -> U) -> ~[U];\n+    pure fn mapi<U>(f: fn(uint, v: &T) -> U) -> ~[U];\n     fn map_r<U>(f: fn(x: &T) -> U) -> ~[U];\n     pure fn alli(f: fn(uint, T) -> bool) -> bool;\n     pure fn flat_map<U>(f: fn(T) -> ~[U]) -> ~[U];\n@@ -1646,12 +1622,12 @@ impl<T> &[T]: ImmutableVector<T> {\n     pure fn foldr<U: Copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n     /// Apply a function to each element of a vector and return the results\n     #[inline]\n-    pure fn map<U>(f: fn(T) -> U) -> ~[U] { map(self, f) }\n+    pure fn map<U>(f: fn(v: &T) -> U) -> ~[U] { map(self, f) }\n     /**\n      * Apply a function to the index and value of each element in the vector\n      * and return the results\n      */\n-    pure fn mapi<U>(f: fn(uint, T) -> U) -> ~[U] {\n+    pure fn mapi<U>(f: fn(uint, v: &T) -> U) -> ~[U] {\n         mapi(self, f)\n     }\n \n@@ -1779,8 +1755,7 @@ mod raw {\n      */\n     #[inline(always)]\n     unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n-        let mut dst = ~[];\n-        reserve(dst, elts);\n+        let mut dst = with_capacity(elts);\n         set_len(dst, elts);\n         as_mut_buf(dst, |p_dst, _len_dst| ptr::memcpy(p_dst, ptr, elts));\n         move dst\n@@ -1972,6 +1947,7 @@ mod bytes {\n \n impl<A> &[A]: iter::BaseIter<A> {\n     pure fn each(blk: fn(v: &A) -> bool) {\n+        // FIXME(#2263)---should be able to call each(self, blk)\n         for each(self) |e| {\n             if (!blk(e)) {\n                 return;\n@@ -1982,7 +1958,7 @@ impl<A> &[A]: iter::BaseIter<A> {\n }\n \n impl<A> &[A]: iter::ExtendedIter<A> {\n-    pure fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n+    pure fn eachi(blk: fn(uint, v: &A) -> bool) { iter::eachi(self, blk) }\n     pure fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n     pure fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n     pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B {\n@@ -2002,7 +1978,7 @@ impl<A: Copy> &[A]: iter::CopyableIter<A> {\n     pure fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }\n-    pure fn map_to_vec<B>(op: fn(A) -> B) -> ~[B] {\n+    pure fn map_to_vec<B>(op: fn(v: &A) -> B) -> ~[B] {\n         iter::map_to_vec(self, op)\n     }\n     pure fn to_vec() -> ~[A] { iter::to_vec(self) }\n@@ -2027,7 +2003,7 @@ mod tests {\n \n     fn square(n: uint) -> uint { return n * n; }\n \n-    fn square_ref(&&n: uint) -> uint { return n * n; }\n+    fn square_ref(n: &uint) -> uint { return square(*n); }\n \n     pure fn is_three(&&n: uint) -> bool { return n == 3u; }\n \n@@ -2260,7 +2236,7 @@ mod tests {\n \n     #[test]\n     fn test_grow_set() {\n-        let mut v = ~[mut 1, 2, 3];\n+        let mut v = ~[1, 2, 3];\n         grow_set(v, 4u, 4, 5);\n         assert (len(v) == 5u);\n         assert (v[0] == 1);\n@@ -2378,7 +2354,7 @@ mod tests {\n                 return option::Some::<int>(i / 2);\n             } else { return option::None::<int>; }\n         }\n-        fn halve_for_sure(&&i: int) -> int { return i / 2; }\n+        fn halve_for_sure(i: &int) -> int { return *i / 2; }\n         let all_even: ~[int] = ~[0, 2, 8, 6];\n         let all_odd1: ~[int] = ~[1, 7, 3];\n         let all_odd2: ~[int] = ~[];\n@@ -2449,37 +2425,37 @@ mod tests {\n     fn test_iteri() {\n         let mut i = 0;\n         for eachi(~[1, 2, 3]) |j, v| {\n-            if i == 0 { assert v == 1; }\n-            assert j + 1u == v as uint;\n-            i += v;\n+            if i == 0 { assert *v == 1; }\n+            assert j + 1u == *v as uint;\n+            i += *v;\n         }\n         assert i == 6;\n     }\n \n     #[test]\n     fn test_reach_empty() {\n-        for reach::<int>(~[]) |_v| {\n+        for rev_each::<int>(~[]) |_v| {\n             fail; // should never execute\n         }\n     }\n \n     #[test]\n-    fn test_riter_nonempty() {\n+    fn test_reach_nonempty() {\n         let mut i = 0;\n-        for reach(~[1, 2, 3]) |v| {\n-            if i == 0 { assert v == 3; }\n-            i += v\n+        for rev_each(~[1, 2, 3]) |v| {\n+            if i == 0 { assert *v == 3; }\n+            i += *v\n         }\n         assert i == 6;\n     }\n \n     #[test]\n     fn test_reachi() {\n         let mut i = 0;\n-        for reachi(~[0, 1, 2]) |j, v| {\n-            if i == 0 { assert v == 2; }\n-            assert j == v as uint;\n-            i += v;\n+        for rev_eachi(~[0, 1, 2]) |j, v| {\n+            if i == 0 { assert *v == 2; }\n+            assert j == *v as uint;\n+            i += *v;\n         }\n         assert i == 3;\n     }\n@@ -2869,10 +2845,10 @@ mod tests {\n     #[test]\n     fn test_capacity() {\n         let mut v = ~[0u64];\n-        reserve(v, 10u);\n+        reserve(&mut v, 10u);\n         assert capacity(v) == 10u;\n         let mut v = ~[0u32];\n-        reserve(v, 10u);\n+        reserve(&mut v, 10u);\n         assert capacity(v) == 10u;\n     }\n "}, {"sha": "0da23db7291f7d2ab4c0085a11d7124b1c749db2", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -79,8 +79,7 @@ impl ~[u8]: FromBase64 {\n             if self[len - 2u] == '=' as u8 { padding += 1u; }\n         }\n \n-        let mut r = ~[];\n-        vec::reserve(r, (len / 4u) * 3u - padding);\n+        let mut r = vec::with_capacity((len / 4u) * 3u - padding);\n \n         let mut i = 0u;\n         while i < len {"}, {"sha": "05875636415a837a1c2ac793f0abe1a8621e8381", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -28,11 +28,11 @@ fn create<T: Copy>() -> Deque<T> {\n       * Grow is only called on full elts, so nelts is also len(elts), unlike\n       * elsewhere.\n       */\n-    fn grow<T: Copy>(nelts: uint, lo: uint, +elts: ~[mut Cell<T>])\n-      -> ~[mut Cell<T>] {\n-        let elts = move elts;\n+    fn grow<T: Copy>(nelts: uint, lo: uint, +elts: ~[Cell<T>])\n+      -> ~[Cell<T>] {\n+        let mut elts = move elts;\n         assert (nelts == vec::len(elts));\n-        let mut rv = ~[mut];\n+        let mut rv = ~[];\n \n         let mut i = 0u;\n         let nalloc = uint::next_power_of_two(nelts + 1u);\n@@ -62,7 +62,7 @@ fn create<T: Copy>() -> Deque<T> {\n                 self.lo = self.elts.len() - 1u;\n             } else { self.lo -= 1u; }\n             if self.lo == self.hi {\n-                self.elts.swap_mut(|v| grow(self.nelts, oldlo, move v));\n+                self.elts.swap(|v| grow(self.nelts, oldlo, move v));\n                 self.lo = self.elts.len() - 1u;\n                 self.hi = self.nelts;\n             }\n@@ -71,7 +71,7 @@ fn create<T: Copy>() -> Deque<T> {\n         }\n         fn add_back(t: T) {\n             if self.lo == self.hi && self.nelts != 0u {\n-                self.elts.swap_mut(|v| grow(self.nelts, self.lo, move v));\n+                self.elts.swap(|v| grow(self.nelts, self.lo, move v));\n                 self.lo = 0u;\n                 self.hi = self.nelts;\n             }"}, {"sha": "f28d7694b20601286d3f4abd9b2d2d349375169e", "filename": "src/libstd/map.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -391,13 +391,11 @@ fn set_add<K:Eq IterBytes Hash Const Copy>(set: Set<K>, +key: K) -> bool {\n \n /// Convert a set into a vector.\n fn vec_from_set<T:Eq IterBytes Hash Copy>(s: Set<T>) -> ~[T] {\n-    let mut v = ~[];\n-    vec::reserve(v, s.size());\n-    do s.each_key() |k| {\n-        vec::push(v, k);\n-        true\n-    };\n-    v\n+    do vec::build_sized(s.size()) |push| {\n+        for s.each_key() |k| {\n+            push(k);\n+        }\n+    }\n }\n \n /// Construct a hashmap from a vector"}, {"sha": "3e104e259b8e2e370a0375c1dfab13cad8914d19", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -156,7 +156,7 @@ mod v4 {\n     }\n     fn parse_to_ipv4_rep(ip: &str) -> result::Result<Ipv4Rep, ~str> {\n         let parts = vec::map(str::split_char(ip, '.'), |s| {\n-            match uint::from_str(s) {\n+            match uint::from_str(*s) {\n               Some(n) if n <= 255u => n,\n               _ => 256u\n             }"}, {"sha": "38a814b22e0409da1e82216bb3d572f8dc4b4baa", "filename": "src/libstd/par.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -76,7 +76,7 @@ fn map_slices<A: Copy Send, B: Copy Send>(\n fn map<A: Copy Send, B: Copy Send>(xs: ~[A], f: fn~(A) -> B) -> ~[B] {\n     vec::concat(map_slices(xs, || {\n         fn~(_base: uint, slice : &[A], copy f) -> ~[B] {\n-            vec::map(slice, |x| f(x))\n+            vec::map(slice, |x| f(*x))\n         }\n     }))\n }\n@@ -87,7 +87,7 @@ fn mapi<A: Copy Send, B: Copy Send>(xs: ~[A],\n     let slices = map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> ~[B] {\n             vec::mapi(slice, |i, x| {\n-                f(i + base, x)\n+                f(i + base, *x)\n             })\n         }\n     });\n@@ -109,7 +109,7 @@ fn mapi_factory<A: Copy Send, B: Copy Send>(\n         let f = f();\n         fn~(base: uint, slice : &[A], move f) -> ~[B] {\n             vec::mapi(slice, |i, x| {\n-                f(i + base, x)\n+                f(i + base, *x)\n             })\n         }\n     });"}, {"sha": "2d49ede3507ff98ae10b99108e7db183e4280177", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -864,7 +864,7 @@ mod node {\n     fn bal(node: @Node) -> Option<@Node> {\n         if height(node) < hint_max_node_height { return option::None; }\n         //1. Gather all leaves as a forest\n-        let mut forest = ~[mut];\n+        let mut forest = ~[];\n         let it = leaf_iterator::start(node);\n         loop {\n             match (leaf_iterator::next(&it)) {"}, {"sha": "af581ba49581f7d78b8d36989fec02d40ffa901d", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -85,7 +85,7 @@ fn emit_from_vec<S: Serializer, T>(s: S, v: ~[T], f: fn(T)) {\n     do s.emit_vec(vec::len(v)) {\n         for vec::eachi(v) |i,e| {\n             do s.emit_vec_elt(i) {\n-                f(e)\n+                f(*e)\n             }\n         }\n     }"}, {"sha": "46f79c01948626a9c0385e17b6e8b9ed0f07ff06", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -40,8 +40,7 @@ fn merge_sort<T: Copy>(le: Le<T>, v: &[const T]) -> ~[T] {\n     }\n \n     fn merge<T: Copy>(le: Le<T>, a: &[T], b: &[T]) -> ~[T] {\n-        let mut rs = ~[];\n-        vec::reserve(rs, len(a) + len(b));\n+        let mut rs = vec::with_capacity(len(a) + len(b));\n         let a_len = len(a);\n         let mut a_ix = 0u;\n         let b_len = len(b);"}, {"sha": "0fd80d4acf489310a4f57c1dad476b80905ed465", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -80,11 +80,11 @@ fn new_sem<Q: Send>(count: int, +q: Q) -> Sem<Q> {\n #[doc(hidden)]\n fn new_sem_and_signal(count: int, num_condvars: uint)\n         -> Sem<~[mut Waitqueue]> {\n-    let mut queues = ~[mut];\n+    let mut queues = ~[];\n     for num_condvars.times {\n         vec::push(queues, new_waitqueue());\n     }\n-    new_sem(count, move queues)\n+    new_sem(count, vec::to_mut(move queues))\n }\n \n #[doc(hidden)]"}, {"sha": "85de1e1c60f042bdc86f7115c868344dd8875a60", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -58,7 +58,7 @@ type path = ~[path_elt];\n /* FIXMEs that say \"bad\" are as per #2543 */\n fn path_to_str_with_sep(p: path, sep: ~str, itr: ident_interner) -> ~str {\n     let strs = do vec::map(p) |e| {\n-        match e {\n+        match *e {\n           path_mod(s) => *itr.get(s),\n           path_name(s) => *itr.get(s)\n         }"}, {"sha": "b0df0ea1c8d013908f86135910f7d77a017bbfc7", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -25,7 +25,7 @@ pure fn dummy_sp() -> span { return mk_sp(0u, 0u); }\n \n pure fn path_name_i(idents: ~[ident], intr: token::ident_interner) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    str::connect(idents.map(|i| *intr.get(i)), ~\"::\")\n+    str::connect(idents.map(|i| *intr.get(*i)), ~\"::\")\n }\n \n "}, {"sha": "a710b558594e04277724704c8fe1c0cb4d1eb715", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -95,14 +95,14 @@ fn attr_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n     return mitems;\n }\n \n-fn desugar_doc_attr(attr: ast::attribute) -> ast::attribute {\n+fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {\n     if attr.node.is_sugared_doc {\n         let comment = get_meta_item_value_str(@attr.node.value).get();\n         let meta = mk_name_value_item_str(~\"doc\",\n                                      strip_doc_comment_decoration(comment));\n         return mk_attr(meta);\n     } else {\n-        attr\n+        *attr\n     }\n }\n "}, {"sha": "5e99314712fb154bc47eb8d6867814dca9df438c", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -183,7 +183,7 @@ impl ext_ctxt: ext_ctxt_helpers {\n              -output: @ast::ty) -> @ast::ty {\n         let args = do vec::map(input_tys) |ty| {\n             {mode: ast::expl(ast::by_ref),\n-             ty: ty,\n+             ty: *ty,\n              ident: parse::token::special_idents::invalid,\n              id: self.next_id()}\n         };\n@@ -333,7 +333,7 @@ fn ser_path(cx: ext_ctxt, tps: ser_tps_map, path: @ast::path,\n                 cx.helper_path(path, ~\"serialize\")));\n \n     let ty_args = do vec::map(path.types) |ty| {\n-        let sv_stmts = ser_ty(cx, tps, ty, cx.clone(s), #ast{ __v });\n+        let sv_stmts = ser_ty(cx, tps, *ty, cx.clone(s), #ast{ __v });\n         let sv = cx.expr(path.span,\n                          ast::expr_block(cx.blk(path.span, sv_stmts)));\n         cx.at(ty.span, #ast{ |__v| $(sv) })\n@@ -588,7 +588,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n         vec::append(~[{ident: cx.ident_of(~\"__S\"),\n                       id: cx.next_id(),\n                       bounds: ser_bnds}],\n-                    vec::map(tps, |tp| cx.clone_ty_param(tp)));\n+                    vec::map(tps, |tp| cx.clone_ty_param(*tp)));\n \n     let ser_output: @ast::ty = @{id: cx.next_id(),\n                                  node: ast::ty_nil,\n@@ -624,7 +624,7 @@ fn deser_path(cx: ext_ctxt, tps: deser_tps_map, path: @ast::path,\n                 cx.helper_path(path, ~\"deserialize\")));\n \n     let ty_args = do vec::map(path.types) |ty| {\n-        let dv_expr = deser_ty(cx, tps, ty, cx.clone(d));\n+        let dv_expr = deser_ty(cx, tps, *ty, cx.clone(d));\n         cx.lambda(cx.expr_blk(dv_expr))\n     };\n \n@@ -795,7 +795,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n                       id: cx.next_id(),\n                       bounds: deser_bnds}],\n                     vec::map(tps, |tp| {\n-                        let cloned = cx.clone_ty_param(tp);\n+                        let cloned = cx.clone_ty_param(*tp);\n                         {bounds: @(vec::append(*cloned.bounds,\n                                                ~[ast::bound_copy])),\n                          .. cloned}"}, {"sha": "a3ab35d77f0e85031e869c327a3a94a3f46fba94", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -320,7 +320,7 @@ fn tt_args_to_original_flavor(cx: ext_ctxt, sp: span, arg: ~[ast::token_tree])\n                           argument_gram).get(arg_nm) {\n           @matched_seq(s, _) => {\n             do s.map() |lf| {\n-                match lf {\n+                match *lf {\n                   @matched_nonterminal(parse::token::nt_expr(arg)) =>\n                     arg, /* whew! list of exprs, here we come! */\n                   _ => fail ~\"badly-structured parse result\""}, {"sha": "1b25ea73f07d2db18107a700e41b547aa17baaaf", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -265,7 +265,7 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     fn variant(name: ident,\n                span: span,\n                +tys: ~[@ast::ty]) -> ast::variant {\n-        let args = tys.map(|ty| {ty: ty, id: self.next_id()});\n+        let args = tys.map(|ty| {ty: *ty, id: self.next_id()});\n \n         {node: {name: name,\n                 attrs: ~[],"}, {"sha": "11250cfbf38df689cf335d8f2ea689e13ebd4bf5", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -91,7 +91,7 @@ impl message: gen_send {\n                          this.proto.name,\n                          self.name(),\n                          str::connect(vec::append_one(\n-                           arg_names.map(|x| ~\"move \" + cx.str_of(x)),\n+                           arg_names.map(|x| ~\"move \" + cx.str_of(*x)),\n                              ~\"move s\"), ~\", \"));\n \n             if !try {\n@@ -144,7 +144,7 @@ impl message: gen_send {\n                     ~\"\"\n                 }\n                 else {\n-                    ~\"(\" + str::connect(arg_names.map(|x| ~\"move \" + x),\n+                    ~\"(\" + str::connect(arg_names.map(|x| ~\"move \" + *x),\n                                         ~\", \") + ~\")\"\n                 };\n "}, {"sha": "5ddc492d0fb5f18bd251951cb69b5e01dbfb52b1", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -224,10 +224,10 @@ fn visit<Tproto, Tstate, Tmessage, V: visitor<Tproto, Tstate, Tmessage>>(\n     // the copy keywords prevent recursive use of dvec\n     let states = do (copy proto.states).map_to_vec |s| {\n         let messages = do (copy s.messages).map_to_vec |m| {\n-            let message(name, span, tys, this, next) = m;\n+            let message(name, span, tys, this, next) = *m;\n             visitor.visit_message(name, span, tys, this, next)\n         };\n-        visitor.visit_state(s, messages)\n+        visitor.visit_state(*s, messages)\n     };\n     visitor.visit_proto(proto, states)\n }"}, {"sha": "115a640bda86b3a51833dba10d3dba005f41010b", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -28,7 +28,7 @@ enum fragment {\n }\n \n fn ids_ext(cx: ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n-    strs.map(|str| cx.parse_sess().interner.intern(@str))\n+    strs.map(|str| cx.parse_sess().interner.intern(@*str))\n }\n fn id_ext(cx: ext_ctxt, str: ~str) -> ast::ident {\n     cx.parse_sess().interner.intern(@str)"}, {"sha": "8df57144c07578460d189592c786fa0261b4cce5", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -262,11 +262,11 @@ fn wrong_occurs(cx: ext_ctxt, l: ident, l_c: uint, r: ident, r_c: uint)\n \n /* handle sequences (anywhere in the AST) of exprs, either real or ...ed */\n fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n-                    recur: fn@(&&@expr) -> @expr,\n+                    recur: fn@(&&v: @expr) -> @expr,\n                     exprs: ~[@expr]) -> ~[@expr] {\n     match elts_to_ell(cx, exprs) {\n       {pre: pre, rep: repeat_me_maybe, post: post} => {\n-        let mut res = vec::map(pre, recur);\n+        let mut res = vec::map(pre, |x| recur(*x));\n         match repeat_me_maybe {\n           None => (),\n           Some(repeat_me) => {\n@@ -314,7 +314,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n             }\n           }\n         }\n-        res = vec::append(res, vec::map(post, recur));\n+        res = vec::append(res, vec::map(post, |x| recur(*x)));\n         return res;\n       }\n     }"}, {"sha": "9b41d90e6d045fcf20d4fdcb7165e9d0fc554a50", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -50,7 +50,8 @@ fn expand_mod(cx: ext_ctxt, sp: span, arg: ast::mac_arg, _body: ast::mac_body)\n     -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::Some(0u), ~\"file\");\n     return mk_uniq_str(cx, sp,\n-                    str::connect(cx.mod_path().map(|x| cx.str_of(x)), ~\"::\"));\n+                       str::connect(cx.mod_path().map(\n+                           |x| cx.str_of(*x)), ~\"::\"));\n }\n \n fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n@@ -88,8 +89,8 @@ fn expand_include_bin(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n \n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n       result::Ok(src) => {\n-        let u8_exprs = vec::map(src, |char: u8| {\n-            mk_u8(cx, sp, char)\n+        let u8_exprs = vec::map(src, |char| {\n+            mk_u8(cx, sp, *char)\n         });\n         return mk_base_vec_e(cx, sp, u8_exprs);\n       }"}, {"sha": "52369ad7207f0e816c03277fc931d041910e087f", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -72,7 +72,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n         let itr = cx.parse_sess().interner;\n \n         for lhses.eachi() |i, lhs| { // try each arm's matchers\n-            match lhs {\n+            match *lhs {\n               @matched_nonterminal(nt_matchers(mtcs)) => {\n                 // `none` is because we're not interpolating\n                 let arg_rdr = new_tt_reader(s_d, itr, None, arg) as reader;"}, {"sha": "7fb910cd4b62de9d2bd9aed895179d49efc4e19e", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -29,7 +29,7 @@ type tt_reader = @{\n     mut cur: tt_frame,\n     /* for MBE-style macro transcription */\n     interpolations: std::map::HashMap<ident, @named_match>,\n-    mut repeat_idx: ~[mut uint],\n+    mut repeat_idx: ~[uint],\n     mut repeat_len: ~[uint],\n     /* cached: */\n     mut cur_tok: token,\n@@ -50,7 +50,8 @@ fn new_tt_reader(sp_diag: span_handler, itr: ident_interner,\n                 None => std::map::HashMap::<uint,@named_match>(),\n                 Some(x) => x\n               },\n-              mut repeat_idx: ~[mut], mut repeat_len: ~[],\n+              mut repeat_idx: ~[],\n+              mut repeat_len: ~[],\n               /* dummy values, never read: */\n               mut cur_tok: EOF,\n               mut cur_span: ast_util::mk_sp(0u,0u)"}, {"sha": "f9b1959f0517efac553f006bd7ee31f07f4c5dab", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 54, "deletions": 52, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -85,7 +85,7 @@ fn fold_meta_item_(&&mi: @meta_item, fld: ast_fold) -> @meta_item {\n                 meta_list(id, mis) => {\n                   let fold_meta_item = |x|fold_meta_item_(x, fld);\n                   meta_list(/* FIXME: (#2543) */ copy id,\n-                            vec::map(mis, fold_meta_item))\n+                            vec::map(mis, |e| fold_meta_item(*e)))\n                 }\n                 meta_name_value(id, s) => {\n                   meta_name_value(id, /* FIXME (#2543) */ copy s)\n@@ -125,7 +125,7 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n }\n \n fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n-    return {inputs: vec::map(decl.inputs, |x| fold_arg_(x, fld) ),\n+    return {inputs: vec::map(decl.inputs, |x| fold_arg_(*x, fld) ),\n          output: fld.fold_ty(decl.output),\n          cf: decl.cf}\n }\n@@ -140,22 +140,22 @@ fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n fn fold_ty_param(tp: ty_param, fld: ast_fold) -> ty_param {\n     {ident: /* FIXME (#2543) */ copy tp.ident,\n      id: fld.new_id(tp.id),\n-     bounds: @vec::map(*tp.bounds, |x| fold_ty_param_bound(x, fld) )}\n+     bounds: @vec::map(*tp.bounds, |x| fold_ty_param_bound(*x, fld) )}\n }\n \n fn fold_ty_params(tps: ~[ty_param], fld: ast_fold) -> ~[ty_param] {\n-    vec::map(tps, |x| fold_ty_param(x, fld) )\n+    vec::map(tps, |x| fold_ty_param(*x, fld) )\n }\n \n fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     let fold_meta_item = |x| fold_meta_item_(x, fld);\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n     return {\n-        directives: vec::map(c.directives, |x| fld.fold_crate_directive(x)),\n+        directives: vec::map(c.directives, |x| fld.fold_crate_directive(*x)),\n         module: fld.fold_mod(c.module),\n-        attrs: vec::map(c.attrs, fold_attribute),\n-        config: vec::map(c.config, fold_meta_item)\n+        attrs: vec::map(c.attrs, |x| fold_attribute(*x)),\n+        config: vec::map(c.config, |x| fold_meta_item(*x))\n     };\n }\n \n@@ -167,7 +167,7 @@ fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n           }\n           cdir_dir_mod(id, cds, attrs) => {\n             cdir_dir_mod(fld.fold_ident(id),\n-                         vec::map(cds, |x| fld.fold_crate_directive(x)),\n+                         vec::map(cds, |x| fld.fold_crate_directive(*x)),\n                          /* FIXME (#2543) */ copy attrs)\n           }\n           cdir_view_item(vi) => cdir_view_item(fld.fold_view_item(vi)),\n@@ -186,15 +186,16 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n     return @{ident: fld.fold_ident(ni.ident),\n-          attrs: vec::map(ni.attrs, fold_attribute),\n+          attrs: vec::map(ni.attrs, |x| fold_attribute(*x)),\n           node:\n               match ni.node {\n                 foreign_item_fn(fdec, purity, typms) => {\n-                  foreign_item_fn({inputs: vec::map(fdec.inputs, fold_arg),\n-                                   output: fld.fold_ty(fdec.output),\n-                                   cf: fdec.cf},\n-                                  purity,\n-                                  fold_ty_params(typms, fld))\n+                  foreign_item_fn(\n+                      {inputs: vec::map(fdec.inputs, |a| fold_arg(*a)),\n+                       output: fld.fold_ty(fdec.output),\n+                       cf: fdec.cf},\n+                      purity,\n+                      fold_ty_params(typms, fld))\n                 }\n                 foreign_item_const(t) => {\n                   foreign_item_const(fld.fold_ty(t))\n@@ -208,7 +209,7 @@ fn noop_fold_item(&&i: @item, fld: ast_fold) -> Option<@item> {\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n     return Some(@{ident: fld.fold_ident(i.ident),\n-               attrs: vec::map(i.attrs, fold_attribute),\n+               attrs: vec::map(i.attrs, |e| fold_attribute(*e)),\n                id: fld.new_id(i.id),\n                node: fld.fold_item_underscore(i.node),\n                vis: i.vis,\n@@ -239,7 +240,7 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           item_enum(enum_definition, typms) => {\n             item_enum(ast::enum_def({\n                 variants: vec::map(enum_definition.variants,\n-                                   |x| fld.fold_variant(x)),\n+                                   |x| fld.fold_variant(*x)),\n                 common: option::map(enum_definition.common,\n                                     |x| fold_struct_def(x, fld))\n             }), fold_ty_params(typms, fld))\n@@ -252,11 +253,11 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n               item_impl(fold_ty_params(tps, fld),\n                         ifce.map(|p| fold_trait_ref(p, fld)),\n                         fld.fold_ty(ty),\n-                        vec::map(methods, |x| fld.fold_method(x)))\n+                        vec::map(methods, |x| fld.fold_method(*x)))\n           }\n           item_trait(tps, traits, methods) => {\n             item_trait(fold_ty_params(tps, fld),\n-                       vec::map(traits, |p| fold_trait_ref(p, fld)),\n+                       vec::map(traits, |p| fold_trait_ref(*p, fld)),\n                        /* FIXME (#2543) */ copy methods)\n           }\n       item_mac(m) => {\n@@ -292,9 +293,9 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n                 id: dtor_id,.. dtor.node},\n             .. dtor}};\n     return @{\n-        traits: vec::map(struct_def.traits, |p| fold_trait_ref(p, fld)),\n-        fields: vec::map(struct_def.fields, |f| fold_struct_field(f, fld)),\n-        methods: vec::map(struct_def.methods, |m| fld.fold_method(m)),\n+        traits: vec::map(struct_def.traits, |p| fold_trait_ref(*p, fld)),\n+        fields: vec::map(struct_def.fields, |f| fold_struct_field(*f, fld)),\n+        methods: vec::map(struct_def.methods, |m| fld.fold_method(*m)),\n         ctor: resulting_optional_constructor,\n         dtor: dtor\n     };\n@@ -328,8 +329,8 @@ fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n \n \n fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n-    return {view_items: vec::map(b.view_items, |x| fld.fold_view_item(x)),\n-         stmts: vec::map(b.stmts, |x| fld.fold_stmt(x)),\n+    return {view_items: vec::map(b.view_items, |x| fld.fold_view_item(*x)),\n+         stmts: vec::map(b.stmts, |x| fld.fold_stmt(*x)),\n          expr: option::map(b.expr, |x| fld.fold_expr(x)),\n          id: fld.new_id(b.id),\n          rules: b.rules};\n@@ -344,7 +345,7 @@ fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n }\n \n fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n-    return {pats: vec::map(a.pats, |x| fld.fold_pat(x)),\n+    return {pats: vec::map(a.pats, |x| fld.fold_pat(*x)),\n          guard: option::map(a.guard, |x| fld.fold_expr(x)),\n          body: fld.fold_block(a.body)};\n }\n@@ -360,7 +361,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n           pat_lit(e) => pat_lit(fld.fold_expr(e)),\n           pat_enum(pth, pats) => {\n               pat_enum(fld.fold_path(pth), option::map(pats,\n-                       |pats| vec::map(pats, |x| fld.fold_pat(x))))\n+                       |pats| vec::map(pats, |x| fld.fold_pat(*x))))\n           }\n           pat_rec(fields, etc) => {\n             let mut fs = ~[];\n@@ -381,7 +382,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n             }\n             pat_struct(pth_, fs, etc)\n           }\n-          pat_tup(elts) => pat_tup(vec::map(elts, |x| fld.fold_pat(x))),\n+          pat_tup(elts) => pat_tup(vec::map(elts, |x| fld.fold_pat(*x))),\n           pat_box(inner) => pat_box(fld.fold_pat(inner)),\n           pat_uniq(inner) => pat_uniq(fld.fold_pat(inner)),\n           pat_region(inner) => pat_region(fld.fold_pat(inner)),\n@@ -393,7 +394,7 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n \n fn noop_fold_decl(d: decl_, fld: ast_fold) -> decl_ {\n     match d {\n-      decl_local(ls) => decl_local(vec::map(ls, |x| fld.fold_local(x))),\n+      decl_local(ls) => decl_local(vec::map(ls, |x| fld.fold_local(*x))),\n       decl_item(it) => match fld.fold_item(it) {\n         Some(it_folded) => decl_item(it_folded),\n         None => decl_local(~[])\n@@ -431,10 +432,10 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_repeat(expr, count, mutt) =>\n             expr_repeat(fld.fold_expr(expr), fld.fold_expr(count), mutt),\n           expr_rec(fields, maybe_expr) => {\n-            expr_rec(vec::map(fields, fold_field),\n+            expr_rec(vec::map(fields, |x| fold_field(*x)),\n                      option::map(maybe_expr, |x| fld.fold_expr(x)))\n           }\n-          expr_tup(elts) => expr_tup(vec::map(elts, |x| fld.fold_expr(x))),\n+          expr_tup(elts) => expr_tup(vec::map(elts, |x| fld.fold_expr(*x))),\n           expr_call(f, args, blk) => {\n             expr_call(fld.fold_expr(f),\n                       fld.map_exprs(|x| fld.fold_expr(x), args),\n@@ -462,20 +463,20 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           }\n           expr_match(expr, arms) => {\n             expr_match(fld.fold_expr(expr),\n-                     vec::map(arms, |x| fld.fold_arm(x)))\n+                     vec::map(arms, |x| fld.fold_arm(*x)))\n           }\n           expr_fn(proto, decl, body, captures) => {\n             expr_fn(proto, fold_fn_decl(decl, fld),\n                     fld.fold_block(body),\n                     @((*captures).map(|cap_item| {\n-                        @({id: fld.new_id((*cap_item).id),\n-                           .. *cap_item})})))\n+                        @({id: fld.new_id(cap_item.id),\n+                           ..**cap_item})})))\n           }\n           expr_fn_block(decl, body, captures) => {\n             expr_fn_block(fold_fn_decl(decl, fld), fld.fold_block(body),\n                           @((*captures).map(|cap_item| {\n-                              @({id: fld.new_id((*cap_item).id),\n-                                 .. *cap_item})})))\n+                              @({id: fld.new_id(cap_item.id),\n+                                 ..**cap_item})})))\n           }\n           expr_block(blk) => expr_block(fld.fold_block(blk)),\n           expr_move(el, er) => {\n@@ -494,7 +495,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           }\n           expr_field(el, id, tys) => {\n             expr_field(fld.fold_expr(el), fld.fold_ident(id),\n-                       vec::map(tys, |x| fld.fold_ty(x)))\n+                       vec::map(tys, |x| fld.fold_ty(*x)))\n           }\n           expr_index(el, er) => {\n             expr_index(fld.fold_expr(el), fld.fold_expr(er))\n@@ -512,7 +513,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_mac(mac) => expr_mac(fold_mac(mac)),\n           expr_struct(path, fields, maybe_expr) => {\n             expr_struct(fld.fold_path(path),\n-                        vec::map(fields, fold_field),\n+                        vec::map(fields, |x| fold_field(*x)),\n                         option::map(maybe_expr, |x| fld.fold_expr(x)))\n           }\n         }\n@@ -535,13 +536,13 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n       ty_vec(mt) => ty_vec(fold_mt(mt, fld)),\n       ty_ptr(mt) => ty_ptr(fold_mt(mt, fld)),\n       ty_rptr(region, mt) => ty_rptr(region, fold_mt(mt, fld)),\n-      ty_rec(fields) => ty_rec(vec::map(fields, |f| fold_field(f, fld))),\n+      ty_rec(fields) => ty_rec(vec::map(fields, |f| fold_field(*f, fld))),\n       ty_fn(proto, purity, bounds, decl) =>\n         ty_fn(proto, purity,\n               @vec::map(*bounds,\n-                        |x| fold_ty_param_bound(x, fld)),\n+                        |x| fold_ty_param_bound(*x, fld)),\n               fold_fn_decl(decl, fld)),\n-      ty_tup(tys) => ty_tup(vec::map(tys, |ty| fld.fold_ty(ty))),\n+      ty_tup(tys) => ty_tup(vec::map(tys, |ty| fld.fold_ty(*ty))),\n       ty_path(path, id) => ty_path(fld.fold_path(path), fld.new_id(id)),\n       ty_fixed_length(t, vs) => ty_fixed_length(fld.fold_ty(t), vs),\n       ty_mac(mac) => ty_mac(fold_mac(mac))\n@@ -550,14 +551,14 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n \n // ...nor do modules\n fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n-    return {view_items: vec::map(m.view_items, |x| fld.fold_view_item(x)),\n+    return {view_items: vec::map(m.view_items, |x| fld.fold_view_item(*x)),\n          items: vec::filter_map(m.items, |x| fld.fold_item(x))};\n }\n \n fn noop_fold_foreign_mod(nm: foreign_mod, fld: ast_fold) -> foreign_mod {\n     return {sort: nm.sort,\n-         view_items: vec::map(nm.view_items, |x| fld.fold_view_item(x)),\n-         items: vec::map(nm.items, |x| fld.fold_foreign_item(x))}\n+         view_items: vec::map(nm.view_items, |x| fld.fold_view_item(*x)),\n+         items: vec::map(nm.items, |x| fld.fold_foreign_item(*x))}\n }\n \n fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n@@ -570,7 +571,7 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     match v.kind {\n         tuple_variant_kind(variant_args) =>\n             kind = tuple_variant_kind(vec::map(variant_args,\n-                                               fold_variant_arg)),\n+                                               |x| fold_variant_arg(*x))),\n         struct_variant_kind(struct_def) => {\n             let dtor = do option::map(struct_def.dtor) |dtor| {\n                 let dtor_body = fld.fold_block(dtor.node.body);\n@@ -581,16 +582,17 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n             kind = struct_variant_kind(@{\n                 traits: ~[],\n                 fields: vec::map(struct_def.fields,\n-                                 |f| fld.fold_struct_field(f)),\n-                methods: vec::map(struct_def.methods, |m| fld.fold_method(m)),\n+                                 |f| fld.fold_struct_field(*f)),\n+                methods: vec::map(struct_def.methods,\n+                                  |m| fld.fold_method(*m)),\n                 ctor: None,\n                 dtor: dtor\n             })\n         }\n \n         enum_variant_kind(enum_definition) => {\n             let variants = vec::map(enum_definition.variants,\n-                                    |x| fld.fold_variant(x));\n+                                    |x| fld.fold_variant(*x));\n             let common = option::map(enum_definition.common,\n                                      |x| fold_struct_def(x, fld));\n             kind = enum_variant_kind(ast::enum_def({ variants: variants,\n@@ -599,7 +601,7 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     }\n \n     let fold_attribute = |x| fold_attribute_(x, fld);\n-    let attrs = vec::map(v.attrs, fold_attribute);\n+    let attrs = vec::map(v.attrs, |x| fold_attribute(*x));\n \n     let de = match v.disr_expr {\n       Some(e) => Some(fld.fold_expr(e)),\n@@ -619,9 +621,9 @@ fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident {\n \n fn noop_fold_path(&&p: path, fld: ast_fold) -> path {\n     return {span: fld.new_span(p.span), global: p.global,\n-         idents: vec::map(p.idents, |x| fld.fold_ident(x)),\n+         idents: vec::map(p.idents, |x| fld.fold_ident(*x)),\n          rp: p.rp,\n-         types: vec::map(p.types, |x| fld.fold_ty(x))};\n+         types: vec::map(p.types, |x| fld.fold_ty(*x))};\n }\n \n fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n@@ -642,7 +644,7 @@ fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n    value */\n fn noop_map_exprs(f: fn@(&&@expr) -> @expr, es: ~[@expr]) -> ~[@expr] {\n-    return vec::map(es, f);\n+    return vec::map(es, |x| f(*x));\n }\n \n fn noop_id(i: node_id) -> node_id { return i; }\n@@ -692,7 +694,7 @@ impl ast_fold_precursor: ast_fold {\n        @view_item {\n         return @{node: self.fold_view_item(x.node, self as ast_fold),\n               attrs: vec::map(x.attrs, |a|\n-                  fold_attribute_(a, self as ast_fold)),\n+                  fold_attribute_(*a, self as ast_fold)),\n               vis: x.vis,\n               span: self.new_span(x.span)};\n     }\n@@ -784,7 +786,7 @@ impl ast_fold_precursor: ast_fold {\n \n impl ast_fold {\n     fn fold_attributes(attrs: ~[attribute]) -> ~[attribute] {\n-        attrs.map(|x| fold_attribute_(x, self))\n+        attrs.map(|x| fold_attribute_(*x, self))\n     }\n }\n "}, {"sha": "471a800b3826faf0a4f787f7408a334eccfb50eb", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -89,7 +89,7 @@ fn strip_doc_comment_decoration(comment: ~str) -> ~str {\n         }\n \n         return do lines.map |line| {\n-            let chars = str::chars(line);\n+            let chars = str::chars(*line);\n             if i > chars.len() {\n                 ~\"\"\n             } else {"}, {"sha": "132bbc96344f4e9404b087442f17b7f62729acd6", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -93,7 +93,7 @@ fn get_rpaths_relative_to_output(os: session::os,\n                                  output: &Path,\n                                  libs: &[Path]) -> ~[Path] {\n     vec::map(libs, |a| {\n-        get_rpath_relative_to_output(os, output, &a)\n+        get_rpath_relative_to_output(os, output, a)\n     })\n }\n \n@@ -148,7 +148,7 @@ fn get_relative_to(abs1: &Path, abs2: &Path) -> Path {\n }\n \n fn get_absolute_rpaths(libs: &[Path]) -> ~[Path] {\n-    vec::map(libs, |a| get_absolute_rpath(&a) )\n+    vec::map(libs, |a| get_absolute_rpath(a) )\n }\n \n fn get_absolute_rpath(lib: &Path) -> Path {"}, {"sha": "d0f281f812856beae6fa5ca3999917d095e65b44", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -553,7 +553,7 @@ fn build_session_options(binary: ~str,\n \n     let addl_lib_search_paths =\n         getopts::opt_strs(matches, ~\"L\")\n-        .map(|s| Path(s));\n+        .map(|s| Path(*s));\n     let cfg = parse_cfgspecs(getopts::opt_strs(matches, ~\"cfg\"));\n     let test = opt_present(matches, ~\"test\");\n     let sopts: @session::options ="}, {"sha": "792d944169adf958386fa285432c4cd9267c2523", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -55,7 +55,7 @@ fn fold_mod(cx: ctxt, m: ast::_mod, fld: fold::ast_fold) ->\n     let view_item_filter = |a| filter_view_item(cx, a);\n     let filtered_view_items = vec::filter_map(m.view_items, view_item_filter);\n     return {\n-        view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(x)),\n+        view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(*x)),\n         items: vec::filter_map(filtered_items, |x| fld.fold_item(x))\n     };\n }\n@@ -76,7 +76,7 @@ fn fold_foreign_mod(cx: ctxt, nm: ast::foreign_mod,\n         nm.view_items, view_item_filter);\n     return {\n         sort: nm.sort,\n-        view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(x)),\n+        view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(*x)),\n         items: filtered_items\n     };\n }\n@@ -103,7 +103,7 @@ fn fold_block(cx: ctxt, b: ast::blk_, fld: fold::ast_fold) ->\n     let filter = |a| filter_stmt(cx, a);\n     let filtered_stmts = vec::filter_map(b.stmts, filter);\n     return {view_items: b.view_items,\n-         stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(x)),\n+         stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(*x)),\n          expr: option::map(b.expr, |x| fld.fold_expr(x)),\n          id: b.id,\n          rules: b.rules};"}, {"sha": "f6c2bf7d5a1163d4ea7fd82bd588c12a5edad3b3", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -63,9 +63,9 @@ fn warn_if_multiple_versions(e: env, diag: span_handler,\n             partition(crate_cache.map_to_vec(|entry| {\n                 let othername = loader::crate_name_from_metas(*entry.metas);\n                 if name == othername {\n-                    Left(entry)\n+                    Left(*entry)\n                 } else {\n-                    Right(entry)\n+                    Right(*entry)\n                 }\n             }));\n "}, {"sha": "dd90168d5c01bfb7c4fb0206057afb1e6900b56e", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -171,7 +171,7 @@ fn get_dep_hashes(cstore: cstore) -> ~[~str] {\n     for sorted.each |x| {\n         debug!(\"  hash[%s]: %s\", x.name, x.hash);\n     }\n-    fn mapper(ch: crate_hash) -> ~str { return ch.hash; }\n+    fn mapper(ch: &crate_hash) -> ~str { return ch.hash; }\n     return vec::map(sorted, mapper);\n }\n "}, {"sha": "51c6b6148ce849f353b62b786a5e341ad39c4849", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -283,9 +283,7 @@ fn item_path(intr: ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n     let len_doc = ebml::get_doc(path_doc, tag_path_len);\n     let len = ebml::doc_as_u32(len_doc) as uint;\n \n-    let mut result = ~[];\n-    vec::reserve(result, len);\n-\n+    let mut result = vec::with_capacity(len);\n     for ebml::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n             let str = ebml::doc_as_str(elt_doc);"}, {"sha": "91d7c723694b01f507307bea68253e534a1095bc", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -1026,7 +1026,7 @@ fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n         type numdep = decoder::crate_dep;\n \n         // Pull the cnums and name,vers,hash out of cstore\n-        let mut deps: ~[mut numdep] = ~[mut];\n+        let mut deps: ~[numdep] = ~[];\n         do cstore::iter_crate_data(cstore) |key, val| {\n             let dep = {cnum: key, name: ecx.tcx.sess.ident_of(val.name),\n                        vers: decoder::get_crate_vers(val.data),"}, {"sha": "e01790641f0061d770218d658570f5b2ebce1269", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -81,7 +81,7 @@ fn raw_pat(p: @pat) -> @pat {\n \n fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: ~[@pat]) {\n     assert(pats.is_not_empty());\n-    let ext = match is_useful(tcx, vec::map(pats, |p| ~[p]), ~[wild()]) {\n+    let ext = match is_useful(tcx, vec::map(pats, |p| ~[*p]), ~[wild()]) {\n       not_useful => return, // This is good, wildcard pattern isn't reachable\n       useful_ => None,\n       useful(ty, ctor) => {"}, {"sha": "e26b3e55eeddce96e79dca016214990272ec309d", "filename": "src/rustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fconst_eval.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -83,7 +83,7 @@ fn classify(e: @expr,\n \n               ast::expr_tup(es) |\n               ast::expr_vec(es, ast::m_imm) => {\n-                join_all(vec::map(es, |e| classify(e, def_map, tcx)))\n+                join_all(vec::map(es, |e| classify(*e, def_map, tcx)))\n               }\n \n               ast::expr_vstore(e, vstore) => {"}, {"sha": "db39c616b554e418f978700e93f74ddfc12cee2a", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -1287,7 +1287,7 @@ impl Resolver {\n \n                             for full_path.idents.eachi |i, ident| {\n                                 if i != path_len - 1u {\n-                                    (*module_path).push(ident);\n+                                    (*module_path).push(*ident);\n                                 }\n                             }\n                         }\n@@ -3762,8 +3762,8 @@ impl Resolver {\n     fn check_consistent_bindings(arm: arm) {\n         if arm.pats.len() == 0 { return; }\n         let map_0 = self.binding_mode_map(arm.pats[0]);\n-        for arm.pats.eachi() |i, p: @pat| {\n-            let map_i = self.binding_mode_map(p);\n+        for arm.pats.eachi() |i, p| {\n+            let map_i = self.binding_mode_map(*p);\n \n             for map_0.each |key, binding_0| {\n                 match map_i.find(key) {\n@@ -3894,15 +3894,15 @@ impl Resolver {\n                         debug!(\"(resolving type) writing resolution for `%s` \\\n                                 (id %d)\",\n                                connect(path.idents.map(\n-                                   |x| self.session.str_of(x)), ~\"::\"),\n+                                   |x| self.session.str_of(*x)), ~\"::\"),\n                                path_id);\n                         self.record_def(path_id, def);\n                     }\n                     None => {\n                         self.session.span_err\n                             (ty.span, fmt!(\"use of undeclared type name `%s`\",\n                                            connect(path.idents.map(\n-                                               |x| self.session.str_of(x)),\n+                                               |x| self.session.str_of(*x)),\n                                                    ~\"::\")));\n                     }\n                 }\n@@ -4080,7 +4080,7 @@ impl Resolver {\n                                 path.span,\n                                 fmt!(\"`%s` does not name a structure\",\n                                      connect(path.idents.map(\n-                                         |x| self.session.str_of(x)),\n+                                         |x| self.session.str_of(*x)),\n                                              ~\"::\")));\n                         }\n                     }\n@@ -4256,7 +4256,7 @@ impl Resolver {\n                 break;\n             }\n \n-            (*module_path_atoms).push(ident);\n+            (*module_path_atoms).push(*ident);\n         }\n \n         return module_path_atoms;\n@@ -4482,13 +4482,13 @@ impl Resolver {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `%s`\",\n                                connect(path.idents.map(\n-                                   |x| self.session.str_of(x)), ~\"::\"));\n+                                   |x| self.session.str_of(*x)), ~\"::\"));\n                         self.record_def(expr.id, def);\n                     }\n                     None => {\n                         let wrong_name =\n                             connect(path.idents.map(\n-                                |x| self.session.str_of(x)), ~\"::\") ;\n+                                |x| self.session.str_of(*x)), ~\"::\") ;\n                         if self.name_exists_in_scope_class(wrong_name) {\n                             self.session.span_err(expr.span,\n                                         fmt!(\"unresolved name: `%s`. \\\n@@ -4550,7 +4550,7 @@ impl Resolver {\n                             path.span,\n                             fmt!(\"`%s` does not name a structure\",\n                                  connect(path.idents.map(\n-                                     |x| self.session.str_of(x)),\n+                                     |x| self.session.str_of(*x)),\n                                          ~\"::\")));\n                     }\n                 }"}, {"sha": "c7abed19c597a7336460e4e4eec87e4edc15b996", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -210,14 +210,14 @@ struct Match {\n fn match_to_str(bcx: block, m: &Match) -> ~str {\n     if bcx.sess().verbose() {\n         // for many programs, this just take too long to serialize\n-        fmt!(\"%?\", m.pats.map(|p| pat_to_str(p, bcx.sess().intr())))\n+        fmt!(\"%?\", m.pats.map(|p| pat_to_str(*p, bcx.sess().intr())))\n     } else {\n         fmt!(\"%u pats\", m.pats.len())\n     }\n }\n \n fn matches_to_str(bcx: block, m: &[@Match]) -> ~str {\n-    fmt!(\"%?\", m.map(|n| match_to_str(bcx, n)))\n+    fmt!(\"%?\", m.map(|n| match_to_str(bcx, *n)))\n }\n \n fn has_nested_bindings(m: &[@Match], col: uint) -> bool {\n@@ -256,7 +256,7 @@ fn expand_nested_bindings(bcx: block, m: &[@Match/&r],\n                 @Match {pats: pats, data: br.data}\n             }\n             _ => {\n-                br\n+                *br\n             }\n         }\n     }\n@@ -789,7 +789,7 @@ fn compile_guard(bcx: block,\n            bcx.to_str(),\n            bcx.expr_to_str(guard_expr),\n            matches_to_str(bcx, m),\n-           vals.map(|v| bcx.val_str(v)));\n+           vals.map(|v| bcx.val_str(*v)));\n     let _indenter = indenter();\n \n     let mut bcx = bcx;\n@@ -840,7 +840,7 @@ fn compile_submatch(bcx: block,\n     debug!(\"compile_submatch(bcx=%s, m=%s, vals=%?)\",\n            bcx.to_str(),\n            matches_to_str(bcx, m),\n-           vals.map(|v| bcx.val_str(v)));\n+           vals.map(|v| bcx.val_str(*v)));\n     let _indenter = indenter();\n \n     /*\n@@ -895,7 +895,7 @@ fn compile_submatch(bcx: block,\n         let pat_ty = node_id_type(bcx, pat_id);\n         do expr::with_field_tys(tcx, pat_ty) |_has_dtor, field_tys| {\n             let rec_vals = rec_fields.map(|field_name| {\n-                let ix = ty::field_idx_strict(tcx, field_name, field_tys);\n+                let ix = ty::field_idx_strict(tcx, *field_name, field_tys);\n                 GEPi(bcx, val, struct_field(ix))\n             });\n             compile_submatch(\n@@ -1227,7 +1227,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n             for sub_pats.each |sub_pat| {\n                 for vec::eachi(args.vals) |i, argval| {\n                     bcx = bind_irrefutable_pat(bcx, sub_pat[i],\n-                                               argval, make_copy);\n+                                               *argval, make_copy);\n                 }\n             }\n         }\n@@ -1245,7 +1245,7 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         ast::pat_tup(elems) => {\n             for vec::eachi(elems) |i, elem| {\n                 let fldptr = GEPi(bcx, val, [0u, i]);\n-                bcx = bind_irrefutable_pat(bcx, elem, fldptr, make_copy);\n+                bcx = bind_irrefutable_pat(bcx, *elem, fldptr, make_copy);\n             }\n         }\n         ast::pat_box(inner) | ast::pat_uniq(inner) |"}, {"sha": "469e86da04e5fbce06121e4723b829663d99db16", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -206,7 +206,7 @@ fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n     assert ix < variant.args.len();\n \n     let arg_lltys = vec::map(variant.args, |aty| {\n-        type_of(ccx, ty::subst_tps(ccx.tcx, ty_substs, aty))\n+        type_of(ccx, ty::subst_tps(ccx.tcx, ty_substs, *aty))\n     });\n     let typed_blobptr = PointerCast(bcx, llblobptr,\n                                     T_ptr(T_struct(arg_lltys)));\n@@ -560,7 +560,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       ty::ty_tup(args) => {\n         for vec::eachi(args) |i, arg| {\n             let llfld_a = GEPi(cx, av, [0u, i]);\n-            cx = f(cx, llfld_a, arg);\n+            cx = f(cx, llfld_a, *arg);\n         }\n       }\n       ty::ty_enum(tid, substs) => {\n@@ -1113,17 +1113,17 @@ fn trans_block_cleanups_(bcx: block,\n         bcx.ccx().sess.opts.debugging_opts & session::no_landing_pads != 0;\n     if bcx.unreachable && !no_lpads { return bcx; }\n     let mut bcx = bcx;\n-    for vec::reach(cleanups) |cu| {\n-            match cu {\n-              clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) => {\n+    for vec::rev_each(cleanups) |cu| {\n+        match *cu {\n+            clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) => {\n                 // Some types don't need to be cleaned up during\n                 // landing pads because they can be freed en mass later\n                 if cleanup_type == normal_exit_and_unwind || !is_lpad {\n                     bcx = cfn(bcx);\n                 }\n-              }\n             }\n         }\n+    }\n     return bcx;\n }\n "}, {"sha": "865374054e65ec684561f29c5a91423a12a62d43", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -144,7 +144,7 @@ fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n     cx.terminated = true;\n     debug!(\"Invoke(%s with arguments (%s))\",\n            val_str(cx.ccx().tn, Fn),\n-           str::connect(vec::map(Args, |a| val_str(cx.ccx().tn, a)),\n+           str::connect(vec::map(Args, |a| val_str(cx.ccx().tn, *a)),\n                         ~\", \"));\n     unsafe {\n         count_insn(cx, \"invoke\");\n@@ -677,7 +677,7 @@ fn Call(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n \n         debug!(\"Call(Fn=%s, Args=%?)\",\n                val_str(cx.ccx().tn, Fn),\n-               Args.map(|arg| val_str(cx.ccx().tn, arg)));\n+               Args.map(|arg| val_str(cx.ccx().tn, *arg)));\n \n         do vec::as_imm_buf(Args) |ptr, len| {\n             llvm::LLVMBuildCall(B(cx), Fn, ptr, len as c_uint, noname())"}, {"sha": "f79fd8c97e79a8369750aa51f26e370ecc2561f7", "filename": "src/rustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -174,7 +174,7 @@ fn trans_fn_ref_with_vtables(\n     debug!(\"trans_fn_ref_with_vtables(bcx=%s, def_id=%?, ref_id=%?, \\\n             type_params=%?, vtables=%?)\",\n            bcx.to_str(), def_id, ref_id,\n-           type_params.map(|t| bcx.ty_to_str(t)),\n+           type_params.map(|t| bcx.ty_to_str(*t)),\n            vtables);\n     let _indenter = indenter();\n \n@@ -454,7 +454,7 @@ fn trans_args(cx: block, llenv: ValueRef, args: CallArgs, fn_ty: ty::t,\n         let last = arg_exprs.len() - 1u;\n         for vec::eachi(arg_exprs) |i, arg_expr| {\n             let arg_val = unpack_result!(bcx, {\n-                trans_arg_expr(bcx, arg_tys[i], arg_expr, &mut temp_cleanups,\n+                trans_arg_expr(bcx, arg_tys[i], *arg_expr, &mut temp_cleanups,\n                                if i == last { ret_flag } else { None },\n                                autoref_arg)\n             });"}, {"sha": "a7c0bfb81cd54fa71a70f82297cc1cc0a31cc701", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -192,9 +192,9 @@ type param_substs = {tys: ~[ty::t],\n \n fn param_substs_to_str(tcx: ty::ctxt, substs: &param_substs) -> ~str {\n     fmt!(\"param_substs {tys:%?, vtables:%?, bounds:%?}\",\n-         substs.tys.map(|t| ty_to_str(tcx, t)),\n+         substs.tys.map(|t| ty_to_str(tcx, *t)),\n          substs.vtables.map(|vs| vs.map(|v| v.to_str(tcx))),\n-         substs.bounds.map(|b| ty::param_bounds_to_str(tcx, b)))\n+         substs.bounds.map(|b| ty::param_bounds_to_str(tcx, *b)))\n }\n \n // Function context.  Every LLVM function we create will have one of\n@@ -1265,7 +1265,7 @@ fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     let params = ty::node_id_to_type_params(tcx, id);\n     match bcx.fcx.param_substs {\n       Some(substs) => {\n-        vec::map(params, |t| ty::subst_tps(tcx, substs.tys, t))\n+        vec::map(params, |t| ty::subst_tps(tcx, substs.tys, *t))\n       }\n       _ => params\n     }\n@@ -1280,7 +1280,7 @@ fn node_vtables(bcx: block, id: ast::node_id) -> Option<typeck::vtable_res> {\n fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n     -> typeck::vtable_res\n {\n-    @vec::map(*vts, |d| resolve_vtable_in_fn_ctxt(fcx, d))\n+    @vec::map(*vts, |d| resolve_vtable_in_fn_ctxt(fcx, *d))\n }\n \n // Apply the typaram substitutions in the fn_ctxt to a vtable. This should\n@@ -1293,7 +1293,7 @@ fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n         typeck::vtable_static(trait_id, tys, sub) => {\n             let tys = match fcx.param_substs {\n                 Some(substs) => {\n-                    vec::map(tys, |t| ty::subst_tps(tcx, substs.tys, t))\n+                    vec::map(tys, |t| ty::subst_tps(tcx, substs.tys, *t))\n                 }\n                 _ => tys\n             };"}, {"sha": "a3803ffb91af078d49e5f8ac6dd66c0c27d87644", "filename": "src/rustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -43,7 +43,7 @@ fn const_vec(cx: @crate_ctxt, e: @ast::expr, es: &[@ast::expr])\n     let vec_ty = ty::expr_ty(cx.tcx, e);\n     let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n     let llunitty = type_of::type_of(cx, unit_ty);\n-    let v = C_array(llunitty, es.map(|e| const_expr(cx, e)));\n+    let v = C_array(llunitty, es.map(|e| const_expr(cx, *e)));\n     let unit_sz = shape::llsize_of(cx, llunitty);\n     let sz = llvm::LLVMConstMul(C_uint(cx, es.len()), unit_sz);\n     return (v, sz, llunitty);\n@@ -286,7 +286,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         gv\n       }\n       ast::expr_tup(es) => {\n-        C_struct(es.map(|e| const_expr(cx, e)))\n+        C_struct(es.map(|e| const_expr(cx, *e)))\n       }\n       ast::expr_rec(fs, None) => {\n           C_struct([C_struct("}, {"sha": "54604835daeb95d84455198d6285ae775a29a51e", "filename": "src/rustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -1057,8 +1057,8 @@ fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: Dest) -> block {\n     let mut temp_cleanups = ~[];\n     for vec::eachi(elts) |i, e| {\n         let dest = GEPi(bcx, addr, [0u, i]);\n-        let e_ty = expr_ty(bcx, e);\n-        bcx = trans_into(bcx, e, SaveIn(dest));\n+        let e_ty = expr_ty(bcx, *e);\n+        bcx = trans_into(bcx, *e, SaveIn(dest));\n         add_clean_temp_mem(bcx, dest, e_ty);\n         vec::push(temp_cleanups, dest);\n     }"}, {"sha": "7b37305705f414892a56c721290c636b51798a1d", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -420,7 +420,7 @@ fn decl_x86_64_fn(tys: x86_64_tys,\n     let llfn = decl(fnty);\n \n     for vec::eachi(tys.attrs) |i, a| {\n-        match a {\n+        match *a {\n             option::Some(attr) => {\n                 let llarg = get_param(llfn, i);\n                 llvm::LLVMAddAttribute(llarg, attr as c_uint);\n@@ -650,7 +650,7 @@ fn trans_foreign_mod(ccx: @crate_ctxt,\n             match tys.x86_64_tys {\n                 Some(x86_64) => {\n                   for vec::eachi(x86_64.attrs) |i, a| {\n-                        match a {\n+                        match *a {\n                             Some(attr) => {\n                                 llvm::LLVMAddInstrAttribute(\n                                     llretval, (i + 1u) as c_uint,"}, {"sha": "a0a207a85d3b7289749def537448c87e39905825", "filename": "src/rustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -330,9 +330,9 @@ fn combine_impl_and_methods_tps(bcx: block,\n                       vec::tailn(node_substs,\n                                  node_substs.len() - n_m_tps));\n     debug!(\"n_m_tps=%?\", n_m_tps);\n-    debug!(\"rcvr_substs=%?\", rcvr_substs.map(|t| bcx.ty_to_str(t)));\n-    debug!(\"node_substs=%?\", node_substs.map(|t| bcx.ty_to_str(t)));\n-    debug!(\"ty_substs=%?\", ty_substs.map(|t| bcx.ty_to_str(t)));\n+    debug!(\"rcvr_substs=%?\", rcvr_substs.map(|t| bcx.ty_to_str(*t)));\n+    debug!(\"node_substs=%?\", node_substs.map(|t| bcx.ty_to_str(*t)));\n+    debug!(\"ty_substs=%?\", ty_substs.map(|t| bcx.ty_to_str(*t)));\n \n     return ty_substs;\n }\n@@ -462,7 +462,7 @@ fn vtable_id(ccx: @crate_ctxt, origin: typeck::vtable_origin) -> mono_id {\n         }\n         typeck::vtable_trait(trait_id, substs) => {\n             @{def: trait_id,\n-              params: vec::map(substs, |t| mono_precise(t, None))}\n+              params: vec::map(substs, |t| mono_precise(*t, None))}\n         }\n         // can't this be checked at the callee?\n         _ => fail ~\"vtable_id\""}, {"sha": "74513357e14cf0bc22355e2eb4fcb73c049f2cf4", "filename": "src/rustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -22,9 +22,9 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n     let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs, |t| {\n-        match normalize_for_monomorphization(ccx.tcx, t) {\n+        match normalize_for_monomorphization(ccx.tcx, *t) {\n           Some(t) => { must_cast = true; t }\n-          None => t\n+          None => *t\n         }\n     });\n \n@@ -40,8 +40,8 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n     #debug[\"monomorphic_fn(fn_id=%? (%s), real_substs=%?, substs=%?, \\\n            hash_id = %?\",\n            fn_id, ty::item_path_str(ccx.tcx, fn_id),\n-           real_substs.map(|s| ty_to_str(ccx.tcx, s)),\n-           substs.map(|s| ty_to_str(ccx.tcx, s)), hash_id];\n+           real_substs.map(|s| ty_to_str(ccx.tcx, *s)),\n+           substs.map(|s| ty_to_str(ccx.tcx, *s)), hash_id];\n \n     match ccx.monomorphized.find(hash_id) {\n       Some(val) => {\n@@ -256,7 +256,7 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n         })\n       }\n       None => {\n-        vec::map(substs, |subst| (subst, None))\n+        vec::map(substs, |subst| (*subst, None))\n       }\n     };\n     let param_ids = match param_uses {\n@@ -298,8 +298,12 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n             }\n         })\n       }\n-      None => precise_param_ids.map(|x| { let (a, b) = x;\n-                mono_precise(a, b) })\n+      None => {\n+          precise_param_ids.map(|x| {\n+              let (a, b) = *x;\n+              mono_precise(a, b)\n+          })\n+      }\n     };\n     @{def: item, params: param_ids}\n }"}, {"sha": "4fda4d7264f8374e9a01432f8744abe7d3fa2ec9", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -66,7 +66,7 @@ impl reflector {\n         debug!(\"passing %u args:\", vec::len(args));\n         let bcx = self.bcx;\n         for args.eachi |i, a| {\n-            debug!(\"arg %u: %s\", i, val_str(bcx.ccx().tn, a));\n+            debug!(\"arg %u: %s\", i, val_str(bcx.ccx().tn, *a));\n         }\n         let bool_ty = ty::mk_bool(tcx);\n         let scratch = scratch_datum(bcx, bool_ty, false);\n@@ -171,7 +171,7 @@ impl reflector {\n                 for tys.eachi |i, t| {\n                     self.visit(~\"tup_field\",\n                                ~[self.c_uint(i),\n-                                 self.c_tydesc(t)]);\n+                                 self.c_tydesc(*t)]);\n                 }\n             }\n           }\n@@ -263,7 +263,7 @@ impl reflector {\n                         for v.args.eachi |j, a| {\n                             self.visit(~\"enum_variant_field\",\n                                        ~[self.c_uint(j),\n-                                         self.c_tydesc(a)]);\n+                                         self.c_tydesc(*a)]);\n                         }\n                     }\n                 }"}, {"sha": "46fd9cefb7fba16a2bb82964208bf35d18e9f097", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -72,7 +72,7 @@ impl nominal_id_ : to_bytes::IterBytes {\n fn mk_nominal_id(tcx: ty::ctxt, did: ast::def_id,\n                  parent_id: Option<ast::def_id>,\n                  tps: ~[ty::t]) -> nominal_id {\n-    let tps_norm = tps.map(|t| ty::normalize_ty(tcx, t));\n+    let tps_norm = tps.map(|t| ty::normalize_ty(tcx, *t));\n     @{did: did, parent_id: parent_id, tps: tps_norm}\n }\n "}, {"sha": "10f93626280023f92ebd0e316c9c9394b5e7d55f", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -329,7 +329,7 @@ fn write_content(bcx: block,\n                         let lleltptr = GEPi(bcx, lldest, [i]);\n                         debug!(\"writing index %? with lleltptr=%?\",\n                                i, bcx.val_str(lleltptr));\n-                        bcx = expr::trans_into(bcx, element,\n+                        bcx = expr::trans_into(bcx, *element,\n                                                SaveIn(lleltptr));\n                         add_clean_temp_mem(bcx, lleltptr, vt.unit_ty);\n                         vec::push(temp_cleanups, lleltptr);"}, {"sha": "d9032f8ce9091dbbf3aacecd8ad7f113b828d779", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -31,7 +31,7 @@ fn type_of_explicit_arg(ccx: @crate_ctxt, arg: ty::arg) -> TypeRef {\n }\n \n fn type_of_explicit_args(ccx: @crate_ctxt, inputs: ~[ty::arg]) -> ~[TypeRef] {\n-    inputs.map(|arg| type_of_explicit_arg(ccx, arg))\n+    inputs.map(|arg| type_of_explicit_arg(ccx, *arg))\n }\n \n fn type_of_fn(cx: @crate_ctxt, inputs: ~[ty::arg],"}, {"sha": "d18c48ae94d29996304895aee9bd8ba86ef30da2", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -1235,7 +1235,7 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n     fn fold_substs(substs: &substs, fldop: fn(t) -> t) -> substs {\n         {self_r: substs.self_r,\n          self_ty: substs.self_ty.map(|t| fldop(t)),\n-         tps: substs.tps.map(|t| fldop(t))}\n+         tps: substs.tps.map(|t| fldop(*t))}\n     }\n \n     match *sty {\n@@ -1269,7 +1269,7 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n             ty_rec(new_fields)\n         }\n         ty_tup(ts) => {\n-            let new_ts = vec::map(ts, |tt| fldop(tt));\n+            let new_ts = vec::map(ts, |tt| fldop(*tt));\n             ty_tup(new_ts)\n         }\n         ty_fn(ref f) => {\n@@ -1332,7 +1332,7 @@ fn fold_regions_and_ty(\n \n         {self_r: substs.self_r.map(|r| fldr(r)),\n          self_ty: substs.self_ty.map(|t| fldt(t)),\n-         tps: substs.tps.map(|t| fldt(t))}\n+         tps: substs.tps.map(|t| fldt(*t))}\n     }\n \n     let tb = ty::get(ty);\n@@ -1476,7 +1476,7 @@ fn param_bound_to_str(cx: ctxt, pb: &param_bound) -> ~str {\n }\n \n fn param_bounds_to_str(cx: ctxt, pbs: param_bounds) -> ~str {\n-    fmt!(\"%?\", pbs.map(|pb| param_bound_to_str(cx, &pb)))\n+    fmt!(\"%?\", pbs.map(|pb| param_bound_to_str(cx, pb)))\n }\n \n fn subst(cx: ctxt,\n@@ -3487,11 +3487,11 @@ fn substd_enum_variants(cx: ctxt,\n                         substs: &substs) -> ~[variant_info] {\n     do vec::map(*enum_variants(cx, id)) |variant_info| {\n         let substd_args = vec::map(variant_info.args,\n-                                   |aty| subst(cx, substs, aty));\n+                                   |aty| subst(cx, substs, *aty));\n \n         let substd_ctor_ty = subst(cx, substs, variant_info.ctor_ty);\n \n-        @{args: substd_args, ctor_ty: substd_ctor_ty,.. *variant_info}\n+        @{args: substd_args, ctor_ty: substd_ctor_ty, ..**variant_info}\n     }\n }\n "}, {"sha": "a01dbb881c5b8adbe3a2d4ea8e8df94b86e34ec3", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -163,7 +163,7 @@ impl vtable_origin {\n             vtable_trait(def_id, ref tys) => {\n                 fmt!(\"vtable_trait(%?:%s, %?)\",\n                      def_id, ty::item_path_str(tcx, def_id),\n-                     tys.map(|t| ty_to_str(tcx, t)))\n+                     tys.map(|t| ty_to_str(tcx, *t)))\n             }\n         }\n     }\n@@ -202,7 +202,7 @@ fn write_substs_to_tcx(tcx: ty::ctxt,\n                        +substs: ~[ty::t]) {\n     if substs.len() > 0u {\n         debug!(\"write_substs_to_tcx(%d, %?)\", node_id,\n-               substs.map(|t| ty_to_str(tcx, t)));\n+               substs.map(|t| ty_to_str(tcx, *t)));\n         tcx.node_type_substs.insert(node_id, substs);\n     }\n }"}, {"sha": "0c47499455362308de8a3108bfeee2662a3a16d8", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -125,7 +125,7 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n             fmt!(\"wrong number of type arguments: expected %u but found %u\",\n                  (*decl_bounds).len(), path.types.len()));\n     }\n-    let tps = path.types.map(|a_t| ast_ty_to_ty(self, rscope, a_t));\n+    let tps = path.types.map(|a_t| ast_ty_to_ty(self, rscope, *a_t));\n \n     let substs = {self_r:self_r, self_ty:None, tps:tps};\n     {substs: substs, ty: ty::subst(tcx, &substs, decl_ty)}\n@@ -295,7 +295,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n                         |tmt| ty::mk_rptr(tcx, r, tmt))\n       }\n       ast::ty_tup(fields) => {\n-        let flds = vec::map(fields, |t| ast_ty_to_ty(self, rscope, t));\n+        let flds = vec::map(fields, |t| ast_ty_to_ty(self, rscope, *t));\n         ty::mk_tup(tcx, flds)\n       }\n       ast::ty_rec(fields) => {\n@@ -489,7 +489,7 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope Copy Owned>(\n                 // were supplied\n                 if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n             };\n-            ty_of_arg(self, rb, a, expected_arg_ty)\n+            ty_of_arg(self, rb, *a, expected_arg_ty)\n         };\n \n         let expected_ret_ty = expected_tys.map(|e| e.output);"}, {"sha": "85465eb7d3cad7cf9aeb4f59d121ebc22ff5f7c6", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -237,7 +237,7 @@ fn check_fn(ccx: @crate_ctxt,\n     let ret_ty = fn_ty.sig.output;\n \n     debug!(\"check_fn(arg_tys=%?, ret_ty=%?, self_info.self_ty=%?)\",\n-           arg_tys.map(|a| ty_to_str(tcx, a)),\n+           arg_tys.map(|a| ty_to_str(tcx, *a)),\n            ty_to_str(tcx, ret_ty),\n            option::map(self_info, |s| ty_to_str(tcx, s.self_ty)));\n \n@@ -1067,8 +1067,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     }\n \n                     bot |= check_expr_with_unifier(\n-                        fcx, arg, Some(formal_ty),\n-                        || demand::assign(fcx, arg.span, formal_ty, arg)\n+                        fcx, *arg, Some(formal_ty),\n+                        || demand::assign(fcx, arg.span, formal_ty, *arg)\n                     );\n                 }\n             }\n@@ -1419,7 +1419,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             _ => ()\n         }\n \n-        let tps = vec::map(tys, |ty| fcx.to_ty(ty));\n+        let tps = vec::map(tys, |ty| fcx.to_ty(*ty));\n \n         match method::lookup(fcx, expr, base, expr.id,\n                              field, expr_t, tps) {\n@@ -1853,16 +1853,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(id, t);\n       }\n       ast::expr_tup(elts) => {\n-        let mut elt_ts = ~[];\n-        vec::reserve(elt_ts, vec::len(elts));\n         let flds = unpack_expected(fcx, expected, |sty| {\n             match sty { ty::ty_tup(flds) => Some(flds), _ => None }\n         });\n-        for elts.eachi |i, e| {\n-            check_expr(fcx, e, flds.map(|fs| fs[i]));\n-            let ety = fcx.expr_ty(e);\n-            vec::push(elt_ts, ety);\n-        }\n+        let elt_ts = do elts.mapi |i, e| {\n+            check_expr(fcx, *e, flds.map(|fs| fs[i]));\n+            fcx.expr_ty(*e)\n+        };\n         let typ = ty::mk_tup(tcx, elt_ts);\n         fcx.write_ty(id, typ);\n       }\n@@ -1886,7 +1883,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         });\n         match base {\n           None => {\n-            fn get_node(f: spanned<field>) -> field { f.node }\n+            fn get_node(f: &spanned<field>) -> field { f.node }\n             let typ = ty::mk_rec(tcx, vec::map(fields_t, get_node));\n             fcx.write_ty(id, typ);\n             /* Check for duplicate fields */\n@@ -2491,7 +2488,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n             (span, ~\"not enough type parameters provided for this item\");\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else {\n-        pth.types.map(|aty| fcx.to_ty(aty))\n+        pth.types.map(|aty| fcx.to_ty(*aty))\n     };\n \n     let substs = {self_r: self_r, self_ty: None, tps: tps};\n@@ -2576,7 +2573,7 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n         });\n \n     for tps_used.eachi |i, b| {\n-        if !b {\n+        if !*b {\n             ccx.tcx.sess.span_err(\n                 span, fmt!(\"type parameter `%s` is unused\",\n                            ccx.tcx.sess.str_of(tps[i].ident)));"}, {"sha": "14de7871e917b63a52d51f0153b02c8c6eddc50d", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -145,7 +145,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n             let vinfo =\n                 ty::enum_variant_with_id(\n                     tcx, v_def_ids.enm, v_def_ids.var);\n-            vinfo.args.map(|t| { ty::subst(tcx, expected_substs, t) })\n+            vinfo.args.map(|t| { ty::subst(tcx, expected_substs, *t) })\n         };\n         let arg_len = arg_types.len(), subpats_len = match subpats {\n             None => arg_len,"}, {"sha": "d969ce908f04147170e5b43e7ddb1dc1eb604192", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -39,7 +39,7 @@ fn replace_bound_regions_in_fn_ty(\n                 all_tys=%?)\",\n            self_ty.map(|t| ty_to_str(tcx, t)),\n            ty_to_str(tcx, ty::mk_fn(tcx, *fn_ty)),\n-           all_tys.map(|t| ty_to_str(tcx, t)));\n+           all_tys.map(|t| ty_to_str(tcx, *t)));\n     let _i = indenter();\n \n     let isr = do create_bound_region_mapping(tcx, isr, all_tys) |br| {"}, {"sha": "3c58eb57189beff9fd6b45766df0aced849a618c", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -164,7 +164,7 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n \n fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n     fn store_methods<T>(ccx: @crate_ctxt, id: ast::node_id,\n-                        stuff: ~[T], f: fn@(T) -> ty::method) {\n+                        stuff: ~[T], f: fn@(v: &T) -> ty::method) {\n         ty::store_trait_methods(ccx.tcx, id, @vec::map(stuff, f));\n     }\n \n@@ -213,7 +213,7 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n       ast_map::node_item(@{node: ast::item_trait(params, _, ms), _}, _) => {\n         store_methods::<ast::trait_method>(ccx, id, ms, |m| {\n             let trait_bounds = ty_param_bounds(ccx, params);\n-            let ty_m = trait_method_to_ty_method(m);\n+            let ty_m = trait_method_to_ty_method(*m);\n             let method_ty = ty_of_ty_method(ccx, ty_m, region_paramd);\n             if ty_m.self_ty.node == ast::sty_static {\n                 make_static_method_ty(ccx, ty_m, region_paramd,\n@@ -226,7 +226,7 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n         // All methods need to be stored, since lookup_method\n         // relies on the same method cache for self-calls\n         store_methods::<@ast::method>(ccx, id, struct_def.methods, |m| {\n-            ty_of_method(ccx, m, region_paramd)\n+            ty_of_method(ccx, *m, region_paramd)\n         });\n       }\n       _ => { /* Ignore things that aren't traits or classes */ }\n@@ -413,7 +413,7 @@ fn convert_methods(ccx: @crate_ctxt,\n     let tcx = ccx.tcx;\n     do vec::map(ms) |m| {\n         let bounds = ty_param_bounds(ccx, m.tps);\n-        let mty = ty_of_method(ccx, m, rp);\n+        let mty = ty_of_method(ccx, *m, rp);\n         let fty = ty::mk_fn(tcx, mty.fty);\n         tcx.tcache.insert(\n             local_def(m.id),\n@@ -500,7 +500,7 @@ fn convert_struct(ccx: @crate_ctxt,\n     do option::iter(struct_def.ctor) |ctor| {\n         // Write the ctor type\n         let t_args = ctor.node.dec.inputs.map(\n-            |a| ty_of_arg(ccx, type_rscope(rp), a, None) );\n+            |a| ty_of_arg(ccx, type_rscope(rp), *a, None) );\n         let t_res = ty::mk_class(\n             tcx, local_def(id),\n             {self_r: rscope::bound_self_region(rp),\n@@ -772,7 +772,7 @@ fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n \n     let bounds = ty_param_bounds(ccx, ty_params);\n     let rb = in_binding_rscope(empty_rscope);\n-    let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, rb, a, None) );\n+    let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, rb, *a, None) );\n     let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n \n     let t_fn = ty::mk_fn(ccx.tcx, FnTyBase {"}, {"sha": "664c2d37d3cbaf58e252a35e3e9132e0fa477da8", "filename": "src/rustc/middle/typeck/infer/region_var_bindings.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_var_bindings.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -877,8 +877,7 @@ impl RegionVarBindings {\n         });\n \n         // It would be nice to write this using map():\n-        let mut edges = ~[];\n-        vec::reserve(edges, num_edges);\n+        let mut edges = vec::with_capacity(num_edges);\n         for self.constraints.each_ref |constraint, span| {\n             vec::push(edges, GraphEdge {\n                 next_edge: [mut uint::max_value, uint::max_value],"}, {"sha": "e6bcdf3e71ff1186bff615925178f19a92c91a67", "filename": "src/rustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -139,10 +139,7 @@ impl Sub: combine {\n                 // anything to do with the region variable that's created\n                 // for it.  The only thing we're doing with `br` here is\n                 // using it in the debug message.\n-                //\n-                // NDM--we should not be used dummy_sp() here, but\n-                // rather passing in the span or something like that.\n-                let rvar = self.infcx.next_region_var_nb(dummy_sp());\n+                let rvar = self.infcx.next_region_var_nb(self.span);\n                 debug!(\"Bound region %s maps to %s\",\n                        bound_region_to_str(self.infcx.tcx, br),\n                        region_to_str(self.infcx.tcx, rvar));"}, {"sha": "9ade20c556820a9bd14d6551b7956159cc9023b1", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -236,7 +236,7 @@ fn expr_repr(cx: ctxt, expr: @ast::expr) -> ~str {\n }\n \n fn tys_to_str(cx: ctxt, ts: ~[t]) -> ~str {\n-    let tstrs = ts.map(|t| ty_to_str(cx, t));\n+    let tstrs = ts.map(|t| ty_to_str(cx, *t));\n     fmt!(\"[%s]\", str::connect(tstrs, \", \"))\n }\n \n@@ -394,7 +394,7 @@ fn parameterized(cx: ctxt,\n     };\n \n     if vec::len(tps) > 0u {\n-        let strs = vec::map(tps, |t| ty_to_str(cx, t) );\n+        let strs = vec::map(tps, |t| ty_to_str(cx, *t));\n         fmt!(\"%s%s<%s>\", base, r_str, str::connect(strs, ~\",\"))\n     } else {\n         fmt!(\"%s%s\", base, r_str)"}, {"sha": "a0a826ad54700bc317af614a4764f5d04dc62ec4", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -209,7 +209,7 @@ fn merge_method_attrs(\n             node: ast::item_trait(_, _, methods), _\n           }, _) => {\n             vec::map(methods, |method| {\n-                match method {\n+                match *method {\n                   ast::required(ty_m) => {\n                     (to_str(ty_m.ident), attr_parser::parse_desc(ty_m.attrs))\n                   }"}, {"sha": "0f7728d60f09d1c1adc8bc4dae69ded1b953b3e6", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -189,7 +189,7 @@ fn variantdocs_from_variants(\n     vec::map(variants, variantdoc_from_variant)\n }\n \n-fn variantdoc_from_variant(variant: ast::variant) -> doc::VariantDoc {\n+fn variantdoc_from_variant(variant: &ast::variant) -> doc::VariantDoc {\n \n     {\n         name: to_str(variant.node.name),\n@@ -218,7 +218,7 @@ fn traitdoc_from_trait(\n     {\n         item: itemdoc,\n         methods: do vec::map(methods) |method| {\n-            match method {\n+            match *method {\n               ast::required(ty_m) => {\n                 {\n                     name: to_str(ty_m.ident),"}, {"sha": "5d2d5d1f8b90c6ff43897c948252367552553267", "filename": "src/rustdoc/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ffold.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -143,7 +143,7 @@ fn default_par_fold<T:Send Copy>(ctxt: T) -> Fold<T> {\n fn default_seq_fold_doc<T>(fold: Fold<T>, doc: doc::Doc) -> doc::Doc {\n     doc::Doc_({\n         pages: do vec::map(doc.pages) |page| {\n-            match page {\n+            match *page {\n               doc::CratePage(doc) => {\n                 doc::CratePage(fold.fold_crate(fold, doc))\n               }\n@@ -192,7 +192,7 @@ fn default_seq_fold_mod<T>(\n     doc::ModDoc_({\n         item: fold.fold_item(fold, doc.item),\n         items: vec::map(doc.items, |ItemTag| {\n-            fold_ItemTag(fold, ItemTag)\n+            fold_ItemTag(fold, *ItemTag)\n         }),\n         .. *doc\n     })\n@@ -231,7 +231,7 @@ fn default_seq_fold_nmod<T>(\n     {\n         item: fold.fold_item(fold, doc.item),\n         fns: vec::map(doc.fns, |FnDoc| {\n-            fold.fold_fn(fold, FnDoc)\n+            fold.fold_fn(fold, *FnDoc)\n         }),\n         .. doc\n     }"}, {"sha": "c5319fc9cf86f21c0a4e02b6a7ee9787d39f079b", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -88,15 +88,15 @@ fn write_markdown(\n     // we don't want to spawn too many pandoc processes\n     do doc.pages.map |page| {\n         let ctxt = {\n-            w: writer_factory(page)\n+            w: writer_factory(*page)\n         };\n         write_page(ctxt, page)\n     };\n }\n \n-fn write_page(ctxt: Ctxt, page: doc::Page) {\n-    write_title(ctxt, page);\n-    match page {\n+fn write_page(ctxt: Ctxt, page: &doc::Page) {\n+    write_title(ctxt, *page);\n+    match *page {\n       doc::CratePage(doc) => {\n         write_crate(ctxt, doc);\n       }\n@@ -236,7 +236,7 @@ fn header_name(doc: doc::ItemTag) -> ~str {\n             } else {\n                 trait_part += ~\", \";\n             }\n-            trait_part += trait_type;\n+            trait_part += *trait_type;\n         }\n         fmt!(\"%s for %s\", trait_part, self_ty)\n       }\n@@ -513,7 +513,7 @@ fn write_sig(ctxt: Ctxt, sig: Option<~str>) {\n \n fn code_block_indent(s: ~str) -> ~str {\n     let lines = str::lines_any(s);\n-    let indented = vec::map(lines, |line| fmt!(\"    %s\", line) );\n+    let indented = vec::map(lines, |line| fmt!(\"    %s\", *line) );\n     str::connect(indented, ~\"\\n\")\n }\n "}, {"sha": "33f120bd1e4ef6df509638167ec2adda326df26a", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -37,9 +37,9 @@ fn main(args: ~[~str]) {\n \n     // check each vector\n     assert raw_v.len() == max;\n-    for raw_v.eachi |i, v| { assert i == v; }\n+    for raw_v.eachi |i, v| { assert i == *v; }\n     assert dvec_v.len() == max;\n-    for dvec_v.eachi |i, v| { assert i == v; }\n+    for dvec_v.eachi |i, v| { assert i == *v; }\n \n     let raw = mid - start;\n     let dvec = end - mid;"}, {"sha": "c950585347cce636962dd636f744c21d19b2fcb0", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -85,7 +85,7 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n     }\n \n     do graph.map() |v| {\n-        map::vec_from_set(v)\n+        map::vec_from_set(*v)\n     }\n }\n \n@@ -173,7 +173,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n         log(info, fmt!(\"PBFS iteration %?\", i));\n         i += 1u;\n         colors = do colors.mapi() |i, c| {\n-            let c : color = c;\n+            let c : color = *c;\n             match c {\n               white => {\n                 let i = i as node_id;\n@@ -200,7 +200,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n \n     // Convert the results.\n     do vec::map(colors) |c| {\n-        match c {\n+        match *c {\n           white => { -1i64 }\n           black(parent) => { parent }\n           _ => { fail ~\"Found remaining gray nodes in BFS\" }\n@@ -305,7 +305,7 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     let mut status = true;\n     let level = do tree.map() |parent| {\n-        let mut parent = parent;\n+        let mut parent = *parent;\n         let mut path = ~[];\n \n         if parent == -1i64 {\n@@ -427,7 +427,7 @@ fn main(args: ~[~str]) {\n \n         if do_sequential {\n             let start = time::precise_time_s();\n-            let bfs_tree = bfs(graph, root);\n+            let bfs_tree = bfs(graph, *root);\n             let stop = time::precise_time_s();\n             \n             //total_seq += stop - start;\n@@ -438,7 +438,7 @@ fn main(args: ~[~str]) {\n             \n             if do_validate {\n                 let start = time::precise_time_s();\n-                assert(validate(edges, root, bfs_tree));\n+                assert(validate(edges, *root, bfs_tree));\n                 let stop = time::precise_time_s();\n                 \n                 io::stdout().write_line(\n@@ -447,7 +447,7 @@ fn main(args: ~[~str]) {\n             }\n             \n             let start = time::precise_time_s();\n-            let bfs_tree = bfs2(graph, root);\n+            let bfs_tree = bfs2(graph, *root);\n             let stop = time::precise_time_s();\n             \n             total_seq += stop - start;\n@@ -458,7 +458,7 @@ fn main(args: ~[~str]) {\n             \n             if do_validate {\n                 let start = time::precise_time_s();\n-                assert(validate(edges, root, bfs_tree));\n+                assert(validate(edges, *root, bfs_tree));\n                 let stop = time::precise_time_s();\n                 \n                 io::stdout().write_line(\n@@ -468,7 +468,7 @@ fn main(args: ~[~str]) {\n         }\n         \n         let start = time::precise_time_s();\n-        let bfs_tree = pbfs(graph_arc, root);\n+        let bfs_tree = pbfs(graph_arc, *root);\n         let stop = time::precise_time_s();\n \n         total_par += stop - start;\n@@ -478,7 +478,7 @@ fn main(args: ~[~str]) {\n \n         if do_validate {\n             let start = time::precise_time_s();\n-            assert(validate(edges, root, bfs_tree));\n+            assert(validate(edges, *root, bfs_tree));\n             let stop = time::precise_time_s();\n             \n             io::stdout().write_line(fmt!(\"Validation completed in %? seconds.\","}, {"sha": "d220135619bc431b728214f59b9dd1f745483178", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -31,7 +31,7 @@ fn show_color_list(set: ~[color]) -> ~str {\n     let mut out = ~\"\";\n     for vec::eachi(set) |_ii, col| {\n         out += ~\" \";\n-        out += show_color(col);\n+        out += show_color(*col);\n     }\n     return out;\n }\n@@ -131,16 +131,16 @@ fn rendezvous(nn: uint, set: ~[color]) {\n \n     // these channels will allow us to talk to each creature by 'name'/index\n     let to_creature: ~[comm::Chan<Option<creature_info>>] =\n-        vec::mapi(set,\n-            fn@(ii: uint, col: color) -> comm::Chan<Option<creature_info>> {\n-                // create each creature as a listener with a port, and\n-                // give us a channel to talk to each\n-                return do task::spawn_listener |from_rendezvous| {\n-                    creature(ii, col, from_rendezvous, to_rendezvous,\n-                             to_rendezvous_log);\n-                };\n+        vec::mapi(set, |ii, col| {\n+            // create each creature as a listener with a port, and\n+            // give us a channel to talk to each\n+            let ii = ii;\n+            let col = *col;\n+            do task::spawn_listener |from_rendezvous, move ii, move col| {\n+                creature(ii, col, from_rendezvous, to_rendezvous,\n+                         to_rendezvous_log);\n             }\n-        );\n+        });\n \n     let mut creatures_met = 0;\n \n@@ -157,7 +157,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n \n     // tell each creature to stop\n     for vec::eachi(to_creature) |_ii, to_one| {\n-        comm::send(to_one, None);\n+        comm::send(*to_one, None);\n     }\n \n     // save each creature's meeting stats"}, {"sha": "95f39df64dc82a1e60915d7b170177e59347f553", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -147,6 +147,7 @@ fn main(args: ~[~str]) {\n     let streams = vec::to_mut(streams);\n     let mut from_child = ~[];\n     let to_child   = vec::mapi(sizes, |ii, sz| {\n+        let sz = *sz;\n         let mut stream = None;\n         stream <-> streams[ii];\n         let (to_parent_, from_child_) = option::unwrap(stream);"}, {"sha": "a222374c7764fe6d9993495ec17d5a5e65b027bd", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -142,13 +142,14 @@ fn main(args: ~[~str]) {\n    let sizes = ~[1u,2u,3u,4u,6u,12u,18u];\n    let from_child = vec::map (sizes, |_sz| comm::Port() );\n    let to_parent  = vec::mapi(sizes, |ii, _sz| comm::Chan(from_child[ii]) );\n-   let to_child   = vec::mapi(sizes, fn@(ii: uint, sz: uint) -> comm::Chan<~[u8]> {\n-       return do task::spawn_listener |from_parent| {\n+   let to_child   = vec::mapi(sizes, |ii, sz| {\n+       let ii = ii;\n+       let sz = *sz;\n+       do task::spawn_listener |from_parent| {\n          make_sequence_processor(sz, from_parent, to_parent[ii]);\n-      };\n+       }\n    });\n-         \n-   \n+\n    // latch stores true after we've started\n    // reading the sequence of interest\n    let mut proc_mode = false;"}, {"sha": "6fe850f45d02f8ddd628a85751f0a405f8a91c37", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -299,8 +299,10 @@ fn main(argv: ~[~str]) {\n     }\n \n     let readers: ~[fn~() -> word_reader]  = if argv.len() >= 2 {\n-        vec::view(argv, 1u, argv.len()).map(\n-            |f| fn~() -> word_reader { file_word_reader(f) } )\n+        vec::view(argv, 1u, argv.len()).map(|f| {\n+            let f = *f;\n+            fn~() -> word_reader { file_word_reader(f) }\n+        })\n     }\n     else {\n         let num_readers = 50;"}, {"sha": "5953e0b85fb5a03ce0717b70cb979b31d30e6ac2", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -16,7 +16,7 @@ fn main() {\n     assert any_negative;\n \n     // Higher precedence than unary operations:\n-    let abs_v = do vec::map(v) |e| { float::abs(e) };\n+    let abs_v = do vec::map(v) |e| { float::abs(*e) };\n     assert do vec::all(abs_v) |e| { float::is_nonnegative(e) };\n     assert !do vec::any(abs_v) |e| { float::is_negative(e) };\n "}, {"sha": "f0a590badbbc67bb0c682bc1c70c2f4ed422fd5b", "filename": "src/test/run-pass/dvec-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Frun-pass%2Fdvec-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Frun-pass%2Fdvec-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdvec-test.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -20,7 +20,7 @@ fn main() {\n     assert d.len() == exp.len();\n \n     for d.eachi |i, e| {\n-        assert e == exp[i];\n+        assert *e == exp[i];\n     }\n \n     let v = dvec::unwrap(move d);"}, {"sha": "9088f6e3584c4d32f7fa53804af1581fa0d9d742", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -54,7 +54,7 @@ fn add_interfaces(store: int, managed_ip: ~str, device: std::map::HashMap<~str,\n         std::json::List(interfaces) =>\n         {\n           do vec::map(*interfaces) |interface| {\n-                add_interface(store, managed_ip, interface)\n+                add_interface(store, managed_ip, *interface)\n           }\n         }\n         _ =>"}, {"sha": "9ae3cc43913b4c8e892d8f3e398c3a616dea7325", "filename": "src/test/run-pass/iter-eachi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Frun-pass%2Fiter-eachi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Frun-pass%2Fiter-eachi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-eachi.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n     let mut c = 0u;\n     for [1u, 2u, 3u, 4u, 5u]/_.eachi |i, v| {\n-        assert (i + 1u) == v;\n+        assert (i + 1u) == *v;\n         c += 1u;\n     }\n     assert c == 5u;\n@@ -10,7 +10,7 @@ fn main() {\n \n     let mut c = 0u;\n     for Some(1u).eachi |i, v| {\n-        assert (i + 1u) == v;\n+        assert (i + 1u) == *v;\n         c += 1u;\n     }\n     assert c == 1u;"}, {"sha": "11f2cc1efb17fab35d29605d8ca9d799f10e7cc6", "filename": "src/test/run-pass/iter-map-to-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Frun-pass%2Fiter-map-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d59ac3a1989c2d233b04cc8adc9b058690c2544/src%2Ftest%2Frun-pass%2Fiter-map-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-map-to-vec.rs?ref=3d59ac3a1989c2d233b04cc8adc9b058690c2544", "patch": "@@ -1,4 +1,4 @@\n-fn inc(&&x: uint) -> uint { x + 1u }\n+fn inc(x: &uint) -> uint { *x + 1u }\n \n fn main() {\n     assert [1u, 3u]/_.map_to_vec(inc) == ~[2u, 4u];"}]}