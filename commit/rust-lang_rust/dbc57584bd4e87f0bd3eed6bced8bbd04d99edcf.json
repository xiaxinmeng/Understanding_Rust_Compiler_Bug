{"sha": "dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYzU3NTg0YmQ0ZTg3ZjBiZDNlZWQ2YmNlZDhiYmQwNGQ5OWVkY2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-27T22:56:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-27T22:56:08Z"}, "message": "auto merge of #6724 : thestinger/rust/swap_fast, r=thestinger\n\nPassing higher alignment values gives the optimization passes more freedom since it can copy in larger chunks. This change results in rustc outputting the same post-optimization IR as clang for swaps and most copies excluding the lack of information about padding.\r\n\r\nCode snippet:\r\n\r\n```rust\r\n#[inline(never)]\r\nfn swap<T>(x: &mut T, y: &mut T) {\r\n    util::swap(x, y);\r\n}\r\n```\r\n\r\nOriginal IR (for `int`):\r\n\r\n```llvm\r\ndefine internal fastcc void @_ZN9swap_283417_a71830ca3ed2d65d3_00E(i64*, i64*) #1 {\r\nstatic_allocas:\r\n  %2 = icmp eq i64* %0, %1\r\n  br i1 %2, label %_ZN4util9swap_283717_a71830ca3ed2d65d3_00E.exit, label %3\r\n\r\n; <label>:3                                       ; preds = %static_allocas\r\n  %4 = load i64* %0, align 1\r\n  %5 = load i64* %1, align 1\r\n  store i64 %5, i64* %0, align 1\r\n  store i64 %4, i64* %1, align 1\r\n  br label %_ZN4util9swap_283717_a71830ca3ed2d65d3_00E.exit\r\n\r\n_ZN4util9swap_283717_a71830ca3ed2d65d3_00E.exit:  ; preds = %3, %static_allocas\r\n  ret void\r\n}\r\n```\r\n\r\nAfter #6710:\r\n\r\n```llvm\r\ndefine internal fastcc void @_ZN9swap_283017_a71830ca3ed2d65d3_00E(i64* nocapture, i64* nocapture) #1 {\r\nstatic_allocas:\r\n  %2 = load i64* %0, align 1\r\n  %3 = load i64* %1, align 1\r\n  store i64 %3, i64* %0, align 1\r\n  store i64 %2, i64* %1, align 1\r\n  ret void\r\n}\r\n```\r\n\r\nAfter this change:\r\n\r\n```llvm\r\ndefine internal fastcc void @_ZN9swap_283017_a71830ca3ed2d65d3_00E(i64* nocapture, i64* nocapture) #1 {\r\nstatic_allocas:\r\n  %2 = load i64* %0, align 8\r\n  %3 = load i64* %1, align 8\r\n  store i64 %3, i64* %0, align 8\r\n  store i64 %2, i64* %1, align 8\r\n  ret void\r\n}\r\n```\r\n\r\nAnother example:\r\n\r\n```rust\r\n#[inline(never)]\r\nfn set<T>(x: &mut T, y: T) {\r\n    *x = y;\r\n}\r\n```\r\n\r\nBefore, with `(int, int)` (align 1):\r\n\r\n```llvm\r\ndefine internal fastcc void @_ZN8set_282517_8fa972e3f9e451983_00E({ i64, i64 }* nocapture, { i64, i64 }* nocapture) #1 {\r\nstatic_allocas:\r\n  %2 = bitcast { i64, i64 }* %1 to i8*\r\n  %3 = bitcast { i64, i64 }* %0 to i8*\r\n  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %2, i64 16, i32 1, i1 false)\r\n  ret void\r\n}\r\n```\r\n\r\nAfter, with `(int, int)` (align 8):\r\n\r\n```llvm\r\ndefine internal fastcc void @_ZN8set_282617_8fa972e3f9e451983_00E({ i64, i64 }* nocapture, { i64, i64 }* nocapture) #1 {\r\nstatic_allocas:\r\n  %2 = bitcast { i64, i64 }* %1 to i8*\r\n  %3 = bitcast { i64, i64 }* %0 to i8*\r\n  tail call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* %2, i64 16, i32 8, i1 false)\r\n  ret void\r\n}\r\n```", "tree": {"sha": "834f7712e7345b319c0662b0488bc25ee53b8654", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/834f7712e7345b319c0662b0488bc25ee53b8654"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf", "html_url": "https://github.com/rust-lang/rust/commit/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d04ee805b96d34e7c5b316270a730fd9a0c537f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d04ee805b96d34e7c5b316270a730fd9a0c537f", "html_url": "https://github.com/rust-lang/rust/commit/5d04ee805b96d34e7c5b316270a730fd9a0c537f"}, {"sha": "e6c04dea0325af808198306e283c17f90d31fc26", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6c04dea0325af808198306e283c17f90d31fc26", "html_url": "https://github.com/rust-lang/rust/commit/e6c04dea0325af808198306e283c17f90d31fc26"}], "stats": {"total": 311, "additions": 231, "deletions": 80}, "files": [{"sha": "90449e8a17aef1b6c362561f8b0b7b8cf6fa7262", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf", "patch": "@@ -52,7 +52,7 @@ use middle::trans::foreign;\n use middle::trans::glue;\n use middle::trans::inline;\n use middle::trans::machine;\n-use middle::trans::machine::llsize_of;\n+use middle::trans::machine::{llalign_of_min, llsize_of};\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::reachable;\n@@ -1442,12 +1442,7 @@ pub fn with_cond(bcx: block, val: ValueRef, f: &fn(block) -> block) -> block {\n     next_cx\n }\n \n-pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef,\n-                   n_bytes: ValueRef) {\n-    // FIXME (Related to #1645, I think?): Provide LLVM with better\n-    // alignment information when the alignment is statically known (it must\n-    // be nothing more than a constant int, or LLVM complains -- not even a\n-    // constant element of a tydesc works).\n+pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = cx.insn_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n     let key = match ccx.sess.targ_cfg.arch {\n@@ -1462,7 +1457,7 @@ pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef,\n     let src_ptr = PointerCast(cx, src, T_ptr(T_i8()));\n     let dst_ptr = PointerCast(cx, dst, T_ptr(T_i8()));\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n-    let align = C_i32(1i32);\n+    let align = C_i32(align as i32);\n     let volatile = C_i1(false);\n     Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile]);\n }\n@@ -1471,8 +1466,10 @@ pub fn memcpy_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"memcpy_ty\");\n     let ccx = bcx.ccx();\n     if ty::type_is_structural(t) {\n-        let llsz = llsize_of(ccx, type_of::type_of(ccx, t));\n-        call_memcpy(bcx, dst, src, llsz);\n+        let llty = type_of::type_of(ccx, t);\n+        let llsz = llsize_of(ccx, llty);\n+        let llalign = llalign_of_min(ccx, llty);\n+        call_memcpy(bcx, dst, src, llsz, llalign as u32);\n     } else {\n         Store(bcx, Load(bcx, src), dst);\n     }"}, {"sha": "335dd47b78b1fc0cce4158ed5c6e79de1cc2218c", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf", "patch": "@@ -521,7 +521,7 @@ pub fn make_opaque_cbox_take_glue(\n             [opaque_tydesc, sz],\n             expr::SaveIn(rval));\n         let cbox_out = PointerCast(bcx, Load(bcx, rval), llopaquecboxty);\n-        call_memcpy(bcx, cbox_out, cbox_in, sz);\n+        call_memcpy(bcx, cbox_out, cbox_in, sz, 1);\n         Store(bcx, cbox_out, cboxptr);\n \n         // Take the (deeply cloned) type descriptor"}, {"sha": "b0560c40277b841879301b5226b842e968b19852", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 67, "deletions": 29, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf", "patch": "@@ -787,7 +787,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                 let llsrcptr = PointerCast(bcx, llsrcptr, T_ptr(T_i8()));\n \n                 let llsize = llsize_of(ccx, llintype);\n-                call_memcpy(bcx, lldestptr, llsrcptr, llsize);\n+                call_memcpy(bcx, lldestptr, llsrcptr, llsize, 1);\n             }\n         }\n         ~\"needs_drop\" => {\n@@ -846,44 +846,82 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             Store(bcx, morestack_addr, fcx.llretptr.get());\n         }\n         ~\"memcpy32\" => {\n-            let dst_ptr = get_param(decl, first_real_arg);\n-            let src_ptr = get_param(decl, first_real_arg + 1);\n-            let size = get_param(decl, first_real_arg + 2);\n-            let align = C_i32(1);\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+            let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n+\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(\n-                &~\"llvm.memcpy.p0i8.p0i8.i32\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, size, align, volatile]);\n+            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memcpy.p0i8.p0i8.i32\");\n+            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n         ~\"memcpy64\" => {\n-            let dst_ptr = get_param(decl, first_real_arg);\n-            let src_ptr = get_param(decl, first_real_arg + 1);\n-            let size = get_param(decl, first_real_arg + 2);\n-            let align = C_i32(1);\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+            let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n+\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(\n-                &~\"llvm.memcpy.p0i8.p0i8.i64\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, size, align, volatile]);\n+            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memcpy.p0i8.p0i8.i64\");\n+            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n         ~\"memmove32\" => {\n-            let dst_ptr = get_param(decl, first_real_arg);\n-            let src_ptr = get_param(decl, first_real_arg + 1);\n-            let size = get_param(decl, first_real_arg + 2);\n-            let align = C_i32(1);\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+            let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n+\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(\n-                &~\"llvm.memmove.p0i8.p0i8.i32\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, size, align, volatile]);\n+            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memmove.p0i8.p0i8.i32\");\n+            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n         ~\"memmove64\" => {\n-            let dst_ptr = get_param(decl, first_real_arg);\n-            let src_ptr = get_param(decl, first_real_arg + 1);\n-            let size = get_param(decl, first_real_arg + 2);\n-            let align = C_i32(1);\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+            let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n+\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n+            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n+            let count = get_param(decl, first_real_arg + 2);\n+            let volatile = C_i1(false);\n+            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memmove.p0i8.p0i8.i64\");\n+            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n+        }\n+        ~\"memset32\" => {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+            let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n+\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n+            let val = get_param(decl, first_real_arg + 1);\n+            let count = get_param(decl, first_real_arg + 2);\n+            let volatile = C_i1(false);\n+            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memset.p0i8.i32\");\n+            Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n+        }\n+        ~\"memset64\" => {\n+            let tp_ty = substs.tys[0];\n+            let lltp_ty = type_of::type_of(ccx, tp_ty);\n+            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+            let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n+\n+            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), T_ptr(T_i8()));\n+            let val = get_param(decl, first_real_arg + 1);\n+            let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(\n-                &~\"llvm.memmove.p0i8.p0i8.i64\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, size, align, volatile]);\n+            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memset.p0i8.i64\");\n+            Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n         }\n         ~\"sqrtf32\" => {\n             let x = get_param(decl, first_real_arg);"}, {"sha": "278a73558926c2adf2ef97174b8fdb81ef65ae04", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf", "patch": "@@ -125,7 +125,7 @@ pub fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> Result {\n \n     let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr));\n     let new_data_ptr = get_dataptr(bcx, get_bodyptr(bcx, newptr));\n-    base::call_memcpy(bcx, new_data_ptr, data_ptr, fill);\n+    base::call_memcpy(bcx, new_data_ptr, data_ptr, fill, 1);\n \n     let bcx = if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n         iter_vec_raw(bcx, new_data_ptr, vec_ty, fill, glue::take_ty)\n@@ -370,7 +370,7 @@ pub fn write_content(bcx: block,\n                     let bytes = s.len() + 1; // copy null-terminator too\n                     let llbytes = C_uint(bcx.ccx(), bytes);\n                     let llcstr = C_cstr(bcx.ccx(), s);\n-                    base::call_memcpy(bcx, lldest, llcstr, llbytes);\n+                    base::call_memcpy(bcx, lldest, llcstr, llbytes, 1);\n                     return bcx;\n                 }\n             }"}, {"sha": "ceb229c79bd9828d4a459c6a179bd4b10d21626a", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf", "patch": "@@ -135,7 +135,8 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n                 ~\"visit_tydesc\"  | ~\"forget\" | ~\"frame_address\" |\n                 ~\"morestack_addr\" => 0,\n \n-                ~\"memcpy32\" | ~\"memcpy64\" | ~\"memmove32\" | ~\"memmove64\" => 0,\n+                ~\"memcpy32\" | ~\"memcpy64\" | ~\"memmove32\" | ~\"memmove64\" |\n+                ~\"memset32\" | ~\"memset64\" => use_repr,\n \n                 ~\"sqrtf32\" | ~\"sqrtf64\" | ~\"powif32\" | ~\"powif64\" |\n                 ~\"sinf32\"  | ~\"sinf64\"  | ~\"cosf32\"  | ~\"cosf64\"  |"}, {"sha": "e700b8760fd6f6f81d52bc91ffe990aff68a62ff", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf", "patch": "@@ -3538,65 +3538,89 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n           (0u, ~[], ty::mk_nil_ptr(ccx.tcx))\n         }\n         ~\"memcpy32\" => {\n-          (0,\n+          (1,\n            ~[\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_mutbl\n               }),\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_imm\n               }),\n               ty::mk_u32()\n            ],\n            ty::mk_nil())\n         }\n         ~\"memcpy64\" => {\n-          (0,\n+          (1,\n            ~[\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_mutbl\n               }),\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_imm\n               }),\n               ty::mk_u64()\n            ],\n            ty::mk_nil())\n         }\n         ~\"memmove32\" => {\n-          (0,\n+          (1,\n            ~[\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_mutbl\n               }),\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_imm\n               }),\n               ty::mk_u32()\n            ],\n            ty::mk_nil())\n         }\n         ~\"memmove64\" => {\n-          (0,\n+          (1,\n            ~[\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_mutbl\n               }),\n               ty::mk_ptr(tcx, ty::mt {\n-                  ty: ty::mk_u8(),\n+                  ty: param(ccx, 0),\n                   mutbl: ast::m_imm\n               }),\n               ty::mk_u64()\n            ],\n            ty::mk_nil())\n         }\n+        ~\"memset32\" => {\n+          (1,\n+           ~[\n+              ty::mk_ptr(tcx, ty::mt {\n+                  ty: param(ccx, 0),\n+                  mutbl: ast::m_mutbl\n+              }),\n+              ty::mk_u8(),\n+              ty::mk_u32()\n+           ],\n+           ty::mk_nil())\n+        }\n+        ~\"memset64\" => {\n+          (1,\n+           ~[\n+              ty::mk_ptr(tcx, ty::mt {\n+                  ty: param(ccx, 0),\n+                  mutbl: ast::m_mutbl\n+              }),\n+              ty::mk_u8(),\n+              ty::mk_u64()\n+           ],\n+           ty::mk_nil())\n+        }\n         ~\"sqrtf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n         ~\"sqrtf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n         ~\"powif32\" => {"}, {"sha": "30ad41f0ca2a9b195c5cb1ed12955680d0b45018", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf", "patch": "@@ -14,8 +14,9 @@ use sys;\n use unstable::intrinsics;\n \n /// Casts the value at `src` to U. The two types must have the same length.\n+#[cfg(stage0)]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    let mut dest: U = intrinsics::init();\n+    let mut dest: U = intrinsics::uninit();\n     {\n         let dest_ptr: *mut u8 = transmute(&mut dest);\n         let src_ptr: *u8 = transmute(src);\n@@ -26,6 +27,26 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n     dest\n }\n \n+#[cfg(target_word_size = \"32\", not(stage0))]\n+#[inline(always)]\n+pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n+    let mut dest: U = intrinsics::uninit();\n+    let dest_ptr: *mut u8 = transmute(&mut dest);\n+    let src_ptr: *u8 = transmute(src);\n+    intrinsics::memcpy32(dest_ptr, src_ptr, sys::size_of::<U>() as u32);\n+    dest\n+}\n+\n+#[cfg(target_word_size = \"64\", not(stage0))]\n+#[inline(always)]\n+pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n+    let mut dest: U = intrinsics::uninit();\n+    let dest_ptr: *mut u8 = transmute(&mut dest);\n+    let src_ptr: *u8 = transmute(src);\n+    intrinsics::memcpy64(dest_ptr, src_ptr, sys::size_of::<U>() as u64);\n+    dest\n+}\n+\n /**\n  * Move a thing into the void\n  *\n@@ -43,6 +64,7 @@ pub unsafe fn forget<T>(thing: T) { intrinsics::forget(thing); }\n  * and/or reinterpret_cast when such calls would otherwise scramble a box's\n  * reference count\n  */\n+#[inline(always)]\n pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n \n /**"}, {"sha": "309129b7f13e4506f22be28dd2f712048198f903", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 65, "deletions": 19, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf", "patch": "@@ -19,19 +19,14 @@ use sys;\n #[cfg(not(test))] use cmp::{Eq, Ord};\n use uint;\n \n+#[cfg(stage0)]\n pub mod libc_ {\n     use libc::c_void;\n     use libc;\n \n     #[nolink]\n     #[abi = \"cdecl\"]\n     pub extern {\n-        #[rust_stack]\n-        unsafe fn memmove(dest: *mut c_void,\n-                          src: *const c_void,\n-                          n: libc::size_t)\n-                       -> *c_void;\n-\n         #[rust_stack]\n         unsafe fn memset(dest: *mut c_void,\n                          c: libc::c_int,\n@@ -97,49 +92,92 @@ pub fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n  * and destination may overlap.\n  */\n #[inline(always)]\n-#[cfg(target_word_size = \"32\")]\n+#[cfg(target_word_size = \"32\", stage0)]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memmove32;\n     let n = count * sys::size_of::<T>();\n     memmove32(dst as *mut u8, src as *u8, n as u32);\n }\n \n+/**\n+ * Copies data from one location to another\n+ *\n+ * Copies `count` elements (not bytes) from `src` to `dst`. The source\n+ * and destination may overlap.\n+ */\n #[inline(always)]\n-#[cfg(target_word_size = \"64\")]\n+#[cfg(target_word_size = \"32\", not(stage0))]\n+pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n+    use unstable::intrinsics::memmove32;\n+    memmove32(dst, src as *T, count as u32);\n+}\n+\n+#[inline(always)]\n+#[cfg(target_word_size = \"64\", stage0)]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     use unstable::intrinsics::memmove64;\n     let n = count * sys::size_of::<T>();\n     memmove64(dst as *mut u8, src as *u8, n as u64);\n }\n \n #[inline(always)]\n-#[cfg(target_word_size = \"32\")]\n+#[cfg(target_word_size = \"64\", not(stage0))]\n+pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n+    use unstable::intrinsics::memmove64;\n+    memmove64(dst, src as *T, count as u64);\n+}\n+\n+#[inline(always)]\n+#[cfg(target_word_size = \"32\", stage0)]\n+pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n+    use unstable::intrinsics::memmove32;\n+    let n = count * sys::size_of::<T>();\n+    memmove32(dst as *mut u8, src as *u8, n as u32);\n+}\n+\n+#[inline(always)]\n+#[cfg(target_word_size = \"32\", not(stage0))]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    #[cfg(stage0)]\n-    use memcpy32 = unstable::intrinsics::memmove32;\n-    #[cfg(not(stage0))]\n     use unstable::intrinsics::memcpy32;\n+    memcpy32(dst, src as *T, count as u32);\n+}\n+\n+#[inline(always)]\n+#[cfg(target_word_size = \"64\", stage0)]\n+pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n+    use unstable::intrinsics::memmove64;\n     let n = count * sys::size_of::<T>();\n-    memcpy32(dst as *mut u8, src as *u8, n as u32);\n+    memmove64(dst as *mut u8, src as *u8, n as u64);\n }\n \n #[inline(always)]\n-#[cfg(target_word_size = \"64\")]\n+#[cfg(target_word_size = \"64\", not(stage0))]\n pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    #[cfg(stage0)]\n-    use memcpy64 = unstable::intrinsics::memmove64;\n-    #[cfg(not(stage0))]\n     use unstable::intrinsics::memcpy64;\n-    let n = count * sys::size_of::<T>();\n-    memcpy64(dst as *mut u8, src as *u8, n as u64);\n+    memcpy64(dst, src as *T, count as u64);\n }\n \n #[inline(always)]\n+#[cfg(stage0)]\n pub unsafe fn set_memory<T>(dst: *mut T, c: int, count: uint) {\n     let n = count * sys::size_of::<T>();\n     libc_::memset(dst as *mut c_void, c as libc::c_int, n as size_t);\n }\n \n+#[inline(always)]\n+#[cfg(target_word_size = \"32\", not(stage0))]\n+pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n+    use unstable::intrinsics::memset32;\n+    memset32(dst, c, count as u32);\n+}\n+\n+#[inline(always)]\n+#[cfg(target_word_size = \"64\", not(stage0))]\n+pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n+    use unstable::intrinsics::memset64;\n+    memset64(dst, c, count as u64);\n+}\n+\n /**\n   Transform a region pointer - &T - to an unsafe pointer - *T.\n   This is safe, but is implemented with an unsafe block due to\n@@ -581,4 +619,12 @@ pub mod ptr_tests {\n             });\n         }\n     }\n+\n+    #[test]\n+    fn test_set_memory() {\n+        let mut xs = [0u8, ..20];\n+        let ptr = vec::raw::to_mut_ptr(xs);\n+        unsafe { set_memory(ptr, 5u8, xs.len()); }\n+        assert_eq!(xs, [5u8, ..20]);\n+    }\n }"}, {"sha": "908c5e23ab070c567275c9e08b69fbed2767eeec", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=dbc57584bd4e87f0bd3eed6bced8bbd04d99edcf", "patch": "@@ -16,7 +16,7 @@ The corresponding definitions are in librustc/middle/trans/foreign.rs.\n \n The atomic intrinsics provide common atomic operations on machine\n words, with multiple possible memory orderings. They obey the same\n-semantics as C++0x. See the LLVM documentation on [[atomics]].\n+semantics as C++11. See the LLVM documentation on [[atomics]].\n \n [atomics]: http://llvm.org/docs/Atomics.html\n \n@@ -31,6 +31,7 @@ A quick refresher on memory ordering:\n   with atomic types and is equivalent to Java's `volatile`.\n \n */\n+\n #[abi = \"rust-intrinsic\"]\n pub extern \"rust-intrinsic\" {\n \n@@ -127,18 +128,40 @@ pub extern \"rust-intrinsic\" {\n     /// Get the address of the `__morestack` stack growth function.\n     pub fn morestack_addr() -> *();\n \n-    /// Equivalent to the `llvm.memcpy.p0i8.0i8.i32` intrinsic.\n+    /// Equivalent to the `llvm.memcpy.p0i8.0i8.i32` intrinsic, with a size of\n+    /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n     #[cfg(not(stage0))]\n-    pub fn memcpy32(dst: *mut u8, src: *u8, size: u32);\n-    /// Equivalent to the `llvm.memcpy.p0i8.0i8.i64` intrinsic.\n+    pub fn memcpy32<T>(dst: *mut T, src: *T, count: u32);\n+    /// Equivalent to the `llvm.memcpy.p0i8.0i8.i64` intrinsic, with a size of\n+    /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n     #[cfg(not(stage0))]\n-    pub fn memcpy64(dst: *mut u8, src: *u8, size: u64);\n+    pub fn memcpy64<T>(dst: *mut T, src: *T, count: u64);\n \n     /// Equivalent to the `llvm.memmove.p0i8.0i8.i32` intrinsic.\n+    #[cfg(stage0)]\n     pub fn memmove32(dst: *mut u8, src: *u8, size: u32);\n     /// Equivalent to the `llvm.memmove.p0i8.0i8.i64` intrinsic.\n+    #[cfg(stage0)]\n     pub fn memmove64(dst: *mut u8, src: *u8, size: u64);\n \n+    /// Equivalent to the `llvm.memmove.p0i8.0i8.i32` intrinsic, with a size of\n+    /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n+    #[cfg(not(stage0))]\n+    pub fn memmove32<T>(dst: *mut T, src: *T, count: u32);\n+    /// Equivalent to the `llvm.memmove.p0i8.0i8.i64` intrinsic, with a size of\n+    /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n+    #[cfg(not(stage0))]\n+    pub fn memmove64<T>(dst: *mut T, src: *T, count: u64);\n+\n+    /// Equivalent to the `llvm.memset.p0i8.i32` intrinsic, with a size of\n+    /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n+    #[cfg(not(stage0))]\n+    pub fn memset32<T>(dst: *mut T, val: u8, count: u32);\n+    /// Equivalent to the `llvm.memset.p0i8.i64` intrinsic, with a size of\n+    /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n+    #[cfg(not(stage0))]\n+    pub fn memset64<T>(dst: *mut T, val: u8, count: u64);\n+\n     pub fn sqrtf32(x: f32) -> f32;\n     pub fn sqrtf64(x: f64) -> f64;\n "}]}