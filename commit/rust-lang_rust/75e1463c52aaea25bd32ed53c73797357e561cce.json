{"sha": "75e1463c52aaea25bd32ed53c73797357e561cce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZTE0NjNjNTJhYWVhMjViZDMyZWQ1M2M3Mzc5NzM1N2U1NjFjY2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-13T14:29:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-13T14:29:56Z"}, "message": "Auto merge of #72013 - nnethercote:make-RawVec-grow-mostly-non-generic, r=Amanieu\n\nMake `RawVec::grow` mostly non-generic.\n\n`cargo-llvm-lines` shows that, in various benchmarks, `RawVec::grow` is\ninstantiated 10s or 100s of times and accounts for 1-8% of lines of\ngenerated LLVM IR.\n\nThis commit moves most of `RawVec::grow` into a separate function that\nisn't parameterized by `T`, which means it doesn't need to be\ninstantiated many times. This reduces compile time significantly.\n\nr? @ghost", "tree": {"sha": "0b9c61044c2ccb5a09931fe6e0bbb8d734884b91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b9c61044c2ccb5a09931fe6e0bbb8d734884b91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75e1463c52aaea25bd32ed53c73797357e561cce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75e1463c52aaea25bd32ed53c73797357e561cce", "html_url": "https://github.com/rust-lang/rust/commit/75e1463c52aaea25bd32ed53c73797357e561cce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75e1463c52aaea25bd32ed53c73797357e561cce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "750db09fa800dceebba57d609d42969172118c92", "url": "https://api.github.com/repos/rust-lang/rust/commits/750db09fa800dceebba57d609d42969172118c92", "html_url": "https://github.com/rust-lang/rust/commit/750db09fa800dceebba57d609d42969172118c92"}, {"sha": "68b75033ad78d88872450a81745cacfc11e58178", "url": "https://api.github.com/repos/rust-lang/rust/commits/68b75033ad78d88872450a81745cacfc11e58178", "html_url": "https://github.com/rust-lang/rust/commit/68b75033ad78d88872450a81745cacfc11e58178"}], "stats": {"total": 244, "additions": 95, "deletions": 149}, "files": [{"sha": "540649c61b332345e59f143efcc318839d39bd7f", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/75e1463c52aaea25bd32ed53c73797357e561cce/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e1463c52aaea25bd32ed53c73797357e561cce/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=75e1463c52aaea25bd32ed53c73797357e561cce", "patch": "@@ -1354,7 +1354,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, value: T) {\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         self.tail = self.wrap_sub(self.tail, 1);\n         let tail = self.tail;\n@@ -1377,7 +1379,9 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, value: T) {\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         let head = self.head;\n         self.head = self.wrap_add(self.head, 1);\n@@ -1485,7 +1489,9 @@ impl<T> VecDeque<T> {\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn insert(&mut self, index: usize, value: T) {\n         assert!(index <= self.len(), \"index out of bounds\");\n-        self.grow_if_necessary();\n+        if self.is_full() {\n+            self.grow();\n+        }\n \n         // Move the least number of elements in the ring buffer and insert\n         // the given object\n@@ -2003,11 +2009,13 @@ impl<T> VecDeque<T> {\n     }\n \n     // This may panic or abort\n-    #[inline]\n-    fn grow_if_necessary(&mut self) {\n+    #[inline(never)]\n+    fn grow(&mut self) {\n         if self.is_full() {\n             let old_cap = self.cap();\n-            self.buf.double();\n+            // Double the buffer size.\n+            self.buf.reserve_exact(old_cap, old_cap);\n+            assert!(self.cap() == old_cap * 2);\n             unsafe {\n                 self.handle_capacity_increase(old_cap);\n             }"}, {"sha": "d46bf81f996f73433649a331789e2203475695a3", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 81, "deletions": 143, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/75e1463c52aaea25bd32ed53c73797357e561cce/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e1463c52aaea25bd32ed53c73797357e561cce/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=75e1463c52aaea25bd32ed53c73797357e561cce", "patch": "@@ -1,7 +1,7 @@\n #![unstable(feature = \"raw_vec_internals\", reason = \"implementation detail\", issue = \"none\")]\n #![doc(hidden)]\n \n-use core::alloc::MemoryBlock;\n+use core::alloc::{LayoutErr, MemoryBlock};\n use core::cmp;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::Drop;\n@@ -211,82 +211,6 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         }\n     }\n \n-    /// Doubles the size of the type's backing allocation. This is common enough\n-    /// to want to do that it's easiest to just have a dedicated method. Slightly\n-    /// more efficient logic can be provided for this than the general case.\n-    ///\n-    /// This function is ideal for when pushing elements one-at-a-time because\n-    /// you don't need to incur the costs of the more general computations\n-    /// reserve needs to do to guard against overflow. You do however need to\n-    /// manually check if your `len == capacity`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n-    ///   all `usize::MAX` slots in your imaginary buffer.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    ///\n-    /// # Aborts\n-    ///\n-    /// Aborts on OOM\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(raw_vec_internals)]\n-    /// # extern crate alloc;\n-    /// # use std::ptr;\n-    /// # use alloc::raw_vec::RawVec;\n-    /// struct MyVec<T> {\n-    ///     buf: RawVec<T>,\n-    ///     len: usize,\n-    /// }\n-    ///\n-    /// impl<T> MyVec<T> {\n-    ///     pub fn push(&mut self, elem: T) {\n-    ///         if self.len == self.buf.capacity() { self.buf.double(); }\n-    ///         // double would have aborted or panicked if the len exceeded\n-    ///         // `isize::MAX` so this is safe to do unchecked now.\n-    ///         unsafe {\n-    ///             ptr::write(self.buf.ptr().add(self.len), elem);\n-    ///         }\n-    ///         self.len += 1;\n-    ///     }\n-    /// }\n-    /// # fn main() {\n-    /// #   let mut vec = MyVec { buf: RawVec::new(), len: 0 };\n-    /// #   vec.push(1);\n-    /// # }\n-    /// ```\n-    #[inline(never)]\n-    #[cold]\n-    pub fn double(&mut self) {\n-        match self.grow(Double, MayMove, Uninitialized) {\n-            Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n-            Ok(()) => { /* yay */ }\n-        }\n-    }\n-\n-    /// Attempts to double the size of the type's backing allocation in place. This is common\n-    /// enough to want to do that it's easiest to just have a dedicated method. Slightly\n-    /// more efficient logic can be provided for this than the general case.\n-    ///\n-    /// Returns `true` if the reallocation attempt has succeeded.\n-    ///\n-    /// # Panics\n-    ///\n-    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n-    ///   all `usize::MAX` slots in your imaginary buffer.\n-    /// * Panics on 32-bit platforms if the requested capacity exceeds\n-    ///   `isize::MAX` bytes.\n-    #[inline(never)]\n-    #[cold]\n-    pub fn double_in_place(&mut self) -> bool {\n-        self.grow(Double, InPlace, Uninitialized).is_ok()\n-    }\n-\n     /// Ensures that the buffer contains at least enough space to hold\n     /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n     /// enough capacity, will reallocate enough space plus comfortable slack\n@@ -354,7 +278,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         needed_extra_capacity: usize,\n     ) -> Result<(), TryReserveError> {\n         if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Amortized { used_capacity, needed_extra_capacity }, MayMove, Uninitialized)\n+            self.grow_amortized(used_capacity, needed_extra_capacity, MayMove)\n         } else {\n             Ok(())\n         }\n@@ -381,8 +305,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         // This is more readable than putting this in one line:\n         // `!self.needs_to_grow(...) || self.grow(...).is_ok()`\n         if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Amortized { used_capacity, needed_extra_capacity }, InPlace, Uninitialized)\n-                .is_ok()\n+            self.grow_amortized(used_capacity, needed_extra_capacity, InPlace).is_ok()\n         } else {\n             true\n         }\n@@ -423,7 +346,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         needed_extra_capacity: usize,\n     ) -> Result<(), TryReserveError> {\n         if self.needs_to_grow(used_capacity, needed_extra_capacity) {\n-            self.grow(Exact { used_capacity, needed_extra_capacity }, MayMove, Uninitialized)\n+            self.grow_exact(used_capacity, needed_extra_capacity)\n         } else {\n             Ok(())\n         }\n@@ -448,14 +371,6 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-enum Strategy {\n-    Double,\n-    Amortized { used_capacity: usize, needed_extra_capacity: usize },\n-    Exact { used_capacity: usize, needed_extra_capacity: usize },\n-}\n-use Strategy::*;\n-\n impl<T, A: AllocRef> RawVec<T, A> {\n     /// Returns if the buffer needs to grow to fulfill the needed extra capacity.\n     /// Mainly used to make inlining reserve-calls possible without inlining `grow`.\n@@ -473,68 +388,59 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         self.cap = Self::capacity_from_bytes(memory.size);\n     }\n \n-    /// Single method to handle all possibilities of growing the buffer.\n-    fn grow(\n+    // This method is usually instantiated many times. So we want it to be as\n+    // small as possible, to improve compile times. But we also want as much of\n+    // its contents to be statically computable as possible, to make the\n+    // generated code run faster. Therefore, this method is carefully written\n+    // so that all of the code that depends on `T` is within it, while as much\n+    // of the code that doesn't depend on `T` as possible is in functions that\n+    // are non-generic over `T`.\n+    fn grow_amortized(\n         &mut self,\n-        strategy: Strategy,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n         placement: ReallocPlacement,\n-        init: AllocInit,\n     ) -> Result<(), TryReserveError> {\n-        let elem_size = mem::size_of::<T>();\n-        if elem_size == 0 {\n+        if mem::size_of::<T>() == 0 {\n             // Since we return a capacity of `usize::MAX` when `elem_size` is\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             return Err(CapacityOverflow);\n         }\n-        let new_layout = match strategy {\n-            Double => unsafe {\n-                // Since we guarantee that we never allocate more than `isize::MAX` bytes,\n-                // `elem_size * self.cap <= isize::MAX` as a precondition, so this can't overflow.\n-                // Additionally the alignment will never be too large as to \"not be satisfiable\",\n-                // so `Layout::from_size_align` will always return `Some`.\n-                //\n-                // TL;DR, we bypass runtime checks due to dynamic assertions in this module,\n-                // allowing us to use `from_size_align_unchecked`.\n-                let cap = if self.cap == 0 {\n-                    // Skip to 4 because tiny `Vec`'s are dumb; but not if that would cause overflow.\n-                    if elem_size > usize::MAX / 8 { 1 } else { 4 }\n-                } else {\n-                    self.cap * 2\n-                };\n-                Layout::from_size_align_unchecked(cap * elem_size, mem::align_of::<T>())\n-            },\n-            Amortized { used_capacity, needed_extra_capacity } => {\n-                // Nothing we can really do about these checks, sadly.\n-                let required_cap =\n-                    used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n-                // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n-                let double_cap = self.cap * 2;\n-                // `double_cap` guarantees exponential growth.\n-                let cap = cmp::max(double_cap, required_cap);\n-                Layout::array::<T>(cap).map_err(|_| CapacityOverflow)?\n-            }\n-            Exact { used_capacity, needed_extra_capacity } => {\n-                let cap =\n-                    used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n-                Layout::array::<T>(cap).map_err(|_| CapacityOverflow)?\n-            }\n-        };\n-        alloc_guard(new_layout.size())?;\n \n-        let memory = if let Some((ptr, old_layout)) = self.current_memory() {\n-            debug_assert_eq!(old_layout.align(), new_layout.align());\n-            unsafe {\n-                self.alloc\n-                    .grow(ptr, old_layout, new_layout.size(), placement, init)\n-                    .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n-            }\n-        } else {\n-            match placement {\n-                MayMove => self.alloc.alloc(new_layout, init),\n-                InPlace => Err(AllocErr),\n-            }\n-            .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n-        };\n+        // Nothing we can really do about these checks, sadly.\n+        let required_cap =\n+            used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n+        // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n+        let double_cap = self.cap * 2;\n+        // `double_cap` guarantees exponential growth.\n+        let cap = cmp::max(double_cap, required_cap);\n+        let new_layout = Layout::array::<T>(cap);\n+\n+        // `finish_grow` is non-generic over `T`.\n+        let memory = finish_grow(new_layout, placement, self.current_memory(), &mut self.alloc)?;\n+        self.set_memory(memory);\n+        Ok(())\n+    }\n+\n+    // The constraints on this method are much the same as those on\n+    // `grow_amortized`, but this method is usually instantiated less often so\n+    // it's less critical.\n+    fn grow_exact(\n+        &mut self,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n+    ) -> Result<(), TryReserveError> {\n+        if mem::size_of::<T>() == 0 {\n+            // Since we return a capacity of `usize::MAX` when the type size is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n+            return Err(CapacityOverflow);\n+        }\n+\n+        let cap = used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?;\n+        let new_layout = Layout::array::<T>(cap);\n+\n+        // `finish_grow` is non-generic over `T`.\n+        let memory = finish_grow(new_layout, MayMove, self.current_memory(), &mut self.alloc)?;\n         self.set_memory(memory);\n         Ok(())\n     }\n@@ -562,6 +468,38 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n }\n \n+// This function is outside `RawVec` to minimize compile times. See the comment\n+// above `RawVec::grow_amortized` for details. (The `A` parameter isn't\n+// significant, because the number of different `A` types seen in practice is\n+// much smaller than the number of `T` types.)\n+fn finish_grow<A>(\n+    new_layout: Result<Layout, LayoutErr>,\n+    placement: ReallocPlacement,\n+    current_memory: Option<(NonNull<u8>, Layout)>,\n+    alloc: &mut A,\n+) -> Result<MemoryBlock, TryReserveError>\n+where\n+    A: AllocRef,\n+{\n+    // Check for the error here to minimize the size of `RawVec::grow_*`.\n+    let new_layout = new_layout.map_err(|_| CapacityOverflow)?;\n+\n+    alloc_guard(new_layout.size())?;\n+\n+    let memory = if let Some((ptr, old_layout)) = current_memory {\n+        debug_assert_eq!(old_layout.align(), new_layout.align());\n+        unsafe { alloc.grow(ptr, old_layout, new_layout.size(), placement, Uninitialized) }\n+    } else {\n+        match placement {\n+            MayMove => alloc.alloc(new_layout, Uninitialized),\n+            InPlace => Err(AllocErr),\n+        }\n+    }\n+    .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?;\n+\n+    Ok(memory)\n+}\n+\n impl<T> RawVec<T, Global> {\n     /// Converts the entire buffer into `Box<[MaybeUninit<T>]>` with the specified `len`.\n     ///"}]}