{"sha": "8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZDBmMGNjM2E3YTZjMGYxNWE5YjIxNGNmYTVmMDc0NDcxM2MxNzg=", "commit": {"author": {"name": "Masood Malekghassemi", "email": "atash@google.com", "date": "2016-03-29T04:56:19Z"}, "committer": {"name": "Masood Malekghassemi", "email": "atash@google.com", "date": "2016-03-29T05:10:26Z"}, "message": "Refactor s.t. TypeRelation implementors don't escape InferCtxt", "tree": {"sha": "8a6c09ecf38c6f5fec812dbecc80309371adc0f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a6c09ecf38c6f5fec812dbecc80309371adc0f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178", "html_url": "https://github.com/rust-lang/rust/commit/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178/comments", "author": {"login": "soltanmm-google", "id": 21180148, "node_id": "MDQ6VXNlcjIxMTgwMTQ4", "avatar_url": "https://avatars.githubusercontent.com/u/21180148?v=4", "gravatar_id": "", "url": "https://api.github.com/users/soltanmm-google", "html_url": "https://github.com/soltanmm-google", "followers_url": "https://api.github.com/users/soltanmm-google/followers", "following_url": "https://api.github.com/users/soltanmm-google/following{/other_user}", "gists_url": "https://api.github.com/users/soltanmm-google/gists{/gist_id}", "starred_url": "https://api.github.com/users/soltanmm-google/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/soltanmm-google/subscriptions", "organizations_url": "https://api.github.com/users/soltanmm-google/orgs", "repos_url": "https://api.github.com/users/soltanmm-google/repos", "events_url": "https://api.github.com/users/soltanmm-google/events{/privacy}", "received_events_url": "https://api.github.com/users/soltanmm-google/received_events", "type": "User", "site_admin": false}, "committer": {"login": "soltanmm-google", "id": 21180148, "node_id": "MDQ6VXNlcjIxMTgwMTQ4", "avatar_url": "https://avatars.githubusercontent.com/u/21180148?v=4", "gravatar_id": "", "url": "https://api.github.com/users/soltanmm-google", "html_url": "https://github.com/soltanmm-google", "followers_url": "https://api.github.com/users/soltanmm-google/followers", "following_url": "https://api.github.com/users/soltanmm-google/following{/other_user}", "gists_url": "https://api.github.com/users/soltanmm-google/gists{/gist_id}", "starred_url": "https://api.github.com/users/soltanmm-google/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/soltanmm-google/subscriptions", "organizations_url": "https://api.github.com/users/soltanmm-google/orgs", "repos_url": "https://api.github.com/users/soltanmm-google/repos", "events_url": "https://api.github.com/users/soltanmm-google/events{/privacy}", "received_events_url": "https://api.github.com/users/soltanmm-google/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f10a12c49f80e8dd277907b9d669dee54b67341a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f10a12c49f80e8dd277907b9d669dee54b67341a", "html_url": "https://github.com/rust-lang/rust/commit/f10a12c49f80e8dd277907b9d669dee54b67341a"}], "stats": {"total": 101, "additions": 56, "deletions": 45}, "files": [{"sha": "725c6d9593cdda9c5cc9055fe99a6301a28af591", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178", "patch": "@@ -407,7 +407,7 @@ pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n             origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n             values: Types(expected_found(true, a, b))\n         };\n-        cx.sub(true, trace).relate(&a, &b).map(|_| ())\n+        cx.sub(true, trace, &a, &b).map(|_| ())\n     })\n }\n \n@@ -668,32 +668,32 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                        cause: None}\n     }\n \n-    // public so that it can be used from the rustc_driver unit tests\n-    pub fn equate(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-              -> equate::Equate<'a, 'tcx>\n+    pub fn equate<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n+        -> RelateResult<'tcx, T>\n+        where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).equate()\n+        self.combine_fields(a_is_expected, trace).equate().relate(a, b)\n     }\n \n-    // public so that it can be used from the rustc_driver unit tests\n-    pub fn sub(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-               -> sub::Sub<'a, 'tcx>\n+    pub fn sub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n+        -> RelateResult<'tcx, T>\n+        where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).sub()\n+        self.combine_fields(a_is_expected, trace).sub().relate(a, b)\n     }\n \n-    // public so that it can be used from the rustc_driver unit tests\n-    pub fn lub(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-               -> lub::Lub<'a, 'tcx>\n+    pub fn lub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n+        -> RelateResult<'tcx, T>\n+        where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).lub()\n+        self.combine_fields(a_is_expected, trace).lub().relate(a, b)\n     }\n \n-    // public so that it can be used from the rustc_driver unit tests\n-    pub fn glb(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-               -> glb::Glb<'a, 'tcx>\n+    pub fn glb<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n+        -> RelateResult<'tcx, T>\n+        where T: Relate<'a, 'tcx>\n     {\n-        self.combine_fields(a_is_expected, trace).glb()\n+        self.combine_fields(a_is_expected, trace).glb().relate(a, b)\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n@@ -834,7 +834,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"sub_types({:?} <: {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n+            self.sub(a_is_expected, trace, &a, &b).map(|_| ())\n         })\n     }\n \n@@ -847,7 +847,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     {\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.equate(a_is_expected, trace).relate(&a, &b).map(|_| ())\n+            self.equate(a_is_expected, trace, &a, &b).map(|_| ())\n         })\n     }\n \n@@ -866,7 +866,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.equate(a_is_expected, trace).relate(&a, &b).map(|_| ())\n+            self.equate(a_is_expected, trace, &a, &b).map(|_| ())\n         })\n     }\n \n@@ -885,7 +885,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: origin,\n                 values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n+            self.sub(a_is_expected, trace, &a, &b).map(|_| ())\n         })\n     }\n \n@@ -1434,7 +1434,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n                 values: Types(expected_found(true, e, e))\n             };\n-            self.equate(true, trace).relate(a, b)\n+            self.equate(true, trace, a, b)\n         }).map(|_| ())\n     }\n "}, {"sha": "635af0a98e246c50a7f3bc451dec055093545f47", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178", "patch": "@@ -602,6 +602,17 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ClosureSubsts<'tcx> {\n     }\n }\n \n+impl<'a,'tcx:'a> Relate<'a,'tcx> for Substs<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &Substs<'tcx>,\n+                 b: &Substs<'tcx>)\n+                 -> RelateResult<'tcx, Substs<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        relate_substs(relation, None, a, b)\n+    }\n+}\n+\n impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::Region {\n     fn relate<R>(relation: &mut R,\n                  a: &ty::Region,"}, {"sha": "6ce623a3b28926c70774ff9c4d703239e9ca7899", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178", "patch": "@@ -24,11 +24,8 @@ use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits::ProjectionMode;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::ty::relate::TypeRelation;\n+use rustc::ty::relate::{TypeRelation, RelateResult};\n use rustc::infer::{self, TypeOrigin};\n-use rustc::infer::lub::Lub;\n-use rustc::infer::glb::Glb;\n-use rustc::infer::sub::Sub;\n use rustc_metadata::cstore::CStore;\n use rustc::front::map as hir_map;\n use rustc::session::{self, config};\n@@ -358,25 +355,25 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         infer::TypeTrace::dummy(self.tcx())\n     }\n \n-    pub fn sub(&self) -> Sub<'a, 'tcx> {\n+    pub fn sub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n-        self.infcx.sub(true, trace)\n+        self.infcx.sub(true, trace, t1, t2)\n     }\n \n-    pub fn lub(&self) -> Lub<'a, 'tcx> {\n+    pub fn lub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n-        self.infcx.lub(true, trace)\n+        self.infcx.lub(true, trace, t1, t2)\n     }\n \n-    pub fn glb(&self) -> Glb<'a, 'tcx> {\n+    pub fn glb(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n-        self.infcx.glb(true, trace)\n+        self.infcx.glb(true, trace, t1, t2)\n     }\n \n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub().relate(&t1, &t2) {\n+        match self.sub(&t1, &t2) {\n             Ok(_) => {}\n             Err(ref e) => {\n                 panic!(\"unexpected error computing sub({:?},{:?}): {}\", t1, t2, e);\n@@ -387,7 +384,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `t1 <: t2` is false (this may register additional\n     /// region checks).\n     pub fn check_not_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub().relate(&t1, &t2) {\n+        match self.sub(&t1, &t2) {\n             Err(_) => {}\n             Ok(_) => {\n                 panic!(\"unexpected success computing sub({:?},{:?})\", t1, t2);\n@@ -397,7 +394,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     /// Checks that `LUB(t1,t2) == t_lub`\n     pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n-        match self.lub().relate(&t1, &t2) {\n+        match self.lub(&t1, &t2) {\n             Ok(t) => {\n                 self.assert_eq(t, t_lub);\n             }\n@@ -410,7 +407,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `GLB(t1,t2) == t_glb`\n     pub fn check_glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_glb: Ty<'tcx>) {\n         debug!(\"check_glb(t1={}, t2={}, t_glb={})\", t1, t2, t_glb);\n-        match self.glb().relate(&t1, &t2) {\n+        match self.glb(&t1, &t2) {\n             Err(e) => {\n                 panic!(\"unexpected error computing LUB: {:?}\", e)\n             }"}, {"sha": "e36da1a568a7d2300427bb58d01d6dba81b6ce64", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178", "patch": "@@ -71,7 +71,7 @@ use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n use rustc::ty::{self, LvaluePreference, TypeAndMut, Ty, TyCtxt};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n-use rustc::ty::relate::{relate_substs, Relate, RelateResult, TypeRelation};\n+use rustc::ty::relate::{RelateResult, TypeRelation};\n use util::common::indent;\n \n use std::cell::RefCell;\n@@ -117,9 +117,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         infcx.commit_if_ok(|_| {\n             let trace = TypeTrace::types(self.origin, false, a, b);\n             if self.use_lub {\n-                infcx.lub(false, trace).relate(&a, &b)\n+                infcx.lub(false, trace, &a, &b)\n             } else {\n-                infcx.sub(false, trace).relate(&a, &b)\n+                infcx.sub(false, trace, &a, &b)\n             }\n         })\n     }\n@@ -649,20 +649,19 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n     debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n \n     let trace = TypeTrace::types(origin, true, prev_ty, new_ty);\n-    let mut lub = fcx.infcx().lub(true, trace);\n \n     // Special-case that coercion alone cannot handle:\n     // Two function item types of differing IDs or Substs.\n     match (&prev_ty.sty, &new_ty.sty) {\n         (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n          &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n             // The signature must always match.\n-            let fty = lub.relate(a_fty, b_fty)?;\n+            let fty = fcx.infcx().lub(true, trace.clone(), a_fty, b_fty)?;\n \n             if a_def_id == b_def_id {\n                 // Same function, maybe the parameters match.\n                 let substs = fcx.infcx().commit_if_ok(|_| {\n-                    relate_substs(&mut lub, None, a_substs, b_substs)\n+                    fcx.infcx().lub(true, trace.clone(), a_substs, b_substs)\n                 }).map(|s| fcx.tcx().mk_substs(s));\n \n                 if let Ok(substs) = substs {\n@@ -724,7 +723,9 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         if !noop {\n-            return fcx.infcx().commit_if_ok(|_| lub.relate(&prev_ty, &new_ty));\n+            return fcx.infcx().commit_if_ok(|_| {\n+                fcx.infcx().lub(true, trace.clone(), &prev_ty, &new_ty)\n+            });\n         }\n     }\n \n@@ -734,7 +735,9 @@ pub fn try_find_lub<'a, 'b, 'tcx, E, I>(fcx: &FnCtxt<'a, 'tcx>,\n             if let Some(e) = first_error {\n                 Err(e)\n             } else {\n-                fcx.infcx().commit_if_ok(|_| lub.relate(&prev_ty, &new_ty))\n+                fcx.infcx().commit_if_ok(|_| {\n+                    fcx.infcx().lub(true, trace, &prev_ty, &new_ty)\n+                })\n             }\n         }\n         Ok((ty, adjustment)) => {"}, {"sha": "107497a2aa3673735e91e27277501dee6b74cf10", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8cd0f0cc3a7a6c0f15a9b214cfa5f0744713c178", "patch": "@@ -2904,7 +2904,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             } else {\n                 fcx.infcx().commit_if_ok(|_| {\n                     let trace = TypeTrace::types(origin, true, then_ty, else_ty);\n-                    fcx.infcx().lub(true, trace).relate(&then_ty, &else_ty)\n+                    fcx.infcx().lub(true, trace, &then_ty, &else_ty)\n                 })\n             };\n             (origin, then_ty, else_ty, result)"}]}