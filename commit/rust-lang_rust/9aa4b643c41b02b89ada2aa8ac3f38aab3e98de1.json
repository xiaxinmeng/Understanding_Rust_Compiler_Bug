{"sha": "9aa4b643c41b02b89ada2aa8ac3f38aab3e98de1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhYTRiNjQzYzQxYjAyYjg5YWRhMmFhOGFjM2YzOGFhYjNlOThkZTE=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-10T16:03:30Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-10T16:26:58Z"}, "message": "copyediting: match", "tree": {"sha": "e32253b9614b26faaaa173aaf1e918b9e752b497", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e32253b9614b26faaaa173aaf1e918b9e752b497"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9aa4b643c41b02b89ada2aa8ac3f38aab3e98de1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9aa4b643c41b02b89ada2aa8ac3f38aab3e98de1", "html_url": "https://github.com/rust-lang/rust/commit/9aa4b643c41b02b89ada2aa8ac3f38aab3e98de1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9aa4b643c41b02b89ada2aa8ac3f38aab3e98de1/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64f4021c408898b961341e1ecadc4d155dfe6b8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/64f4021c408898b961341e1ecadc4d155dfe6b8e", "html_url": "https://github.com/rust-lang/rust/commit/64f4021c408898b961341e1ecadc4d155dfe6b8e"}], "stats": {"total": 140, "additions": 23, "deletions": 117}, "files": [{"sha": "33d603f326af3a19f09ef9182605ef207c44d04f", "filename": "src/doc/trpl/match.md", "status": "modified", "additions": 23, "deletions": 117, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/9aa4b643c41b02b89ada2aa8ac3f38aab3e98de1/src%2Fdoc%2Ftrpl%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/9aa4b643c41b02b89ada2aa8ac3f38aab3e98de1/src%2Fdoc%2Ftrpl%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmatch.md?ref=9aa4b643c41b02b89ada2aa8ac3f38aab3e98de1", "patch": "@@ -1,13 +1,13 @@\n % Match\n \n-Often, a simple `if`/`else` isn't enough, because you have more than two\n+Often, a simple `if`/`else` isn\u2019t enough, because you have more than two\n possible options. Also, `else` conditions can get incredibly complicated, so\n-what's the solution?\n+what\u2019s the solution?\n \n Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`\n groupings with something more powerful. Check it out:\n \n-```{rust}\n+```rust\n let x = 5;\n \n match x {\n@@ -21,11 +21,14 @@ match x {\n ```\n \n `match` takes an expression and then branches based on its value. Each *arm* of\n-the branch is of the form `val => expression`. When the value matches, that arm's\n-expression will be evaluated. It's called `match` because of the term 'pattern\n-matching', which `match` is an implementation of.\n+the branch is of the form `val => expression`. When the value matches, that arm\u2019s\n+expression will be evaluated. It\u2019s called `match` because of the term \u2018pattern\n+matching\u2019, which `match` is an implementation of. There\u2019s an [entire section on\n+patterns][patterns] coming up next, that covers all the options that fit here.\n \n-So what's the big advantage here? Well, there are a few. First of all, `match`\n+[patterns]: patterns.html\n+\n+So what\u2019s the big advantage here? Well, there are a few. First of all, `match`\n enforces *exhaustiveness checking*. Do you see that last arm, the one with the\n underscore (`_`)? If we remove that arm, Rust will give us an error:\n \n@@ -36,121 +39,24 @@ error: non-exhaustive patterns: `_` not covered\n In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n integer, Rust knows that it can have a number of different values \u2013 for example,\n `6`. Without the `_`, however, there is no arm that could match, and so Rust refuses\n-to compile. `_` acts like a *catch-all arm*. If none of the other arms match,\n+to compile. `_` acts like a \u2018catch-all arm\u2019. If none of the other arms match,\n the arm with `_` will, and since we have this catch-all arm, we now have an arm\n for every possible value of `x`, and so our program will compile successfully.\n \n-`match` statements also destructure enums, as well. Remember this code from the\n-section on enums?\n-\n-```{rust}\n-use std::cmp::Ordering;\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    let ordering = cmp(x, y);\n-\n-    if ordering == Ordering::Less {\n-        println!(\"less\");\n-    } else if ordering == Ordering::Greater {\n-        println!(\"greater\");\n-    } else if ordering == Ordering::Equal {\n-        println!(\"equal\");\n-    }\n-}\n-```\n-\n-We can re-write this as a `match`:\n-\n-```{rust}\n-use std::cmp::Ordering;\n-\n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n-\n-    match cmp(x, y) {\n-        Ordering::Less => println!(\"less\"),\n-        Ordering::Greater => println!(\"greater\"),\n-        Ordering::Equal => println!(\"equal\"),\n-    }\n-}\n-```\n-\n-This version has way less noise, and it also checks exhaustively to make sure\n-that we have covered all possible variants of `Ordering`. With our `if`/`else`\n-version, if we had forgotten the `Greater` case, for example, our program would\n-have happily compiled. If we forget in the `match`, it will not. Rust helps us\n-make sure to cover all of our bases.\n-\n-`match` expressions also allow us to get the values contained in an `enum`\n-(also known as destructuring) as follows:\n-\n-```{rust}\n-enum OptionalInt {\n-    Value(i32),\n-    Missing,\n-}\n-\n-fn main() {\n-    let x = OptionalInt::Value(5);\n-    let y = OptionalInt::Missing;\n-\n-    match x {\n-        OptionalInt::Value(n) => println!(\"x is {}\", n),\n-        OptionalInt::Missing => println!(\"x is missing!\"),\n-    }\n-\n-    match y {\n-        OptionalInt::Value(n) => println!(\"y is {}\", n),\n-        OptionalInt::Missing => println!(\"y is missing!\"),\n-    }\n-}\n-```\n-\n-That is how you can get and use the values contained in `enum`s.\n-It can also allow us to handle errors or unexpected computations; for example, a\n-function that is not guaranteed to be able to compute a result (an `i32` here)\n-could return an `OptionalInt`, and we would handle that value with a `match`.\n-As you can see, `enum` and `match` used together are quite useful!\n-\n `match` is also an expression, which means we can use it on the right-hand\n-side of a `let` binding or directly where an expression is used. We could\n-also implement the previous example like this:\n-\n-```{rust}\n-use std::cmp::Ordering;\n+side of a `let` binding or directly where an expression is used:\n \n-fn cmp(a: i32, b: i32) -> Ordering {\n-    if a < b { Ordering::Less }\n-    else if a > b { Ordering::Greater }\n-    else { Ordering::Equal }\n-}\n-\n-fn main() {\n-    let x = 5;\n-    let y = 10;\n+```rust\n+let x = 5;\n \n-    println!(\"{}\", match cmp(x, y) {\n-        Ordering::Less => \"less\",\n-        Ordering::Greater => \"greater\",\n-        Ordering::Equal => \"equal\",\n-    });\n-}\n+let numer = match x {\n+    1 => \"one\",\n+    2 => \"two\",\n+    3 => \"three\",\n+    4 => \"four\",\n+    5 => \"five\",\n+    _ => \"something else\",\n+};\n ```\n \n-Sometimes, it's a nice pattern.\n+Sometimes, it\u2019s a nice way of converting things."}]}