{"sha": "d0ab6e8644ded75c9a43b46151568f6b782bec59", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwYWI2ZTg2NDRkZWQ3NWM5YTQzYjQ2MTUxNTY4ZjZiNzgyYmVjNTk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-19T20:43:55Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:31Z"}, "message": "rustc_trans: compute LLVM types from type layouts, not Rust types.", "tree": {"sha": "cd53da56721e9ae60bcea4c966e4d1cd35e50564", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd53da56721e9ae60bcea4c966e4d1cd35e50564"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0ab6e8644ded75c9a43b46151568f6b782bec59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0ab6e8644ded75c9a43b46151568f6b782bec59", "html_url": "https://github.com/rust-lang/rust/commit/d0ab6e8644ded75c9a43b46151568f6b782bec59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0ab6e8644ded75c9a43b46151568f6b782bec59/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fad99542c8643984b7630d8e297007aef824b268", "url": "https://api.github.com/repos/rust-lang/rust/commits/fad99542c8643984b7630d8e297007aef824b268", "html_url": "https://github.com/rust-lang/rust/commit/fad99542c8643984b7630d8e297007aef824b268"}], "stats": {"total": 564, "additions": 184, "deletions": 380}, "files": [{"sha": "d905592347f6472aa69ad3d8e2de83ed02b500fe", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d0ab6e8644ded75c9a43b46151568f6b782bec59/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ab6e8644ded75c9a43b46151568f6b782bec59/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=d0ab6e8644ded75c9a43b46151568f6b782bec59", "patch": "@@ -1541,10 +1541,10 @@ impl<'a, 'tcx> Layout {\n                         discr_range: (min as u64)..=(max as u64),\n                         variants\n                     },\n-                    fields: FieldPlacement::Arbitrary {\n-                        offsets: vec![Size::from_bytes(0)],\n-                        memory_index: vec![0]\n-                    },\n+                    // FIXME(eddyb): using `FieldPlacement::Arbitrary` here results\n+                    // in lost optimizations, specifically around allocations, see\n+                    // `test/codegen/{alloc-optimisation,vec-optimizes-away}.rs`.\n+                    fields: FieldPlacement::Union(1),\n                     abi: if discr.size(dl) == size {\n                         Abi::Scalar(discr)\n                     } else {"}, {"sha": "07c64c35c07d6c46828b927b2ac6780b0f8c5049", "filename": "src/librustc_trans/adt.rs", "status": "removed", "additions": 0, "deletions": 196, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/fad99542c8643984b7630d8e297007aef824b268/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad99542c8643984b7630d8e297007aef824b268/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=fad99542c8643984b7630d8e297007aef824b268", "patch": "@@ -1,196 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! # Representation of Algebraic Data Types\n-//!\n-//! This module determines how to represent enums, structs, and tuples\n-//! based on their monomorphized types; it is responsible both for\n-//! choosing a representation and translating basic operations on\n-//! values of those types.  (Note: exporting the representations for\n-//! debuggers is handled in debuginfo.rs, not here.)\n-//!\n-//! Note that the interface treats everything as a general case of an\n-//! enum, so structs/tuples/etc. have one pseudo-variant with\n-//! discriminant 0; i.e., as if they were a univariant enum.\n-//!\n-//! Having everything in one place will enable improvements to data\n-//! structure representation; possibilities include:\n-//!\n-//! - User-specified alignment (e.g., cacheline-aligning parts of\n-//!   concurrently accessed data structures); LLVM can't represent this\n-//!   directly, so we'd have to insert padding fields in any structure\n-//!   that might contain one and adjust GEP indices accordingly.  See\n-//!   issue #4578.\n-//!\n-//! - Store nested enums' discriminants in the same word.  Rather, if\n-//!   some variants start with enums, and those enums representations\n-//!   have unused alignment padding between discriminant and body, the\n-//!   outer enum's discriminant can be stored there and those variants\n-//!   can start at offset 0.  Kind of fancy, and might need work to\n-//!   make copies of the inner enum type cooperate, but it could help\n-//!   with `Option` or `Result` wrapped around another enum.\n-//!\n-//! - Tagged pointers would be neat, but given that any type can be\n-//!   used unboxed and any field can have pointers (including mutable)\n-//!   taken to it, implementing them for Rust seems difficult.\n-\n-use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Size, FullLayout};\n-\n-use context::CrateContext;\n-use type_::Type;\n-\n-/// LLVM-level types are a little complicated.\n-///\n-/// C-like enums need to be actual ints, not wrapped in a struct,\n-/// because that changes the ABI on some platforms (see issue #10308).\n-///\n-/// For nominal types, in some cases, we need to use LLVM named structs\n-/// and fill in the actual contents in a second pass to prevent\n-/// unbounded recursion; see also the comments in `trans::type_of`.\n-pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    generic_type_of(cx, t, None)\n-}\n-\n-pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                    t: Ty<'tcx>, name: &str) -> Type {\n-    generic_type_of(cx, t, Some(name))\n-}\n-\n-pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                t: Ty<'tcx>, llty: &mut Type) {\n-    let l = cx.layout_of(t);\n-    debug!(\"finish_type_of: {} with layout {:#?}\", t, l);\n-    if let layout::Abi::Scalar(_) = l.abi {\n-        return;\n-    }\n-    match *l.layout {\n-        layout::Univariant => {\n-            let is_enum = if let ty::TyAdt(def, _) = t.sty {\n-                def.is_enum()\n-            } else {\n-                false\n-            };\n-            let variant_layout = if is_enum {\n-                l.for_variant(0)\n-            } else {\n-                l\n-            };\n-            llty.set_struct_body(&struct_llfields(cx, variant_layout),\n-                                 variant_layout.is_packed())\n-        }\n-\n-        _ => {}\n-    }\n-}\n-\n-fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                             t: Ty<'tcx>,\n-                             name: Option<&str>) -> Type {\n-    let l = cx.layout_of(t);\n-    debug!(\"adt::generic_type_of {:#?} name: {:?}\", l, name);\n-    if let layout::Abi::Scalar(value) = l.abi {\n-        return cx.llvm_type_of(value.to_ty(cx.tcx()));\n-    }\n-    match *l.layout {\n-        layout::Univariant => {\n-            match name {\n-                None => {\n-                    Type::struct_(cx, &struct_llfields(cx, l), l.is_packed())\n-                }\n-                Some(name) => {\n-                    Type::named_struct(cx, name)\n-                }\n-            }\n-        }\n-        _ => {\n-            let align = l.align(cx);\n-            let abi_align = align.abi();\n-            let elem_ty = if let Some(ity) = layout::Integer::for_abi_align(cx, align) {\n-                Type::from_integer(cx, ity)\n-            } else {\n-                let vec_align = cx.data_layout().vector_align(Size::from_bytes(abi_align));\n-                assert_eq!(vec_align.abi(), abi_align);\n-                Type::vector(&Type::i32(cx), abi_align / 4)\n-            };\n-\n-            let size = l.size(cx).bytes();\n-            assert_eq!(size % abi_align, 0);\n-            let fill = Type::array(&elem_ty, size / abi_align);\n-            match name {\n-                None => {\n-                    Type::struct_(cx, &[fill], l.is_packed())\n-                }\n-                Some(name) => {\n-                    let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(&[fill], l.is_packed());\n-                    llty\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// Double an index and add 1 to account for padding.\n-pub fn memory_index_to_gep(index: u64) -> u64 {\n-    1 + index * 2\n-}\n-\n-pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                 layout: FullLayout<'tcx>) -> Vec<Type> {\n-    debug!(\"struct_llfields: {:#?}\", layout);\n-    let align = layout.align(cx);\n-    let size = layout.size(cx);\n-    let field_count = layout.fields.count();\n-\n-    let mut offset = Size::from_bytes(0);\n-    let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n-    for i in layout.fields.index_by_increasing_offset() {\n-        let field = layout.field(cx, i);\n-        let target_offset = layout.fields.offset(i as usize);\n-        debug!(\"struct_llfields: {}: {:?} offset: {:?} target_offset: {:?}\",\n-            i, field, offset, target_offset);\n-        assert!(target_offset >= offset);\n-        let padding = target_offset - offset;\n-        result.push(Type::array(&Type::i8(cx), padding.bytes()));\n-        debug!(\"    padding before: {:?}\", padding);\n-\n-        let llty = cx.llvm_type_of(field.ty);\n-        result.push(llty);\n-\n-        if layout.is_packed() {\n-            assert_eq!(padding.bytes(), 0);\n-        } else {\n-            let field_align = field.align(cx);\n-            assert!(field_align.abi() <= align.abi(),\n-                    \"non-packed type has field with larger align ({}): {:#?}\",\n-                    field_align.abi(), layout);\n-        }\n-\n-        offset = target_offset + field.size(cx);\n-    }\n-    if !layout.is_unsized() && field_count > 0 {\n-        if offset > size {\n-            bug!(\"layout: {:#?} stride: {:?} offset: {:?}\",\n-                 layout, size, offset);\n-        }\n-        let padding = size - offset;\n-        debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n-               padding, offset, size);\n-        result.push(Type::array(&Type::i8(cx), padding.bytes()));\n-        assert!(result.len() == 1 + field_count * 2);\n-    } else {\n-        debug!(\"struct_llfields: offset: {:?} stride: {:?}\",\n-               offset, size);\n-    }\n-\n-    result\n-}\n-"}, {"sha": "83fc10173166c65314750b58bffe70c837d3576c", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0ab6e8644ded75c9a43b46151568f6b782bec59/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ab6e8644ded75c9a43b46151568f6b782bec59/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=d0ab6e8644ded75c9a43b46151568f6b782bec59", "patch": "@@ -104,7 +104,6 @@ pub mod back {\n }\n \n mod abi;\n-mod adt;\n mod allocator;\n mod asm;\n mod assert_module_sources;"}, {"sha": "8dbef1f8d0845cb399c2585a1bad0c087ee047fe", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0ab6e8644ded75c9a43b46151568f6b782bec59/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ab6e8644ded75c9a43b46151568f6b782bec59/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=d0ab6e8644ded75c9a43b46151568f6b782bec59", "patch": "@@ -77,7 +77,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     // Not in the cache. Build it.\n-    let nullptr = C_null(Type::nil(ccx).ptr_to());\n+    let nullptr = C_null(Type::i8p(ccx));\n \n     let (size, align) = ccx.size_and_align_of(ty);\n     let mut components: Vec<_> = ["}, {"sha": "b72ccf6ba28ea7f90e9ae26fe0d398afed6f75a1", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 19, "deletions": 46, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d0ab6e8644ded75c9a43b46151568f6b782bec59/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ab6e8644ded75c9a43b46151568f6b782bec59/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=d0ab6e8644ded75c9a43b46151568f6b782bec59", "patch": "@@ -10,17 +10,16 @@\n \n use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, Align, FullLayout, Layout, LayoutOf};\n+use rustc::ty::layout::{self, Align, FullLayout, LayoutOf};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n use abi;\n-use adt;\n use base;\n use builder::Builder;\n use common::{self, CrateContext, C_usize, C_u8, C_u32, C_uint, C_int, C_null, val_ty};\n use consts;\n-use type_of::LayoutLlvmExt;\n+use type_of::{self, LayoutLlvmExt};\n use type_::Type;\n use value::Value;\n use glue;\n@@ -206,52 +205,26 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let alignment = self.alignment | Alignment::from(l);\n \n         // Unions and newtypes only use an offset of 0.\n-        match *l.layout {\n-            // FIXME(eddyb) The fields of a fat pointer aren't correct, especially\n-            // to unsized structs, we can't represent their pointee types in `Ty`.\n-            Layout::FatPointer { .. } => {}\n-\n-            _ if offset == 0 => {\n-                let ty = ccx.llvm_type_of(field.ty);\n-                return LvalueRef {\n-                    llval: bcx.pointercast(self.llval, ty.ptr_to()),\n-                    llextra: if field.is_unsized() {\n-                        self.llextra\n-                    } else {\n-                        ptr::null_mut()\n-                    },\n-                    ty: LvalueTy::from_ty(field.ty),\n-                    alignment,\n-                };\n-            }\n-\n-            _ => {}\n-        }\n-\n-        // Discriminant field of enums.\n-        if let layout::NullablePointer { .. } = *l.layout {\n-            let ty = ccx.llvm_type_of(field.ty);\n-            let size = field.size(ccx).bytes();\n-\n-            // If the discriminant is not on a multiple of the primitive's size,\n-            // we need to go through i8*. Also assume the worst alignment.\n-            if offset % size != 0 {\n-                let byte_ptr = bcx.pointercast(self.llval, Type::i8p(ccx));\n-                let byte_ptr = bcx.inbounds_gep(byte_ptr, &[C_usize(ccx, offset)]);\n-                let byte_align = Alignment::Packed(Align::from_bytes(1, 1).unwrap());\n-                return LvalueRef::new_sized(\n-                    bcx.pointercast(byte_ptr, ty.ptr_to()), field.ty, byte_align);\n+        let has_llvm_fields = match *l.fields {\n+            layout::FieldPlacement::Union(_) => false,\n+            layout::FieldPlacement::Array { .. } => true,\n+            layout::FieldPlacement::Arbitrary { .. } => {\n+                match l.abi {\n+                    layout::Abi::Scalar(_) | layout::Abi::Vector { .. } => false,\n+                    layout::Abi::Aggregate { .. } => true\n+                }\n             }\n-\n-            let discr_ptr = bcx.pointercast(self.llval, ty.ptr_to());\n-            return LvalueRef::new_sized(\n-                bcx.inbounds_gep(discr_ptr, &[C_usize(ccx, offset / size)]),\n-                field.ty, alignment);\n-        }\n+        };\n \n         let simple = || {\n             LvalueRef {\n-                llval: bcx.struct_gep(self.llval, l.llvm_field_index(ix)),\n+                llval: if has_llvm_fields {\n+                    bcx.struct_gep(self.llval, l.llvm_field_index(ix))\n+                } else {\n+                    assert_eq!(offset, 0);\n+                    let ty = ccx.llvm_type_of(field.ty);\n+                    bcx.pointercast(self.llval, ty.ptr_to())\n+                },\n                 llextra: if ccx.shared().type_has_metadata(field.ty) {\n                     self.llextra\n                 } else {\n@@ -460,7 +433,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 layout::General { .. } => {\n                     let variant_layout = layout.for_variant(variant_index);\n                     let variant_ty = Type::struct_(bcx.ccx,\n-                        &adt::struct_llfields(bcx.ccx, variant_layout),\n+                        &type_of::struct_llfields(bcx.ccx, variant_layout),\n                         variant_layout.is_packed());\n                     downcast.llval = bcx.pointercast(downcast.llval, variant_ty.ptr_to());\n                 }"}, {"sha": "dbdc8919da9c17e85cffc19de8c4d8ac299c8ad6", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d0ab6e8644ded75c9a43b46151568f6b782bec59/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ab6e8644ded75c9a43b46151568f6b782bec59/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=d0ab6e8644ded75c9a43b46151568f6b782bec59", "patch": "@@ -66,10 +66,6 @@ impl Type {\n         ty!(llvm::LLVMVoidTypeInContext(ccx.llcx()))\n     }\n \n-    pub fn nil(ccx: &CrateContext) -> Type {\n-        Type::empty_struct(ccx)\n-    }\n-\n     pub fn metadata(ccx: &CrateContext) -> Type {\n         ty!(llvm::LLVMRustMetadataTypeInContext(ccx.llcx()))\n     }\n@@ -202,9 +198,6 @@ impl Type {\n         ty!(llvm::LLVMStructCreateNamed(ccx.llcx(), name.as_ptr()))\n     }\n \n-    pub fn empty_struct(ccx: &CrateContext) -> Type {\n-        Type::struct_(ccx, &[], false)\n-    }\n \n     pub fn array(ty: &Type, len: u64) -> Type {\n         ty!(llvm::LLVMRustArrayType(ty.to_ref(), len))"}, {"sha": "7474e71a715f71dd894fe6574d49809d87e052f4", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 160, "deletions": 125, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/d0ab6e8644ded75c9a43b46151568f6b782bec59/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0ab6e8644ded75c9a43b46151568f6b782bec59/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=d0ab6e8644ded75c9a43b46151568f6b782bec59", "patch": "@@ -9,10 +9,9 @@\n // except according to those terms.\n \n use abi::FnType;\n-use adt;\n use common::*;\n use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::layout::{self, Align, Layout, LayoutOf, Size, FullLayout};\n+use rustc::ty::layout::{self, HasDataLayout, Align, LayoutOf, Size, FullLayout};\n use trans_item::DefPathBasedNames;\n use type_::Type;\n \n@@ -43,30 +42,10 @@ pub fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) ->\n     }\n }\n \n-fn compute_llvm_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    // Check the cache.\n-    if let Some(&llty) = cx.lltypes().borrow().get(&t) {\n-        return llty;\n-    }\n-\n-    debug!(\"type_of {:?}\", t);\n-\n-    assert!(!t.has_escaping_regions(), \"{:?} has escaping regions\", t);\n-\n-    // Replace any typedef'd types with their equivalent non-typedef\n-    // type. This ensures that all LLVM nominal types that contain\n-    // Rust types are defined as the same LLVM types.  If we don't do\n-    // this then, e.g. `Option<{myfield: bool}>` would be a different\n-    // type than `Option<myrec>`.\n-    let t_norm = cx.tcx().erase_regions(&t);\n-\n-    if t != t_norm {\n-        let llty = cx.llvm_type_of(t_norm);\n-        debug!(\"--> normalized {:?} to {:?} llty={:?}\", t, t_norm, llty);\n-        cx.lltypes().borrow_mut().insert(t, llty);\n-        return llty;\n-    }\n-\n+fn uncached_llvm_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                ty: Ty<'tcx>,\n+                                defer: &mut Option<(Type, FullLayout<'tcx>)>)\n+                                -> Type {\n     let ptr_ty = |ty: Ty<'tcx>| {\n         if cx.shared().type_has_metadata(ty) {\n             if let ty::TyStr = ty.sty {\n@@ -88,97 +67,130 @@ fn compute_llvm_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type\n             cx.llvm_type_of(ty).ptr_to()\n         }\n     };\n+    match ty.sty {\n+        ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n+        ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => {\n+            return ptr_ty(ty);\n+        }\n+        ty::TyAdt(def, _) if def.is_box() => {\n+            return ptr_ty(ty.boxed_ty());\n+        }\n+        ty::TyFnPtr(sig) => {\n+            let sig = cx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+            return FnType::new(cx, sig, &[]).llvm_type(cx).ptr_to();\n+        }\n+        _ => {}\n+    }\n+\n+    let layout = cx.layout_of(ty);\n+    if let layout::Abi::Scalar(value) = layout.abi {\n+        let llty = match value {\n+            layout::Int(layout::I1, _) => Type::i8(cx),\n+            layout::Int(i, _) => Type::from_integer(cx, i),\n+            layout::F32 => Type::f32(cx),\n+            layout::F64 => Type::f64(cx),\n+            layout::Pointer => cx.llvm_type_of(layout::Pointer.to_ty(cx.tcx()))\n+        };\n+        return llty;\n+    }\n+\n+    if let layout::Abi::Vector { .. } = layout.abi {\n+        return Type::vector(&cx.llvm_type_of(layout.field(cx, 0).ty),\n+                            layout.fields.count() as u64);\n+    }\n \n-    let mut llty = match t.sty {\n-      ty::TyBool => Type::bool(cx),\n-      ty::TyChar => Type::char(cx),\n-      ty::TyInt(t) => Type::int_from_ty(cx, t),\n-      ty::TyUint(t) => Type::uint_from_ty(cx, t),\n-      ty::TyFloat(t) => Type::float_from_ty(cx, t),\n-      ty::TyNever => Type::nil(cx),\n-      ty::TyClosure(..) => {\n-          // Only create the named struct, but don't fill it in. We\n-          // fill it in *after* placing it into the type cache.\n-          adt::incomplete_type_of(cx, t, \"closure\")\n-      }\n-      ty::TyGenerator(..) => {\n-          // Only create the named struct, but don't fill it in. We\n-          // fill it in *after* placing it into the type cache.\n-          adt::incomplete_type_of(cx, t, \"generator\")\n-      }\n-\n-      ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n-      ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => {\n-          ptr_ty(ty)\n-      }\n-      ty::TyAdt(def, _) if def.is_box() => {\n-          ptr_ty(t.boxed_ty())\n-      }\n-\n-      ty::TyArray(ty, size) => {\n-          let llty = cx.llvm_type_of(ty);\n-          let size = size.val.to_const_int().unwrap().to_u64().unwrap();\n-          Type::array(&llty, size)\n-      }\n-\n-      ty::TySlice(ty) => {\n-          Type::array(&cx.llvm_type_of(ty), 0)\n-      }\n-      ty::TyStr => {\n-          Type::array(&Type::i8(cx), 0)\n-      }\n-      ty::TyDynamic(..) |\n-      ty::TyForeign(..) => adt::type_of(cx, t),\n-\n-      ty::TyFnDef(..) => Type::nil(cx),\n-      ty::TyFnPtr(sig) => {\n-        let sig = cx.tcx().erase_late_bound_regions_and_normalize(&sig);\n-        FnType::new(cx, sig, &[]).llvm_type(cx).ptr_to()\n-      }\n-      ty::TyTuple(ref tys, _) if tys.is_empty() => Type::nil(cx),\n-      ty::TyTuple(..) => {\n-          adt::type_of(cx, t)\n-      }\n-      ty::TyAdt(..) if t.is_simd() => {\n-          let e = t.simd_type(cx.tcx());\n-          if !e.is_machine() {\n-              cx.sess().fatal(&format!(\"monomorphising SIMD type `{}` with \\\n-                                        a non-machine element type `{}`\",\n-                                       t, e))\n-          }\n-          let llet = cx.llvm_type_of(e);\n-          let n = t.simd_size(cx.tcx()) as u64;\n-          Type::vector(&llet, n)\n-      }\n-      ty::TyAdt(..) => {\n-          // Only create the named struct, but don't fill it in. We\n-          // fill it in *after* placing it into the type cache. This\n-          // avoids creating more than one copy of the enum when one\n-          // of the enum's variants refers to the enum itself.\n-          let name = llvm_type_name(cx, t);\n-          adt::incomplete_type_of(cx, t, &name[..])\n-      }\n-\n-      ty::TyInfer(..) |\n-      ty::TyProjection(..) |\n-      ty::TyParam(..) |\n-      ty::TyAnon(..) |\n-      ty::TyError => bug!(\"type_of with {:?}\", t),\n+    let name = match ty.sty {\n+        ty::TyClosure(..) | ty::TyGenerator(..) | ty::TyAdt(..) => {\n+            let mut name = String::with_capacity(32);\n+            let printer = DefPathBasedNames::new(cx.tcx(), true, true);\n+            printer.push_type_name(ty, &mut name);\n+            Some(name)\n+        }\n+        _ => None\n     };\n \n-    debug!(\"--> mapped t={:?} to llty={:?}\", t, llty);\n+    match *layout.fields {\n+        layout::FieldPlacement::Union(_) => {\n+            let size = layout.size(cx).bytes();\n+            let fill = Type::array(&Type::i8(cx), size);\n+            match name {\n+                None => {\n+                    Type::struct_(cx, &[fill], layout.is_packed())\n+                }\n+                Some(ref name) => {\n+                    let mut llty = Type::named_struct(cx, name);\n+                    llty.set_struct_body(&[fill], layout.is_packed());\n+                    llty\n+                }\n+            }\n+        }\n+        layout::FieldPlacement::Array { count, .. } => {\n+            Type::array(&cx.llvm_type_of(layout.field(cx, 0).ty), count)\n+        }\n+        layout::FieldPlacement::Arbitrary { .. } => {\n+            match name {\n+                None => {\n+                    Type::struct_(cx, &struct_llfields(cx, layout), layout.is_packed())\n+                }\n+                Some(ref name) => {\n+                    let llty = Type::named_struct(cx, name);\n+                    *defer = Some((llty, layout));\n+                    llty\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                 layout: FullLayout<'tcx>) -> Vec<Type> {\n+    debug!(\"struct_llfields: {:#?}\", layout);\n+    let align = layout.align(cx);\n+    let size = layout.size(cx);\n+    let field_count = layout.fields.count();\n+\n+    let mut offset = Size::from_bytes(0);\n+    let mut result: Vec<Type> = Vec::with_capacity(1 + field_count * 2);\n+    for i in layout.fields.index_by_increasing_offset() {\n+        let field = layout.field(cx, i);\n+        let target_offset = layout.fields.offset(i as usize);\n+        debug!(\"struct_llfields: {}: {:?} offset: {:?} target_offset: {:?}\",\n+            i, field, offset, target_offset);\n+        assert!(target_offset >= offset);\n+        let padding = target_offset - offset;\n+        result.push(Type::array(&Type::i8(cx), padding.bytes()));\n+        debug!(\"    padding before: {:?}\", padding);\n \n-    cx.lltypes().borrow_mut().insert(t, llty);\n+        let llty = cx.llvm_type_of(field.ty);\n+        result.push(llty);\n \n-    // If this was an enum or struct, fill in the type now.\n-    match t.sty {\n-        ty::TyAdt(..) | ty::TyClosure(..) | ty::TyGenerator(..) if !t.is_simd() && !t.is_box() => {\n-            adt::finish_type_of(cx, t, &mut llty);\n+        if layout.is_packed() {\n+            assert_eq!(padding.bytes(), 0);\n+        } else {\n+            let field_align = field.align(cx);\n+            assert!(field_align.abi() <= align.abi(),\n+                    \"non-packed type has field with larger align ({}): {:#?}\",\n+                    field_align.abi(), layout);\n         }\n-        _ => ()\n+\n+        offset = target_offset + field.size(cx);\n+    }\n+    if !layout.is_unsized() && field_count > 0 {\n+        if offset > size {\n+            bug!(\"layout: {:#?} stride: {:?} offset: {:?}\",\n+                 layout, size, offset);\n+        }\n+        let padding = size - offset;\n+        debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n+               padding, offset, size);\n+        result.push(Type::array(&Type::i8(cx), padding.bytes()));\n+        assert!(result.len() == 1 + field_count * 2);\n+    } else {\n+        debug!(\"struct_llfields: offset: {:?} stride: {:?}\",\n+               offset, size);\n     }\n \n-    llty\n+    result\n }\n \n impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n@@ -219,7 +231,38 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n     pub fn llvm_type_of(&self, ty: Ty<'tcx>) -> Type {\n-        compute_llvm_type(self, ty)\n+        // Check the cache.\n+        if let Some(&llty) = self.lltypes().borrow().get(&ty) {\n+            return llty;\n+        }\n+\n+        debug!(\"type_of {:?}\", ty);\n+\n+        assert!(!ty.has_escaping_regions(), \"{:?} has escaping regions\", ty);\n+\n+        // Make sure lifetimes are erased, to avoid generating distinct LLVM\n+        // types for Rust types that only differ in the choice of lifetimes.\n+        let normal_ty = self.tcx().erase_regions(&ty);\n+\n+        if ty != normal_ty {\n+            let llty = self.llvm_type_of(normal_ty);\n+            debug!(\"--> normalized {:?} to {:?} llty={:?}\", ty, normal_ty, llty);\n+            self.lltypes().borrow_mut().insert(ty, llty);\n+            return llty;\n+        }\n+\n+        let mut defer = None;\n+        let llty = uncached_llvm_type(self, ty, &mut defer);\n+\n+        debug!(\"--> mapped ty={:?} to llty={:?}\", ty, llty);\n+\n+        self.lltypes().borrow_mut().insert(ty, llty);\n+\n+        if let Some((mut llty, layout)) = defer {\n+            llty.set_struct_body(&struct_llfields(self, layout), layout.is_packed())\n+        }\n+\n+        llty\n     }\n \n     pub fn immediate_llvm_type_of(&self, ty: Ty<'tcx>) -> Type {\n@@ -240,26 +283,18 @@ impl<'tcx> LayoutLlvmExt for FullLayout<'tcx> {\n         if let layout::Abi::Scalar(_) = self.abi {\n             bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self);\n         }\n-        let index = self.fields.memory_index(index);\n-        match *self.layout {\n-            Layout::Vector | Layout::Array => {\n-                index as u64\n+        match *self.fields {\n+            layout::FieldPlacement::Union(_) => {\n+                bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self)\n             }\n \n-            Layout::FatPointer | Layout::Univariant => {\n-                adt::memory_index_to_gep(index as u64)\n+            layout::FieldPlacement::Array { .. } => {\n+                index as u64\n             }\n \n-            _ => {\n-                bug!(\"FullLayout::llvm_field_index({:?}): not applicable\", self)\n+            layout::FieldPlacement::Arbitrary { .. } => {\n+                1 + (self.fields.memory_index(index) as u64) * 2\n             }\n         }\n     }\n }\n-\n-fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> String {\n-    let mut name = String::with_capacity(32);\n-    let printer = DefPathBasedNames::new(cx.tcx(), true, true);\n-    printer.push_type_name(ty, &mut name);\n-    name\n-}"}]}