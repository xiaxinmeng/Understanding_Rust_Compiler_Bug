{"sha": "99dd5911a1026da0a374b697e4a0407a631eb388", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZGQ1OTExYTEwMjZkYTBhMzc0YjY5N2U0YTA0MDdhNjMxZWIzODg=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-04-15T12:00:14Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-04-16T07:53:27Z"}, "message": "syntax: unify all MacResult's into a single trait.\n\nThere's now one unified way to return things from a macro, instead of\nbeing able to choose the `AnyMacro` trait or the `MRItem`/`MRExpr`\nvariants of the `MacResult` enum. This does simplify the logic handling\nthe expansions, but the biggest value of this is it makes macros in (for\nexample) type position easier to implement, as there's this single thing\nto modify.\n\nBy my measurements (using `-Z time-passes` on libstd and librustc etc.),\nthis appears to have little-to-no impact on expansion speed. There are\npresumably larger costs than the small number of extra allocations and\nvirtual calls this adds (notably, all `macro_rules!`-defined macros have\nnot changed in behaviour, since they had to use the `AnyMacro` trait\nanyway).", "tree": {"sha": "4e88a1416f3c7336e83d2c1797aa0de76d8ca84b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e88a1416f3c7336e83d2c1797aa0de76d8ca84b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99dd5911a1026da0a374b697e4a0407a631eb388", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99dd5911a1026da0a374b697e4a0407a631eb388", "html_url": "https://github.com/rust-lang/rust/commit/99dd5911a1026da0a374b697e4a0407a631eb388", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99dd5911a1026da0a374b697e4a0407a631eb388/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "168b2d1a3f4569706fe4f9a2baee04e37f85d297", "url": "https://api.github.com/repos/rust-lang/rust/commits/168b2d1a3f4569706fe4f9a2baee04e37f85d297", "html_url": "https://github.com/rust-lang/rust/commit/168b2d1a3f4569706fe4f9a2baee04e37f85d297"}], "stats": {"total": 419, "additions": 245, "deletions": 174}, "files": [{"sha": "50cdd6cedc23c0683dad05e36603db338234e211", "filename": "src/libfourcc/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibfourcc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibfourcc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfourcc%2Flib.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -57,7 +57,7 @@ use syntax::ast::Name;\n use syntax::attr::contains;\n use syntax::codemap::{Span, mk_sp};\n use syntax::ext::base;\n-use syntax::ext::base::{SyntaxExtension, BasicMacroExpander, NormalTT, ExtCtxt, MRExpr};\n+use syntax::ext::base::{SyntaxExtension, BasicMacroExpander, NormalTT, ExtCtxt, MacExpr};\n use syntax::ext::build::AstBuilder;\n use syntax::parse;\n use syntax::parse::token;\n@@ -73,7 +73,7 @@ pub fn macro_registrar(register: |Name, SyntaxExtension|) {\n         None));\n }\n \n-pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::MacResult {\n+pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> ~base::MacResult {\n     let (expr, endian) = parse_tts(cx, tts);\n \n     let little = match endian {\n@@ -101,12 +101,12 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) ->\n             }\n             _ => {\n                 cx.span_err(expr.span, \"unsupported literal in fourcc!\");\n-                return MRExpr(cx.expr_lit(sp, ast::LitUint(0u64, ast::TyU32)));\n+                return base::DummyResult::expr(sp)\n             }\n         },\n         _ => {\n             cx.span_err(expr.span, \"non-literal in fourcc!\");\n-            return MRExpr(cx.expr_lit(sp, ast::LitUint(0u64, ast::TyU32)));\n+            return base::DummyResult::expr(sp)\n         }\n     };\n \n@@ -126,7 +126,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) ->\n         };\n     }\n     let e = cx.expr_lit(sp, ast::LitUint(val as u64, ast::TyU32));\n-    MRExpr(e)\n+    MacExpr::new(e)\n }\n \n struct Ident {"}, {"sha": "e65b84091e5f915e44baec16a0b35510efeb87eb", "filename": "src/libhexfloat/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibhexfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibhexfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibhexfloat%2Flib.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -53,7 +53,7 @@ use syntax::ast;\n use syntax::ast::Name;\n use syntax::codemap::{Span, mk_sp};\n use syntax::ext::base;\n-use syntax::ext::base::{SyntaxExtension, BasicMacroExpander, NormalTT, ExtCtxt, MRExpr};\n+use syntax::ext::base::{SyntaxExtension, BasicMacroExpander, NormalTT, ExtCtxt, MacExpr};\n use syntax::ext::build::AstBuilder;\n use syntax::parse;\n use syntax::parse::token;\n@@ -97,7 +97,7 @@ fn hex_float_lit_err(s: &str) -> Option<(uint, ~str)> {\n     }\n }\n \n-pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::MacResult {\n+pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> ~base::MacResult {\n     let (expr, ty_lit) = parse_tts(cx, tts);\n \n     let ty = match ty_lit {\n@@ -121,12 +121,12 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) ->\n             }\n             _ => {\n                 cx.span_err(expr.span, \"unsupported literal in hexfloat!\");\n-                return base::MacResult::dummy_expr(sp);\n+                return base::DummyResult::expr(sp);\n             }\n         },\n         _ => {\n             cx.span_err(expr.span, \"non-literal in hexfloat!\");\n-            return base::MacResult::dummy_expr(sp);\n+            return base::DummyResult::expr(sp);\n         }\n     };\n \n@@ -137,7 +137,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) ->\n                 let pos = expr.span.lo + syntax::codemap::Pos::from_uint(err_pos + 1);\n                 let span = syntax::codemap::mk_sp(pos,pos);\n                 cx.span_err(span, format!(\"invalid hex float literal in hexfloat!: {}\", err_str));\n-                return base::MacResult::dummy_expr(sp);\n+                return base::DummyResult::expr(sp);\n             }\n             _ => ()\n         }\n@@ -147,7 +147,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) ->\n         None => ast::LitFloatUnsuffixed(s),\n         Some (ty) => ast::LitFloat(s, ty)\n     };\n-    MRExpr(cx.expr_lit(sp, lit))\n+    MacExpr::new(cx.expr_lit(sp, lit))\n }\n \n struct Ident {"}, {"sha": "efefe885acb9dbdd30ebb29577cd2f83bf1cd354", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -45,7 +45,7 @@ impl State {\n static OPTIONS: &'static [&'static str] = &[\"volatile\", \"alignstack\", \"intel\"];\n \n pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-               -> base::MacResult {\n+               -> ~base::MacResult {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n                                            tts.iter()\n@@ -72,7 +72,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                                    \"inline assembly must be a string literal.\") {\n                     Some((s, st)) => (s, st),\n                     // let compilation continue\n-                    None => return MacResult::dummy_expr(sp),\n+                    None => return DummyResult::expr(sp),\n                 };\n                 asm = s;\n                 asm_str_style = Some(style);\n@@ -210,7 +210,7 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         inputs.push((token::intern_and_get_ident(i.to_str()), out));\n     }\n \n-    MRExpr(@ast::Expr {\n+    MacExpr::new(@ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprInlineAsm(ast::InlineAsm {\n             asm: token::intern_and_get_ident(asm.get()),"}, {"sha": "90bde60621d3b5213633f3bbcd85b54ea7b4d7c8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 106, "deletions": 38, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -50,19 +50,19 @@ pub trait MacroExpander {\n               ecx: &mut ExtCtxt,\n               span: Span,\n               token_tree: &[ast::TokenTree])\n-              -> MacResult;\n+              -> ~MacResult;\n }\n \n pub type MacroExpanderFn =\n     fn(ecx: &mut ExtCtxt, span: codemap::Span, token_tree: &[ast::TokenTree])\n-       -> MacResult;\n+       -> ~MacResult;\n \n impl MacroExpander for BasicMacroExpander {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n               token_tree: &[ast::TokenTree])\n-              -> MacResult {\n+              -> ~MacResult {\n         (self.expander)(ecx, span, token_tree)\n     }\n }\n@@ -78,7 +78,7 @@ pub trait IdentMacroExpander {\n               sp: Span,\n               ident: ast::Ident,\n               token_tree: Vec<ast::TokenTree> )\n-              -> MacResult;\n+              -> ~MacResult;\n }\n \n impl IdentMacroExpander for BasicIdentMacroExpander {\n@@ -87,62 +87,130 @@ impl IdentMacroExpander for BasicIdentMacroExpander {\n               sp: Span,\n               ident: ast::Ident,\n               token_tree: Vec<ast::TokenTree> )\n-              -> MacResult {\n+              -> ~MacResult {\n         (self.expander)(cx, sp, ident, token_tree)\n     }\n }\n \n pub type IdentMacroExpanderFn =\n-    fn(&mut ExtCtxt, Span, ast::Ident, Vec<ast::TokenTree> ) -> MacResult;\n+    fn(&mut ExtCtxt, Span, ast::Ident, Vec<ast::TokenTree> ) -> ~MacResult;\n \n pub type MacroCrateRegistrationFun =\n     fn(|ast::Name, SyntaxExtension|);\n \n-pub trait AnyMacro {\n-    fn make_expr(&self) -> @ast::Expr;\n-    fn make_items(&self) -> SmallVector<@ast::Item>;\n-    fn make_stmt(&self) -> @ast::Stmt;\n+/// The result of a macro expansion. The return values of the various\n+/// methods are spliced into the AST at the callsite of the macro (or\n+/// just into the compiler's internal macro table, for `make_def`).\n+pub trait MacResult {\n+    /// Define a new macro.\n+    fn make_def(&self) -> Option<MacroDef> {\n+        None\n+    }\n+    /// Create an expression.\n+    fn make_expr(&self) -> Option<@ast::Expr> {\n+        None\n+    }\n+    /// Create zero or more items.\n+    fn make_items(&self) -> Option<SmallVector<@ast::Item>> {\n+        None\n+    }\n+\n+    /// Create a statement.\n+    ///\n+    /// By default this attempts to create an expression statement,\n+    /// returning None if that fails.\n+    fn make_stmt(&self) -> Option<@ast::Stmt> {\n+        self.make_expr()\n+            .map(|e| @codemap::respan(e.span, ast::StmtExpr(e, ast::DUMMY_NODE_ID)))\n+    }\n }\n \n+/// A convenience type for macros that return a single expression.\n+pub struct MacExpr {\n+    e: @ast::Expr\n+}\n+impl MacExpr {\n+    pub fn new(e: @ast::Expr) -> ~MacResult {\n+        ~MacExpr { e: e } as ~MacResult\n+    }\n+}\n+impl MacResult for MacExpr {\n+    fn make_expr(&self) -> Option<@ast::Expr> {\n+        Some(self.e)\n+    }\n+}\n+/// A convenience type for macros that return a single item.\n+pub struct MacItem {\n+    i: @ast::Item\n+}\n+impl MacItem {\n+    pub fn new(i: @ast::Item) -> ~MacResult {\n+        ~MacItem { i: i } as ~MacResult\n+    }\n+}\n+impl MacResult for MacItem {\n+    fn make_items(&self) -> Option<SmallVector<@ast::Item>> {\n+        Some(SmallVector::one(self.i))\n+    }\n+    fn make_stmt(&self) -> Option<@ast::Stmt> {\n+        Some(@codemap::respan(\n+            self.i.span,\n+            ast::StmtDecl(\n+                @codemap::respan(self.i.span, ast::DeclItem(self.i)),\n+                ast::DUMMY_NODE_ID)))\n+    }\n+}\n \n-pub enum MacResult {\n-    MRExpr(@ast::Expr),\n-    MRItem(@ast::Item),\n-    MRAny(~AnyMacro:),\n-    MRDef(MacroDef),\n+/// Fill-in macro expansion result, to allow compilation to continue\n+/// after hitting errors.\n+pub struct DummyResult {\n+    expr_only: bool,\n+    span: Span\n }\n-impl MacResult {\n-    /// Create an empty expression MacResult; useful for satisfying\n-    /// type signatures after emitting a non-fatal error (which stop\n-    /// compilation well before the validity (or otherwise)) of the\n-    /// expression are checked.\n-    pub fn raw_dummy_expr(sp: codemap::Span) -> @ast::Expr {\n+\n+impl DummyResult {\n+    /// Create a default MacResult that can be anything.\n+    ///\n+    /// Use this as a return value after hitting any errors and\n+    /// calling `span_err`.\n+    pub fn any(sp: Span) -> ~MacResult {\n+        ~DummyResult { expr_only: false, span: sp } as ~MacResult\n+    }\n+\n+    /// Create a default MacResult that can only be an expression.\n+    ///\n+    /// Use this for macros that must expand to an expression, so even\n+    /// if an error is encountered internally, the user will recieve\n+    /// an error that they also used it in the wrong place.\n+    pub fn expr(sp: Span) -> ~MacResult {\n+        ~DummyResult { expr_only: true, span: sp } as ~MacResult\n+    }\n+\n+    /// A plain dummy expression.\n+    pub fn raw_expr(sp: Span) -> @ast::Expr {\n         @ast::Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::ExprLit(@codemap::respan(sp, ast::LitNil)),\n             span: sp,\n         }\n     }\n-    pub fn dummy_expr(sp: codemap::Span) -> MacResult {\n-        MRExpr(MacResult::raw_dummy_expr(sp))\n-    }\n-    pub fn dummy_any(sp: codemap::Span) -> MacResult {\n-        MRAny(~DummyMacResult { sp: sp })\n-    }\n-}\n-struct DummyMacResult {\n-    sp: codemap::Span\n }\n-impl AnyMacro for DummyMacResult {\n-    fn make_expr(&self) -> @ast::Expr {\n-        MacResult::raw_dummy_expr(self.sp)\n+\n+impl MacResult for DummyResult {\n+    fn make_expr(&self) -> Option<@ast::Expr> {\n+        Some(DummyResult::raw_expr(self.span))\n     }\n-    fn make_items(&self) -> SmallVector<@ast::Item> {\n-        SmallVector::zero()\n+    fn make_items(&self) -> Option<SmallVector<@ast::Item>> {\n+        if self.expr_only {\n+            None\n+        } else {\n+            Some(SmallVector::zero())\n+        }\n     }\n-    fn make_stmt(&self) -> @ast::Stmt {\n-        @codemap::respan(self.sp,\n-                         ast::StmtExpr(MacResult::raw_dummy_expr(self.sp), ast::DUMMY_NODE_ID))\n+    fn make_stmt(&self) -> Option<@ast::Stmt> {\n+        Some(@codemap::respan(self.span,\n+                              ast::StmtExpr(DummyResult::raw_expr(self.span),\n+                                            ast::DUMMY_NODE_ID)))\n     }\n }\n "}, {"sha": "f4680b27084f881781a6f2c04fb7e7246718bbc6", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -18,10 +18,10 @@ use ext::build::AstBuilder;\n \n use std::char;\n \n-pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::MacResult {\n+pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> ~base::MacResult {\n     // Gather all argument expressions\n     let exprs = match get_exprs_from_tts(cx, sp, tts) {\n-        None => return MacResult::dummy_expr(sp),\n+        None => return DummyResult::expr(sp),\n         Some(e) => e,\n     };\n     let mut bytes = Vec::new();\n@@ -74,5 +74,5 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) ->\n     }\n \n     let e = cx.expr_vec_slice(sp, bytes);\n-    MRExpr(e)\n+    MacExpr::new(e)\n }"}, {"sha": "8cd899738bf29d82a8a50fafc33fb67dcfcfb51f", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -26,7 +26,7 @@ use parse::token::InternedString;\n use parse::token;\n use parse;\n \n-pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::MacResult {\n+pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> ~base::MacResult {\n     let mut p = parse::new_parser_from_tts(cx.parse_sess(),\n                                            cx.cfg(),\n                                            tts.iter()\n@@ -47,5 +47,5 @@ pub fn expand_cfg(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]) -> base::M\n     let matches_cfg = attr::test_cfg(cx.cfg().as_slice(),\n                                      in_cfg.iter().map(|&x| x));\n     let e = cx.expr_bool(sp, matches_cfg);\n-    MRExpr(e)\n+    MacExpr::new(e)\n }"}, {"sha": "123271c5b5e608e18a1c50b1d8ea71296467703d", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -19,10 +19,10 @@ use std::strbuf::StrBuf;\n \n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: codemap::Span,\n-                         tts: &[ast::TokenTree]) -> base::MacResult {\n+                         tts: &[ast::TokenTree]) -> ~base::MacResult {\n     let es = match base::get_exprs_from_tts(cx, sp, tts) {\n         Some(e) => e,\n-        None => return base::MacResult::dummy_expr(sp)\n+        None => return base::DummyResult::expr(sp)\n     };\n     let mut accumulator = StrBuf::new();\n     for e in es.move_iter() {\n@@ -57,7 +57,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n             }\n         }\n     }\n-    base::MRExpr(cx.expr_str(\n+    base::MacExpr::new(cx.expr_str(\n             sp,\n             token::intern_and_get_ident(accumulator.into_owned())))\n }"}, {"sha": "9513c15c3d0b112b223a2f0637e8bdcb6e5ce763", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -19,15 +19,15 @@ use parse::token::{str_to_ident};\n use std::strbuf::StrBuf;\n \n pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> base::MacResult {\n+    -> ~base::MacResult {\n     let mut res_str = StrBuf::new();\n     for (i, e) in tts.iter().enumerate() {\n         if i & 1 == 1 {\n             match *e {\n                 ast::TTTok(_, token::COMMA) => (),\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! expecting comma.\");\n-                    return MacResult::dummy_expr(sp);\n+                    return DummyResult::expr(sp);\n                 }\n             }\n         } else {\n@@ -37,7 +37,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 }\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! requires ident args.\");\n-                    return MacResult::dummy_expr(sp);\n+                    return DummyResult::expr(sp);\n                 }\n             }\n         }\n@@ -61,5 +61,5 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         ),\n         span: sp,\n     };\n-    MRExpr(e)\n+    MacExpr::new(e)\n }"}, {"sha": "7229f5c1df9eb7bde62981cb324bffe93ee87fce", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -24,9 +24,9 @@ use parse::token;\n use std::os;\n \n pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> base::MacResult {\n+    -> ~base::MacResult {\n     let var = match get_single_str_from_tts(cx, sp, tts, \"option_env!\") {\n-        None => return MacResult::dummy_expr(sp),\n+        None => return DummyResult::expr(sp),\n         Some(v) => v\n     };\n \n@@ -56,24 +56,24 @@ pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                           s))))\n       }\n     };\n-    MRExpr(e)\n+    MacExpr::new(e)\n }\n \n pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> base::MacResult {\n+    -> ~base::MacResult {\n     let exprs = match get_exprs_from_tts(cx, sp, tts) {\n         Some(ref exprs) if exprs.len() == 0 => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n-            return MacResult::dummy_expr(sp);\n+            return DummyResult::expr(sp);\n         }\n-        None => return MacResult::dummy_expr(sp),\n+        None => return DummyResult::expr(sp),\n         Some(exprs) => exprs\n     };\n \n     let var = match expr_to_str(cx,\n                                 *exprs.get(0),\n                                 \"expected string literal\") {\n-        None => return MacResult::dummy_expr(sp),\n+        None => return DummyResult::expr(sp),\n         Some((v, _style)) => v\n     };\n     let msg = match exprs.len() {\n@@ -84,13 +84,13 @@ pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n         2 => {\n             match expr_to_str(cx, *exprs.get(1), \"expected string literal\") {\n-                None => return MacResult::dummy_expr(sp),\n+                None => return DummyResult::expr(sp),\n                 Some((s, _style)) => s\n             }\n         }\n         _ => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n-            return MacResult::dummy_expr(sp);\n+            return DummyResult::expr(sp);\n         }\n     };\n \n@@ -101,5 +101,5 @@ pub fn expand_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         }\n         Some(s) => cx.expr_str(sp, token::intern_and_get_ident(s))\n     };\n-    MRExpr(e)\n+    MacExpr::new(e)\n }"}, {"sha": "d73cb3856f95f844231ed4b5ddf058c693f1c043", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 28, "deletions": 36, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -52,7 +52,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                             format!(\"expected macro name without module \\\n                                   separators\"));\n                         // let compilation continue\n-                        return MacResult::raw_dummy_expr(e.span);\n+                        return DummyResult::raw_expr(e.span);\n                     }\n                     let extname = pth.segments.get(0).identifier;\n                     let extnamestr = token::get_ident(extname);\n@@ -65,7 +65,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                                         extnamestr.get()));\n \n                             // let compilation continue\n-                            return MacResult::raw_dummy_expr(e.span);\n+                            return DummyResult::raw_expr(e.span);\n                         }\n                         Some(&NormalTT(ref expandfun, exp_span)) => {\n                             fld.cx.bt_push(ExpnInfo {\n@@ -88,18 +88,17 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n \n                             let expanded = match expandfun.expand(fld.cx,\n                                                    mac_span.call_site,\n-                                                   marked_before.as_slice()) {\n-                                MRExpr(e) => e,\n-                                MRAny(any_macro) => any_macro.make_expr(),\n-                                _ => {\n+                                                   marked_before.as_slice()).make_expr() {\n+                                Some(e) => e,\n+                                None => {\n                                     fld.cx.span_err(\n                                         pth.span,\n                                         format!(\n                                             \"non-expr macro in expr pos: {}\",\n                                             extnamestr.get()\n                                         )\n                                     );\n-                                    return MacResult::raw_dummy_expr(e.span);\n+                                    return DummyResult::raw_expr(e.span);\n                                 }\n                             };\n \n@@ -112,7 +111,7 @@ pub fn expand_expr(e: @ast::Expr, fld: &mut MacroExpander) -> @ast::Expr {\n                                 format!(\"'{}' is not a tt-style macro\",\n                                         extnamestr.get())\n                             );\n-                            return MacResult::raw_dummy_expr(e.span);\n+                            return DummyResult::raw_expr(e.span);\n                         }\n                     };\n \n@@ -430,25 +429,8 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n         }\n     };\n \n-    let items = match expanded {\n-        MRItem(it) => {\n-            mark_item(it,fm).move_iter()\n-                .flat_map(|i| fld.fold_item(i).move_iter())\n-                .collect()\n-        }\n-        MRExpr(_) => {\n-            fld.cx.span_err(pth.span,\n-                            format!(\"expr macro in item position: {}\",\n-                                    extnamestr.get()));\n-            return SmallVector::zero();\n-        }\n-        MRAny(any_macro) => {\n-            any_macro.make_items().move_iter()\n-                    .flat_map(|i| mark_item(i, fm).move_iter())\n-                    .flat_map(|i| fld.fold_item(i).move_iter())\n-                    .collect()\n-        }\n-        MRDef(MacroDef { name, ext }) => {\n+    let items = match expanded.make_def() {\n+        Some(MacroDef { name, ext }) => {\n             // yikes... no idea how to apply the mark to this. I'm afraid\n             // we're going to have to wait-and-see on this one.\n             fld.extsbox.insert(intern(name), ext);\n@@ -458,6 +440,22 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n                 SmallVector::zero()\n             }\n         }\n+        None => {\n+            match expanded.make_items() {\n+                Some(items) => {\n+                    items.move_iter()\n+                        .flat_map(|i| mark_item(i, fm).move_iter())\n+                        .flat_map(|i| fld.fold_item(i).move_iter())\n+                        .collect()\n+                }\n+                None => {\n+                    fld.cx.span_err(pth.span,\n+                                    format!(\"expr macro in item position: {}\",\n+                                            extnamestr.get()));\n+                    return SmallVector::zero();\n+                }\n+            }\n+        }\n     };\n     fld.cx.bt_pop();\n     return items;\n@@ -593,15 +591,9 @@ pub fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<@Stmt> {\n \n             let expanded = match expandfun.expand(fld.cx,\n                                                   mac_span.call_site,\n-                                                  marked_tts.as_slice()) {\n-                MRExpr(e) => {\n-                    @codemap::Spanned {\n-                        node: StmtExpr(e, ast::DUMMY_NODE_ID),\n-                        span: e.span,\n-                    }\n-                }\n-                MRAny(any_macro) => any_macro.make_stmt(),\n-                _ => {\n+                                                  marked_tts.as_slice()).make_stmt() {\n+                Some(stmt) => stmt,\n+                None => {\n                     fld.cx.span_err(pth.span,\n                                     format!(\"non-stmt macro in stmt pos: {}\",\n                                             extnamestr));"}, {"sha": "41c74ce9ae543ebf3de529b5fd5c8c8c51d58895", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -16,11 +16,11 @@ use ext::base;\n use ext::build::AstBuilder;\n \n pub fn expand_syntax_ext(ecx: &mut base::ExtCtxt, sp: Span,\n-                         _tts: &[ast::TokenTree]) -> base::MacResult {\n+                         _tts: &[ast::TokenTree]) -> ~base::MacResult {\n     ecx.span_err(sp, \"`fmt!` is deprecated, use `format!` instead\");\n     ecx.parse_sess.span_diagnostic.span_note(sp,\n         \"see http://static.rust-lang.org/doc/master/std/fmt/index.html \\\n          for documentation\");\n \n-    base::MRExpr(ecx.expr_uint(sp, 2))\n+    base::MacExpr::new(ecx.expr_uint(sp, 2))\n }"}, {"sha": "86c7ae28ac2db41d408672ccdccd2334f39d6a64", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -806,14 +806,14 @@ impl<'a, 'b> Context<'a, 'b> {\n }\n \n pub fn expand_args(ecx: &mut ExtCtxt, sp: Span,\n-                   tts: &[ast::TokenTree]) -> base::MacResult {\n+                   tts: &[ast::TokenTree]) -> ~base::MacResult {\n \n     match parse_args(ecx, sp, tts) {\n         (extra, Some((efmt, args, order, names))) => {\n-            MRExpr(expand_preparsed_format_args(ecx, sp, extra, efmt, args,\n+            MacExpr::new(expand_preparsed_format_args(ecx, sp, extra, efmt, args,\n                                                 order, names))\n         }\n-        (_, None) => MRExpr(ecx.expr_uint(sp, 2))\n+        (_, None) => MacExpr::new(ecx.expr_uint(sp, 2))\n     }\n }\n \n@@ -845,7 +845,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                 efmt,\n                                 \"format argument must be a string literal.\") {\n         Some((fmt, _)) => fmt,\n-        None => return MacResult::raw_dummy_expr(sp)\n+        None => return DummyResult::raw_expr(sp)\n     };\n \n     let mut parser = parse::Parser::new(fmt.get());\n@@ -863,7 +863,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     match parser.errors.shift() {\n         Some(error) => {\n             cx.ecx.span_err(efmt.span, \"invalid format string: \" + error);\n-            return MacResult::raw_dummy_expr(sp);\n+            return DummyResult::raw_expr(sp);\n         }\n         None => {}\n     }"}, {"sha": "666bc486fbf0beaaab4960ff88556c9247f37ea1", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -18,12 +18,12 @@ use std::rc::Rc;\n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: codemap::Span,\n                          tt: &[ast::TokenTree])\n-                      -> base::MacResult {\n+                      -> ~base::MacResult {\n \n     cx.print_backtrace();\n     println!(\"{}\", print::pprust::tt_to_str(&ast::TTDelim(\n                 Rc::new(tt.iter().map(|x| (*x).clone()).collect()))));\n \n     // any so that `log_syntax` can be invoked as an expression and item.\n-    base::MacResult::dummy_any(sp)\n+    base::DummyResult::any(sp)\n }"}, {"sha": "7664d089149229ece423e8968b069b9e1da73889", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -289,53 +289,53 @@ pub mod rt {\n \n pub fn expand_quote_tokens(cx: &mut ExtCtxt,\n                            sp: Span,\n-                           tts: &[ast::TokenTree]) -> base::MacResult {\n+                           tts: &[ast::TokenTree]) -> ~base::MacResult {\n     let (cx_expr, expr) = expand_tts(cx, sp, tts);\n     let expanded = expand_wrapper(cx, sp, cx_expr, expr);\n-    base::MRExpr(expanded)\n+    base::MacExpr::new(expanded)\n }\n \n pub fn expand_quote_expr(cx: &mut ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::TokenTree]) -> base::MacResult {\n+                         tts: &[ast::TokenTree]) -> ~base::MacResult {\n     let expanded = expand_parse_call(cx, sp, \"parse_expr\", Vec::new(), tts);\n-    base::MRExpr(expanded)\n+    base::MacExpr::new(expanded)\n }\n \n pub fn expand_quote_item(cx: &mut ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::TokenTree]) -> base::MacResult {\n+                         tts: &[ast::TokenTree]) -> ~base::MacResult {\n     let e_attrs = cx.expr_vec_ng(sp);\n     let expanded = expand_parse_call(cx, sp, \"parse_item\",\n                                     vec!(e_attrs), tts);\n-    base::MRExpr(expanded)\n+    base::MacExpr::new(expanded)\n }\n \n pub fn expand_quote_pat(cx: &mut ExtCtxt,\n                         sp: Span,\n-                        tts: &[ast::TokenTree]) -> base::MacResult {\n+                        tts: &[ast::TokenTree]) -> ~base::MacResult {\n     let e_refutable = cx.expr_lit(sp, ast::LitBool(true));\n     let expanded = expand_parse_call(cx, sp, \"parse_pat\",\n                                     vec!(e_refutable), tts);\n-    base::MRExpr(expanded)\n+    base::MacExpr::new(expanded)\n }\n \n pub fn expand_quote_ty(cx: &mut ExtCtxt,\n                        sp: Span,\n-                       tts: &[ast::TokenTree]) -> base::MacResult {\n+                       tts: &[ast::TokenTree]) -> ~base::MacResult {\n     let e_param_colons = cx.expr_lit(sp, ast::LitBool(false));\n     let expanded = expand_parse_call(cx, sp, \"parse_ty\",\n                                      vec!(e_param_colons), tts);\n-    base::MRExpr(expanded)\n+    base::MacExpr::new(expanded)\n }\n \n pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n                          sp: Span,\n-                         tts: &[ast::TokenTree]) -> base::MacResult {\n+                         tts: &[ast::TokenTree]) -> ~base::MacResult {\n     let e_attrs = cx.expr_vec_ng(sp);\n     let expanded = expand_parse_call(cx, sp, \"parse_stmt\",\n                                     vec!(e_attrs), tts);\n-    base::MRExpr(expanded)\n+    base::MacExpr::new(expanded)\n }\n \n fn ids_ext(strs: Vec<~str> ) -> Vec<ast::Ident> {"}, {"sha": "7f1d81722557e68d027c7d05fd10d45027b10cc2", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -29,63 +29,63 @@ use std::str;\n \n /* line!(): expands to the current line number */\n pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> base::MacResult {\n+    -> ~base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n     let topmost = topmost_expn_info(cx.backtrace().unwrap());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n \n-    base::MRExpr(cx.expr_uint(topmost.call_site, loc.line))\n+    base::MacExpr::new(cx.expr_uint(topmost.call_site, loc.line))\n }\n \n /* col!(): expands to the current column number */\n pub fn expand_col(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> base::MacResult {\n+    -> ~base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n     let topmost = topmost_expn_info(cx.backtrace().unwrap());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    base::MRExpr(cx.expr_uint(topmost.call_site, loc.col.to_uint()))\n+    base::MacExpr::new(cx.expr_uint(topmost.call_site, loc.col.to_uint()))\n }\n \n /* file!(): expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> base::MacResult {\n+    -> ~base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n     let topmost = topmost_expn_info(cx.backtrace().unwrap());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n     let filename = token::intern_and_get_ident(loc.file.name);\n-    base::MRExpr(cx.expr_str(topmost.call_site, filename))\n+    base::MacExpr::new(cx.expr_str(topmost.call_site, filename))\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> base::MacResult {\n+    -> ~base::MacResult {\n     let s = pprust::tts_to_str(tts);\n-    base::MRExpr(cx.expr_str(sp, token::intern_and_get_ident(s)))\n+    base::MacExpr::new(cx.expr_str(sp, token::intern_and_get_ident(s)))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> base::MacResult {\n+    -> ~base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let string = cx.mod_path()\n                    .iter()\n                    .map(|x| token::get_ident(*x).get().to_str())\n                    .collect::<Vec<~str>>()\n                    .connect(\"::\");\n-    base::MRExpr(cx.expr_str(sp, token::intern_and_get_ident(string)))\n+    base::MacExpr::new(cx.expr_str(sp, token::intern_and_get_ident(string)))\n }\n \n // include! : parse the given file as an expr\n // This is generally a bad idea because it's going to behave\n // unhygienically.\n pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> base::MacResult {\n+    -> ~base::MacResult {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include!\") {\n         Some(f) => f,\n-        None => return MacResult::dummy_expr(sp),\n+        None => return DummyResult::expr(sp),\n     };\n     // The file will be added to the code map by the parser\n     let mut p =\n@@ -95,21 +95,21 @@ pub fn expand_include(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                                       sp,\n                                                       &Path::new(file)),\n                                         sp);\n-    base::MRExpr(p.parse_expr())\n+    base::MacExpr::new(p.parse_expr())\n }\n \n // include_str! : read the given file, insert it as a literal string expr\n pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-    -> base::MacResult {\n+    -> ~base::MacResult {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_str!\") {\n         Some(f) => f,\n-        None => return MacResult::dummy_expr(sp)\n+        None => return DummyResult::expr(sp)\n     };\n     let file = res_rel_file(cx, sp, &Path::new(file));\n     let bytes = match File::open(&file).read_to_end() {\n         Err(e) => {\n             cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e));\n-            return MacResult::dummy_expr(sp);\n+            return DummyResult::expr(sp);\n         }\n         Ok(bytes) => bytes,\n     };\n@@ -121,31 +121,31 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             let interned = token::intern_and_get_ident(src);\n             cx.codemap().new_filemap(filename, src.to_owned());\n \n-            base::MRExpr(cx.expr_str(sp, interned))\n+            base::MacExpr::new(cx.expr_str(sp, interned))\n         }\n         None => {\n             cx.span_err(sp, format!(\"{} wasn't a utf-8 file\", file.display()));\n-            return MacResult::dummy_expr(sp);\n+            return DummyResult::expr(sp);\n         }\n     }\n }\n \n pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n-        -> base::MacResult\n+        -> ~base::MacResult\n {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_bin!\") {\n         Some(f) => f,\n-        None => return MacResult::dummy_expr(sp)\n+        None => return DummyResult::expr(sp)\n     };\n     let file = res_rel_file(cx, sp, &Path::new(file));\n     match File::open(&file).read_to_end() {\n         Err(e) => {\n             cx.span_err(sp, format!(\"couldn't read {}: {}\", file.display(), e));\n-            return MacResult::dummy_expr(sp);\n+            return DummyResult::expr(sp);\n         }\n         Ok(bytes) => {\n             let bytes = bytes.iter().map(|x| *x).collect();\n-            base::MRExpr(cx.expr_lit(sp, ast::LitBinary(Rc::new(bytes))))\n+            base::MacExpr::new(cx.expr_lit(sp, ast::LitBinary(Rc::new(bytes))))\n         }\n     }\n }"}, {"sha": "d428251604c953d723f6ec1a801032a23b4b10b0", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -17,7 +17,7 @@ use parse::token::{keywords, is_keyword};\n pub fn expand_trace_macros(cx: &mut ExtCtxt,\n                            sp: Span,\n                            tt: &[ast::TokenTree])\n-                        -> base::MacResult {\n+                        -> ~base::MacResult {\n     match tt {\n         [ast::TTTok(_, ref tok)] if is_keyword(keywords::True, tok) => {\n             cx.set_trace_macros(true);\n@@ -28,5 +28,5 @@ pub fn expand_trace_macros(cx: &mut ExtCtxt,\n         _ => cx.span_err(sp, \"trace_macros! accepts only `true` or `false`\"),\n     }\n \n-    base::MacResult::dummy_any(sp)\n+    base::DummyResult::any(sp)\n }"}, {"sha": "279544d106ea49752f9e3113b8589e0251cda73c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -12,7 +12,7 @@ use ast::{Ident, Matcher_, Matcher, MatchTok, MatchNonterminal, MatchSeq};\n use ast::{TTDelim};\n use ast;\n use codemap::{Span, Spanned, DUMMY_SP};\n-use ext::base::{AnyMacro, ExtCtxt, MacResult, MRAny, MRDef, MacroDef};\n+use ext::base::{ExtCtxt, MacResult, MacroDef};\n use ext::base::{NormalTT, MacroExpander};\n use ext::base;\n use ext::tt::macro_parser::{Success, Error, Failure};\n@@ -57,13 +57,13 @@ impl<'a> ParserAnyMacro<'a> {\n     }\n }\n \n-impl<'a> AnyMacro for ParserAnyMacro<'a> {\n-    fn make_expr(&self) -> @ast::Expr {\n+impl<'a> MacResult for ParserAnyMacro<'a> {\n+    fn make_expr(&self) -> Option<@ast::Expr> {\n         let ret = self.parser.borrow_mut().parse_expr();\n         self.ensure_complete_parse(true);\n-        ret\n+        Some(ret)\n     }\n-    fn make_items(&self) -> SmallVector<@ast::Item> {\n+    fn make_items(&self) -> Option<SmallVector<@ast::Item>> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();\n@@ -74,13 +74,13 @@ impl<'a> AnyMacro for ParserAnyMacro<'a> {\n             }\n         }\n         self.ensure_complete_parse(false);\n-        ret\n+        Some(ret)\n     }\n-    fn make_stmt(&self) -> @ast::Stmt {\n+    fn make_stmt(&self) -> Option<@ast::Stmt> {\n         let attrs = self.parser.borrow_mut().parse_outer_attributes();\n         let ret = self.parser.borrow_mut().parse_stmt(attrs);\n         self.ensure_complete_parse(true);\n-        ret\n+        Some(ret)\n     }\n }\n \n@@ -95,7 +95,7 @@ impl MacroExpander for MacroRulesMacroExpander {\n               cx: &mut ExtCtxt,\n               sp: Span,\n               arg: &[ast::TokenTree])\n-              -> MacResult {\n+              -> ~MacResult {\n         generic_extension(cx,\n                           sp,\n                           self.name,\n@@ -105,14 +105,23 @@ impl MacroExpander for MacroRulesMacroExpander {\n     }\n }\n \n+struct MacroRulesDefiner {\n+    def: RefCell<Option<MacroDef>>\n+}\n+impl MacResult for MacroRulesDefiner {\n+    fn make_def(&self) -> Option<MacroDef> {\n+        Some(self.def.borrow_mut().take().expect(\"MacroRulesDefiner expanded twice\"))\n+    }\n+}\n+\n // Given `lhses` and `rhses`, this is the new macro we create\n fn generic_extension(cx: &ExtCtxt,\n                      sp: Span,\n                      name: Ident,\n                      arg: &[ast::TokenTree],\n                      lhses: &[Rc<NamedMatch>],\n                      rhses: &[Rc<NamedMatch>])\n-                     -> MacResult {\n+                     -> ~MacResult {\n     if cx.trace_macros() {\n         println!(\"{}! \\\\{ {} \\\\}\",\n                  token::get_ident(name),\n@@ -160,9 +169,9 @@ fn generic_extension(cx: &ExtCtxt,\n                 let p = Parser(cx.parse_sess(), cx.cfg(), ~trncbr);\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n-                return MRAny(~ParserAnyMacro {\n+                return ~ParserAnyMacro {\n                     parser: RefCell::new(p),\n-                })\n+                } as ~MacResult\n               }\n               Failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                 best_fail_spot = sp;\n@@ -184,7 +193,7 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n                          sp: Span,\n                          name: Ident,\n                          arg: Vec<ast::TokenTree> )\n-                         -> base::MacResult {\n+                         -> ~base::MacResult {\n     // these spans won't matter, anyways\n     fn ms(m: Matcher_) -> Matcher {\n         Spanned {\n@@ -236,8 +245,10 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n         rhses: rhses,\n     };\n \n-    return MRDef(MacroDef {\n-        name: token::get_ident(name).to_str(),\n-        ext: NormalTT(exp, Some(sp))\n-    });\n+    ~MacroRulesDefiner {\n+        def: RefCell::new(Some(MacroDef {\n+            name: token::get_ident(name).to_str(),\n+            ext: NormalTT(exp, Some(sp))\n+        }))\n+    } as ~MacResult\n }"}, {"sha": "070bb6dfcb793c906753ccc16cc801f7ff8a89fd", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99dd5911a1026da0a374b697e4a0407a631eb388/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=99dd5911a1026da0a374b697e4a0407a631eb388", "patch": "@@ -35,11 +35,11 @@ pub fn macro_registrar(register: |Name, SyntaxExtension|) {\n     register(token::intern(\"into_foo\"), ItemModifier(expand_into_foo));\n }\n \n-fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> MacResult {\n+fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> ~MacResult {\n     if !tts.is_empty() {\n         cx.span_fatal(sp, \"make_a_1 takes no arguments\");\n     }\n-    MRExpr(quote_expr!(cx, 1i))\n+    MacExpr::new(quote_expr!(cx, 1i))\n }\n \n fn expand_into_foo(cx: &mut ExtCtxt, sp: Span, attr: @MetaItem, it: @Item)"}]}