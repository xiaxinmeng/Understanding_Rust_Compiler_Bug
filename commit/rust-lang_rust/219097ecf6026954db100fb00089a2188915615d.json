{"sha": "219097ecf6026954db100fb00089a2188915615d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxOTA5N2VjZjYwMjY5NTRkYjEwMGZiMDAwODlhMjE4ODkxNTYxNWQ=", "commit": {"author": {"name": "Masaki Hara", "email": "ackie.h.gmai@gmail.com", "date": "2018-10-28T06:36:58Z"}, "committer": {"name": "CrLF0710", "email": "crlf0710@gmail.com", "date": "2019-04-04T18:26:56Z"}, "message": "Add unstable-book articles on fnbox and boxed_closure_impls.", "tree": {"sha": "4f4fce629c2f44b5305df11f3cb7f1e0f98c39bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f4fce629c2f44b5305df11f3cb7f1e0f98c39bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/219097ecf6026954db100fb00089a2188915615d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/219097ecf6026954db100fb00089a2188915615d", "html_url": "https://github.com/rust-lang/rust/commit/219097ecf6026954db100fb00089a2188915615d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/219097ecf6026954db100fb00089a2188915615d/comments", "author": {"login": "qnighy", "id": 41755, "node_id": "MDQ6VXNlcjQxNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/41755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qnighy", "html_url": "https://github.com/qnighy", "followers_url": "https://api.github.com/users/qnighy/followers", "following_url": "https://api.github.com/users/qnighy/following{/other_user}", "gists_url": "https://api.github.com/users/qnighy/gists{/gist_id}", "starred_url": "https://api.github.com/users/qnighy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qnighy/subscriptions", "organizations_url": "https://api.github.com/users/qnighy/orgs", "repos_url": "https://api.github.com/users/qnighy/repos", "events_url": "https://api.github.com/users/qnighy/events{/privacy}", "received_events_url": "https://api.github.com/users/qnighy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "480dcb403caa90ecd2cc717ad4801805c010d3f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/480dcb403caa90ecd2cc717ad4801805c010d3f6", "html_url": "https://github.com/rust-lang/rust/commit/480dcb403caa90ecd2cc717ad4801805c010d3f6"}], "stats": {"total": 350, "additions": 350, "deletions": 0}, "files": [{"sha": "0c738d0f78e03365a7af16b5204fc7dc3f7b10fa", "filename": "src/doc/unstable-book/src/library-features/boxed-closure-impls.md", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/219097ecf6026954db100fb00089a2188915615d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fboxed-closure-impls.md", "raw_url": "https://github.com/rust-lang/rust/raw/219097ecf6026954db100fb00089a2188915615d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fboxed-closure-impls.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fboxed-closure-impls.md?ref=219097ecf6026954db100fb00089a2188915615d", "patch": "@@ -0,0 +1,98 @@\n+# `boxed_closure_impls`\n+\n+The tracking issue for this feature is [#48055]\n+\n+[#48055]: https://github.com/rust-lang/rust/issues/48055\n+\n+------------------------\n+\n+This includes the following blanket impls for closure traits:\n+\n+```rust,ignore\n+impl<A, F: FnOnce<A> + ?Sized> FnOnce for Box<F> {\n+    // ...\n+}\n+impl<A, F: FnMut<A> + ?Sized> FnMut for Box<F> {\n+    // ...\n+}\n+impl<A, F: Fn<A> + ?Sized> Fn for Box<F> {\n+    // ...\n+}\n+```\n+\n+## Usage\n+\n+`Box` can be used almost transparently. You can even use `Box<dyn FnOnce>` now.\n+\n+```rust\n+#![feature(boxed_closure_impls)]\n+\n+fn main() {\n+    let resource = \"hello\".to_owned();\n+    // Create a boxed once-callable closure\n+    let f: Box<dyn FnOnce(&i32)> = Box::new(|x| {\n+        let s = resource;\n+        println!(\"{}\", x);\n+        println!(\"{}\", s);\n+    });\n+\n+    // Call it\n+    f();\n+}\n+```\n+\n+## The reason for instability\n+\n+This is unstable because of the first impl.\n+\n+It would have been easy if we're allowed to tighten the bound:\n+\n+```rust,ignore\n+impl<A, F: FnMut<A> + ?Sized> FnOnce for Box<F> {\n+    // ...\n+}\n+```\n+\n+However, `Box<dyn FnOnce()>` drops out of the modified impl.\n+To rescue this, we had had a temporary solution called [`fnbox`][fnbox].\n+\n+[fnbox]: library-features/fnbox.html\n+\n+Unfortunately, due to minor coherence reasons, `fnbox` and\n+`FnOnce for Box<impl FnMut>` had not been able to coexist.\n+We had preferred `fnbox` for the time being.\n+\n+Now, as [`unsized_locals`][unsized_locals] is implemented, we can just write the\n+original impl:\n+\n+[unsized_locals]: language-features/unsized-locals.html\n+\n+```rust,ignore\n+impl<A, F: FnOnce<A> + ?Sized> FnOnce for Box<F> {\n+    type Output = <F as FnOnce<A>>::Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: A) -> Self::Output {\n+        // *self is an unsized rvalue\n+        <F as FnOnce<A>>::call_once(*self, args)\n+    }\n+}\n+```\n+\n+However, since `unsized_locals` is a very young feature, we're careful about\n+this `FnOnce` impl now.\n+\n+There's another reason for instability: for compatibility with `fnbox`,\n+we currently allow specialization of the `Box<impl FnOnce>` impl:\n+\n+```rust,ignore\n+impl<A, F: FnOnce<A> + ?Sized> FnOnce for Box<F> {\n+    type Output = <F as FnOnce<A>>::Output;\n+\n+    // we have \"default\" here\n+    default extern \"rust-call\" fn call_once(self, args: A) -> Self::Output {\n+        <F as FnOnce<A>>::call_once(*self, args)\n+    }\n+}\n+```\n+\n+This isn't what we desire in the long term."}, {"sha": "3200601e557f6f799d91b8bc2ebd6d4de6aad723", "filename": "src/doc/unstable-book/src/library-features/fnbox.md", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/219097ecf6026954db100fb00089a2188915615d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffnbox.md", "raw_url": "https://github.com/rust-lang/rust/raw/219097ecf6026954db100fb00089a2188915615d/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffnbox.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffnbox.md?ref=219097ecf6026954db100fb00089a2188915615d", "patch": "@@ -0,0 +1,252 @@\n+# `fnbox`\n+\n+The tracking issue for this feature is [#28796]\n+\n+[#28796]: https://github.com/rust-lang/rust/issues/28796\n+\n+------------------------\n+\n+As an analogy to `&dyn Fn()` and `&mut dyn FnMut()`, you may have expected\n+`Box<dyn FnOnce()>` to work. But it hadn't until the recent improvement!\n+`FnBox` had been a **temporary** solution for this until we are able to pass\n+trait objects by value.\n+\n+See [`boxed_closure_impls`][boxed_closure_impls] for the newer approach.\n+\n+[boxed_closure_impls]: library-features/boxed-closure-impls.html\n+\n+## Usage\n+\n+If you want to box `FnOnce` closures, you can use `Box<dyn FnBox()>` instead of `Box<dyn FnOnce()>`.\n+\n+```rust\n+#![feature(fnbox)]\n+\n+use std::boxed::FnBox;\n+\n+fn main() {\n+    let resource = \"hello\".to_owned();\n+    // Create a boxed once-callable closure\n+    let f: Box<dyn FnBox() -> String> = Box::new(|| resource);\n+\n+    // Call it\n+    let s = f();\n+    println!(\"{}\", s);\n+}\n+```\n+\n+## How `Box<dyn FnOnce()>` did not work\n+\n+**Spoiler**: [`boxed_closure_impls`][boxed_closure_impls] actually implements\n+`Box<dyn FnOnce()>`! This didn't work because we lacked features like\n+[`unsized_locals`][unsized_locals] for a long time. Therefore, this section\n+just explains historical reasons for `FnBox`.\n+\n+[unsized_locals]: language-features/unsized-locals.html\n+\n+### First approach: just provide `Box` adapter impl\n+\n+The first (and natural) attempt for `Box<dyn FnOnce()>` would look like:\n+\n+```rust,ignore\n+impl<A, F: FnOnce<A> + ?Sized> FnOnce<A> for Box<F> {\n+    type Output = <F as FnOnce<A>>::Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: A) -> Self::Output {\n+        <F as FnOnce<A>>::call_once(*self, args)\n+    }\n+}\n+```\n+\n+However, this doesn't work. We have to relax the `Sized` bound for `F` because\n+we expect trait objects here, but `*self` must be `Sized` because it is passed\n+as a function argument.\n+\n+### The second attempt: add `FnOnce::call_box`\n+\n+One may come up with this workaround: modify `FnOnce`'s definition like this:\n+\n+```rust,ignore\n+pub trait FnOnce<Args> {\n+    type Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+    // Add this new method\n+    extern \"rust-call\" fn call_box(self: Box<Self>, args: Args) -> Self::Output;\n+}\n+```\n+\n+...and then, modify the `impl` like this:\n+\n+```rust,ignore\n+impl<A, F: FnOnce<A> + ?Sized> FnOnce<A> for Box<F> {\n+    type Output = <F as FnOnce<A>>::Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: A) -> Self::Output {\n+        // We can use `call_box` here!\n+        <F as FnOnce<A>>::call_box(self, args)\n+    }\n+    // We'll have to define this in every impl of `FnOnce`.\n+    extern \"rust-call\" fn call_box(self: Box<Self>, args: A) -> Self::Output {\n+        <F as FnOnce<A>>::call_box(*self, args)\n+    }\n+}\n+```\n+\n+What's wrong with this? The problem here is crates:\n+\n+- `FnOnce` is in `libcore`, as it shouldn't depend on allocations.\n+- `Box` is in `liballoc`, as it:s the very allocated pointer.\n+\n+It is impossible to add `FnOnce::call_box` because it is reverse-dependency.\n+\n+There's another problem: `call_box` can't have defaults.\n+`default impl` from the specialization RFC may resolve this problem.\n+\n+### The third attempt: add `FnBox` that contains `call_box`\n+\n+`call_box` can't reside in `FnOnce`, but how about defining a new trait in\n+`liballoc`?\n+\n+`FnBox` is almost a copy of `FnOnce`, but with `call_box`:\n+\n+```rust,ignore\n+pub trait FnBox<Args> {\n+    type Output;\n+\n+    extern \"rust-call\" fn call_box(self: Box<Self>, args: Args) -> Self::Output;\n+}\n+```\n+\n+For `Sized` types (from which we coerce into `dyn FnBox`), we define\n+the blanket impl that proxies calls to `FnOnce`:\n+\n+```rust,ignore\n+impl<A, F: FnOnce<A>> FnBox<A> for F {\n+    type Output = <F as FnOnce<A>>::Output;\n+\n+    extern \"rust-call\" fn call_box(self: Box<Self>, args: A) -> Self::Output {\n+        // Here we assume `F` to be sized.\n+        <F as FnOnce<A>>::call_once(*self, args)\n+    }\n+}\n+```\n+\n+Now it looks like that we can define `FnOnce` for `Box<F>`.\n+\n+```rust,ignore\n+impl<A, F: FnBox<A> + ?Sized> FnOnce<A> for Box<F> {\n+    type Output = <F as FnOnce<A>>::Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: A) -> Self::Output {\n+        <F as FnBox<A>>::call_box(self, args)\n+    }\n+}\n+```\n+\n+## Limitations of `FnBox`\n+\n+### Interaction with HRTB\n+\n+Firstly, the actual implementation is different from the one presented above.\n+Instead of implementing `FnOnce` for `Box<impl FnBox>`, `liballoc` only\n+implements `FnOnce` for `Box<dyn FnBox>`.\n+\n+```rust,ignore\n+impl<'a, A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + 'a> {\n+    type Output = R;\n+\n+    extern \"rust-call\" fn call_once(self, args: A) -> Self::Output {\n+        FnBox::call_box(*self, args)\n+    }\n+}\n+\n+// Sendable variant\n+impl<'a, A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + Send + 'a> {\n+    type Output = R;\n+\n+    extern \"rust-call\" fn call_once(self, args: A) -> Self::Output {\n+        FnBox::call_box(*self, args)\n+    }\n+}\n+```\n+\n+The consequence is that the following example doesn't work:\n+\n+```rust,compile_fail\n+#![feature(fnbox)]\n+\n+use std::boxed::FnBox;\n+\n+fn main() {\n+    let f: Box<dyn FnBox(&i32)> = Box::new(|x| println!(\"{}\", x));\n+    f(42);\n+}\n+```\n+\n+Note that `dyn FnBox(&i32)` desugars to\n+`dyn for<'r> FnBox<(&'r i32,), Output = ()>`.\n+It isn't covered in `dyn FnBox<A, Output = R> + 'a` or\n+`dyn FnBox<A, Output = R> + Send + 'a` due to HRTB.\n+\n+### Interaction with `Fn`/`FnMut`\n+\n+It would be natural to have the following impls:\n+\n+```rust,ignore\n+impl<A, F: FnMut<A> + ?Sized> FnMut<A> for Box<F> {\n+    // ...\n+}\n+impl<A, F: Fn<A> + ?Sized> Fn<A> for Box<F> {\n+    // ...\n+}\n+```\n+\n+However, we hadn't been able to write these in presense of `FnBox`\n+(until [`boxed_closure_impls`][boxed_closure_impls] lands).\n+\n+To have `FnMut<A>` for `Box<F>`, we should have (at least) this impl:\n+\n+```rust,ignore\n+// Note here we only impose `F: FnMut<A>`.\n+// If we can write `F: FnOnce<A>` here, that will resolve all problems.\n+impl<A, F: FnMut<A> + ?Sized> FnOnce<A> for Box<F> {\n+    // ...\n+}\n+```\n+\n+Unfortunately, the compiler complains that it **overlaps** with our\n+`dyn FnBox()` impls. At first glance, the overlap must not happen.\n+The `A` generic parameter does the trick here: due to coherence rules,\n+a downstream crate may define the following impl:\n+\n+```rust,ignore\n+struct MyStruct;\n+impl<'a> FnMut<MyStruct> for dyn FnBox<MyStruct, Output = ()> + 'a {\n+    // ...\n+}\n+```\n+\n+The trait solver doesn't know that `A` is always a tuple type, so this is\n+still possible. With this in mind, the compiler emits the overlap error.\n+\n+## Modification\n+\n+For compatibility with [`boxed_closure_impls`][boxed_closure_impls],\n+we now have a slightly modified version of `FnBox`:\n+\n+```rust,ignore\n+// It's now a subtrait of `FnOnce`\n+pub trait FnBox<Args>: FnOnce<Args> {\n+    // now uses FnOnce::Output\n+    // type Output;\n+\n+    extern \"rust-call\" fn call_box(self: Box<Self>, args: Args) -> Self::Output;\n+}\n+```\n+\n+## The future of `fnbox`\n+\n+`FnBox` has long been considered a temporary solution for `Box<FnOnce>`\n+problem. Since we have [`boxed_closure_impls`][boxed_closure_impls] now,\n+it may be deprecated and removed in the future."}]}