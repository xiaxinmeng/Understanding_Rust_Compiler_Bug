{"sha": "7366d105cb29100c6522619abbabe57777240778", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNjZkMTA1Y2IyOTEwMGM2NTIyNjE5YWJiYWJlNTc3NzcyNDA3Nzg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-07T21:04:01Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-08T02:22:41Z"}, "message": "Refactor away Target", "tree": {"sha": "82ccaa1388da12c749e9586476c6052b6e0a95dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82ccaa1388da12c749e9586476c6052b6e0a95dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7366d105cb29100c6522619abbabe57777240778", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7366d105cb29100c6522619abbabe57777240778", "html_url": "https://github.com/rust-lang/rust/commit/7366d105cb29100c6522619abbabe57777240778", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7366d105cb29100c6522619abbabe57777240778/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "661b7ce830c1d3313f0fd4456c0f55583711730c", "url": "https://api.github.com/repos/rust-lang/rust/commits/661b7ce830c1d3313f0fd4456c0f55583711730c", "html_url": "https://github.com/rust-lang/rust/commit/661b7ce830c1d3313f0fd4456c0f55583711730c"}], "stats": {"total": 170, "additions": 75, "deletions": 95}, "files": [{"sha": "b2f60ddb8da617781fb601c63128fd2fc21e2746", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7366d105cb29100c6522619abbabe57777240778/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7366d105cb29100c6522619abbabe57777240778/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7366d105cb29100c6522619abbabe57777240778", "patch": "@@ -92,8 +92,7 @@ use std::cell::{Cell, RefCell};\n use std::fmt;\n use std::mem::replace;\n \n-use resolve_imports::{Target, ImportDirective, ImportResolution};\n-use resolve_imports::Shadowable;\n+use resolve_imports::{ImportDirective, ImportResolution};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -951,6 +950,7 @@ bitflags! {\n         // Variants are considered `PUBLIC`, but some of them live in private enums.\n         // We need to track them to prohibit reexports like `pub use PrivEnum::Variant`.\n         const PRIVATE_VARIANT = 1 << 2,\n+        const PRELUDE = 1 << 3,\n     }\n }\n \n@@ -1291,10 +1291,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                            name);\n                     return Indeterminate;\n                 }\n-                Success((target, used_proxy)) => {\n+                Success((binding, used_proxy)) => {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n-                    if let Some(module_def) = target.binding.module() {\n+                    if let Some(module_def) = binding.module() {\n                         search_module = module_def;\n \n                         // Keep track of the closest private module used\n@@ -1390,7 +1390,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 debug!(\"(resolving module path for import) indeterminate; bailing\");\n                                 return Indeterminate;\n                             }\n-                            Success((target, _)) => match target.binding.module() {\n+                            Success((binding, _)) => match binding.module() {\n                                 Some(containing_module) => {\n                                     search_module = containing_module;\n                                     start_index = 1;\n@@ -1424,7 +1424,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                      name: Name,\n                                      namespace: Namespace,\n                                      record_used: bool)\n-                                     -> ResolveResult<(Target<'a>, bool)> {\n+                                     -> ResolveResult<(NameBinding<'a>, bool)> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in namespace {:?} in `{}`\",\n                name,\n                namespace,\n@@ -1446,10 +1446,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     debug!(\"(resolving item in lexical scope) indeterminate higher scope; bailing\");\n                     return Indeterminate;\n                 }\n-                Success((target, used_reexport)) => {\n+                Success((binding, used_reexport)) => {\n                     // We found the module.\n                     debug!(\"(resolving item in lexical scope) found name in module, done\");\n-                    return Success((target, used_reexport));\n+                    return Success((binding, used_reexport));\n                 }\n             }\n \n@@ -1543,7 +1543,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     /// Attempts to resolve the supplied name in the given module for the\n-    /// given namespace. If successful, returns the target corresponding to\n+    /// given namespace. If successful, returns the binding corresponding to\n     /// the name.\n     ///\n     /// The boolean returned on success is an indicator of whether this lookup\n@@ -1554,7 +1554,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               namespace: Namespace,\n                               allow_private_imports: bool,\n                               record_used: bool)\n-                              -> ResolveResult<(Target<'a>, bool)> {\n+                              -> ResolveResult<(NameBinding<'a>, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n                name,\n                module_to_string(&*module_));\n@@ -1570,7 +1570,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     self.used_crates.insert(krate);\n                 }\n             }\n-            return Success((Target::new(module_, binding, Shadowable::Never), false));\n+            return Success((binding, false));\n         }\n \n         // Check the list of resolved imports.\n@@ -1580,12 +1580,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     debug!(\"(resolving name in module) import unresolved; bailing out\");\n                     return Indeterminate;\n                 }\n-                if let Some(target) = import_resolution.target.clone() {\n+                if let Some(binding) = import_resolution.binding.clone() {\n                     debug!(\"(resolving name in module) resolved to import\");\n                     if record_used {\n                         self.record_import_use(name, namespace, &import_resolution);\n                     }\n-                    return Success((target, true));\n+                    return Success((binding, true));\n                 }\n             }\n             Some(..) | None => {} // Continue.\n@@ -2616,11 +2616,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        -> BareIdentifierPatternResolution {\n         let module = self.current_module;\n         match self.resolve_item_in_lexical_scope(module, name, ValueNS, true) {\n-            Success((target, _)) => {\n+            Success((binding, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in finding {} at {:?}\",\n                        name,\n-                       &target.binding);\n-                match target.binding.def() {\n+                       &binding);\n+                match binding.def() {\n                     None => {\n                         panic!(\"resolved name in the value namespace to a set of name bindings \\\n                                 with no def?!\");\n@@ -2776,7 +2776,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let module = self.current_module;\n         let name = identifier.unhygienic_name;\n         match self.resolve_item_in_lexical_scope(module, name, namespace, record_used) {\n-            Success((target, _)) => target.binding.def().map(LocalDef::from_def),\n+            Success((binding, _)) => binding.def().map(LocalDef::from_def),\n             Failed(Some((span, msg))) => {\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n                 None\n@@ -2914,7 +2914,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name = segments.last().unwrap().identifier.name;\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n         let def = match result {\n-            Success((Target { binding, .. }, _)) => {\n+            Success((binding, _)) => {\n                 let (def, lp) = binding.def_and_lp();\n                 (def, last_private.or(lp))\n             }\n@@ -2970,7 +2970,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let name = segments.last().unwrap().identifier.name;\n         match self.resolve_name_in_module(containing_module, name, namespace, false, true) {\n-            Success((Target { binding, .. }, _)) => {\n+            Success((binding, _)) => {\n                 let (def, lp) = binding.def_and_lp();\n                 Some((def, last_private.or(lp)))\n             }\n@@ -3008,12 +3008,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             if let AnonymousModuleRibKind(module) = self.get_ribs(namespace)[i].kind {\n-                if let Success((target, _)) = self.resolve_name_in_module(module,\n-                                                                          ident.unhygienic_name,\n-                                                                          namespace,\n-                                                                          true,\n-                                                                          true) {\n-                    if let Some(def) = target.binding.def() {\n+                if let Success((binding, _)) = self.resolve_name_in_module(module,\n+                                                                           ident.unhygienic_name,\n+                                                                           namespace,\n+                                                                           true,\n+                                                                           true) {\n+                    if let Some(def) = binding.def() {\n                         return Some(LocalDef::from_def(def));\n                     }\n                 }\n@@ -3455,11 +3455,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // Look for imports.\n             for (&(_, ns), import) in search_module.import_resolutions.borrow().iter() {\n                 if ns != TypeNS { continue }\n-                let target = match import.target {\n-                    Some(ref target) => target,\n+                let binding = match import.binding {\n+                    Some(ref binding) => binding,\n                     None => continue,\n                 };\n-                let did = match target.binding.def() {\n+                let did = match binding.def() {\n                     Some(Def::Trait(trait_def_id)) => trait_def_id,\n                     Some(..) | None => continue,\n                 };"}, {"sha": "882531efbb7168ab64274c23b9e7c867fcd01e51", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 47, "deletions": 67, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/7366d105cb29100c6522619abbabe57777240778/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7366d105cb29100c6522619abbabe57777240778/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7366d105cb29100c6522619abbabe57777240778", "patch": "@@ -78,24 +78,14 @@ impl ImportDirective {\n             shadowable: shadowable,\n         }\n     }\n-}\n-\n-/// The item that an import resolves to.\n-#[derive(Clone,Debug)]\n-pub struct Target<'a> {\n-    pub target_module: Module<'a>,\n-    pub binding: NameBinding<'a>,\n-    pub shadowable: Shadowable,\n-}\n \n-impl<'a> Target<'a> {\n-    pub fn new(target_module: Module<'a>, binding: NameBinding<'a>, shadowable: Shadowable)\n-               -> Self {\n-        Target {\n-            target_module: target_module,\n-            binding: binding,\n-            shadowable: shadowable,\n+    // Given the binding to which this directive resolves in a particular namespace,\n+    // this returns the binding for the name this directive defines in that namespace.\n+    fn import<'a>(&self, mut binding: NameBinding<'a>) -> NameBinding<'a> {\n+        if self.shadowable == Shadowable::Always {\n+            binding.modifiers = binding.modifiers | DefModifiers::PRELUDE;\n         }\n+        binding\n     }\n }\n \n@@ -117,7 +107,7 @@ pub struct ImportResolution<'a> {\n     pub is_public: bool,\n \n     /// Resolution of the name in the namespace\n-    pub target: Option<Target<'a>>,\n+    pub binding: Option<NameBinding<'a>>,\n \n     /// The source node of the `use` directive\n     pub id: NodeId,\n@@ -128,14 +118,16 @@ impl<'a> ImportResolution<'a> {\n         ImportResolution {\n             outstanding_references: 0,\n             id: id,\n-            target: None,\n+            binding: None,\n             is_public: is_public,\n         }\n     }\n \n     pub fn shadowable(&self) -> Shadowable {\n-        match self.target {\n-            Some(ref target) => target.shadowable,\n+        match self.binding {\n+            Some(ref binding) if binding.defined_with(DefModifiers::PRELUDE) =>\n+                Shadowable::Always,\n+            Some(_) => Shadowable::Never,\n             None => Shadowable::Always,\n         }\n     }\n@@ -217,23 +209,17 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                       e.import_directive.is_public)\n             });\n \n-            if resolution.target.is_none() {\n+            if resolution.binding.is_none() {\n                 debug!(\"(resolving import error) adding fake target to import resolution of `{}`\",\n                        target);\n \n-                let name_binding = NameBinding {\n+                let dummy_binding = NameBinding {\n                     modifiers: DefModifiers::IMPORTABLE,\n                     def_or_module: DefOrModule::Def(Def::Err),\n                     span: None,\n                 };\n \n-                // Create a fake target pointing to a fake name binding in our\n-                // own module\n-                let target = Target::new(e.source_module,\n-                                         name_binding,\n-                                         Shadowable::Always);\n-\n-                resolution.target = Some(target);\n+                resolution.binding = Some(dummy_binding);\n             }\n         }\n \n@@ -374,14 +360,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n     }\n \n     /// Resolves the name in the namespace of the module because it is being imported by\n-    /// importing_module. Returns the module in which the name was defined (as opposed to imported),\n-    /// the name bindings defining the name, and whether or not the name was imported into `module`.\n+    /// importing_module. Returns the name bindings defining the name\n+    /// and whether or not the name was imported.\n     fn resolve_name_in_module(&mut self,\n                               module: Module<'b>, // Module containing the name\n                               name: Name,\n                               ns: Namespace,\n                               importing_module: Module<'b>) // Module importing the name\n-                              -> (ResolveResult<(Module<'b>, NameBinding<'b>)>, bool) {\n+                              -> (ResolveResult<NameBinding<'b>>, bool) {\n         build_reduced_graph::populate_module_if_necessary(self.resolver, module);\n         if let Some(name_binding) = module.get_child(name, ns) {\n             if name_binding.is_extern_crate() {\n@@ -390,7 +376,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     self.resolver.used_crates.insert(krate);\n                 }\n             }\n-            return (Success((module, name_binding)), false)\n+            return (Success(name_binding), false)\n         }\n \n         // If there is an unresolved glob at this point in the containing module, bail out.\n@@ -411,10 +397,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     return (Failed(None), false);\n                 }\n \n-                let target = resolution.target.clone();\n-                if let Some(Target { target_module, binding, shadowable: _ }) = target {\n+                if let Some(binding) = resolution.binding.clone() {\n                     self.resolver.record_import_use(name, ns, &resolution);\n-                    (Success((target_module, binding)), true)\n+                    (Success(binding), true)\n                 } else {\n                     (Failed(None), false)\n                 }\n@@ -470,9 +455,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             self.resolve_name_in_module(target_module, source, TypeNS, module_);\n \n         match (&value_result, &type_result) {\n-            (&Success((_, ref name_binding)), _) if !value_used_reexport &&\n-                                                    directive.is_public &&\n-                                                    !name_binding.is_public() => {\n+            (&Success(ref name_binding), _) if !value_used_reexport &&\n+                                               directive.is_public &&\n+                                               !name_binding.is_public() => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                 let note_msg = format!(\"Consider marking `{}` as `pub` in the imported module\",\n                                         source);\n@@ -481,8 +466,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     .emit();\n             }\n \n-            (_, &Success((_, ref name_binding))) if !type_used_reexport &&\n-                                                    directive.is_public => {\n+            (_, &Success(ref name_binding)) if !type_used_reexport &&\n+                                               directive.is_public => {\n                 if !name_binding.is_public() {\n                     let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                     let note_msg =\n@@ -534,7 +519,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         {\n             let mut check_and_write_import = |namespace, result, used_public: &mut bool| {\n-                let result: &ResolveResult<(Module<'b>, NameBinding)> = result;\n+                let result: &ResolveResult<NameBinding> = result;\n \n                 let import_resolution = import_resolutions.get_mut(&(target, namespace)).unwrap();\n                 let namespace_name = match namespace {\n@@ -543,7 +528,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 };\n \n                 match *result {\n-                    Success((ref target_module, ref name_binding)) => {\n+                    Success(ref name_binding) => {\n                         debug!(\"(resolving single import) found {:?} target: {:?}\",\n                                namespace_name,\n                                name_binding.def());\n@@ -556,9 +541,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                              directive.span,\n                                                              target);\n \n-                        import_resolution.target = Some(Target::new(target_module,\n-                                                                    name_binding.clone(),\n-                                                                    directive.shadowable));\n+                        import_resolution.binding = Some(directive.import(name_binding.clone()));\n                         import_resolution.id = directive.id;\n                         import_resolution.is_public = directive.is_public;\n \n@@ -600,8 +583,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             // Record what this import resolves to for later uses in documentation,\n             // this may resolve to either a value or a type, but for documentation\n             // purposes it's good enough to just favor one over the other.\n-            import_resolution_value.target.as_ref().map(|target| {\n-                let def = target.binding.def().unwrap();\n+            import_resolution_value.binding.as_ref().map(|binding| {\n+                let def = binding.def().unwrap();\n                 let last_private = if value_used_public { lp } else { DependsOn(def.def_id()) };\n                 (def, last_private)\n             })\n@@ -612,8 +595,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             assert!(import_resolution_type.outstanding_references >= 1);\n             import_resolution_type.outstanding_references -= 1;\n \n-            import_resolution_type.target.as_ref().map(|target| {\n-                let def = target.binding.def().unwrap();\n+            import_resolution_type.binding.as_ref().map(|binding| {\n+                let def = binding.def().unwrap();\n                 let last_private = if type_used_public { lp } else { DependsOn(def.def_id()) };\n                 (def, last_private)\n             })\n@@ -695,15 +678,15 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 import_resolutions.entry((name, ns))\n                                   .or_insert_with(|| ImportResolution::new(id, is_public));\n \n-            match target_import_resolution.target {\n-                Some(ref target) if target_import_resolution.is_public => {\n+            match target_import_resolution.binding {\n+                Some(ref binding) if target_import_resolution.is_public => {\n                     self.check_for_conflicting_import(&dest_import_resolution,\n                                                       import_directive.span,\n                                                       name,\n                                                       ns);\n                     dest_import_resolution.id = id;\n                     dest_import_resolution.is_public = is_public;\n-                    dest_import_resolution.target = Some(target.clone());\n+                    dest_import_resolution.binding = Some(import_directive.import(binding.clone()));\n                     self.add_export(module_, name, &dest_import_resolution);\n                 }\n                 _ => {}\n@@ -778,10 +761,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                  name);\n                 span_err!(self.resolver.session, import_directive.span, E0251, \"{}\", msg);\n             } else {\n-                let target = Target::new(containing_module,\n-                                         name_binding.clone(),\n-                                         import_directive.shadowable);\n-                dest_import_resolution.target = Some(target);\n+                dest_import_resolution.binding = Some(import_directive.import(name_binding.clone()));\n                 dest_import_resolution.id = id;\n                 dest_import_resolution.is_public = is_public;\n                 self.add_export(module_, name, &dest_import_resolution);\n@@ -800,7 +780,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             Some(def_id) => self.resolver.ast_map.as_local_node_id(def_id).unwrap(),\n             None => return,\n         };\n-        let export = match resolution.target.as_ref().unwrap().binding.def() {\n+        let export = match resolution.binding.as_ref().unwrap().def() {\n             Some(def) => Export { name: name, def_id: def.def_id() },\n             None => return,\n         };\n@@ -813,16 +793,16 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                     import_span: Span,\n                                     name: Name,\n                                     namespace: Namespace) {\n-        let target = &import_resolution.target;\n+        let binding = &import_resolution.binding;\n         debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n                name,\n-               target.is_some());\n+               binding.is_some());\n \n-        match *target {\n-            Some(ref target) if target.shadowable != Shadowable::Always => {\n+        match *binding {\n+            Some(ref binding) if !binding.defined_with(DefModifiers::PRELUDE) => {\n                 let ns_word = match namespace {\n                     TypeNS => {\n-                        match target.binding.module() {\n+                        match binding.module() {\n                             Some(ref module) if module.is_normal() => \"module\",\n                             Some(ref module) if module.is_trait() => \"trait\",\n                             _ => \"type\",\n@@ -876,8 +856,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         };\n \n         if ns == ValueNS {\n-            match import.target {\n-                Some(ref target) if target.shadowable != Shadowable::Always => {\n+            match import.binding {\n+                Some(ref binding) if !binding.defined_with(DefModifiers::PRELUDE) => {\n                     let mut err = struct_span_err!(self.resolver.session,\n                                                    import_span,\n                                                    E0255,\n@@ -892,8 +872,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 Some(_) | None => {}\n             }\n         } else {\n-            match import.target {\n-                Some(ref target) if target.shadowable != Shadowable::Always => {\n+            match import.binding {\n+                Some(ref binding) if !binding.defined_with(DefModifiers::PRELUDE) => {\n                     if name_binding.is_extern_crate() {\n                         let msg = format!(\"import `{0}` conflicts with imported crate \\\n                                            in this module (maybe you meant `use {0}::*`?)\","}]}