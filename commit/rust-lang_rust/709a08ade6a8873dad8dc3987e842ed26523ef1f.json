{"sha": "709a08ade6a8873dad8dc3987e842ed26523ef1f", "node_id": "C_kwDOAAsO6NoAKDcwOWEwOGFkZTZhODg3M2RhZDhkYzM5ODdlODQyZWQyNjUyM2VmMWY", "commit": {"author": {"name": "Nathan Whitaker", "email": "nathan.whitaker01@gmail.com", "date": "2022-10-14T01:20:39Z"}, "committer": {"name": "Nathan Whitaker", "email": "nathan.whitaker01@gmail.com", "date": "2022-10-14T01:20:39Z"}, "message": "Lower condition directly from AST to HIR", "tree": {"sha": "83b264cc27469da8e41c1901b54aeb5abe5f4bc7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83b264cc27469da8e41c1901b54aeb5abe5f4bc7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/709a08ade6a8873dad8dc3987e842ed26523ef1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/709a08ade6a8873dad8dc3987e842ed26523ef1f", "html_url": "https://github.com/rust-lang/rust/commit/709a08ade6a8873dad8dc3987e842ed26523ef1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/709a08ade6a8873dad8dc3987e842ed26523ef1f/comments", "author": {"login": "nathanwhit", "id": 17734409, "node_id": "MDQ6VXNlcjE3NzM0NDA5", "avatar_url": "https://avatars.githubusercontent.com/u/17734409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nathanwhit", "html_url": "https://github.com/nathanwhit", "followers_url": "https://api.github.com/users/nathanwhit/followers", "following_url": "https://api.github.com/users/nathanwhit/following{/other_user}", "gists_url": "https://api.github.com/users/nathanwhit/gists{/gist_id}", "starred_url": "https://api.github.com/users/nathanwhit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nathanwhit/subscriptions", "organizations_url": "https://api.github.com/users/nathanwhit/orgs", "repos_url": "https://api.github.com/users/nathanwhit/repos", "events_url": "https://api.github.com/users/nathanwhit/events{/privacy}", "received_events_url": "https://api.github.com/users/nathanwhit/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nathanwhit", "id": 17734409, "node_id": "MDQ6VXNlcjE3NzM0NDA5", "avatar_url": "https://avatars.githubusercontent.com/u/17734409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nathanwhit", "html_url": "https://github.com/nathanwhit", "followers_url": "https://api.github.com/users/nathanwhit/followers", "following_url": "https://api.github.com/users/nathanwhit/following{/other_user}", "gists_url": "https://api.github.com/users/nathanwhit/gists{/gist_id}", "starred_url": "https://api.github.com/users/nathanwhit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nathanwhit/subscriptions", "organizations_url": "https://api.github.com/users/nathanwhit/orgs", "repos_url": "https://api.github.com/users/nathanwhit/repos", "events_url": "https://api.github.com/users/nathanwhit/events{/privacy}", "received_events_url": "https://api.github.com/users/nathanwhit/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad8b24272428b28770471f222c19fa3154a65819", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad8b24272428b28770471f222c19fa3154a65819", "html_url": "https://github.com/rust-lang/rust/commit/ad8b24272428b28770471f222c19fa3154a65819"}], "stats": {"total": 46, "additions": 24, "deletions": 22}, "files": [{"sha": "ec9c3935020566aee76eeef1bf82fc9092125762", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/709a08ade6a8873dad8dc3987e842ed26523ef1f/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709a08ade6a8873dad8dc3987e842ed26523ef1f/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=709a08ade6a8873dad8dc3987e842ed26523ef1f", "patch": "@@ -387,23 +387,26 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         then: &Block,\n         else_opt: Option<&Expr>,\n     ) -> hir::ExprKind<'hir> {\n-        let lowered_cond = self.lower_expr(cond);\n-        let new_cond = self.wrap_cond_in_drop_scope(lowered_cond);\n+        let lowered_cond = self.lower_cond(cond);\n         let then_expr = self.lower_block_expr(then);\n         if let Some(rslt) = else_opt {\n-            hir::ExprKind::If(new_cond, self.arena.alloc(then_expr), Some(self.lower_expr(rslt)))\n+            hir::ExprKind::If(\n+                lowered_cond,\n+                self.arena.alloc(then_expr),\n+                Some(self.lower_expr(rslt)),\n+            )\n         } else {\n-            hir::ExprKind::If(new_cond, self.arena.alloc(then_expr), None)\n+            hir::ExprKind::If(lowered_cond, self.arena.alloc(then_expr), None)\n         }\n     }\n \n-    // Wraps a condition (i.e. `cond` in `if cond` or `while cond`) in a terminating scope\n+    // Lowers a condition (i.e. `cond` in `if cond` or `while cond`), wrapping it in a terminating scope\n     // so that temporaries created in the condition don't live beyond it.\n-    fn wrap_cond_in_drop_scope(&mut self, cond: &'hir hir::Expr<'hir>) -> &'hir hir::Expr<'hir> {\n-        fn has_let_expr<'hir>(expr: &'hir hir::Expr<'hir>) -> bool {\n-            match expr.kind {\n-                hir::ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n-                hir::ExprKind::Let(..) => true,\n+    fn lower_cond(&mut self, cond: &Expr) -> &'hir hir::Expr<'hir> {\n+        fn has_let_expr(expr: &Expr) -> bool {\n+            match &expr.kind {\n+                ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n+                ExprKind::Let(..) => true,\n                 _ => false,\n             }\n         }\n@@ -415,23 +418,23 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // In order to mantain the drop behavior for the non `let` parts of the condition,\n         // we still wrap them in terminating scopes, e.g. `if foo && let pat = val` essentially\n         // gets transformed into `if { let _t = foo; _t } && let pat = val`\n-        match cond.kind {\n-            hir::ExprKind::Binary(\n-                op @ Spanned { node: hir::BinOpKind::And | hir::BinOpKind::Or, .. },\n-                lhs,\n-                rhs,\n-            ) if has_let_expr(cond) => {\n-                let lhs = self.wrap_cond_in_drop_scope(lhs);\n-                let rhs = self.wrap_cond_in_drop_scope(rhs);\n+        match &cond.kind {\n+            ExprKind::Binary(op @ Spanned { node: ast::BinOpKind::And, .. }, lhs, rhs)\n+                if has_let_expr(cond) =>\n+            {\n+                let op = self.lower_binop(*op);\n+                let lhs = self.lower_cond(lhs);\n+                let rhs = self.lower_cond(rhs);\n \n                 self.arena.alloc(self.expr(\n                     cond.span,\n                     hir::ExprKind::Binary(op, lhs, rhs),\n                     AttrVec::new(),\n                 ))\n             }\n-            hir::ExprKind::Let(_) => cond,\n+            ExprKind::Let(..) => self.lower_expr(cond),\n             _ => {\n+                let cond = self.lower_expr(cond);\n                 let reason = DesugaringKind::CondTemporary;\n                 let span_block = self.mark_span_with_reason(reason, cond.span, None);\n                 self.expr_drop_temps(span_block, cond, AttrVec::new())\n@@ -462,14 +465,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: &Block,\n         opt_label: Option<Label>,\n     ) -> hir::ExprKind<'hir> {\n-        let lowered_cond = self.with_loop_condition_scope(|t| t.lower_expr(cond));\n-        let new_cond = self.wrap_cond_in_drop_scope(lowered_cond);\n+        let lowered_cond = self.with_loop_condition_scope(|t| t.lower_cond(cond));\n         let then = self.lower_block_expr(body);\n         let expr_break = self.expr_break(span, AttrVec::new());\n         let stmt_break = self.stmt_expr(span, expr_break);\n         let else_blk = self.block_all(span, arena_vec![self; stmt_break], None);\n         let else_expr = self.arena.alloc(self.expr_block(else_blk, AttrVec::new()));\n-        let if_kind = hir::ExprKind::If(new_cond, self.arena.alloc(then), Some(else_expr));\n+        let if_kind = hir::ExprKind::If(lowered_cond, self.arena.alloc(then), Some(else_expr));\n         let if_expr = self.expr(span, if_kind, AttrVec::new());\n         let block = self.block_expr(self.arena.alloc(if_expr));\n         let span = self.lower_span(span.with_hi(cond.span.hi()));"}]}