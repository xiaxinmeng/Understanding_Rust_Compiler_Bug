{"sha": "10a400ffaa8b67add66a62bde0ef3c415d7aed5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYTQwMGZmYWE4YjY3YWRkNjZhNjJiZGUwZWYzYzQxNWQ3YWVkNWY=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-02T17:37:19Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-20T09:08:55Z"}, "message": "Reimplement ARC::unwrap() and friends.", "tree": {"sha": "10c5798e9fe2a1c62ebf0cf629f7034c992314ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10c5798e9fe2a1c62ebf0cf629f7034c992314ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10a400ffaa8b67add66a62bde0ef3c415d7aed5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10a400ffaa8b67add66a62bde0ef3c415d7aed5f", "html_url": "https://github.com/rust-lang/rust/commit/10a400ffaa8b67add66a62bde0ef3c415d7aed5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10a400ffaa8b67add66a62bde0ef3c415d7aed5f/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55adc4467b4364d949774d5bfd1eba4a16c0b810", "url": "https://api.github.com/repos/rust-lang/rust/commits/55adc4467b4364d949774d5bfd1eba4a16c0b810", "html_url": "https://github.com/rust-lang/rust/commit/55adc4467b4364d949774d5bfd1eba4a16c0b810"}], "stats": {"total": 310, "additions": 283, "deletions": 27}, "files": [{"sha": "404d5bfde58761f86193062f49452bb3918c47e1", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 72, "deletions": 8, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/10a400ffaa8b67add66a62bde0ef3c415d7aed5f/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a400ffaa8b67add66a62bde0ef3c415d7aed5f/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=10a400ffaa8b67add66a62bde0ef3c415d7aed5f", "patch": "@@ -50,9 +50,9 @@ use std::borrow;\n \n /// As sync::condvar, a mechanism for unlock-and-descheduling and signaling.\n pub struct Condvar<'self> {\n-    is_mutex: bool,\n-    failed: &'self mut bool,\n-    cond: &'self sync::Condvar<'self>\n+    priv is_mutex: bool,\n+    priv failed: &'self mut bool,\n+    priv cond: &'self sync::Condvar<'self>\n }\n \n impl<'self> Condvar<'self> {\n@@ -108,7 +108,7 @@ impl<'self> Condvar<'self> {\n  ****************************************************************************/\n \n /// An atomically reference counted wrapper for shared immutable state.\n-pub struct ARC<T> { x: UnsafeAtomicRcBox<T> }\n+pub struct ARC<T> { priv x: UnsafeAtomicRcBox<T> }\n \n /// Create an atomically reference counted wrapper.\n pub fn ARC<T:Freeze + Send>(data: T) -> ARC<T> {\n@@ -123,6 +123,20 @@ impl<T:Freeze+Send> ARC<T> {\n     pub fn get<'a>(&'a self) -> &'a T {\n         unsafe { &*self.x.get_immut() }\n     }\n+\n+    /**\n+     * Retrieve the data back out of the ARC. This function blocks until the\n+     * reference given to it is the last existing one, and then unwrap the data\n+     * instead of destroying it.\n+     *\n+     * If multiple tasks call unwrap, all but the first will fail. Do not call\n+     * unwrap from a task that holds another reference to the same ARC; it is\n+     * guaranteed to deadlock.\n+     */\n+    pub fn unwrap(self) -> T {\n+        let ARC { x: x } = self;\n+        unsafe { x.unwrap() }\n+    }\n }\n \n /**\n@@ -143,9 +157,9 @@ impl<T:Freeze + Send> Clone for ARC<T> {\n  ****************************************************************************/\n \n #[doc(hidden)]\n-struct MutexARCInner<T> { lock: Mutex, failed: bool, data: T }\n+struct MutexARCInner<T> { priv lock: Mutex, priv failed: bool, priv data: T }\n /// An ARC with mutable data protected by a blocking mutex.\n-struct MutexARC<T> { x: UnsafeAtomicRcBox<MutexARCInner<T>> }\n+struct MutexARC<T> { priv x: UnsafeAtomicRcBox<MutexARCInner<T>> }\n \n /// Create a mutex-protected ARC with the supplied data.\n pub fn MutexARC<T:Send>(user_data: T) -> MutexARC<T> {\n@@ -225,6 +239,22 @@ impl<T:Send> MutexARC<T> {\n                           cond: cond })\n         }\n     }\n+\n+    /**\n+     * Retrieves the data, blocking until all other references are dropped,\n+     * exactly as arc::unwrap.\n+     *\n+     * Will additionally fail if another task has failed while accessing the arc.\n+     */\n+    pub fn unwrap(self) -> T {\n+        let MutexARC { x: x } = self;\n+        let inner = unsafe { x.unwrap() };\n+        let MutexARCInner { failed: failed, data: data, _ } = inner;\n+        if failed {\n+            fail!(~\"Can't unwrap poisoned MutexARC - another task failed inside!\");\n+        }\n+        data\n+    }\n }\n \n // Common code for {mutex.access,rwlock.write}{,_cond}.\n@@ -268,7 +298,7 @@ fn PoisonOnFail<'r>(failed: &'r mut bool) -> PoisonOnFail {\n  ****************************************************************************/\n \n #[doc(hidden)]\n-struct RWARCInner<T> { lock: RWlock, failed: bool, data: T }\n+struct RWARCInner<T> { priv lock: RWlock, priv failed: bool, priv data: T }\n /**\n  * A dual-mode ARC protected by a reader-writer lock. The data can be accessed\n  * mutably or immutably, and immutably-accessing tasks may run concurrently.\n@@ -278,7 +308,7 @@ struct RWARCInner<T> { lock: RWlock, failed: bool, data: T }\n #[mutable] // XXX remove after snap\n #[no_freeze]\n struct RWARC<T> {\n-    x: UnsafeAtomicRcBox<RWARCInner<T>>,\n+    priv x: UnsafeAtomicRcBox<RWARCInner<T>>,\n }\n \n /// Create a reader/writer ARC with the supplied data.\n@@ -429,6 +459,23 @@ impl<T:Freeze + Send> RWARC<T> {\n             }\n         }\n     }\n+\n+    /**\n+     * Retrieves the data, blocking until all other references are dropped,\n+     * exactly as arc::unwrap.\n+     *\n+     * Will additionally fail if another task has failed while accessing the arc\n+     * in write mode.\n+     */\n+    pub fn unwrap(self) -> T {\n+        let RWARC { x: x, _ } = self;\n+        let inner = unsafe { x.unwrap() };\n+        let RWARCInner { failed: failed, data: data, _ } = inner;\n+        if failed {\n+            fail!(~\"Can't unwrap poisoned RWARC - another task failed inside!\")\n+        }\n+        data\n+    }\n }\n \n // Borrowck rightly complains about immutably aliasing the rwlock in order to\n@@ -611,6 +658,23 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n+    pub fn test_mutex_arc_unwrap_poison() {\n+        let arc = MutexARC(1);\n+        let arc2 = ~(&arc).clone();\n+        let (p, c) = comm::stream();\n+        do task::spawn {\n+            unsafe {\n+                do arc2.access |one| {\n+                    c.send(());\n+                    assert!(*one == 2);\n+                }\n+            }\n+        }\n+        let _ = p.recv();\n+        let one = arc.unwrap();\n+        assert!(one == 1);\n+    }\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_rw_arc_poison_wr() {\n         let arc = ~RWARC(1);\n         let arc2 = (*arc).clone();"}, {"sha": "f80ad7239b5b0545be164774729b9a89fa2f768f", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 211, "deletions": 19, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/10a400ffaa8b67add66a62bde0ef3c415d7aed5f/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10a400ffaa8b67add66a62bde0ef3c415d7aed5f/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=10a400ffaa8b67add66a62bde0ef3c415d7aed5f", "patch": "@@ -9,12 +9,15 @@\n // except according to those terms.\n \n use cast;\n+use cell::Cell;\n+use comm;\n use libc;\n+use ptr;\n use option::*;\n use task;\n use task::atomically;\n+use unstable::atomics::{AtomicOption,AtomicUint,Acquire,Release,SeqCst};\n use unstable::finally::Finally;\n-use unstable::intrinsics;\n use ops::Drop;\n use clone::Clone;\n use kinds::Send;\n@@ -27,14 +30,22 @@ pub struct UnsafeAtomicRcBox<T> {\n }\n \n struct AtomicRcBoxData<T> {\n-    count: int,\n+    count: AtomicUint,\n+    // An unwrapper uses this protocol to communicate with the \"other\" task that\n+    // drops the last refcount on an arc. Unfortunately this can't be a proper\n+    // pipe protocol because the unwrapper has to access both stages at once.\n+    // FIXME(#7544): Maybe use AtomicPtr instead (to avoid xchg in take() later)?\n+    unwrapper: AtomicOption<(comm::ChanOne<()>, comm::PortOne<bool>)>,\n+    // FIXME(#3224) should be able to make this non-option to save memory\n     data: Option<T>,\n }\n \n impl<T: Send> UnsafeAtomicRcBox<T> {\n     pub fn new(data: T) -> UnsafeAtomicRcBox<T> {\n         unsafe {\n-            let data = ~AtomicRcBoxData { count: 1, data: Some(data) };\n+            let data = ~AtomicRcBoxData { count: AtomicUint::new(1),\n+                                          unwrapper: AtomicOption::empty(),\n+                                          data: Some(data) };\n             let ptr = cast::transmute(data);\n             return UnsafeAtomicRcBox { data: ptr };\n         }\n@@ -44,7 +55,7 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n     pub unsafe fn get(&self) -> *mut T\n     {\n         let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n-        assert!(data.count > 0);\n+        assert!(data.count.load(Acquire) > 0); // no barrier is really needed\n         let r: *mut T = data.data.get_mut_ref();\n         cast::forget(data);\n         return r;\n@@ -53,20 +64,88 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n     #[inline]\n     pub unsafe fn get_immut(&self) -> *T\n     {\n-        let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n-        assert!(data.count > 0);\n-        let r: *T = cast::transmute_immut(data.data.get_mut_ref());\n+        let data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+        assert!(data.count.load(Acquire) > 0); // no barrier is really needed\n+        let r: *T = data.data.get_ref();\n         cast::forget(data);\n         return r;\n     }\n+\n+    /// Wait until all other handles are dropped, then retrieve the enclosed\n+    /// data. See extra::arc::ARC for specific semantics documentation.\n+    /// If called when the task is already unkillable, unwrap will unkillably\n+    /// block; otherwise, an unwrapping task can be killed by linked failure.\n+    pub unsafe fn unwrap(self) -> T {\n+        let this = Cell::new(self); // argh\n+        do task::unkillable {\n+            let mut this = this.take();\n+            let mut data: ~AtomicRcBoxData<T> = cast::transmute(this.data);\n+            // Set up the unwrap protocol.\n+            let (p1,c1) = comm::oneshot(); // ()\n+            let (p2,c2) = comm::oneshot(); // bool\n+            // Try to put our server end in the unwrapper slot.\n+            // This needs no barrier -- it's protected by the release barrier on\n+            // the xadd, and the acquire+release barrier in the destructor's xadd.\n+            // FIXME(#6598) Change Acquire to Relaxed.\n+            if data.unwrapper.fill(~(c1,p2), Acquire).is_none() {\n+                // Got in. Tell this handle's destructor not to run (we are now it).\n+                this.data = ptr::mut_null();\n+                // Drop our own reference.\n+                let old_count = data.count.fetch_sub(1, Release);\n+                assert!(old_count >= 1);\n+                if old_count == 1 {\n+                    // We were the last owner. Can unwrap immediately.\n+                    // AtomicOption's destructor will free the server endpoint.\n+                    // FIXME(#3224): it should be like this\n+                    // let ~AtomicRcBoxData { data: user_data, _ } = data;\n+                    // user_data\n+                    data.data.take_unwrap()\n+                } else {\n+                    // The *next* person who sees the refcount hit 0 will wake us.\n+                    let p1 = Cell::new(p1); // argh\n+                    // Unlike the above one, this cell is necessary. It will get\n+                    // taken either in the do block or in the finally block.\n+                    let c2_and_data = Cell::new((c2,data));\n+                    do (|| {\n+                        do task::rekillable { p1.take().recv(); }\n+                        // Got here. Back in the 'unkillable' without getting killed.\n+                        let (c2, data) = c2_and_data.take();\n+                        c2.send(true);\n+                        // FIXME(#3224): it should be like this\n+                        // let ~AtomicRcBoxData { data: user_data, _ } = data;\n+                        // user_data\n+                        let mut data = data;\n+                        data.data.take_unwrap()\n+                    }).finally {\n+                        if task::failing() {\n+                            // Killed during wait. Because this might happen while\n+                            // someone else still holds a reference, we can't free\n+                            // the data now; the \"other\" last refcount will free it.\n+                            let (c2, data) = c2_and_data.take();\n+                            c2.send(false);\n+                            cast::forget(data);\n+                        } else {\n+                            assert!(c2_and_data.is_empty());\n+                        }\n+                    }\n+                }\n+            } else {\n+                // If 'put' returns the server end back to us, we were rejected;\n+                // someone else was trying to unwrap. Avoid guaranteed deadlock.\n+                cast::forget(data);\n+                fail!(\"Another task is already unwrapping this ARC!\");\n+            }\n+        }\n+    }\n }\n \n impl<T: Send> Clone for UnsafeAtomicRcBox<T> {\n     fn clone(&self) -> UnsafeAtomicRcBox<T> {\n         unsafe {\n             let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n-            let new_count = intrinsics::atomic_xadd(&mut data.count, 1) + 1;\n-            assert!(new_count >= 2);\n+            // This barrier might be unnecessary, but I'm not sure...\n+            let old_count = data.count.fetch_add(1, Acquire);\n+            assert!(old_count >= 1);\n             cast::forget(data);\n             return UnsafeAtomicRcBox { data: self.data };\n         }\n@@ -77,12 +156,37 @@ impl<T: Send> Clone for UnsafeAtomicRcBox<T> {\n impl<T> Drop for UnsafeAtomicRcBox<T>{\n     fn drop(&self) {\n         unsafe {\n+            if self.data.is_null() {\n+                return; // Happens when destructing an unwrapper's handle.\n+            }\n             do task::unkillable {\n                 let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n-                let new_count = intrinsics::atomic_xsub(&mut data.count, 1) - 1;\n-                assert!(new_count >= 0);\n-                if new_count == 0 {\n-                    // drop glue takes over.\n+                // Must be acquire+release, not just release, to make sure this\n+                // doesn't get reordered to after the unwrapper pointer load.\n+                let old_count = data.count.fetch_sub(1, SeqCst);\n+                assert!(old_count >= 1);\n+                if old_count == 1 {\n+                    // Were we really last, or should we hand off to an\n+                    // unwrapper? It's safe to not xchg because the unwrapper\n+                    // will set the unwrap lock *before* dropping his/her\n+                    // reference. In effect, being here means we're the only\n+                    // *awake* task with the data.\n+                    match data.unwrapper.take(Acquire) {\n+                        Some(~(message,response)) => {\n+                            // Send 'ready' and wait for a response.\n+                            message.send(());\n+                            // Unkillable wait. Message guaranteed to come.\n+                            if response.recv() {\n+                                // Other task got the data.\n+                                cast::forget(data);\n+                            } else {\n+                                // Other task was killed. drop glue takes over.\n+                            }\n+                        }\n+                        None => {\n+                            // drop glue takes over.\n+                        }\n+                    }\n                 } else {\n                     cast::forget(data);\n                 }\n@@ -139,6 +243,13 @@ struct ExData<T> {\n \n /**\n  * An arc over mutable data that is protected by a lock. For library use only.\n+ *\n+ * # Safety note\n+ *\n+ * This uses a pthread mutex, not one that's aware of the userspace scheduler.\n+ * The user of an exclusive must be careful not to invoke any functions that may\n+ * reschedule the task while holding the lock, or deadlock may result. If you\n+ * need to block or yield while accessing shared state, use extra::sync::RWARC.\n  */\n pub struct Exclusive<T> {\n     x: UnsafeAtomicRcBox<ExData<T>>\n@@ -189,12 +300,13 @@ impl<T:Send> Exclusive<T> {\n             f(cast::transmute_immut(x))\n         }\n     }\n-}\n \n-fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n-    unsafe {\n-        let old = intrinsics::atomic_cxchg(address, oldval, newval);\n-        old == oldval\n+    pub fn unwrap(self) -> T {\n+        let Exclusive { x: x } = self;\n+        // Someday we might need to unkillably unwrap an exclusive, but not today.\n+        let inner = unsafe { x.unwrap() };\n+        let ExData { data: user_data, _ } = inner; // will destroy the LittleLock\n+        user_data\n     }\n }\n \n@@ -208,10 +320,13 @@ extern {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use cell::Cell;\n     use comm;\n-    use super::exclusive;\n+    use option::*;\n+    use super::{exclusive, UnsafeAtomicRcBox};\n     use task;\n     use uint;\n+    use util;\n \n     #[test]\n     fn exclusive_arc() {\n@@ -263,4 +378,81 @@ mod tests {\n             }\n         }\n     }\n+\n+    #[test]\n+    fn unsafe_unwrap_basic() {\n+        unsafe {\n+            let x = UnsafeAtomicRcBox::new(~~\"hello\");\n+            assert!(x.unwrap() == ~~\"hello\");\n+        }\n+    }\n+\n+    #[test]\n+    fn exclusive_unwrap_basic() {\n+        // Unlike the above, also tests no double-freeing of the LittleLock.\n+        let x = exclusive(~~\"hello\");\n+        assert!(x.unwrap() == ~~\"hello\");\n+    }\n+\n+    #[test]\n+    fn exclusive_unwrap_contended() {\n+        let x = exclusive(~~\"hello\");\n+        let x2 = Cell::new(x.clone());\n+        do task::spawn {\n+            let x2 = x2.take();\n+            unsafe { do x2.with |_hello| { } }\n+            task::yield();\n+        }\n+        assert!(x.unwrap() == ~~\"hello\");\n+\n+        // Now try the same thing, but with the child task blocking.\n+        let x = exclusive(~~\"hello\");\n+        let x2 = Cell::new(x.clone());\n+        let mut res = None;\n+        let mut builder = task::task();\n+        builder.future_result(|r| res = Some(r));\n+        do builder.spawn {\n+            let x2 = x2.take();\n+            assert!(x2.unwrap() == ~~\"hello\");\n+        }\n+        // Have to get rid of our reference before blocking.\n+        util::ignore(x);\n+        res.unwrap().recv();\n+    }\n+\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    fn exclusive_unwrap_conflict() {\n+        let x = exclusive(~~\"hello\");\n+        let x2 = Cell::new(x.clone());\n+        let mut res = None;\n+        let mut builder = task::task();\n+        builder.future_result(|r| res = Some(r));\n+        do builder.spawn {\n+            let x2 = x2.take();\n+            assert!(x2.unwrap() == ~~\"hello\");\n+        }\n+        assert!(x.unwrap() == ~~\"hello\");\n+        // See #4689 for why this can't be just \"res.recv()\".\n+        assert!(res.unwrap().recv() == task::Success);\n+    }\n+\n+    #[test] #[ignore(cfg(windows))]\n+    fn exclusive_unwrap_deadlock() {\n+        // This is not guaranteed to get to the deadlock before being killed,\n+        // but it will show up sometimes, and if the deadlock were not there,\n+        // the test would nondeterministically fail.\n+        let result = do task::try {\n+            // a task that has two references to the same exclusive will\n+            // deadlock when it unwraps. nothing to be done about that.\n+            let x = exclusive(~~\"hello\");\n+            let x2 = x.clone();\n+            do task::spawn {\n+                for 10.times { task::yield(); } // try to let the unwrapper go\n+                fail!(); // punt it awake from its deadlock\n+            }\n+            let _z = x.unwrap();\n+            unsafe { do x2.with |_hello| { } }\n+        };\n+        assert!(result.is_err());\n+    }\n }"}]}