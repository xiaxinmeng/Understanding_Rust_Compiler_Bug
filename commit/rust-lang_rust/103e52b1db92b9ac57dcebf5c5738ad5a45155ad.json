{"sha": "103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwM2U1MmIxZGI5MmI5YWM1N2RjZWJmNWM1NzM4YWQ1YTQ1MTU1YWQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-13T03:09:17Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-13T03:09:17Z"}, "message": "Merge branch 'master' into mulit-decor", "tree": {"sha": "f25dde7fb14152c900f89c7b9c85e63b1439c828", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f25dde7fb14152c900f89c7b9c85e63b1439c828"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "html_url": "https://github.com/rust-lang/rust/commit/103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d16772ecb93270ac64b44b429a157f397a3e41d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d16772ecb93270ac64b44b429a157f397a3e41d", "html_url": "https://github.com/rust-lang/rust/commit/5d16772ecb93270ac64b44b429a157f397a3e41d"}, {"sha": "c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2b30b86df6b34ba19e87e63402e43d9e81a64fb", "html_url": "https://github.com/rust-lang/rust/commit/c2b30b86df6b34ba19e87e63402e43d9e81a64fb"}], "stats": {"total": 3301, "additions": 2401, "deletions": 900}, "files": [{"sha": "e342a3de55a95903d5a56c5a8b7ba79be707c5a9", "filename": "AUTHORS.txt", "status": "modified", "additions": 64, "deletions": 49, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -8,6 +8,7 @@ Aaron Raimist <aaron@aaronraimist.com>\n Aaron Todd <github@opprobrio.us>\n Aaron Turon <aturon@mozilla.com>\n Aaron Weiss <aaronweiss74@gmail.com>\n+Abhishek Chanda <abhishek@cloudscaling.com>\n Adam Bozanich <adam.boz@gmail.com>\n Adam Jacob <adam@opscode.com>\n Adam Roben <adam@roben.org>\n@@ -28,6 +29,7 @@ Aleksandr Koshlo <sash7ko@gmail.com>\n Alex Crichton <alex@alexcrichton.com>\n Alex Gaynor <alex.gaynor@gmail.com>\n Alex Lyon <arcterus@mail.com>\n+Alex Quach <alex@clinkle.com>\n Alex R\u00f8nne Petersen <alex@lycus.org>\n Alex Whitney <aw1209@ic.ac.uk>\n Alexander Bliskovsky <alexander.bliskovsky@gmail.com>\n@@ -41,7 +43,6 @@ Alexandros Tasos <sdi1100085@di.uoa.gr>\n Alexei Sholik <alcosholik@gmail.com>\n Alexis Beingessner <a.beingessner@gmail.com>\n Alfie John <alfie@alfie.wtf>\n-Alfie John <alfiej@fastmail.fm>\n Ali Smesseim <smesseim.ali@gmail.com>\n Alisdair Owens <awo101@zepler.net>\n Aljaz\u030c \"g5pw\" Srebrnic\u030c <a2piratesoft@gmail.com>\n@@ -64,10 +65,13 @@ Andrew Gallant <jamslam@gmail.com>\n Andrew Hobden <andrew@hoverbear.org>\n Andrew Paseltiner <apaseltiner@gmail.com>\n Andrew Poelstra <asp11@sfu.ca>\n+Andrew Seidl <dev@aas.io>\n Andrew Wagner <drewm1980@gmail.com>\n Angus Lees <gus@inodes.org>\n Anthony Juckel <ajuckel@gmail.com>\n Anton L\u00f6fgren <anton.lofgren@gmail.com>\n+Aram Visser <aramvisser@gmail.com>\n+Areski Belaid <areski@gmail.com>\n Arcterus <Arcterus@mail.com>\n Ariel Ben-Yehuda <arielb1@mail.tau.ac.il>\n Arjan Topolovec <arjan.top@gmail.com>\n@@ -78,20 +82,22 @@ Arpad Borsos <arpad.borsos@googlemail.com>\n Artem <artemciy@gmail.com>\n Arthur Liao <arthurtw8@gmail.com>\n Ashok Gautham <ScriptDevil@gmail.com>\n+Augusto Hack <hack.augusto@gmail.com>\n Austin Bonander <austin.bonander@gmail.com>\n Austin King <shout@ozten.com>\n Austin Seipp <mad.one@gmail.com>\n Axel Viala <axel.viala@darnuria.eu>\n Aydin Kim <ladinjin@hanmail.net>\n Barosl Lee <vcs@barosl.com>\n Ben Alpert <ben@benalpert.com>\n+Ben Ashford <ben@bcash.org>\n Ben Blum <bblum@andrew.cmu.edu>\n Ben Foppa <benjamin.foppa@gmail.com>\n Ben Gamari <bgamari.foss@gmail.com>\n Ben Harris <mail@bharr.is>\n Ben Kelly <ben@wanderview.com>\n Ben Noordhuis <info@bnoordhuis.nl>\n-Ben S <ogham@users.noreply.github.com>\n+Ben Sago <ogham@users.noreply.github.com>\n Ben Striegel <ben.striegel@gmail.com>\n Benjamin Adamson <adamson.benjamin@gmail.com>\n Benjamin Herr <ben@0x539.de>\n@@ -112,6 +118,7 @@ Brandon Waskiewicz <brandon.waskiewicz@gmail.com>\n Branimir <branimir@volomp.com>\n Brendan Cully <brendan@kublai.com>\n Brendan Eich <brendan@mozilla.org>\n+Brendan Graetz <github@bguiz.com>\n Brendan McLoughlin <btmcloughlin@gmail.com>\n Brendan Zabarauskas <bjzaba@yahoo.com.au>\n Brett Cannon <brett@python.org>\n@@ -135,8 +142,8 @@ Camille TJHOA <camille.tjhoa@outlook.com>\n CarVac <c.lo.to.da.down.lo@gmail.com>\n Carl Lerche <me@carllerche.com>\n Carl-Anton Ingmarsson <mail@carlanton.se>\n-Carlos <toqueteos@gmail.com>\n-Carol Nichols <carol.nichols@gmail.com>\n+Carlos Galarza <carloslfu@gmail.com>\n+Carol (Nichols || Goulding) <carol.nichols@gmail.com>\n Carol Willing <carolcode@willingconsulting.com>\n Carter Hinsley <carterhinsley@gmail.com>\n Carter Tazio Schonwald <carter.schonwald@gmail.com>\n@@ -151,10 +158,11 @@ Chris Peterson <cpeterson@mozilla.com>\n Chris Pressey <cpressey@gmail.com>\n Chris Sainty <csainty@hotmail.com>\n Chris Shea <cmshea@gmail.com>\n-Chris Thorn <thorn@thoughtbot.com>\n+Chris Thorn <chris@thorn.co>\n Chris Wong <lambda.fairy@gmail.com>\n Christoph Burgdorf <christoph.burgdorf@bvsn.org>\n Christopher Bergqvist <spambox0@digitalpoetry.se>\n+Christopher Chambers <chris.chambers@peanutcode.com>\n Christopher Kendell <ckendell@outlook.com>\n Chuck Ries <chuck.ries@gmail.com>\n Clark Gaebel <cg.wowus.cg@gmail.com>\n@@ -172,13 +180,14 @@ Corey Richardson <corey@octayn.net>\n Cristi Burc\u0103 <scribu@gmail.com>\n Cristian Kubis <cristian.kubis@tsunix.de>\n DJUrsus <colinvh@divitu.com>\n-Dabo Ross <daboross@daboross.net>\n+David Ross <daboross@daboross.net>\n Damian Gryski <damian@gryski.com>\n Damien Grassart <damien@grassart.com>\n Damien Radtke <dradtke@channeliq.com>\n Damien Schoof <damien.schoof@gmail.com>\n Dan Albert <danalbert@google.com>\n Dan Burkert <dan@danburkert.com>\n+Dan Callahan <dan.callahan@gmail.com>\n Dan Connolly <dckc@madmode.com>\n Dan Luu <danluu@gmail.com>\n Dan Schatzberg <schatzberg.dan@gmail.com>\n@@ -234,6 +243,8 @@ Dmitry Ermolov <epdmitry@yandex.ru>\n Dmitry Promsky <dmitry@willworkforcookies.com>\n Dmitry Vasiliev <dima@hlabs.org>\n Do Nhat Minh <mrordinaire@gmail.com>\n+Dominic van Berkel <dominic@baudvine.net>\n+Dominick Allen <dominick.allen1989@gmail.com>\n Dominik Inf\u00fchr <dominik.infuehr@gmail.com>\n Donovan Preston <donovanpreston@gmail.com>\n Douglas Young <rcxdude@gmail.com>\n@@ -287,11 +298,10 @@ Felix S. Klock II <pnkfelix@pnkfx.org>\n Fenhl <fenhl@fenhl.net>\n Filip Szczepa\u0144ski <jazz2rulez@gmail.com>\n Flaper Fesp <flaper87@gmail.com>\n-Flavio Percoco <flaper87@gmail.com>\n Florian Gilcher <florian.gilcher@asquera.de>\n Florian Hahn <flo@fhahn.com>\n Florian Hartwig <florian.j.hartwig@gmail.com>\n-Florian Wilkens <floya@live.de>\n+Florian Wilkens <mrfloya_github@outlook.com>\n Florian Zeitz <florob@babelmonkeys.de>\n Francisco Souza <f@souza.cc>\n Franklin Chen <franklinchen@franklinchen.com>\n@@ -310,13 +320,12 @@ Georges Dubus <georges.dubus@gmail.com>\n Germano Gabbianelli <tyrion@users.noreply.github.com>\n Gil Cottle <rc@redtown.org>\n Gioele Barabucci <gioele@svario.it>\n-GlacJAY <glacjay@gmail.com>\n Gleb Kozyrev <gleb@gkoz.com>\n Glenn Willen <gwillen@nerdnet.org>\n Gon\u00e7alo Cabrita <_@gmcabrita.com>\n Graham Fawcett <graham.fawcett@gmail.com>\n Grahame Bowland <grahame@angrygoats.net>\n-Graydon Hoare <graydon@mozilla.com>\n+Graydon Hoare <graydon@pobox.com>\n Greg Chapple <gregchapple1@gmail.com>\n Grigoriy <ohaistarlight@gmail.com>\n Guillaume Gomez <guillaume1.gomez@gmail.com>\n@@ -325,11 +334,13 @@ Gyorgy Andrasek <jurily@gmail.com>\n G\u00e1bor Horv\u00e1th <xazax.hun@gmail.com>\n G\u00e1bor Lehel <glaebhoerl@gmail.com>\n Haitao Li <lihaitao@gmail.com>\n+Hajime Morrita <omo@dodgson.org>\n Hanno Braun <mail@hannobraun.de>\n Harry Marr <harry.marr@gmail.com>\n Heather <heather@cynede.net>\n+Heejong Ahn <heejongahn@gmail.com\n Henrik Schopmans <h.schopmans@googlemail.com>\n-Herman J. Radtke III <hermanradtke@gmail.com>\n+Herman J. Radtke III <herman@hermanradtke.com>\n HeroesGrave <heroesgrave@gmail.com>\n Hong Chulju <ang0123dev@gmail.com>\n Honza Strnad <hanny.strnad@gmail.com>\n@@ -343,6 +354,7 @@ Ian D. Bollinger <ian.bollinger@gmail.com>\n Ian Daniher <it.daniher@gmail.com>\n Ignacio Corderi <icorderi@msn.com>\n Igor Bukanov <igor@mir2.org>\n+Igor Strebezhev <xamgore@ya.ru>\n Ilya Dmitrichenko <ilya@xively.com>\n Ilyong Cho <ilyoan@gmail.com>\n Ingo Blechschmidt <iblech@web.de>\n@@ -390,7 +402,7 @@ Jashank Jeremy <jashank@rulingia.com>\n Jason Fager <jfager@gmail.com>\n Jason Orendorff <jorendorff@mozilla.com>\n Jason Thompson <jason@jthompson.ca>\n-Jason Toffaletti <jason@topsy.com>\n+Jason Toffaletti <toffaletti@gmail.com>\n Jauhien Piatlicki <jauhien@gentoo.org>\n Jay Anderson <jayanderson0@gmail.com>\n Jay True <glacjay@gmail.com>\n@@ -421,8 +433,10 @@ Jimmie Elvenmark <flugsio@gmail.com>\n Jimmy Lu <jimmy.lu.2011@gmail.com>\n Jimmy Zelinskie <jimmyzelinskie@gmail.com>\n Ji\u0159\u00ed Str\u00e1nsk\u00fd <jistr@jistr.com>\n+Jo\u00e3o Oliveira <hello@jxs.pt>\n Joe Pletcher <joepletcher@gmail.com>\n Joe Schafer <joe@jschaf.com>\n+Johann Hofmann <mail@johann-hofmann.com>\n Johannes Hoff <johshoff@gmail.com>\n Johannes L\u00f6thberg <johannes@kyriasis.com>\n Johannes Muenzel <jmuenzel@gmail.com>\n@@ -436,10 +450,10 @@ John Gallagher <jgallagher@bignerdranch.com>\n John Hodge <acessdev@gmail.com>\n John Ka\u030are Alsaker <john.kare.alsaker@gmail.com>\n John Kleint <jk@hinge.co>\n-John K\u00e5re Alsaker <john.kare.alsaker@gmail.com>\n John Louis Walker <injyuw@gmail.com>\n John Schmidt <john.schmidt.h@gmail.com>\n John Simon <john@johnsoft.com>\n+John Talling <inrustwetrust@users.noreply.github.com>\n John Zhang <john@zhang.io>\n Jon Haddad <jon@jonhaddad.com>\n Jon Morton <jonanin@gmail.com>\n@@ -462,6 +476,7 @@ Joseph Rushton Wakeling <joe@webdrake.net>\n Josh Haberman <jhaberman@gmail.com>\n Josh Matthews <josh@joshmatthews.net>\n Josh Stone <cuviper@gmail.com>\n+Josh Triplett <josh@joshtriplett.org>\n Joshua Clark <joshua.clark@txstate.edu>\n Joshua Wise <joshua@joshuawise.com>\n Joshua Yanovski <pythonesque@gmail.com>\n@@ -492,6 +507,7 @@ Kevin Walter <kevin.walter.private@googlemail.com>\n Kevin Yap <me@kevinyap.ca>\n Kiet Tran <ktt3ja@gmail.com>\n Kim R\u00f8en <kim@pam.no>\n+KokaKiwi <kokakiwi+rust@kokakiwi.net>\n Kostas Karachalios <vrinek@me.com>\n Kyeongwoon Lee <kyeongwoon.lee@samsung.com>\n Lai Jiangshan <laijs@cn.fujitsu.com>\n@@ -515,6 +531,7 @@ Lo\u00efc Damien <loic.damien@dzamlo.ch>\n Luca Bruno <lucab@debian.org>\n Luis de Bethencourt <luis@debethencourt.com>\n Luke Francl <look@recursion.org>\n+Luke Gallagher <luke@hypergeometric.net>\n Luke Metz <luke.metz@students.olin.edu>\n Luke Steensen <luke.steensen@gmail.com>\n Luqman Aden <me@luqman.ca>\n@@ -523,10 +540,12 @@ Magnus Auvinen <magnus.auvinen@gmail.com>\n Mahmut Bulut <mahmutbulut0@gmail.com>\n Makoto Nakashima <makoto.nksm+github@gmail.com>\n Manish Goregaokar <manishsmail@gmail.com>\n+Manuel Hoffmann <manuel@polythematik.de>\n Marcel Rodrigues <marcelgmr@gmail.com>\n Margaret Meyerhofer <mmeyerho@andrew.cmu.edu>\n Marijn Haverbeke <marijnh@gmail.com>\n Mark Lacey <641@rudkx.com>\n+Mark Mossberg <mark.mossberg@gmail.com>\n Mark Rowe <mrowe@bdash.net.nz>\n Mark Sinclair <mark.edward.x@gmail.com>\n Mark Vian <mrv.caseus@gmail.com>\n@@ -563,6 +582,7 @@ Maximilian Haack <mxhaack@gmail.com>\n Maya Nitu <maya_nitu@yahoo.com>\n Meyer S. Jacobs <meyermagic@gmail.com>\n Micah Chalmer <micah@micahchalmer.net>\n+Michael Alexander <beefsack@gmail.com>\n Michael Arntzenius <daekharel@gmail.com>\n Michael Bebenita <mbebenita@mozilla.com>\n Michael Budde <mbudde@gmail.com>\n@@ -582,9 +602,12 @@ Michael Sullivan <sully@msully.net>\n Michael Williams <m.t.williams@live.com>\n Michael Woerister <michaelwoerister@posteo>\n Michael Zhou <moz@google.com>\n+Micha\u0142 Czardybon <mczard@poczta.onet.pl>\n Micha\u0142 Krasnoborski <mkrdln@gmail.com>\n Mick Koch <kchmck@gmail.com>\n Micka\u00ebl Delahaye <mickael.delahaye@gmail.com>\n+Micka\u00ebl Raybaud-Roig <raybaudroigm@gmail.com>\n+Micka\u00ebl Sala\u00fcn <mic@digikod.net>\n Mihnea Dobrescu-Balaur <mihnea@linux.com>\n Mike Boutin <mike.boutin@gmail.com>\n Mike Dilger <mike@efx.co.nz>\n@@ -595,28 +618,28 @@ Mikhail Zabaluev <mikhail.zabaluev@gmail.com>\n Mikko Perttunen <cyndis@kapsi.fi>\n Ms2ger <ms2ger@gmail.com>\n Mukilan Thiagarajan <mukilanthiagarajan@gmail.com>\n-Mukilan Thiyagarajan <mukilanthiagarajan@gmail.com>\n Murarth <murarth@gmail.com>\n M\u00e1ty\u00e1s Mustoha <mmatyas@inf.u-szeged.hu>\n-NAKASHIMA, Makoto <makoto.nksm+github@gmail.com>\n NODA, Kai <nodakai@gmail.com>\n Nafis <nhoss2@gmail.com>\n Nathan Froyd <froydnj@gmail.com>\n Nathan Stoddard <nstodda@purdue.edu>\n Nathan Typanski <ntypanski@gmail.com>\n+Nathan Wilson <wilnathan@gmail.com>\n Nathan Zadoks <nathan@nathan7.eu>\n-Nathaniel Herman <nherman@college.harvard.edu>\n+Nathaniel Herman <nherman@post.harvard.edu>\n Nathaniel Theis <nttheis@gmail.com>\n Neil Pankey <npankey@gmail.com>\n Nelson Chen <crazysim@gmail.com>\n NiccosSystem <niccossystem@gmail.com>\n-Nicholas <npmazzuca@gmail.com>\n Nicholas Bishop <nicholasbishop@gmail.com>\n Nicholas Mazzuca <npmazzuca@gmail.com>\n Nick Cameron <ncameron@mozilla.com>\n Nick Desaulniers <ndesaulniers@mozilla.com>\n+Nick Hamann <nick@wabbo.org>\n Nick Howell <howellnick@gmail.com>\n Nick Sarten <gen.battle@gmail.com>\n+Nick Platt <platt.nicholas@gmail.com>\n Nicolas Silva <nical.silva@gmail.com>\n Niels Egberts <git@nielsegberts.nl>\n Niels langager Ellegaard <niels.ellegaard@gmail.com>\n@@ -626,16 +649,18 @@ Niklas Koep <niklas.koep@gmail.com>\n Niko Matsakis <niko@alum.mit.edu>\n Noam Yorav-Raphael <noamraph@gmail.com>\n Noufal Ibrahim <noufal@nibrahim.net.in>\n+Oak <White-Oak@users.noreply.github.com>\n O S K Chaitanya <osk@medhas.org>\n OGINO Masanori <masanori.ogino@gmail.com>\n-Oliver Schneider <oliver.schneider@kit.edu>\n+Oliver Schneider <github6541940@oli-obk.de>\n Olivier Saut <osaut@airpost.net>\n Olle Jonsson <olle.jonsson@gmail.com>\n Or Brostovski <tohava@gmail.com>\n Or Neeman <oneeman@gmail.com>\n Oren Hazi <oren.hazi@gmail.com>\n Orpheus Lummis <o@orpheuslummis.com>\n Orph\u00e9e Lafond-Lummis <o@orftz.com>\n+O\u017ebolt Menegatti <ozbolt.menegatti@gmail.com>\n P1start <rewi-github@whanau.org>\n Pablo Brasero <pablo@pablobm.com>\n Palmer Cox <p@lmercox.com>\n@@ -650,14 +675,15 @@ Paul Collier <paul@paulcollier.ca>\n Paul Collins <paul@ondioline.org>\n Paul Crowley <paulcrowley@google.com>\n Paul Osborne <osbpau@gmail.com>\n+Paul Quint <DrKwint@gmail.com>\n Paul Stansifer <paul.stansifer@gmail.com>\n Paul Woolcock <pwoolcoc+github@gmail.com>\n Pavel Panchekha <me@pavpanchekha.com>\n Pawel Olzacki <p.olzacki2@samsung.com>\n Pedro Larroy <pedro.larroy@here.com>\n Peer Aramillo Irizar <peer.aramillo.irizar@gmail.com>\n Peter Atashian <retep998@gmail.com>\n-Peter Elmers <peter.elmers@yahoo.com>\n+Peter Elmers <peter.elmers@rice.edu>\n Peter Hull <peterhull90@gmail.com>\n Peter Marheine <peter@taricorp.net>\n Peter Minten <peter@pminten.nl>\n@@ -675,12 +701,12 @@ Piotr Czarnecki <pioczarn@gmail.com>\n Piotr Jawniak <sawyer47@gmail.com>\n Piotr Szotkowski <chastell@chastell.net>\n Piotr Zolnierek <pz@anixe.pl>\n+Poga Po <poga.bahamut@gmail.com>\n Potpourri <pot_pourri@mail.ru>\n-Pradeep Kumar <gohanpra@gmail.com>\n Prudhvi Krishna Surapaneni <me@prudhvi.net>\n+Przemek Weso\u0142ek <jest@go.art.pl>\n Pyfisch <pyfisch@gmail.com>\n Pyry Kontio <pyry.kontio@drasa.eu>\n-Pythoner6 <pythoner6@gmail.com>\n Q.P.Liu <qpliu@yahoo.com>\n Rafael \u00c1vila de Esp\u00edndola <respindola@mozilla.com>\n Rahul Hor\u00e9 <hore.rahul@gmail.com>\n@@ -694,9 +720,9 @@ Raphael Speyer <rspeyer@gmail.com>\n Raul Gutierrez S <rgs@itevenworks.net>\n Ray Clanan <rclanan@utopianconcept.com>\n Reilly Watson <reillywatson@gmail.com>\n+Remi Rampin <remirampin@gmail.com>\n Renato Alves <alves.rjc@gmail.com>\n Renato Riccieri Santos Zannon <renato@rrsz.com.br>\n-Renato Zannon <renato@rrsz.com.br>\n Reuben Morais <reuben.morais@gmail.com>\n Ricardo M. Correia <rcorreia@wizy.org>\n Ricardo Martins <ricardo@scarybox.net>\n@@ -714,6 +740,7 @@ Robert Irelan <rirelan@gmail.com>\n Robert Knight <robertknight@gmail.com>\n Robert Millar <robert.millar@cantab.net>\n Robin Gloster <robin@loc-com.de>\n+Robin Kruppe <robin.kruppe@gmail.com>\n Robin Stocker <robin@nibor.org>\n Rohit Joshi <rohitjoshi@users.noreply.github.com>\n Roland Tanglao <roland@rolandtanglao.com>\n@@ -722,14 +749,13 @@ Rolf van de Krol <info@rolfvandekrol.nl>\n Ron Dahlgren <ronald.dahlgren@gmail.com>\n Roy Crihfield <rscrihf@gmail.com>\n Roy Frostig <rfrostig@mozilla.com>\n-Russell <rpjohnst@gmail.com>\n+Russell Johnston <rpjohnst@gmail.com>\n Ruud van Asseldonk <dev@veniogames.com>\n Ryan Levick <ryan@6wunderkinder.com>\n Ryan Mulligan <ryan@ryantm.com>\n Ryan Prichard <ryan.prichard@gmail.com>\n Ryan Riginding <marc.riginding@gmail.com>\n Ryan Scheel <ryan.havvy@gmail.com>\n-Ryman <haqkrs@gmail.com>\n R\u00fcdiger Sonderfeld <ruediger@c-plusplus.de>\n S Pradeep Kumar <gohanpra@gmail.com>\n Sae-bom Kim <sae-bom.kim@samsung.com>\n@@ -745,6 +771,7 @@ Saurabh Anand <saurabhanandiit@gmail.com>\n Scott Jenkins <scottdjwales@gmail.com>\n Scott Lawrence <bytbox@gmail.com>\n Scott Olson <scott@scott-olson.org>\n+Sean Bowe <ewillbefull@gmail.com>\n Sean Chalmers <sclhiannan@gmail.com>\n Sean Collins <sean@cllns.com>\n Sean Gillespie <sean.william.g@gmail.com>\n@@ -799,16 +826,18 @@ Taylor Hutchison <seanthutchison@gmail.com>\n Ted Horst <ted.horst@earthlink.net>\n Tero H\u00e4nninen <lgvz@users.noreply.github.com>\n Thad Guidry <thadguidry@gmail.com>\n+Theo Belaire <theo.belaire@gmail.com>\n Thiago Carvalho <thiago.carvalho@westwing.de>\n Thiago Pontes <email@thiago.me>\n Thomas Backman <serenity@exscape.org>\n+Thomas Bracht Laumann Jespersen <laumann.thomas@gmail.com>\n Thomas Daede <daede003@umn.edu>\n Tiago Nobrega <tigarmo@gmail.com>\n+Tibor Benke <ihrwein@gmail.com>\n Till Hoeppner <till@hoeppner.ws>\n Tim Brooks <brooks@cern.ch>\n Tim Chevalier <chevalier@alum.wellesley.edu>\n Tim Cuthbertson <tim@gfxmonk.net>\n-Tim Dumol <tim@timdumol.com>\n Tim Joseph Dumol <tim@timdumol.com>\n Tim Kuehn <tkuehn@cmu.edu>\n Tim Parenti <timparenti@gmail.com>\n@@ -836,7 +865,7 @@ Trinick <slicksilver555@mac.com>\n Tristan Storch <tstorch@math.uni-bielefeld.de>\n Tshepang Lekhonkhobe <tshepang@gmail.com>\n Tuncer Ayaz <tuncer.ayaz@gmail.com>\n-TyOverby <ty@pre-alpha.com>\n+Ty Overby <ty@pre-alpha.com>\n Tycho Sci <tychosci@gmail.com>\n Tyler Bindon <martica@martica.org>\n Tyler Thrailkill <tylerbthrailkill@gmail.com>\n@@ -870,8 +899,10 @@ WebeWizard <webewizard@gmail.com>\n Wendell Smith <wendell.smith@yale.edu>\n Wesley Wiser <wwiser@gmail.com>\n Will <will@glozer.net>\n+Will Hipschman <whipsch@gmail.com>\n William Ting <io@williamting.com>\n Willson Mock <willson.mock@gmail.com>\n+Xue Fuqiao <xfq.free@gmail.com>\n Yasuhiro Fujii <y-fujii@mimosa-pudica.net>\n YawarRaza7349 <YawarRaza7349@gmail.com>\n Yazhong Liu <yorkiefixer@gmail.com>\n@@ -889,68 +920,56 @@ Zack Slayton <zack.slayton@gmail.com>\n Zbigniew Siciarz <zbigniew@siciarz.net>\n Ziad Hatahet <hatahet@gmail.com>\n Zooko Wilcox-O'Hearn <zooko@zooko.com>\n-adridu59 <adri-from-59@hotmail.fr>\n-aochagavia <aochagavia92@gmail.com>\n-areski <areski@gmail.com>\n arturo <arturo@openframeworks.cc>\n auREAX <mark@xn--hwg34fba.ws>\n awlnx <alecweber1994@gmail.com>\n aydin.kim <aydin.kim@samsung.com>\n-b1nd <clint.ryan3@gmail.com>\n bachm <Ab@vapor.com>\n bcoopers <coopersmithbrian@gmail.com>\n-blackbeam <aikorsky@gmail.com>\n+Anatoly Ikorsky <aikorsky@gmail.com>\n blake2-ppc <ulrik.sverdrup@gmail.com>\n bluss <bluss>\n-bombless <bombless@126.com>\n bors <bors@rust-lang.org>\n-caipre <platt.nicholas@gmail.com>\n chitra\n chromatic <chromatic@wgz.org>\n comex <comexk@gmail.com>\n crhino <piraino.chris@gmail.com>\n-dan@daramos.com <dan@daramos.com>\n+Daniel Ramos <dan@daramos.com>\n darkf <lw9k123@gmail.com>\n defuz <defuz.net@gmail.com>\n dgoon <dgoon@dgoon.net>\n donkopotamus <general@chocolate-fish.com>\n eliovir <eliovir@gmail.com>\n elszben <notgonna@tellyou>\n emanueLczirai <emanueLczirai@cryptoLab.net>\n+fenduru <fenduru@users.noreply.github.com>\n flo-l <lacknerflo@gmail.com>\n fort <e@mail.com>\n free-Runner <aali07@students.poly.edu>\n g3xzh <g3xzh@yahoo.com>\n gamazeps <gamaz3ps@gmail.com>\n gareth <gareth@gareth-N56VM.(none)>\n gentlefolk <cemacken@gmail.com>\n-gifnksm <makoto.nksm@gmail.com>\n+github-monoculture <eocene@gmx.com>\n hansjorg <hansjorg@gmail.com>\n-iancormac84 <wilnathan@gmail.com>\n-inrustwetrust <inrustwetrust@users.noreply.github.com>\n jamesluke <jamesluke@users.noreply.github.com>\n jatinn <jatinn@users.noreply.github.com>\n jbranchaud <jbranchaud@gmail.com>\n-jfager <jfager@gmail.com>\n jmgrosen <jmgrosen@gmail.com>\n jmu303 <muj@bc.edu>\n-joaoxsouls <joaoxsouls@gmail.com>\n jrincayc <jrincayc@users.noreply.github.com>\n juxiliary <juxiliary@gmail.com>\n jxv <joevargas@hush.com>\n kgv <mail@kgv.name>\n kjpgit <kjpgit@users.noreply.github.com>\n klutzy <klutzytheklutzy@gmail.com>\n korenchkin <korenchkin2@gmail.com>\n-kud1ing <github@kudling.de>\n kulakowski <george.kulakowski@gmail.com>\n-kvark <kvarkus@gmail.com>\n kwantam <kwantam@gmail.com>\n lpy <pylaurent1314@gmail.com>\n lucy <ne.tetewi@gmail.com>\n lummax <luogpg@googlemail.com>\n lyuts <dioxinu@gmail.com>\n-m-r-r <raybaudroigm@gmail.com>\n madmalik <matthias.tellen@googlemail.com>\n maikklein <maikklein@googlemail.com>\n masklinn <github.com@masklinn.net>\n@@ -962,21 +981,20 @@ mr.Shu <mr@shu.io>\n mrec <mike.capp@gmail.com>\n musitdev <philippe.delrieu@free.fr>\n nathan dotz <nathan.dotz@gmail.com>\n-nham <hamann.nick@gmail.com>\n-niftynif <nif.ward@gmail.com>\n+Nils Winter <nils.winter@gmail.com>\n noam <noam@clusterfoo.com>\n novalis <novalis@novalis.org>\n nsf <no.smile.face@gmail.com>\n-nwin <nwin@users.noreply.github.com>\n-oli-obk <github6541940@oli-obk.de>\n olivren <o.renaud@gmx.fr>\n osa1 <omeragacan@gmail.com>\n+pez <james.austin.perry@gmail.com>\n posixphreak <posixphreak@gmail.com>\n qwitwa <qwitwa@gmail.com>\n ray glover <ray@rayglover.net>\n reedlepee <reedlepee123@gmail.com>\n reus <reusee@ymail.com>\n rjz <rj@rjzaworski.com>\n+rundrop1 <rundrop1@zoho.com>\n sevrak <sevrak@rediffmail.com>\n sheroze1123 <mss385@cornell.edu>\n smenardpw <sebastien@knoglr.com>\n@@ -990,12 +1008,9 @@ tinaun <tinagma@gmail.com>\n tshakah <tshakah@gmail.com>\n ville-h <ville3.14159@gmail.com>\n visualfc <visualfc@gmail.com>\n-we <vadim.petrochenkov@gmail.com>\n whataloadofwhat <unusualmoniker@gmail.com>\n wickerwaka <martin.donlon@gmail.com>\n wonyong kim <wonyong.kim@samsung.com>\n xales <xales@naveria.com>\n zofrex <zofrex@gmail.com>\n-zslayton <zack.slayton@gmail.com>\n-zzmp <zmp@umich.edu>\n \u514b\u96f7 <geekcraik@users.noreply.github.com>"}, {"sha": "3219449edd8a18cbed81f0216ca317fcb8db483f", "filename": "RELEASES.md", "status": "modified", "additions": 140, "deletions": 76, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -1,79 +1,142 @@\n-Version 1.0.0-beta (April 2015)\n--------------------------------------\n-\n-* ~1100 changes, numerous bugfixes\n-\n-* Highlights\n-\n-    * The big news is that the vast majority of the standard library\n-      is now `#[stable]` -- 75% of the non-deprecated API surface at\n-      last count. Numerous crates are now running on stable\n-      Rust. Starting with this release, it is not possible to use\n-      unstable features on a stable build.\n-    * Arithmetic on basic integer types now\n-      [checks for overflow in debug builds][overflow].\n-\n-* Language\n-\n-    * [`Send` no longer implies `'static`][send-rfc], which made\n-      possible the [`thread::scoped` API][scoped]. Scoped threads can\n-      borrow data from their parent's stack frame -- safely!\n-    * [UFCS now supports trait-less associated paths][moar-ufcs] like\n-      `MyType::default()`.\n-    * Primitive types [now have inherent methods][prim-inherent],\n-      obviating the need for extension traits like `SliceExt`.\n-    * Methods with `Self: Sized` in their `where` clause are\n-      [considered object-safe][self-sized], allowing many extension\n-      traits like `IteratorExt` to be merged into the traits they\n-      extended.\n-    * You can now [refer to associated types][assoc-where] whose\n-      corresponding trait bounds appear only in a `where` clause.\n-    * The final bits of [OIBIT landed][oibit-final], meaning that\n-      traits like `Send` and `Sync` are now library-defined.\n-    * A [Reflect trait][reflect] was introduced, which means that\n-      downcasting via the `Any` trait is effectively limited to\n-      concrete types. This helps retain the potentially-important\n-      \"parametricity\" property: generic code cannot behave differently\n-      for different type arguments except in minor ways.\n-    * The `unsafe_destructor` feature is now deprecated in favor of\n-      the [new `dropck`][dropck]. This change is a major reduction in\n-      unsafe code.\n-    * Trait coherence was [revised again][fundamental], this time with\n-      an eye toward API evolution over time.\n-\n-* Libraries\n-\n-    * The new path and IO modules are complete and `#[stable]`. This\n-      was the major library focus for this cycle.\n-    * The path API was [revised][path-normalize] to normalize `.`,\n-      adjusting the tradeoffs in favor of the most common usage.\n-    * A large number of remaining APIs in `std` were also stabilized\n-      during this cycle; about 75% of the non-deprecated API surface\n-      is now stable.\n-    * The new [string pattern API][string-pattern] landed, which makes\n-      the string slice API much more internally consistent and flexible.\n-    * A shiny [framework for Debug implementations][debug-builder] landed.\n-      This makes it possible to opt in to \"pretty-printed\" debugging output.\n-    * A new set of [generic conversion traits][conversion] replaced\n-      many existing ad hoc traits.\n-    * Generic numeric traits were\n-      [completely removed][num-traits]. This was made possible thanks\n-      to inherent methods for primitive types, and the removal gives\n-      maximal flexibility for designing a numeric hierarchy in the future.\n-    * The `Fn` traits are now related via [inheritance][fn-inherit]\n-      and provide ergonomic [blanket implementations][fn-blanket].\n-    * The `Index` and `IndexMut` traits were changed to\n-      [take the index by value][index-value], enabling code like\n-      `hash_map[\"string\"]` to work.\n-    * `Copy` now [inherits][copy-clone] from `Clone`, meaning that all\n-      `Copy` data is known to be `Clone` as well.\n-\n-* Infrastructure\n-\n-    * Metadata was tuned, shrinking binaries [by 27%][metadata-shrink].\n-    * Much headway was made on ecosystem-wide CI, making it possible\n-      to [compare builds for breakage][ci-compare].\n-\n+Version 1.0.0 (May 2015)\n+========================\n+\n+* ~1500 changes, numerous bugfixes\n+\n+Highlights\n+----------\n+\n+* The vast majority of the standard library is now `#[stable]`. It is\n+  no longer possible to use unstable features with a stable build of\n+  the compiler.\n+* Many popular crates on [crates.io] now work on the stable release\n+  channel.\n+* Arithmetic on basic integer types now [checks for overflow in debug\n+  builds][overflow].\n+\n+Language\n+--------\n+\n+* Several [restrictions have been added to trait coherence][coh] in\n+  order to make it easier for upstream authors to change traits\n+  without breaking downsteam code.\n+* Digits of binary and octal literals are [lexed more eagerly][lex] to\n+  improve error messages and macro behavior. For example, `0b1234` is\n+  now lexed as `0b1234` instead of two tokens, `0b1` and `234`.\n+* Trait bounds [are always invariant][inv], eleminating the need for\n+  the `PhantomFn` and `MarkerTrait` lang items, which have been\n+  removed.\n+* [\"-\" is no longer a valid character in crate names][cr], the `extern crate\n+  \"foo\" as bar` syntax has been replaced with `extern crate foo as\n+  bar`, and Cargo now automatically translates \"-\" in *package* names\n+  to underscore for the crate name.\n+* [Lifetime shadowing is an error][lt].\n+* [`Send` no longer implies `'static`][send-rfc].\n+* [UFCS now supports trait-less associated paths][moar-ufcs] like\n+  `MyType::default()`.\n+* Primitive types [now have inherent methods][prim-inherent],\n+  obviating the need for extension traits like `SliceExt`.\n+* Methods with `Self: Sized` in their `where` clause are [considered\n+  object-safe][self-sized], allowing many extension traits like\n+  `IteratorExt` to be merged into the traits they extended.\n+* You can now [refer to associated types][assoc-where] whose\n+  corresponding trait bounds appear only in a `where` clause.\n+* The final bits of [OIBIT landed][oibit-final], meaning that traits\n+  like `Send` and `Sync` are now library-defined.\n+* A [Reflect trait][reflect] was introduced, which means that\n+  downcasting via the `Any` trait is effectively limited to concrete\n+  types. This helps retain the potentially-important \"parametricity\"\n+  property: generic code cannot behave differently for different type\n+  arguments except in minor ways.\n+* The `unsafe_destructor` feature is now deprecated in favor of the\n+  [new `dropck`][dropck]. This change is a major reduction in unsafe\n+  code.\n+\n+Libraries\n+---------\n+\n+* The `thread_local` module [has been renamed to `std::thread`][th].\n+* The methods of `IteratorExt` [have been moved to the `Iterator`\n+  trait itself][ie].\n+* Several traits that implement Rust's conventions for type\n+  conversions, `AsMut`, `AsRef`, `From`, and `Into` have been\n+  [centralized in the `std::convert` module][con].\n+* The `FromError` trait [was removed in favor of `From`][fe].\n+* The basic sleep function [has moved to\n+  `std::thread::sleep_ms`][slp].\n+* The `splitn` function now takes an `n` parameter that represents the\n+  number of items yielded by the returned iterator [instead of the\n+  number of 'splits'][spl].\n+* [On Unix, all file descriptors are `CLOEXEC` by default][clo].\n+* [Derived implementations of `PartialOrd` now order enums according\n+  to their explicitly-assigned discriminants][po].\n+* [Methods for searching strings are generic over `Pattern`s][pat],\n+  implemented presently by `&char`, `&str`, `FnMut(char) -> bool` and\n+  some others.\n+* [In method resolution, object methods are resolved before inherent\n+  methods][meth].\n+* [`String::from_str` has been deprecated in favor of the `From` impl,\n+  `String::from`][sf].\n+* [`io::Error` implements `Sync`][ios].\n+* [The `words` method on `&str` has been replaced with\n+  `split_whitespace`][sw], to avoid answering the tricky question, 'what is\n+  a word?'\n+* The new path and IO modules are complete and `#[stable]`. This\n+  was the major library focus for this cycle.\n+* The path API was [revised][path-normalize] to normalize `.`,\n+  adjusting the tradeoffs in favor of the most common usage.\n+* A large number of remaining APIs in `std` were also stabilized\n+  during this cycle; about 75% of the non-deprecated API surface\n+  is now stable.\n+* The new [string pattern API][string-pattern] landed, which makes\n+  the string slice API much more internally consistent and flexible.\n+* A new set of [generic conversion traits][conversion] replaced\n+  many existing ad hoc traits.\n+* Generic numeric traits were [completely removed][num-traits]. This\n+  was made possible thanks to inherent methods for primitive types,\n+  and the removal gives maximal flexibility for designing a numeric\n+  hierarchy in the future.\n+* The `Fn` traits are now related via [inheritance][fn-inherit]\n+  and provide ergonomic [blanket implementations][fn-blanket].\n+* The `Index` and `IndexMut` traits were changed to\n+  [take the index by value][index-value], enabling code like\n+  `hash_map[\"string\"]` to work.\n+* `Copy` now [inherits][copy-clone] from `Clone`, meaning that all\n+  `Copy` data is known to be `Clone` as well.\n+\n+Misc\n+----\n+\n+* Many errors now have extended explanations that can be accessed with\n+  the `--explain` flag to `rustc`.\n+* Many new examples have been added to the standard library\n+  documentation.\n+* rustdoc has received a number of improvements focused on completion\n+  and polish.\n+* Metadata was tuned, shrinking binaries [by 27%][metadata-shrink].\n+* Much headway was made on ecosystem-wide CI, making it possible\n+  to [compare builds for breakage][ci-compare].\n+\n+\n+[crates.io]: http://crates.io\n+[clo]: https://github.com/rust-lang/rust/pull/24034\n+[coh]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md\n+[con]: https://github.com/rust-lang/rust/pull/23875\n+[cr]: https://github.com/rust-lang/rust/pull/23419\n+[fe]: https://github.com/rust-lang/rust/pull/23879\n+[ie]: https://github.com/rust-lang/rust/pull/23300\n+[inv]: https://github.com/rust-lang/rust/pull/23938\n+[ios]: https://github.com/rust-lang/rust/pull/24133\n+[lex]: https://github.com/rust-lang/rfcs/blob/master/text/0879-small-base-lexing.md\n+[lt]: https://github.com/rust-lang/rust/pull/24057\n+[meth]: https://github.com/rust-lang/rust/pull/24056\n+[pat]: https://github.com/rust-lang/rfcs/blob/master/text/0528-string-patterns.md\n+[po]: https://github.com/rust-lang/rust/pull/24270\n+[sf]: https://github.com/rust-lang/rust/pull/24517\n+[slp]: https://github.com/rust-lang/rust/pull/23949\n+[spl]: https://github.com/rust-lang/rfcs/blob/master/text/0979-align-splitn-with-other-languages.md\n+[sw]: https://github.com/rust-lang/rfcs/blob/master/text/1054-str-words.md\n+[th]: https://github.com/rust-lang/rfcs/blob/master/text/0909-move-thread-local-to-std-thread.md\n [send-rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0458-send-improvements.md\n [scoped]: http://static.rust-lang.org/doc/master/std/thread/fn.scoped.html\n [moar-ufcs]: https://github.com/rust-lang/rust/pull/22172\n@@ -97,6 +160,7 @@ Version 1.0.0-beta (April 2015)\n [copy-clone]: https://github.com/rust-lang/rust/pull/23860\n [path-normalize]: https://github.com/rust-lang/rust/pull/23229\n \n+\n Version 1.0.0-alpha.2 (February 2015)\n -------------------------------------\n "}, {"sha": "fb7562e7bdf8b28b8ebcb3537d66016d120efe5c", "filename": "src/doc/grammar.md", "status": "modified", "additions": 68, "deletions": 66, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -253,7 +253,7 @@ The two values of the boolean type are written `true` and `false`.\n ### Symbols\n \n ```antlr\n-symbol : \"::\" \"->\"\n+symbol : \"::\" | \"->\"\n        | '#' | '[' | ']' | '(' | ')' | '{' | '}'\n        | ',' | ';' ;\n ```\n@@ -304,7 +304,7 @@ transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n ## Items\n \n ```antlr\n-item : mod_item | fn_item | type_item | struct_item | enum_item\n+item : vis ? mod_item | fn_item | type_item | struct_item | enum_item\n      | const_item | static_item | trait_item | impl_item | extern_block ;\n ```\n \n@@ -322,7 +322,7 @@ mod : [ view_item | item ] * ;\n #### View items\n \n ```antlr\n-view_item : extern_crate_decl | use_decl ;\n+view_item : extern_crate_decl | use_decl ';' ;\n ```\n \n ##### Extern crate declarations\n@@ -335,14 +335,14 @@ crate_name: ident | ( ident \"as\" ident )\n ##### Use declarations\n \n ```antlr\n-use_decl : \"pub\" ? \"use\" [ path \"as\" ident\n-                          | path_glob ] ;\n+use_decl : vis ? \"use\" [ path \"as\" ident\n+                        | path_glob ] ;\n \n path_glob : ident [ \"::\" [ path_glob\n                           | '*' ] ] ?\n           | '{' path_item [ ',' path_item ] * '}' ;\n \n-path_item : ident | \"mod\" ;\n+path_item : ident | \"self\" ;\n ```\n \n ### Functions\n@@ -414,16 +414,17 @@ extern_block : [ foreign_fn ] * ;\n \n ## Visibility and Privacy\n \n-**FIXME:** grammar?\n-\n+```antlr\n+vis : \"pub\" ;\n+```\n ### Re-exporting and Visibility\n \n-**FIXME:** grammar?\n+See [Use declarations](#use-declarations).\n \n ## Attributes\n \n ```antlr\n-attribute : \"#!\" ? '[' meta_item ']' ;\n+attribute : '#' '!' ? '[' meta_item ']' ;\n meta_item : ident [ '=' literal\n                   | '(' meta_seq ')' ] ? ;\n meta_seq : meta_item [ ',' meta_seq ] ? ;\n@@ -433,26 +434,19 @@ meta_seq : meta_item [ ',' meta_seq ] ? ;\n \n ## Statements\n \n-**FIXME:** grammar?\n+```antlr\n+stmt : decl_stmt | expr_stmt ;\n+```\n \n ### Declaration statements\n \n-**FIXME:** grammar?\n-\n-A _declaration statement_ is one that introduces one or more *names* into the\n-enclosing statement block. The declared names may denote new variables or new\n-items.\n+```antlr\n+decl_stmt : item | let_decl ;\n+```\n \n #### Item declarations\n \n-**FIXME:** grammar?\n-\n-An _item declaration statement_ has a syntactic form identical to an\n-[item](#items) declaration within a module. Declaring an item &mdash; a\n-function, enumeration, structure, type, static, trait, implementation or module\n-&mdash; locally within a statement block is simply a way of restricting its\n-scope to a narrow region containing all of its uses; it is otherwise identical\n-in meaning to declaring the item outside the statement block.\n+See [Items](#items).\n \n #### Variable declarations\n \n@@ -463,11 +457,21 @@ init : [ '=' ] expr ;\n \n ### Expression statements\n \n-**FIXME:** grammar?\n+```antlr\n+expr_stmt : expr ';' ;\n+```\n \n ## Expressions\n \n-**FIXME:** grammar?\n+```antlr\n+expr : literal | path | tuple_expr | unit_expr | struct_expr\n+     | block_expr | method_call_expr | field_expr | array_expr\n+     | idx_expr | range_expr | unop_expr | binop_expr\n+     | paren_expr | call_expr | lambda_expr | while_expr\n+     | loop_expr | break_expr | continue_expr | for_expr\n+     | if_expr | match_expr | if_let_expr | while_let_expr\n+     | return_expr ;\n+```\n \n #### Lvalues, rvalues and temporaries\n \n@@ -479,19 +483,23 @@ init : [ '=' ] expr ;\n \n ### Literal expressions\n \n-**FIXME:** grammar?\n+See [Literals](#literals).\n \n ### Path expressions\n \n-**FIXME:** grammar?\n+See [Paths](#paths).\n \n ### Tuple expressions\n \n-**FIXME:** grammar?\n+```antlr\n+tuple_expr : '(' [ expr [ ',' expr ] * | expr ',' ] ? ')' ;\n+```\n \n ### Unit expressions\n \n-**FIXME:** grammar?\n+```antlr\n+unit_expr : \"()\" ;\n+```\n \n ### Structure expressions\n \n@@ -507,8 +515,7 @@ struct_expr : expr_path '{' ident ':' expr\n ### Block expressions\n \n ```antlr\n-block_expr : '{' [ view_item ] *\n-                 [ stmt ';' | item ] *\n+block_expr : '{' [ stmt ';' | item ] *\n                  [ expr ] '}' ;\n ```\n \n@@ -529,7 +536,7 @@ field_expr : expr '.' ident ;\n ```antlr\n array_expr : '[' \"mut\" ? array_elems? ']' ;\n \n-array_elems : [expr [',' expr]*] | [expr ',' \"..\" expr] ;\n+array_elems : [expr [',' expr]*] | [expr ';' expr] ;\n ```\n \n ### Index expressions\n@@ -549,65 +556,60 @@ range_expr : expr \"..\" expr |\n \n ### Unary operator expressions\n \n-**FIXME:** grammar?\n+```antlr\n+unop_expr : unop expr ;\n+unop : '-' | '*' | '!' ;\n+```\n \n ### Binary operator expressions\n \n ```antlr\n-binop_expr : expr binop expr ;\n+binop_expr : expr binop expr | type_cast_expr\n+           | assignment_expr | compound_assignment_expr ;\n+binop : arith_op | bitwise_op | lazy_bool_op | comp_op\n ```\n \n #### Arithmetic operators\n \n-**FIXME:** grammar?\n+```antlr\n+arith_op : '+' | '-' | '*' | '/' | '%' ;\n+```\n \n #### Bitwise operators\n \n-**FIXME:** grammar?\n+```antlr\n+bitwise_op : '&' | '|' | '^' | \"<<\" | \">>\" ;\n+```\n \n #### Lazy boolean operators\n \n-**FIXME:** grammar?\n+```antlr\n+lazy_bool_op : \"&&\" | \"||\" ;\n+```\n \n #### Comparison operators\n \n-**FIXME:** grammar?\n+```antlr\n+comp_op : \"==\" | \"!=\" | '<' | '>' | \"<=\" | \">=\" ;\n+```\n \n #### Type cast expressions\n \n-**FIXME:** grammar?\n+```antlr\n+type_cast_expr : value \"as\" type ;\n+```\n \n #### Assignment expressions\n \n-**FIXME:** grammar?\n+```antlr\n+assignment_expr : expr '=' expr ;\n+```\n \n #### Compound assignment expressions\n \n-**FIXME:** grammar?\n-\n-#### Operator precedence\n-\n-The precedence of Rust binary operators is ordered as follows, going from\n-strong to weak:\n-\n-```text\n-* / %\n-as\n-+ -\n-<< >>\n-&\n-^\n-|\n-< > <= >=\n-== !=\n-&&\n-||\n-=\n-```\n-\n-Operators at the same precedence level are evaluated left-to-right. [Unary\n-operators](#unary-operator-expressions) have the same precedence level and it\n-is stronger than any of the binary operators'.\n+```antlr\n+compound_assignment_expr : expr [ arith_op | bitwise_op ] '=' expr ;\n+```\n \n ### Grouped expressions\n "}, {"sha": "c4725c26e46bd14fd634dafb8ac5aeb8c627d808", "filename": "src/doc/index.md", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -5,15 +5,14 @@ to jump to any particular section.\n \n # Getting Started\n \n-If you haven't seen Rust at all yet, the first thing you should read is the [30\n-minute intro](intro.html). It will give you an overview of the basic ideas of Rust\n-at a high level.\n+If you haven't seen Rust at all yet, the first thing you should read is the\n+introduction to [The Rust Programming Language](book/index.html). It'll give\n+you a good idea of what Rust is like.\n \n-Once you know you really want to learn Rust, the next step is reading [The\n-Rust Programming Language](book/index.html). It is a lengthy explanation of\n-Rust, its syntax, and its concepts. Upon completing the book, you'll be an\n-intermediate Rust developer, and will have a good grasp of the fundamental\n-ideas behind Rust.\n+The book provides a lengthy explanation of Rust, its syntax, and its\n+concepts. Upon completing the book, you'll be an intermediate Rust\n+developer, and will have a good grasp of the fundamental ideas behind\n+Rust.\n \n [Rust By Example][rbe] was originally a community resource, but was then\n donated to the Rust project. As the name implies, it teaches you Rust through a\n@@ -24,7 +23,7 @@ series of small examples.\n # Community & Getting Help\n \n If you need help with something, or just want to talk about Rust with others,\n-there's a few places you can do that:\n+there are a few places you can do that:\n \n The Rust IRC channels on [irc.mozilla.org](http://irc.mozilla.org/) are the\n fastest way to get help.\n@@ -59,7 +58,7 @@ the language in as much detail as possible is in [the reference](reference.html)\n \n # Tools\n \n-Rust's still a young language, so there isn't a ton of tooling yet, but the\n+Rust is still a young language, so there isn't a ton of tooling yet, but the\n tools we have are really nice.\n \n [Cargo](http://crates.io) is Rust's package manager, and its website contains\n@@ -69,16 +68,21 @@ lots of good documentation.\n \n # FAQs\n \n-There are questions that are asked quite often, and so we've made FAQs for them:\n+There are questions that are asked quite often, so we've made FAQs for them:\n \n * [Language Design FAQ](complement-design-faq.html)\n * [Language FAQ](complement-lang-faq.html)\n * [Project FAQ](complement-project-faq.html)\n * [How to submit a bug report](https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports)\n \n-# The standard library\n+# The Standard Library\n \n We have [API documentation for the entire standard\n library](std/index.html). There's a list of crates on the left with more\n specific sections, or you can use the search bar at the top to search for\n something if you know its name.\n+\n+# The Error Index\n+\n+If you encounter an error while compiling your code you may be able to look it\n+up in the [Rust Compiler Error Index](error-index.html)."}, {"sha": "2ddec9ba424f2009cdebbb755fc048ff84006735", "filename": "src/doc/reference.md", "status": "modified", "additions": 206, "deletions": 88, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -31,23 +31,27 @@ You may also be interested in the [grammar].\n \n ## Unicode productions\n \n-A few productions in Rust's grammar permit Unicode code points outside the ASCII\n-range. We define these productions in terms of character properties specified\n-in the Unicode standard, rather than in terms of ASCII-range code points. The\n-section [Special Unicode Productions](#special-unicode-productions) lists these\n-productions.\n+A few productions in Rust's grammar permit Unicode code points outside the\n+ASCII range. We define these productions in terms of character properties\n+specified in the Unicode standard, rather than in terms of ASCII-range code\n+points. The grammar has a [Special Unicode Productions][unicodeproductions]\n+section that lists these productions.\n+\n+[unicodeproductions]: grammar.html#special-unicode-productions\n \n ## String table productions\n \n Some rules in the grammar &mdash; notably [unary\n operators](#unary-operator-expressions), [binary\n-operators](#binary-operator-expressions), and [keywords](#keywords) &mdash; are\n+operators](#binary-operator-expressions), and [keywords][keywords] &mdash; are\n given in a simplified form: as a listing of a table of unquoted, printable\n whitespace-separated strings. These cases form a subset of the rules regarding\n the [token](#tokens) rule, and are assumed to be the result of a\n lexical-analysis phase feeding the parser, driven by a DFA, operating over the\n disjunction of all such string table entries.\n \n+[keywords]: grammar.html#keywords\n+\n When such a string enclosed in double-quotes (`\"`) occurs inside the grammar,\n it is an implicit reference to a single member of such a string table\n production. See [tokens](#tokens) for more information.\n@@ -75,7 +79,7 @@ An identifier is any nonempty Unicode[^non_ascii_idents] string of the following\n - The first character has property `XID_start`\n - The remaining characters have property `XID_continue`\n \n-that does _not_ occur in the set of [keywords](#keywords).\n+that does _not_ occur in the set of [keywords][keywords].\n \n > **Note**: `XID_start` and `XID_continue` as character properties cover the\n > character ranges used to form the more familiar C and Java language-family\n@@ -401,7 +405,7 @@ Symbols are a general class of printable [token](#tokens) that play structural\n roles in a variety of grammar productions. They are catalogued here for\n completeness as the set of remaining miscellaneous printable tokens that do not\n otherwise appear as [unary operators](#unary-operator-expressions), [binary\n-operators](#binary-operator-expressions), or [keywords](#keywords).\n+operators](#binary-operator-expressions), or [keywords][keywords].\n \n \n ## Paths\n@@ -422,12 +426,12 @@ x;\n x::y::z;\n ```\n \n-Path components are usually [identifiers](#identifiers), but the trailing\n-component of a path may be an angle-bracket-enclosed list of type arguments. In\n-[expression](#expressions) context, the type argument list is given after a\n-final (`::`) namespace qualifier in order to disambiguate it from a relational\n-expression involving the less-than symbol (`<`). In type expression context,\n-the final namespace qualifier is omitted.\n+Path components are usually [identifiers](#identifiers), but they may\n+also include angle-bracket-enclosed lists of type arguments. In\n+[expression](#expressions) context, the type argument list is given\n+after a `::` namespace qualifier in order to disambiguate it from a\n+relational expression involving the less-than symbol (`<`). In type\n+expression context, the final namespace qualifier is omitted.\n \n Two examples of paths with type arguments:\n \n@@ -493,8 +497,9 @@ names, and invoked through a consistent syntax: `some_extension!(...)`.\n \n Users of `rustc` can define new syntax extensions in two ways:\n \n-* [Compiler plugins][plugin] can include arbitrary\n-  Rust code that manipulates syntax trees at compile time.\n+* [Compiler plugins][plugin] can include arbitrary Rust code that\n+  manipulates syntax trees at compile time. Note that the interface\n+  for compiler plugins is considered highly unstable.\n \n * [Macros](book/macros.html) define new syntax in a higher-level,\n   declarative way.\n@@ -547,7 +552,7 @@ _name_ s that occur in its body. At the \"current layer\", they all must repeat\n the same number of times, so ` ( $( $i:ident ),* ; $( $j:ident ),* ) => ( $(\n ($i,$j) ),* )` is valid if given the argument `(a,b,c ; d,e,f)`, but not\n `(a,b,c ; d,e)`. The repetition walks through the choices at that layer in\n-lockstep, so the former input transcribes to `( (a,d), (b,e), (c,f) )`.\n+lockstep, so the former input transcribes to `(a,d), (b,e), (c,f)`.\n \n Nested repetitions are allowed.\n \n@@ -556,14 +561,18 @@ Nested repetitions are allowed.\n The parser used by the macro system is reasonably powerful, but the parsing of\n Rust syntax is restricted in two ways:\n \n-1. The parser will always parse as much as possible. If it attempts to match\n-   `$i:expr [ , ]` against `8 [ , ]`, it will attempt to parse `i` as an array\n-   index operation and fail. Adding a separator can solve this problem.\n+1. Macro definitions are required to include suitable separators after parsing\n+   expressions and other bits of the Rust grammar. This implies that\n+   a macro definition like `$i:expr [ , ]` is not legal, because `[` could be part\n+   of an expression. A macro definition like `$i:expr,` or `$i:expr;` would be legal,\n+   however, because `,` and `;` are legal separators. See [RFC 550] for more information.\n 2. The parser must have eliminated all ambiguity by the time it reaches a `$`\n    _name_ `:` _designator_. This requirement most often affects name-designator\n    pairs when they occur at the beginning of, or immediately after, a `$(...)*`;\n    requiring a distinctive token in front can solve the problem.\n \n+[RFC 550]: https://github.com/rust-lang/rfcs/blob/master/text/0550-macro-future-proofing.md\n+\n # Crates and source files\n \n Although Rust, like any other language, can be implemented by an interpreter as\n@@ -611,7 +620,7 @@ module needs its own source file: [module definitions](#modules) can be nested\n within one file.\n \n Each source file contains a sequence of zero or more `item` definitions, and\n-may optionally begin with any number of [attributes](#Items and attributes)\n+may optionally begin with any number of [attributes](#items-and-attributes)\n that apply to the containing module, most of which influence the behavior of\n the compiler. The anonymous crate module can have additional attributes that\n apply to the crate as a whole.\n@@ -653,9 +662,10 @@ There are several kinds of item:\n * [`use` declarations](#use-declarations)\n * [modules](#modules)\n * [functions](#functions)\n-* [type definitions](#type-definitions)\n+* [type definitions](grammar.html#type-definitions)\n * [structures](#structures)\n * [enumerations](#enumerations)\n+* [constant items](#constant-items)\n * [static items](#static-items)\n * [traits](#traits)\n * [implementations](#implementations)\n@@ -672,16 +682,17 @@ which sub-item declarations may appear.\n \n ### Type Parameters\n \n-All items except modules may be *parameterized* by type. Type parameters are\n-given as a comma-separated list of identifiers enclosed in angle brackets\n-(`<...>`), after the name of the item and before its definition. The type\n-parameters of an item are considered \"part of the name\", not part of the type\n-of the item. A referencing [path](#paths) must (in principle) provide type\n-arguments as a list of comma-separated types enclosed within angle brackets, in\n-order to refer to the type-parameterized item. In practice, the type-inference\n-system can usually infer such argument types from context. There are no\n-general type-parametric types, only type-parametric items. That is, Rust has\n-no notion of type abstraction: there are no first-class \"forall\" types.\n+All items except modules, constants and statics may be *parameterized* by type.\n+Type parameters are given as a comma-separated list of identifiers enclosed in\n+angle brackets (`<...>`), after the name of the item and before its definition.\n+The type parameters of an item are considered \"part of the name\", not part of\n+the type of the item. A referencing [path](#paths) must (in principle) provide\n+type arguments as a list of comma-separated types enclosed within angle\n+brackets, in order to refer to the type-parameterized item. In practice, the\n+type-inference system can usually infer such argument types from context. There\n+are no general type-parametric types, only type-parametric items. That is, Rust\n+has no notion of type abstraction: there are no higher-ranked (or \"forall\") types\n+abstracted over other types, though higher-ranked types do exist for lifetimes.\n \n ### Modules\n \n@@ -727,6 +738,7 @@ mod vec;\n \n mod thread {\n     // Load the `local_data` module from `thread/local_data.rs`\n+    // or `thread/local_data/mod.rs`.\n     mod local_data;\n }\n ```\n@@ -743,7 +755,7 @@ mod thread {\n }\n ```\n \n-##### Extern crate declarations\n+#### Extern crate declarations\n \n An _`extern crate` declaration_ specifies a dependency on an external crate.\n The external crate is then bound into the declaring scope as the `ident`\n@@ -767,12 +779,12 @@ extern crate std; // equivalent to: extern crate std as std;\n extern crate std as ruststd; // linking to 'std' under another name\n ```\n \n-##### Use declarations\n+#### Use declarations\n \n A _use declaration_ creates one or more local name bindings synonymous with\n some other [path](#paths). Usually a `use` declaration is used to shorten the\n path required to refer to a module item. These declarations may appear at the\n-top of [modules](#modules) and [blocks](#blocks).\n+top of [modules](#modules) and [blocks](grammar.html#block-expressions).\n \n > **Note**: Unlike in many languages,\n > `use` declarations in Rust do *not* declare linkage dependency with external crates.\n@@ -842,7 +854,7 @@ module declarations should be at the crate root if direct usage of the declared\n modules within `use` items is desired. It is also possible to use `self` and\n `super` at the beginning of a `use` item to refer to the current and direct\n parent modules respectively. All rules regarding accessing declared modules in\n-`use` declarations applies to both module declarations and `extern crate`\n+`use` declarations apply to both module declarations and `extern crate`\n declarations.\n \n An example of what will and will not work for `use` items:\n@@ -999,7 +1011,8 @@ the guarantee that these issues are never caused by safe code.\n * `&mut` and `&` follow LLVM\u2019s scoped [noalias] model, except if the `&T`\n   contains an `UnsafeCell<U>`. Unsafe code must not violate these aliasing\n   guarantees.\n-* Mutating an immutable value/reference without `UnsafeCell<U>`\n+* Mutating non-mutable data (that is, data reached through a shared reference or\n+  data owned by a `let` binding), unless that data is contained within an `UnsafeCell<U>`.\n * Invoking undefined behavior via compiler intrinsics:\n   * Indexing outside of the bounds of an object with `std::ptr::offset`\n     (`offset` intrinsic), with\n@@ -1029,9 +1042,13 @@ be undesired.\n * Exiting without calling destructors\n * Sending signals\n * Accessing/modifying the file system\n-* Unsigned integer overflow (well-defined as wrapping)\n-* Signed integer overflow (well-defined as two\u2019s complement representation\n-  wrapping)\n+* Integer overflow\n+  - Overflow is considered \"unexpected\" behavior and is always user-error,\n+    unless the `wrapping` primitives are used. In non-optimized builds, the compiler\n+    will insert debug checks that panic on overflow, but in optimized builds overflow\n+    instead results in wrapped values. See [RFC 560] for the rationale and more details.\n+\n+[RFC 560]: https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md\n \n #### Diverging functions\n \n@@ -1143,9 +1160,7 @@ let px: i32 = match p { Point(x, _) => x };\n ```\n \n A _unit-like struct_ is a structure without any fields, defined by leaving off\n-the list of fields entirely. Such types will have a single value, just like\n-the [unit value `()`](#unit-and-boolean-literals) of the unit type. For\n-example:\n+the list of fields entirely. Such types will have a single value. For example:\n \n ```\n struct Cookie;\n@@ -1307,11 +1322,26 @@ type of the value is not required to ascribe to `Sync`.\n \n ### Traits\n \n-A _trait_ describes a set of method types.\n+A _trait_ describes an abstract interface that types can\n+implement. This interface consists of associated items, which come in\n+three varieties:\n \n-Traits can include default implementations of methods, written in terms of some\n-unknown [`self` type](#self-types); the `self` type may either be completely\n-unspecified, or constrained by some other trait.\n+- functions\n+- constants\n+- types\n+\n+Associated functions whose first parameter is named `self` are called\n+methods and may be invoked using `.` notation (e.g., `x.foo()`).\n+\n+All traits define an implicit type parameter `Self` that refers to\n+\"the type that is implementing this interface\". Traits may also\n+contain additional type parameters. These type parameters (including\n+`Self`) may be constrained by other traits and so forth as usual.\n+\n+Trait bounds on `Self` are considered \"supertraits\". These are\n+required to be acyclic.  Supertraits are somewhat different from other\n+constraints in that they affect what methods are available in the\n+vtable when the trait is used as a [trait object](#trait-objects).\n \n Traits are implemented for specific types through separate\n [implementations](#implementations).\n@@ -1356,15 +1386,18 @@ fn draw_twice<T: Shape>(surface: Surface, sh: T) {\n }\n ```\n \n-Traits also define an [trait object](#trait-objects) with the same name as the\n-trait. Values of this type are created by [casting](#type-cast-expressions)\n-pointer values (pointing to a type for which an implementation of the given\n-trait is in scope) to pointers to the trait name, used as a type.\n+Traits also define an [trait object](#trait-objects) with the same\n+name as the trait. Values of this type are created by coercing from a\n+pointer of some specific type to a pointer of trait type. For example,\n+`&T` could be coerced to `&Shape` if `T: Shape` holds (and similarly\n+for `Box<T>`). This coercion can either be implicit or\n+[explicit](#type-cast-expressions). Here is an example of an explicit\n+coercion:\n \n ```\n-# trait Shape { fn dummy(&self) { } }\n-# impl Shape for i32 { }\n-# let mycircle = 0i32;\n+trait Shape { }\n+impl Shape for i32 { }\n+let mycircle = 0i32;\n let myshape: Box<Shape> = Box::new(mycircle) as Box<Shape>;\n ```\n \n@@ -2038,7 +2071,8 @@ The name `str_eq` has a special meaning to the Rust compiler, and the presence\n of this definition means that it will use this definition when generating calls\n to the string equality function.\n \n-A complete list of the built-in language items will be added in the future.\n+The set of language items is currently considered unstable. A complete\n+list of the built-in language items will be added in the future.\n \n ### Inline attributes\n \n@@ -2050,11 +2084,6 @@ The compiler automatically inlines functions based on internal heuristics.\n Incorrectly inlining functions can actually make the program slower, so it\n should be used with care.\n \n-Immutable statics are always considered inlineable unless marked with\n-`#[inline(never)]`. It is undefined whether two different inlineable statics\n-have the same memory address. In other words, the compiler is free to collapse\n-duplicate inlineable statics together.\n-\n `#[inline]` and `#[inline(always)]` always cause the function to be serialized\n into the crate metadata to allow cross-crate inlining.\n \n@@ -2256,10 +2285,6 @@ The currently implemented features of the reference compiler are:\n * `unboxed_closures` - Rust's new closure design, which is currently a work in\n                        progress feature with many known bugs.\n \n-* `unsafe_destructor` - Allows use of the `#[unsafe_destructor]` attribute,\n-                        which is considered wildly unsafe and will be\n-                        obsoleted by language improvements.\n-\n * `unsafe_no_drop_flag` - Allows use of the `#[unsafe_no_drop_flag]` attribute,\n                           which removes hidden flag added to a type that\n                           implements the `Drop` trait. The design for the\n@@ -2379,18 +2404,54 @@ expressions](#index-expressions) (`expr[expr]`), and [field\n references](#field-expressions) (`expr.f`). All other expressions are rvalues.\n \n The left operand of an [assignment](#assignment-expressions) or\n-[compound-assignment](#compound-assignment-expressions) expression is an lvalue\n-context, as is the single operand of a unary\n-[borrow](#unary-operator-expressions). All other expression contexts are\n-rvalue contexts.\n+[compound-assignment](#compound-assignment-expressions) expression is\n+an lvalue context, as is the single operand of a unary\n+[borrow](#unary-operator-expressions). The discriminant or subject of\n+a [match expression](#match-expressions) may be an lvalue context, if\n+ref bindings are made, but is otherwise an rvalue context. All other\n+expression contexts are rvalue contexts.\n \n When an lvalue is evaluated in an _lvalue context_, it denotes a memory\n location; when evaluated in an _rvalue context_, it denotes the value held _in_\n that memory location.\n \n-When an rvalue is used in an lvalue context, a temporary un-named lvalue is\n-created and used instead. A temporary's lifetime equals the largest lifetime\n-of any reference that points to it.\n+##### Temporary lifetimes\n+\n+When an rvalue is used in an lvalue context, a temporary un-named\n+lvalue is created and used instead. The lifetime of temporary values\n+is typically the innermost enclosing statement; the tail expression of\n+a block is considered part of the statement that encloses the block.\n+\n+When a temporary rvalue is being created that is assigned into a `let`\n+declaration, however, the temporary is created with the lifetime of\n+the enclosing block instead, as using the enclosing statement (the\n+`let` declaration) would be a guaranteed error (since a pointer to the\n+temporary would be stored into a variable, but the temporary would be\n+freed before the variable could be used). The compiler uses simple\n+syntactic rules to decide which values are being assigned into a `let`\n+binding, and therefore deserve a longer temporary lifetime.\n+\n+Here are some examples:\n+\n+- `let x = foo(&temp())`. The expression `temp()` is an rvalue. As it\n+  is being borrowed, a temporary is created which will be freed after\n+  the innermost enclosing statement (the `let` declaration, in this case).\n+- `let x = temp().foo()`. This is the same as the previous example,\n+  except that the value of `temp()` is being borrowed via autoref on a\n+  method-call. Here we are assuming that `foo()` is an `&self` method\n+  defined in some trait, say `Foo`. In other words, the expression\n+  `temp().foo()` is equivalent to `Foo::foo(&temp())`.\n+- `let x = &temp()`. Here, the same temporary is being assigned into\n+  `x`, rather than being passed as a parameter, and hence the\n+  temporary's lifetime is considered to be the enclosing block.\n+- `let x = SomeStruct { foo: &temp() }`. As in the previous case, the\n+  temporary is assigned into a struct which is then assigned into a\n+  binding, and hence it is given the lifetime of the enclosing block.\n+- `let x = [ &temp() ]`. As in the previous case, the\n+  temporary is assigned into an array which is then assigned into a\n+  binding, and hence it is given the lifetime of the enclosing block.\n+- `let ref x = temp()`. In this case, the temporary is created using a ref binding,\n+  but the result is the same: the lifetime is extended to the enclosing block.\n \n #### Moved and copied types\n \n@@ -2435,11 +2496,6 @@ comma:\n (0); // zero in parentheses\n ```\n \n-### Unit expressions\n-\n-The expression `()` denotes the _unit value_, the only value of the type with\n-the same name.\n-\n ### Structure expressions\n \n There are several forms of structure expressions. A _structure expression_\n@@ -2537,8 +2593,10 @@ A field access is an [lvalue](#lvalues,-rvalues-and-temporaries) referring to\n the value of that field. When the type providing the field inherits mutability,\n it can be [assigned](#assignment-expressions) to.\n \n-Also, if the type of the expression to the left of the dot is a pointer, it is\n-automatically dereferenced to make the field access possible.\n+Also, if the type of the expression to the left of the dot is a\n+pointer, it is automatically dereferenced as many times as necessary\n+to make the field access possible. In cases of ambiguity, we prefer\n+fewer autoderefs to more.\n \n ### Array expressions\n \n@@ -2564,14 +2622,26 @@ array is mutable, the resulting [lvalue](#lvalues,-rvalues-and-temporaries) can\n be assigned to.\n \n Indices are zero-based, and may be of any integral type. Vector access is\n-bounds-checked at run-time. When the check fails, it will put the thread in a\n-_panicked state_.\n+bounds-checked at compile-time for constant arrays being accessed with a constant index value.\n+Otherwise a check will be performed at run-time that will put the thread in a _panicked state_ if it fails.\n \n ```{should-fail}\n ([1, 2, 3, 4])[0];\n-([\"a\", \"b\"])[10]; // panics\n+\n+let x = ([\"a\", \"b\"])[10]; // compiler error: const index-expr is out of bounds\n+\n+let n = 10;\n+let y = ([\"a\", \"b\"])[n]; // panics\n+\n+let arr = [\"a\", \"b\"];\n+arr[10]; // panics\n ```\n \n+Also, if the type of the expression to the left of the brackets is a\n+pointer, it is automatically dereferenced as many times as necessary\n+to make the indexing possible. In cases of ambiguity, we prefer fewer\n+autoderefs to more.\n+\n ### Range expressions\n \n The `..` operator will construct an object of one of the `std::ops::Range` variants.\n@@ -2594,7 +2664,7 @@ assert_eq!(x,y);\n \n ### Unary operator expressions\n \n-Rust defines three unary operators. They are all written as prefix operators,\n+Rust defines the following unary operators. They are all written as prefix operators,\n before the expression they apply to.\n \n * `-`\n@@ -2608,11 +2678,20 @@ before the expression they apply to.\n     implemented by the type and required for an outer expression that will or\n     could mutate the dereference), and produces the result of dereferencing the\n     `&` or `&mut` borrowed pointer returned from the overload method.\n-\n * `!`\n   : Logical negation. On the boolean type, this flips between `true` and\n     `false`. On integer types, this inverts the individual bits in the\n     two's complement representation of the value.\n+* `&` and `&mut`\n+  : Borrowing. When applied to an lvalue, these operators produce a\n+    reference (pointer) to the lvalue. The lvalue is also placed into\n+    a borrowed state for the duration of the reference. For a shared\n+    borrow (`&`), this implies that the lvalue may not be mutated, but\n+    it may be read or shared again. For a mutable borrow (`&mut`), the\n+    lvalue may not be accessed in any way until the borrow expires.\n+    If the `&` or `&mut` operators are applied to an rvalue, a\n+    temporary value is created; the lifetime of this temporary value\n+    is defined by [syntactic rules](#temporary-lifetimes).\n \n ### Binary operator expressions\n \n@@ -2722,6 +2801,13 @@ fn avg(v: &[f64]) -> f64 {\n }\n ```\n \n+Some of the conversions which can be done through the `as` operator\n+can also be done implicitly at various points in the program, such as\n+argument passing and assignment to a `let` binding with an explicit\n+type. Implicit conversions are limited to \"harmless\" conversions that\n+do not lose information and which have minimal or no risk of\n+surprising side-effects on the dynamic execution semantics.\n+\n #### Assignment expressions\n \n An _assignment expression_ consists of an\n@@ -3064,6 +3150,20 @@ of a condition expression it expects a refutable let statement. If the value of\n expression on the right hand side of the let statement matches the pattern, the corresponding\n block will execute, otherwise flow proceeds to the first `else` block that follows.\n \n+```\n+let dish = (\"Ham\", \"Eggs\");\n+\n+// this body will be skipped because the pattern is refuted\n+if let (\"Bacon\", b) = dish {\n+    println!(\"Bacon is served with {}\", b);\n+}\n+\n+// this body will execute\n+if let (\"Ham\", b) = dish {\n+    println!(\"Ham is served with {}\", b);\n+}\n+```\n+\n ### While let loops\n \n A `while let` loop is semantically identical to a `while` loop but in place of a\n@@ -3259,7 +3359,7 @@ constructor or `struct` field may refer, directly or indirectly, to the\n enclosing `enum` or `struct` type itself. Such recursion has restrictions:\n \n * Recursive types must include a nominal type in the recursion\n-  (not mere [type definitions](#type-definitions),\n+  (not mere [type definitions](grammar.html#type-definitions),\n    or other structural types such as [arrays](#array,-and-slice-types) or [tuples](#tuple-types)).\n * A recursive `enum` item must have at least one non-recursive constructor\n   (in order to give the recursion a basis case).\n@@ -3329,6 +3429,22 @@ let bo: Binop = add;\n x = bo(5,7);\n ```\n \n+#### Function types for specific items\n+\n+Internally to the compiler, there are also function types that are specific to a particular\n+function item. In the following snippet, for example, the internal types of the functions\n+`foo` and `bar` are different, despite the fact that they have the same signature:\n+\n+```\n+fn foo() { }\n+fn bar() { }\n+```\n+\n+The types of `foo` and `bar` can both be implicitly coerced to the fn\n+pointer type `fn()`. There is currently no syntax for unique fn types,\n+though the compiler will emit a type like `fn() {foo}` in error\n+messages to indicate \"the unique fn type for the function `foo`\".\n+\n ### Closure types\n \n A [lambda expression](#lambda-expressions) produces a closure value with\n@@ -3413,8 +3529,9 @@ has type `Vec<A>`, a vector with element type `A`.\n \n ### Self types\n \n-The special type `self` has a meaning within methods inside an impl item. It\n-refers to the type of the implicit `self` argument. For example, in:\n+The special type `Self` has a meaning within traits and impls. In a trait definition, it refers\n+to an implicit type parameter representing the \"implementing\" type. In an impl,\n+it is an alias for the implementing type. For example, in:\n \n ```\n trait Printable {\n@@ -3428,8 +3545,9 @@ impl Printable for String {\n }\n ```\n \n-`self` refers to the value of type `String` that is the receiver for a call to\n-the method `make_string`.\n+The notation `&self` is a shorthand for `self: &Self`. In this case,\n+in the impl, `Self` refers to the value of type `String` that is the\n+receiver for a call to the method `make_string`.\n \n # Special traits\n "}, {"sha": "3f97928a56e3f067af823d1939ea8d85cf779aef", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -15,6 +15,7 @@\n     * [Concurrency](concurrency.md)\n     * [Error Handling](error-handling.md)\n     * [FFI](ffi.md)\n+    * [Borrow and AsRef](borrow-and-asref.md)\n * [Syntax and Semantics](syntax-and-semantics.md)\n     * [Variable Bindings](variable-bindings.md)\n     * [Functions](functions.md)"}, {"sha": "f5f314f1c21d6ee9d3bc719134a7ad013b23698f", "filename": "src/doc/trpl/borrow-and-asref.md", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fborrow-and-asref.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fborrow-and-asref.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fborrow-and-asref.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -0,0 +1,93 @@\n+% Borrow and AsRef\n+\n+The [`Borrow`][borrow] and [`AsRef`][asref] traits are very similar, but\n+different. Here\u2019s a quick refresher on what these two traits mean.\n+\n+[borrow]: ../std/borrow/trait.Borrow.html\n+[asref]: ../std/convert/trait.AsRef.html\n+\n+# Borrow\n+\n+The `Borrow` trait is used when you\u2019re writing a datastructure, and you want to\n+use either an owned or borrowed type as synonymous for some purpose.\n+\n+For example, [`HashMap`][hashmap] has a [`get` method][get] which uses `Borrow`:\n+\n+```rust,ignore\n+fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n+    where K: Borrow<Q>,\n+          Q: Hash + Eq\n+```\n+\n+[hashmap]: ../std/collections/struct.HashMap.html\n+[get]: ../std/collections/struct.HashMap.html#method.get\n+\n+This signature is pretty complicated. The `K` parameter is what we\u2019re interested\n+in here. It refers to a parameter of the `HashMap` itself:\n+\n+```rust,ignore\n+struct HashMap<K, V, S = RandomState> {\n+```\n+\n+The `K` parameter is the type of _key_ the `HashMap` uses. So, looking at\n+the signature of `get()` again, we can use `get()` when the key implements\n+`Borrow<Q>`. That way, we can make a `HashMap` which uses `String` keys,\n+but use `&str`s when we\u2019re searching:\n+\n+```rust\n+use std::collections::HashMap;\n+\n+let mut map = HashMap::new();\n+map.insert(\"Foo\".to_string(), 42);\n+\n+assert_eq!(map.get(\"Foo\"), Some(&42));\n+```\n+\n+This is because the standard library has `impl Borrow<str> for String`.\n+\n+For most types, when you want to take an owned or borrowed type, a `&T` is\n+enough. But one area where `Borrow` is effective is when there\u2019s more than one\n+kind of borrowed value. Slices are an area where this is especially true: you\n+can have both an `&[T]` or a `&mut [T]`. If we wanted to accept both of these\n+types, `Borrow` is up for it:\n+\n+```\n+use std::borrow::Borrow;\n+use std::fmt::Display;\n+\n+fn foo<T: Borrow<i32> + Display>(a: T) {\n+    println!(\"a is borrowed: {}\", a);\n+}\n+\n+let mut i = 5;\n+\n+foo(&i);\n+foo(&mut i);\n+```\n+\n+This will print out `a is borrowed: 5` twice.\n+\n+# AsRef\n+\n+The `AsRef` trait is a conversion trait. It\u2019s used for converting some value to\n+a reference in generic code. Like this:\n+\n+```rust\n+let s = \"Hello\".to_string();\n+\n+fn foo<T: AsRef<str>>(s: T) {\n+    let slice = s.as_ref();\n+}\n+```\n+\n+# Which should I use?\n+\n+We can see how they\u2019re kind of the same: they both deal with owned and borrowed\n+versions of some type. However, they\u2019re a bit different.\n+\n+Choose `Borrow` when you want to abstract over different kinds of borrowing, or\n+when you\u2019re building a datastructure that treats owned and borrowed values in\n+equivalent ways, such as hashing and comparison.\n+\n+Choose `AsRef` when you want to convert something to a reference directly, and\n+you\u2019re writing generic code."}, {"sha": "127e097c34f7db03ef946a34e4fd8f168821ca31", "filename": "src/doc/trpl/compiler-plugins.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fcompiler-plugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fcompiler-plugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompiler-plugins.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -176,7 +176,7 @@ for a full example, the core of which is reproduced here:\n \n ```ignore\n declare_lint!(TEST_LINT, Warn,\n-              \"Warn about items named 'lintme'\")\n+              \"Warn about items named 'lintme'\");\n \n struct Pass;\n "}, {"sha": "e5702ed163542f8aa7fcdbd850c2599d02064e36", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -273,7 +273,7 @@ information\u2019. Why throw it away? Well, for a basic program, we just want to\n print a generic error, as basically any issue means we can\u2019t continue. The\n [`ok()` method][ok] returns a value which has another method defined on it:\n `expect()`. The [`expect()` method][expect] takes a value it\u2019s called on, and\n-if it isn\u2019t a successful one, [`panic!`][panic]s with a message you passed you\n+if it isn\u2019t a successful one, [`panic!`][panic]s with a message you\n passed it. A `panic!` like this will cause our program to crash, displaying\n the message.\n \n@@ -713,7 +713,7 @@ variety of numbers, we need to give Rust a hint as to the exact type of number\n we want. Hence, `let guess: u32`. The colon (`:`) after `guess` tells Rust\n we\u2019re going to annotate its type. `u32` is an unsigned, thirty-two bit\n integer. Rust has [a number of built-in number types][number], but we\u2019ve\n-chosen `u32`. It\u2019s a good default choice for a small positive numer.\n+chosen `u32`. It\u2019s a good default choice for a small positive number.\n \n [parse]: ../std/primitive.str.html#method.parse\n [number]: primitive-types.html#numeric-types\n@@ -922,7 +922,7 @@ failure. Each contains more information: the successful parsed integer, or an\n error type. In this case, we `match` on `Ok(num)`, which sets the inner value\n of the `Ok` to the name `num`, and then we just return it on the right-hand\n side. In the `Err` case, we don\u2019t care what kind of error it is, so we just\n-use `_` intead of a name. This ignores the error, and `continue` causes us\n+use `_` instead of a name. This ignores the error, and `continue` causes us\n to go to the next iteration of the `loop`.\n \n Now we should be good! Let\u2019s try:"}, {"sha": "25d5122b4e49e31d167f8dde9b7340c05952fa58", "filename": "src/doc/trpl/lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flifetimes.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -5,7 +5,7 @@ Rust\u2019s most unique and compelling features, with which Rust developers should\n become quite acquainted. Ownership is how Rust achieves its largest goal,\n memory safety. There are a few distinct concepts, each with its own chapter:\n \n-* [ownership][ownership], ownership, the key concept\n+* [ownership][ownership], the key concept\n * [borrowing][borrowing], and their associated feature \u2018references\u2019\n * lifetimes, which you\u2019re reading now\n "}, {"sha": "86b94453389667b35da4431d7d53504d5ab4fcbb", "filename": "src/doc/trpl/match.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmatch.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -50,7 +50,7 @@ side of a `let` binding or directly where an expression is used:\n ```rust\n let x = 5;\n \n-let numer = match x {\n+let number = match x {\n     1 => \"one\",\n     2 => \"two\",\n     3 => \"three\","}, {"sha": "1527d9cf978df96af30197592a36ab15f1cd015a", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -127,12 +127,12 @@ fn grow(&self) -> Circle {\n We just say we\u2019re returning a `Circle`. With this method, we can grow a new\n circle to any arbitrary size.\n \n-# Static methods\n+# Associated functions\n \n-You can also define static methods that do not take a `self` parameter. Here\u2019s a\n-pattern that\u2019s very common in Rust code:\n+You can also define associated functions that do not take a `self` parameter.\n+Here\u2019s a pattern that\u2019s very common in Rust code:\n \n-```\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,"}, {"sha": "674d65974494ee14ba3d4105bc781070184fc3df", "filename": "src/doc/trpl/mutability.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fmutability.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fmutability.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmutability.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -78,8 +78,8 @@ When we call `clone()`, the `Arc<T>` needs to update the reference count. Yet\n we\u2019ve not used any `mut`s here, `x` is an immutable binding, and we didn\u2019t take\n `&mut 5` or anything. So what gives?\n \n-To this, we have to go back to the core of Rust\u2019s guiding philosophy, memory\n-safety, and the mechanism by which Rust guarantees it, the\n+To understand this, we have to go back to the core of Rust\u2019s guiding\n+philosophy, memory safety, and the mechanism by which Rust guarantees it, the\n [ownership][ownership] system, and more specifically, [borrowing][borrowing]:\n \n > You may have one or the other of these two kinds of borrows, but not both at\n@@ -169,7 +169,7 @@ struct Point {\n     y: Cell<i32>,\n }\n \n-let mut point = Point { x: 5, y: Cell::new(6) };\n+let point = Point { x: 5, y: Cell::new(6) };\n \n point.y.set(7);\n "}, {"sha": "b210f1c643f438dce8edd6c65c16aada12803186", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -6,7 +6,7 @@ become quite acquainted. Ownership is how Rust achieves its largest goal,\n memory safety. There are a few distinct concepts, each with its own\n chapter:\n \n-* ownership, which you\u2019re reading now.\n+* ownership, which you\u2019re reading now\n * [borrowing][borrowing], and their associated feature \u2018references\u2019\n * [lifetimes][lifetimes], an advanced concept of borrowing\n \n@@ -23,7 +23,7 @@ Before we get to the details, two important notes about the ownership system.\n Rust has a focus on safety and speed. It accomplishes these goals through many\n \u2018zero-cost abstractions\u2019, which means that in Rust, abstractions cost as little\n as possible in order to make them work. The ownership system is a prime example\n-of a zero cost abstraction. All of the analysis we\u2019ll talk about in this guide\n+of a zero-cost abstraction. All of the analysis we\u2019ll talk about in this guide\n is _done at compile time_. You do not pay any run-time cost for any of these\n features.\n \n@@ -41,7 +41,7 @@ With that in mind, let\u2019s learn about ownership.\n \n # Ownership\n \n-[`Variable bindings`][bindings] have a property in Rust: they \u2018have ownership\u2019\n+[Variable bindings][bindings] have a property in Rust: they \u2018have ownership\u2019\n of what they\u2019re bound to. This means that when a binding goes out of scope, the\n resource that they\u2019re bound to are freed. For example:\n \n@@ -106,8 +106,8 @@ take(v);\n println!(\"v[0] is: {}\", v[0]);\n ```\n \n-Same error: \u201cuse of moved value.\u201d When we transfer ownership to something else,\n-we say that we\u2019ve \u2018moved\u2019 the thing we refer to. You don\u2019t need some sort of\n+Same error: \u2018use of moved value\u2019. When we transfer ownership to something else,\n+we say that we\u2019ve \u2018moved\u2019 the thing we refer to. You don\u2019t need any sort of\n special annotation here, it\u2019s the default thing that Rust does.\n \n ## The details\n@@ -121,19 +121,19 @@ let v = vec![1, 2, 3];\n let v2 = v;\n ```\n \n-The first line creates some data for the vector on the [stack][sh], `v`. The\n-vector\u2019s data, however, is stored on the [heap][sh], and so it contains a\n-pointer to that data. When we move `v` to `v2`, it creates a copy of that pointer,\n-for `v2`. Which would mean two pointers to the contents of the vector on the\n-heap. That would be a problem: it would violate Rust\u2019s safety guarantees by\n-introducing a data race. Therefore, Rust forbids using `v` after we\u2019ve done the\n-move.\n+The first line allocates memory for the vector object, `v`, and for the data it\n+contains. The vector object is stored on the [stack][sh] and contains a pointer\n+to the content (`[1, 2, 3]`) stored on the [heap][sh]. When we move `v` to `v2`,\n+it creates a copy of that pointer, for `v2`. Which means that there would be two\n+pointers to the content of the vector on the heap. It would violate Rust\u2019s\n+safety guarantees by introducing a data race. Therefore, Rust forbids using `v`\n+after we\u2019ve done the move.\n \n [sh]: the-stack-and-the-heap.html\n \n It\u2019s also important to note that optimizations may remove the actual copy of\n-the bytes, depending on circumstances. So it may not be as inefficient as it\n-initially seems.\n+the bytes on the stack, depending on circumstances. So it may not be as\n+inefficient as it initially seems.\n \n ## `Copy` types\n \n@@ -174,7 +174,7 @@ fn foo(v: Vec<i32>) -> Vec<i32> {\n }\n ```\n \n-This would get very tedius. It gets worse the more things we want to take ownership of:\n+This would get very tedious. It gets worse the more things we want to take ownership of:\n \n ```rust\n fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {"}, {"sha": "22483816769c3a47b67b98144917f12ac396b336", "filename": "src/doc/trpl/primitive-types.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fprimitive-types.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -15,7 +15,7 @@ let x = true;\n let y: bool = false;\n ```\n \n-A common use of booleans is in [`if` statements][if].\n+A common use of booleans is in [`if` conditionals][if].\n \n [if]: if.html\n \n@@ -176,7 +176,7 @@ Slices have type `&[T]`. We\u2019ll talk about that `T` when we cover\n \n [generics]: generics.html\n \n-You can find more documentation for `slices`s [in the standard library\n+You can find more documentation for slices [in the standard library\n documentation][slice].\n \n [slice]: ../std/primitive.slice.html"}, {"sha": "c434371ce59d319ed4044c15d80440b204fabb35", "filename": "src/doc/trpl/references-and-borrowing.md", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -6,7 +6,7 @@ become quite acquainted. Ownership is how Rust achieves its largest goal,\n memory safety. There are a few distinct concepts, each with its own\n chapter:\n \n-* [ownership][ownership], ownership, the key concept\n+* [ownership][ownership], the key concept\n * borrowing, which you\u2019re reading now\n * [lifetimes][lifetimes], an advanced concept of borrowing\n \n@@ -312,6 +312,7 @@ println!(\"{}\", y);\n \n We get this error:\n \n+```text\n error: `x` does not live long enough\n     y = &x;\n          ^\n@@ -334,3 +335,37 @@ In other words, `y` is only valid for the scope where `x` exists. As soon as\n `x` goes away, it becomes invalid to refer to it. As such, the error says that\n the borrow \u2018doesn\u2019t live long enough\u2019 because it\u2019s not valid for the right\n amount of time.\n+\n+The same problem occurs when the reference is declared _before_ the variable it refers to:\n+\n+```rust,ignore\n+let y: &i32;\n+let x = 5;\n+y = &x;\n+\n+println!(\"{}\", y);\n+```\n+\n+We get this error:\n+\n+```text\n+error: `x` does not live long enough\n+y = &x;\n+     ^\n+note: reference must be valid for the block suffix following statement 0 at\n+2:16...\n+    let y: &i32;\n+    let x = 5;\n+    y = &x;\n+    \n+    println!(\"{}\", y);\n+}\n+\n+note: ...but borrowed value is only valid for the block suffix following\n+statement 1 at 3:14\n+    let x = 5;\n+    y = &x;\n+    \n+    println!(\"{}\", y);\n+}\n+```"}, {"sha": "7b1cd7dc8093b3646730023c36a5a12c5e1570c5", "filename": "src/doc/trpl/the-stack-and-the-heap.md", "status": "modified", "additions": 568, "deletions": 1, "changes": 569, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -1,3 +1,570 @@\n % The Stack and the Heap\n \n-Coming Soon\n+As a systems language, Rust operates at a low level. If you\u2019re coming from a\n+high-level language, there are some aspects of systems programming that you may\n+not be familiar with. The most important one is how memory works, with a stack\n+and a heap. If you\u2019re familiar with how C-like languages use stack allocation,\n+this chapter will be a refresher. If you\u2019re not, you\u2019ll learn about this more\n+general concept, but with a Rust-y focus.\n+\n+# Memory management\n+\n+These two terms are about memory management. The stack and the heap are\n+abstractions that help you determine when to allocate and deallocate memory.\n+\n+Here\u2019s a high-level comparison:\n+\n+The stack is very fast, and is where memory is allocated in Rust by default.\n+But the allocation is local to a function call, and is limited in size. The\n+heap, on the other hand, is slower, and is explicitly allocated by your\n+program. But it\u2019s effectively unlimited in size, and is globally accessible.\n+\n+# The Stack\n+\n+Let\u2019s talk about this Rust program:\n+\n+```rust\n+fn main() {\n+    let x = 42;\n+}\n+```\n+\n+This program has one variable binding, `x`. This memory needs to be allocated\n+from somewhere. Rust \u2018stack allocates\u2019 by default, which means that basic\n+values \u2018go on the stack\u2019. What does that mean?\n+\n+Well, when a function gets called, some memory gets allocated for all of its\n+local variables and some other information. This is called a \u2018stack frame\u2019, and\n+for the purpose of this tutorial, we\u2019re going to ignore the extra information\n+and just consider the local variables we\u2019re allocating. So in this case, when\n+`main()` is run, we\u2019ll allocate a single 32-bit integer for our stack frame.\n+This is automatically handled for you, as you can see, we didn\u2019t have to write\n+any special Rust code or anything.\n+\n+When the function is over, its stack frame gets deallocated. This happens\n+automatically, we didn\u2019t have to do anything special here.\n+\n+That\u2019s all there is for this simple program. The key thing to understand here\n+is that stack allocation is very, very fast. Since we know all the local\n+variables we have ahead of time, we can grab the memory all at once. And since\n+we\u2019ll throw them all away at the same time as well, we can get rid of it very\n+fast too.\n+\n+The downside is that we can\u2019t keep values around if we need them for longer\n+than a single function. We also haven\u2019t talked about what that name, \u2018stack\u2019\n+means. To do that, we need a slightly more complicated example:\n+\n+```rust\n+fn foo() {\n+    let y = 5;\n+    let z = 100;\n+}\n+\n+fn main() {\n+    let x = 42;\n+\n+    foo();\n+}\n+```\n+\n+This program has three variables total: two in `foo()`, one in `main()`. Just\n+as before, when `main()` is called, a single integer is allocated for its stack\n+frame. But before we can show what happens when `foo()` is called, we need to\n+visualize what\u2019s going on with memory. Your operating system presents a view of\n+memory to your program that\u2019s pretty simple: a huge list of addresses, from 0\n+to a large number, representing how much RAM your computer has. For example, if\n+you have a gigabyte of RAM, your addresses go from `0` to `1,073,741,824`. That\n+number comes from 2<sup>30</sup>, the number of bytes in a gigabyte.\n+\n+This memory is kind of like a giant array: addresses start at zero and go\n+up to the final number. So here\u2019s a diagram of our first stack frame:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 0       | x    | 42    |\n+\n+We\u2019ve got `x` located at address `0`, with the value `42`.\n+\n+When `foo()` is called, a new stack frame is allocated:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 2       | z    | 100   |\n+| 1       | y    | 5     |\n+| 0       | x    | 42    |\n+\n+Because `0` was taken by the first frame, `1` and `2` are used for `foo()`\u2019s\n+stack frame. It grows upward, the more functions we call.\n+\n+\n+There\u2019s some important things we have to take note of here. The numbers 0, 1,\n+and 2 are all solely for illustrative purposes, and bear no relationship to the\n+actual numbers the computer will actually use. In particular, the series of\n+addresses are in reality going to be separated by some number of bytes that\n+separate each address, and that separation may even exceed the size of the\n+value being stored.\n+\n+After `foo()` is over, its frame is deallocated:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 0       | x    | 42    |\n+\n+And then, after `main()`, even this last value goes away. Easy!\n+\n+It\u2019s called a \u2018stack\u2019 because it works like a stack of dinner plates: the first\n+plate you put down is the last plate to pick back up. Stacks are sometimes\n+called \u2018last in, first out queues\u2019 for this reason, as the last value you put\n+on the stack is the first one you retrieve from it.\n+\n+Let\u2019s try a three-deep example:\n+\n+```rust\n+fn bar() {\n+    let i = 6;\n+}\n+\n+fn foo() {\n+    let a = 5;\n+    let b = 100;\n+    let c = 1;\n+\n+    bar();\n+}\n+\n+fn main() {\n+    let x = 42;\n+\n+    foo();\n+}\n+```\n+\n+Okay, first, we call `main()`:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 0       | x    | 42    |\n+\n+Next up, `main()` calls `foo()`:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 3       | c    | 1     |\n+| 2       | b    | 100   |\n+| 1       | a    | 5     |\n+| 0       | x    | 42    |\n+\n+And then `foo()` calls `bar()`:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 4       | i    | 6     |\n+| 3       | c    | 1     |\n+| 2       | b    | 100   |\n+| 1       | a    | 5     |\n+| 0       | x    | 42    |\n+\n+Whew! Our stack is growing tall.\n+\n+After `bar()` is over, its frame is deallocated, leaving just `foo()` and\n+`main()`:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 3       | c    | 1     |\n+| 2       | b    | 100   |\n+| 1       | a    | 5     |\n+| 0       | x    | 42    |\n+\n+And then `foo()` ends, leaving just `main()`\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 0       | x    | 42    |\n+\n+And then we\u2019re done. Getting the hang of it? It\u2019s like piling up dishes: you\n+add to the top, you take away from the top.\n+\n+# The Heap\n+\n+Now, this works pretty well, but not everything can work like this. Sometimes,\n+you need to pass some memory between different functions, or keep it alive for\n+longer than a single function\u2019s execution. For this, we can use the heap.\n+\n+In Rust, you can allocate memory on the heap with the [`Box<T>` type][box].\n+Here\u2019s an example:\n+\n+```rust\n+fn main() {\n+    let x = Box::new(5);\n+    let y = 42;\n+}\n+```\n+\n+[box]: ../std/boxed/index.html\n+\n+Here\u2019s what happens in memory when `main()` is called:\n+\n+| Address | Name | Value  |\n++---------+------+--------+\n+| 1       | y    | 42     |\n+| 0       | x    | ?????? |\n+\n+We allocate space for two variables on the stack. `y` is `42`, as it always has\n+been, but what about `x`? Well, `x` is a `Box<i32>`, and boxes allocate memory\n+on the heap. The actual value of the box is a structure which has a pointer to\n+\u2018the heap\u2019. When we start executing the function, and `Box::new()` is called,\n+it allocates some memory for the heap, and puts `5` there. The memory now looks\n+like this:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 5              |\n+| ...             | ...  | ...            |\n+| 1               | y    | 42             |\n+| 0               | x    | 2<sup>30</sup> |\n+\n+We have 2<sup>30</sup> in our hypothetical computer with 1GB of RAM. And since\n+our stack grows from zero, the easiest place to allocate memory is from the\n+other end. So our first value is at the highest place in memory. And the value\n+of the struct at `x` has a [raw pointer][rawpointer] to the place we\u2019ve\n+allocated on the heap, so the value of `x` is 2<sup>30</sup>, the memory\n+location we\u2019ve asked for.\n+\n+[rawpointer]: raw-pointers.html\n+\n+We haven\u2019t really talked too much about what it actually means to allocate and\n+deallocate memory in these contexts. Getting into very deep detail is out of\n+the scope of this tutorial, but what\u2019s important to point out here is that\n+the heap isn\u2019t just a stack that grows from the opposite end. We\u2019ll have an\n+example of this later in the book, but because the heap can be allocated and\n+freed in any order, it can end up with \u2018holes\u2019. Here\u2019s a diagram of the memory\n+layout of a program which has been running for a while now:\n+\n+\n+| Address              | Name | Value                |\n++----------------------+------+----------------------+\n+| 2<sup>30</sup>       |      | 5                    |\n+| (2<sup>30</sup>) - 1 |      |                      |\n+| (2<sup>30</sup>) - 2 |      |                      |\n+| (2<sup>30</sup>) - 3 |      | 42                   |\n+| ...                  | ...  | ...                  |\n+| 3                    | y    | (2<sup>30</sup>) - 3 |\n+| 2                    | y    | 42                   |\n+| 1                    | y    | 42                   |\n+| 0                    | x    | 2<sup>30</sup>       |\n+\n+In this case, we\u2019ve allocated four things on the heap, but deallocated two of\n+them. There\u2019s a gap between 2<sup>30</sup> and (2<sup>30</sup>) - 3 which isn\u2019t\n+currently being used. The specific details of how and why this happens depends\n+on what kind of strategy you use to manage the heap. Different programs can use\n+different \u2018memory allocators\u2019, which are libraries that manage this for you.\n+Rust programs use [jemalloc][jemalloc] for this purpose.\n+\n+[jemalloc]: http://www.canonware.com/jemalloc/\n+\n+Anyway, back to our example. Since this memory is on the heap, it can stay\n+alive longer than the function which allocates the box. In this case, however,\n+it doesn\u2019t.[^moving] When the function is over, we need to free the stack frame\n+for `main()`. `Box<T>`, though, has a trick up its sleve: [Drop][drop]. The\n+implementation of `Drop` for `Box` deallocates the memory that was allocated\n+when it was created. Great! So when `x` goes away, it first frees the memory\n+allocated on the heap:\n+\n+| Address | Name | Value  |\n++---------+------+--------+\n+| 1       | y    | 42     |\n+| 0       | x    | ?????? |\n+\n+[drop]: drop.html\n+[moving]: We can make the memory live longer by transferring ownership,\n+          sometimes called \u2018moving out of the box\u2019. More complex examples will\n+          be covered later.\n+\n+\n+And then the stack frame goes away, freeing all of our memory.\n+\n+# Arguments and borrowing\n+\n+We\u2019ve got some basic examples with the stack and the heap going, but what about\n+function arguments and borrowing? Here\u2019s a small Rust program:\n+\n+```rust\n+fn foo(i: &i32) {\n+    let z = 42;\n+}\n+\n+fn main() {\n+    let x = 5;\n+    let y = &x;\n+\n+    foo(y);\n+}\n+```\n+\n+When we enter `main()`, memory looks like this:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 1       | y    | 0     |\n+| 0       | x    | 5     |\n+\n+`x` is a plain old `5`, and `y` is a reference to `x`. So its value is the\n+memory location that `x` lives at, which in this case is `0`.\n+\n+What about when we call `foo()`, passing `y` as an argument?\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 3       | z    | 42    |\n+| 2       | i    | 0     |\n+| 1       | y    | 0     |\n+| 0       | x    | 5     |\n+\n+Stack frames aren\u2019t just for local bindings, they\u2019re for arguments too. So in\n+this case, we need to have both `i`, our argument, and `z`, our local variable\n+binding. `i` is a copy of the argument, `y`. Since `y`\u2019s value is `0`, so is\n+`i`\u2019s.\n+\n+This is one reason why borrowing a variable doesn\u2019t deallocate any memory: the\n+value of a reference is just a pointer to a memory location. If we got rid of\n+the underlying memory, things wouldn\u2019t work very well.\n+\n+# A complex example\n+\n+Okay, let\u2019s go through this complex program step-by-step:\n+\n+```rust\n+fn foo(x: &i32) {\n+    let y = 10;\n+    let z = &y;\n+\n+    baz(z);\n+    bar(x, z);\n+}\n+\n+fn bar(a: &i32, b: &i32) {\n+    let c = 5;\n+    let d = Box::new(5);\n+    let e = &d;\n+\n+    baz(e);\n+}\n+\n+fn baz(f: &i32) {\n+    let g = 100;\n+}\n+\n+fn main() {\n+    let h = 3;\n+    let i = Box::new(20);\n+    let j = &h;\n+\n+    foo(j);\n+}\n+```\n+\n+First, we call `main()`:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 20             |\n+| ...             | ...  | ...            |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+We allocate memory for `j`, `i`, and `h`. `i` is on the heap, and so has a\n+value pointing there.\n+\n+Next, at the end of `main()`, `foo()` gets called:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 20             |\n+| ...             | ...  | ...            |\n+| 5               | z    | 4              |\n+| 4               | y    | 10             |\n+| 3               | x    | 0              |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+Space gets allocated for `x`, `y`, and `z`. The argument `x` has the same value\n+as `j`, since that\u2019s what we passed it in. It\u2019s a pointer to the `0` address,\n+since `j` points at `h`.\n+\n+Next, `foo()` calls `baz()`, passing `z`:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 20             |\n+| ...             | ...  | ...            |\n+| 7               | g    | 100            |\n+| 6               | f    | 4              |\n+| 5               | z    | 4              |\n+| 4               | y    | 10             |\n+| 3               | x    | 0              |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+We\u2019ve allocated memory for `f` and `g`. `baz()` is very short, so when it\u2019s\n+over, we get rid of its stack frame:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 20             |\n+| ...             | ...  | ...            |\n+| 5               | z    | 4              |\n+| 4               | y    | 10             |\n+| 3               | x    | 0              |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+Next, `foo()` calls `bar()` with `x` and `z`:\n+\n+| Address              | Name | Value                |\n++----------------------+------+----------------------+\n+|  2<sup>30</sup>      |      | 20                   |\n+| (2<sup>30</sup>) - 1 |      | 5                    |\n+| ...                  | ...  | ...                  |\n+| 10                   | e    | 4                    |\n+| 9                    | d    | (2<sup>30</sup>) - 1 |\n+| 8                    | c    | 5                    |\n+| 7                    | b    | 4                    |\n+| 6                    | a    | 0                    |\n+| 5                    | z    | 4                    |\n+| 4                    | y    | 10                   |\n+| 3                    | x    | 0                    |\n+| 2                    | j    | 0                    |\n+| 1                    | i    | 2<sup>30</sup>       |\n+| 0                    | h    | 3                    |\n+\n+We end up allocating another value on the heap, and so we have to subtract one\n+from 2<sup>30</sup>. It\u2019s easier to just write that than `1,073,741,823`. In any\n+case, we set up the variables as usual.\n+\n+At the end of `bar()`, it calls `baz()`:\n+\n+| Address              | Name | Value                |\n++----------------------+------+----------------------+\n+|  2<sup>30</sup>      |      | 20                   |\n+| (2<sup>30</sup>) - 1 |      | 5                    |\n+| ...                  | ...  | ...                  |\n+| 12                   | g    | 100                  |\n+| 11                   | f    | 4                    |\n+| 10                   | e    | 4                    |\n+| 9                    | d    | (2<sup>30</sup>) - 1 |\n+| 8                    | c    | 5                    |\n+| 7                    | b    | 4                    |\n+| 6                    | a    | 0                    |\n+| 5                    | z    | 4                    |\n+| 4                    | y    | 10                   |\n+| 3                    | x    | 0                    |\n+| 2                    | j    | 0                    |\n+| 1                    | i    | 2<sup>30</sup>       |\n+| 0                    | h    | 3                    |\n+\n+With this, we\u2019re at our deepest point! Whew! Congrats for following along this\n+far.\n+\n+After `baz()` is over, we get rid of `f` and `g`:\n+\n+| Address              | Name | Value                |\n++----------------------+------+----------------------+\n+|  2<sup>30</sup>      |      | 20                   |\n+| (2<sup>30</sup>) - 1 |      | 5                    |\n+| ...                  | ...  | ...                  |\n+| 10                   | e    | 4                    |\n+| 9                    | d    | (2<sup>30</sup>) - 1 |\n+| 8                    | c    | 5                    |\n+| 7                    | b    | 4                    |\n+| 6                    | a    | 0                    |\n+| 5                    | z    | 4                    |\n+| 4                    | y    | 10                   |\n+| 3                    | x    | 0                    |\n+| 2                    | j    | 0                    |\n+| 1                    | i    | 2<sup>30</sup>       |\n+| 0                    | h    | 3                    |\n+\n+Next, we return from `bar()`. `d` in this case is a `Box<T>`, so it also frees\n+what it points to: (2<sup>30</sup>) - 1.\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+|  2<sup>30</sup> |      | 20             |\n+| ...             | ...  | ...            |\n+| 5               | z    | 4              |\n+| 4               | y    | 10             |\n+| 3               | x    | 0              |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+And after that, `foo()` returns:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+|  2<sup>30</sup> |      | 20             |\n+| ...             | ...  | ...            |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+And then, finally, `main()`, which cleans the rest up. When `i` is `Drop`ped,\n+it will clean up the last of the heap too.\n+\n+# What do other languages do?\n+\n+Most languages with a garbage collector heap-allocate by default. This means\n+that every value is boxed. There are a number of reasons why this is done, but\n+they\u2019re out of scope for this tutorial. There are some possible optimizations\n+that don\u2019t make it true 100% of the time, too. Rather than relying on the stack\n+and `Drop` to clean up memory, the garbage collector deals with the heap\n+instead.\n+\n+# Which to use?\n+\n+So if the stack is faster and easier to manage, why do we need the heap? A big\n+reason is that Stack-allocation alone means you only have LIFO semantics for\n+reclaiming storage. Heap-allocation is strictly more general, allowing storage\n+to be taken from and returned to the pool in arbitrary order, but at a\n+complexity cost.\n+\n+Generally, you should prefer stack allocation, and so, Rust stack-allocates by\n+default. The LIFO model of the stack is simpler, at a fundamental level. This\n+has two big impacts: runtime efficiency and semantic impact.\n+\n+## Runtime Efficiency.\n+\n+Managing the memory for the stack is trivial: The machine just\n+increments or decrements a single value, the so-called \u201cstack pointer\u201d.\n+Managing memory for the heap is non-trivial: heap-allocated memory is freed at\n+arbitrary points, and each block of heap-allocated memory can be of arbitrary\n+size, the memory manager must generally work much harder to identify memory for\n+reuse.\n+\n+If you\u2019d like to dive into this topic in greater detail, [this paper][wilson]\n+is a great introduction.\n+\n+[wilson]: http://www.cs.northwestern.edu/~pdinda/icsclass/doc/dsa.pdf\n+\n+## Semantic impact \n+\n+Stack-allocation impacts the Rust language itself, and thus the developer\u2019s\n+mental model. The LIFO semantics is what drives how the Rust language handles\n+automatic memory management. Even the deallocation of a uniquely-owned\n+heap-allocated box can be driven by the stack-based LIFO semantics, as\n+discussed throughout this chapter. The flexibility (i.e. expressiveness) of non\n+LIFO-semantics means that in general the compiler cannot automatically infer at\n+compile-time where memory should be freed; it has to rely on dynamic protocols,\n+potentially from outside the language itself, to drive deallocation (reference\n+counting, as used by `Rc<T>` and `Arc<T>`, is one example of this).\n+\n+When taken to the extreme, the increased expressive power of heap allocation\n+comes at the cost of either significant runtime support (e.g. in the form of a\n+garbage collector) or significant programmer effort (in the form of explicit\n+memory management calls that require verification not provided by the Rust\n+compiler)."}, {"sha": "e71d2033f49ed2f404e68baf56080bad695d18d4", "filename": "src/doc/trpl/while-loops.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fwhile-loops.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -1,4 +1,4 @@\n-% while loops\n+% while Loops\n \n Rust also has a `while` loop. It looks like this:\n "}, {"sha": "74837a06faecd094d2c588293465dbe8b543801a", "filename": "src/etc/CONFIGS.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fetc%2FCONFIGS.md", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fetc%2FCONFIGS.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2FCONFIGS.md?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -1,10 +1,16 @@\n # Configs\n \n-Here are some links to repos with configs which ease the use of rust:\n+These are some links to repos with configs which ease the use of rust.\n+\n+## Officially Maintained Configs\n \n * [rust.vim](https://github.com/rust-lang/rust.vim)\n * [emacs rust-mode](https://github.com/rust-lang/rust-mode)\n * [gedit-config](https://github.com/rust-lang/gedit-config)\n * [kate-config](https://github.com/rust-lang/kate-config)\n * [nano-config](https://github.com/rust-lang/nano-config)\n * [zsh-config](https://github.com/rust-lang/zsh-config)\n+\n+## Community-maintained Configs\n+\n+* [.editorconfig](https://gist.github.com/derhuerst/c9d1b9309e308d9851fa) ([what is this?](http://editorconfig.org/))"}, {"sha": "fc8ed7b383ec5943f7852534e636e3e43d6ca6ad", "filename": "src/etc/check-sanitycheck.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fetc%2Fcheck-sanitycheck.py", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fetc%2Fcheck-sanitycheck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck-sanitycheck.py?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -13,7 +13,6 @@\n import os\n import sys\n import functools\n-import resource\n \n STATUS = 0\n \n@@ -37,6 +36,7 @@ def inner():\n \n @only_on(('linux', 'darwin', 'freebsd', 'openbsd'))\n def check_rlimit_core():\n+    import resource\n     soft, hard = resource.getrlimit(resource.RLIMIT_CORE)\n     if soft > 0:\n         error_unless_permitted('ALLOW_NONZERO_RLIMIT_CORE', \"\"\"\\"}, {"sha": "e155dc86f3251d497b43cea25c82ae1d503e9bd1", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -8,6 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::{isize, usize};\n+\n+#[inline(always)]\n+fn check_size_and_alignment(size: usize, align: usize) {\n+    debug_assert!(size != 0);\n+    debug_assert!(size <= isize::MAX as usize, \"Tried to allocate too much: {} bytes\", size);\n+    debug_assert!(usize::is_power_of_two(align), \"Invalid alignment of allocation: {}\", align);\n+}\n+\n // FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias`\n \n /// Return a pointer to `size` bytes of memory aligned to `align`.\n@@ -19,6 +28,7 @@\n /// size on the platform.\n #[inline]\n pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n+    check_size_and_alignment(size, align);\n     imp::allocate(size, align)\n }\n \n@@ -38,6 +48,7 @@ pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n /// any value in range_inclusive(requested_size, usable_size).\n #[inline]\n pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n+    check_size_and_alignment(size, align);\n     imp::reallocate(ptr, old_size, size, align)\n }\n \n@@ -56,6 +67,7 @@ pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usiz\n #[inline]\n pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n                                  align: usize) -> usize {\n+    check_size_and_alignment(size, align);\n     imp::reallocate_inplace(ptr, old_size, size, align)\n }\n "}, {"sha": "8ec4a68f2b14b7c6334a24f8a10cd33676d61fd9", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 86, "deletions": 3, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -1537,7 +1537,7 @@ impl BitSet {\n         bit_vec.nbits = trunc_len * u32::BITS;\n     }\n \n-    /// Iterator over each u32 stored in the `BitSet`.\n+    /// Iterator over each usize stored in the `BitSet`.\n     ///\n     /// # Examples\n     ///\n@@ -1558,7 +1558,7 @@ impl BitSet {\n         SetIter {set: self, next_idx: 0}\n     }\n \n-    /// Iterator over each u32 stored in `self` union `other`.\n+    /// Iterator over each usize stored in `self` union `other`.\n     /// See [union_with](#method.union_with) for an efficient in-place version.\n     ///\n     /// # Examples\n@@ -1658,7 +1658,7 @@ impl BitSet {\n         })\n     }\n \n-    /// Iterator over each u32 stored in the symmetric difference of `self` and `other`.\n+    /// Iterator over each usize stored in the symmetric difference of `self` and `other`.\n     /// See [symmetric_difference_with](#method.symmetric_difference_with) for\n     /// an efficient in-place version.\n     ///\n@@ -1796,6 +1796,89 @@ impl BitSet {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n \n+    /// Moves all elements from `other` into `Self`, leaving `other` empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections, bit_set_append_split_off)]\n+    /// use std::collections::{BitVec, BitSet};\n+    ///\n+    /// let mut a = BitSet::new();\n+    /// a.insert(2);\n+    /// a.insert(6);\n+    ///\n+    /// let mut b = BitSet::new();\n+    /// b.insert(1);\n+    /// b.insert(3);\n+    /// b.insert(6);\n+    ///\n+    /// a.append(&mut b);\n+    ///\n+    /// assert_eq!(a.len(), 4);\n+    /// assert_eq!(b.len(), 0);\n+    /// assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b01110010])));\n+    /// ```\n+    #[unstable(feature = \"bit_set_append_split_off\",\n+               reason = \"recently added as part of collections reform 2\")]\n+    pub fn append(&mut self, other: &mut Self) {\n+        self.union_with(other);\n+        other.clear();\n+    }\n+\n+    /// Splits the `BitSet` into two at the given key including the key.\n+    /// Retains the first part in-place while returning the second part.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(collections, bit_set_append_split_off)]\n+    /// use std::collections::{BitSet, BitVec};\n+    /// let mut a = BitSet::new();\n+    /// a.insert(2);\n+    /// a.insert(6);\n+    /// a.insert(1);\n+    /// a.insert(3);\n+    ///\n+    /// let b = a.split_off(3);\n+    ///\n+    /// assert_eq!(a.len(), 2);\n+    /// assert_eq!(b.len(), 2);\n+    /// assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b01100000])));\n+    /// assert_eq!(b, BitSet::from_bit_vec(BitVec::from_bytes(&[0b00010010])));\n+    /// ```\n+    #[unstable(feature = \"bit_set_append_split_off\",\n+               reason = \"recently added as part of collections reform 2\")]\n+    pub fn split_off(&mut self, at: usize) -> Self {\n+        let mut other = BitSet::new();\n+\n+        if at == 0 {\n+            swap(self, &mut other);\n+            return other;\n+        } else if at >= self.bit_vec.len() {\n+            return other;\n+        }\n+\n+        // Calculate block and bit at which to split\n+        let w = at / u32::BITS;\n+        let b = at % u32::BITS;\n+\n+        // Pad `other` with `w` zero blocks,\n+        // append `self`'s blocks in the range from `w` to the end to `other`\n+        other.bit_vec.storage.extend(repeat(0u32).take(w)\n+                                     .chain(self.bit_vec.storage[w..].iter().cloned()));\n+        other.bit_vec.nbits = self.bit_vec.nbits;\n+\n+        if b > 0 {\n+            other.bit_vec.storage[w] &= !0 << b;\n+        }\n+\n+        // Sets `bit_vec.len()` and fixes the last block as well\n+        self.bit_vec.truncate(at);\n+\n+        other\n+    }\n+\n     /// Returns the number of set bits in this set.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "a86a4b4215f23ff2b927b944fee0201a696a8f2d", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -37,6 +37,11 @@ use self::Cow::*;\n /// trait: if `T: Borrow<U>`, then `&U` can be borrowed from `&T`.  A given\n /// type can be borrowed as multiple different types. In particular, `Vec<T>:\n /// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n+///\n+/// `Borrow` is very similar to, but different than, `AsRef`. See\n+/// [the book][book] for more.\n+///\n+/// [book]: ../../book/borrow-and-asref.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Borrow<Borrowed: ?Sized> {\n     /// Immutably borrows from an owned value."}, {"sha": "d5a069b194a5de3535c7fdc4664faf70ea095733", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -1002,7 +1002,7 @@ pub trait SliceConcatExt<T: ?Sized> {\n     /// The resulting type after concatenation\n     type Output;\n \n-    /// Flattens a slice of `T` into a single value `U`.\n+    /// Flattens a slice of `T` into a single value `Self::Output`.\n     ///\n     /// # Examples\n     ///\n@@ -1012,7 +1012,8 @@ pub trait SliceConcatExt<T: ?Sized> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn concat(&self) -> Self::Output;\n \n-    /// Flattens a slice of `T` into a single value `U`, placing a given separator between each.\n+    /// Flattens a slice of `T` into a single value `Self::Output`, placing a given separator\n+    /// between each.\n     ///\n     /// # Examples\n     ///"}, {"sha": "28e476742911b77dbe8c251c39b929f77e8717c5", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -1052,6 +1052,7 @@ impl<T: fmt::Display + ?Sized> ToString for T {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<str> for String {\n+    #[inline]\n     fn as_ref(&self) -> &str {\n         self\n     }"}, {"sha": "aa0ab41b7455b05d4bba2192a4525a5d58af9f8a", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -367,7 +367,7 @@ impl<V> VecMap<V> {\n             // Move all elements to other\n             swap(self, &mut other);\n             return other\n-        } else if at > self.v.len() {\n+        } else if at >= self.v.len() {\n             // No elements to copy\n             return other;\n         }"}, {"sha": "e6aa15608f03eb0297afcae622927e105a55c92d", "filename": "src/libcollectionstest/bit/set.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcollectionstest%2Fbit%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcollectionstest%2Fbit%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fset.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -387,6 +387,67 @@ fn test_bit_vec_clone() {\n     assert!(b.contains(&1000));\n }\n \n+#[test]\n+fn test_bit_set_append() {\n+    let mut a = BitSet::new();\n+    a.insert(2);\n+    a.insert(6);\n+\n+    let mut b = BitSet::new();\n+    b.insert(1);\n+    b.insert(3);\n+    b.insert(6);\n+\n+    a.append(&mut b);\n+\n+    assert_eq!(a.len(), 4);\n+    assert_eq!(b.len(), 0);\n+    assert!(b.capacity() >= 6);\n+\n+    assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b01110010])));\n+}\n+\n+#[test]\n+fn test_bit_set_split_off() {\n+    // Split at 0\n+    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010,\n+                                                          0b00110011, 0b01101011, 0b10101101]));\n+\n+    let b = a.split_off(0);\n+\n+    assert_eq!(a.len(), 0);\n+    assert_eq!(b.len(), 21);\n+\n+    assert_eq!(b, BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010,\n+                                                            0b00110011, 0b01101011, 0b10101101])));\n+\n+    // Split behind last element\n+    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010,\n+                                                          0b00110011, 0b01101011, 0b10101101]));\n+\n+    let b = a.split_off(50);\n+\n+    assert_eq!(a.len(), 21);\n+    assert_eq!(b.len(), 0);\n+\n+    assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010,\n+                                                            0b00110011, 0b01101011, 0b10101101])));\n+\n+    // Split at arbitrary element\n+    let mut a = BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010,\n+                                                          0b00110011, 0b01101011, 0b10101101]));\n+\n+    let b = a.split_off(34);\n+\n+    assert_eq!(a.len(), 12);\n+    assert_eq!(b.len(), 9);\n+\n+    assert_eq!(a, BitSet::from_bit_vec(BitVec::from_bytes(&[0b10100000, 0b00010010, 0b10010010,\n+                                                            0b00110011, 0b01000000])));\n+    assert_eq!(b, BitSet::from_bit_vec(BitVec::from_bytes(&[0, 0, 0, 0,\n+                                                            0b00101011, 0b10101101])));\n+}\n+\n mod bench {\n     use std::collections::{BitSet, BitVec};\n     use std::__rand::{Rng, thread_rng, ThreadRng};"}, {"sha": "9b50478472fa92d30ad3f3e5c63a2c7217b174ef", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(bit_set_append_split_off)]\n #![feature(bit_vec_append_split_off)]\n #![feature(box_syntax)]\n #![feature(collections)]"}, {"sha": "f6987c1966493843c25c768fad1a9d5aaf8f1f7e", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -24,6 +24,11 @@ use marker::Sized;\n \n /// A cheap, reference-to-reference conversion.\n ///\n+/// `AsRef` is very similar to, but different than, `Borrow`. See\n+/// [the book][book] for more.\n+///\n+/// [book]: ../../book/borrow-and-asref.html\n+///\n /// # Examples\n ///\n /// Both `String` and `&str` implement `AsRef<str>`:\n@@ -173,6 +178,7 @@ impl<T> AsMut<[T]> for [T] {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<str> for str {\n+    #[inline]\n     fn as_ref(&self) -> &str {\n         self\n     }"}, {"sha": "cab79d938c374b83ce8dcde6ca04b1a934ed0160", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -137,7 +137,7 @@ pub trait Iterator {\n     ///\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n-    /// assert_eq!(a.iter().last().unwrap(), &5);\n+    /// assert_eq!(a.iter().last(), Some(&5));\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -155,7 +155,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n-    /// assert_eq!(it.nth(2).unwrap(), &3);\n+    /// assert_eq!(it.nth(2), Some(&3));\n     /// assert_eq!(it.nth(2), None);\n     /// ```\n     #[inline]\n@@ -178,8 +178,8 @@ pub trait Iterator {\n     /// let a = [0];\n     /// let b = [1];\n     /// let mut it = a.iter().chain(b.iter());\n-    /// assert_eq!(it.next().unwrap(), &0);\n-    /// assert_eq!(it.next().unwrap(), &1);\n+    /// assert_eq!(it.next(), Some(&0));\n+    /// assert_eq!(it.next(), Some(&1));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -201,7 +201,7 @@ pub trait Iterator {\n     /// let a = [0];\n     /// let b = [1];\n     /// let mut it = a.iter().zip(b.iter());\n-    /// assert_eq!(it.next().unwrap(), (&0, &1));\n+    /// assert_eq!(it.next(), Some((&0, &1)));\n     /// assert!(it.next().is_none());\n     /// ```\n     ///\n@@ -234,8 +234,8 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2];\n     /// let mut it = a.iter().map(|&x| 2 * x);\n-    /// assert_eq!(it.next().unwrap(), 2);\n-    /// assert_eq!(it.next().unwrap(), 4);\n+    /// assert_eq!(it.next(), Some(2));\n+    /// assert_eq!(it.next(), Some(4));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -255,7 +255,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2];\n     /// let mut it = a.iter().filter(|&x| *x > 1);\n-    /// assert_eq!(it.next().unwrap(), &2);\n+    /// assert_eq!(it.next(), Some(&2));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -275,7 +275,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2];\n     /// let mut it = a.iter().filter_map(|&x| if x > 1 {Some(2 * x)} else {None});\n-    /// assert_eq!(it.next().unwrap(), 4);\n+    /// assert_eq!(it.next(), Some(4));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -310,8 +310,8 @@ pub trait Iterator {\n     /// ```\n     /// let a = [100, 200];\n     /// let mut it = a.iter().enumerate();\n-    /// assert_eq!(it.next().unwrap(), (0, &100));\n-    /// assert_eq!(it.next().unwrap(), (1, &200));\n+    /// assert_eq!(it.next(), Some((0, &100)));\n+    /// assert_eq!(it.next(), Some((1, &200)));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -353,9 +353,9 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().skip_while(|&a| *a < 3);\n-    /// assert_eq!(it.next().unwrap(), &3);\n-    /// assert_eq!(it.next().unwrap(), &4);\n-    /// assert_eq!(it.next().unwrap(), &5);\n+    /// assert_eq!(it.next(), Some(&3));\n+    /// assert_eq!(it.next(), Some(&4));\n+    /// assert_eq!(it.next(), Some(&5));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -375,8 +375,8 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().take_while(|&a| *a < 3);\n-    /// assert_eq!(it.next().unwrap(), &1);\n-    /// assert_eq!(it.next().unwrap(), &2);\n+    /// assert_eq!(it.next(), Some(&1));\n+    /// assert_eq!(it.next(), Some(&2));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -395,8 +395,8 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().skip(3);\n-    /// assert_eq!(it.next().unwrap(), &4);\n-    /// assert_eq!(it.next().unwrap(), &5);\n+    /// assert_eq!(it.next(), Some(&4));\n+    /// assert_eq!(it.next(), Some(&5));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -413,9 +413,9 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().take(3);\n-    /// assert_eq!(it.next().unwrap(), &1);\n-    /// assert_eq!(it.next().unwrap(), &2);\n-    /// assert_eq!(it.next().unwrap(), &3);\n+    /// assert_eq!(it.next(), Some(&1));\n+    /// assert_eq!(it.next(), Some(&2));\n+    /// assert_eq!(it.next(), Some(&3));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -437,11 +437,11 @@ pub trait Iterator {\n     ///   *fac = *fac * x;\n     ///   Some(*fac)\n     /// });\n-    /// assert_eq!(it.next().unwrap(), 1);\n-    /// assert_eq!(it.next().unwrap(), 2);\n-    /// assert_eq!(it.next().unwrap(), 6);\n-    /// assert_eq!(it.next().unwrap(), 24);\n-    /// assert_eq!(it.next().unwrap(), 120);\n+    /// assert_eq!(it.next(), Some(1));\n+    /// assert_eq!(it.next(), Some(2));\n+    /// assert_eq!(it.next(), Some(6));\n+    /// assert_eq!(it.next(), Some(24));\n+    /// assert_eq!(it.next(), Some(120));\n     /// assert!(it.next().is_none());\n     /// ```\n     #[inline]\n@@ -680,7 +680,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n-    /// assert_eq!(it.find(|&x| *x == 3).unwrap(), &3);\n+    /// assert_eq!(it.find(|&x| *x == 3), Some(&3));\n     /// assert_eq!(it.collect::<Vec<_>>(), [&4, &5]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -715,7 +715,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n-    /// assert_eq!(it.position(|x| *x == 3).unwrap(), 2);\n+    /// assert_eq!(it.position(|x| *x == 3), Some(2));\n     /// assert_eq!(it.collect::<Vec<_>>(), [&4, &5]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -743,7 +743,7 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2, 2, 4, 5];\n     /// let mut it = a.iter();\n-    /// assert_eq!(it.rposition(|x| *x == 2).unwrap(), 2);\n+    /// assert_eq!(it.rposition(|x| *x == 2), Some(2));\n     /// assert_eq!(it.collect::<Vec<_>>(), [&1, &2]);\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -773,7 +773,7 @@ pub trait Iterator {\n     ///\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n-    /// assert_eq!(a.iter().max().unwrap(), &5);\n+    /// assert_eq!(a.iter().max(), Some(&5));\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -796,7 +796,7 @@ pub trait Iterator {\n     ///\n     /// ```\n     /// let a = [1, 2, 3, 4, 5];\n-    /// assert_eq!(a.iter().min().unwrap(), &1);\n+    /// assert_eq!(a.iter().min(), Some(&1));\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1025,9 +1025,9 @@ pub trait Iterator {\n     /// ```\n     /// let a = [1, 2];\n     /// let mut it = a.iter().cycle();\n-    /// assert_eq!(it.next().unwrap(), &1);\n-    /// assert_eq!(it.next().unwrap(), &2);\n-    /// assert_eq!(it.next().unwrap(), &1);\n+    /// assert_eq!(it.next(), Some(&1));\n+    /// assert_eq!(it.next(), Some(&2));\n+    /// assert_eq!(it.next(), Some(&1));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "9db1ceddf0d752ae20df6770281667b841a63668", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 45, "deletions": 64, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -140,7 +140,7 @@ impl<T> SliceExt for [T] {\n             assume(!p.is_null());\n             if mem::size_of::<T>() == 0 {\n                 Iter {ptr: p,\n-                      end: (p as usize + self.len()) as *const T,\n+                      end: ((p as usize).wrapping_add(self.len())) as *const T,\n                       _marker: marker::PhantomData}\n             } else {\n                 Iter {ptr: p,\n@@ -277,7 +277,7 @@ impl<T> SliceExt for [T] {\n             assume(!p.is_null());\n             if mem::size_of::<T>() == 0 {\n                 IterMut {ptr: p,\n-                         end: (p as usize + self.len()) as *mut T,\n+                         end: ((p as usize).wrapping_add(self.len())) as *mut T,\n                          _marker: marker::PhantomData}\n             } else {\n                 IterMut {ptr: p,\n@@ -632,35 +632,17 @@ fn size_from_ptr<T>(_: *const T) -> usize {\n \n \n // Use macros to be generic over const/mut\n-//\n-// They require non-negative `$by` because otherwise the expression\n-// `(ptr as usize + $by)` would interpret `-1` as `usize::MAX` (and\n-// thus trigger a panic when overflow checks are on).\n-\n-// Use this to do `$ptr + $by`, where `$by` is non-negative.\n-macro_rules! slice_add_offset {\n+macro_rules! slice_offset {\n     ($ptr:expr, $by:expr) => {{\n         let ptr = $ptr;\n         if size_from_ptr(ptr) == 0 {\n-            transmute(ptr as usize + $by)\n+            transmute((ptr as isize).wrapping_add($by))\n         } else {\n             ptr.offset($by)\n         }\n     }};\n }\n \n-// Use this to do `$ptr - $by`, where `$by` is non-negative.\n-macro_rules! slice_sub_offset {\n-    ($ptr:expr, $by:expr) => {{\n-        let ptr = $ptr;\n-        if size_from_ptr(ptr) == 0 {\n-            transmute(ptr as usize - $by)\n-        } else {\n-            ptr.offset(-$by)\n-        }\n-    }};\n-}\n-\n macro_rules! slice_ref {\n     ($ptr:expr) => {{\n         let ptr = $ptr;\n@@ -683,22 +665,24 @@ macro_rules! iterator {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n-                unsafe {\n-                    ::intrinsics::assume(!self.ptr.is_null());\n-                    ::intrinsics::assume(!self.end.is_null());\n-                    if self.ptr == self.end {\n-                        None\n-                    } else {\n+                if self.ptr == self.end {\n+                    None\n+                } else {\n+                    unsafe {\n+                        if mem::size_of::<T>() != 0 {\n+                            ::intrinsics::assume(!self.ptr.is_null());\n+                            ::intrinsics::assume(!self.end.is_null());\n+                        }\n                         let old = self.ptr;\n-                        self.ptr = slice_add_offset!(self.ptr, 1);\n+                        self.ptr = slice_offset!(self.ptr, 1);\n                         Some(slice_ref!(old))\n                     }\n                 }\n             }\n \n             #[inline]\n             fn size_hint(&self) -> (usize, Option<usize>) {\n-                let diff = (self.end as usize) - (self.ptr as usize);\n+                let diff = (self.end as usize).wrapping_sub(self.ptr as usize);\n                 let size = mem::size_of::<T>();\n                 let exact = diff / (if size == 0 {1} else {size});\n                 (exact, Some(exact))\n@@ -726,13 +710,15 @@ macro_rules! iterator {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n-                unsafe {\n-                    ::intrinsics::assume(!self.ptr.is_null());\n-                    ::intrinsics::assume(!self.end.is_null());\n-                    if self.end == self.ptr {\n-                        None\n-                    } else {\n-                        self.end = slice_sub_offset!(self.end, 1);\n+                if self.end == self.ptr {\n+                    None\n+                } else {\n+                    unsafe {\n+                        self.end = slice_offset!(self.end, -1);\n+                        if mem::size_of::<T>() != 0 {\n+                            ::intrinsics::assume(!self.ptr.is_null());\n+                            ::intrinsics::assume(!self.end.is_null());\n+                        }\n                         Some(slice_ref!(self.end))\n                     }\n                 }\n@@ -742,29 +728,29 @@ macro_rules! iterator {\n }\n \n macro_rules! make_slice {\n-    ($t: ty => $result: ty: $start: expr, $end: expr) => {{\n-        let diff = $end as usize - $start as usize;\n-        let len = if mem::size_of::<T>() == 0 {\n-            diff\n+    ($start: expr, $end: expr) => {{\n+        let start = $start;\n+        let diff = ($end as usize).wrapping_sub(start as usize);\n+        if size_from_ptr(start) == 0 {\n+            // use a non-null pointer value\n+            unsafe { from_raw_parts(1 as *const _, diff) }\n         } else {\n-            diff / mem::size_of::<$t>()\n-        };\n-        unsafe {\n-            from_raw_parts($start, len)\n+            let len = diff / size_from_ptr(start);\n+            unsafe { from_raw_parts(start, len) }\n         }\n     }}\n }\n \n macro_rules! make_mut_slice {\n-    ($t: ty => $result: ty: $start: expr, $end: expr) => {{\n-        let diff = $end as usize - $start as usize;\n-        let len = if mem::size_of::<T>() == 0 {\n-            diff\n+    ($start: expr, $end: expr) => {{\n+        let start = $start;\n+        let diff = ($end as usize).wrapping_sub(start as usize);\n+        if size_from_ptr(start) == 0 {\n+            // use a non-null pointer value\n+            unsafe { from_raw_parts_mut(1 as *mut _, diff) }\n         } else {\n-            diff / mem::size_of::<$t>()\n-        };\n-        unsafe {\n-            from_raw_parts_mut($start, len)\n+            let len = diff / size_from_ptr(start);\n+            unsafe { from_raw_parts_mut(start, len) }\n         }\n     }}\n }\n@@ -787,14 +773,14 @@ impl<'a, T> Iter<'a, T> {\n     /// iterator can continue to be used while this exists.\n     #[unstable(feature = \"core\")]\n     pub fn as_slice(&self) -> &'a [T] {\n-        make_slice!(T => &'a [T]: self.ptr, self.end)\n+        make_slice!(self.ptr, self.end)\n     }\n \n     // Helper function for Iter::nth\n     fn iter_nth(&mut self, n: usize) -> Option<&'a T> {\n         match self.as_slice().get(n) {\n             Some(elem_ref) => unsafe {\n-                self.ptr = slice_add_offset!(elem_ref as *const _, 1);\n+                self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n                 Some(slice_ref!(elem_ref))\n             },\n             None => {\n@@ -827,12 +813,7 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     fn idx(&mut self, index: usize) -> Option<&'a T> {\n         unsafe {\n             if index < self.indexable() {\n-                if mem::size_of::<T>() == 0 {\n-                    // Use a non-null pointer value\n-                    Some(&mut *(1 as *mut _))\n-                } else {\n-                    Some(transmute(self.ptr.offset(index as isize)))\n-                }\n+                Some(slice_ref!(self.ptr.offset(index as isize)))\n             } else {\n                 None\n             }\n@@ -860,14 +841,14 @@ impl<'a, T> IterMut<'a, T> {\n     /// restricted lifetimes that do not consume the iterator.\n     #[unstable(feature = \"core\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n-        make_mut_slice!(T => &'a mut [T]: self.ptr, self.end)\n+        make_mut_slice!(self.ptr, self.end)\n     }\n \n     // Helper function for IterMut::nth\n     fn iter_nth(&mut self, n: usize) -> Option<&'a mut T> {\n-        match make_mut_slice!(T => &'a mut [T]: self.ptr, self.end).get_mut(n) {\n+        match make_mut_slice!(self.ptr, self.end).get_mut(n) {\n             Some(elem_ref) => unsafe {\n-                self.ptr = slice_add_offset!(elem_ref as *mut _, 1);\n+                self.ptr = slice_offset!(self.ptr, (n as isize).wrapping_add(1));\n                 Some(slice_ref!(elem_ref))\n             },\n             None => {"}, {"sha": "11ca6e332b5713da5c204c7cd65755269aaab7b0", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -44,8 +44,11 @@ pub trait FromStr {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Err;\n \n-    /// Parses a string `s` to return an optional value of this type. If the\n-    /// string is ill-formatted, the None is returned.\n+    /// Parses a string `s` to return a value of this type.\n+    ///\n+    /// If parsing succeeds, return the value inside `Ok`, otherwise\n+    /// when the string is ill-formatted return an error specific to the\n+    /// inside `Err`. The error type is specific to implementation of the trait.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from_str(s: &str) -> Result<Self, Self::Err>;\n }"}, {"sha": "69ab34fee5a1f9b0e6cdb2762414baaccd3f9b5c", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -5722,6 +5722,9 @@ pub mod funcs {\n                 pub fn tcgetpgrp(fd: c_int) -> pid_t;\n                 pub fn ttyname(fd: c_int) -> *mut c_char;\n                 pub fn unlink(c: *const c_char) -> c_int;\n+                pub fn wait(status: *const c_int) -> pid_t;\n+                pub fn waitpid(pid: pid_t, status: *const c_int, options: c_int)\n+                               -> pid_t;\n                 pub fn write(fd: c_int, buf: *const c_void, count: size_t)\n                              -> ssize_t;\n                 pub fn pread(fd: c_int, buf: *mut c_void, count: size_t,\n@@ -5773,6 +5776,9 @@ pub mod funcs {\n                 pub fn sysconf(name: c_int) -> c_long;\n                 pub fn ttyname(fd: c_int) -> *mut c_char;\n                 pub fn unlink(c: *const c_char) -> c_int;\n+                pub fn wait(status: *const c_int) -> pid_t;\n+                pub fn waitpid(pid: pid_t, status: *const c_int, options: c_int)\n+                               -> pid_t;\n                 pub fn write(fd: c_int, buf: *const c_void, count: size_t)\n                              -> ssize_t;\n                 pub fn pread(fd: c_int, buf: *mut c_void, count: size_t,"}, {"sha": "6690e6831afee2a7572a8f828a6688820f9e3cfa", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -273,8 +273,8 @@ See also http://doc.rust-lang.org/book/unsafe.html\n \n E0137: r##\"\n This error indicates that the compiler found multiple functions with the\n-#[main] attribute. This is an error because there must be a unique entry point\n-into a Rust program.\n+`#[main]` attribute. This is an error because there must be a unique entry\n+point into a Rust program.\n \"##,\n \n E0152: r##\"\n@@ -745,13 +745,15 @@ variable.\n \n For example:\n \n+```\n let x: i32 = \"I am not a number!\";\n //     ~~~   ~~~~~~~~~~~~~~~~~~~~\n //      |             |\n //      |    initializing expression;\n //      |    compiler infers type `&str`\n //      |\n //    type `i32` assigned to variable `x`\n+```\n \"##,\n \n E0309: r##\"\n@@ -760,6 +762,7 @@ how long the data stored within them is guaranteed to be live. This lifetime\n must be as long as the data needs to be alive, and missing the constraint that\n denotes this will cause this error.\n \n+```\n // This won't compile because T is not constrained, meaning the data\n // stored in it is not guaranteed to last as long as the reference\n struct Foo<'a, T> {\n@@ -770,6 +773,7 @@ struct Foo<'a, T> {\n struct Foo<'a, T: 'a> {\n     foo: &'a T\n }\n+```\n \"##,\n \n E0310: r##\"\n@@ -778,6 +782,7 @@ how long the data stored within them is guaranteed to be live. This lifetime\n must be as long as the data needs to be alive, and missing the constraint that\n denotes this will cause this error.\n \n+```\n // This won't compile because T is not constrained to the static lifetime\n // the reference needs\n struct Foo<T> {\n@@ -788,6 +793,7 @@ struct Foo<T> {\n struct Foo<T: 'static> {\n     foo: &'static T\n }\n+```\n \"##\n \n }"}, {"sha": "b6202084296bb400b87ca669632d9040694354c4", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -189,6 +189,7 @@ pub const tag_item_impl_vtables: usize = 0x7e;\n \n pub const tag_impls: usize = 0x109; // top-level only\n pub const tag_impls_impl: usize = 0x7f;\n+pub const tag_impls_impl_trait_def_id: usize = 0x8d;\n \n pub const tag_items_data_item_inherent_impl: usize = 0x80;\n pub const tag_items_data_item_extension_impl: usize = 0x81;"}, {"sha": "6caefec48783afe89549aa4a922642995039ab91", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -304,31 +304,23 @@ pub fn get_native_libraries(cstore: &cstore::CStore, crate_num: ast::CrateNum)\n     decoder::get_native_libraries(&*cdata)\n }\n \n-pub fn each_impl<F>(cstore: &cstore::CStore,\n-                    crate_num: ast::CrateNum,\n-                    callback: F) where\n-    F: FnMut(ast::DefId),\n-{\n-    let cdata = cstore.get_crate_data(crate_num);\n-    decoder::each_impl(&*cdata, callback)\n-}\n-\n-pub fn each_implementation_for_type<F>(cstore: &cstore::CStore,\n-                                       def_id: ast::DefId,\n-                                       callback: F) where\n+pub fn each_inherent_implementation_for_type<F>(cstore: &cstore::CStore,\n+                                                def_id: ast::DefId,\n+                                                callback: F) where\n     F: FnMut(ast::DefId),\n {\n     let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::each_implementation_for_type(&*cdata, def_id.node, callback)\n+    decoder::each_inherent_implementation_for_type(&*cdata, def_id.node, callback)\n }\n \n pub fn each_implementation_for_trait<F>(cstore: &cstore::CStore,\n                                         def_id: ast::DefId,\n-                                        callback: F) where\n+                                        mut callback: F) where\n     F: FnMut(ast::DefId),\n {\n-    let cdata = cstore.get_crate_data(def_id.krate);\n-    decoder::each_implementation_for_trait(&*cdata, def_id.node, callback)\n+    cstore.iter_crate_data(|_, cdata| {\n+        decoder::each_implementation_for_trait(cdata, def_id, &mut callback)\n+    })\n }\n \n /// If the given def ID describes an item belonging to a trait (either a"}, {"sha": "382dc437bdc4829c0b3effe1b22cd5a2cfae6513", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 85, "deletions": 78, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -21,7 +21,8 @@ use metadata::common::*;\n use metadata::csearch::MethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n-use metadata::tydecode::{parse_ty_data, parse_region_data, parse_def_id,\n+use metadata::encoder::def_to_u64;\n+use metadata::tydecode::{parse_ty_data, parse_region_data,\n                          parse_type_param_def_data, parse_bare_fn_ty_data,\n                          parse_trait_ref_data, parse_predicate_data};\n use middle::def;\n@@ -190,29 +191,32 @@ fn item_symbol(item: rbml::Doc) -> String {\n     reader::get_doc(item, tag_items_data_item_symbol).as_str().to_string()\n }\n \n-fn item_parent_item(d: rbml::Doc) -> Option<ast::DefId> {\n+fn translated_def_id(cdata: Cmd, d: rbml::Doc) -> ast::DefId {\n+    let id = reader::doc_as_u64(d);\n+    let def_id = ast::DefId { krate: (id >> 32) as u32, node: id as u32 };\n+    translate_def_id(cdata, def_id)\n+}\n+\n+fn item_parent_item(cdata: Cmd, d: rbml::Doc) -> Option<ast::DefId> {\n     let mut ret = None;\n     reader::tagged_docs(d, tag_items_data_parent_item, |did| {\n-        ret = Some(reader::with_doc_data(did, parse_def_id));\n+        ret = Some(translated_def_id(cdata, did));\n         false\n     });\n     ret\n }\n \n-fn item_reqd_and_translated_parent_item(cnum: ast::CrateNum,\n-                                        d: rbml::Doc) -> ast::DefId {\n-    let trait_did = item_parent_item(d).expect(\"item without parent\");\n-    ast::DefId { krate: cnum, node: trait_did.node }\n+fn item_require_parent_item(cdata: Cmd, d: rbml::Doc) -> ast::DefId {\n+    translated_def_id(cdata, reader::get_doc(d, tag_items_data_parent_item))\n }\n \n fn item_def_id(d: rbml::Doc, cdata: Cmd) -> ast::DefId {\n-    let tagdoc = reader::get_doc(d, tag_def_id);\n-    return translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n+    translated_def_id(cdata, reader::get_doc(d, tag_def_id))\n }\n \n fn get_provided_source(d: rbml::Doc, cdata: Cmd) -> Option<ast::DefId> {\n     reader::maybe_get_doc(d, tag_item_method_provided_source).map(|doc| {\n-        translate_def_id(cdata, reader::with_doc_data(doc, parse_def_id))\n+        translated_def_id(cdata, doc)\n     })\n }\n \n@@ -261,14 +265,12 @@ fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n }\n \n fn enum_variant_ids(item: rbml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n-    let mut ids: Vec<ast::DefId> = Vec::new();\n-    let v = tag_items_data_item_variant;\n-    reader::tagged_docs(item, v, |p| {\n-        let ext = reader::with_doc_data(p, parse_def_id);\n-        ids.push(ast::DefId { krate: cdata.cnum, node: ext.node });\n+    let mut ids = vec![];\n+    reader::tagged_docs(item, tag_items_data_item_variant, |p| {\n+        ids.push(translated_def_id(cdata, p));\n         true\n     });\n-    return ids;\n+    ids\n }\n \n fn item_path(item_doc: rbml::Doc) -> Vec<ast_map::PathElem> {\n@@ -303,8 +305,7 @@ fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Name {\n     }\n }\n \n-fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n-    -> DefLike {\n+fn item_to_def_like(cdata: Cmd, item: rbml::Doc, did: ast::DefId) -> DefLike {\n     let fam = item_family(item);\n     match fam {\n         Constant  => {\n@@ -314,11 +315,9 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n                 // See the comment for methods below.\n                 let provenance = if reader::maybe_get_doc(\n                       item, tag_item_trait_parent_sort).is_some() {\n-                    def::FromTrait(item_reqd_and_translated_parent_item(cnum,\n-                                                                        item))\n+                    def::FromTrait(item_require_parent_item(cdata, item))\n                 } else {\n-                    def::FromImpl(item_reqd_and_translated_parent_item(cnum,\n-                                                                       item))\n+                    def::FromImpl(item_require_parent_item(cdata, item))\n                 };\n                 DlDef(def::DefAssociatedConst(did, provenance))\n             } else {\n@@ -339,17 +338,15 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n             // a trait_parent_sort.\n             let provenance = if reader::maybe_get_doc(\n                   item, tag_item_trait_parent_sort).is_some() {\n-                def::FromTrait(item_reqd_and_translated_parent_item(cnum,\n-                                                                    item))\n+                def::FromTrait(item_require_parent_item(cdata, item))\n             } else {\n-                def::FromImpl(item_reqd_and_translated_parent_item(cnum,\n-                                                                   item))\n+                def::FromImpl(item_require_parent_item(cdata, item))\n             };\n             DlDef(def::DefMethod(did, provenance))\n         }\n         Type => {\n             if item_sort(item) == Some('t') {\n-                let trait_did = item_reqd_and_translated_parent_item(cnum, item);\n+                let trait_did = item_require_parent_item(cdata, item);\n                 DlDef(def::DefAssociatedTy(trait_did, did))\n             } else {\n                 DlDef(def::DefTy(did, false))\n@@ -358,11 +355,11 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n         Mod => DlDef(def::DefMod(did)),\n         ForeignMod => DlDef(def::DefForeignMod(did)),\n         StructVariant => {\n-            let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n+            let enum_did = item_require_parent_item(cdata, item);\n             DlDef(def::DefVariant(enum_did, did, true))\n         }\n         TupleVariant => {\n-            let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n+            let enum_did = item_require_parent_item(cdata, item);\n             DlDef(def::DefVariant(enum_did, did, false))\n         }\n         Trait => DlDef(def::DefTrait(did)),\n@@ -560,9 +557,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n {\n     // Iterate over all children.\n     let _ = reader::tagged_docs(item_doc, tag_mod_child, |child_info_doc| {\n-        let child_def_id = reader::with_doc_data(child_info_doc,\n-                                                 parse_def_id);\n-        let child_def_id = translate_def_id(cdata, child_def_id);\n+        let child_def_id = translated_def_id(cdata, child_info_doc);\n \n         // This item may be in yet another crate if it was the child of a\n         // reexport.\n@@ -584,9 +579,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n             Some(child_item_doc) => {\n                 // Hand off the item to the callback.\n                 let child_name = item_name(&*intr, child_item_doc);\n-                let def_like = item_to_def_like(child_item_doc,\n-                                                child_def_id,\n-                                                cdata.cnum);\n+                let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n                 let visibility = item_visibility(child_item_doc);\n                 callback(def_like, child_name, visibility);\n \n@@ -615,9 +608,8 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                     if let StaticMethod = item_family(impl_method_doc) {\n                         // Hand off the static method to the callback.\n                         let static_method_name = item_name(&*intr, impl_method_doc);\n-                        let static_method_def_like = item_to_def_like(impl_method_doc,\n-                                                                      impl_item_def_id,\n-                                                                      cdata.cnum);\n+                        let static_method_def_like = item_to_def_like(cdata, impl_method_doc,\n+                                                                      impl_item_def_id);\n                         callback(static_method_def_like,\n                                  static_method_name,\n                                  item_visibility(impl_method_doc));\n@@ -633,9 +625,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n     let _ = each_reexport(item_doc, |reexport_doc| {\n         let def_id_doc = reader::get_doc(reexport_doc,\n                                          tag_items_data_item_reexport_def_id);\n-        let child_def_id = reader::with_doc_data(def_id_doc,\n-                                                 parse_def_id);\n-        let child_def_id = translate_def_id(cdata, child_def_id);\n+        let child_def_id = translated_def_id(cdata, def_id_doc);\n \n         let name_doc = reader::get_doc(reexport_doc,\n                                        tag_items_data_item_reexport_name);\n@@ -657,9 +647,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n         // Get the item.\n         if let Some(child_item_doc) = maybe_find_item(child_def_id.node, other_crates_items) {\n             // Hand off the item to the callback.\n-            let def_like = item_to_def_like(child_item_doc,\n-                                            child_def_id,\n-                                            child_def_id.krate);\n+            let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n             // These items have a public visibility because they're part of\n             // a public re-export.\n             callback(def_like, token::intern(name), ast::Public);\n@@ -733,9 +721,8 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeI\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n         Ok(ii) => csearch::FoundAst::Found(ii),\n         Err(path) => {\n-            match item_parent_item(item_doc) {\n+            match item_parent_item(cdata, item_doc) {\n                 Some(did) => {\n-                    let did = translate_def_id(cdata, did);\n                     let parent_item = lookup_item(did.node, cdata.data());\n                     match decode_inlined_item(cdata, tcx, path, parent_item) {\n                         Ok(ii) => csearch::FoundAst::FoundParent(did, ii),\n@@ -759,7 +746,7 @@ pub fn get_enum_variant_defs(intr: &IdentInterner,\n         let item = find_item(did.node, items);\n         let name = item_name(intr, item);\n         let visibility = item_visibility(item);\n-        match item_to_def_like(item, *did, cdata.cnum) {\n+        match item_to_def_like(cdata, item, *did) {\n             DlDef(def @ def::DefVariant(..)) => (def, name, visibility),\n             _ => unreachable!()\n         }\n@@ -889,8 +876,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n \n     let def_id = item_def_id(method_doc, cdata);\n \n-    let container_id = item_reqd_and_translated_parent_item(cdata.cnum,\n-                                                            method_doc);\n+    let container_id = item_require_parent_item(cdata, method_doc);\n     let container_doc = lookup_item(container_id.node, cdata.data());\n     let container = match item_family(container_doc) {\n         Trait => TraitContainer(container_id),\n@@ -1094,7 +1080,7 @@ pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n     let item = lookup_item(node_id, cdata.data());\n     let mut ret = None;\n     reader::tagged_docs(item, tag_items_data_item_is_tuple_struct_ctor, |_| {\n-        ret = Some(item_reqd_and_translated_parent_item(cdata.cnum, item));\n+        ret = Some(item_require_parent_item(cdata, item));\n         false\n     });\n     ret\n@@ -1144,7 +1130,7 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n             let name = item_name(&*intr, an_item);\n             let did = item_def_id(an_item, cdata);\n             let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n-            let origin_id =  translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n+            let origin_id =  translated_def_id(cdata, tagdoc);\n             result.push(ty::field_ty {\n                 name: name,\n                 id: did,\n@@ -1158,7 +1144,7 @@ pub fn get_struct_fields(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId)\n         let did = item_def_id(an_item, cdata);\n         let tagdoc = reader::get_doc(an_item, tag_item_field_origin);\n         let f = item_family(an_item);\n-        let origin_id =  translate_def_id(cdata, reader::with_doc_data(tagdoc, parse_def_id));\n+        let origin_id =  translated_def_id(cdata, tagdoc);\n         result.push(ty::field_ty {\n             name: special_idents::unnamed_field.name,\n             id: did,\n@@ -1342,55 +1328,77 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n     }\n }\n \n-pub fn each_impl<F>(cdata: Cmd, mut callback: F) where\n-    F: FnMut(ast::DefId),\n-{\n-    let impls_doc = reader::get_doc(rbml::Doc::new(cdata.data()), tag_impls);\n-    let _ = reader::tagged_docs(impls_doc, tag_impls_impl, |impl_doc| {\n-        callback(item_def_id(impl_doc, cdata));\n-        true\n-    });\n+// Translate a DefId from the current compilation environment to a DefId\n+// for an external crate.\n+fn reverse_translate_def_id(cdata: Cmd, did: ast::DefId) -> Option<ast::DefId> {\n+    if did.krate == cdata.cnum {\n+        return Some(ast::DefId { krate: ast::LOCAL_CRATE, node: did.node });\n+    }\n+\n+    for (&local, &global) in &cdata.cnum_map {\n+        if global == did.krate {\n+            return Some(ast::DefId { krate: local, node: did.node });\n+        }\n+    }\n+\n+    None\n }\n \n-pub fn each_implementation_for_type<F>(cdata: Cmd,\n-                                       id: ast::NodeId,\n-                                       mut callback: F)\n+pub fn each_inherent_implementation_for_type<F>(cdata: Cmd,\n+                                                id: ast::NodeId,\n+                                                mut callback: F)\n     where F: FnMut(ast::DefId),\n {\n     let item_doc = lookup_item(id, cdata.data());\n     reader::tagged_docs(item_doc,\n                         tag_items_data_item_inherent_impl,\n                         |impl_doc| {\n-        let implementation_def_id = item_def_id(impl_doc, cdata);\n-        callback(implementation_def_id);\n+        if reader::maybe_get_doc(impl_doc, tag_item_trait_ref).is_none() {\n+            callback(item_def_id(impl_doc, cdata));\n+        }\n         true\n     });\n }\n \n pub fn each_implementation_for_trait<F>(cdata: Cmd,\n-                                        id: ast::NodeId,\n+                                        def_id: ast::DefId,\n                                         mut callback: F) where\n     F: FnMut(ast::DefId),\n {\n-    let item_doc = lookup_item(id, cdata.data());\n+    if cdata.cnum == def_id.krate {\n+        let item_doc = lookup_item(def_id.node, cdata.data());\n+        let _ = reader::tagged_docs(item_doc,\n+                                    tag_items_data_item_extension_impl,\n+                                    |impl_doc| {\n+            callback(item_def_id(impl_doc, cdata));\n+            true\n+        });\n+        return;\n+    }\n \n-    let _ = reader::tagged_docs(item_doc,\n-                                tag_items_data_item_extension_impl,\n-                                |impl_doc| {\n-        let implementation_def_id = item_def_id(impl_doc, cdata);\n-        callback(implementation_def_id);\n-        true\n-    });\n+    // Do a reverse lookup beforehand to avoid touching the crate_num\n+    // hash map in the loop below.\n+    if let Some(crate_local_did) = reverse_translate_def_id(cdata, def_id) {\n+        let def_id_u64 = def_to_u64(crate_local_did);\n+\n+        let impls_doc = reader::get_doc(rbml::Doc::new(cdata.data()), tag_impls);\n+        let _ = reader::tagged_docs(impls_doc, tag_impls_impl, |impl_doc| {\n+            let impl_trait = reader::get_doc(impl_doc, tag_impls_impl_trait_def_id);\n+            if reader::doc_as_u64(impl_trait) == def_id_u64 {\n+                callback(item_def_id(impl_doc, cdata));\n+            }\n+            true\n+        });\n+    }\n }\n \n pub fn get_trait_of_item(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n                          -> Option<ast::DefId> {\n     let item_doc = lookup_item(id, cdata.data());\n-    let parent_item_id = match item_parent_item(item_doc) {\n+    let parent_item_id = match item_parent_item(cdata, item_doc) {\n         None => return None,\n         Some(item_id) => item_id,\n     };\n-    let parent_item_id = translate_def_id(cdata, parent_item_id);\n     let parent_item_doc = lookup_item(parent_item_id.node, cdata.data());\n     match item_family(parent_item_doc) {\n         Trait => Some(item_def_id(parent_item_doc, cdata)),\n@@ -1538,8 +1546,7 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n         let name = item_name(&*token::get_ident_interner(), ident_str_doc);\n         let def_id_doc = reader::get_doc(rp_doc,\n                                          tag_region_param_def_def_id);\n-        let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n-        let def_id = translate_def_id(cdata, def_id);\n+        let def_id = translated_def_id(cdata, def_id_doc);\n \n         let doc = reader::get_doc(rp_doc, tag_region_param_def_space);\n         let space = subst::ParamSpace::from_uint(reader::doc_as_u64(doc) as usize);"}, {"sha": "afc71f83975c221abe05ba7bbc15b9b38925e78e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -91,8 +91,8 @@ fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Name) {\n     rbml_w.wr_tagged_str(tag_item_impl_type_basename, &token::get_name(name));\n }\n \n-pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_str(tag_def_id, &def_to_string(id));\n+fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n+    rbml_w.wr_tagged_u64(tag_def_id, def_to_u64(id));\n }\n \n #[derive(Clone)]\n@@ -122,6 +122,10 @@ fn encode_family(rbml_w: &mut Encoder, c: char) {\n     rbml_w.wr_tagged_u8(tag_items_data_item_family, c as u8);\n }\n \n+pub fn def_to_u64(did: DefId) -> u64 {\n+    (did.krate as u64) << 32 | (did.node as u64)\n+}\n+\n pub fn def_to_string(did: DefId) -> String {\n     format!(\"{}:{}\", did.krate, did.node)\n }\n@@ -153,9 +157,9 @@ fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n }\n \n fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n-    let s = def_to_string(vid);\n-    rbml_w.wr_tagged_str(tag_items_data_item_variant, &s[..]);\n-    rbml_w.wr_tagged_str(tag_mod_child, &s[..]);\n+    let id = def_to_u64(vid);\n+    rbml_w.wr_tagged_u64(tag_items_data_item_variant, id);\n+    rbml_w.wr_tagged_u64(tag_mod_child, id);\n }\n \n pub fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n@@ -260,7 +264,7 @@ fn encode_disr_val(_: &EncodeContext,\n }\n \n fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_str(tag_items_data_parent_item, &def_to_string(id));\n+    rbml_w.wr_tagged_u64(tag_items_data_parent_item, def_to_u64(id));\n }\n \n fn encode_struct_fields(rbml_w: &mut Encoder,\n@@ -275,7 +279,7 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n         }\n         encode_struct_field_family(rbml_w, f.vis);\n         encode_def_id(rbml_w, f.id);\n-        rbml_w.wr_tagged_str(tag_item_field_origin, &def_to_string(origin));\n+        rbml_w.wr_tagged_u64(tag_item_field_origin, def_to_u64(origin));\n         rbml_w.end_tag();\n     }\n }\n@@ -358,8 +362,8 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n     debug!(\"(encode reexported static method) {}::{}\",\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n-    rbml_w.wr_tagged_str(tag_items_data_item_reexport_def_id,\n-                         &def_to_string(method_def_id));\n+    rbml_w.wr_tagged_u64(tag_items_data_item_reexport_def_id,\n+                         def_to_u64(method_def_id));\n     rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n                          &format!(\"{}::{}\", exp.name,\n                                             token::get_name(method_name)));\n@@ -495,8 +499,8 @@ fn encode_reexports(ecx: &EncodeContext,\n                        exp.def_id.node,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n-                rbml_w.wr_tagged_str(tag_items_data_item_reexport_def_id,\n-                                     &def_to_string(exp.def_id));\n+                rbml_w.wr_tagged_u64(tag_items_data_item_reexport_def_id,\n+                                     def_to_u64(exp.def_id));\n                 rbml_w.wr_tagged_str(tag_items_data_item_reexport_name,\n                                      exp.name.as_str());\n                 rbml_w.end_tag();\n@@ -526,12 +530,12 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n \n     // Encode info about all the module children.\n     for item in &md.items {\n-        rbml_w.wr_tagged_str(tag_mod_child,\n-                             &def_to_string(local_def(item.id)));\n+        rbml_w.wr_tagged_u64(tag_mod_child,\n+                             def_to_u64(local_def(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n-            rbml_w.wr_tagged_str(tag_mod_child,\n-                                 &def_to_string(local_def(auxiliary_node_id)));\n+            rbml_w.wr_tagged_u64(tag_mod_child,\n+                                 def_to_u64(local_def(auxiliary_node_id)));\n             true\n         });\n \n@@ -541,8 +545,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    token::get_ident(ident),\n                    did, ecx.tcx.map.node_to_string(did));\n \n-            rbml_w.wr_tagged_str(tag_mod_impl,\n-                                 &def_to_string(local_def(did)));\n+            rbml_w.wr_tagged_u64(tag_mod_impl, def_to_u64(local_def(did)));\n         }\n     }\n \n@@ -619,8 +622,7 @@ fn encode_parent_sort(rbml_w: &mut Encoder, sort: char) {\n fn encode_provided_source(rbml_w: &mut Encoder,\n                           source_opt: Option<DefId>) {\n     if let Some(source) = source_opt {\n-        rbml_w.wr_tagged_str(tag_item_method_provided_source,\n-                             &def_to_string(source));\n+        rbml_w.wr_tagged_u64(tag_item_method_provided_source, def_to_u64(source));\n     }\n }\n \n@@ -725,8 +727,8 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         encode_name(rbml_w, param.name);\n         rbml_w.end_tag();\n \n-        rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n-                             &def_to_string(param.def_id));\n+        rbml_w.wr_tagged_u64(tag_region_param_def_def_id,\n+                             def_to_u64(param.def_id));\n \n         rbml_w.wr_tagged_u64(tag_region_param_def_space,\n                              param.space.to_uint() as u64);\n@@ -1089,8 +1091,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         // Encode all the items in this module.\n         for foreign_item in &fm.items {\n-            rbml_w.wr_tagged_str(tag_mod_child,\n-                                 &def_to_string(local_def(foreign_item.id)));\n+            rbml_w.wr_tagged_u64(tag_mod_child,\n+                                 def_to_u64(local_def(foreign_item.id)));\n         }\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -1335,8 +1337,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n \n-            rbml_w.wr_tagged_str(tag_mod_child,\n-                                 &def_to_string(method_def_id.def_id()));\n+            rbml_w.wr_tagged_u64(tag_mod_child,\n+                                 def_to_u64(method_def_id.def_id()));\n         }\n         encode_path(rbml_w, path.clone());\n \n@@ -1893,6 +1895,7 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n                     def_id.krate != ast::LOCAL_CRATE {\n                 self.rbml_w.start_tag(tag_impls_impl);\n                 encode_def_id(self.rbml_w, local_def(item.id));\n+                self.rbml_w.wr_tagged_u64(tag_impls_impl_trait_def_id, def_to_u64(def_id));\n                 self.rbml_w.end_tag();\n             }\n         }\n@@ -1932,12 +1935,12 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info);\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in &krate.module.items {\n-        rbml_w.wr_tagged_str(tag_mod_child,\n-                             &def_to_string(local_def(item.id)));\n+        rbml_w.wr_tagged_u64(tag_mod_child,\n+                             def_to_u64(local_def(item.id)));\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n-            rbml_w.wr_tagged_str(tag_mod_child,\n-                                 &def_to_string(local_def(auxiliary_node_id)));\n+            rbml_w.wr_tagged_u64(tag_mod_child,\n+                                 def_to_u64(local_def(auxiliary_node_id)));\n             true\n         });\n     }"}, {"sha": "0458bd70346c1b19d1ecbce422bb07da9ddcbb62", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -1125,7 +1125,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         // that case we can adjust the length of the\n                         // original vec accordingly, but we'd have to\n                         // make trans do the right thing, and it would\n-                        // only work for `~` vectors. It seems simpler\n+                        // only work for `Box<[T]>`s. It seems simpler\n                         // to just require that people call\n                         // `vec.pop()` or `vec.unshift()`.\n                         let slice_bk = ty::BorrowKind::from_mutbl(slice_mutbl);"}, {"sha": "222da6d7c3e5ef39ca6a6174d7d2b20632557273", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -323,7 +323,7 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n             def_id.krate == ast::LOCAL_CRATE\n         }\n \n-        ty::ty_uniq(_) => { // treat ~T like Box<T>\n+        ty::ty_uniq(_) => { // Box<T>\n             let krate = tcx.lang_items.owned_box().map(|d| d.krate);\n             krate == Some(ast::LOCAL_CRATE)\n         }"}, {"sha": "e199bb17bf94c00333021568f34c43ad65807423", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 106, "deletions": 70, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -117,23 +117,71 @@ pub enum MethodMatchedData {\n /// obligation is for `int`. In that case, we drop the impl out of the\n /// list.  But the other cases are considered *candidates*.\n ///\n-/// Candidates can either be definitive or ambiguous. An ambiguous\n-/// candidate is one that might match or might not, depending on how\n-/// type variables wind up being resolved. This only occurs during inference.\n+/// For selection to succeed, there must be exactly one matching\n+/// candidate. If the obligation is fully known, this is guaranteed\n+/// by coherence. However, if the obligation contains type parameters\n+/// or variables, there may be multiple such impls.\n ///\n-/// For selection to succeed, there must be exactly one non-ambiguous\n-/// candidate.  Usually, it is not possible to have more than one\n-/// definitive candidate, due to the coherence rules. However, there is\n-/// one case where it could occur: if there is a blanket impl for a\n-/// trait (that is, an impl applied to all T), and a type parameter\n-/// with a where clause. In that case, we can have a candidate from the\n-/// where clause and a second candidate from the impl. This is not a\n-/// problem because coherence guarantees us that the impl which would\n-/// be used to satisfy the where clause is the same one that we see\n-/// now. To resolve this issue, therefore, we ignore impls if we find a\n-/// matching where clause. Part of the reason for this is that where\n-/// clauses can give additional information (like, the types of output\n-/// parameters) that would have to be inferred from the impl.\n+/// It is not a real problem if multiple matching impls exist because\n+/// of type variables - it just means the obligation isn't sufficiently\n+/// elaborated. In that case we report an ambiguity, and the caller can\n+/// try again after more type information has been gathered or report a\n+/// \"type annotations required\" error.\n+///\n+/// However, with type parameters, this can be a real problem - type\n+/// parameters don't unify with regular types, but they *can* unify\n+/// with variables from blanket impls, and (unless we know its bounds\n+/// will always be satisfied) picking the blanket impl will be wrong\n+/// for at least *some* substitutions. To make this concrete, if we have\n+///\n+///    trait AsDebug { type Out : fmt::Debug; fn debug(self) -> Self::Out; }\n+///    impl<T: fmt::Debug> AsDebug for T {\n+///        type Out = T;\n+///        fn debug(self) -> fmt::Debug { self }\n+///    }\n+///    fn foo<T: AsDebug>(t: T) { println!(\"{:?}\", <T as AsDebug>::debug(t)); }\n+///\n+/// we can't just use the impl to resolve the <T as AsDebug> obligation\n+/// - a type from another crate (that doesn't implement fmt::Debug) could\n+/// implement AsDebug.\n+///\n+/// Because where-clauses match the type exactly, multiple clauses can\n+/// only match if there are unresolved variables, and we can mostly just\n+/// report this ambiguity in that case. This is still a problem - we can't\n+/// *do anything* with ambiguities that involve only regions. This is issue\n+/// #21974.\n+///\n+/// If a single where-clause matches and there are no inference\n+/// variables left, then it definitely matches and we can just select\n+/// it.\n+///\n+/// In fact, we even select the where-clause when the obligation contains\n+/// inference variables. The can lead to inference making \"leaps of logic\",\n+/// for example in this situation:\n+///\n+///    pub trait Foo<T> { fn foo(&self) -> T; }\n+///    impl<T> Foo<()> for T { fn foo(&self) { } }\n+///    impl Foo<bool> for bool { fn foo(&self) -> bool { *self } }\n+///\n+///    pub fn foo<T>(t: T) where T: Foo<bool> {\n+///       println!(\"{:?}\", <T as Foo<_>>::foo(&t));\n+///    }\n+///    fn main() { foo(false); }\n+///\n+/// Here the obligation <T as Foo<$0>> can be matched by both the blanket\n+/// impl and the where-clause. We select the where-clause and unify $0=bool,\n+/// so the program prints \"false\". However, if the where-clause is omitted,\n+/// the blanket impl is selected, we unify $0=(), and the program prints\n+/// \"()\".\n+///\n+/// Exactly the same issues apply to projection and object candidates, except\n+/// that we can have both a projection candidate and a where-clause candidate\n+/// for the same obligation. In that case either would do (except that\n+/// different \"leaps of logic\" would occur if inference variables are\n+/// present), and we just pick the projection. This is, for example,\n+/// required for associated types to work in default impls, as the bounds\n+/// are visible both as projection bounds and as where-clauses from the\n+/// parameter environment.\n #[derive(PartialEq,Eq,Debug,Clone)]\n enum SelectionCandidate<'tcx> {\n     PhantomFnCandidate,\n@@ -1350,63 +1398,51 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Returns true if `candidate_i` should be dropped in favor of\n     /// `candidate_j`.  Generally speaking we will drop duplicate\n     /// candidates and prefer where-clause candidates.\n+    /// Returns true if `victim` should be dropped in favor of\n+    /// `other`.  Generally speaking we will drop duplicate\n+    /// candidates and prefer where-clause candidates.\n+    ///\n+    /// See the comment for \"SelectionCandidate\" for more details.\n     fn candidate_should_be_dropped_in_favor_of<'o>(&mut self,\n-                                                   candidate_i: &SelectionCandidate<'tcx>,\n-                                                   candidate_j: &SelectionCandidate<'tcx>)\n+                                                   victim: &SelectionCandidate<'tcx>,\n+                                                   other: &SelectionCandidate<'tcx>)\n                                                    -> bool\n     {\n-        if candidate_i == candidate_j {\n+        if victim == other {\n             return true;\n         }\n \n-        match (candidate_i, candidate_j) {\n-            (&ImplCandidate(..), &ParamCandidate(..)) |\n-            (&ClosureCandidate(..), &ParamCandidate(..)) |\n-            (&FnPointerCandidate(..), &ParamCandidate(..)) |\n-            (&BuiltinObjectCandidate(..), &ParamCandidate(_)) |\n-            (&BuiltinCandidate(..), &ParamCandidate(..)) => {\n-                // We basically prefer always prefer to use a\n-                // where-clause over another option. Where clauses\n-                // impose the burden of finding the exact match onto\n-                // the caller. Using an impl in preference of a where\n-                // clause can also lead us to \"overspecialize\", as in\n-                // #18453.\n-                true\n-            }\n-            (&ImplCandidate(..), &ObjectCandidate(..)) => {\n-                // This means that we are matching an object of type\n-                // `Trait` against the trait `Trait`. In that case, we\n-                // always prefer to use the object vtable over the\n-                // impl. Like a where clause, the impl may or may not\n-                // be the one that is used by the object (because the\n-                // impl may have additional where-clauses that the\n-                // object's source might not meet) -- if it is, using\n-                // the vtable is fine. If it is not, using the vtable\n-                // is good. A win win!\n-                true\n-            }\n-            (&DefaultImplCandidate(_), _) => {\n-                // Prefer other candidates over default implementations.\n-                self.tcx().sess.bug(\n-                    \"default implementations shouldn't be recorded \\\n-                     when there are other valid candidates\");\n-            }\n-            (&ProjectionCandidate, &ParamCandidate(_)) => {\n-                // FIXME(#20297) -- this gives where clauses precedent\n-                // over projections. Really these are just two means\n-                // of deducing information (one based on the where\n-                // clauses on the trait definition; one based on those\n-                // on the enclosing scope), and it'd be better to\n-                // integrate them more intelligently. But for now this\n-                // seems ok. If we DON'T give where clauses\n-                // precedence, we run into trouble in default methods,\n-                // where both the projection bounds for `Self::A` and\n-                // the where clauses are in scope.\n-                true\n-            }\n-            _ => {\n-                false\n-            }\n+        match other {\n+            &ObjectCandidate(..) |\n+            &ParamCandidate(_) | &ProjectionCandidate => match victim {\n+                &DefaultImplCandidate(..) => {\n+                    self.tcx().sess.bug(\n+                        \"default implementations shouldn't be recorded \\\n+                         when there are other valid candidates\");\n+                }\n+                &PhantomFnCandidate => {\n+                    self.tcx().sess.bug(\"PhantomFn didn't short-circuit selection\");\n+                }\n+                &ImplCandidate(..) |\n+                &ClosureCandidate(..) |\n+                &FnPointerCandidate(..) |\n+                &BuiltinObjectCandidate(..) |\n+                &DefaultImplObjectCandidate(..) |\n+                &BuiltinCandidate(..) => {\n+                    // We have a where-clause so don't go around looking\n+                    // for impls.\n+                    true\n+                }\n+                &ObjectCandidate(..) |\n+                &ProjectionCandidate => {\n+                    // Arbitrarily give param candidates priority\n+                    // over projection and object candidates.\n+                    true\n+                },\n+                &ParamCandidate(..) => false,\n+                &ErrorCandidate => false // propagate errors\n+            },\n+            _ => false\n         }\n     }\n \n@@ -2441,10 +2477,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// `match_impl()`. For example, if `impl_def_id` is declared\n     /// as:\n     ///\n-    ///    impl<T:Copy> Foo for ~T { ... }\n+    ///    impl<T:Copy> Foo for Box<T> { ... }\n     ///\n-    /// and `obligation_self_ty` is `int`, we'd back an `Err(_)`\n-    /// result. But if `obligation_self_ty` were `~int`, we'd get\n+    /// and `obligation_self_ty` is `int`, we'd get back an `Err(_)`\n+    /// result. But if `obligation_self_ty` were `Box<int>`, we'd get\n     /// back `Ok(T=int)`.\n     fn match_inherent_impl(&mut self,\n                            impl_def_id: ast::DefId,"}, {"sha": "e445b6bb300e3ef1f689234d8cbc05962170c5a9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 36, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -2564,9 +2564,11 @@ impl<'tcx> TraitDef<'tcx> {\n                        tcx: &ctxt<'tcx>,\n                        impl_def_id: DefId,\n                        impl_trait_ref: TraitRef<'tcx>) {\n+        debug!(\"TraitDef::record_impl for {}, from {}\",\n+               self.repr(tcx), impl_trait_ref.repr(tcx));\n+\n         // We don't want to borrow_mut after we already populated all impls,\n         // so check if an impl is present with an immutable borrow first.\n-\n         if let Some(sty) = fast_reject::simplify_type(tcx,\n                                                       impl_trait_ref.self_ty(), false) {\n             if let Some(is) = self.nonblanket_impls.borrow().get(&sty) {\n@@ -6336,10 +6338,10 @@ pub fn populate_implementations_for_primitive_if_necessary(tcx: &ctxt,\n     tcx.populated_external_primitive_impls.borrow_mut().insert(primitive_def_id);\n }\n \n-/// Populates the type context with all the implementations for the given type\n-/// if necessary.\n-pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n-                                                      type_id: ast::DefId) {\n+/// Populates the type context with all the inherent implementations for\n+/// the given type if necessary.\n+pub fn populate_inherent_implementations_for_type_if_necessary(tcx: &ctxt,\n+                                                               type_id: ast::DefId) {\n     if type_id.krate == LOCAL_CRATE {\n         return\n     }\n@@ -6348,37 +6350,15 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n         return\n     }\n \n-    debug!(\"populate_implementations_for_type_if_necessary: searching for {:?}\", type_id);\n+    debug!(\"populate_inherent_implementations_for_type_if_necessary: searching for {:?}\", type_id);\n \n     let mut inherent_impls = Vec::new();\n-    csearch::each_implementation_for_type(&tcx.sess.cstore, type_id, |impl_def_id| {\n-        let impl_items = csearch::get_impl_items(&tcx.sess.cstore, impl_def_id);\n-\n-        // Record the implementation, if needed\n-        if let Some(trait_ref) = csearch::get_impl_trait(tcx, impl_def_id) {\n-            let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n-            trait_def.record_impl(tcx, impl_def_id, trait_ref);\n-        } else {\n-            inherent_impls.push(impl_def_id);\n-        }\n-\n-        // For any methods that use a default implementation, add them to\n-        // the map. This is a bit unfortunate.\n-        for impl_item_def_id in &impl_items {\n-            let method_def_id = impl_item_def_id.def_id();\n-            match impl_or_trait_item(tcx, method_def_id) {\n-                MethodTraitItem(method) => {\n-                    if let Some(source) = method.provided_source {\n-                        tcx.provided_method_sources\n-                           .borrow_mut()\n-                           .insert(method_def_id, source);\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n+    csearch::each_inherent_implementation_for_type(&tcx.sess.cstore, type_id, |impl_def_id| {\n+        // Record the implementation.\n+        inherent_impls.push(impl_def_id);\n \n         // Store the implementation info.\n+        let impl_items = csearch::get_impl_items(&tcx.sess.cstore, impl_def_id);\n         tcx.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n     });\n \n@@ -6388,18 +6368,18 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n \n /// Populates the type context with all the implementations for the given\n /// trait if necessary.\n-pub fn populate_implementations_for_trait_if_necessary(\n-        tcx: &ctxt,\n-        trait_id: ast::DefId) {\n+pub fn populate_implementations_for_trait_if_necessary(tcx: &ctxt, trait_id: ast::DefId) {\n     if trait_id.krate == LOCAL_CRATE {\n         return\n     }\n \n     let def = lookup_trait_def(tcx, trait_id);\n     if def.flags.get().intersects(TraitFlags::IMPLS_VALID) {\n-        return\n+        return;\n     }\n \n+    debug!(\"populate_implementations_for_trait_if_necessary: searching for {}\", def.repr(tcx));\n+\n     if csearch::is_defaulted_trait(&tcx.sess.cstore, trait_id) {\n         record_trait_has_default_impl(tcx, trait_id);\n     }"}, {"sha": "32ec70c487887d51c2bcc4e4929e1659e4596491", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -637,7 +637,7 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n     }\n }\n \n-// This is necessary to handle types like Option<~[T]>, for which\n+// This is necessary to handle types like Option<Vec<T>>, for which\n // autoderef cannot convert the &[T] handler\n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {"}, {"sha": "839b39a8ca003a304170dc613a38241cbfbae8b4", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -732,7 +732,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     /// let p: Point;\n     /// p.x = 22; // ok, even though `p` is uninitialized\n     ///\n-    /// let p: ~Point;\n+    /// let p: Box<Point>;\n     /// (*p).x = 22; // not ok, p is uninitialized, can't deref\n     /// ```\n     fn check_if_assigned_path_is_moved(&self,"}, {"sha": "9a8bbc5ea0bc0c99426fb953e95c2d6730de7327", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -1314,7 +1314,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // impl [... for] Public<...>, but not `impl [... for]\n-                // ~[Public]` or `(Public,)` etc.\n+                // Vec<Public>` or `(Public,)` etc.\n                 let self_is_public_path;\n \n                 // check the properties of the Self type:"}, {"sha": "7e7af8006805d1354ce61e05af3adecdabd4b39f", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 104, "deletions": 4, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -10,8 +10,111 @@\n \n #![allow(non_snake_case)]\n \n+// Error messages for EXXXX errors.\n+// Each message should start and end with a new line, and be wrapped to 80 characters.\n+// In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n+register_long_diagnostics! {\n+\n+E0154: r##\"\n+Imports (`use` statements) are not allowed after non-item statements, such as\n+variable declarations and expression statements.\n+\n+Here is an example that demonstrates the error:\n+```\n+fn f() {\n+    // Variable declaration before import\n+    let x = 0;\n+    use std::io::Read;\n+    ...\n+}\n+```\n+\n+The solution is to declare the imports at the top of the block, function, or\n+file.\n+\n+Here is the previous example again, with the correct order:\n+```\n+fn f() {\n+    use std::io::Read;\n+    let x = 0;\n+    ...\n+}\n+```\n+\n+See the Declaration Statements section of the reference for more information\n+about what constitutes an Item declaration and what does not:\n+\n+http://doc.rust-lang.org/reference.html#statements\n+\"##,\n+\n+E0259: r##\"\n+The name chosen for an external crate conflicts with another external crate that\n+has been imported into the current module.\n+\n+Wrong example:\n+```\n+extern crate a;\n+extern crate crate_a as a;\n+```\n+\n+The solution is to choose a different name that doesn't conflict with any\n+external crate imported into the current module.\n+\n+Correct example:\n+```\n+extern crate a;\n+extern crate crate_a as other_name;\n+```\n+\"##,\n+\n+E0260: r##\"\n+The name for an item declaration conflicts with an external crate's name.\n+\n+For instance,\n+```\n+extern crate abc;\n+\n+struct abc;\n+```\n+\n+There are two possible solutions:\n+\n+Solution #1: Rename the item.\n+\n+```\n+extern crate abc;\n+\n+struct xyz;\n+```\n+\n+Solution #2: Import the crate with a different name.\n+\n+```\n+extern crate abc as xyz;\n+\n+struct abc;\n+```\n+\n+See the Declaration Statements section of the reference for more information\n+about what constitutes an Item declaration and what does not:\n+\n+http://doc.rust-lang.org/reference.html#statements\n+\"##,\n+\n+E0317: r##\"\n+User-defined types or type parameters cannot shadow the primitive types.\n+This error indicates you tried to define a type, struct or enum with the same\n+name as an existing primitive type.\n+\n+See the Types section of the reference for more information about the primitive\n+types:\n+\n+http://doc.rust-lang.org/reference.html#types\n+\"##\n+\n+}\n+\n register_diagnostics! {\n-    E0154,\n     E0157,\n     E0153,\n     E0251, // a named type or value has already been imported in this module\n@@ -22,9 +125,6 @@ register_diagnostics! {\n     E0256, // import conflicts with type in this module\n     E0257, // inherent implementations are only allowed on types defined in the current module\n     E0258, // import conflicts with existing submodule\n-    E0259, // an extern crate has already been imported into this module\n-    E0260, // name conflicts with an external crate that has been imported into this module\n-    E0317, // user-defined types or type parameters cannot shadow the primitive types\n     E0364, // item is private\n     E0365  // item is private\n }"}, {"sha": "447230ada2230fd8e454f6a4b9ed845dce30dd56", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -2688,18 +2688,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                    check_ribs: bool)\n                                    -> AssocItemResolveResult\n     {\n+        let max_assoc_types;\n+\n         match maybe_qself {\n-            Some(&ast::QSelf { position: 0, .. }) =>\n-                return TypecheckRequired,\n-            _ => {}\n+            Some(qself) => {\n+                if qself.position == 0 {\n+                    return TypecheckRequired;\n+                }\n+                max_assoc_types = path.segments.len() - qself.position;\n+                // Make sure the trait is valid.\n+                let _ = self.resolve_trait_reference(id, path, max_assoc_types);\n+            }\n+            None => {\n+                max_assoc_types = path.segments.len();\n+            }\n         }\n-        let max_assoc_types = if let Some(qself) = maybe_qself {\n-            // Make sure the trait is valid.\n-            let _ = self.resolve_trait_reference(id, path, 1);\n-            path.segments.len() - qself.position\n-        } else {\n-            path.segments.len()\n-        };\n \n         let mut resolution = self.with_no_errors(|this| {\n             this.resolve_path(id, path, 0, namespace, check_ribs)"}, {"sha": "9870b41e7fa631783312f98fbcec69e31b5d5b4b", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -618,7 +618,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                namespace_name,\n                                name_bindings.def_for_namespace(namespace));\n                         self.check_for_conflicting_import(\n-                            &import_resolution.target_for_namespace(namespace),\n+                            &import_resolution,\n                             directive.span,\n                             target,\n                             namespace);\n@@ -755,7 +755,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                             // Continue.\n                         }\n                         Some(ref value_target) => {\n-                            self.check_for_conflicting_import(&dest_import_resolution.value_target,\n+                            self.check_for_conflicting_import(&dest_import_resolution,\n                                                               import_directive.span,\n                                                               *ident,\n                                                               ValueNS);\n@@ -767,7 +767,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                             // Continue.\n                         }\n                         Some(ref type_target) => {\n-                            self.check_for_conflicting_import(&dest_import_resolution.type_target,\n+                            self.check_for_conflicting_import(&dest_import_resolution,\n                                                               import_directive.span,\n                                                               *ident,\n                                                               TypeNS);\n@@ -887,24 +887,31 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n     /// Checks that imported names and items don't have the same name.\n     fn check_for_conflicting_import(&mut self,\n-                                    target: &Option<Target>,\n+                                    import_resolution: &ImportResolution,\n                                     import_span: Span,\n                                     name: Name,\n                                     namespace: Namespace) {\n+        let target = import_resolution.target_for_namespace(namespace);\n         debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n                &token::get_name(name),\n                target.is_some());\n \n-        match *target {\n+        match target {\n             Some(ref target) if target.shadowable != Shadowable::Always => {\n-                let msg = format!(\"a {} named `{}` has already been imported \\\n-                                   in this module\",\n-                                  match namespace {\n-                                    TypeNS => \"type\",\n-                                    ValueNS => \"value\",\n-                                  },\n+                let ns_word = match namespace {\n+                    TypeNS => \"type\",\n+                    ValueNS => \"value\",\n+                };\n+                span_err!(self.resolver.session, import_span, E0252,\n+                          \"a {} named `{}` has already been imported \\\n+                           in this module\", ns_word,\n                                   &token::get_name(name));\n-                span_err!(self.resolver.session, import_span, E0252, \"{}\", &msg[..]);\n+                let use_id = import_resolution.id(namespace);\n+                let item = self.resolver.ast_map.expect_item(use_id);\n+                // item is syntax::ast::Item;\n+                span_note!(self.resolver.session, item.span,\n+                            \"previous import of `{}` here\",\n+                            token::get_name(name));\n             }\n             Some(_) | None => {}\n         }"}, {"sha": "38ad909dd012e41eca1c583080256cbbb6cabe2a", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -289,7 +289,7 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n     // when using unix's linker. Perhaps one day when we just use a linker from LLVM\n     // we won't need to do this name mangling. The problem with name mangling is\n     // that it seriously limits the available characters. For example we can't\n-    // have things like &T or ~[T] in symbol names when one would theoretically\n+    // have things like &T in symbol names when one would theoretically\n     // want them for things like impls of traits on that type.\n     //\n     // To be able to work on all platforms and get *some* reasonable output, we"}, {"sha": "504663571f5338e3ed04ae5842398813c8e11d24", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -230,8 +230,8 @@ impl<'a> SpanUtils<'a> {\n     // Reparse span and return an owned vector of sub spans of the first limit\n     // identifier tokens in the given nesting level.\n     // example with Foo<Bar<T,V>, Bar<T,V>>\n-    // Nesting = 0: all idents outside of brackets: ~[Foo]\n-    // Nesting = 1: idents within one level of brackets: ~[Bar, Bar]\n+    // Nesting = 0: all idents outside of brackets: Vec<Foo>\n+    // Nesting = 1: idents within one level of brackets: Vec<Bar, Bar>\n     pub fn spans_with_brackets(&self, span: Span, nesting: isize, limit: isize) -> Vec<Span> {\n         let mut result: Vec<Span> = vec!();\n \n@@ -352,7 +352,7 @@ impl<'a> SpanUtils<'a> {\n             return vec!();\n         }\n         // Type params are nested within one level of brackets:\n-        // i.e. we want ~[A, B] from Foo<A, B<T,U>>\n+        // i.e. we want Vec<A, B> from Foo<A, B<T,U>>\n         self.spans_with_brackets(span, 1, number)\n     }\n "}, {"sha": "132947e34d795e052da61c5214e1960077ad4668", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -196,7 +196,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n             // The `noalias` attribute on the return value is useful to a\n             // function ptr caller.\n             match ret_ty.sty {\n-                // `~` pointer return values never alias because ownership\n+                // `Box` pointer return values never alias because ownership\n                 // is transferred\n                 ty::ty_uniq(it) if common::type_is_sized(ccx.tcx(), it) => {\n                     attrs.ret(llvm::Attribute::NoAlias);\n@@ -239,7 +239,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n                 attrs.arg(idx, llvm::Attribute::ZExt);\n             }\n \n-            // `~` pointer parameters never alias because ownership is transferred\n+            // `Box` pointer parameters never alias because ownership is transferred\n             ty::ty_uniq(inner) => {\n                 let llsz = machine::llsize_of_real(ccx, type_of::type_of(ccx, inner));\n "}, {"sha": "bd04bd7a75460d0e0b44e37f55c7a6aa84e9bebd", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -142,26 +142,24 @@ impl<'tcx> TypeMap<'tcx> {\n     fn get_unique_type_id_of_type<'a>(&mut self, cx: &CrateContext<'a, 'tcx>,\n                                       type_: Ty<'tcx>) -> UniqueTypeId {\n \n-        // basic type           -> {:name of the type:}\n-        // tuple                -> {tuple_(:param-uid:)*}\n-        // struct               -> {struct_:svh: / :node-id:_<(:param-uid:),*> }\n-        // enum                 -> {enum_:svh: / :node-id:_<(:param-uid:),*> }\n-        // enum variant         -> {variant_:variant-name:_:enum-uid:}\n-        // reference (&)        -> {& :pointee-uid:}\n-        // mut reference (&mut) -> {&mut :pointee-uid:}\n-        // ptr (*)              -> {* :pointee-uid:}\n-        // mut ptr (*mut)       -> {*mut :pointee-uid:}\n-        // unique ptr (~)       -> {~ :pointee-uid:}\n-        // @-ptr (@)            -> {@ :pointee-uid:}\n-        // sized vec ([T; x])   -> {[:size:] :element-uid:}\n-        // unsized vec ([T])    -> {[] :element-uid:}\n-        // trait (T)            -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n-        // closure              -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n+        // basic type             -> {:name of the type:}\n+        // tuple                  -> {tuple_(:param-uid:)*}\n+        // struct                 -> {struct_:svh: / :node-id:_<(:param-uid:),*> }\n+        // enum                   -> {enum_:svh: / :node-id:_<(:param-uid:),*> }\n+        // enum variant           -> {variant_:variant-name:_:enum-uid:}\n+        // reference (&)          -> {& :pointee-uid:}\n+        // mut reference (&mut)   -> {&mut :pointee-uid:}\n+        // ptr (*)                -> {* :pointee-uid:}\n+        // mut ptr (*mut)         -> {*mut :pointee-uid:}\n+        // unique ptr (box)       -> {box :pointee-uid:}\n+        // @-ptr (@)              -> {@ :pointee-uid:}\n+        // sized vec ([T; x])     -> {[:size:] :element-uid:}\n+        // unsized vec ([T])      -> {[] :element-uid:}\n+        // trait (T)              -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n+        // closure                -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n         //                             :return-type-uid: : (:bounds:)*}\n-        // function             -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n+        // function               -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n         //                             :return-type-uid:}\n-        // unique vec box (~[]) -> {HEAP_VEC_BOX<:pointee-uid:>}\n-        // gc box               -> {GC_BOX<:pointee-uid:>}\n \n         match self.type_to_unique_id.get(&type_).cloned() {\n             Some(unique_type_id) => return unique_type_id,\n@@ -202,7 +200,7 @@ impl<'tcx> TypeMap<'tcx> {\n                 }\n             },\n             ty::ty_uniq(inner_type) => {\n-                unique_type_id.push('~');\n+                unique_type_id.push_str(\"box \");\n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n                 unique_type_id.push_str(&inner_type_id[..]);"}, {"sha": "54ec1aace92112fe16a1109126004b15fdbacdc6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -1603,7 +1603,8 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                         Some(i as usize)),\n                         _ => {\n                             span_err!(tcx.sess, ast_ty.span, E0249,\n-                                      \"expected constant expr for array length\");\n+                                      \"expected constant integer expression \\\n+                                       for array length\");\n                             this.tcx().types.err\n                         }\n                     }"}, {"sha": "6171df218bb60a468ecec9570881f0c9a7a105d2", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -371,7 +371,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: ast::DefId) {\n         // Read the inherent implementation candidates for this type from the\n         // metadata if necessary.\n-        ty::populate_implementations_for_type_if_necessary(self.tcx(), def_id);\n+        ty::populate_inherent_implementations_for_type_if_necessary(self.tcx(), def_id);\n \n         if let Some(impl_infos) = self.tcx().inherent_impls.borrow().get(&def_id) {\n             for &impl_def_id in &***impl_infos {"}, {"sha": "3769e9fa0f36a025c2b5cbab6fd3963e4ee97abf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -2458,7 +2458,7 @@ fn check_expr_with_lvalue_pref<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, expr: &'tcx ast::\n }\n \n // determine the `self` type, using fresh variables for all variables\n-// declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n+// declared on the impl declaration e.g., `impl<A,B> for Vec<(A,B)>`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n pub fn impl_self_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,"}, {"sha": "4dc1596b1ff7c5d13cbabd4595984ebe9566bfd7", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 77, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -16,13 +16,10 @@\n // mappings. That mapping code resides here.\n \n \n-use metadata::csearch::{each_impl, get_impl_trait};\n-use metadata::csearch;\n use middle::subst::{self, Subst};\n use middle::ty::RegionEscape;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, ConstTraitItemId};\n-use middle::ty::{MethodTraitItemId, TypeTraitItemId};\n-use middle::ty::{ParameterEnvironment, lookup_item_type};\n+use middle::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n use middle::ty::{Ty, ty_bool, ty_char, ty_enum, ty_err};\n use middle::ty::{ty_param, TypeScheme, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n@@ -33,7 +30,6 @@ use middle::ty;\n use CrateCtxt;\n use middle::infer::InferCtxt;\n use middle::infer::new_infer_ctxt;\n-use std::collections::HashSet;\n use std::cell::RefCell;\n use std::rc::Rc;\n use syntax::ast::{Crate, DefId};\n@@ -130,11 +126,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                       Rc::new((*v.borrow()).clone()));\n         }\n \n-        // Bring in external crates. It's fine for this to happen after the\n-        // coherence checks, because we ensure by construction that no errors\n-        // can happen at link time.\n-        self.add_external_crates();\n-\n         // Populate the table of destructors. It might seem a bit strange to\n         // do this here, but it's actually the most convenient place, since\n         // the coherence tables contain the trait -> type mappings.\n@@ -267,11 +258,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         trait_def.record_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n \n-    fn get_self_type_for_implementation(&self, impl_did: DefId)\n-                                        -> TypeScheme<'tcx> {\n-        self.crate_context.tcx.tcache.borrow().get(&impl_did).unwrap().clone()\n-    }\n-\n     // Converts an implementation in the AST to a vector of items.\n     fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n         match item.node {\n@@ -313,66 +299,6 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         }\n     }\n \n-    // External crate handling\n-\n-    fn add_external_impl(&self,\n-                         impls_seen: &mut HashSet<DefId>,\n-                         impl_def_id: DefId) {\n-        let tcx = self.crate_context.tcx;\n-        let impl_items = csearch::get_impl_items(&tcx.sess.cstore,\n-                                                 impl_def_id);\n-\n-        // Make sure we don't visit the same implementation multiple times.\n-        if !impls_seen.insert(impl_def_id) {\n-            // Skip this one.\n-            return\n-        }\n-        // Good. Continue.\n-\n-        let _ = lookup_item_type(tcx, impl_def_id);\n-        let associated_traits = get_impl_trait(tcx, impl_def_id);\n-\n-        // Do a sanity check.\n-        assert!(associated_traits.is_some());\n-\n-        // Record all the trait items.\n-        if let Some(trait_ref) = associated_traits {\n-            self.add_trait_impl(trait_ref, impl_def_id);\n-        }\n-\n-        // For any methods that use a default implementation, add them to\n-        // the map. This is a bit unfortunate.\n-        for item_def_id in &impl_items {\n-            let impl_item = ty::impl_or_trait_item(tcx, item_def_id.def_id());\n-            match impl_item {\n-                ty::MethodTraitItem(ref method) => {\n-                    if let Some(source) = method.provided_source {\n-                        tcx.provided_method_sources\n-                           .borrow_mut()\n-                           .insert(item_def_id.def_id(), source);\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        tcx.impl_items.borrow_mut().insert(impl_def_id, impl_items);\n-    }\n-\n-    // Adds implementations and traits from external crates to the coherence\n-    // info.\n-    fn add_external_crates(&self) {\n-        let mut impls_seen = HashSet::new();\n-\n-        let crate_store = &self.crate_context.tcx.sess.cstore;\n-        crate_store.iter_crate_data(|crate_number, _crate_metadata| {\n-            each_impl(crate_store, crate_number, |def_id| {\n-                assert_eq!(crate_number, def_id.krate);\n-                self.add_external_impl(&mut impls_seen, def_id)\n-            })\n-        })\n-    }\n-\n     //\n     // Destructors\n     //\n@@ -395,7 +321,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n             let method_def_id = items[0];\n \n-            let self_type = self.get_self_type_for_implementation(impl_did);\n+            let self_type = ty::lookup_item_type(tcx, impl_did);\n             match self_type.ty.sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) |\n@@ -451,7 +377,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 return\n             }\n \n-            let self_type = self.get_self_type_for_implementation(impl_did);\n+            let self_type = ty::lookup_item_type(tcx, impl_did);\n             debug!(\"check_implementations_of_copy: self_type={} (bound)\",\n                    self_type.repr(tcx));\n "}, {"sha": "e9c69c84630ef2efc8f9eca5551c6ae9a8f4213d", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -48,14 +48,9 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         // check_for_overlapping_impls_of_trait() check, since that\n         // check can populate this table further with impls from other\n         // crates.\n-        let trait_defs : Vec<&ty::TraitDef> = {\n-            let d = self.tcx.trait_defs.borrow();\n-            d.values().map(|&v|v).collect()\n-        };\n+        let trait_defs: Vec<_> = self.tcx.trait_defs.borrow().values().cloned().collect();\n \n         for trait_def in trait_defs {\n-            // FIXME -- it seems like this method actually pushes\n-            // duplicate impls onto the list\n             ty::populate_implementations_for_trait_if_necessary(\n                 self.tcx,\n                 trait_def.trait_ref.def_id);"}, {"sha": "f9565d528e89a266fd2228d6f2eb143744752e78", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 181, "deletions": 22, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -46,6 +46,23 @@ enum variant, one of the fields was not provided. Each field should be specified\n exactly once.\n \"##,\n \n+E0067: r##\"\n+The left-hand side of an assignment operator must be an lvalue expression. An\n+lvalue expression represents a memory location and includes item paths (ie,\n+namespaced variables), dereferences, indexing expressions, and field references.\n+\n+```\n+use std::collections::LinkedList;\n+\n+// Good\n+let mut list = LinkedList::new();\n+\n+\n+// Bad: assignment to non-lvalue expression\n+LinkedList::new() += 1;\n+```\n+\"##,\n+\n E0081: r##\"\n Enum discriminants are used to differentiate enum variants stored in memory.\n This error indicates that the same value was used for two or more variants,\n@@ -119,6 +136,162 @@ construct an instance of the following type using only safe code:\n ```\n enum Empty {}\n ```\n+\"##,\n+\n+E0131: r##\"\n+It is not possible to define `main` with type parameters, or even with function\n+parameters. When `main` is present, it must take no arguments and return `()`.\n+\"##,\n+\n+E0132: r##\"\n+It is not possible to declare type parameters on a function that has the `start`\n+attribute. Such a function must have the following type signature:\n+\n+```\n+fn(isize, *const *const u8) -> isize\n+```\n+\"##,\n+\n+E0184: r##\"\n+Explicitly implementing both Drop and Copy for a type is currently disallowed.\n+This feature can make some sense in theory, but the current implementation is\n+incorrect and can lead to memory unsafety (see [issue #20126][iss20126]), so\n+it has been disabled for now.\n+\n+[iss20126]: https://github.com/rust-lang/rust/issues/20126\n+\"##,\n+\n+E0204: r##\"\n+An attempt to implement the `Copy` trait for a struct failed because one of the\n+fields does not implement `Copy`. To fix this, you must implement `Copy` for the\n+mentioned field. Note that this may not be possible, as in the example of\n+\n+```\n+struct Foo {\n+    foo : Vec<u32>,\n+}\n+\n+impl Copy for Foo { }\n+```\n+\n+This fails because `Vec<T>` does not implement `Copy` for any `T`.\n+\n+Here's another example that will fail:\n+\n+```\n+#[derive(Copy)]\n+struct Foo<'a> {\n+    ty: &'a mut bool,\n+}\n+```\n+\n+This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n+differs from the behavior for `&T`, which is always `Copy`).\n+\"##,\n+\n+E0205: r##\"\n+An attempt to implement the `Copy` trait for an enum failed because one of the\n+variants does not implement `Copy`. To fix this, you must implement `Copy` for\n+the mentioned variant. Note that this may not be possible, as in the example of\n+\n+```\n+enum Foo {\n+    Bar(Vec<u32>),\n+    Baz,\n+}\n+\n+impl Copy for Foo { }\n+```\n+\n+This fails because `Vec<T>` does not implement `Copy` for any `T`.\n+\n+Here's another example that will fail:\n+\n+```\n+#[derive(Copy)]\n+enum Foo<'a> {\n+    Bar(&'a mut bool),\n+    Baz\n+}\n+```\n+\n+This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n+differs from the behavior for `&T`, which is always `Copy`).\n+\"##,\n+\n+E0206: r##\"\n+You can only implement `Copy` for a struct or enum. Both of the following\n+examples will fail, because neither `i32` (primitive type) nor `&'static Bar`\n+(reference to `Bar`) is a struct or enum:\n+\n+```\n+type Foo = i32;\n+impl Copy for Foo { } // error\n+\n+#[derive(Copy, Clone)]\n+struct Bar;\n+impl Copy for &'static Bar { } // error\n+```\n+\"##,\n+\n+E0243: r##\"\n+This error indicates that not enough type parameters were found in a type or\n+trait.\n+\n+For example, the `Foo` struct below is defined to be generic in `T`, but the\n+type parameter is missing in the definition of `Bar`:\n+\n+```\n+struct Foo<T> { x: T }\n+\n+struct Bar { x: Foo }\n+```\n+\"##,\n+\n+E0244: r##\"\n+This error indicates that too many type parameters were found in a type or\n+trait.\n+\n+For example, the `Foo` struct below has no type parameters, but is supplied\n+with two in the definition of `Bar`:\n+\n+```\n+struct Foo { x: bool }\n+\n+struct Bar<S, T> { x: Foo<S, T> }\n+```\n+\"##,\n+\n+E0249: r##\"\n+This error indicates a constant expression for the array length was found, but\n+it was not an integer (signed or unsigned) expression.\n+\n+Some examples of code that produces this error are:\n+\n+```\n+const A: [u32; \"hello\"] = []; // error\n+const B: [u32; true] = []; // error\n+const C: [u32; 0.0] = []; // error\n+\"##,\n+\n+E0250: r##\"\n+This means there was an error while evaluating the expression for the length of\n+a fixed-size array type.\n+\n+Some examples of code that produces this error are:\n+\n+```\n+// divide by zero in the length expression\n+const A: [u32; 1/0] = [];\n+\n+// Rust currently will not evaluate the function `foo` at compile time\n+fn foo() -> usize { 12 }\n+const B: [u32; foo()] = [];\n+\n+// it is an error to try to add `u8` and `f64`\n+use std::{f64, u8};\n+const C: [u32; u8::MAX + f64::EPSILON] = [];\n+```\n \"##\n \n }\n@@ -133,23 +306,22 @@ register_diagnostics! {\n     E0030,\n     E0031,\n     E0033,\n-    E0034,\n-    E0035,\n-    E0036,\n-    E0038,\n+    E0034, // multiple applicable methods in scope\n+    E0035, // does not take type parameters\n+    E0036, // incorrect number of type parameters given for this method\n+    E0038, // cannot convert to a trait object because trait is not object-safe\n     E0040, // explicit use of destructor method\n-    E0044,\n-    E0045,\n+    E0044, // foreign items may not have type parameters\n+    E0045, // variadic function must have C calling convention\n     E0049,\n     E0050,\n     E0053,\n-    E0055,\n-    E0057,\n+    E0055, // method has an incompatible type for trait\n+    E0057, // method has an incompatible type for trait\n     E0059,\n     E0060,\n     E0061,\n     E0066,\n-    E0067,\n     E0068,\n     E0069,\n     E0070,\n@@ -189,8 +361,6 @@ register_diagnostics! {\n     E0128,\n     E0129,\n     E0130,\n-    E0131,\n-    E0132,\n     E0141,\n     E0159,\n     E0163,\n@@ -204,7 +374,6 @@ register_diagnostics! {\n     E0178,\n     E0182,\n     E0183,\n-    E0184,\n     E0185,\n     E0186,\n     E0187, // can't infer the kind of the closure\n@@ -226,12 +395,6 @@ register_diagnostics! {\n     E0202, // associated items are not allowed in inherent impls\n     E0203, // type parameter has more than one relaxed default bound,\n            // and only one is supported\n-    E0204, // trait `Copy` may not be implemented for this type; field\n-           // does not implement `Copy`\n-    E0205, // trait `Copy` may not be implemented for this type; variant\n-           // does not implement `copy`\n-    E0206, // trait `Copy` may not be implemented for this type; type is\n-           // not a structure or enumeration\n     E0207, // type parameter is not constrained by the impl trait, self type, or predicate\n     E0208,\n     E0209, // builtin traits can only be implemented on structs or enums\n@@ -268,14 +431,10 @@ register_diagnostics! {\n     E0240,\n     E0241,\n     E0242, // internal error looking up a definition\n-    E0243, // wrong number of type arguments\n-    E0244, // wrong number of type arguments\n     E0245, // not a trait\n     E0246, // illegal recursive type\n     E0247, // found module name used as a type\n     E0248, // found value name used as a type\n-    E0249, // expected constant expr for array length\n-    E0250, // expected constant expr for array length\n     E0318, // can't create default impls for traits outside their crates\n     E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck"}, {"sha": "7c062d354d395f2d2cf2408fee973a56be7cd74b", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -178,8 +178,8 @@\n //! further that for whatever reason I specifically supply the value of\n //! `String` for the type parameter `T`:\n //!\n-//!     let mut vector = ~[\"string\", ...];\n-//!     convertAll::<int, String>(v);\n+//!     let mut vector = vec![\"string\", ...];\n+//!     convertAll::<int, String>(vector);\n //!\n //! Is this legal? To put another way, can we apply the `impl` for\n //! `Object` to the type `String`? The answer is yes, but to see why"}, {"sha": "3ce8835b1a8de76744d561010ce4a5794d7e007e", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -221,7 +221,7 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEn\n \n pub fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n                    did: ast::DefId) -> Vec<clean::Item> {\n-    ty::populate_implementations_for_type_if_necessary(tcx, did);\n+    ty::populate_inherent_implementations_for_type_if_necessary(tcx, did);\n     let mut impls = Vec::new();\n \n     match tcx.inherent_impls.borrow().get(&did) {"}, {"sha": "4c2357f8a8f0d05b1df64fbbe00cafe4997a53e0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -897,7 +897,7 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-// maybe use a Generic enum and use ~[Generic]?\n+// maybe use a Generic enum and use Vec<Generic>?\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct Generics {\n     pub lifetimes: Vec<Lifetime>,"}, {"sha": "36cf650d54e9af91d2c395d431ee9d2fab1f00fb", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -905,6 +905,8 @@ impl DocFolder for Cache {\n         // Index this method for searching later on\n         if let Some(ref s) = item.name {\n             let (parent, is_method) = match item.inner {\n+                clean::AssociatedTypeItem(..) |\n+                clean::AssociatedConstItem(..) |\n                 clean::TyMethodItem(..) |\n                 clean::StructFieldItem(..) |\n                 clean::VariantItem(..) => {\n@@ -1862,6 +1864,17 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         try!(write!(w, \"</div>\"));\n     }\n \n+    if !consts.is_empty() {\n+        try!(write!(w, \"\n+            <h2 id='associated-const'>Associated Constants</h2>\n+            <div class='methods'>\n+        \"));\n+        for t in &consts {\n+            try!(trait_item(w, *t));\n+        }\n+        try!(write!(w, \"</div>\"));\n+    }\n+\n     // Output the documentation for each function individually\n     if !required.is_empty() {\n         try!(write!(w, \""}, {"sha": "932a536ab18875a6be23d3f3f02d9656a7bcad8f", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -34,7 +34,8 @@\n                      \"macro\",\n                      \"primitive\",\n                      \"associatedtype\",\n-                     \"constant\"];\n+                     \"constant\",\n+                     \"associatedconstant\"];\n \n     $('.js-only').removeClass('js-only');\n "}, {"sha": "48f65a5abfd453927e0ccbc1b679ae2e6708c8f0", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -916,6 +916,24 @@ impl<K, V, S> HashMap<K, V, S>\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut letters = HashMap::new();\n+    ///\n+    /// for ch in \"a short treatise on fungi\".chars() {\n+    ///     let counter = letters.entry(ch).or_insert(0);\n+    ///     *counter += 1;\n+    /// }\n+    ///\n+    /// assert_eq!(letters[&'s'], 2);\n+    /// assert_eq!(letters[&'t'], 3);\n+    /// assert_eq!(letters[&'u'], 1);\n+    /// assert_eq!(letters.get(&'y'), None);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn entry(&mut self, key: K) -> Entry<K, V> {\n         // Gotta resize now."}, {"sha": "e7b2b01d09f35eea9e12efee7b654d43cdf6ce34", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -844,7 +844,7 @@ impl fmt::Display for CharsError {\n /// An iterator over the contents of an instance of `BufRead` split on a\n /// particular byte.\n ///\n-/// See `BufReadExt::split` for more information.\n+/// See `BufRead::split` for more information.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Split<B> {\n     buf: B,\n@@ -873,7 +873,7 @@ impl<B: BufRead> Iterator for Split<B> {\n /// An iterator over the lines of an instance of `BufRead` split on a newline\n /// byte.\n ///\n-/// See `BufReadExt::lines` for more information.\n+/// See `BufRead::lines` for more information.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Lines<B> {\n     buf: B,"}, {"sha": "934b3156357d64e09a2ea574c78c6be9027ff9d4", "filename": "src/libstd/path.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -1199,7 +1199,7 @@ impl Into<OsString> for PathBuf {\n /// absolute, and so on. More details about the overall approach can be found in\n /// the module documentation.\n ///\n-/// This is an *unsized* type, meaning that it must always be used with behind a\n+/// This is an *unsized* type, meaning that it must always be used behind a\n /// pointer like `&` or `Box`.\n ///\n /// # Examples\n@@ -1449,6 +1449,8 @@ impl Path {\n \n     /// Determines whether `base` is a prefix of `self`.\n     ///\n+    /// Only considers whole path components to match.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1457,6 +1459,8 @@ impl Path {\n     /// let path = Path::new(\"/etc/passwd\");\n     ///\n     /// assert!(path.starts_with(\"/etc\"));\n+    ///\n+    /// assert!(!path.starts_with(\"/e\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn starts_with<P: AsRef<Path>>(&self, base: P) -> bool {\n@@ -1465,6 +1469,8 @@ impl Path {\n \n     /// Determines whether `child` is a suffix of `self`.\n     ///\n+    /// Only considers whole path components to match.\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "2e043c58a5da94e9cf733a59d100d31545c16b78", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -85,6 +85,8 @@ pub struct LocalKey<T> {\n }\n \n /// Declare a new thread local storage key of type `std::thread::LocalKey`.\n+///\n+/// See [LocalKey documentation](thread/struct.LocalKey.html) for more information.\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable]"}, {"sha": "e195c3aaa3f8f8c0b021fb2b6df45d37f0a30364", "filename": "src/libstd/thread/scoped_tls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fscoped_tls.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -66,6 +66,8 @@ pub struct ScopedKey<T> { #[doc(hidden)] pub inner: __impl::KeyInner<T> }\n ///\n /// This macro declares a `static` item on which methods are used to get and\n /// set the value stored within.\n+///\n+/// See [ScopedKey documentation](thread/struct.ScopedKey.html) for more information.\n #[macro_export]\n #[allow_internal_unstable]\n macro_rules! scoped_thread_local {"}, {"sha": "1525f1a822bec5436160b91abb9f9f078383b179", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -904,8 +904,8 @@ impl<'a> MethodDef<'a> {\n                                  nonself_args: &[P<Expr>])\n         -> P<Expr> {\n \n-        let mut raw_fields = Vec::new(); // ~[[fields of self],\n-                                 // [fields of next Self arg], [etc]]\n+        let mut raw_fields = Vec::new(); // Vec<[fields of self],\n+                                 // [fields of next Self arg], [etc]>\n         let mut patterns = Vec::new();\n         for i in 0..self_args.len() {\n             let struct_path= cx.path(DUMMY_SP, vec!( type_ident ));"}, {"sha": "d71557bd7372d6f37a608e2319cc4f664254a53a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -1719,7 +1719,7 @@ mod tests {\n     // induced by visit.  Each of these arrays contains a list of indexes,\n     // interpreted as the varrefs in the varref traversal that this binding\n     // should match.  So, for instance, in a program with two bindings and\n-    // three varrefs, the array ~[~[1,2],~[0]] would indicate that the first\n+    // three varrefs, the array [[1, 2], [0]] would indicate that the first\n     // binding should match the second two varrefs, and the second binding\n     // should match the first varref.\n     //"}, {"sha": "541ec16b415d47ad6c22b1bc994568c0c1af4aaf", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 35, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -109,15 +109,6 @@ pub enum PathParsingMode {\n     LifetimeAndTypesWithColons,\n }\n \n-/// How to parse a qualified path, whether to allow trailing parameters.\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum QPathParsingMode {\n-    /// No trailing parameters, e.g. `<T as Trait>::Item`\n-    NoParameters,\n-    /// Optional parameters, e.g. `<T as Trait>::item::<'a, U>`\n-    MaybeParameters,\n-}\n-\n /// How to parse a bound, whether to allow bound modifiers such as `?`.\n #[derive(Copy, Clone, PartialEq)]\n pub enum BoundParsingMode {\n@@ -1359,7 +1350,7 @@ impl<'a> Parser<'a> {\n         } else if try!(self.eat_lt()) {\n \n             let (qself, path) =\n-                 try!(self.parse_qualified_path(QPathParsingMode::NoParameters));\n+                 try!(self.parse_qualified_path(NoTypesAllowed));\n \n             TyPath(Some(qself), path)\n         } else if self.check(&token::ModSep) ||\n@@ -1578,7 +1569,7 @@ impl<'a> Parser<'a> {\n \n     // QUALIFIED PATH `<TYPE [as TRAIT_REF]>::IDENT[::<PARAMS>]`\n     // Assumes that the leading `<` has been parsed already.\n-    pub fn parse_qualified_path(&mut self, mode: QPathParsingMode)\n+    pub fn parse_qualified_path(&mut self, mode: PathParsingMode)\n                                 -> PResult<(QSelf, ast::Path)> {\n         let self_type = try!(self.parse_ty_sum());\n         let mut path = if try!(self.eat_keyword(keywords::As)) {\n@@ -1599,29 +1590,18 @@ impl<'a> Parser<'a> {\n         try!(self.expect(&token::Gt));\n         try!(self.expect(&token::ModSep));\n \n-        let item_name = try!(self.parse_ident());\n-        let parameters = match mode {\n-            QPathParsingMode::NoParameters => ast::PathParameters::none(),\n-            QPathParsingMode::MaybeParameters => {\n-                if try!(self.eat(&token::ModSep)) {\n-                    try!(self.expect_lt());\n-                    // Consumed `item::<`, go look for types\n-                    let (lifetimes, types, bindings) =\n-                        try!(self.parse_generic_values_after_lt());\n-                    ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n-                        lifetimes: lifetimes,\n-                        types: OwnedSlice::from_vec(types),\n-                        bindings: OwnedSlice::from_vec(bindings),\n-                    })\n-                } else {\n-                    ast::PathParameters::none()\n-                }\n+        let segments = match mode {\n+            LifetimeAndTypesWithoutColons => {\n+                try!(self.parse_path_segments_without_colons())\n+            }\n+            LifetimeAndTypesWithColons => {\n+                try!(self.parse_path_segments_with_colons())\n+            }\n+            NoTypesAllowed => {\n+                try!(self.parse_path_segments_without_types())\n             }\n         };\n-        path.segments.push(ast::PathSegment {\n-            identifier: item_name,\n-            parameters: parameters\n-        });\n+        path.segments.extend(segments);\n \n         if path.segments.len() == 1 {\n             path.span.lo = self.last_span.lo;\n@@ -2096,7 +2076,7 @@ impl<'a> Parser<'a> {\n                 if try!(self.eat_lt()){\n \n                     let (qself, path) =\n-                        try!(self.parse_qualified_path(QPathParsingMode::MaybeParameters));\n+                        try!(self.parse_qualified_path(LifetimeAndTypesWithColons));\n \n                     return Ok(self.mk_expr(lo, hi, ExprPath(Some(qself), path)));\n                 }\n@@ -3176,7 +3156,7 @@ impl<'a> Parser<'a> {\n             let (qself, path) = if try!(self.eat_lt()) {\n                 // Parse a qualified path\n                 let (qself, path) =\n-                    try!(self.parse_qualified_path(QPathParsingMode::NoParameters));\n+                    try!(self.parse_qualified_path(NoTypesAllowed));\n                 (Some(qself), path)\n             } else {\n                 // Parse an unqualified path\n@@ -3270,7 +3250,7 @@ impl<'a> Parser<'a> {\n                     let (qself, path) = if try!(self.eat_lt()) {\n                         // Parse a qualified path\n                         let (qself, path) =\n-                            try!(self.parse_qualified_path(QPathParsingMode::NoParameters));\n+                            try!(self.parse_qualified_path(NoTypesAllowed));\n                         (Some(qself), path)\n                     } else {\n                         // Parse an unqualified path"}, {"sha": "ed9937c53f4af80a27dd02dd3ffb71676fd1623a", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -312,7 +312,7 @@ impl<'a> Printer<'a> {\n         self.token[self.right] = t;\n     }\n     pub fn pretty_print(&mut self, token: Token) -> io::Result<()> {\n-        debug!(\"pp ~[{},{}]\", self.left, self.right);\n+        debug!(\"pp Vec<{},{}>\", self.left, self.right);\n         match token {\n           Token::Eof => {\n             if !self.scan_stack_empty {\n@@ -329,7 +329,7 @@ impl<'a> Printer<'a> {\n                 self.left = 0;\n                 self.right = 0;\n             } else { self.advance_right(); }\n-            debug!(\"pp Begin({})/buffer ~[{},{}]\",\n+            debug!(\"pp Begin({})/buffer Vec<{},{}>\",\n                    b.offset, self.left, self.right);\n             self.token[self.right] = token;\n             self.size[self.right] = -self.right_total;\n@@ -339,10 +339,10 @@ impl<'a> Printer<'a> {\n           }\n           Token::End => {\n             if self.scan_stack_empty {\n-                debug!(\"pp End/print ~[{},{}]\", self.left, self.right);\n+                debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n                 self.print(token, 0)\n             } else {\n-                debug!(\"pp End/buffer ~[{},{}]\", self.left, self.right);\n+                debug!(\"pp End/buffer Vec<{},{}>\", self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = token;\n                 self.size[self.right] = -1;\n@@ -358,7 +358,7 @@ impl<'a> Printer<'a> {\n                 self.left = 0;\n                 self.right = 0;\n             } else { self.advance_right(); }\n-            debug!(\"pp Break({})/buffer ~[{},{}]\",\n+            debug!(\"pp Break({})/buffer Vec<{},{}>\",\n                    b.offset, self.left, self.right);\n             self.check_stack(0);\n             let right = self.right;\n@@ -370,11 +370,11 @@ impl<'a> Printer<'a> {\n           }\n           Token::String(s, len) => {\n             if self.scan_stack_empty {\n-                debug!(\"pp String('{}')/print ~[{},{}]\",\n+                debug!(\"pp String('{}')/print Vec<{},{}>\",\n                        s, self.left, self.right);\n                 self.print(Token::String(s, len), len)\n             } else {\n-                debug!(\"pp String('{}')/buffer ~[{},{}]\",\n+                debug!(\"pp String('{}')/buffer Vec<{},{}>\",\n                        s, self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = Token::String(s, len);\n@@ -386,7 +386,7 @@ impl<'a> Printer<'a> {\n         }\n     }\n     pub fn check_stream(&mut self) -> io::Result<()> {\n-        debug!(\"check_stream ~[{}, {}] with left_total={}, right_total={}\",\n+        debug!(\"check_stream Vec<{}, {}> with left_total={}, right_total={}\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n             debug!(\"scan window is {}, longer than space on line ({})\",\n@@ -446,7 +446,7 @@ impl<'a> Printer<'a> {\n         assert!((self.right != self.left));\n     }\n     pub fn advance_left(&mut self) -> io::Result<()> {\n-        debug!(\"advance_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n+        debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,\n                self.left, self.size[self.left]);\n \n         let mut left_size = self.size[self.left];"}, {"sha": "00ef8760985be4842fd41774a76bd7cbc157db30", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -259,8 +259,8 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn> ) {\n // This will panic (intentionally) when fed any dynamic tests, because\n // it is copying the static values out into a dynamic vector and cannot\n // copy dynamic values. It is doing this because from this point on\n-// a ~[TestDescAndFn] is used in order to effect ownership-transfer\n-// semantics into parallel test runners, which in turn requires a ~[]\n+// a Vec<TestDescAndFn> is used in order to effect ownership-transfer\n+// semantics into parallel test runners, which in turn requires a Vec<>\n // rather than a &[].\n pub fn test_main_static(args: env::Args, tests: &[TestDescAndFn]) {\n     let args = args.collect::<Vec<_>>();"}, {"sha": "cbf13c0a559092fee8af5cbff0ec903c71f65173", "filename": "src/test/compile-fail/double-import.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Fcompile-fail%2Fdouble-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Fcompile-fail%2Fdouble-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdouble-import.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(no_std)]\n+#![no_std]\n+\n+// This tests that conflicting imports shows both `use` lines\n+// when reporting the error.\n+\n+mod sub1 {\n+    fn foo() {} // implementation 1\n+}\n+\n+mod sub2 {\n+    fn foo() {} // implementation 2\n+}\n+\n+use sub1::foo; //~ NOTE previous import of `foo` here\n+use sub2::foo; //~ ERROR a value named `foo` has already been imported in this module [E0252]\n+\n+fn main() {}"}, {"sha": "a48c03aa178c35df84fbe42ea31e8de47bfef79f", "filename": "src/test/compile-fail/issue-20413.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Fcompile-fail%2Fissue-20413.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Fcompile-fail%2Fissue-20413.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20413.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+  fn answer(self);\n+}\n+\n+struct NoData<T>;\n+//~^ ERROR: parameter `T` is never used\n+\n+impl<T> Foo for T where NoData<T>: Foo {\n+//~^ ERROR: overflow evaluating the requirement\n+  fn answer(self) {\n+    let val: NoData<T> = NoData;\n+  }\n+}\n+\n+fn main() {}"}, {"sha": "95ab2bbab14a3e7e2f8f48db73242a2d78e71dc6", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -37,7 +37,7 @@ fn test<'a,T,U:Copy>(_: &'a isize) {\n     assert_copy::<&'static mut isize>(); //~ ERROR `core::marker::Copy` is not implemented\n     assert_copy::<&'a mut isize>();  //~ ERROR `core::marker::Copy` is not implemented\n \n-    // ~ pointers are not ok\n+    // owned pointers are not ok\n     assert_copy::<Box<isize>>();   //~ ERROR `core::marker::Copy` is not implemented\n     assert_copy::<String>();   //~ ERROR `core::marker::Copy` is not implemented\n     assert_copy::<Vec<isize> >(); //~ ERROR `core::marker::Copy` is not implemented"}, {"sha": "dea2a0c5a23f8180c0779c39b6b43f610511b5c3", "filename": "src/test/debuginfo/issue11600.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Fdebuginfo%2Fissue11600.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Fdebuginfo%2Fissue11600.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue11600.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -13,7 +13,7 @@\n // ignore-test\n \n fn main() {\n-    let args : ~[String] = ::std::os::args();\n+    let args : Vec<String> = ::std::os::args();\n     ::std::io::println(args[0]);\n }\n \n@@ -25,6 +25,6 @@ fn main() {\n // compile-flags:-g\n // gdb-command:list\n // gdb-check:1[...]fn main() {\n-// gdb-check:2[...]let args : ~[String] = ::std::os::args();\n+// gdb-check:2[...]let args : Vec<String> = ::std::os::args();\n // gdb-check:3[...]::std::io::println(args[0]);\n // gdb-check:4[...]}"}, {"sha": "4ad0187df7a8f4cea80e21963857ad3eb55a27bd", "filename": "src/test/run-pass/associated-item-long-paths.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frun-pass%2Fassociated-item-long-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frun-pass%2Fassociated-item-long-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-item-long-paths.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem::size_of;\n+\n+// The main point of this test is to ensure that we can parse and resolve\n+// associated items on associated types.\n+\n+trait Foo {\n+    type U;\n+}\n+\n+trait Bar {\n+    // Note 1: Chains of associated items in a path won't type-check.\n+    // Note 2: Associated consts can't depend on type parameters or `Self`,\n+    // which are the only types that an associated type can be referenced on for\n+    // now, so we can only test methods.\n+    fn method() -> u32;\n+    fn generic_method<T>() -> usize;\n+}\n+\n+struct MyFoo;\n+struct MyBar;\n+\n+impl Foo for MyFoo {\n+    type U = MyBar;\n+}\n+\n+impl Bar for MyBar {\n+    fn method() -> u32 {\n+        2u32\n+    }\n+    fn generic_method<T>() -> usize {\n+        size_of::<T>()\n+    }\n+}\n+\n+fn foo<T>()\n+    where T: Foo,\n+          T::U: Bar,\n+{\n+    assert_eq!(2u32, <T as Foo>::U::method());\n+    assert_eq!(8usize, <T as Foo>::U::generic_method::<f64>());\n+}\n+\n+fn main() {\n+    foo::<MyFoo>();\n+}"}, {"sha": "72a23b998e5a16dc587722cfaf9ca54cae3e1308", "filename": "src/test/run-pass/const-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-bound.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -20,7 +20,7 @@ struct F { field: isize }\n pub fn main() {\n     /*foo(1);\n     foo(\"hi\".to_string());\n-    foo(~[1, 2, 3]);\n+    foo(vec![1, 2, 3]);\n     foo(F{field: 42});\n     foo((1, 2));\n     foo(@1);*/"}, {"sha": "5f07ba2235fd539ab24d03ba3a66ac8179ff2024", "filename": "src/test/run-pass/issue-18075.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frun-pass%2Fissue-18075.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frun-pass%2Fissue-18075.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18075.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// exec-env:RUST_LOG=rustc::middle=debug\n+\n+fn main() {\n+    let b = 1isize;\n+    println!(\"{}\", b);\n+}"}, {"sha": "21e5129844498412759ad5ac2f20454a07a98cea", "filename": "src/test/run-pass/issue-23336.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frun-pass%2Fissue-23336.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frun-pass%2Fissue-23336.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23336.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Data { fn doit(&self) {} }\n+impl<T> Data for T {}\n+pub trait UnaryLogic { type D: Data; }\n+impl UnaryLogic for () { type D = i32; }\n+\n+pub fn crashes<T: UnaryLogic>(t: T::D) {\n+    t.doit();\n+}\n+\n+fn main() { crashes::<()>(0); }"}, {"sha": "e6b577ada0c869a55f93d8ec4fa54616fb7e1e94", "filename": "src/test/run-pass/issue-3556.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3556.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -32,10 +32,6 @@ fn check_strs(actual: &str, expected: &str) -> bool\n \n pub fn main()\n {\n-// assert!(check_strs(fmt!(\"%?\", Text(@\"foo\".to_string())), \"Text(@~\\\"foo\\\")\"));\n-// assert!(check_strs(fmt!(\"%?\", ETag(@~[\"foo\".to_string()], @\"bar\".to_string())),\n-//                    \"ETag(@~[ ~\\\"foo\\\" ], @~\\\"bar\\\")\"));\n-\n     let t = Token::Text(\"foo\".to_string());\n     let u = Token::Section(vec![\"alpha\".to_string()],\n                     true,"}, {"sha": "ab75c2064a403667f5edd6168cfacdb25d409e2e", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -22,8 +22,8 @@ use std::io::{ReaderUtil,WriterUtil};\n enum Result {\n   Nil,\n   Int(isize),\n-  Data(~[u8]),\n-  List(~[Result]),\n+  Data(Vec<u8>),\n+  List(Vec<Result>),\n   Error(String),\n   Status(String)\n }\n@@ -35,15 +35,15 @@ fn parse_data(len: usize, io: @io::Reader) -> Result {\n       assert_eq!(bytes.len(), len);\n       Data(bytes)\n   } else {\n-      Data(~[])\n+      Data(vec![])\n   };\n   assert_eq!(io.read_char(), '\\r');\n   assert_eq!(io.read_char(), '\\n');\n   return res;\n }\n \n fn parse_list(len: usize, io: @io::Reader) -> Result {\n-    let mut list: ~[Result] = ~[];\n+    let mut list: Vec<Result> = vec![];\n     for _ in 0..len {\n         let v = match io.read_char() {\n             '$' => parse_bulk(io),\n@@ -72,7 +72,7 @@ fn parse_multi(io: @io::Reader) -> Result {\n     match from_str::<isize>(chop(io.read_line())) {\n     None => panic!(),\n     Some(-1) => Nil,\n-    Some(0) => List(~[]),\n+    Some(0) => List(vec![]),\n     Some(len) if len >= 0 => parse_list(len as usize, io),\n     Some(_) => panic!()\n     }\n@@ -96,7 +96,7 @@ fn parse_response(io: @io::Reader) -> Result {\n     }\n }\n \n-fn cmd_to_string(cmd: ~[String]) -> String {\n+fn cmd_to_string(cmd: Vec<String>) -> String {\n   let mut res = \"*\".to_string();\n   res.push_str(cmd.len().to_string());\n   res.push_str(\"\\r\\n\");\n@@ -107,15 +107,15 @@ fn cmd_to_string(cmd: ~[String]) -> String {\n   res\n }\n \n-fn query(cmd: ~[String], sb: TcpSocketBuf) -> Result {\n+fn query(cmd: Vec<String>, sb: TcpSocketBuf) -> Result {\n   let cmd = cmd_to_string(cmd);\n   //println!(\"{}\", cmd);\n   sb.write_str(cmd);\n   let res = parse_response(@sb as @io::Reader);\n   res\n }\n \n-fn query2(cmd: ~[String]) -> Result {\n+fn query2(cmd: Vec<String>) -> Result {\n   let _cmd = cmd_to_string(cmd);\n     io::with_str_reader(\"$3\\r\\nXXX\\r\\n\".to_string())(|sb| {\n     let res = parse_response(@sb as @io::Reader);"}, {"sha": "6fe510586c74822223e2da6790a2323b76a7ab60", "filename": "src/test/run-pass/slice-of-zero-size-elements.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frun-pass%2Fslice-of-zero-size-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frun-pass%2Fslice-of-zero-size-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-of-zero-size-elements.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C debug-assertions\n+\n+#![feature(core)]\n+\n+use std::slice;\n+\n+fn foo<T>(v: &[T]) -> Option<&[T]> {\n+    let mut it = v.iter();\n+    for _ in 0..5 {\n+        let _ = it.next();\n+    }\n+    Some(it.as_slice())\n+}\n+\n+fn foo_mut<T>(v: &mut [T]) -> Option<&mut [T]> {\n+    let mut it = v.iter_mut();\n+    for _ in 0..5 {\n+        let _ = it.next();\n+    }\n+    Some(it.into_slice())\n+}\n+\n+pub fn main() {\n+    // In a slice of zero-size elements the pointer is meaningless.\n+    // Ensure iteration still works even if the pointer is at the end of the address space.\n+    let slice: &[()] = unsafe { slice::from_raw_parts(-5isize as *const (), 10) };\n+    assert_eq!(slice.len(), 10);\n+    assert_eq!(slice.iter().count(), 10);\n+\n+    // .nth() on the iterator should also behave correctly\n+    let mut it = slice.iter();\n+    assert!(it.nth(5).is_some());\n+    assert_eq!(it.count(), 4);\n+\n+    // Converting Iter to a slice should never have a null pointer\n+    assert!(foo(slice).is_some());\n+\n+    // Test mutable iterators as well\n+    let slice: &mut [()] = unsafe { slice::from_raw_parts_mut(-5isize as *mut (), 10) };\n+    assert_eq!(slice.len(), 10);\n+    assert_eq!(slice.iter_mut().count(), 10);\n+\n+    {\n+        let mut it = slice.iter_mut();\n+        assert!(it.nth(5).is_some());\n+        assert_eq!(it.count(), 4);\n+    }\n+\n+    assert!(foo_mut(slice).is_some())\n+}"}, {"sha": "20d4c744414c6a3e5178e34375c5ef328af4d813", "filename": "src/test/rustdoc/assoc-consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/103e52b1db92b9ac57dcebf5c5738ad5a45155ad/src%2Ftest%2Frustdoc%2Fassoc-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fassoc-consts.rs?ref=103e52b1db92b9ac57dcebf5c5738ad5a45155ad", "patch": "@@ -13,6 +13,7 @@\n pub trait Foo {\n     // @has assoc_consts/trait.Foo.html '//*[@class=\"rust trait\"]' \\\n     //      'const FOO: usize;'\n+    // @has - '//*[@id=\"associatedconstant.FOO\"]' 'const FOO'\n     const FOO: usize;\n }\n "}]}