{"sha": "8b09d046fedf84ed869204bbe0779a0439bbf9eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMDlkMDQ2ZmVkZjg0ZWQ4NjkyMDRiYmUwNzc5YTA0MzliYmY5ZWI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-18T09:41:28Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-19T16:33:08Z"}, "message": "fix LinkedList invalidating mutable references", "tree": {"sha": "aaffd683a5f23932762285c409c66102f0476daa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aaffd683a5f23932762285c409c66102f0476daa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b09d046fedf84ed869204bbe0779a0439bbf9eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b09d046fedf84ed869204bbe0779a0439bbf9eb", "html_url": "https://github.com/rust-lang/rust/commit/8b09d046fedf84ed869204bbe0779a0439bbf9eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b09d046fedf84ed869204bbe0779a0439bbf9eb/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be1dbaffed6858ba176cd69e298c1be365d8f801", "url": "https://api.github.com/repos/rust-lang/rust/commits/be1dbaffed6858ba176cd69e298c1be365d8f801", "html_url": "https://github.com/rust-lang/rust/commit/be1dbaffed6858ba176cd69e298c1be365d8f801"}], "stats": {"total": 48, "additions": 37, "deletions": 11}, "files": [{"sha": "bc1a024e989b0c1abbbc215f4b5fa0fd8044c8f9", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8b09d046fedf84ed869204bbe0779a0439bbf9eb/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b09d046fedf84ed869204bbe0779a0439bbf9eb/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=8b09d046fedf84ed869204bbe0779a0439bbf9eb", "patch": "@@ -86,6 +86,9 @@ impl<T> Clone for Iter<'_, T> {\n /// [`LinkedList`]: struct.LinkedList.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n+    // We do *not* exclusively own the entire list here, references to node's `element`\n+    // have been handed out by the iterator!  So be careful when using this; the methods\n+    // called must be aware that there can be aliasing pointers to `element`.\n     list: &'a mut LinkedList<T>,\n     head: Option<NonNull<Node<T>>>,\n     tail: Option<NonNull<Node<T>>>,\n@@ -143,14 +146,17 @@ impl<T> LinkedList<T> {\n     /// Adds the given node to the front of the list.\n     #[inline]\n     fn push_front_node(&mut self, mut node: Box<Node<T>>) {\n+        // This method takes care not to create mutable references to whole nodes,\n+        // to maintain validity of aliasing pointers into `element`.\n         unsafe {\n             node.next = self.head;\n             node.prev = None;\n             let node = Some(Box::into_raw_non_null(node));\n \n             match self.head {\n                 None => self.tail = node,\n-                Some(mut head) => head.as_mut().prev = node,\n+                // Not creating new mutable (unique!) references overlapping `element`.\n+                Some(head) => (*head.as_ptr()).prev = node,\n             }\n \n             self.head = node;\n@@ -161,13 +167,16 @@ impl<T> LinkedList<T> {\n     /// Removes and returns the node at the front of the list.\n     #[inline]\n     fn pop_front_node(&mut self) -> Option<Box<Node<T>>> {\n+        // This method takes care not to create mutable references to whole nodes,\n+        // to maintain validity of aliasing pointers into `element`.\n         self.head.map(|node| unsafe {\n             let node = Box::from_raw(node.as_ptr());\n             self.head = node.next;\n \n             match self.head {\n                 None => self.tail = None,\n-                Some(mut head) => head.as_mut().prev = None,\n+                // Not creating new mutable (unique!) references overlapping `element`.\n+                Some(head) => (*head.as_ptr()).prev = None,\n             }\n \n             self.len -= 1;\n@@ -178,14 +187,17 @@ impl<T> LinkedList<T> {\n     /// Adds the given node to the back of the list.\n     #[inline]\n     fn push_back_node(&mut self, mut node: Box<Node<T>>) {\n+        // This method takes care not to create mutable references to whole nodes,\n+        // to maintain validity of aliasing pointers into `element`.\n         unsafe {\n             node.next = None;\n             node.prev = self.tail;\n             let node = Some(Box::into_raw_non_null(node));\n \n             match self.tail {\n                 None => self.head = node,\n-                Some(mut tail) => tail.as_mut().next = node,\n+                // Not creating new mutable (unique!) references overlapping `element`.\n+                Some(tail) => (*tail.as_ptr()).next = node,\n             }\n \n             self.tail = node;\n@@ -196,13 +208,16 @@ impl<T> LinkedList<T> {\n     /// Removes and returns the node at the back of the list.\n     #[inline]\n     fn pop_back_node(&mut self) -> Option<Box<Node<T>>> {\n+        // This method takes care not to create mutable references to whole nodes,\n+        // to maintain validity of aliasing pointers into `element`.\n         self.tail.map(|node| unsafe {\n             let node = Box::from_raw(node.as_ptr());\n             self.tail = node.prev;\n \n             match self.tail {\n                 None => self.head = None,\n-                Some(mut tail) => tail.as_mut().next = None,\n+                // Not creating new mutable (unique!) references overlapping `element`.\n+                Some(tail) => (*tail.as_ptr()).next = None,\n             }\n \n             self.len -= 1;\n@@ -213,18 +228,22 @@ impl<T> LinkedList<T> {\n     /// Unlinks the specified node from the current list.\n     ///\n     /// Warning: this will not check that the provided node belongs to the current list.\n+    ///\n+    /// This method takes care not to create mutable references to `element`, to\n+    /// maintain validity of aliasing pointers.\n     #[inline]\n     unsafe fn unlink_node(&mut self, mut node: NonNull<Node<T>>) {\n-        let node = node.as_mut();\n+        let node = node.as_mut(); // this one is ours now, we can create an &mut.\n \n+        // Not creating new mutable (unique!) references overlapping `element`.\n         match node.prev {\n-            Some(mut prev) => prev.as_mut().next = node.next.clone(),\n+            Some(prev) => (*prev.as_ptr()).next = node.next.clone(),\n             // this node is the head node\n             None => self.head = node.next.clone(),\n         };\n \n         match node.next {\n-            Some(mut next) => next.as_mut().prev = node.prev.clone(),\n+            Some(next) => (*next.as_ptr()).prev = node.prev.clone(),\n             // this node is the tail node\n             None => self.tail = node.prev.clone(),\n         };\n@@ -297,6 +316,8 @@ impl<T> LinkedList<T> {\n         match self.tail {\n             None => mem::swap(self, other),\n             Some(mut tail) => {\n+                // `as_mut` is okay here because we have exclusive access to the entirety\n+                // of both lists.\n                 if let Some(mut other_head) = other.head.take() {\n                     unsafe {\n                         tail.as_mut().next = Some(other_head);\n@@ -916,9 +937,11 @@ impl<T> IterMut<'_, T> {\n                issue = \"27794\")]\n     pub fn insert_next(&mut self, element: T) {\n         match self.head {\n+            // `push_back` is okay with aliasing `element` references\n             None => self.list.push_back(element),\n-            Some(mut head) => unsafe {\n-                let mut prev = match head.as_ref().prev {\n+            Some(head) => unsafe {\n+                let prev = match head.as_ref().prev {\n+                    // `push_front` is okay with aliasing nodes\n                     None => return self.list.push_front(element),\n                     Some(prev) => prev,\n                 };\n@@ -929,8 +952,10 @@ impl<T> IterMut<'_, T> {\n                     element,\n                 }));\n \n-                prev.as_mut().next = node;\n-                head.as_mut().prev = node;\n+                // Not creating references to entire nodes to not invalidate the\n+                // reference to `element` we handed to the user.\n+                (*prev.as_ptr()).next = node;\n+                (*head.as_ptr()).prev = node;\n \n                 self.list.len += 1;\n             },\n@@ -994,6 +1019,7 @@ impl<T, F> Iterator for DrainFilter<'_, T, F>\n                 self.idx += 1;\n \n                 if (self.pred)(&mut node.as_mut().element) {\n+                    // `unlink_node` is okay with aliasing `element` references.\n                     self.list.unlink_node(node);\n                     return Some(Box::from_raw(node.as_ptr()).element);\n                 }"}]}