{"sha": "6473a87cec100682764f4d926541fc7eb455b00c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0NzNhODdjZWMxMDA2ODI3NjRmNGQ5MjY1NDFmYzdlYjQ1NWIwMGM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-02T03:37:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-02T14:47:25Z"}, "message": "restructure to better support method inlining", "tree": {"sha": "695fd8037c9ee0b1f932ad4864ed867b05270d55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/695fd8037c9ee0b1f932ad4864ed867b05270d55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6473a87cec100682764f4d926541fc7eb455b00c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6473a87cec100682764f4d926541fc7eb455b00c", "html_url": "https://github.com/rust-lang/rust/commit/6473a87cec100682764f4d926541fc7eb455b00c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6473a87cec100682764f4d926541fc7eb455b00c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "def72bda47977b3bc36143eba9692bff12a8303c", "url": "https://api.github.com/repos/rust-lang/rust/commits/def72bda47977b3bc36143eba9692bff12a8303c", "html_url": "https://github.com/rust-lang/rust/commit/def72bda47977b3bc36143eba9692bff12a8303c"}], "stats": {"total": 458, "additions": 270, "deletions": 188}, "files": [{"sha": "bd1309c7c86033f2b2855e7672b766d18f212f7c", "filename": "src/comp/metadata/astencode.rs", "status": "modified", "additions": 42, "deletions": 108, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fastencode.rs?ref=6473a87cec100682764f4d926541fc7eb455b00c", "patch": "@@ -2,6 +2,7 @@ import syntax::ast;\n import syntax::fold;\n import syntax::visit;\n import syntax::ast_util;\n+import syntax::ast_util::inlined_item_methods;\n import syntax::codemap::span;\n import std::map::map;\n import std::smallintmap::map;\n@@ -31,8 +32,6 @@ import syntax::print::pprust;\n \n export encode_inlined_item;\n export decode_inlined_item;\n-export encode_inlined_method;\n-export decode_inlined_method;\n \n type decode_ctxt = @{\n     cdata: cstore::crate_metadata,\n@@ -53,123 +52,49 @@ iface tr {\n // ______________________________________________________________________\n // Top-level methods.\n \n-// The type inline_fn should be a type that can represent both methods\n-// and top-level items. As it happens, the type ast::method is perfect\n-// for this purpose, but I use this typedef just to keep clear when\n-// the thing may not, in fact, be an actual method in the AST but\n-// rather some sort of function.\n-enum inline_fn = @ast::method;\n-\n fn encode_inlined_item(ecx: @e::encode_ctxt,\n                        ebml_w: ebml::writer,\n                        path: ast_map::path,\n-                       item: @ast::item) {\n-    let ifn = inline_fn(alt item.node {\n-      ast::item_fn(decl, tps, body) {\n-          @{ident: item.ident,\n-            attrs: item.attrs,\n-            tps: tps,\n-            decl: decl,\n-            body: body,\n-            id: item.id,\n-            span: item.span}\n-      }\n-\n-      _ {\n-          ecx.ccx.sess.span_bug(item.span, \"Cannot inline non-function\")\n-      }\n-    });\n-\n-    encode_inlined_fn(ecx, ebml_w, path, ifn);\n-}\n-\n-fn decode_inlined_item(cdata: cstore::crate_metadata,\n-                       tcx: ty::ctxt,\n-                       maps: maps,\n-                       path: ast_map::path,\n-                       par_doc: ebml::doc) -> option<@ast::item> {\n-    let oifn = decode_inlined_fn(cdata, tcx, maps, path, par_doc);\n-    option::map(oifn) {|ifn|\n-        let item = @{ident: ifn.ident,\n-                     attrs: ifn.attrs,\n-                     id: ifn.id,\n-                     node: ast::item_fn(ifn.decl, ifn.tps, ifn.body),\n-                     span: ifn.span};\n-        ast_map::map_decoded_item(tcx.items, path, item);\n-        item\n-    }\n-}\n-\n-fn encode_inlined_method(ecx: @e::encode_ctxt,\n-                         ebml_w: ebml::writer,\n-                         path: ast_map::path,\n-                         mthd: @ast::method) {\n-    encode_inlined_fn(ecx, ebml_w, path, inline_fn(mthd))\n-}\n-\n-fn decode_inlined_method(cdata: cstore::crate_metadata,\n-                         tcx: ty::ctxt,\n-                         maps: maps,\n-                         path: ast_map::path,\n-                         par_doc: ebml::doc) -> option<@ast::method> {\n-    let oifn = decode_inlined_fn(cdata, tcx, maps, path, par_doc);\n-    option::map(oifn) {|ifn|\n-        ast_map::map_decoded_method(tcx.items, path, *ifn);\n-        *ifn\n-    }\n-}\n-\n-fn encode_inlined_fn(ecx: @e::encode_ctxt,\n-                     ebml_w: ebml::writer,\n-                     path: ast_map::path,\n-                     ifn: inline_fn) {\n-\n+                       ii: ast::inlined_item) {\n     #debug[\"> Encoding inlined item: %s::%s (%u)\",\n-           ast_map::path_to_str(path),\n-           ifn.ident,\n+           ast_map::path_to_str(path), ii.ident(),\n            ebml_w.writer.tell()];\n \n-    let id_range = compute_id_range(ifn);\n+    let id_range = compute_id_range(ii);\n     ebml_w.wr_tag(c::tag_ast as uint) {||\n         encode_id_range(ebml_w, id_range);\n-        encode_ast(ebml_w, ifn);\n-        encode_side_tables_for_ifn(ecx, ebml_w, ifn);\n+        encode_ast(ebml_w, ii);\n+        encode_side_tables_for_ii(ecx, ebml_w, ii);\n     }\n \n     #debug[\"< Encoded inlined fn: %s::%s (%u)\",\n-           ast_map::path_to_str(path),\n-           ifn.ident,\n+           ast_map::path_to_str(path), ii.ident(),\n            ebml_w.writer.tell()];\n }\n \n-// Decodes the inlined function and associated side tables.  Does\n-// *not* insert the function into the ast_map, since the correct way\n-// to do this depends on whether this is an inlined item or method;\n-// therefore, you ought to be invoking decode_inlined_item() or\n-// decode_inlined_method() and not this helper function.\n-fn decode_inlined_fn(cdata: cstore::crate_metadata,\n-                     tcx: ty::ctxt,\n-                     maps: maps,\n-                     path: ast_map::path,\n-                     par_doc: ebml::doc) -> option<inline_fn> {\n+fn decode_inlined_item(cdata: cstore::crate_metadata,\n+                       tcx: ty::ctxt,\n+                       maps: maps,\n+                       path: ast_map::path,\n+                       par_doc: ebml::doc) -> option<ast::inlined_item> {\n     let dcx = @{cdata: cdata, tcx: tcx, maps: maps};\n     alt par_doc.opt_child(c::tag_ast) {\n       none { none }\n       some(ast_doc) {\n-        #debug[\"> Decoding inlined fn: %s\", ast_map::path_to_str(path)];\n+        #debug[\"> Decoding inlined fn: %s::?\", ast_map::path_to_str(path)];\n         let from_id_range = decode_id_range(ast_doc);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n         let xcx = @{dcx: dcx,\n                     from_id_range: from_id_range,\n                     to_id_range: to_id_range};\n-        let raw_ifn = decode_ast(ast_doc);\n-        let ifn = renumber_ast(xcx, raw_ifn);\n-        #debug[\"Fn named: %s\", ifn.ident];\n+        let raw_ii = decode_ast(ast_doc);\n+        let ii = renumber_ast(xcx, raw_ii);\n+        ast_map::map_decoded_item(dcx.tcx.items, path, ii);\n+        #debug[\"Fn named: %s\", ii.ident()];\n         decode_side_tables(xcx, ast_doc);\n         #debug[\"< Decoded inlined fn: %s::%s\",\n-               ast_map::path_to_str(path),\n-               ifn.ident];\n-        some(ifn)\n+               ast_map::path_to_str(path), ii.ident()];\n+        some(ii)\n       }\n     }\n }\n@@ -183,7 +108,7 @@ fn empty(range: id_range) -> bool {\n     range.min >= range.max\n }\n \n-fn visit_ids(ifn: inline_fn, vfn: fn@(ast::node_id)) {\n+fn visit_ids(item: ast::inlined_item, vfn: fn@(ast::node_id)) {\n     let visitor = visit::mk_simple_visitor(@{\n         visit_mod: fn@(_m: ast::_mod, _sp: span, id: ast::node_id) {\n             vfn(id)\n@@ -292,13 +217,13 @@ fn visit_ids(ifn: inline_fn, vfn: fn@(ast::node_id)) {\n         }\n     });\n \n-    visit::visit_method_helper(*ifn, (), visitor);\n+    item.accept((), visitor)\n }\n \n-fn compute_id_range(ifn: inline_fn) -> id_range {\n+fn compute_id_range(item: ast::inlined_item) -> id_range {\n     let min = @mutable int::max_value;\n     let max = @mutable int::min_value;\n-    visit_ids(ifn) {|id|\n+    visit_ids(item) {|id|\n         *min = int::min(*min, id);\n         *max = int::max(*max, id + 1);\n     }\n@@ -395,25 +320,34 @@ impl deserializer_helpers<D: serialization::deserializer> for D {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: ebml::writer, ifn: inline_fn) {\n+fn encode_ast(ebml_w: ebml::writer, item: ast::inlined_item) {\n     ebml_w.wr_tag(c::tag_tree as uint) {||\n-        astencode_gen::serialize_syntax_ast_method(ebml_w, **ifn)\n+        astencode_gen::serialize_syntax_ast_inlined_item(ebml_w, item)\n     }\n }\n \n-fn decode_ast(par_doc: ebml::doc) -> inline_fn {\n+fn decode_ast(par_doc: ebml::doc) -> ast::inlined_item {\n     let chi_doc = par_doc[c::tag_tree];\n     let d = serialization::mk_ebml_deserializer(chi_doc);\n-    inline_fn(@astencode_gen::deserialize_syntax_ast_method(d))\n+    astencode_gen::deserialize_syntax_ast_inlined_item(d)\n }\n \n-fn renumber_ast(xcx: extended_decode_ctxt, ifn: inline_fn) -> inline_fn {\n+fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n+    -> ast::inlined_item {\n     let fld = fold::make_fold({\n         new_id: xcx.tr_id(_),\n         new_span: xcx.tr_span(_)\n         with *fold::default_ast_fold()\n     });\n-    inline_fn(fld.fold_method(*ifn))\n+\n+    alt ii {\n+      ast::ii_item(i) {\n+        ast::ii_item(fld.fold_item(i))\n+      }\n+      ast::ii_method(d, m) {\n+        ast::ii_method(xcx.tr_def_id(d), fld.fold_method(m))\n+      }\n+    }\n }\n \n // ______________________________________________________________________\n@@ -664,11 +598,11 @@ impl writer for ebml::writer {\n     }\n }\n \n-fn encode_side_tables_for_ifn(ecx: @e::encode_ctxt,\n-                              ebml_w: ebml::writer,\n-                              ifn: inline_fn) {\n+fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n+                             ebml_w: ebml::writer,\n+                             ii: ast::inlined_item) {\n     ebml_w.wr_tag(c::tag_table as uint) {||\n-        visit_ids(ifn, fn@(id: ast::node_id) {\n+        visit_ids(ii, fn@(id: ast::node_id) {\n             // Note: this will cause a copy of ebml_w, which is bad as\n             // it has mutable fields.  But I believe it's harmless since\n             // we generate balanced EBML."}, {"sha": "1c413de261ca14d649f96897ab46907484f26d9f", "filename": "src/comp/metadata/astencode_gen.rs", "status": "modified", "additions": 79, "deletions": 7, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmetadata%2Fastencode_gen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmetadata%2Fastencode_gen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fastencode_gen.rs?ref=6473a87cec100682764f4d926541fc7eb455b00c", "patch": "@@ -8748,12 +8748,84 @@ fn deserialize_syntax_ast_def_id<S: std::serialization::deserializer>(s: S) ->\n    syntax::ast::def_id {\n     deserialize_162(s)\n }\n-fn serialize_syntax_ast_method<S: std::serialization::serializer>(s: S,\n-                                                                  v:\n-                                                                      syntax::ast::method) {\n-    serialize_160(s, v);\n+/*syntax::ast::inlined_item*/\n+fn serialize_168<S: std::serialization::serializer>(s: S,\n+                                                    v:\n+                                                        syntax::ast::inlined_item) {\n+    s.emit_enum(\"syntax::ast::inlined_item\",\n+                /*@syntax::ast::item*/\n+                /*syntax::ast::def_id*//*@syntax::ast::method*/\n+                {||\n+                    alt v {\n+                      syntax::ast::ii_item(v0) {\n+                        s.emit_enum_variant(\"syntax::ast::ii_item\", 0u, 1u,\n+                                            {||\n+                                                {\n+                                                    s.emit_enum_variant_arg(0u,\n+                                                                            {||\n+                                                                                serialize_117(s,\n+                                                                                              v0)\n+                                                                            })\n+                                                }\n+                                            })\n+                      }\n+                      syntax::ast::ii_method(v0, v1) {\n+                        s.emit_enum_variant(\"syntax::ast::ii_method\", 1u, 2u,\n+                                            {||\n+                                                {\n+                                                    s.emit_enum_variant_arg(0u,\n+                                                                            {||\n+                                                                                serialize_162(s,\n+                                                                                              v0)\n+                                                                            });\n+                                                    s.emit_enum_variant_arg(1u,\n+                                                                            {||\n+                                                                                serialize_159(s,\n+                                                                                              v1)\n+                                                                            })\n+                                                }\n+                                            })\n+                      }\n+                    }\n+                });\n }\n-fn deserialize_syntax_ast_method<S: std::serialization::deserializer>(s: S) ->\n-   syntax::ast::method {\n-    deserialize_160(s)\n+fn serialize_syntax_ast_inlined_item<S: std::serialization::serializer>(s: S,\n+                                                                        v:\n+                                                                            syntax::ast::inlined_item) {\n+    serialize_168(s, v);\n+}\n+/*syntax::ast::inlined_item*/\n+fn deserialize_168<S: std::serialization::deserializer>(s: S) ->\n+   syntax::ast::inlined_item {\n+    s.read_enum(\"syntax::ast::inlined_item\",\n+                /*@syntax::ast::item*/\n+\n+                /*syntax::ast::def_id*//*@syntax::ast::method*/\n+                {||\n+                    s.read_enum_variant({|v_id|\n+                                            alt check v_id {\n+                                              0u {\n+                                                syntax::ast::ii_item(s.read_enum_variant_arg(0u,\n+                                                                                             {||\n+                                                                                                 deserialize_117(s)\n+                                                                                             }))\n+                                              }\n+                                              1u {\n+                                                syntax::ast::ii_method(s.read_enum_variant_arg(0u,\n+                                                                                               {||\n+                                                                                                   deserialize_162(s)\n+                                                                                               }),\n+                                                                       s.read_enum_variant_arg(1u,\n+                                                                                               {||\n+                                                                                                   deserialize_159(s)\n+                                                                                               }))\n+                                              }\n+                                            }\n+                                        })\n+                })\n+}\n+fn deserialize_syntax_ast_inlined_item<S: std::serialization::deserializer>(s:\n+                                                                                S)\n+   -> syntax::ast::inlined_item {\n+    deserialize_168(s)\n }"}, {"sha": "7dbf8dde75aa385434dee6a560eebb6b7b6a7a5d", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=6473a87cec100682764f4d926541fc7eb455b00c", "patch": "@@ -79,7 +79,7 @@ fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n // not marked for inlining, then the AST will not be present and hence none\n // will be returned.\n fn maybe_get_item_ast(tcx: ty::ctxt, maps: maps, def: ast::def_id)\n-    -> option<@ast::item> {\n+    -> option<ast::inlined_item> {\n     let cstore = tcx.sess.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::maybe_get_item_ast(cdata, tcx, maps, def.node)"}, {"sha": "196789ee58cb211fa45652ec60b2608d62bc00e2", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=6473a87cec100682764f4d926541fc7eb455b00c", "patch": "@@ -264,7 +264,7 @@ fn get_item_path(cdata: cmd, id: ast::node_id) -> ast_map::path {\n }\n \n fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt, maps: maps,\n-                      id: ast::node_id) -> option<@ast::item> {\n+                      id: ast::node_id) -> option<ast::inlined_item> {\n     let item_doc = lookup_item(id, cdata.data);\n     let path = vec::init(item_path(item_doc));\n     astencode::decode_inlined_item(cdata, tcx, maps, path, item_doc)"}, {"sha": "57507b8d8f933d0f87761b5d4fb283f8fa2c9071", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=6473a87cec100682764f4d926541fc7eb455b00c", "patch": "@@ -352,7 +352,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_symbol(ecx, ebml_w, item.id);\n         encode_path(ebml_w, path, ast_map::path_name(item.ident));\n         if should_inline(path, item) {\n-            astencode::encode_inlined_item(ecx, ebml_w, path, item);\n+            astencode::encode_inlined_item(ecx, ebml_w, path, ii_item(item));\n         }\n         ebml_w.end_tag();\n       }"}, {"sha": "673b36491914fb65843c6c386d089fdb6f12ca1b", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=6473a87cec100682764f4d926541fc7eb455b00c", "patch": "@@ -1,6 +1,7 @@\n import std::map;\n import syntax::ast::*;\n import syntax::ast_util;\n+import syntax::ast_util::inlined_item_methods;\n import syntax::{visit, codemap};\n \n enum path_elt { path_mod(str), path_name(str) }\n@@ -23,7 +24,7 @@ fn path_to_str(p: path) -> str {\n enum ast_node {\n     node_item(@item, @path),\n     node_native_item(@native_item, @path),\n-    node_method(@method, node_id, @path),\n+    node_method(@method, def_id, @path),\n     node_variant(variant, def_id, @path),\n     node_expr(@expr),\n     // Locals are numbered, because the alias analysis needs to know in which\n@@ -59,7 +60,7 @@ fn map_crate(c: crate) -> map {\n \n // Used for items loaded from external crate that are being inlined into this\n // crate:\n-fn map_decoded_item(map: map, path: path, i: @item) {\n+fn map_decoded_item(map: map, path: path, ii: inlined_item) {\n     // I believe it is ok for the local IDs of inlined items from other crates\n     // to overlap with the local ids from this crate, so just generate the ids\n     // starting from 0.  (In particular, I think these ids are only used in\n@@ -70,16 +71,7 @@ fn map_decoded_item(map: map, path: path, i: @item) {\n               mutable path: path,\n               mutable local_id: 0u};\n     let v = mk_ast_map_visitor();\n-    v.visit_item(i, cx, v);\n-}\n-\n-fn map_decoded_method(map: map, path: path, m: @method) {\n-    // As above.\n-    let cx = {map: map,\n-              mutable path: path,\n-              mutable local_id: 0u};\n-    let v = mk_ast_map_visitor();\n-    visit::visit_method_helper(m, cx, v);\n+    ii.accept(cx, v);\n }\n \n fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n@@ -117,7 +109,8 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n     cx.map.insert(i.id, node_item(i, @cx.path));\n     alt i.node {\n       item_impl(_, _, _, ms) {\n-        for m in ms { cx.map.insert(m.id, node_method(m, i.id, @cx.path)); }\n+        let implid = ast_util::local_def(i.id);\n+        for m in ms { cx.map.insert(m.id, node_method(m, implid, @cx.path)); }\n       }\n       item_res(_, _, _, dtor_id, ctor_id) {\n         cx.map.insert(ctor_id, node_res_ctor(i));"}, {"sha": "91d69168fafd710a0bb5c569aa69186bf4dcd39e", "filename": "src/comp/middle/inline.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmiddle%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmiddle%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Finline.rs?ref=6473a87cec100682764f4d926541fc7eb455b00c", "patch": "@@ -1,6 +1,7 @@\n import std::map::hashmap;\n import syntax::ast;\n import syntax::ast_util;\n+import syntax::ast_util::inlined_item_methods;\n import syntax::visit;\n import middle::typeck::method_map;\n import middle::trans::common::maps;\n@@ -9,13 +10,13 @@ import metadata::csearch;\n export inline_map;\n export instantiate_inlines;\n \n-type inline_map = hashmap<ast::def_id, @ast::item>;\n+type inline_map = hashmap<ast::def_id, ast::inlined_item>;\n \n enum ctxt = {\n     tcx: ty::ctxt,\n     maps: maps,\n     inline_map: inline_map,\n-    mutable to_process: [@ast::item]\n+    mut to_process: [ast::inlined_item]\n };\n \n fn instantiate_inlines(enabled: bool,\n@@ -37,7 +38,9 @@ fn instantiate_inlines(enabled: bool,\n         let to_process = [];\n         to_process <-> cx.to_process;\n         #debug[\"Recursively looking at inlined items\"];\n-        vec::iter(to_process, {|i| visit::visit_item(i, cx, vt)});\n+        vec::iter(to_process) {|ii|\n+            ii.accept(cx, vt);\n+        }\n     }\n     ret inline_map;\n }\n@@ -78,20 +81,20 @@ impl methods for ctxt {\n             #debug[\"No AST attached to def %s\",\n                    ty::item_path_str(self.tcx, did)];\n           }\n-          some(item) { /* Found an AST, add to table: */\n+          some(ii) { /* Found an AST, add to table: */\n             #debug[\"Inlining def %s\", ty::item_path_str(self.tcx, did)];\n-            self.to_process += [item];\n-            self.inline_map.insert(did, item);\n+            self.to_process += [ii];\n+            self.inline_map.insert(did, ii);\n           }\n         }\n     }\n \n-    fn maybe_enqueue_impl_method(_origin: typeck::method_origin) {\n-        // alt method_origin {\n-        //   method_static(did) { self.maybe_enqueue_fn(did); }\n-        //   method_param(_, _, _, _) | method_iface(_, _) {\n-        //     /* fallthrough */\n-        //   }\n-        // }\n+    fn maybe_enqueue_impl_method(method_origin: typeck::method_origin) {\n+        alt method_origin {\n+          typeck::method_static(did) { self.maybe_enqueue_fn(did); }\n+          typeck::method_param(_, _, _, _) | typeck::method_iface(_, _) {\n+            /* fallthrough */\n+          }\n+        }\n     }\n }"}, {"sha": "846417fcb4456952da8bf52af4474702307f6f68", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 87, "deletions": 38, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=6473a87cec100682764f4d926541fc7eb455b00c", "patch": "@@ -23,6 +23,7 @@ import front::attr;\n import middle::inline::inline_map;\n import back::{link, abi, upcall};\n import syntax::{ast, ast_util, codemap};\n+import ast_util::inlined_item_methods;\n import ast_util::local_def;\n import syntax::visit;\n import syntax::codemap::span;\n@@ -2105,8 +2106,8 @@ fn monomorphic_fn(ccx: crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n         trans_enum_variant(ccx, enum_id.node, v, this_tv.disr_val,\n                            (*tvs).len() == 1u, [], psubsts, lldecl);\n       }\n-      ast_map::node_method(mth, impl_id, _) {\n-        let selfty = ty::node_id_to_type(ccx.tcx, impl_id);\n+      ast_map::node_method(mth, impl_def_id, _) {\n+        let selfty = ty::lookup_item_type(ccx.tcx, impl_def_id).ty;\n         let selfty = ty::substitute_type_params(ccx.tcx, substs, selfty);\n         trans_fn(ccx, pt, mth.decl, mth.body, lldecl,\n                  impl_self(selfty), [], psubsts, fn_id.node);\n@@ -2131,12 +2132,12 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n         } else {\n             alt ccx.inline_map.find(fn_id) {\n               none { fn_id }\n-              some(item) {\n+              some(ii) {\n                 #debug[\"Found inlined version of %s with id %d\",\n                        ty::item_path_str(tcx, fn_id),\n-                       item.id];\n+                       ii.id()];\n                 {crate: ast::local_crate,\n-                 node: item.id}\n+                 node: ii.id()}\n               }\n             }\n         }\n@@ -3882,8 +3883,10 @@ fn new_fn_ctxt(ccx: crate_ctxt, path: path, llfndecl: ValueRef,\n // spaces that have been created for them (by code in the llallocas field of\n // the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n // field of the fn_ctxt with\n-fn create_llargs_for_fn_args(cx: fn_ctxt, ty_self: self_arg,\n-                             args: [ast::arg], ty_params: [ast::ty_param]) {\n+fn create_llargs_for_fn_args(cx: fn_ctxt,\n+                             ty_self: self_arg,\n+                             args: [ast::arg],\n+                             tps_bounds: [ty::param_bounds]) {\n     // Skip the implicit arguments 0, and 1.\n     let arg_n = first_tp_arg;\n     alt ty_self {\n@@ -3892,11 +3895,11 @@ fn create_llargs_for_fn_args(cx: fn_ctxt, ty_self: self_arg,\n       }\n       no_self {}\n     }\n-    for tp in ty_params {\n+    for bounds in tps_bounds {\n         let lltydesc = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n         let dicts = none;\n         arg_n += 1u;\n-        for bound in *cx.ccx.tcx.ty_param_bounds.get(tp.id) {\n+        for bound in *bounds {\n             alt bound {\n               ty::bound_iface(_) {\n                 let dict = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n@@ -3983,15 +3986,16 @@ enum self_arg { impl_self(ty::t), no_self, }\n // returned.\n fn trans_closure(ccx: crate_ctxt, path: path, decl: ast::fn_decl,\n                  body: ast::blk, llfndecl: ValueRef,\n-                 ty_self: self_arg, ty_params: [ast::ty_param],\n+                 ty_self: self_arg,\n+                 tps_bounds: [ty::param_bounds],\n                  param_substs: option<param_substs>,\n                  id: ast::node_id, maybe_load_env: fn(fn_ctxt)) {\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n     let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, param_substs,\n                                some(body.span));\n-    create_llargs_for_fn_args(fcx, ty_self, decl.inputs, ty_params);\n+    create_llargs_for_fn_args(fcx, ty_self, decl.inputs, tps_bounds);\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n@@ -4023,15 +4027,20 @@ fn trans_closure(ccx: crate_ctxt, path: path, decl: ast::fn_decl,\n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n-fn trans_fn(ccx: crate_ctxt, path: path, decl: ast::fn_decl,\n-            body: ast::blk, llfndecl: ValueRef, ty_self: self_arg,\n-            ty_params: [ast::ty_param], param_substs: option<param_substs>,\n+fn trans_fn(ccx: crate_ctxt,\n+            path: path,\n+            decl: ast::fn_decl,\n+            body: ast::blk,\n+            llfndecl: ValueRef,\n+            ty_self: self_arg,\n+            tps_bounds: [ty::param_bounds],\n+            param_substs: option<param_substs>,\n             id: ast::node_id) {\n     let do_time = ccx.sess.opts.stats;\n     let start = if do_time { time::get_time() }\n                 else { {sec: 0u32, usec: 0u32} };\n     trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n-                  ty_params, param_substs, id, {|fcx|\n+                  tps_bounds, param_substs, id, {|fcx|\n         if ccx.sess.opts.extra_debuginfo {\n             debuginfo::create_function(fcx);\n         }\n@@ -4043,12 +4052,12 @@ fn trans_fn(ccx: crate_ctxt, path: path, decl: ast::fn_decl,\n }\n \n fn trans_res_ctor(ccx: crate_ctxt, path: path, dtor: ast::fn_decl,\n-                  ctor_id: ast::node_id, ty_params: [ast::ty_param],\n+                  ctor_id: ast::node_id, tps_bounds: [ty::param_bounds],\n                   param_substs: option<param_substs>, llfndecl: ValueRef) {\n     // Create a function for the constructor\n     let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, ctor_id,\n                                param_substs, none);\n-    create_llargs_for_fn_args(fcx, no_self, dtor.inputs, ty_params);\n+    create_llargs_for_fn_args(fcx, no_self, dtor.inputs, tps_bounds);\n     let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n     let fty = node_id_type(bcx, ctor_id);\n     let arg_t = ty::ty_fn_args(fty)[0].ty;\n@@ -4091,7 +4100,8 @@ fn trans_enum_variant(ccx: crate_ctxt, enum_id: ast::node_id,\n     }\n     let fcx = new_fn_ctxt_w_id(ccx, [], llfndecl, variant.node.id,\n                                param_substs, none);\n-    create_llargs_for_fn_args(fcx, no_self, fn_args, ty_params);\n+    create_llargs_for_fn_args(fcx, no_self, fn_args,\n+                              param_bounds(ccx, ty_params));\n     let ty_param_substs = alt param_substs {\n       some(substs) { substs.tys }\n       none {\n@@ -4248,7 +4258,8 @@ fn trans_item(ccx: crate_ctxt, item: ast::item) {\n         };\n         if decl.purity != ast::crust_fn  {\n             trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n-                     llfndecl, no_self, tps, none, item.id);\n+                     llfndecl, no_self, param_bounds(ccx, tps),\n+                     none, item.id);\n         } else {\n             native::trans_crust_fn(ccx, *path + [path_name(item.ident)],\n                                    decl, body, llfndecl, item.id);\n@@ -4259,13 +4270,15 @@ fn trans_item(ccx: crate_ctxt, item: ast::item) {\n       }\n       ast::item_res(decl, tps, body, dtor_id, ctor_id) {\n         let llctor_decl = ccx.item_ids.get(ctor_id);\n-        trans_res_ctor(ccx, *path, decl, ctor_id, tps, none, llctor_decl);\n+        trans_res_ctor(ccx, *path, decl, ctor_id,\n+                       param_bounds(ccx, tps), none, llctor_decl);\n \n         // Create a function for the destructor\n         alt ccx.item_ids.find(item.id) {\n           some(lldtor_decl) {\n             trans_fn(ccx, *path + [path_name(item.ident)], decl, body,\n-                     lldtor_decl, no_self, tps, none, dtor_id);\n+                     lldtor_decl, no_self, param_bounds(ccx, tps),\n+                     none, dtor_id);\n           }\n           _ {\n             ccx.sess.span_fatal(item.span, \"unbound dtor in trans_item\");\n@@ -4309,9 +4322,34 @@ fn trans_mod(ccx: crate_ctxt, m: ast::_mod) {\n     for item in m.items { trans_item(ccx, *item); }\n }\n \n+fn compute_ii_method_info(ccx: crate_ctxt,\n+                          impl_did: ast::def_id,\n+                          m: @ast::method,\n+                          f: fn(ty::t, [ty::param_bounds], ast_map::path)) {\n+    let {bounds: impl_bnds, ty: impl_ty} =\n+        ty::lookup_item_type(ccx.tcx, impl_did);\n+    let m_bounds = *impl_bnds + param_bounds(ccx, m.tps);\n+    let impl_path = ty::item_path(ccx.tcx, impl_did);\n+    let m_path = impl_path + [path_name(m.ident)];\n+    f(impl_ty, m_bounds, m_path);\n+}\n+\n fn trans_inlined_items(ccx: crate_ctxt, inline_map: inline_map) {\n-    inline_map.values {|item|\n-        trans_item(ccx, *item)\n+    inline_map.values {|ii|\n+        alt ii {\n+          ast::ii_item(item) {\n+            trans_item(ccx, *item)\n+          }\n+          ast::ii_method(impl_did, m) {\n+            compute_ii_method_info(ccx, impl_did, m) {\n+                |impl_ty, m_bounds, m_path|\n+                let llfndecl = ccx.item_ids.get(m.id);\n+                trans_fn(ccx, m_path, m.decl, m.body,\n+                         llfndecl, impl_self(impl_ty), m_bounds,\n+                         none, m.id);\n+            }\n+          }\n+        }\n     }\n }\n \n@@ -4323,18 +4361,18 @@ fn get_pair_fn_ty(llpairty: TypeRef) -> TypeRef {\n fn register_fn(ccx: crate_ctxt, sp: span, path: path, flav: str,\n                ty_params: [ast::ty_param], node_id: ast::node_id) {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n-    register_fn_full(ccx, sp, path, flav, ty_params, node_id, t);\n+    let bnds = param_bounds(ccx, ty_params);\n+    register_fn_full(ccx, sp, path, flav, bnds, node_id, t);\n }\n \n-fn param_bounds(ccx: crate_ctxt, tp: ast::ty_param) -> ty::param_bounds {\n-    ccx.tcx.ty_param_bounds.get(tp.id)\n+fn param_bounds(ccx: crate_ctxt, tps: [ast::ty_param]) -> [ty::param_bounds] {\n+    vec::map(tps) {|tp| ccx.tcx.ty_param_bounds.get(tp.id) }\n }\n \n fn register_fn_full(ccx: crate_ctxt, sp: span, path: path, flav: str,\n-                    tps: [ast::ty_param], node_id: ast::node_id,\n+                    bnds: [ty::param_bounds], node_id: ast::node_id,\n                     node_type: ty::t) {\n-    let llfty = type_of_fn_from_ty(ccx, node_type,\n-                                   vec::map(tps, {|p| param_bounds(ccx, p)}));\n+    let llfty = type_of_fn_from_ty(ccx, node_type, bnds);\n     register_fn_fuller(ccx, sp, path, flav, node_id, node_type,\n                        lib::llvm::CCallConv, llfty);\n }\n@@ -4480,8 +4518,7 @@ fn collect_native_item(ccx: crate_ctxt,\n             // For intrinsics: link the function directly to the intrinsic\n             // function itself.\n             let fn_type = type_of_fn_from_ty(\n-                ccx, node_type,\n-                vec::map(tps, {|p| param_bounds(ccx, p)}));\n+                ccx, node_type, param_bounds(ccx, tps));\n             let ri_name = \"rust_intrinsic_\" + native::link_name(i);\n             let llnativefn = get_extern_fn(\n                 ccx.externs, ccx.llmod, ri_name,\n@@ -4555,7 +4592,7 @@ fn collect_item(ccx: crate_ctxt, abi: @mutable option<ast::native_abi>,\n         // -- one to identify the type, and one to find the dtor symbol.\n         let t = ty::node_id_to_type(ccx.tcx, dtor_id);\n         register_fn_full(ccx, i.span, my_path + [path_name(\"dtor\")],\n-                         \"res_dtor\", tps, i.id, t);\n+                         \"res_dtor\", param_bounds(ccx, tps), i.id, t);\n       }\n       ast::item_enum(variants, tps) {\n         for variant in variants {\n@@ -4581,14 +4618,26 @@ fn collect_items(ccx: crate_ctxt, crate: @ast::crate) {\n \n fn collect_inlined_items(ccx: crate_ctxt, inline_map: inline::inline_map) {\n     let abi = @mutable none::<ast::native_abi>;\n-    inline_map.values {|item|\n-        collect_item(ccx, abi, item);\n+    inline_map.values {|ii|\n+        alt ii {\n+          ast::ii_item(item) {\n+            collect_item(ccx, abi, item);\n+            alt item.node {\n+              ast::item_fn(_, _, _) {\n+                set_always_inline(ccx.item_ids.get(item.id));\n+              }\n+              _ { /* fallthrough */ }\n+            }\n+          }\n \n-        alt item.node {\n-          ast::item_fn(_, _, _) {\n-            set_always_inline(ccx.item_ids.get(item.id));\n+          ast::ii_method(impl_did, m) {\n+            compute_ii_method_info(ccx, impl_did, m) {\n+                |_impl_ty, m_bounds, m_path|\n+                let mthd_ty = ty::node_id_to_type(ccx.tcx, m.id);\n+                register_fn_full(ccx, m.span, m_path, \"impl_method\",\n+                                 m_bounds, m.id, mthd_ty);\n+            }\n           }\n-          _ { /* fallthrough */ }\n         }\n     }\n }"}, {"sha": "b3660e3f672892e4bbb0e3372e48cddc1e7f9d5a", "filename": "src/comp/middle/trans/impl.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fimpl.rs?ref=6473a87cec100682764f4d926541fc7eb455b00c", "patch": "@@ -49,9 +49,10 @@ fn trans_impl(ccx: crate_ctxt, path: path, name: ast::ident,\n     for m in methods {\n         alt ccx.item_ids.find(m.id) {\n           some(llfn) {\n+            let m_bounds = param_bounds(ccx, tps + m.tps);\n             trans_fn(ccx, sub_path + [path_name(m.ident)], m.decl, m.body,\n                      llfn, impl_self(ty::node_id_to_type(ccx.tcx, id)),\n-                     tps + m.tps, none, m.id);\n+                     m_bounds, none, m.id);\n           }\n           _ {\n             ccx.sess.bug(\"Unbound id in trans_impl\");\n@@ -337,13 +338,13 @@ fn trans_impl_vtable(ccx: crate_ctxt, pt: path,\n                      tps: [ast::ty_param], it: @ast::item) {\n     let new_pt = pt + [path_name(it.ident), path_name(int::str(it.id)),\n                        path_name(\"wrap\")];\n-    let extra_tps = vec::map(tps, {|p| param_bounds(ccx, p)});\n+    let extra_tps = param_bounds(ccx, tps);\n     let ptrs = vec::map(*ty::iface_methods(ccx.tcx, iface_id), {|im|\n         alt vec::find(ms, {|m| m.ident == im.ident}) {\n           some(m) {\n             let target = ccx.item_ids.get(m.id);\n-            trans_impl_wrapper(ccx, new_pt + [path_name(m.ident)], extra_tps,\n-                               target)\n+            trans_impl_wrapper(ccx, new_pt + [path_name(m.ident)],\n+                               extra_tps, target)\n           }\n           _ {\n             ccx.sess.span_bug(it.span, \"No matching method \\"}, {"sha": "eea47191eef760ebf80c40096667d64b40a38bdf", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=6473a87cec100682764f4d926541fc7eb455b00c", "patch": "@@ -534,6 +534,14 @@ enum native_item_ {\n     native_item_fn(fn_decl, [ty_param]),\n }\n \n+// The data we save and restore about an inlined item or method.  This is not\n+// part of the AST that we parse from a file, but it becomes part of the tree\n+// that we trans.\n+enum inlined_item {\n+    ii_item(@item),\n+    ii_method(def_id /* impl id */, @method)\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "04bd4236c9bea50ff7d6f8d5d9f41a161b0a55cd", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=6473a87cec100682764f4d926541fc7eb455b00c", "patch": "@@ -411,6 +411,29 @@ pure fn class_item_ident(ci: @class_item) -> ident {\n     }\n }\n \n+impl inlined_item_methods for inlined_item {\n+    fn ident() -> ident {\n+        alt self {\n+          ii_item(i) { i.ident }\n+          ii_method(_, m) { m.ident }\n+        }\n+    }\n+\n+    fn id() -> ast::node_id {\n+        alt self {\n+          ii_item(i) { i.id }\n+          ii_method(_, m) { m.id }\n+        }\n+    }\n+\n+    fn accept<E>(e: E, v: visit::vt<E>) {\n+        alt self {\n+          ii_item(i) { v.visit_item(i, e, v) }\n+          ii_method(_, m) { visit::visit_method_helper(m, e, v) }\n+        }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "7ceae54876949105af0bc5cd76075d3f20cab91c", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=6473a87cec100682764f4d926541fc7eb455b00c", "patch": "@@ -750,7 +750,6 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n     ret result;\n }\n \n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "79316c23dca8b8ae690214c2d236da2695ef62d9", "filename": "src/etc/gen-astencode", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fetc%2Fgen-astencode", "raw_url": "https://github.com/rust-lang/rust/raw/6473a87cec100682764f4d926541fc7eb455b00c/src%2Fetc%2Fgen-astencode", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgen-astencode?ref=6473a87cec100682764f4d926541fc7eb455b00c", "patch": "@@ -17,7 +17,7 @@ function msg {\n M=src/comp/metadata\n GEN_TYPES=\"syntax::ast::item syntax::ast::def middle::typeck::method_origin \\\n            middle::freevars::freevar_entry syntax::ast::def_id\n-           syntax::ast::method\"\n+           syntax::ast::inlined_item\"\n \n # Find serializer tool:\n for S in build/*/stage1/bin/serializer; do"}]}