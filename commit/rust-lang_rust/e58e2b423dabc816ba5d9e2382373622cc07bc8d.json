{"sha": "e58e2b423dabc816ba5d9e2382373622cc07bc8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1OGUyYjQyM2RhYmM4MTZiYTVkOWUyMzgyMzczNjIyY2MwN2JjOGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-16T13:05:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-12T00:32:46Z"}, "message": "remove the subtyping relations from TypeVariable", "tree": {"sha": "13cca30464f71f92f3ecf0d96c7b3666e38ea4b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13cca30464f71f92f3ecf0d96c7b3666e38ea4b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e58e2b423dabc816ba5d9e2382373622cc07bc8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e58e2b423dabc816ba5d9e2382373622cc07bc8d", "html_url": "https://github.com/rust-lang/rust/commit/e58e2b423dabc816ba5d9e2382373622cc07bc8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e58e2b423dabc816ba5d9e2382373622cc07bc8d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "105ec7e3bbbef50076f0e6963e8a9327bacf7b5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/105ec7e3bbbef50076f0e6963e8a9327bacf7b5f", "html_url": "https://github.com/rust-lang/rust/commit/105ec7e3bbbef50076f0e6963e8a9327bacf7b5f"}], "stats": {"total": 181, "additions": 51, "deletions": 130}, "files": [{"sha": "825f279e78e4b0968fd0b865d247504edcbac5bd", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e58e2b423dabc816ba5d9e2382373622cc07bc8d/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58e2b423dabc816ba5d9e2382373622cc07bc8d/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=e58e2b423dabc816ba5d9e2382373622cc07bc8d", "patch": "@@ -38,7 +38,6 @@ use super::lub::Lub;\n use super::sub::Sub;\n use super::InferCtxt;\n use super::{MiscVariable, TypeTrace};\n-use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n \n use ty::{IntType, UintType};\n use ty::{self, Ty, TyCtxt};\n@@ -59,6 +58,11 @@ pub struct CombineFields<'infcx, 'gcx: 'infcx+'tcx, 'tcx: 'infcx> {\n     pub obligations: PredicateObligations<'tcx>,\n }\n \n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum RelationDir {\n+    SubtypeOf, SupertypeOf, EqTo\n+}\n+\n impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n     pub fn super_combine_tys<R>(&self,\n                                 relation: &mut R,\n@@ -177,6 +181,8 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n                        a_is_expected: bool)\n                        -> RelateResult<'tcx, ()>\n     {\n+        use self::RelationDir::*;\n+\n         // We use SmallVector here instead of Vec because this code is hot and\n         // it's rare that the stack length exceeds 1.\n         let mut stack = SmallVector::new();\n@@ -224,16 +230,15 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n                     // Generalize type if necessary.\n                     let generalized_ty = match dir {\n                         EqTo => self.generalize(a_ty, b_vid, false),\n-                        BiTo | SupertypeOf | SubtypeOf => self.generalize(a_ty, b_vid, true),\n+                        SupertypeOf | SubtypeOf => self.generalize(a_ty, b_vid, true),\n                     }?;\n                     debug!(\"instantiate(a_ty={:?}, dir={:?}, \\\n                                         b_vid={:?}, generalized_ty={:?})\",\n                            a_ty, dir, b_vid,\n                            generalized_ty);\n                     self.infcx.type_variables\n                         .borrow_mut()\n-                        .instantiate_and_push(\n-                            b_vid, generalized_ty, &mut stack);\n+                        .instantiate(b_vid, generalized_ty);\n                     generalized_ty\n                 }\n             };\n@@ -246,7 +251,6 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n             // to associate causes/spans with each of the relations in\n             // the stack to get this right.\n             match dir {\n-                BiTo => Ok(a_ty),\n                 EqTo => self.equate(a_is_expected).relate(&a_ty, &b_ty),\n                 SubtypeOf => self.sub(a_is_expected).relate(&a_ty, &b_ty),\n                 SupertypeOf => self.sub(a_is_expected).relate_with_variance("}, {"sha": "f620965ced84590e5c1b32d769374248dc66342f", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e58e2b423dabc816ba5d9e2382373622cc07bc8d/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58e2b423dabc816ba5d9e2382373622cc07bc8d/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=e58e2b423dabc816ba5d9e2382373622cc07bc8d", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::CombineFields;\n+use super::combine::{CombineFields, RelationDir};\n use super::{Subtype};\n-use super::type_variable::{EqTo};\n \n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n@@ -58,17 +57,17 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n         match (&a.sty, &b.sty) {\n             (&ty::TyInfer(TyVar(a_id)), &ty::TyInfer(TyVar(b_id))) => {\n-                infcx.type_variables.borrow_mut().relate_vars(a_id, EqTo, b_id);\n+                infcx.type_variables.borrow_mut().equate(a_id, b_id);\n                 Ok(a)\n             }\n \n             (&ty::TyInfer(TyVar(a_id)), _) => {\n-                self.fields.instantiate(b, EqTo, a_id, self.a_is_expected)?;\n+                self.fields.instantiate(b, RelationDir::EqTo, a_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n \n             (_, &ty::TyInfer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, EqTo, b_id, self.a_is_expected)?;\n+                self.fields.instantiate(a, RelationDir::EqTo, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n "}, {"sha": "f1de9b043e36ff71794b8e9de576b06cb89a3a67", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e58e2b423dabc816ba5d9e2382373622cc07bc8d/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58e2b423dabc816ba5d9e2382373622cc07bc8d/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=e58e2b423dabc816ba5d9e2382373622cc07bc8d", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use super::SubregionOrigin;\n-use super::combine::CombineFields;\n-use super::type_variable::{SubtypeOf, SupertypeOf};\n+use super::combine::{CombineFields, RelationDir};\n \n use traits::Obligation;\n use ty::{self, Ty, TyCtxt};\n@@ -104,11 +103,11 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n             }\n             (&ty::TyInfer(TyVar(a_id)), _) => {\n                 self.fields\n-                    .instantiate(b, SupertypeOf, a_id, !self.a_is_expected)?;\n+                    .instantiate(b, RelationDir::SupertypeOf, a_id, !self.a_is_expected)?;\n                 Ok(a)\n             }\n             (_, &ty::TyInfer(TyVar(b_id))) => {\n-                self.fields.instantiate(a, SubtypeOf, b_id, self.a_is_expected)?;\n+                self.fields.instantiate(a, RelationDir::SubtypeOf, b_id, self.a_is_expected)?;\n                 Ok(a)\n             }\n "}, {"sha": "298b2a97d5f3641c4657129740421c491269a6b1", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 31, "deletions": 113, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/e58e2b423dabc816ba5d9e2382373622cc07bc8d/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58e2b423dabc816ba5d9e2382373622cc07bc8d/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=e58e2b423dabc816ba5d9e2382373622cc07bc8d", "patch": "@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::RelationDir::*;\n use self::TypeVariableValue::*;\n-use self::UndoEntry::*;\n use hir::def_id::{DefId};\n-use syntax::util::small_vector::SmallVector;\n use syntax::ast;\n use syntax_pos::Span;\n use ty::{self, Ty};\n@@ -55,7 +52,6 @@ struct TypeVariableData<'tcx> {\n enum TypeVariableValue<'tcx> {\n     Known(Ty<'tcx>),\n     Bounded {\n-        relations: Vec<Relation>,\n         default: Option<Default<'tcx>>\n     }\n }\n@@ -76,33 +72,13 @@ pub struct Snapshot {\n     eq_snapshot: ut::Snapshot<ty::TyVid>,\n }\n \n-enum UndoEntry<'tcx> {\n-    // The type of the var was specified.\n-    SpecifyVar(ty::TyVid, Vec<Relation>, Option<Default<'tcx>>),\n-    Relate(ty::TyVid, ty::TyVid),\n-    RelateRange(ty::TyVid, usize),\n+struct Instantiate<'tcx> {\n+    vid: ty::TyVid,\n+    default: Option<Default<'tcx>>,\n }\n \n struct Delegate<'tcx>(PhantomData<&'tcx ()>);\n \n-type Relation = (RelationDir, ty::TyVid);\n-\n-#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n-pub enum RelationDir {\n-    SubtypeOf, SupertypeOf, EqTo, BiTo\n-}\n-\n-impl RelationDir {\n-    fn opposite(self) -> RelationDir {\n-        match self {\n-            SubtypeOf => SupertypeOf,\n-            SupertypeOf => SubtypeOf,\n-            EqTo => EqTo,\n-            BiTo => BiTo,\n-        }\n-    }\n-}\n-\n impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn new() -> TypeVariableTable<'tcx> {\n         TypeVariableTable {\n@@ -111,10 +87,6 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         }\n     }\n \n-    fn relations<'a>(&'a mut self, a: ty::TyVid) -> &'a mut Vec<Relation> {\n-        relations(self.values.get_mut(a.index as usize))\n-    }\n-\n     pub fn default(&self, vid: ty::TyVid) -> Option<Default<'tcx>> {\n         match &self.values.get(vid.index as usize).value {\n             &Known(_) => None,\n@@ -130,68 +102,37 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         &self.values.get(vid.index as usize).origin\n     }\n \n-    /// Records that `a <: b`, `a :> b`, or `a == b`, depending on `dir`.\n+    /// Records that `a == b`, depending on `dir`.\n     ///\n     /// Precondition: neither `a` nor `b` are known.\n-    pub fn relate_vars(&mut self, a: ty::TyVid, dir: RelationDir, b: ty::TyVid) {\n-        let a = self.root_var(a);\n-        let b = self.root_var(b);\n-        if a != b {\n-            if dir == EqTo {\n-                // a and b must be equal which we mark in the unification table\n-                let root = self.eq_relations.union(a, b);\n-                // In addition to being equal, all relations from the variable which is no longer\n-                // the root must be added to the root so they are not forgotten as the other\n-                // variable should no longer be referenced (other than to get the root)\n-                let other = if a == root { b } else { a };\n-                let count = {\n-                    let (relations, root_relations) = if other.index < root.index {\n-                        let (pre, post) = self.values.split_at_mut(root.index as usize);\n-                        (relations(&mut pre[other.index as usize]), relations(&mut post[0]))\n-                    } else {\n-                        let (pre, post) = self.values.split_at_mut(other.index as usize);\n-                        (relations(&mut post[0]), relations(&mut pre[root.index as usize]))\n-                    };\n-                    root_relations.extend_from_slice(relations);\n-                    relations.len()\n-                };\n-                self.values.record(RelateRange(root, count));\n-            } else {\n-                self.relations(a).push((dir, b));\n-                self.relations(b).push((dir.opposite(), a));\n-                self.values.record(Relate(a, b));\n-            }\n-        }\n+    pub fn equate(&mut self, a: ty::TyVid, b: ty::TyVid) {\n+        debug_assert!(self.probe(a).is_none());\n+        debug_assert!(self.probe(b).is_none());\n+        self.eq_relations.union(a, b);\n     }\n \n-    /// Instantiates `vid` with the type `ty` and then pushes an entry onto `stack` for each of the\n-    /// relations of `vid` to other variables. The relations will have the form `(ty, dir, vid1)`\n-    /// where `vid1` is some other variable id.\n+    /// Instantiates `vid` with the type `ty`.\n     ///\n     /// Precondition: `vid` must be a root in the unification table\n-    pub fn instantiate_and_push(\n-        &mut self,\n-        vid: ty::TyVid,\n-        ty: Ty<'tcx>,\n-        stack: &mut SmallVector<(Ty<'tcx>, RelationDir, ty::TyVid)>)\n-    {\n+    /// and has not previously been instantiated.\n+    pub fn instantiate(&mut self, vid: ty::TyVid, ty: Ty<'tcx>) {\n         debug_assert!(self.root_var(vid) == vid);\n-        let old_value = {\n-            let value_ptr = &mut self.values.get_mut(vid.index as usize).value;\n-            mem::replace(value_ptr, Known(ty))\n-        };\n+        debug_assert!(self.probe(vid).is_none());\n \n-        let (relations, default) = match old_value {\n-            Bounded { relations, default } => (relations, default),\n-            Known(_) => bug!(\"Asked to instantiate variable that is \\\n-                              already instantiated\")\n+        let old_value = {\n+            let vid_data = &mut self.values[vid.index as usize];\n+            mem::replace(&mut vid_data.value, TypeVariableValue::Known(ty))\n         };\n \n-        for &(dir, vid) in &relations {\n-            stack.push((ty, dir, vid));\n+        match old_value {\n+            TypeVariableValue::Bounded { default } => {\n+                self.values.record(Instantiate { vid: vid, default: default });\n+            }\n+            TypeVariableValue::Known(old_ty) => {\n+                bug!(\"instantiating type variable `{:?}` twice: new-value = {:?}, old-value={:?}\",\n+                     vid, ty, old_ty)\n+            }\n         }\n-\n-        self.values.record(SpecifyVar(vid, relations, default));\n     }\n \n     pub fn new_var(&mut self,\n@@ -201,7 +142,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         debug!(\"new_var(diverging={:?}, origin={:?})\", diverging, origin);\n         self.eq_relations.new_key(());\n         let index = self.values.push(TypeVariableData {\n-            value: Bounded { relations: vec![], default: default },\n+            value: Bounded { default: default },\n             origin: origin,\n             diverging: diverging\n         });\n@@ -298,7 +239,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n                     debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n                 }\n \n-                sv::UndoLog::Other(SpecifyVar(vid, ..)) => {\n+                sv::UndoLog::Other(Instantiate { vid, .. }) => {\n                     if vid.index < new_elem_threshold {\n                         // quick check to see if this variable was\n                         // created since the snapshot started or not.\n@@ -334,35 +275,12 @@ impl<'tcx> TypeVariableTable<'tcx> {\n \n impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n     type Value = TypeVariableData<'tcx>;\n-    type Undo = UndoEntry<'tcx>;\n-\n-    fn reverse(values: &mut Vec<TypeVariableData<'tcx>>, action: UndoEntry<'tcx>) {\n-        match action {\n-            SpecifyVar(vid, relations, default) => {\n-                values[vid.index as usize].value = Bounded {\n-                    relations: relations,\n-                    default: default\n-                };\n-            }\n+    type Undo = Instantiate<'tcx>;\n \n-            Relate(a, b) => {\n-                relations(&mut (*values)[a.index as usize]).pop();\n-                relations(&mut (*values)[b.index as usize]).pop();\n-            }\n-\n-            RelateRange(i, n) => {\n-                let relations = relations(&mut (*values)[i.index as usize]);\n-                for _ in 0..n {\n-                    relations.pop();\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn relations<'a>(v: &'a mut TypeVariableData) -> &'a mut Vec<Relation> {\n-    match v.value {\n-        Known(_) => bug!(\"var_sub_var: variable is known\"),\n-        Bounded { ref mut relations, .. } => relations\n+    fn reverse(values: &mut Vec<TypeVariableData<'tcx>>, action: Instantiate<'tcx>) {\n+        let Instantiate { vid, default } = action;\n+        values[vid.index as usize].value = Bounded {\n+            default: default\n+        };\n     }\n }"}, {"sha": "9176a4c01575f212d84a55633b87d0f026b3c4ca", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e58e2b423dabc816ba5d9e2382373622cc07bc8d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58e2b423dabc816ba5d9e2382373622cc07bc8d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e58e2b423dabc816ba5d9e2382373622cc07bc8d", "patch": "@@ -32,6 +32,7 @@\n #![feature(i128_type)]\n #![feature(libc)]\n #![feature(loop_break_value)]\n+#![feature(never_type)]\n #![feature(nonzero)]\n #![cfg_attr(stage0, feature(pub_restricted))]\n #![feature(quote)]"}, {"sha": "2551ed0208af3ef4cce431604a84dfdca4eb3fa2", "filename": "src/test/compile-fail/issue-7813.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e58e2b423dabc816ba5d9e2382373622cc07bc8d/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58e2b423dabc816ba5d9e2382373622cc07bc8d/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs?ref=e58e2b423dabc816ba5d9e2382373622cc07bc8d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let v = &[];\n-    //~^ NOTE consider giving `it` a type\n-    let it = v.iter(); //~ ERROR cannot infer type for `_`\n+    let v = &[]; //~ NOTE consider giving `v` a type\n+    let it = v.iter(); //~ ERROR type annotations needed\n+    //~^ NOTE cannot infer type for `_`\n }"}]}