{"sha": "d755238172ead0c619ac404487615534abc51ef1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NTUyMzgxNzJlYWQwYzYxOWFjNDA0NDg3NjE1NTM0YWJjNTFlZjE=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-01-15T17:52:04Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-01-15T20:21:30Z"}, "message": "Simplify deref impls for type aliases", "tree": {"sha": "b312437c8ae9a35511cacde2ee82787119c28b6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b312437c8ae9a35511cacde2ee82787119c28b6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d755238172ead0c619ac404487615534abc51ef1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d755238172ead0c619ac404487615534abc51ef1", "html_url": "https://github.com/rust-lang/rust/commit/d755238172ead0c619ac404487615534abc51ef1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d755238172ead0c619ac404487615534abc51ef1/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6ad49aa67b7e6e0d9c5bc4bd68f44a009f91595", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6ad49aa67b7e6e0d9c5bc4bd68f44a009f91595", "html_url": "https://github.com/rust-lang/rust/commit/e6ad49aa67b7e6e0d9c5bc4bd68f44a009f91595"}], "stats": {"total": 94, "additions": 55, "deletions": 39}, "files": [{"sha": "ae15b458fbaea9d53b5c367501313a6c4bb753d4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d755238172ead0c619ac404487615534abc51ef1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d755238172ead0c619ac404487615534abc51ef1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d755238172ead0c619ac404487615534abc51ef1", "patch": "@@ -2105,7 +2105,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             build_deref_target_impls(cx, &items, &mut ret);\n         }\n \n-        let provided = trait_\n+        let provided: FxHashSet<String> = trait_\n             .def_id()\n             .map(|did| {\n                 cx.tcx\n@@ -2116,6 +2116,33 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             })\n             .unwrap_or_default();\n \n+        let for_ = self.for_.clean(cx);\n+        let type_alias = for_.def_id().and_then(|did| match cx.tcx.def_kind(did) {\n+            Some(DefKind::TyAlias) => Some(cx.tcx.type_of(did).clean(cx)),\n+            _ => None,\n+        });\n+        if let Some(type_alias) = type_alias {\n+            ret.push(Item {\n+                name: None,\n+                attrs: self.attrs.clean(cx),\n+                source: self.whence.clean(cx),\n+                def_id,\n+                visibility: self.vis.clean(cx),\n+                stability: cx.stability(self.id).clean(cx),\n+                deprecation: cx.deprecation(self.id).clean(cx),\n+                inner: ImplItem(Impl {\n+                    unsafety: self.unsafety,\n+                    generics: self.generics.clean(cx),\n+                    provided_trait_methods: provided.clone(),\n+                    trait_: trait_.clone(),\n+                    for_: type_alias,\n+                    items: items.clone(),\n+                    polarity: Some(cx.tcx.impl_polarity(def_id).clean(cx)),\n+                    synthetic: false,\n+                    blanket_impl: None,\n+                }),\n+            });\n+        }\n         ret.push(Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n@@ -2129,7 +2156,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n                 generics: self.generics.clean(cx),\n                 provided_trait_methods: provided,\n                 trait_,\n-                for_: self.for_.clean(cx),\n+                for_,\n                 items,\n                 polarity: Some(cx.tcx.impl_polarity(def_id).clean(cx)),\n                 synthetic: false,"}, {"sha": "aaacae045b903a90bbabd94880a86bd72040bbb3", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 26, "deletions": 37, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d755238172ead0c619ac404487615534abc51ef1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d755238172ead0c619ac404487615534abc51ef1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d755238172ead0c619ac404487615534abc51ef1", "patch": "@@ -2595,7 +2595,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    render_assoc_items(w, cx, it, it.def_id, &AssocItemRender::All);\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n \n     let mut synthetic_types = Vec::new();\n \n@@ -2942,7 +2942,7 @@ fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct\n             }\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, &AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union) {\n@@ -2988,7 +2988,7 @@ fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union)\n             document(w, cx, field);\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, &AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n@@ -3130,7 +3130,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n             render_stability_since(w, variant, it);\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, &AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n fn render_attribute(attr: &ast::MetaItem) -> Option<String> {\n@@ -3344,7 +3344,7 @@ fn render_assoc_items(\n     cx: &Context,\n     containing_item: &clean::Item,\n     it: DefId,\n-    what: &AssocItemRender<'_>,\n+    what: AssocItemRender<'_>,\n ) {\n     let c = &cx.cache;\n     let v = match c.impls.get(&it) {\n@@ -3377,7 +3377,7 @@ fn render_assoc_items(\n                     trait_.print(),\n                     type_.print()\n                 );\n-                RenderMode::ForDeref { mut_: *deref_mut_ }\n+                RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n         };\n         for i in &non_trait {\n@@ -3461,19 +3461,6 @@ fn render_assoc_items(\n     }\n }\n \n-fn get_def_id(real_target: &clean::Type, cx: &Context) -> Option<DefId> {\n-    if let Some(did) = real_target.def_id() {\n-        return Some(did);\n-    } else {\n-        if let Some(prim) = real_target.primitive_type() {\n-            if let Some(&did) = cx.cache.primitive_locations.get(&prim) {\n-                return Some(did);\n-            }\n-        }\n-    }\n-    None\n-}\n-\n fn render_deref_methods(\n     w: &mut Buffer,\n     cx: &Context,\n@@ -3488,21 +3475,23 @@ fn render_deref_methods(\n         .iter()\n         .filter_map(|item| match item.inner {\n             clean::TypedefItem(ref t, true) => Some(match *t {\n-                clean::Typedef { item_type: Some(ref type_), .. } => (&t.type_, Some(type_)),\n-                _ => (&t.type_, None),\n+                clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n+                _ => (&t.type_, &t.type_),\n             }),\n             _ => None,\n         })\n         .next()\n         .expect(\"Expected associated type binding\");\n-    let did = get_def_id(&target, cx);\n     let what =\n-        AssocItemRender::DerefFor { trait_: deref_type, type_: target, deref_mut_: deref_mut };\n-    if let Some(did) = did {\n-        render_assoc_items(w, cx, container_item, did, &what);\n-    }\n-    if let Some(did) = real_target.and_then(|x| get_def_id(x, cx)) {\n-        render_assoc_items(w, cx, container_item, did, &what);\n+        AssocItemRender::DerefFor { trait_: deref_type, type_: real_target, deref_mut_: deref_mut };\n+    if let Some(did) = target.def_id() {\n+        render_assoc_items(w, cx, container_item, did, what);\n+    } else {\n+        if let Some(prim) = target.primitive_type() {\n+            if let Some(&did) = cx.cache.primitive_locations.get(&prim) {\n+                render_assoc_items(w, cx, container_item, did, what);\n+            }\n+        }\n     }\n }\n \n@@ -3884,7 +3873,7 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Opa\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, &AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n fn item_trait_alias(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::TraitAlias) {\n@@ -3905,7 +3894,7 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::T\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, &AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typedef) {\n@@ -3926,7 +3915,7 @@ fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typed\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, &AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n@@ -3941,7 +3930,7 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n \n     document(w, cx, it);\n \n-    render_assoc_items(w, cx, it, it.def_id, &AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n@@ -4137,20 +4126,20 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                 .filter(|i| i.inner_impl().trait_.is_some())\n                 .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did)\n             {\n-                if let Some((target, real_target)) = impl_\n+                if let Some(target) = impl_\n                     .inner_impl()\n                     .items\n                     .iter()\n                     .filter_map(|item| match item.inner {\n                         clean::TypedefItem(ref t, true) => Some(match *t {\n-                            clean::Typedef { item_type: Some(ref type_), .. } => (&t.type_, type_),\n-                            _ => (&t.type_, &t.type_),\n+                            clean::Typedef { item_type: Some(ref type_), .. } => type_,\n+                            _ => &t.type_,\n                         }),\n                         _ => None,\n                     })\n                     .next()\n                 {\n-                    let inner_impl = real_target\n+                    let inner_impl = target\n                         .def_id()\n                         .or(target\n                             .primitive_type()\n@@ -4613,7 +4602,7 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, m: &clean::Pr\n \n fn item_primitive(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n     document(w, cx, it);\n-    render_assoc_items(w, cx, it, it.def_id, &AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n fn item_keyword(w: &mut Buffer, cx: &Context, it: &clean::Item) {"}]}