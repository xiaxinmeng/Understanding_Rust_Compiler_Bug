{"sha": "4e8046f67ad688ae1deb30922e08a224d9964b1e", "node_id": "C_kwDOAAsO6NoAKDRlODA0NmY2N2FkNjg4YWUxZGViMzA5MjJlMDhhMjI0ZDk5NjRiMWU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-02-13T14:48:01Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-23T07:55:25Z"}, "message": "Stop pretty-printing HIR visibility.", "tree": {"sha": "919ff978a4c47bd8db8e2a8aa0148c97c2e57cbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/919ff978a4c47bd8db8e2a8aa0148c97c2e57cbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e8046f67ad688ae1deb30922e08a224d9964b1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e8046f67ad688ae1deb30922e08a224d9964b1e", "html_url": "https://github.com/rust-lang/rust/commit/4e8046f67ad688ae1deb30922e08a224d9964b1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e8046f67ad688ae1deb30922e08a224d9964b1e/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10d10efb2186bfea33a13830dc5bce967b12d049", "url": "https://api.github.com/repos/rust-lang/rust/commits/10d10efb2186bfea33a13830dc5bce967b12d049", "html_url": "https://github.com/rust-lang/rust/commit/10d10efb2186bfea33a13830dc5bce967b12d049"}], "stats": {"total": 112, "additions": 29, "deletions": 83}, "files": [{"sha": "87ff94577836cfcccd89d382c2eb98bc252356b9", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 27, "deletions": 79, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4e8046f67ad688ae1deb30922e08a224d9964b1e/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8046f67ad688ae1deb30922e08a224d9964b1e/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=4e8046f67ad688ae1deb30922e08a224d9964b1e", "patch": "@@ -8,12 +8,11 @@ use rustc_ast_pretty::pprust::{Comments, PrintState};\n use rustc_hir as hir;\n use rustc_hir::{GenericArg, GenericParam, GenericParamKind, Node, Term};\n use rustc_hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n-use rustc_span::source_map::{SourceMap, Spanned};\n+use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, Ident, IdentPrinter, Symbol};\n use rustc_span::{self, FileName};\n use rustc_target::spec::abi::Abi;\n \n-use std::borrow::Cow;\n use std::cell::Cell;\n use std::vec;\n \n@@ -190,13 +189,6 @@ where\n     printer.s.eof()\n }\n \n-pub fn visibility_qualified<S: Into<Cow<'static, str>>>(vis: &hir::Visibility<'_>, w: S) -> String {\n-    to_string(NO_ANN, |s| {\n-        s.print_visibility(vis);\n-        s.word(w)\n-    })\n-}\n-\n pub fn generic_params_to_string(generic_params: &[GenericParam<'_>]) -> String {\n     to_string(NO_ANN, |s| s.print_generic_params(generic_params))\n }\n@@ -222,21 +214,19 @@ pub fn fn_to_string(\n     header: hir::FnHeader,\n     name: Option<Symbol>,\n     generics: &hir::Generics<'_>,\n-    vis: &hir::Visibility<'_>,\n     arg_names: &[Ident],\n     body_id: Option<hir::BodyId>,\n ) -> String {\n-    to_string(NO_ANN, |s| s.print_fn(decl, header, name, generics, vis, arg_names, body_id))\n+    to_string(NO_ANN, |s| s.print_fn(decl, header, name, generics, arg_names, body_id))\n }\n \n pub fn enum_def_to_string(\n     enum_definition: &hir::EnumDef<'_>,\n     generics: &hir::Generics<'_>,\n     name: Symbol,\n     span: rustc_span::Span,\n-    visibility: &hir::Visibility<'_>,\n ) -> String {\n-    to_string(NO_ANN, |s| s.print_enum_def(enum_definition, generics, name, span, visibility))\n+    to_string(NO_ANN, |s| s.print_enum_def(enum_definition, generics, name, span))\n }\n \n impl<'a> State<'a> {\n@@ -394,7 +384,6 @@ impl<'a> State<'a> {\n                     },\n                     Some(item.ident.name),\n                     generics,\n-                    &item.vis,\n                     arg_names,\n                     None,\n                 );\n@@ -403,7 +392,7 @@ impl<'a> State<'a> {\n                 self.end() // end the outer fn box\n             }\n             hir::ForeignItemKind::Static(ref t, m) => {\n-                self.head(visibility_qualified(&item.vis, \"static\"));\n+                self.head(\"static\");\n                 if m == hir::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n@@ -415,7 +404,7 @@ impl<'a> State<'a> {\n                 self.end() // end the outer cbox\n             }\n             hir::ForeignItemKind::Type => {\n-                self.head(visibility_qualified(&item.vis, \"type\"));\n+                self.head(\"type\");\n                 self.print_ident(item.ident);\n                 self.word(\";\");\n                 self.end(); // end the head-ibox\n@@ -429,9 +418,8 @@ impl<'a> State<'a> {\n         ident: Ident,\n         ty: &hir::Ty<'_>,\n         default: Option<hir::BodyId>,\n-        vis: &hir::Visibility<'_>,\n     ) {\n-        self.word(visibility_qualified(vis, \"\"));\n+        self.head(\"\");\n         self.word_space(\"const\");\n         self.print_ident(ident);\n         self.word_space(\":\");\n@@ -472,7 +460,7 @@ impl<'a> State<'a> {\n         generics: &hir::Generics<'_>,\n         inner: impl Fn(&mut Self),\n     ) {\n-        self.head(visibility_qualified(&item.vis, \"type\"));\n+        self.head(\"type\");\n         self.print_ident(item.ident);\n         self.print_generic_params(&generics.params);\n         self.end(); // end the inner ibox\n@@ -493,7 +481,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, AnnNode::Item(item));\n         match item.kind {\n             hir::ItemKind::ExternCrate(orig_name) => {\n-                self.head(visibility_qualified(&item.vis, \"extern crate\"));\n+                self.head(\"extern crate\");\n                 if let Some(orig_name) = orig_name {\n                     self.print_name(orig_name);\n                     self.space();\n@@ -506,7 +494,7 @@ impl<'a> State<'a> {\n                 self.end(); // end outer head-block\n             }\n             hir::ItemKind::Use(ref path, kind) => {\n-                self.head(visibility_qualified(&item.vis, \"use\"));\n+                self.head(\"use\");\n                 self.print_path(path, false);\n \n                 match kind {\n@@ -525,7 +513,7 @@ impl<'a> State<'a> {\n                 self.end(); // end outer head-block\n             }\n             hir::ItemKind::Static(ref ty, m, expr) => {\n-                self.head(visibility_qualified(&item.vis, \"static\"));\n+                self.head(\"static\");\n                 if m == hir::Mutability::Mut {\n                     self.word_space(\"mut\");\n                 }\n@@ -541,7 +529,7 @@ impl<'a> State<'a> {\n                 self.end(); // end the outer cbox\n             }\n             hir::ItemKind::Const(ref ty, expr) => {\n-                self.head(visibility_qualified(&item.vis, \"const\"));\n+                self.head(\"const\");\n                 self.print_ident(item.ident);\n                 self.word_space(\":\");\n                 self.print_type(&ty);\n@@ -560,7 +548,6 @@ impl<'a> State<'a> {\n                     sig.header,\n                     Some(item.ident.name),\n                     param_names,\n-                    &item.vis,\n                     &[],\n                     Some(body),\n                 );\n@@ -570,12 +557,10 @@ impl<'a> State<'a> {\n                 self.ann.nested(self, Nested::Body(body));\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n-                self.print_mac_def(macro_def, &item.ident, item.span, |state| {\n-                    state.print_visibility(&item.vis)\n-                });\n+                self.print_mac_def(macro_def, &item.ident, item.span, |_| {});\n             }\n             hir::ItemKind::Mod(ref _mod) => {\n-                self.head(visibility_qualified(&item.vis, \"mod\"));\n+                self.head(\"mod\");\n                 self.print_ident(item.ident);\n                 self.nbsp();\n                 self.bopen();\n@@ -593,7 +578,7 @@ impl<'a> State<'a> {\n                 self.bclose(item.span);\n             }\n             hir::ItemKind::GlobalAsm(ref asm) => {\n-                self.head(visibility_qualified(&item.vis, \"global_asm!\"));\n+                self.head(\"global_asm!\");\n                 self.print_inline_asm(asm);\n                 self.end()\n             }\n@@ -619,14 +604,14 @@ impl<'a> State<'a> {\n                 });\n             }\n             hir::ItemKind::Enum(ref enum_definition, ref params) => {\n-                self.print_enum_def(enum_definition, params, item.ident.name, item.span, &item.vis);\n+                self.print_enum_def(enum_definition, params, item.ident.name, item.span);\n             }\n             hir::ItemKind::Struct(ref struct_def, ref generics) => {\n-                self.head(visibility_qualified(&item.vis, \"struct\"));\n+                self.head(\"struct\");\n                 self.print_struct(struct_def, generics, item.ident.name, item.span, true);\n             }\n             hir::ItemKind::Union(ref struct_def, ref generics) => {\n-                self.head(visibility_qualified(&item.vis, \"union\"));\n+                self.head(\"union\");\n                 self.print_struct(struct_def, generics, item.ident.name, item.span, true);\n             }\n             hir::ItemKind::Impl(hir::Impl {\n@@ -641,7 +626,6 @@ impl<'a> State<'a> {\n                 items,\n             }) => {\n                 self.head(\"\");\n-                self.print_visibility(&item.vis);\n                 self.print_defaultness(defaultness);\n                 self.print_unsafety(unsafety);\n                 self.word_nbsp(\"impl\");\n@@ -678,7 +662,6 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, trait_items) => {\n                 self.head(\"\");\n-                self.print_visibility(&item.vis);\n                 self.print_is_auto(is_auto);\n                 self.print_unsafety(unsafety);\n                 self.word_nbsp(\"trait\");\n@@ -704,7 +687,7 @@ impl<'a> State<'a> {\n                 self.bclose(item.span);\n             }\n             hir::ItemKind::TraitAlias(ref generics, ref bounds) => {\n-                self.head(visibility_qualified(&item.vis, \"trait\"));\n+                self.head(\"trait\");\n                 self.print_ident(item.ident);\n                 self.print_generic_params(&generics.params);\n                 let mut real_bounds = Vec::with_capacity(bounds.len());\n@@ -752,9 +735,8 @@ impl<'a> State<'a> {\n         generics: &hir::Generics<'_>,\n         name: Symbol,\n         span: rustc_span::Span,\n-        visibility: &hir::Visibility<'_>,\n     ) {\n-        self.head(visibility_qualified(visibility, \"enum\"));\n+        self.head(\"enum\");\n         self.print_name(name);\n         self.print_generic_params(&generics.params);\n         self.print_where_clause(&generics.where_clause);\n@@ -777,27 +759,6 @@ impl<'a> State<'a> {\n         self.bclose(span)\n     }\n \n-    pub fn print_visibility(&mut self, vis: &hir::Visibility<'_>) {\n-        match vis.node {\n-            hir::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n-            hir::VisibilityKind::Crate(ast::CrateSugar::JustCrate) => self.word_nbsp(\"crate\"),\n-            hir::VisibilityKind::Crate(ast::CrateSugar::PubCrate) => self.word_nbsp(\"pub(crate)\"),\n-            hir::VisibilityKind::Restricted { ref path, .. } => {\n-                self.word(\"pub(\");\n-                if path.segments.len() == 1 && path.segments[0].ident.name == kw::Super {\n-                    // Special case: `super` can print like `pub(super)`.\n-                    self.word(\"super\");\n-                } else {\n-                    // Everything else requires `in` at present.\n-                    self.word_nbsp(\"in\");\n-                    self.print_path(path, false);\n-                }\n-                self.word_nbsp(\")\");\n-            }\n-            hir::VisibilityKind::Inherited => (),\n-        }\n-    }\n-\n     pub fn print_defaultness(&mut self, defaultness: hir::Defaultness) {\n         match defaultness {\n             hir::Defaultness::Default { .. } => self.word_nbsp(\"default\"),\n@@ -822,7 +783,6 @@ impl<'a> State<'a> {\n                     self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n                         s.maybe_print_comment(field.span.lo());\n                         s.print_outer_attributes(s.attrs(field.hir_id));\n-                        s.print_visibility(&field.vis);\n                         s.print_type(&field.ty)\n                     });\n                     self.pclose();\n@@ -844,7 +804,6 @@ impl<'a> State<'a> {\n                     self.hardbreak_if_not_bol();\n                     self.maybe_print_comment(field.span.lo());\n                     self.print_outer_attributes(self.attrs(field.hir_id));\n-                    self.print_visibility(&field.vis);\n                     self.print_ident(field.ident);\n                     self.word_nbsp(\":\");\n                     self.print_type(&field.ty);\n@@ -871,11 +830,10 @@ impl<'a> State<'a> {\n         ident: Ident,\n         m: &hir::FnSig<'_>,\n         generics: &hir::Generics<'_>,\n-        vis: &hir::Visibility<'_>,\n         arg_names: &[Ident],\n         body_id: Option<hir::BodyId>,\n     ) {\n-        self.print_fn(&m.decl, m.header, Some(ident.name), generics, vis, arg_names, body_id)\n+        self.print_fn(&m.decl, m.header, Some(ident.name), generics, arg_names, body_id)\n     }\n \n     pub fn print_trait_item(&mut self, ti: &hir::TraitItem<'_>) {\n@@ -885,21 +843,15 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(self.attrs(ti.hir_id()));\n         match ti.kind {\n             hir::TraitItemKind::Const(ref ty, default) => {\n-                let vis =\n-                    Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Inherited };\n-                self.print_associated_const(ti.ident, &ty, default, &vis);\n+                self.print_associated_const(ti.ident, &ty, default);\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(ref arg_names)) => {\n-                let vis =\n-                    Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Inherited };\n-                self.print_method_sig(ti.ident, sig, &ti.generics, &vis, arg_names, None);\n+                self.print_method_sig(ti.ident, sig, &ti.generics, arg_names, None);\n                 self.word(\";\");\n             }\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                let vis =\n-                    Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Inherited };\n                 self.head(\"\");\n-                self.print_method_sig(ti.ident, sig, &ti.generics, &vis, &[], Some(body));\n+                self.print_method_sig(ti.ident, sig, &ti.generics, &[], Some(body));\n                 self.nbsp();\n                 self.end(); // need to close a box\n                 self.end(); // need to close a box\n@@ -925,11 +877,11 @@ impl<'a> State<'a> {\n \n         match ii.kind {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n-                self.print_associated_const(ii.ident, &ty, Some(expr), &ii.vis);\n+                self.print_associated_const(ii.ident, &ty, Some(expr));\n             }\n             hir::ImplItemKind::Fn(ref sig, body) => {\n                 self.head(\"\");\n-                self.print_method_sig(ii.ident, sig, &ii.generics, &ii.vis, &[], Some(body));\n+                self.print_method_sig(ii.ident, sig, &ii.generics, &[], Some(body));\n                 self.nbsp();\n                 self.end(); // need to close a box\n                 self.end(); // need to close a box\n@@ -2007,11 +1959,10 @@ impl<'a> State<'a> {\n         header: hir::FnHeader,\n         name: Option<Symbol>,\n         generics: &hir::Generics<'_>,\n-        vis: &hir::Visibility<'_>,\n         arg_names: &[Ident],\n         body_id: Option<hir::BodyId>,\n     ) {\n-        self.print_fn_header_info(header, vis);\n+        self.print_fn_header_info(header);\n \n         if let Some(name) = name {\n             self.nbsp();\n@@ -2300,16 +2251,13 @@ impl<'a> State<'a> {\n             },\n             name,\n             &generics,\n-            &Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Inherited },\n             arg_names,\n             None,\n         );\n         self.end();\n     }\n \n-    pub fn print_fn_header_info(&mut self, header: hir::FnHeader, vis: &hir::Visibility<'_>) {\n-        self.word(visibility_qualified(vis, \"\"));\n-\n+    pub fn print_fn_header_info(&mut self, header: hir::FnHeader) {\n         match header.constness {\n             hir::Constness::NotConst => {}\n             hir::Constness::Const => self.word_nbsp(\"const\"),"}, {"sha": "201863ede2f1cf48ca2fa776f5f35521adb11c3e", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e8046f67ad688ae1deb30922e08a224d9964b1e/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8046f67ad688ae1deb30922e08a224d9964b1e/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=4e8046f67ad688ae1deb30922e08a224d9964b1e", "patch": "@@ -272,7 +272,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 v.process_generic_params(&generics, &method_data.qualname, hir_id);\n \n                 method_data.value =\n-                    fn_to_string(sig.decl, sig.header, Some(ident.name), generics, vis, &[], None);\n+                    fn_to_string(sig.decl, sig.header, Some(ident.name), generics, &[], None);\n                 method_data.sig = sig::method_signature(hir_id, ident, generics, sig, &v.save_ctxt);\n \n                 v.dumper.dump_def(&access_from_vis!(v.save_ctxt, vis, def_id), method_data);"}, {"sha": "582186cbd1fe7221c30c5655bc4c9b7fe97b1421", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e8046f67ad688ae1deb30922e08a224d9964b1e/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e8046f67ad688ae1deb30922e08a224d9964b1e/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=4e8046f67ad688ae1deb30922e08a224d9964b1e", "patch": "@@ -164,7 +164,6 @@ impl<'tcx> SaveContext<'tcx> {\n                         },\n                         Some(item.ident.name),\n                         generics,\n-                        &item.vis,\n                         arg_names,\n                         None,\n                     ),\n@@ -220,7 +219,6 @@ impl<'tcx> SaveContext<'tcx> {\n                         sig.header,\n                         Some(item.ident.name),\n                         generics,\n-                        &item.vis,\n                         &[],\n                         None,\n                     ),\n@@ -309,7 +307,7 @@ impl<'tcx> SaveContext<'tcx> {\n                 let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n                 filter!(self.span_utils, item.ident.span);\n                 let value =\n-                    enum_def_to_string(def, generics, item.ident.name, item.span, &item.vis);\n+                    enum_def_to_string(def, generics, item.ident.name, item.span);\n                 Some(Data::DefData(Def {\n                     kind: DefKind::Enum,\n                     id: id_from_def_id(def_id),"}]}