{"sha": "9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMjY5YTNhYThmZTgxNDBhZDNmMmZjMmNmZGZkNjhkNmI0MGVjODY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-08T10:56:16Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-08T11:03:48Z"}, "message": "Allow binding of nested patterns\n\nSee src/test/run-pass/nested-patterns.rs for some examples. The syntax is\n\n    boundvar@subpattern\n\nWhich will match the subpattern as usual, but also bind boundvar to the\nwhole matched value.\n\nCloses #838", "tree": {"sha": "efb59785d520476c50204eadce27bfb9128ca512", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efb59785d520476c50204eadce27bfb9128ca512"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "html_url": "https://github.com/rust-lang/rust/commit/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c966b7b18a5529c33dd9766460880bd681ab102", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c966b7b18a5529c33dd9766460880bd681ab102", "html_url": "https://github.com/rust-lang/rust/commit/8c966b7b18a5529c33dd9766460880bd681ab102"}], "stats": {"total": 211, "additions": 132, "deletions": 79}, "files": [{"sha": "3d081c143f349acae38e763f091b717afed7de84", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -585,8 +585,9 @@ fn pattern_roots(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat)\n             &set: [pattern_root]) {\n         alt pat.node {\n           ast::pat_wild. | ast::pat_lit(_) | ast::pat_range(_, _) {}\n-          ast::pat_bind(nm) {\n+          ast::pat_bind(nm, sub) {\n             set += [{id: pat.id, name: nm, mut: mut, span: pat.span}];\n+            alt sub { some(p) { walk(tcx, mut, p, set); } _ {} }\n           }\n           ast::pat_tag(_, ps) | ast::pat_tup(ps) {\n             for p in ps { walk(tcx, mut, p, set); }"}, {"sha": "8e83105199a42d72416ad4a1eeebfcac0916b881", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -2,6 +2,7 @@ import syntax::ast::*;\n import syntax::ast_util::{variant_def_ids, dummy_sp, compare_lit_exprs,\n                           lit_expr_eq};\n import syntax::visit;\n+import std::option::{some, none};\n \n fn check_crate(tcx: ty::ctxt, crate: @crate) {\n     let v =\n@@ -64,57 +65,58 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n     }\n \n     alt a.node {\n-      pat_wild. | pat_bind(_) { ret true; }\n+      pat_bind(_, some(p)) { pattern_supersedes(tcx, p, b) }\n+      pat_wild. | pat_bind(_, none.) { true }\n       pat_lit(la) {\n         alt b.node {\n-          pat_lit(lb) { ret lit_expr_eq(la, lb); }\n-          _ { ret false; }\n+          pat_lit(lb) { lit_expr_eq(la, lb) }\n+          _ { false }\n         }\n       }\n       pat_tag(va, suba) {\n         alt b.node {\n           pat_tag(vb, subb) {\n-            ret tcx.def_map.get(a.id) == tcx.def_map.get(b.id) &&\n-                    patterns_supersede(tcx, suba, subb);\n+            tcx.def_map.get(a.id) == tcx.def_map.get(b.id) &&\n+                patterns_supersede(tcx, suba, subb)\n           }\n-          _ { ret false; }\n+          _ { false }\n         }\n       }\n       pat_rec(suba, _) {\n         alt b.node {\n-          pat_rec(subb, _) { ret field_patterns_supersede(tcx, suba, subb); }\n-          _ { ret false; }\n+          pat_rec(subb, _) { field_patterns_supersede(tcx, suba, subb) }\n+          _ { false }\n         }\n       }\n       pat_tup(suba) {\n         alt b.node {\n-          pat_tup(subb) { ret patterns_supersede(tcx, suba, subb); }\n-          _ { ret false; }\n+          pat_tup(subb) { patterns_supersede(tcx, suba, subb) }\n+          _ { false }\n         }\n       }\n       pat_box(suba) {\n         alt b.node {\n-          pat_box(subb) { ret pattern_supersedes(tcx, suba, subb); }\n-          _ { ret pattern_supersedes(tcx, suba, b); }\n+          pat_box(subb) { pattern_supersedes(tcx, suba, subb) }\n+          _ { pattern_supersedes(tcx, suba, b) }\n         }\n       }\n       pat_uniq(suba) {\n         alt b.node {\n-          pat_uniq(subb) { ret pattern_supersedes(tcx, suba, subb); }\n-          _ { ret pattern_supersedes(tcx, suba, b); }\n+          pat_uniq(subb) { pattern_supersedes(tcx, suba, subb) }\n+          _ { pattern_supersedes(tcx, suba, b) }\n         }\n       }\n       pat_range(begina, enda) {\n         alt b.node {\n           pat_lit(lb) {\n-            ret compare_lit_exprs(begina, lb) <= 0 &&\n-                compare_lit_exprs(enda, lb) >= 0;\n+            compare_lit_exprs(begina, lb) <= 0 &&\n+            compare_lit_exprs(enda, lb) >= 0\n           }\n           pat_range(beginb, endb) {\n-            ret compare_lit_exprs(begina, beginb) <= 0 &&\n-                compare_lit_exprs(enda, endb) >= 0;\n+            compare_lit_exprs(begina, beginb) <= 0 &&\n+            compare_lit_exprs(enda, endb) >= 0\n           }\n-          _ { ret false; }\n+          _ { false }\n         }\n       }\n     }\n@@ -130,25 +132,26 @@ fn check_local(tcx: ty::ctxt, loc: @local, &&s: (), v: visit::vt<()>) {\n \n fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n     alt pat.node {\n-      pat_wild. | pat_bind(_) { ret false; }\n-      pat_lit(_) { ret true; }\n-      pat_box(sub) { ret is_refutable(tcx, sub); }\n-      pat_uniq(sub) { ret is_refutable(tcx, sub); }\n+      pat_box(sub) | pat_uniq(sub) | pat_bind(_, some(sub)) {\n+        is_refutable(tcx, sub)\n+      }\n+      pat_wild. | pat_bind(_, none.) { false }\n+      pat_lit(_) { true }\n       pat_rec(fields, _) {\n         for field: field_pat in fields {\n             if is_refutable(tcx, field.pat) { ret true; }\n         }\n-        ret false;\n+        false\n       }\n       pat_tup(elts) {\n         for elt in elts { if is_refutable(tcx, elt) { ret true; } }\n-        ret false;\n+        false\n       }\n       pat_tag(_, args) {\n         let vdef = variant_def_ids(tcx.def_map.get(pat.id));\n         if std::vec::len(ty::tag_variants(tcx, vdef.tg)) != 1u { ret true; }\n         for p: @pat in args { if is_refutable(tcx, p) { ret true; } }\n-        ret false;\n+        false\n       }\n     }\n }"}, {"sha": "7ed27f2502d221fe5c6917db7c93802f7b06e6fb", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -819,7 +819,7 @@ fn lookup_in_ty_params(name: ident, ty_params: [ast::ty_param]) ->\n fn lookup_in_pat(name: ident, pat: @ast::pat) -> option::t<def_id> {\n     let found = none;\n     ast_util::pat_bindings(pat) {|bound|\n-        let p_name = alt bound.node { ast::pat_bind(n) { n } };\n+        let p_name = alt bound.node { ast::pat_bind(n, _) { n } };\n         if str::eq(p_name, name) { found = some(local_def(bound.id)); }\n     };\n     ret found;\n@@ -1376,7 +1376,7 @@ fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n \n fn check_pat(ch: checker, p: @ast::pat) {\n     ast_util::pat_bindings(p) {|p|\n-        let ident = alt p.node { pat_bind(n) { n } };\n+        let ident = alt p.node { pat_bind(n, _) { n } };\n         add_name(ch, p.span, ident);\n     };\n }\n@@ -1424,7 +1424,7 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n                 let local_values = checker(*e, \"value\");\n                 for (_, loc) in locs {\n                     ast_util::pat_bindings(loc.node.pat) {|p|\n-                        let ident = alt p.node { pat_bind(n) { n } };\n+                        let ident = alt p.node { pat_bind(n, _) { n } };\n                         add_name(local_values, p.span, ident);\n                         check_name(values, p.span, ident);\n                     };"}, {"sha": "104085579b5bcd450add0f559c73fc54906de4b5", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -4702,7 +4702,7 @@ fn alloc_ty(cx: @block_ctxt, t: ty::t) -> result {\n fn alloc_local(cx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     let t = node_id_type(bcx_ccx(cx), local.node.id);\n     let is_simple = alt local.node.pat.node {\n-      ast::pat_bind(_) { true } _ { false }\n+      ast::pat_bind(_, none.) { true } _ { false }\n     };\n     // Do not allocate space for locals that can be kept immediate.\n     let ccx = bcx_ccx(cx);\n@@ -4716,7 +4716,7 @@ fn alloc_local(cx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     }\n     let r = alloc_ty(cx, t);\n     alt local.node.pat.node {\n-      ast::pat_bind(ident) {\n+      ast::pat_bind(ident, none.) {\n         if bcx_ccx(cx).sess.get_opts().debuginfo {\n             let _: () = str::as_buf(ident, {|buf|\n                 llvm::LLVMSetValueName(r.val, buf)"}, {"sha": "3b729a819e3a7da1e46c0f67953fd702f0f71866", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 49, "deletions": 19, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -88,14 +88,31 @@ type match_branch =\n               id_map: ast_util::pat_id_map}};\n type match = [match_branch];\n \n-fn matches_always(p: @ast::pat) -> bool {\n-    ret alt p.node {\n-          ast::pat_wild. { true }\n-          ast::pat_bind(_) { true }\n-          ast::pat_rec(_, _) { true }\n-          ast::pat_tup(_) { true }\n-          _ { false }\n-        };\n+fn has_nested_bindings(m: match, col: uint) -> bool {\n+    for br in m {\n+        alt br.pats[col].node {\n+          ast::pat_bind(_, some(_)) { ret true; }\n+          _ {}\n+        }\n+    }\n+    ret false;\n+}\n+\n+fn expand_nested_bindings(m: match, col: uint, val: ValueRef) -> match {\n+    let result = [];\n+    for br in m {\n+        alt br.pats[col].node {\n+          ast::pat_bind(name, some(inner)) {\n+            let pats = vec::slice(br.pats, 0u, col) + [inner] +\n+                vec::slice(br.pats, col + 1u, vec::len(br.pats));\n+            result += [@{pats: pats,\n+                         bound: br.bound + [{ident: name, val: val}]\n+                         with *br}];\n+          }\n+          _ { result += [br]; }\n+        }\n+    }\n+    result\n }\n \n type enter_pat = fn@(@ast::pat) -> option::t<[@ast::pat]>;\n@@ -109,7 +126,7 @@ fn enter_match(m: match, col: uint, val: ValueRef, e: enter_pat) -> match {\n                 vec::slice(br.pats, col + 1u, vec::len(br.pats));\n             let new_br = @{pats: pats,\n                            bound: alt br.pats[col].node {\n-                             ast::pat_bind(name) {\n+                             ast::pat_bind(name, none.) {\n                                br.bound + [{ident: name, val: val}]\n                              }\n                              _ { br.bound }\n@@ -123,6 +140,13 @@ fn enter_match(m: match, col: uint, val: ValueRef, e: enter_pat) -> match {\n }\n \n fn enter_default(m: match, col: uint, val: ValueRef) -> match {\n+    fn matches_always(p: @ast::pat) -> bool {\n+        ret alt p.node {\n+          ast::pat_wild. | ast::pat_bind(_, none.) | ast::pat_rec(_, _) |\n+          ast::pat_tup(_) { true }\n+          _ { false }\n+        };\n+    }\n     fn e(p: @ast::pat) -> option::t<[@ast::pat]> {\n         ret if matches_always(p) { some([]) } else { none };\n     }\n@@ -303,18 +327,17 @@ type exit_node = {bound: bind_map, from: BasicBlockRef, to: BasicBlockRef};\n type mk_fail = fn@() -> BasicBlockRef;\n \n fn pick_col(m: match) -> uint {\n+    fn score(p: @ast::pat) -> uint {\n+        alt p.node {\n+          ast::pat_lit(_) | ast::pat_tag(_, _) | ast::pat_range(_, _) { 1u }\n+          ast::pat_bind(_, some(p)) { score(p) }\n+          _ { 0u }\n+        }\n+    }\n     let scores = vec::init_elt_mut(0u, vec::len(m[0].pats));\n     for br: match_branch in m {\n         let i = 0u;\n-        for p: @ast::pat in br.pats {\n-            alt p.node {\n-              ast::pat_lit(_) | ast::pat_tag(_, _) | ast::pat_range(_, _) {\n-                scores[i] += 1u;\n-              }\n-              _ { }\n-            }\n-            i += 1u;\n-        }\n+        for p: @ast::pat in br.pats { scores[i] += score(p); i += 1u; }\n     }\n     let max_score = 0u;\n     let best_col = 0u;\n@@ -368,6 +391,9 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n \n     let col = pick_col(m);\n     let val = vals[col];\n+    let m = has_nested_bindings(m, col) ?\n+        expand_nested_bindings(m, col, val) : m;\n+\n     let vals_left =\n         vec::slice(vals, 0u, col) +\n             vec::slice(vals, col + 1u, vec::len(vals));\n@@ -662,7 +688,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n                         make_copy: bool) -> @block_ctxt {\n     let ccx = bcx.fcx.lcx.ccx, bcx = bcx;\n     alt pat.node {\n-      ast::pat_bind(_) {\n+      ast::pat_bind(_, inner) {\n         if make_copy || ccx.copy_map.contains_key(pat.id) {\n             let ty = ty::node_id_to_monotype(ccx.tcx, pat.id);\n             // FIXME: Could constrain pat_bind to make this\n@@ -676,6 +702,10 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n             bcx.fcx.lllocals.insert(pat.id, local_mem(alloc));\n             trans_common::add_clean(bcx, alloc, ty);\n         } else { bcx.fcx.lllocals.insert(pat.id, local_mem(val)); }\n+        alt inner {\n+          some(pat) { bcx = bind_irrefutable_pat(bcx, pat, val, true); }\n+          _ {}\n+        }\n       }\n       ast::pat_tag(_, sub) {\n         if vec::len(sub) == 0u { ret bcx; }"}, {"sha": "c156bb739ffbb56916b959bd791430fe5a2f56e2", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -1048,7 +1048,7 @@ type binding = {lhs: [inst], rhs: option::t<initializer>};\n fn local_to_bindings(loc: @local) -> binding {\n     let lhs = [];\n     pat_bindings(loc.node.pat) {|p|\n-        let ident = alt p.node { pat_bind(name) { name } };\n+        let ident = alt p.node { pat_bind(name, _) { name } };\n         lhs += [{ident: ident, node: p.id}];\n     };\n     {lhs: lhs, rhs: loc.node.init}"}, {"sha": "e5166a5e6bac4a1d81b6a6a4ae6c096fb2158832", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -12,7 +12,7 @@ type ctxt = {cs: @mutable [sp_constr], tcx: ty::ctxt};\n \n fn collect_local(loc: @local, cx: ctxt, v: visit::vt<ctxt>) {\n     pat_bindings(loc.node.pat) {|p|\n-        let ident = alt p.node { pat_bind(id) { id } };\n+        let ident = alt p.node { pat_bind(id, _) { id } };\n         log \"collect_local: pushing \" + ident;;\n         *cx.cs += [respan(loc.span, ninit(p.id, ident))];\n     };"}, {"sha": "4e54b405542a434a419152b88ad1a7c9d6c3a6a0", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -108,7 +108,7 @@ fn find_pre_post_loop(fcx: fn_ctxt, l: @local, index: @expr, body: blk,\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n     pat_bindings(l.node.pat) {|p|\n-        let ident = alt p.node { pat_bind(id) { id } };\n+        let ident = alt p.node { pat_bind(id, _) { id } };\n         let v_init = ninit(p.id, ident);\n         relax_precond_block(fcx, bit_num(fcx, v_init) as node_id, body);\n         // Hack: for-loop index variables are frequently ignored,\n@@ -579,11 +579,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                         /* FIXME: This won't be necessary when typestate\n                         works well enough for pat_bindings to return a\n                         refinement-typed thing. */\n-                        let ident = alt pat.node {\n-                          pat_bind(n) { n }\n-                          _ { fcx.ccx.tcx.sess.span_bug(pat.span,\n-                                                        \"Impossible LHS\"); }\n-                        };\n+                        let ident = alt pat.node { pat_bind(n, _) { n } };\n                         alt p {\n                           some(p) {\n                             copy_in_postcond(fcx, id,\n@@ -612,14 +608,10 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                      postconds of the RHSs themselves */\n                     pat_bindings(alocal.node.pat) {|pat|\n                         alt pat.node {\n-                          pat_bind(n) {\n+                          pat_bind(n, _) {\n                             set_in_postcond(bit_num(fcx, ninit(pat.id, n)),\n                                             prev_pp);\n                           }\n-                          _ {\n-                            fcx.ccx.tcx.sess.span_bug(pat.span,\n-                                                      \"Impossible LHS\");\n-                          }\n                         }\n                     };\n                     copy_pre_post_(fcx.ccx, id, prev_pp.precondition,"}, {"sha": "2b47baed9eedc5fbefca0a130e9841387a40f9d0", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -206,7 +206,7 @@ fn find_pre_post_state_loop(fcx: fn_ctxt, pres: prestate, l: @local,\n     // in the body\n     let index_post = tritv_clone(expr_poststate(fcx.ccx, index));\n     pat_bindings(l.node.pat) {|p|\n-        let ident = alt p.node { pat_bind(name) { name } };\n+        let ident = alt p.node { pat_bind(name, _) { name } };\n         set_in_poststate_ident(fcx, p.id, ident, index_post);\n     };\n "}, {"sha": "34fc1816c3fccaf96b8413be584217bdbd1bf80a", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -1178,7 +1178,7 @@ fn gather_locals(ccx: @crate_ctxt, f: ast::_fn, id: ast::node_id,\n     let visit_pat =\n         lambda (p: @ast::pat, &&e: (), v: visit::vt<()>) {\n             alt p.node {\n-              ast::pat_bind(_) { assign(p.id, none); }\n+              ast::pat_bind(_, _) { assign(p.id, none); }\n               _ {/* no-op */ }\n             }\n             visit::visit_pat(p, e, v);\n@@ -1248,7 +1248,7 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n         }\n         write::ty_only_fixup(fcx, pat.id, b_ty);\n       }\n-      ast::pat_bind(name) {\n+      ast::pat_bind(name, sub) {\n         let vid = lookup_local(fcx, pat.span, pat.id);\n         let typ = ty::mk_var(fcx.ccx.tcx, vid);\n         typ = demand::simple(fcx, pat.span, expected, typ);\n@@ -1260,6 +1260,10 @@ fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n             typ = demand::simple(fcx, pat.span, ct, typ);\n         }\n         write::ty_only_fixup(fcx, pat.id, typ);\n+        alt sub {\n+          some(p) { check_pat(fcx, map, p, expected); }\n+          _ {}\n+        }\n       }\n       ast::pat_tag(path, subpats) {\n         // Typecheck the path."}, {"sha": "30acee6dc68e02f7657f34533bd902b11d49e4d4", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -92,7 +92,7 @@ type field_pat = {ident: ident, pat: @pat};\n \n tag pat_ {\n     pat_wild;\n-    pat_bind(ident);\n+    pat_bind(ident, option::t<@pat>);\n     pat_tag(@path, [@pat]);\n     pat_rec([field_pat], bool);\n     pat_tup([@pat]);"}, {"sha": "794d4bf5339fd36fcc8f864a21f7b9bdf5e4f6b0", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -58,7 +58,7 @@ type pat_id_map = std::map::hashmap<str, node_id>;\n fn pat_id_map(pat: @pat) -> pat_id_map {\n     let map = std::map::new_str_hash::<node_id>();\n     pat_bindings(pat) {|bound|\n-        let name = alt bound.node { pat_bind(n) { n } };\n+        let name = alt bound.node { pat_bind(n, _) { n } };\n         map.insert(name, bound.id);\n     };\n     ret map;\n@@ -67,7 +67,8 @@ fn pat_id_map(pat: @pat) -> pat_id_map {\n // FIXME: could return a constrained type\n fn pat_bindings(pat: @pat, it: block(@pat)) {\n     alt pat.node {\n-      pat_bind(_) { it(pat); }\n+      pat_bind(_, option::none.) { it(pat); }\n+      pat_bind(_, option::some(sub)) { it(pat); pat_bindings(sub, it); }\n       pat_tag(_, sub) { for p in sub { pat_bindings(p, it); } }\n       pat_rec(fields, _) { for f in fields { pat_bindings(f.pat, it); } }\n       pat_tup(elts) { for elt in elts { pat_bindings(elt, it); } }"}, {"sha": "ce82c4d7c3b2eb45bedb2b12e8a93af996d9e90c", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -270,7 +270,9 @@ fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n     ret alt p {\n           pat_wild. { p }\n-          pat_bind(ident) { pat_bind(fld.fold_ident(ident)) }\n+          pat_bind(ident, sub) {\n+            pat_bind(fld.fold_ident(ident), option::map(fld.fold_pat, sub))\n+          }\n           pat_lit(_) { p }\n           pat_tag(pth, pats) {\n             pat_tag(fld.fold_path(pth), vec::map(fld.fold_pat, pats))"}, {"sha": "5748637fde4085431a99839c4eb01ecd10d3565b", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -1429,10 +1429,9 @@ fn parse_pat(p: parser) -> @ast::pat {\n                 if p.get_bad_expr_words().contains_key(fieldname) {\n                     p.fatal(\"found \" + fieldname + \" in binding position\");\n                 }\n-                subpat =\n-                    @{id: p.get_id(),\n-                      node: ast::pat_bind(fieldname),\n-                      span: ast_util::mk_sp(lo, hi)};\n+                subpat = @{id: p.get_id(),\n+                           node: ast::pat_bind(fieldname, none),\n+                           span: ast_util::mk_sp(lo, hi)};\n             }\n             fields += [{ident: fieldname, pat: subpat}];\n         }\n@@ -1479,7 +1478,9 @@ fn parse_pat(p: parser) -> @ast::pat {\n                         _ { true }\n                       } {\n             hi = p.get_hi_pos();\n-            pat = ast::pat_bind(parse_value_ident(p));\n+            let name = parse_value_ident(p);\n+            let sub = eat(p, token::AT) ? some(parse_pat(p)) : none;\n+            pat = ast::pat_bind(name, sub);\n         } else {\n             let tag_path = parse_path_and_ty_param_substs(p);\n             hi = tag_path.span.hi;"}, {"sha": "ff28edd057a13655873d6072f1d0e0c33a6a2368", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -1062,7 +1062,13 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n     s.ann.pre(ann_node);\n     alt pat.node {\n       ast::pat_wild. { word(s.s, \"_\"); }\n-      ast::pat_bind(id) { word(s.s, id); }\n+      ast::pat_bind(id, sub) {\n+        word(s.s, id);\n+        alt sub {\n+          some(p) { word(s.s, \"@\"); print_pat(s, p); }\n+          _ {}\n+        }\n+      }\n       ast::pat_tag(path, args) {\n         print_path(s, path, true);\n         if vec::len(args) > 0u {"}, {"sha": "9e61d82287cf3a7728abdfe35e8e10dc88e33b4d", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -159,8 +159,9 @@ fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n         for f: field_pat in fields { v.visit_pat(f.pat, e, v); }\n       }\n       pat_tup(elts) { for elt in elts { v.visit_pat(elt, e, v); } }\n-      pat_box(inner) { v.visit_pat(inner, e, v); }\n-      pat_uniq(inner) { v.visit_pat(inner, e, v); }\n+      pat_box(inner) | pat_uniq(inner) | pat_bind(_, some(inner)) {\n+        v.visit_pat(inner, e, v);\n+      }\n       _ { }\n     }\n }"}, {"sha": "79eb1d40e4d1acea6bf765a624eec4f982aa3a6b", "filename": "src/test/run-pass/nested-patterns.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Ftest%2Frun-pass%2Fnested-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86/src%2Ftest%2Frun-pass%2Fnested-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-patterns.rs?ref=9a269a3aa8fe8140ad3f2fc2cfdfd68d6b40ec86", "patch": "@@ -0,0 +1,12 @@\n+fn main() {\n+    alt {a: 10, b: @20} {\n+        x@{a, b: @20} { assert x.a == 10; assert a == 10; }\n+        {b, _} { fail; }\n+    }\n+    let x@{b, _} = {a: 10, b: {mutable c: 20}};\n+    x.b.c = 30;\n+    assert b.c == 20;\n+    let y@{d, _} = {a: 10, d: {mutable c: 20}};\n+    y.d.c = 30;\n+    assert d.c == 20;\n+}"}]}