{"sha": "0ecff8c623fa29cccad6f946c657e81dacd85847", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlY2ZmOGM2MjNmYTI5Y2NjYWQ2Zjk0NmM2NTdlODFkYWNkODU4NDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-19T04:22:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-07-19T04:22:51Z"}, "message": "Auto merge of #87146 - Aaron1011:better-macro-lint, r=petrochenkov\n\nCompute a better `lint_node_id` during expansion\n\nWhen we need to emit a lint at a macro invocation, we currently use the\n`NodeId` of its parent definition (e.g. the enclosing function). This\nmeans that any `#[allow]` / `#[deny]` attributes placed 'closer' to the\nmacro (e.g. on an enclosing block or statement) will have no effect.\n\nThis commit computes a better `lint_node_id` in `InvocationCollector`.\nWhen we visit/flat_map an AST node, we assign it a `NodeId` (earlier\nthan we normally would), and store than `NodeId` in current\n`ExpansionData`. When we collect a macro invocation, the current\n`lint_node_id` gets cloned along with our `ExpansionData`, allowing it\nto be used if we need to emit a lint later on.\n\nThis improves the handling of `#[allow]` / `#[deny]` for\n`SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` and some `asm!`-related lints.\nThe 'legacy derive helpers' lint retains its current behavior\n(I've inlined the now-removed `lint_node_id` function), since\nthere isn't an `ExpansionData` readily available.", "tree": {"sha": "55544579cafd394ca22ccd8cd8ab7179c39ed57f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55544579cafd394ca22ccd8cd8ab7179c39ed57f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ecff8c623fa29cccad6f946c657e81dacd85847", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ecff8c623fa29cccad6f946c657e81dacd85847", "html_url": "https://github.com/rust-lang/rust/commit/0ecff8c623fa29cccad6f946c657e81dacd85847", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ecff8c623fa29cccad6f946c657e81dacd85847/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10c0b003dbfee812788ac9f753a9b28bb3996b26", "url": "https://api.github.com/repos/rust-lang/rust/commits/10c0b003dbfee812788ac9f753a9b28bb3996b26", "html_url": "https://github.com/rust-lang/rust/commit/10c0b003dbfee812788ac9f753a9b28bb3996b26"}, {"sha": "1c1c7949ab6a8d4150b7e645ae4779677e86ebd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c1c7949ab6a8d4150b7e645ae4779677e86ebd1", "html_url": "https://github.com/rust-lang/rust/commit/1c1c7949ab6a8d4150b7e645ae4779677e86ebd1"}], "stats": {"total": 285, "additions": 226, "deletions": 59}, "files": [{"sha": "ff13f0d4e42079ee7d784a9f0f2517333ed86c10", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=0ecff8c623fa29cccad6f946c657e81dacd85847", "patch": "@@ -455,15 +455,15 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                 ecx.parse_sess().buffer_lint(\n                     lint::builtin::BAD_ASM_STYLE,\n                     find_span(\".intel_syntax\"),\n-                    ecx.resolver.lint_node_id(ecx.current_expansion.id),\n+                    ecx.current_expansion.lint_node_id,\n                     \"avoid using `.intel_syntax`, Intel syntax is the default\",\n                 );\n             }\n             if template_str.contains(\".att_syntax\") {\n                 ecx.parse_sess().buffer_lint(\n                     lint::builtin::BAD_ASM_STYLE,\n                     find_span(\".att_syntax\"),\n-                    ecx.resolver.lint_node_id(ecx.current_expansion.id),\n+                    ecx.current_expansion.lint_node_id,\n                     \"avoid using `.att_syntax`, prefer using `options(att_syntax)` instead\",\n                 );\n             }"}, {"sha": "1ea2c8843d6d7b3cdd4eaf7898a5fef05df98600", "filename": "compiler/rustc_builtin_macros/src/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fsource_util.rs?ref=0ecff8c623fa29cccad6f946c657e81dacd85847", "patch": "@@ -159,7 +159,7 @@ pub fn expand_include<'cx>(\n         }\n     }\n \n-    Box::new(ExpandResult { p, node_id: cx.resolver.lint_node_id(cx.current_expansion.id) })\n+    Box::new(ExpandResult { p, node_id: cx.current_expansion.lint_node_id })\n }\n \n // include_str! : read the given file, insert it as a literal string expr"}, {"sha": "8c6aef80635cf596c26137255496d728139ef303", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=0ecff8c623fa29cccad6f946c657e81dacd85847", "patch": "@@ -29,6 +29,9 @@ use std::rc::Rc;\n \n crate use rustc_span::hygiene::MacroKind;\n \n+// When adding new variants, make sure to\n+// adjust the `visit_*` / `flat_map_*` calls in `InvocationCollector`\n+// to use `assign_id!`\n #[derive(Debug, Clone)]\n pub enum Annotatable {\n     Item(P<ast::Item>),\n@@ -869,9 +872,6 @@ pub trait ResolverExpand {\n \n     fn check_unused_macros(&mut self);\n \n-    /// Some parent node that is close enough to the given macro call.\n-    fn lint_node_id(&self, expn_id: LocalExpnId) -> NodeId;\n-\n     // Resolver interfaces for specific built-in macros.\n     /// Does `#[derive(...)]` attribute with the given `ExpnId` have built-in `Copy` inside it?\n     fn has_derive_copy(&self, expn_id: LocalExpnId) -> bool;\n@@ -926,6 +926,8 @@ pub struct ExpansionData {\n     pub module: Rc<ModuleData>,\n     pub dir_ownership: DirOwnership,\n     pub prior_type_ascription: Option<(Span, bool)>,\n+    /// Some parent node that is close to this macro call\n+    pub lint_node_id: NodeId,\n }\n \n type OnExternModLoaded<'a> =\n@@ -971,6 +973,7 @@ impl<'a> ExtCtxt<'a> {\n                 module: Default::default(),\n                 dir_ownership: DirOwnership::Owned { relative: None },\n                 prior_type_ascription: None,\n+                lint_node_id: ast::CRATE_NODE_ID,\n             },\n             force_mode: false,\n             expansions: FxHashMap::default(),"}, {"sha": "dcd871c9d205056d64e0ec6af3d82005542a0d27", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 83, "deletions": 20, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=0ecff8c623fa29cccad6f946c657e81dacd85847", "patch": "@@ -12,7 +12,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AstLike, Block, Inline, ItemKind, MacArgs};\n+use rustc_ast::{AstLike, Block, Inline, ItemKind, Local, MacArgs};\n use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n use rustc_ast::{NodeId, PatKind, Path, StmtKind, Unsafe};\n use rustc_ast_pretty::pprust;\n@@ -1098,6 +1098,43 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n }\n \n+/// Wraps a call to `noop_visit_*` / `noop_flat_map_*`\n+/// for an AST node that supports attributes\n+/// (see the `Annotatable` enum)\n+/// This method assigns a `NodeId`, and sets that `NodeId`\n+/// as our current 'lint node id'. If a macro call is found\n+/// inside this AST node, we will use this AST node's `NodeId`\n+/// to emit lints associated with that macro (allowing\n+/// `#[allow]` / `#[deny]` to be applied close to\n+/// the macro invocation).\n+///\n+/// Do *not* call this for a macro AST node\n+/// (e.g. `ExprKind::MacCall`) - we cannot emit lints\n+/// at these AST nodes, since they are removed and\n+/// replaced with the result of macro expansion.\n+///\n+/// All other `NodeId`s are assigned by `visit_id`.\n+/// * `self` is the 'self' parameter for the current method,\n+/// * `id` is a mutable reference to the `NodeId` field\n+///    of the current AST node.\n+/// * `closure` is a closure that executes the\n+///   `noop_visit_*` / `noop_flat_map_*` method\n+///   for the current AST node.\n+macro_rules! assign_id {\n+    ($self:ident, $id:expr, $closure:expr) => {{\n+        let old_id = $self.cx.current_expansion.lint_node_id;\n+        if $self.monotonic {\n+            debug_assert_eq!(*$id, ast::DUMMY_NODE_ID);\n+            let new_id = $self.cx.resolver.next_node_id();\n+            *$id = new_id;\n+            $self.cx.current_expansion.lint_node_id = new_id;\n+        }\n+        let ret = ($closure)();\n+        $self.cx.current_expansion.lint_node_id = old_id;\n+        ret\n+    }};\n+}\n+\n impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n         self.cfg.configure_expr(expr);\n@@ -1118,12 +1155,19 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 self.check_attributes(&expr.attrs);\n                 self.collect_bang(mac, expr.span, AstFragmentKind::Expr).make_expr().into_inner()\n             } else {\n-                ensure_sufficient_stack(|| noop_visit_expr(&mut expr, self));\n+                assign_id!(self, &mut expr.id, || {\n+                    ensure_sufficient_stack(|| noop_visit_expr(&mut expr, self));\n+                });\n                 expr\n             }\n         });\n     }\n \n+    // This is needed in order to set `lint_node_id` for `let` statements\n+    fn visit_local(&mut self, local: &mut P<Local>) {\n+        assign_id!(self, &mut local.id, || noop_visit_local(local, self));\n+    }\n+\n     fn flat_map_arm(&mut self, arm: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n         let mut arm = configure!(self, arm);\n \n@@ -1133,7 +1177,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 .make_arms();\n         }\n \n-        noop_flat_map_arm(arm, self)\n+        assign_id!(self, &mut arm.id, || noop_flat_map_arm(arm, self))\n     }\n \n     fn flat_map_expr_field(&mut self, field: ast::ExprField) -> SmallVec<[ast::ExprField; 1]> {\n@@ -1145,7 +1189,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 .make_expr_fields();\n         }\n \n-        noop_flat_map_expr_field(field, self)\n+        assign_id!(self, &mut field.id, || noop_flat_map_expr_field(field, self))\n     }\n \n     fn flat_map_pat_field(&mut self, fp: ast::PatField) -> SmallVec<[ast::PatField; 1]> {\n@@ -1157,7 +1201,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 .make_pat_fields();\n         }\n \n-        noop_flat_map_pat_field(fp, self)\n+        assign_id!(self, &mut fp.id, || noop_flat_map_pat_field(fp, self))\n     }\n \n     fn flat_map_param(&mut self, p: ast::Param) -> SmallVec<[ast::Param; 1]> {\n@@ -1169,7 +1213,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 .make_params();\n         }\n \n-        noop_flat_map_param(p, self)\n+        assign_id!(self, &mut p.id, || noop_flat_map_param(p, self))\n     }\n \n     fn flat_map_field_def(&mut self, sf: ast::FieldDef) -> SmallVec<[ast::FieldDef; 1]> {\n@@ -1181,7 +1225,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 .make_field_defs();\n         }\n \n-        noop_flat_map_field_def(sf, self)\n+        assign_id!(self, &mut sf.id, || noop_flat_map_field_def(sf, self))\n     }\n \n     fn flat_map_variant(&mut self, variant: ast::Variant) -> SmallVec<[ast::Variant; 1]> {\n@@ -1193,7 +1237,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 .make_variants();\n         }\n \n-        noop_flat_map_variant(variant, self)\n+        assign_id!(self, &mut variant.id, || noop_flat_map_variant(variant, self))\n     }\n \n     fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n@@ -1214,9 +1258,11 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     .make_opt_expr()\n                     .map(|expr| expr.into_inner())\n             } else {\n-                Some({\n-                    noop_visit_expr(&mut expr, self);\n-                    expr\n+                assign_id!(self, &mut expr.id, || {\n+                    Some({\n+                        noop_visit_expr(&mut expr, self);\n+                        expr\n+                    })\n                 })\n             }\n         })\n@@ -1266,6 +1312,8 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         }\n \n         // The placeholder expander gives ids to statements, so we avoid folding the id here.\n+        // We don't use `assign_id!` - it will be called when we visit statement's contents\n+        // (e.g. an expression, item, or local)\n         let ast::Stmt { id, kind, span } = stmt;\n         noop_flat_map_stmt_kind(kind, self)\n             .into_iter()\n@@ -1377,7 +1425,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 let orig_dir_ownership =\n                     mem::replace(&mut self.cx.current_expansion.dir_ownership, dir_ownership);\n \n-                let result = noop_flat_map_item(item, self);\n+                let result = assign_id!(self, &mut item.id, || noop_flat_map_item(item, self));\n \n                 // Restore the module info.\n                 self.cx.current_expansion.dir_ownership = orig_dir_ownership;\n@@ -1387,7 +1435,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n             }\n             _ => {\n                 item.attrs = attrs;\n-                noop_flat_map_item(item, self)\n+                // The crate root is special - don't assign an ID to it.\n+                if !(matches!(item.kind, ast::ItemKind::Mod(..)) && ident == Ident::invalid()) {\n+                    assign_id!(self, &mut item.id, || noop_flat_map_item(item, self))\n+                } else {\n+                    noop_flat_map_item(item, self)\n+                }\n             }\n         }\n     }\n@@ -1411,7 +1464,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     _ => unreachable!(),\n                 })\n             }\n-            _ => noop_flat_map_assoc_item(item, self),\n+            _ => {\n+                assign_id!(self, &mut item.id, || noop_flat_map_assoc_item(item, self))\n+            }\n         }\n     }\n \n@@ -1434,7 +1489,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     _ => unreachable!(),\n                 })\n             }\n-            _ => noop_flat_map_assoc_item(item, self),\n+            _ => {\n+                assign_id!(self, &mut item.id, || noop_flat_map_assoc_item(item, self))\n+            }\n         }\n     }\n \n@@ -1478,7 +1535,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     _ => unreachable!(),\n                 })\n             }\n-            _ => noop_flat_map_foreign_item(foreign_item, self),\n+            _ => {\n+                assign_id!(self, &mut foreign_item.id, || noop_flat_map_foreign_item(\n+                    foreign_item,\n+                    self\n+                ))\n+            }\n         }\n     }\n \n@@ -1498,13 +1560,14 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 .make_generic_params();\n         }\n \n-        noop_flat_map_generic_param(param, self)\n+        assign_id!(self, &mut param.id, || noop_flat_map_generic_param(param, self))\n     }\n \n     fn visit_id(&mut self, id: &mut ast::NodeId) {\n-        if self.monotonic {\n-            debug_assert_eq!(*id, ast::DUMMY_NODE_ID);\n-            *id = self.cx.resolver.next_node_id()\n+        // We may have already assigned a `NodeId`\n+        // by calling `assign_id`\n+        if self.monotonic && *id == ast::DUMMY_NODE_ID {\n+            *id = self.cx.resolver.next_node_id();\n         }\n     }\n }"}, {"sha": "7f985af364d7dbf34369be8461e25bb690d69a91", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=0ecff8c623fa29cccad6f946c657e81dacd85847", "patch": "@@ -289,7 +289,6 @@ fn generic_extension<'cx>(\n \n                 let mut p = Parser::new(sess, tts, false, None);\n                 p.last_type_ascription = cx.current_expansion.prior_type_ascription;\n-                let lint_node_id = cx.resolver.lint_node_id(cx.current_expansion.id);\n \n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n@@ -301,7 +300,7 @@ fn generic_extension<'cx>(\n                     // macro leaves unparsed tokens.\n                     site_span: sp,\n                     macro_ident: name,\n-                    lint_node_id,\n+                    lint_node_id: cx.current_expansion.lint_node_id,\n                     arm_span,\n                 });\n             }"}, {"sha": "7a8b731da5c2ee5d327dd0a882371a9e2149ea93", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=0ecff8c623fa29cccad6f946c657e81dacd85847", "patch": "@@ -120,6 +120,12 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         })\n     }\n \n+    fn visit_expr_field(&mut self, f: &'a ast::ExprField) {\n+        self.with_lint_attrs(f.id, &f.attrs, |cx| {\n+            ast_visit::walk_expr_field(cx, f);\n+        })\n+    }\n+\n     fn visit_stmt(&mut self, s: &'a ast::Stmt) {\n         // Add the statement's lint attributes to our\n         // current state when checking the statement itself.\n@@ -204,8 +210,10 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n \n     fn visit_arm(&mut self, a: &'a ast::Arm) {\n-        run_early_pass!(self, check_arm, a);\n-        ast_visit::walk_arm(self, a);\n+        self.with_lint_attrs(a.id, &a.attrs, |cx| {\n+            run_early_pass!(cx, check_arm, a);\n+            ast_visit::walk_arm(cx, a);\n+        })\n     }\n \n     fn visit_expr_post(&mut self, e: &'a ast::Expr) {\n@@ -389,9 +397,15 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n     // All of the buffered lints should have been emitted at this point.\n     // If not, that means that we somehow buffered a lint for a node id\n     // that was not lint-checked (perhaps it doesn't exist?). This is a bug.\n-    for (_id, lints) in buffered.map {\n+    for (id, lints) in buffered.map {\n         for early_lint in lints {\n-            sess.delay_span_bug(early_lint.span, \"failed to process buffered lint here\");\n+            sess.delay_span_bug(\n+                early_lint.span,\n+                &format!(\n+                    \"failed to process buffered lint here (dummy = {})\",\n+                    id == ast::DUMMY_NODE_ID\n+                ),\n+            );\n         }\n     }\n }"}, {"sha": "4d85bf6b499d950ca010bc312b95781738615ea8", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=0ecff8c623fa29cccad6f946c657e81dacd85847", "patch": "@@ -274,15 +274,15 @@ impl<HCX> ToStableHashKey<HCX> for LintId {\n }\n \n // Duplicated from rustc_session::config::ExternDepSpec to avoid cyclic dependency\n-#[derive(PartialEq)]\n+#[derive(PartialEq, Debug)]\n pub enum ExternDepSpec {\n     Json(Json),\n     Raw(String),\n }\n \n // This could be a closure, but then implementing derive trait\n // becomes hacky (and it gets allocated).\n-#[derive(PartialEq)]\n+#[derive(PartialEq, Debug)]\n pub enum BuiltinLintDiagnostics {\n     Normal,\n     BareTraitObject(Span, /* is_global */ bool),"}, {"sha": "b2a8aa0ceccaaee3770dcad0259166f37ba7ad3f", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecff8c623fa29cccad6f946c657e81dacd85847/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=0ecff8c623fa29cccad6f946c657e81dacd85847", "patch": "@@ -281,7 +281,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         // Derives are not included when `invocations` are collected, so we have to add them here.\n         let parent_scope = &ParentScope { derives, ..parent_scope };\n         let supports_macro_expansion = invoc.fragment_kind.supports_macro_expansion();\n-        let node_id = self.lint_node_id(eager_expansion_root);\n+        let node_id = invoc.expansion_data.lint_node_id;\n         let (ext, res) = self.smart_resolve_macro_path(\n             path,\n             kind,\n@@ -348,14 +348,6 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         }\n     }\n \n-    fn lint_node_id(&self, expn_id: LocalExpnId) -> NodeId {\n-        // FIXME - make this more precise. This currently returns the NodeId of the\n-        // nearest closing item - we should try to return the closest parent of the ExpnId\n-        self.invocation_parents\n-            .get(&expn_id)\n-            .map_or(ast::CRATE_NODE_ID, |id| self.def_id_to_node_id[id.0])\n-    }\n-\n     fn has_derive_copy(&self, expn_id: LocalExpnId) -> bool {\n         self.containers_deriving_copy.contains(&expn_id)\n     }\n@@ -1105,9 +1097,13 @@ impl<'a> Resolver<'a> {\n                     let seg = Segment::from_ident(ident);\n                     check_consistency(self, &[seg], ident.span, kind, initial_res, res);\n                     if res == Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat) {\n+                        let node_id = self\n+                            .invocation_parents\n+                            .get(&parent_scope.expansion)\n+                            .map_or(ast::CRATE_NODE_ID, |id| self.def_id_to_node_id[id.0]);\n                         self.lint_buffer.buffer_lint_with_diagnostic(\n                             LEGACY_DERIVE_HELPERS,\n-                            self.lint_node_id(parent_scope.expansion),\n+                            node_id,\n                             ident.span,\n                             \"derive helper attribute is used before it is introduced\",\n                             BuiltinLintDiagnostics::LegacyDeriveHelpers(binding.span),"}, {"sha": "fff380934e8e9be3f682b211f087d1576ae8f79b", "filename": "src/test/ui/lint/semicolon-in-expressions-from-macros/semicolon-in-expressions-from-macros.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0ecff8c623fa29cccad6f946c657e81dacd85847/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecff8c623fa29cccad6f946c657e81dacd85847/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.rs?ref=0ecff8c623fa29cccad6f946c657e81dacd85847", "patch": "@@ -1,14 +1,17 @@\n // check-pass\n // edition:2018\n+#![feature(stmt_expr_attributes)]\n #![warn(semicolon_in_expressions_from_macros)]\n \n #[allow(dead_code)]\n macro_rules! foo {\n     ($val:ident) => {\n-        true; //~ WARN trailing\n-              //~| WARN this was previously\n-              //~| WARN trailing\n-              //~| WARN this was previously\n+        true; //~  WARN trailing semicolon in macro\n+              //~| WARN this was previously accepted\n+              //~| WARN trailing semicolon in macro\n+              //~| WARN this was previously accepted\n+              //~| WARN trailing semicolon in macro\n+              //~| WARN this was previously accepted\n     }\n }\n \n@@ -18,17 +21,14 @@ async fn bar() {\n }\n \n fn main() {\n-    // This `allow` doesn't work\n     #[allow(semicolon_in_expressions_from_macros)]\n     let _ = {\n         foo!(first)\n     };\n \n-    // This 'allow' doesn't work either\n     #[allow(semicolon_in_expressions_from_macros)]\n     let _ = foo!(second);\n \n-    // But this 'allow' does\n     #[allow(semicolon_in_expressions_from_macros)]\n     fn inner() {\n         let _ = foo!(third);\n@@ -38,4 +38,14 @@ fn main() {\n     async {\n         let _ = foo!(fourth);\n     };\n+\n+    let _ = {\n+        foo!(warn_in_block)\n+    };\n+\n+    let _ = foo!(warn_in_expr);\n+\n+    // This `#[allow]` does not work, since the attribute gets dropped\n+    // when we expand the macro\n+    let _ = #[allow(semicolon_in_expressions_from_macros)] foo!(allow_does_not_work);\n }"}, {"sha": "c00c3d77dcedc8bd961f165d6a7551b2b001374b", "filename": "src/test/ui/lint/semicolon-in-expressions-from-macros/semicolon-in-expressions-from-macros.stderr", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0ecff8c623fa29cccad6f946c657e81dacd85847/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0ecff8c623fa29cccad6f946c657e81dacd85847/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fsemicolon-in-expressions-from-macros%2Fsemicolon-in-expressions-from-macros.stderr?ref=0ecff8c623fa29cccad6f946c657e81dacd85847", "patch": "@@ -1,14 +1,14 @@\n warning: trailing semicolon in macro used in expression position\n-  --> $DIR/semicolon-in-expressions-from-macros.rs:8:13\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:9:13\n    |\n LL |         true;\n    |             ^\n ...\n-LL |         foo!(first)\n-   |         ----------- in this macro invocation\n+LL |         foo!(warn_in_block)\n+   |         ------------------- in this macro invocation\n    |\n note: the lint level is defined here\n-  --> $DIR/semicolon-in-expressions-from-macros.rs:3:9\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:4:9\n    |\n LL | #![warn(semicolon_in_expressions_from_macros)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -17,17 +17,30 @@ LL | #![warn(semicolon_in_expressions_from_macros)]\n    = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: trailing semicolon in macro used in expression position\n-  --> $DIR/semicolon-in-expressions-from-macros.rs:8:13\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:9:13\n    |\n LL |         true;\n    |             ^\n ...\n-LL |     let _ = foo!(second);\n-   |             ------------ in this macro invocation\n+LL |     let _ = foo!(warn_in_expr);\n+   |             ------------------ in this macro invocation\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n    = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-warning: 2 warnings emitted\n+warning: trailing semicolon in macro used in expression position\n+  --> $DIR/semicolon-in-expressions-from-macros.rs:9:13\n+   |\n+LL |         true;\n+   |             ^\n+...\n+LL |     let _ = #[allow(semicolon_in_expressions_from_macros)] foo!(allow_does_not_work);\n+   |                                                            ------------------------- in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #79813 <https://github.com/rust-lang/rust/issues/79813>\n+   = note: this warning originates in the macro `foo` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+warning: 3 warnings emitted\n "}, {"sha": "2f484809a5c9941cc3e6f762c19194965d62bf97", "filename": "src/test/ui/proc-macro/auxiliary/call-deprecated.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0ecff8c623fa29cccad6f946c657e81dacd85847/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fcall-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecff8c623fa29cccad6f946c657e81dacd85847/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fcall-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fcall-deprecated.rs?ref=0ecff8c623fa29cccad6f946c657e81dacd85847", "patch": "@@ -0,0 +1,19 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro_attribute]\n+#[deprecated(since = \"1.0.0\", note = \"test\")]\n+pub fn attr(_: TokenStream, input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_attribute]\n+#[deprecated(since = \"1.0.0\", note = \"test\")]\n+pub fn attr_remove(_: TokenStream, _: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}"}, {"sha": "b92cc23638ae1d2cc2a17923d008d2742089b59f", "filename": "src/test/ui/proc-macro/call-deprecated.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0ecff8c623fa29cccad6f946c657e81dacd85847/src%2Ftest%2Fui%2Fproc-macro%2Fcall-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ecff8c623fa29cccad6f946c657e81dacd85847/src%2Ftest%2Fui%2Fproc-macro%2Fcall-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcall-deprecated.rs?ref=0ecff8c623fa29cccad6f946c657e81dacd85847", "patch": "@@ -0,0 +1,34 @@\n+// check-pass\n+// aux-build:call-deprecated.rs\n+\n+extern crate call_deprecated;\n+\n+// These first two `#[allow(deprecated)]` attributes\n+// do nothing, since the AST nodes for `First` and `Second`\n+// haven't been been assigned a `NodeId`.\n+// See #63221 for a discussion about how we should\n+// handle the interaction of 'inert' attributes and\n+// proc-macro attributes.\n+\n+#[allow(deprecated)]\n+#[call_deprecated::attr] //~ WARN use of deprecated macro\n+struct First;\n+\n+#[allow(deprecated)]\n+#[call_deprecated::attr_remove] //~ WARN use of deprecated macro\n+struct Second;\n+\n+#[allow(deprecated)]\n+mod bar {\n+    #[allow(deprecated)]\n+    #[call_deprecated::attr]\n+    struct Third;\n+\n+    #[allow(deprecated)]\n+    #[call_deprecated::attr_remove]\n+    struct Fourth;\n+}\n+\n+\n+fn main() {\n+}"}, {"sha": "3506f9a16a3c4b7ff5ec661c6a4e429a349e3ce3", "filename": "src/test/ui/proc-macro/call-deprecated.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ecff8c623fa29cccad6f946c657e81dacd85847/src%2Ftest%2Fui%2Fproc-macro%2Fcall-deprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0ecff8c623fa29cccad6f946c657e81dacd85847/src%2Ftest%2Fui%2Fproc-macro%2Fcall-deprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcall-deprecated.stderr?ref=0ecff8c623fa29cccad6f946c657e81dacd85847", "patch": "@@ -0,0 +1,16 @@\n+warning: use of deprecated macro `call_deprecated::attr`: test\n+  --> $DIR/call-deprecated.rs:14:3\n+   |\n+LL | #[call_deprecated::attr]\n+   |   ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(deprecated)]` on by default\n+\n+warning: use of deprecated macro `call_deprecated::attr_remove`: test\n+  --> $DIR/call-deprecated.rs:18:3\n+   |\n+LL | #[call_deprecated::attr_remove]\n+   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: 2 warnings emitted\n+"}]}