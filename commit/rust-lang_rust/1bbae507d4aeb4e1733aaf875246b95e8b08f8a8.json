{"sha": "1bbae507d4aeb4e1733aaf875246b95e8b08f8a8", "node_id": "C_kwDOAAsO6NoAKDFiYmFlNTA3ZDRhZWI0ZTE3MzNhYWY4NzUyNDZiOTVlOGIwOGY4YTg", "commit": {"author": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2022-04-19T01:28:53Z"}, "committer": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2022-04-19T01:43:20Z"}, "message": "mark payload fields of ScalarPair enums as Scalar::Union when they're not always initialized", "tree": {"sha": "c86920fd63f1bfb5dbc09ce44e45c7ee5b0841e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c86920fd63f1bfb5dbc09ce44e45c7ee5b0841e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bbae507d4aeb4e1733aaf875246b95e8b08f8a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bbae507d4aeb4e1733aaf875246b95e8b08f8a8", "html_url": "https://github.com/rust-lang/rust/commit/1bbae507d4aeb4e1733aaf875246b95e8b08f8a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bbae507d4aeb4e1733aaf875246b95e8b08f8a8/comments", "author": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "311e2683e1bad87715b1558f7900e294d24ce491", "url": "https://api.github.com/repos/rust-lang/rust/commits/311e2683e1bad87715b1558f7900e294d24ce491", "html_url": "https://github.com/rust-lang/rust/commit/311e2683e1bad87715b1558f7900e294d24ce491"}], "stats": {"total": 844, "additions": 828, "deletions": 16}, "files": [{"sha": "7cf2984a63f90609b10f30ed2d85d393792a656c", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1bbae507d4aeb4e1733aaf875246b95e8b08f8a8/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbae507d4aeb4e1733aaf875246b95e8b08f8a8/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=1bbae507d4aeb4e1733aaf875246b95e8b08f8a8", "patch": "@@ -1120,21 +1120,12 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                 match st[i].abi() {\n                                     Abi::Scalar(_) => Abi::Scalar(niche_scalar),\n                                     Abi::ScalarPair(first, second) => {\n-                                        // We need to use scalar_unit to reset the\n-                                        // valid range to the maximal one for that\n-                                        // primitive, because only the niche is\n-                                        // guaranteed to be initialised, not the\n-                                        // other primitive.\n+                                        // Only the niche is guaranteed to be initialised,\n+                                        // so use union layout for the other primitive.\n                                         if offset.bytes() == 0 {\n-                                            Abi::ScalarPair(\n-                                                niche_scalar,\n-                                                scalar_unit(second.primitive()),\n-                                            )\n+                                            Abi::ScalarPair(niche_scalar, second.to_union())\n                                         } else {\n-                                            Abi::ScalarPair(\n-                                                scalar_unit(first.primitive()),\n-                                                niche_scalar,\n-                                            )\n+                                            Abi::ScalarPair(first.to_union(), niche_scalar)\n                                         }\n                                     }\n                                     _ => Abi::Aggregate { sized: true },\n@@ -1329,22 +1320,30 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 } else {\n                     // Try to use a ScalarPair for all tagged enums.\n                     let mut common_prim = None;\n+                    let mut common_prim_initialized_in_all_variants = true;\n                     for (field_layouts, layout_variant) in iter::zip(&variants, &layout_variants) {\n                         let FieldsShape::Arbitrary { ref offsets, .. } = layout_variant.fields else {\n                             bug!();\n                         };\n                         let mut fields =\n                             iter::zip(field_layouts, offsets).filter(|p| !p.0.is_zst());\n                         let (field, offset) = match (fields.next(), fields.next()) {\n-                            (None, None) => continue,\n+                            (None, None) => {\n+                                common_prim_initialized_in_all_variants = false;\n+                                continue;\n+                            }\n                             (Some(pair), None) => pair,\n                             _ => {\n                                 common_prim = None;\n                                 break;\n                             }\n                         };\n                         let prim = match field.abi {\n-                            Abi::Scalar(scalar) => scalar.primitive(),\n+                            Abi::Scalar(scalar) => {\n+                                common_prim_initialized_in_all_variants &=\n+                                    matches!(scalar, Scalar::Initialized { .. });\n+                                scalar.primitive()\n+                            }\n                             _ => {\n                                 common_prim = None;\n                                 break;\n@@ -1364,7 +1363,13 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         }\n                     }\n                     if let Some((prim, offset)) = common_prim {\n-                        let pair = self.scalar_pair(tag, scalar_unit(prim));\n+                        let prim_scalar = if common_prim_initialized_in_all_variants {\n+                            scalar_unit(prim)\n+                        } else {\n+                            // Common prim might be uninit.\n+                            Scalar::Union { value: prim }\n+                        };\n+                        let pair = self.scalar_pair(tag, prim_scalar);\n                         let pair_offsets = match pair.fields {\n                             FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n                                 assert_eq!(memory_index, &[0, 1]);"}, {"sha": "bc3667c5f809ff66ed061dcead1a6717fbee3b21", "filename": "src/test/ui/layout/issue-96158-scalarpair-payload-might-be-uninit.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1bbae507d4aeb4e1733aaf875246b95e8b08f8a8/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bbae507d4aeb4e1733aaf875246b95e8b08f8a8/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.rs?ref=1bbae507d4aeb4e1733aaf875246b95e8b08f8a8", "patch": "@@ -0,0 +1,53 @@\n+#![crate_type = \"lib\"]\n+#![feature(rustc_attrs)]\n+\n+use std::mem::MaybeUninit;\n+\n+enum HasNiche {\n+    A,\n+    B,\n+    C,\n+}\n+\n+// This should result in ScalarPair(Initialized, Union),\n+// since the u8 payload will be uninit for `None`.\n+#[rustc_layout(debug)]\n+pub enum MissingPayloadField { //~ ERROR: layout_of\n+    Some(u8),\n+    None\n+}\n+\n+// This should result in ScalarPair(Initialized, Initialized),\n+// since the u8 field is present in all variants,\n+// and hence will always be initialized.\n+#[rustc_layout(debug)]\n+pub enum CommonPayloadField { //~ ERROR: layout_of\n+    A(u8),\n+    B(u8),\n+}\n+\n+// This should result in ScalarPair(Initialized, Union),\n+// since, though a u8-sized field is present in all variants, it might be uninit.\n+#[rustc_layout(debug)]\n+pub enum CommonPayloadFieldIsMaybeUninit { //~ ERROR: layout_of\n+    A(u8),\n+    B(MaybeUninit<u8>),\n+}\n+\n+// This should result in ScalarPair(Initialized, Union),\n+// since only the niche field (used for the tag) is guaranteed to be initialized.\n+#[rustc_layout(debug)]\n+pub enum NicheFirst { //~ ERROR: layout_of\n+    A(HasNiche, u8),\n+    B,\n+    C\n+}\n+\n+// This should result in ScalarPair(Union, Initialized),\n+// since only the niche field (used for the tag) is guaranteed to be initialized.\n+#[rustc_layout(debug)]\n+pub enum NicheSecond { //~ ERROR: layout_of\n+    A(u8, HasNiche),\n+    B,\n+    C,\n+}"}, {"sha": "af51f813076ed71feac0f658aec4ba994d845d41", "filename": "src/test/ui/layout/issue-96158-scalarpair-payload-might-be-uninit.stderr", "status": "added", "additions": 754, "deletions": 0, "changes": 754, "blob_url": "https://github.com/rust-lang/rust/blob/1bbae507d4aeb4e1733aaf875246b95e8b08f8a8/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1bbae507d4aeb4e1733aaf875246b95e8b08f8a8/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr?ref=1bbae507d4aeb4e1733aaf875246b95e8b08f8a8", "patch": "@@ -0,0 +1,754 @@\n+error: layout_of(MissingPayloadField) = Layout {\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size {\n+                       raw: 0,\n+                   },\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n+           variants: Multiple {\n+               tag: Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               tag_encoding: Direct,\n+               tag_field: 0,\n+               variants: [\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size {\n+                                   raw: 1,\n+                               },\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: Align {\n+                               pow2: 3,\n+                           },\n+                       },\n+                       size: Size {\n+                           raw: 2,\n+                       },\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [],\n+                           memory_index: [],\n+                       },\n+                       variants: Single {\n+                           index: 1,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: Align {\n+                               pow2: 3,\n+                           },\n+                       },\n+                       size: Size {\n+                           raw: 1,\n+                       },\n+                   },\n+               ],\n+           },\n+           abi: ScalarPair(\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               Union {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+               },\n+           ),\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size {\n+                       raw: 0,\n+                   },\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n+           align: AbiAndPrefAlign {\n+               abi: Align {\n+                   pow2: 0,\n+               },\n+               pref: Align {\n+                   pow2: 3,\n+               },\n+           },\n+           size: Size {\n+               raw: 2,\n+           },\n+       }\n+  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:15:1\n+   |\n+LL | / pub enum MissingPayloadField {\n+LL | |     Some(u8),\n+LL | |     None\n+LL | | }\n+   | |_^\n+\n+error: layout_of(CommonPayloadField) = Layout {\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size {\n+                       raw: 0,\n+                   },\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n+           variants: Multiple {\n+               tag: Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               tag_encoding: Direct,\n+               tag_field: 0,\n+               variants: [\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size {\n+                                   raw: 1,\n+                               },\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: Align {\n+                               pow2: 3,\n+                           },\n+                       },\n+                       size: Size {\n+                           raw: 2,\n+                       },\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size {\n+                                   raw: 1,\n+                               },\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 1,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: Align {\n+                               pow2: 3,\n+                           },\n+                       },\n+                       size: Size {\n+                           raw: 2,\n+                       },\n+                   },\n+               ],\n+           },\n+           abi: ScalarPair(\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=255,\n+               },\n+           ),\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size {\n+                       raw: 0,\n+                   },\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n+           align: AbiAndPrefAlign {\n+               abi: Align {\n+                   pow2: 0,\n+               },\n+               pref: Align {\n+                   pow2: 3,\n+               },\n+           },\n+           size: Size {\n+               raw: 2,\n+           },\n+       }\n+  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:24:1\n+   |\n+LL | / pub enum CommonPayloadField {\n+LL | |     A(u8),\n+LL | |     B(u8),\n+LL | | }\n+   | |_^\n+\n+error: layout_of(CommonPayloadFieldIsMaybeUninit) = Layout {\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size {\n+                       raw: 0,\n+                   },\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n+           variants: Multiple {\n+               tag: Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               tag_encoding: Direct,\n+               tag_field: 0,\n+               variants: [\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size {\n+                                   raw: 1,\n+                               },\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: Align {\n+                               pow2: 3,\n+                           },\n+                       },\n+                       size: Size {\n+                           raw: 2,\n+                       },\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size {\n+                                   raw: 1,\n+                               },\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 1,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: Align {\n+                               pow2: 3,\n+                           },\n+                       },\n+                       size: Size {\n+                           raw: 2,\n+                       },\n+                   },\n+               ],\n+           },\n+           abi: ScalarPair(\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               Union {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+               },\n+           ),\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size {\n+                       raw: 0,\n+                   },\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n+           align: AbiAndPrefAlign {\n+               abi: Align {\n+                   pow2: 0,\n+               },\n+               pref: Align {\n+                   pow2: 3,\n+               },\n+           },\n+           size: Size {\n+               raw: 2,\n+           },\n+       }\n+  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:32:1\n+   |\n+LL | / pub enum CommonPayloadFieldIsMaybeUninit {\n+LL | |     A(u8),\n+LL | |     B(MaybeUninit<u8>),\n+LL | | }\n+   | |_^\n+\n+error: layout_of(NicheFirst) = Layout {\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size {\n+                       raw: 0,\n+                   },\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n+           variants: Multiple {\n+               tag: Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=4,\n+               },\n+               tag_encoding: Niche {\n+                   dataful_variant: 0,\n+                   niche_variants: 1..=2,\n+                   niche_start: 3,\n+               },\n+               tag_field: 0,\n+               variants: [\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size {\n+                                   raw: 0,\n+                               },\n+                               Size {\n+                                   raw: 1,\n+                               },\n+                           ],\n+                           memory_index: [\n+                               0,\n+                               1,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=2,\n+                           },\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=255,\n+                           },\n+                       ),\n+                       largest_niche: Some(\n+                           Niche {\n+                               offset: Size {\n+                                   raw: 0,\n+                               },\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=2,\n+                           },\n+                       ),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: Align {\n+                               pow2: 3,\n+                           },\n+                       },\n+                       size: Size {\n+                           raw: 2,\n+                       },\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [],\n+                           memory_index: [],\n+                       },\n+                       variants: Single {\n+                           index: 1,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: Align {\n+                               pow2: 3,\n+                           },\n+                       },\n+                       size: Size {\n+                           raw: 0,\n+                       },\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [],\n+                           memory_index: [],\n+                       },\n+                       variants: Single {\n+                           index: 2,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: Align {\n+                               pow2: 3,\n+                           },\n+                       },\n+                       size: Size {\n+                           raw: 0,\n+                       },\n+                   },\n+               ],\n+           },\n+           abi: ScalarPair(\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=4,\n+               },\n+               Union {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+               },\n+           ),\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size {\n+                       raw: 0,\n+                   },\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=4,\n+               },\n+           ),\n+           align: AbiAndPrefAlign {\n+               abi: Align {\n+                   pow2: 0,\n+               },\n+               pref: Align {\n+                   pow2: 3,\n+               },\n+           },\n+           size: Size {\n+               raw: 2,\n+           },\n+       }\n+  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:40:1\n+   |\n+LL | / pub enum NicheFirst {\n+LL | |     A(HasNiche, u8),\n+LL | |     B,\n+LL | |     C\n+LL | | }\n+   | |_^\n+\n+error: layout_of(NicheSecond) = Layout {\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size {\n+                       raw: 1,\n+                   },\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n+           variants: Multiple {\n+               tag: Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=4,\n+               },\n+               tag_encoding: Niche {\n+                   dataful_variant: 0,\n+                   niche_variants: 1..=2,\n+                   niche_start: 3,\n+               },\n+               tag_field: 0,\n+               variants: [\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size {\n+                                   raw: 0,\n+                               },\n+                               Size {\n+                                   raw: 1,\n+                               },\n+                           ],\n+                           memory_index: [\n+                               0,\n+                               1,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                       abi: ScalarPair(\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=255,\n+                           },\n+                           Initialized {\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=2,\n+                           },\n+                       ),\n+                       largest_niche: Some(\n+                           Niche {\n+                               offset: Size {\n+                                   raw: 1,\n+                               },\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=2,\n+                           },\n+                       ),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: Align {\n+                               pow2: 3,\n+                           },\n+                       },\n+                       size: Size {\n+                           raw: 2,\n+                       },\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [],\n+                           memory_index: [],\n+                       },\n+                       variants: Single {\n+                           index: 1,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: Align {\n+                               pow2: 3,\n+                           },\n+                       },\n+                       size: Size {\n+                           raw: 0,\n+                       },\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [],\n+                           memory_index: [],\n+                       },\n+                       variants: Single {\n+                           index: 2,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align {\n+                               pow2: 0,\n+                           },\n+                           pref: Align {\n+                               pow2: 3,\n+                           },\n+                       },\n+                       size: Size {\n+                           raw: 0,\n+                       },\n+                   },\n+               ],\n+           },\n+           abi: ScalarPair(\n+               Union {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+               },\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=4,\n+               },\n+           ),\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size {\n+                       raw: 1,\n+                   },\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=4,\n+               },\n+           ),\n+           align: AbiAndPrefAlign {\n+               abi: Align {\n+                   pow2: 0,\n+               },\n+               pref: Align {\n+                   pow2: 3,\n+               },\n+           },\n+           size: Size {\n+               raw: 2,\n+           },\n+       }\n+  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:49:1\n+   |\n+LL | / pub enum NicheSecond {\n+LL | |     A(u8, HasNiche),\n+LL | |     B,\n+LL | |     C,\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 5 previous errors\n+"}]}