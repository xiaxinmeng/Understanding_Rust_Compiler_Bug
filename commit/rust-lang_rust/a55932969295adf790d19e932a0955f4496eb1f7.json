{"sha": "a55932969295adf790d19e932a0955f4496eb1f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NTkzMjk2OTI5NWFkZjc5MGQxOWU5MzJhMDk1NWY0NDk2ZWIxZjc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-18T03:18:20Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-18T21:32:37Z"}, "message": "test that we preserve boxes in patterns---still one bug", "tree": {"sha": "a45c077cce1560be201ff963fbd78f355ea11abb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a45c077cce1560be201ff963fbd78f355ea11abb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a55932969295adf790d19e932a0955f4496eb1f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a55932969295adf790d19e932a0955f4496eb1f7", "html_url": "https://github.com/rust-lang/rust/commit/a55932969295adf790d19e932a0955f4496eb1f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a55932969295adf790d19e932a0955f4496eb1f7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f283bb168564b365cd361d8afff7d3809f02f02", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f283bb168564b365cd361d8afff7d3809f02f02", "html_url": "https://github.com/rust-lang/rust/commit/3f283bb168564b365cd361d8afff7d3809f02f02"}], "stats": {"total": 316, "additions": 255, "deletions": 61}, "files": [{"sha": "7044851b83ea9c9aa651428eb621a84c490ce51f", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 132, "deletions": 46, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/a55932969295adf790d19e932a0955f4496eb1f7/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55932969295adf790d19e932a0955f4496eb1f7/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=a55932969295adf790d19e932a0955f4496eb1f7", "patch": "@@ -85,6 +85,7 @@ enum categorization {\n     cat_stack_upvar(cmt),           // upvar in stack closure\n     cat_deref(cmt, uint, ptr_kind), // deref of a ptr\n     cat_comp(cmt, comp_kind),       // adjust to locate an internal component\n+    cat_discr(cmt, ast::node_id),   // alt discriminant (see preserve())\n }\n \n // different kinds of pointers:\n@@ -205,7 +206,8 @@ fn req_loans_in_expr(ex: @ast::expr,\n     // If this expression is borrowed, have to ensure it remains valid:\n     for tcx.borrowings.find(ex.id).each { |scope_id|\n         let cmt = self.bccx.cat_borrow_of_expr(ex);\n-        self.guarantee_valid(cmt, m_const, ty::re_scope(scope_id));\n+        let scope_r = ty::re_scope(scope_id);\n+        self.guarantee_valid(cmt, m_const, scope_r);\n     }\n \n     // Special checks for various kinds of expressions:\n@@ -224,20 +226,19 @@ fn req_loans_in_expr(ex: @ast::expr,\n \n       ast::expr_call(f, args, _) {\n         let arg_tys = ty::ty_fn_args(ty::expr_ty(self.tcx(), f));\n+        let scope_r = ty::re_scope(ex.id);\n         vec::iter2(args, arg_tys) { |arg, arg_ty|\n             alt ty::resolved_mode(self.tcx(), arg_ty.mode) {\n               ast::by_mutbl_ref {\n                 let arg_cmt = self.bccx.cat_expr(arg);\n-                self.guarantee_valid(arg_cmt, m_mutbl, ty::re_scope(ex.id));\n+                self.guarantee_valid(arg_cmt, m_mutbl, scope_r);\n               }\n               ast::by_ref {\n                 let arg_cmt = self.bccx.cat_expr(arg);\n                 if TREAT_CONST_AS_IMM {\n-                    self.guarantee_valid(arg_cmt, m_imm,\n-                                         ty::re_scope(ex.id));\n+                    self.guarantee_valid(arg_cmt, m_imm,  scope_r);\n                 } else {\n-                    self.guarantee_valid(arg_cmt, m_const,\n-                                         ty::re_scope(ex.id));\n+                    self.guarantee_valid(arg_cmt, m_const, scope_r);\n                 }\n               }\n               ast::by_move | ast::by_copy | ast::by_val {}\n@@ -249,7 +250,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n         let cmt = self.bccx.cat_expr(ex_v);\n         for arms.each { |arm|\n             for arm.pats.each { |pat|\n-                self.gather_pat(cmt, pat, arm.body.node.id);\n+                self.gather_pat(cmt, pat, arm.body.node.id, ex.id);\n             }\n         }\n       }\n@@ -265,8 +266,10 @@ impl methods for gather_loan_ctxt {\n     fn tcx() -> ty::ctxt { self.bccx.tcx }\n \n     // guarantees that addr_of(cmt) will be valid for the duration of\n-    // `scope_r`, or reports an error.  This may entail taking out loans,\n-    // which will be added to the `req_loan_map`.\n+    // `static_scope_r`, or reports an error.  This may entail taking\n+    // out loans, which will be added to the `req_loan_map`.  This can\n+    // also entail \"rooting\" GC'd pointers, which means ensuring\n+    // dynamically that they are not freed.\n     fn guarantee_valid(cmt: cmt,\n                        mutbl: ast::mutability,\n                        scope_r: ty::region) {\n@@ -334,16 +337,24 @@ impl methods for gather_loan_ctxt {\n         }\n     }\n \n-    fn gather_pat(cmt: cmt, pat: @ast::pat, alt_id: ast::node_id) {\n+    fn gather_pat(cmt: cmt, pat: @ast::pat,\n+                  arm_id: ast::node_id, alt_id: ast::node_id) {\n \n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n         //\n-        // In general, the way that this works is that we\n+        // In general, the way that this works is that we walk down\n+        // the pattern, constructing a cmt that represents the path\n+        // that will be taken to reach the value being matched.\n+        //\n+        // When we encounter named bindings, we take the cmt that has\n+        // been built up and pass it off to guarantee_valid() so that\n+        // we can be sure that the binding will remain valid for the\n+        // duration of the arm.\n \n-        #debug[\"gather_pat: id=%d pat=%s cmt=%s alt_id=%d\",\n+        #debug[\"gather_pat: id=%d pat=%s cmt=%s arm_id=%d alt_id=%d\",\n                pat.id, pprust::pat_to_str(pat),\n-               self.bccx.cmt_to_repr(cmt), alt_id];\n+               self.bccx.cmt_to_repr(cmt), arm_id, alt_id];\n         let _i = indenter();\n \n         let tcx = self.tcx();\n@@ -359,7 +370,7 @@ impl methods for gather_loan_ctxt {\n             // variant(x, y, z)\n             for subpats.each { |subpat|\n                 let subcmt = self.bccx.cat_variant(pat, cmt, subpat);\n-                self.gather_pat(subcmt, subpat, alt_id);\n+                self.gather_pat(subcmt, subpat, arm_id, alt_id);\n             }\n           }\n \n@@ -370,32 +381,44 @@ impl methods for gather_loan_ctxt {\n           ast::pat_ident(id, o_pat) {\n             // x or x @ p --- `x` must remain valid for the scope of the alt\n             #debug[\"defines identifier %s\", pprust::path_to_str(id)];\n-            self.guarantee_valid(cmt, m_const, ty::re_scope(alt_id));\n-            for o_pat.each { |p| self.gather_pat(cmt, p, alt_id); }\n+\n+            // Note: there is a discussion of the function of\n+            // cat_discr in the method preserve():\n+            let cmt1 = self.bccx.cat_discr(cmt, alt_id);\n+            let arm_scope = ty::re_scope(arm_id);\n+            self.guarantee_valid(cmt1, m_const, arm_scope);\n+\n+            for o_pat.each { |p|\n+                self.gather_pat(cmt, p, arm_id, alt_id);\n+            }\n           }\n \n           ast::pat_rec(field_pats, _) {\n             // {f1: p1, ..., fN: pN}\n             for field_pats.each { |fp|\n                 let cmt_field = self.bccx.cat_field(pat, cmt, fp.ident,\n                                                     tcx.ty(fp.pat));\n-                self.gather_pat(cmt_field, fp.pat, alt_id);\n+                self.gather_pat(cmt_field, fp.pat, arm_id, alt_id);\n             }\n           }\n \n           ast::pat_tup(subpats) {\n             // (p1, ..., pN)\n             for subpats.each { |subpat|\n                 let subcmt = self.bccx.cat_tuple_elt(pat, cmt, subpat);\n-                self.gather_pat(subcmt, subpat, alt_id);\n+                self.gather_pat(subcmt, subpat, arm_id, alt_id);\n             }\n           }\n \n           ast::pat_box(subpat) | ast::pat_uniq(subpat) {\n             // @p1, ~p1\n             alt self.bccx.cat_deref(pat, cmt, 0u, true) {\n-              some(subcmt) { self.gather_pat(subcmt, subpat, alt_id); }\n-              none { tcx.sess.span_bug(pat.span, \"Non derefable type\"); }\n+              some(subcmt) {\n+                self.gather_pat(subcmt, subpat, arm_id, alt_id);\n+              }\n+              none {\n+                tcx.sess.span_bug(pat.span, \"Non derefable type\");\n+              }\n             }\n           }\n \n@@ -1006,6 +1029,10 @@ impl categorize_methods for borrowck_ctxt {\n         }\n     }\n \n+    fn cat_discr(cmt: cmt, alt_id: ast::node_id) -> cmt {\n+        ret @{cat:cat_discr(cmt, alt_id) with *cmt};\n+    }\n+\n     fn cat_field<N:ast_node>(node: N, base_cmt: cmt,\n                              f_name: str, f_ty: ty::t) -> cmt {\n         let f_mutbl = alt field_mutbl(self.tcx, base_cmt.ty, f_name) {\n@@ -1239,6 +1266,7 @@ impl categorize_methods for borrowck_ctxt {\n           cat_comp(cmt, comp) {\n             #fmt[\"%s.%s\", self.cat_to_repr(cmt.cat), self.comp_to_repr(comp)]\n           }\n+          cat_discr(cmt, _) { self.cat_to_repr(cmt.cat) }\n         }\n     }\n \n@@ -1326,6 +1354,9 @@ impl categorize_methods for borrowck_ctxt {\n               _ { mut_str + \" indexed content\" }\n             }\n           }\n+          cat_discr(cmt, _) {\n+            self.cmt_to_str(cmt)\n+          }\n         }\n     }\n \n@@ -1420,34 +1451,23 @@ fn field_mutbl(tcx: ty::ctxt,\n // Preserve(Ex, S) holds if ToAddr(Ex) will remain valid for the entirety of\n // the scope S.\n \n-enum preserve_ctxt = @{\n-    bccx: borrowck_ctxt, opt_scope_id: option<ast::node_id>\n-};\n-\n impl preserve_methods for borrowck_ctxt {\n-    fn preserve(cmt: cmt,\n-                opt_scope_id: option<ast::node_id>) -> bckres<()> {\n-        preserve_ctxt(@{bccx:self, opt_scope_id:opt_scope_id}).preserve(cmt)\n-    }\n-}\n-\n-impl preserve_methods for preserve_ctxt {\n-    fn preserve(cmt: cmt) -> bckres<()> {\n-        #debug[\"preserve(%s)\", self.bccx.cmt_to_repr(cmt)];\n+    fn preserve(cmt: cmt, opt_scope_id: option<ast::node_id>) -> bckres<()> {\n+        #debug[\"preserve(%s)\", self.cmt_to_repr(cmt)];\n         let _i = indenter();\n \n         alt cmt.cat {\n           cat_rvalue | cat_special(_) {\n             ok(())\n           }\n           cat_stack_upvar(cmt) {\n-            self.preserve(cmt)\n+            self.preserve(cmt, opt_scope_id)\n           }\n           cat_local(_) {\n             // This should never happen.  Local variables are always lendable,\n             // so either `loan()` should be called or there must be some\n             // intermediate @ or &---they are not lendable but do not recurse.\n-            self.bccx.tcx.sess.span_bug(\n+            self.tcx.sess.span_bug(\n                 cmt.span,\n                 \"preserve() called with local\");\n           }\n@@ -1463,13 +1483,13 @@ impl preserve_methods for preserve_ctxt {\n           cat_comp(cmt_base, comp_res) {\n             // Most embedded components: if the base is stable, the\n             // type never changes.\n-            self.preserve(cmt_base)\n+            self.preserve(cmt_base, opt_scope_id)\n           }\n           cat_comp(cmt1, comp_variant) {\n-            self.require_imm(cmt, cmt1, err_mut_variant)\n+            self.require_imm(cmt, cmt1, opt_scope_id, err_mut_variant)\n           }\n           cat_deref(cmt1, _, uniq_ptr) {\n-            self.require_imm(cmt, cmt1, err_mut_uniq)\n+            self.require_imm(cmt, cmt1, opt_scope_id, err_mut_uniq)\n           }\n           cat_deref(_, _, region_ptr) {\n             // References are always \"stable\" by induction (when the\n@@ -1482,33 +1502,96 @@ impl preserve_methods for preserve_ctxt {\n             ok(())\n           }\n           cat_deref(base, derefs, gc_ptr) {\n-            // GC'd pointers of type @MT: always stable because we can inc\n-            // the ref count or keep a GC root as necessary.  We need to\n-            // insert this id into the root_map, however.\n-            alt self.opt_scope_id {\n+            // GC'd pointers of type @MT: always stable because we can\n+            // inc the ref count or keep a GC root as necessary.  We\n+            // need to insert this id into the root_map, however.\n+            alt opt_scope_id {\n               some(scope_id) {\n                 #debug[\"Inserting root map entry for %s: \\\n                         node %d:%u -> scope %d\",\n-                       self.bccx.cmt_to_repr(cmt), base.id,\n+                       self.cmt_to_repr(cmt), base.id,\n                        derefs, scope_id];\n+\n                 let rk = {id: base.id, derefs: derefs};\n-                self.bccx.root_map.insert(rk, scope_id);\n+                self.root_map.insert(rk, scope_id);\n                 ok(())\n               }\n               none {\n                 err({cmt:cmt, code:err_preserve_gc})\n               }\n             }\n           }\n+          cat_discr(base, alt_id) {\n+            // Subtle: in an alt, we must ensure that each binding\n+            // variable remains valid for the duration of the arm in\n+            // which it appears, presuming that this arm is taken.\n+            // But it is inconvenient in trans to root something just\n+            // for one arm.  Therefore, we insert a cat_discr(),\n+            // basically a special kind of category that says \"if this\n+            // value must be dynamically rooted, root it for the scope\n+            // `alt_id`.\n+            //\n+            // As an example, consider this scenario:\n+            //\n+            //    let mut x = @some(3);\n+            //    alt *x { some(y) {...} none {...} }\n+            //\n+            // Technically, the value `x` need only be rooted\n+            // in the `some` arm.  However, we evaluate `x` in trans\n+            // before we know what arm will be taken, so we just\n+            // always root it for the duration of the alt.\n+            //\n+            // As a second example, consider *this* scenario:\n+            //\n+            //    let x = @mut @some(3);\n+            //    alt x { @@some(y) {...} @@none {...} }\n+            //\n+            // Here again, `x` need only be rooted in the `some` arm.\n+            // In this case, the value which needs to be rooted is\n+            // found only when checking which pattern matches: but\n+            // this check is done before entering the arm.  Therefore,\n+            // even in this case we just choose to keep the value\n+            // rooted for the entire alt.  This means the value will be\n+            // rooted even if the none arm is taken.  Oh well.\n+            //\n+            // At first, I tried to optimize the second case to only\n+            // root in one arm, but the result was suboptimal: first,\n+            // it interfered with the construction of phi nodes in the\n+            // arm, as we were adding code to root values before the\n+            // phi nodes were added.  This could have been addressed\n+            // with a second basic block.  However, the naive approach\n+            // also yielded suboptimal results for patterns like:\n+            //\n+            //    let x = @mut @...;\n+            //    alt x { @@some_variant(y) | @@some_other_variant(y) {...} }\n+            //\n+            // The reason is that we would root the value once for\n+            // each pattern and not once per arm.  This is also easily\n+            // fixed, but it's yet more code for what is really quite\n+            // the corner case.\n+            //\n+            // Nonetheless, if you decide to optimize this case in the\n+            // future, you need only adjust where the cat_discr()\n+            // node appears to draw the line between what will be rooted\n+            // in the *arm* vs the *alt*.\n+\n+            // current scope must be the arm, which is always a child of alt:\n+            assert self.tcx.region_map.get(opt_scope_id.get()) == alt_id;\n+\n+            self.preserve(base, some(alt_id))\n+          }\n         }\n     }\n \n-    fn require_imm(cmt: cmt, cmt1: cmt, code: bckerr_code) -> bckres<()> {\n+    fn require_imm(cmt: cmt,\n+                   cmt1: cmt,\n+                   opt_scope_id: option<ast::node_id>,\n+                   code: bckerr_code) -> bckres<()> {\n         // Variant contents and unique pointers: must be immutably\n         // rooted to a preserved address.\n         alt cmt1.mutbl {\n           m_mutbl | m_const { err({cmt:cmt, code:code}) }\n-          m_imm { self.preserve(cmt1) }\n+          m_imm { self.preserve(cmt1, opt_scope_id) }\n         }\n     }\n }\n@@ -1569,6 +1652,9 @@ impl loan_methods for loan_ctxt {\n           cat_local(_) | cat_arg(_) | cat_stack_upvar(_) {\n             self.ok_with_loan_of(cmt, req_mutbl)\n           }\n+          cat_discr(base, _) {\n+            self.loan(base, req_mutbl)\n+          }\n           cat_comp(cmt_base, comp_field(_)) |\n           cat_comp(cmt_base, comp_index(_)) |\n           cat_comp(cmt_base, comp_tuple) |"}, {"sha": "df79c52155aa683a6a0fc726bb8de8e916657f98", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a55932969295adf790d19e932a0955f4496eb1f7/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55932969295adf790d19e932a0955f4496eb1f7/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=a55932969295adf790d19e932a0955f4496eb1f7", "patch": "@@ -87,7 +87,7 @@ fn assoc(key: str, list: bind_map) -> option<ValueRef> {\n type match_branch =\n     @{pats: [@ast::pat],\n       bound: bind_map,\n-      data: @{body: BasicBlockRef,\n+      data: @{bodycx: block,\n               guard: option<@ast::expr>,\n               id_map: pat_id_map}};\n type match = [match_branch];\n@@ -302,6 +302,26 @@ fn collect_record_fields(m: match, col: uint) -> [ast::ident] {\n     ret fields;\n }\n \n+fn root_pats_as_necessary(bcx: block, m: match, col: uint, val: ValueRef) {\n+    for vec::each(m) {|br|\n+        let pat_id = br.pats[col].id;\n+\n+        alt bcx.ccx().maps.root_map.find({id:pat_id, derefs:0u}) {\n+          none {}\n+          some(scope_id) {\n+            // Note: the scope_id will always be the id of the alt.  See the\n+            // extended comment in rustc::middle::borrowck::preserve() for\n+            // details (look for the case covering cat_discr).\n+\n+            let ty = node_id_type(bcx, pat_id);\n+            let val = load_if_immediate(bcx, val, ty);\n+            root_value(bcx, val, ty, scope_id);\n+            ret; // if we kept going, we'd only be rooting same value again\n+          }\n+        }\n+    }\n+}\n+\n fn any_box_pat(m: match, col: uint) -> bool {\n     for vec::each(m) {|br|\n         alt br.pats[col].node { ast::pat_box(_) { ret true; } _ { } }\n@@ -383,9 +403,10 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n           _ { }\n         }\n         if !bcx.unreachable {\n-            exits += [{bound: m[0].bound, from: bcx.llbb, to: data.body}];\n+            exits += [{bound: m[0].bound, from: bcx.llbb,\n+                       to: data.bodycx.llbb}];\n         }\n-        Br(bcx, data.body);\n+        Br(bcx, data.bodycx.llbb);\n         ret;\n     }\n \n@@ -405,6 +426,8 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n         if pat_id == 0 { pat_id = br.pats[col].id; }\n     }\n \n+    root_pats_as_necessary(bcx, m, col, val);\n+\n     let rec_fields = collect_record_fields(m, col);\n     // Separate path for extracting and binding record fields\n     if rec_fields.len() > 0u {\n@@ -639,7 +662,7 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: [ast::arm],\n         for vec::each(a.pats) {|p|\n             match += [@{pats: [p],\n                         bound: [],\n-                        data: @{body: body.llbb, guard: a.guard,\n+                        data: @{bodycx: body, guard: a.guard,\n                                 id_map: id_map}}];\n         }\n     }"}, {"sha": "d4ee78d19f3f5298d7df87bb30d332e45f29db80", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a55932969295adf790d19e932a0955f4496eb1f7/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55932969295adf790d19e932a0955f4496eb1f7/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a55932969295adf790d19e932a0955f4496eb1f7", "patch": "@@ -1681,6 +1681,17 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n                           save_in(lhs_res.val));\n }\n \n+fn root_value(bcx: block, val: ValueRef, ty: ty::t,\n+              scope_id: ast::node_id) {\n+    if !bcx.sess().opts.no_asm_comments {\n+        add_comment(bcx, #fmt[\"preserving until end of scope %d\",\n+                              scope_id]);\n+    }\n+    let root_loc = alloca(bcx, type_of(bcx.ccx(), ty));\n+    copy_val(bcx, INIT, root_loc, val, ty);\n+    add_root_cleanup(bcx, scope_id, root_loc, ty);\n+}\n+\n fn autoderef(cx: block, e_id: ast::node_id,\n              v: ValueRef, t: ty::t) -> result_t {\n     let _icx = cx.insn_ctxt(\"autoderef\");\n@@ -1693,19 +1704,12 @@ fn autoderef(cx: block, e_id: ast::node_id,\n                e_id, val_str(ccx.tn, v1), ty_to_str(ccx.tcx, t1),\n                derefs];\n \n-        // check if the result of this autoderef must be preserved\n+        // root the autoderef'd value, if necessary:\n         derefs += 1u;\n-        alt cx.ccx().maps.root_map.find({id:e_id, derefs:derefs}) {\n-          none {}\n+        alt ccx.maps.root_map.find({id:e_id, derefs:derefs}) {\n+          none { }\n           some(scope_id) {\n-            if !cx.sess().no_asm_comments() {\n-                add_comment(cx, #fmt[\"preserving until end of scope %d\",\n-                                     scope_id]);\n-            }\n-            let root_loc = alloca(cx, type_of(cx.ccx(), t1));\n-            Store(cx, v1, root_loc);\n-            take_ty(cx, root_loc, t1);\n-            add_root_cleanup(cx, scope_id, root_loc, t1);\n+            root_value(cx, v1, t1, scope_id);\n           }\n         }\n "}, {"sha": "2db156552a9bdaccf68cbd443250bc7414518ca3", "filename": "src/test/run-pass/borrowck-preserve-box-in-arm-not-taken.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a55932969295adf790d19e932a0955f4496eb1f7/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55932969295adf790d19e932a0955f4496eb1f7/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-arm-not-taken.rs?ref=a55932969295adf790d19e932a0955f4496eb1f7", "patch": "@@ -0,0 +1,20 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+// exec-env:RUST_POISON_ON_FREE=1\n+\n+fn main() {\n+    let x: @mut @option<~int> = @mut @none;\n+    alt x {\n+      @@some(y) {\n+        // here, the refcount of `*x` is bumped so\n+        // `y` remains valid even if `*x` is modified.\n+        *x = @none;\n+      }\n+\n+      @@none {\n+        // here, no bump of the ref count of `*x` is needed, but in\n+        // fact a bump occurs anyway because of how pattern marching\n+        // works.\n+      }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "044db44595d13bcfe9eaf47d86b5d0185516d0c0", "filename": "src/test/run-pass/borrowck-preserve-box-in-discr.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a55932969295adf790d19e932a0955f4496eb1f7/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55932969295adf790d19e932a0955f4496eb1f7/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs?ref=a55932969295adf790d19e932a0955f4496eb1f7", "patch": "@@ -0,0 +1,19 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+// exec-env:RUST_POISON_ON_FREE=1\n+\n+fn main() {\n+    let mut x = @{f: ~3};\n+    alt *x {\n+      {f: b_x} {\n+        assert *b_x == 3;\n+        assert ptr::addr_of(*x.f) == ptr::addr_of(*b_x);\n+\n+        x = @{f: ~4};\n+\n+        #debug[\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint];\n+        assert *b_x == 3;\n+        assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n+      }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "d5274238439878554f18bf1cc01d714c2d56c28b", "filename": "src/test/run-pass/borrowck-preserve-box-in-pat.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a55932969295adf790d19e932a0955f4496eb1f7/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55932969295adf790d19e932a0955f4496eb1f7/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs?ref=a55932969295adf790d19e932a0955f4496eb1f7", "patch": "@@ -0,0 +1,19 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+// exec-env:RUST_POISON_ON_FREE=1\n+\n+fn main() {\n+    let mut x = @mut @{f: ~3};\n+    alt x {\n+      @@{f: b_x} {\n+        assert *b_x == 3;\n+        assert ptr::addr_of(x.f) == ptr::addr_of(b_x);\n+\n+        *x = @{f: ~4};\n+\n+        #debug[\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint];\n+        assert *b_x == 3;\n+        assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n+      }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "c50afeeaa90a2319c52ff6f4f1af8c116e645b4b", "filename": "src/test/run-pass/borrowck-preserve-expl-deref.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a55932969295adf790d19e932a0955f4496eb1f7/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55932969295adf790d19e932a0955f4496eb1f7/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs?ref=a55932969295adf790d19e932a0955f4496eb1f7", "patch": "@@ -0,0 +1,23 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+// exec-env:RUST_POISON_ON_FREE=1\n+\n+fn borrow(x: &int, f: fn(x: &int)) {\n+    let before = *x;\n+    f(x);\n+    let after = *x;\n+    assert before == after;\n+}\n+\n+fn main() {\n+    let mut x = @{f: ~3};\n+    borrow((*x).f) {|b_x|\n+        assert *b_x == 3;\n+        assert ptr::addr_of(*x.f) == ptr::addr_of(*b_x);\n+        x = @{f: ~4};\n+\n+        #debug[\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint];\n+        assert *b_x == 3;\n+        assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n+    }\n+}"}]}