{"sha": "6d5bf8b23f4e59fdc67f635a10f450dfab2f076b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNWJmOGIyM2Y0ZTU5ZmRjNjdmNjM1YTEwZjQ1MGRmYWIyZjA3NmI=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2018-05-03T21:49:22Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2018-05-17T20:13:42Z"}, "message": "Remove the intrinsic for align_offset\n\nKeep only the language item. This removes some indirection and makes\ncodegen worse for debug builds, but simplifies code significantly, which\nis a good tradeoff to make, in my opinion.\n\nBesides, the codegen can be improved even further with some constant\nevaluation improvements that we expect to happen in the future.", "tree": {"sha": "d73787a67d3af203fc03693ff7f47c5e2ea9d406", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d73787a67d3af203fc03693ff7f47c5e2ea9d406"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d5bf8b23f4e59fdc67f635a10f450dfab2f076b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d5bf8b23f4e59fdc67f635a10f450dfab2f076b", "html_url": "https://github.com/rust-lang/rust/commit/6d5bf8b23f4e59fdc67f635a10f450dfab2f076b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d5bf8b23f4e59fdc67f635a10f450dfab2f076b/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "680031b0164a94aaeee17a1d8c3027e6e8865a4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/680031b0164a94aaeee17a1d8c3027e6e8865a4c", "html_url": "https://github.com/rust-lang/rust/commit/680031b0164a94aaeee17a1d8c3027e6e8865a4c"}], "stats": {"total": 110, "additions": 26, "deletions": 84}, "files": [{"sha": "1420e00b47ffa5e8733e4d354985670b6f7cfd18", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6d5bf8b23f4e59fdc67f635a10f450dfab2f076b/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5bf8b23f4e59fdc67f635a10f450dfab2f076b/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=6d5bf8b23f4e59fdc67f635a10f450dfab2f076b", "patch": "@@ -1467,48 +1467,6 @@ extern \"rust-intrinsic\" {\n     /// docs my friends, its friday!\n     pub fn align_offset(ptr: *const (), align: usize) -> usize;\n \n-    /// Computes the offset that needs to be applied to the pointer in order to make it aligned to\n-    /// `align`.\n-    ///\n-    /// If it is not possible to align the pointer, the implementation returns\n-    /// `usize::max_value()`.\n-    ///\n-    /// The offset is expressed in number of `T` elements, and not bytes. The value returned can be\n-    /// used with the `offset` or `offset_to` methods.\n-    ///\n-    /// There are no guarantees whatsover that offsetting the pointer will not overflow or go\n-    /// beyond the allocation that the pointer points into. It is up to the caller to ensure that\n-    /// the returned offset is correct in all terms other than alignment.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// `align` must be a power-of-two.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Accessing adjacent `u8` as `u16`\n-    ///\n-    /// ```\n-    /// # #![feature(core_intrinsics)]\n-    /// # fn foo(n: usize) {\n-    /// # use std::intrinsics::align_offset;\n-    /// # use std::mem::align_of;\n-    /// # unsafe {\n-    /// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n-    /// let ptr = &x[n] as *const u8;\n-    /// let offset = align_offset(ptr, align_of::<u16>());\n-    /// if offset < x.len() - n - 1 {\n-    ///     let u16_ptr = ptr.offset(offset as isize) as *const u16;\n-    ///     assert_ne!(*u16_ptr, 500);\n-    /// } else {\n-    ///     // while the pointer can be aligned via `offset`, it would point\n-    ///     // outside the allocation\n-    /// }\n-    /// # } }\n-    /// ```\n-    #[cfg(not(stage0))]\n-    pub fn align_offset<T>(ptr: *const T, align: usize) -> usize;\n-\n     /// Emits a `!nontemporal` store according to LLVM (see their docs).\n     /// Probably will never become stable.\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);"}, {"sha": "e2286d23e3348997070006080604e2d7f955d0c2", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6d5bf8b23f4e59fdc67f635a10f450dfab2f076b/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5bf8b23f4e59fdc67f635a10f450dfab2f076b/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=6d5bf8b23f4e59fdc67f635a10f450dfab2f076b", "patch": "@@ -1478,7 +1478,7 @@ impl<T: ?Sized> *const T {\n             panic!(\"align_offset: align is not a power-of-two\");\n         }\n         unsafe {\n-            intrinsics::align_offset(self, align)\n+            align_offset(self, align)\n         }\n     }\n \n@@ -2543,7 +2543,7 @@ impl<T: ?Sized> *mut T {\n             panic!(\"align_offset: align is not a power-of-two\");\n         }\n         unsafe {\n-            intrinsics::align_offset(self, align)\n+            align_offset(self, align)\n         }\n     }\n \n@@ -2565,8 +2565,6 @@ impl<T: ?Sized> *mut T {\n /// Calculate offset (in terms of elements of `stride` stride) that has to be applied\n /// to pointer `p` so that pointer `p` would get aligned to `a`.\n ///\n-/// This is an implementation of the `align_offset` intrinsic for the case where `stride > 1`.\n-///\n /// Note: This implementation has been carefully tailored to not panic. It is UB for this to panic.\n /// The only real change that can be made here is change of `INV_TABLE_MOD_16` and associated\n /// constants.\n@@ -2578,7 +2576,7 @@ impl<T: ?Sized> *mut T {\n /// Any questions go to @nagisa.\n #[lang=\"align_offset\"]\n #[cfg(not(stage0))]\n-unsafe fn align_offset(p: *const (), a: usize, stride: usize) -> usize {\n+pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     /// Calculate multiplicative modular inverse of `x` modulo `m`.\n     ///\n     /// This implementation is tailored for align_offset and has following preconditions:\n@@ -2587,12 +2585,13 @@ unsafe fn align_offset(p: *const (), a: usize, stride: usize) -> usize {\n     /// * `x < m`; (if `x \u2265 m`, pass in `x % m` instead)\n     ///\n     /// Implementation of this function shall not panic. Ever.\n+    #[inline]\n     fn mod_inv(x: usize, m: usize) -> usize {\n         /// Multiplicative modular inverse table modulo 2\u2074 = 16.\n         ///\n         /// Note, that this table does not contain values where inverse does not exist (i.e. for\n         /// `0\u207b\u00b9 mod 16`, `2\u207b\u00b9 mod 16`, etc.)\n-        static INV_TABLE_MOD_16: [usize; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n+        const INV_TABLE_MOD_16: [usize; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n         /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n         const INV_TABLE_MOD: usize = 16;\n         /// INV_TABLE_MOD\u00b2\n@@ -2627,18 +2626,30 @@ unsafe fn align_offset(p: *const (), a: usize, stride: usize) -> usize {\n         }\n     }\n \n+    let stride = ::mem::size_of::<T>();\n     let a_minus_one = a.wrapping_sub(1);\n     let pmoda = p as usize & a_minus_one;\n-    let smoda = stride & a_minus_one;\n-    // a is power-of-two so cannot be 0. stride = 0 is handled by the intrinsic.\n-    let gcdpow = intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a));\n-    let gcd = 1usize << gcdpow;\n \n     if pmoda == 0 {\n         // Already aligned. Yay!\n         return 0;\n     }\n \n+    if stride <= 1 {\n+        return if stride == 0 {\n+            // If the pointer is not aligned, and the element is zero-sized, then no amount of\n+            // elements will ever align the pointer.\n+            !0\n+        } else {\n+            a.wrapping_sub(pmoda)\n+        };\n+    }\n+\n+    let smoda = stride & a_minus_one;\n+    // a is power-of-two so cannot be 0. stride = 0 is handled above.\n+    let gcdpow = intrinsics::cttz_nonzero(stride).min(intrinsics::cttz_nonzero(a));\n+    let gcd = 1usize << gcdpow;\n+\n     if gcd == 1 {\n         // This branch solves for the variable $o$ in following linear congruence equation:\n         //"}, {"sha": "fdc9aa473e8b8ed2247225eecf8495ea96af1eba", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6d5bf8b23f4e59fdc67f635a10f450dfab2f076b/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5bf8b23f4e59fdc67f635a10f450dfab2f076b/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=6d5bf8b23f4e59fdc67f635a10f450dfab2f076b", "patch": "@@ -1794,8 +1794,11 @@ impl<T> [T] {\n             // handle ZSTs specially, which is \u2013 don't handle them at all.\n             return (self, &[], &[]);\n         }\n+\n+        // First, find at what point do we split between the first and 2nd slice. Easy with\n+        // ptr.align_offset.\n         let ptr = self.as_ptr();\n-        let offset = ::intrinsics::align_offset(ptr, ::mem::align_of::<U>());\n+        let offset = ::ptr::align_offset(ptr, ::mem::align_of::<U>());\n         if offset > self.len() {\n             return (self, &[], &[]);\n         } else {\n@@ -1848,7 +1851,7 @@ impl<T> [T] {\n         // First, find at what point do we split between the first and 2nd slice. Easy with\n         // ptr.align_offset.\n         let ptr = self.as_ptr();\n-        let offset = ::intrinsics::align_offset(ptr, ::mem::align_of::<U>());\n+        let offset = ::ptr::align_offset(ptr, ::mem::align_of::<U>());\n         if offset > self.len() {\n             return (self, &mut [], &mut []);\n         } else {"}, {"sha": "cffe7f79e970c91e44eb93817b8bd19050f88172", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6d5bf8b23f4e59fdc67f635a10f450dfab2f076b/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5bf8b23f4e59fdc67f635a10f450dfab2f076b/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=6d5bf8b23f4e59fdc67f635a10f450dfab2f076b", "patch": "@@ -25,7 +25,6 @@ use type_of::LayoutLlvmExt;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc::hir;\n-use rustc::middle::lang_items::AlignOffsetLangItem;\n use syntax::ast;\n use syntax::symbol::Symbol;\n use builder::Builder;\n@@ -390,31 +389,6 @@ pub fn codegen_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             args[0].deref(bx.cx).codegen_get_discr(bx, ret_ty)\n         }\n \n-        \"align_offset\" => {\n-            let (ptr, align) = (args[0].immediate(), args[1].immediate());\n-            let stride_of_t = bx.cx.layout_of(substs.type_at(0)).size_and_align().0.bytes();\n-            let stride = C_usize(bx.cx, stride_of_t);\n-            let zero = C_null(bx.cx.isize_ty);\n-            let max = C_int(cx.isize_ty, -1); // -1isize (wherein I cheat horribly to make !0usize)\n-\n-            if stride_of_t <= 1 {\n-                // offset = ptr as usize % align => offset = ptr as usize & (align - 1)\n-                let modmask = bx.sub(align, C_usize(bx.cx, 1));\n-                let offset = bx.and(bx.ptrtoint(ptr, bx.cx.isize_ty), modmask);\n-                let is_zero = bx.icmp(llvm::IntPredicate::IntEQ, offset, zero);\n-                // if offset == 0 { 0 } else { if stride_of_t == 1 { align - offset } else { !0 } }\n-                bx.select(is_zero, zero, if stride_of_t == 1 {\n-                    bx.sub(align, offset)\n-                } else {\n-                    max\n-                })\n-            } else {\n-                let did = ::common::langcall(bx.tcx(), Some(span), \"\", AlignOffsetLangItem);\n-                let instance = ty::Instance::mono(bx.tcx(), did);\n-                let llfn = ::callee::get_fn(bx.cx, instance);\n-                bx.call(llfn, &[ptr, align, stride], None)\n-            }\n-        }\n         name if name.starts_with(\"simd_\") => {\n             match generic_simd_intrinsic(bx, name,\n                                          callee_ty,"}, {"sha": "af1f1044edf2f79c5586f8110067c7e3c7a141ef", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d5bf8b23f4e59fdc67f635a10f450dfab2f076b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5bf8b23f4e59fdc67f635a10f450dfab2f076b/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=6d5bf8b23f4e59fdc67f635a10f450dfab2f076b", "patch": "@@ -314,10 +314,6 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 (0, vec![tcx.mk_fn_ptr(fn_ty), mut_u8, mut_u8], tcx.types.i32)\n             }\n \n-            \"align_offset\" => {\n-                (1, vec![tcx.mk_imm_ptr(param(0)), tcx.types.usize], tcx.types.usize)\n-            },\n-\n             \"nontemporal_store\" => {\n                 (1, vec![ tcx.mk_mut_ptr(param(0)), param(0) ], tcx.mk_nil())\n             }"}]}