{"sha": "132f5fc2e5247cf5dab74e5a4408135056852c30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMmY1ZmMyZTUyNDdjZjVkYWI3NGU1YTQ0MDgxMzUwNTY4NTJjMzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-27T17:48:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-27T17:48:23Z"}, "message": "Auto merge of #75933 - Aaron1011:feature/closure-move-err, r=oli-obk\n\nPoint to a move-related span when pointing to closure upvars\n\nFixes #75904\n\nWhen emitting move/borrow errors, we may point into a closure to\nindicate why an upvar is used in the closure. However, we use the\n'upvar span', which is just an arbitrary usage of the upvar. If the\nupvar is used in multiple places (e.g. a borrow and a move), we may end\nup pointing to the borrow. If the overall error is a move error, this\ncan be confusing.\n\nThis PR tracks the span that caused an upvar to become captured by-value\ninstead of by-ref (assuming that it's not a `move` closure). We use this\nspan instead of the 'upvar' span when we need to point to an upvar usage\nduring borrow checking.", "tree": {"sha": "199069ce54a9da2e7124452128dbeab9a1cc5306", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/199069ce54a9da2e7124452128dbeab9a1cc5306"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/132f5fc2e5247cf5dab74e5a4408135056852c30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/132f5fc2e5247cf5dab74e5a4408135056852c30", "html_url": "https://github.com/rust-lang/rust/commit/132f5fc2e5247cf5dab74e5a4408135056852c30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/132f5fc2e5247cf5dab74e5a4408135056852c30/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d0c847d3353e319ed82598a106e28fd490caa6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d0c847d3353e319ed82598a106e28fd490caa6b", "html_url": "https://github.com/rust-lang/rust/commit/3d0c847d3353e319ed82598a106e28fd490caa6b"}, {"sha": "b5b8b9329b3a118879bad6c476612d49f89461a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5b8b9329b3a118879bad6c476612d49f89461a3", "html_url": "https://github.com/rust-lang/rust/commit/b5b8b9329b3a118879bad6c476612d49f89461a3"}], "stats": {"total": 120, "additions": 102, "deletions": 18}, "files": [{"sha": "b6300a40b0d8d1e3e92dc0baa40442232b9dace8", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=132f5fc2e5247cf5dab74e5a4408135056852c30", "patch": "@@ -721,7 +721,13 @@ pub enum UpvarCapture<'tcx> {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n     /// depending on inference.\n-    ByValue,\n+    ///\n+    /// If the upvar was inferred to be captured by value (e.g. `move`\n+    /// was not used), then the `Span` points to a usage that\n+    /// required it. There may be more than one such usage\n+    /// (e.g. `|| { a; a; }`), in which case we pick an\n+    /// arbitrary one.\n+    ByValue(Option<Span>),\n \n     /// Upvar is captured by reference.\n     ByRef(UpvarBorrow<'tcx>),"}, {"sha": "dfaa75d9f23f80f14c2c56700b7b0b3289c084cd", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=132f5fc2e5247cf5dab74e5a4408135056852c30", "patch": "@@ -938,19 +938,38 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             \"closure_span: def_id={:?} target_place={:?} places={:?}\",\n             def_id, target_place, places\n         );\n-        let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(def_id.as_local()?);\n+        let local_did = def_id.as_local()?;\n+        let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(local_did);\n         let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(.., body_id, args_span, _) = expr {\n-            for (upvar, place) in self.infcx.tcx.upvars_mentioned(def_id)?.values().zip(places) {\n+            for ((upvar_hir_id, upvar), place) in\n+                self.infcx.tcx.upvars_mentioned(def_id)?.iter().zip(places)\n+            {\n                 match place {\n                     Operand::Copy(place) | Operand::Move(place)\n                         if target_place == place.as_ref() =>\n                     {\n                         debug!(\"closure_span: found captured local {:?}\", place);\n                         let body = self.infcx.tcx.hir().body(*body_id);\n                         let generator_kind = body.generator_kind();\n-                        return Some((*args_span, generator_kind, upvar.span));\n+                        let upvar_id = ty::UpvarId {\n+                            var_path: ty::UpvarPath { hir_id: *upvar_hir_id },\n+                            closure_expr_id: local_did,\n+                        };\n+\n+                        // If we have a more specific span available, point to that.\n+                        // We do this even though this span might be part of a borrow error\n+                        // message rather than a move error message. Our goal is to point\n+                        // to a span that shows why the upvar is used in the closure,\n+                        // so a move-related span is as good as any (and potentially better,\n+                        // if the overall error is due to a move of the upvar).\n+                        let usage_span =\n+                            match self.infcx.tcx.typeck(local_did).upvar_capture(upvar_id) {\n+                                ty::UpvarCapture::ByValue(Some(span)) => span,\n+                                _ => upvar.span,\n+                            };\n+                        return Some((*args_span, generator_kind, usage_span));\n                     }\n                     _ => {}\n                 }"}, {"sha": "86908eaabd1f4e1963d69f14111df62644bf5d2e", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=132f5fc2e5247cf5dab74e5a4408135056852c30", "patch": "@@ -163,7 +163,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n             let var_hir_id = upvar_id.var_path.hir_id;\n             let capture = tables.upvar_capture(*upvar_id);\n             let by_ref = match capture {\n-                ty::UpvarCapture::ByValue => false,\n+                ty::UpvarCapture::ByValue(_) => false,\n                 ty::UpvarCapture::ByRef(..) => true,\n             };\n             let mut upvar = Upvar {"}, {"sha": "249cce0ba19942809c580e6a5d9db10f05c4e907", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=132f5fc2e5247cf5dab74e5a4408135056852c30", "patch": "@@ -876,7 +876,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let mut projs = closure_env_projs.clone();\n                     projs.push(ProjectionElem::Field(Field::new(i), ty));\n                     match capture {\n-                        ty::UpvarCapture::ByValue => {}\n+                        ty::UpvarCapture::ByValue(_) => {}\n                         ty::UpvarCapture::ByRef(..) => {\n                             projs.push(ProjectionElem::Deref);\n                         }"}, {"sha": "066e46fec14567f40a049a4ea65f7bf515e94d96", "filename": "src/librustc_mir_build/thir/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fexpr.rs?ref=132f5fc2e5247cf5dab74e5a4408135056852c30", "patch": "@@ -959,7 +959,7 @@ fn convert_var<'tcx>(\n             // ...but the upvar might be an `&T` or `&mut T` capture, at which\n             // point we need an implicit deref\n             match cx.typeck_results().upvar_capture(upvar_id) {\n-                ty::UpvarCapture::ByValue => field_kind,\n+                ty::UpvarCapture::ByValue(_) => field_kind,\n                 ty::UpvarCapture::ByRef(borrow) => ExprKind::Deref {\n                     arg: Expr {\n                         temp_lifetime,\n@@ -1074,7 +1074,7 @@ fn capture_upvar<'tcx>(\n         kind: convert_var(cx, closure_expr, var_hir_id),\n     };\n     match upvar_capture {\n-        ty::UpvarCapture::ByValue => captured_var.to_ref(),\n+        ty::UpvarCapture::ByValue(_) => captured_var.to_ref(),\n         ty::UpvarCapture::ByRef(upvar_borrow) => {\n             let borrow_kind = match upvar_borrow.kind {\n                 ty::BorrowKind::ImmBorrow => BorrowKind::Shared,"}, {"sha": "55525586479d91b5003305a06b0e44173b2f11fb", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=132f5fc2e5247cf5dab74e5a4408135056852c30", "patch": "@@ -945,7 +945,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                         let var = self.variable(var_hir_id, upvar.span);\n                         self.acc(self.s.exit_ln, var, ACC_READ | ACC_USE);\n                     }\n-                    ty::UpvarCapture::ByValue => {}\n+                    ty::UpvarCapture::ByValue(_) => {}\n                 }\n             }\n         }\n@@ -1610,7 +1610,7 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 closure_expr_id: self.ir.body_owner,\n             };\n             match self.typeck_results.upvar_capture(upvar_id) {\n-                ty::UpvarCapture::ByValue => {}\n+                ty::UpvarCapture::ByValue(_) => {}\n                 ty::UpvarCapture::ByRef(..) => continue,\n             };\n             if self.used_on_entry(entry_ln, var) {"}, {"sha": "484961dbdb8f23e840264c92e06d336468bc4417", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=132f5fc2e5247cf5dab74e5a4408135056852c30", "patch": "@@ -786,7 +786,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                     return;\n                 }\n             }\n-            ty::UpvarCapture::ByValue => {}\n+            ty::UpvarCapture::ByValue(_) => {}\n         }\n         let fn_hir_id = self.tcx.hir().local_def_id_to_hir_id(upvar_id.closure_expr_id);\n         let ty = self.resolve_node_type(fn_hir_id);"}, {"sha": "9bb84c0786847eb8aa9db17784f6fe875d62ffc5", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=132f5fc2e5247cf5dab74e5a4408135056852c30", "patch": "@@ -42,6 +42,7 @@ use rustc_infer::infer::UpvarRegion;\n use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n use rustc_middle::ty::{self, Ty, TyCtxt, UpvarSubsts};\n use rustc_span::{Span, Symbol};\n+use std::collections::hash_map::Entry;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn closure_analyze(&self, body: &'tcx hir::Body<'tcx>) {\n@@ -124,7 +125,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 closure_captures.insert(var_hir_id, upvar_id);\n \n                 let capture_kind = match capture_clause {\n-                    hir::CaptureBy::Value => ty::UpvarCapture::ByValue,\n+                    hir::CaptureBy::Value => ty::UpvarCapture::ByValue(None),\n                     hir::CaptureBy::Ref => {\n                         let origin = UpvarRegion(upvar_id, span);\n                         let upvar_region = self.next_region_var(origin);\n@@ -237,7 +238,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     debug!(\"var_id={:?} upvar_ty={:?} capture={:?}\", var_hir_id, upvar_ty, capture);\n \n                     match capture {\n-                        ty::UpvarCapture::ByValue => upvar_ty,\n+                        ty::UpvarCapture::ByValue(_) => upvar_ty,\n                         ty::UpvarCapture::ByRef(borrow) => tcx.mk_ref(\n                             borrow.region,\n                             ty::TypeAndMut { ty: upvar_ty, mutbl: borrow.kind.to_mutbl_lossy() },\n@@ -300,15 +301,43 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n         debug!(\"adjust_upvar_borrow_kind_for_consume: upvar={:?}\", upvar_id);\n \n+        let usage_span = tcx.hir().span(place_with_id.hir_id);\n+\n         // To move out of an upvar, this must be a FnOnce closure\n         self.adjust_closure_kind(\n             upvar_id.closure_expr_id,\n             ty::ClosureKind::FnOnce,\n-            tcx.hir().span(place_with_id.hir_id),\n+            usage_span,\n             var_name(tcx, upvar_id.var_path.hir_id),\n         );\n \n-        self.adjust_upvar_captures.insert(upvar_id, ty::UpvarCapture::ByValue);\n+        // In a case like `let pat = upvar`, don't use the span\n+        // of the pattern, as this just looks confusing.\n+        let by_value_span = match tcx.hir().get(place_with_id.hir_id) {\n+            hir::Node::Pat(_) => None,\n+            _ => Some(usage_span),\n+        };\n+\n+        let new_capture = ty::UpvarCapture::ByValue(by_value_span);\n+        match self.adjust_upvar_captures.entry(upvar_id) {\n+            Entry::Occupied(mut e) => {\n+                match e.get() {\n+                    // We always overwrite `ByRef`, since we require\n+                    // that the upvar be available by value.\n+                    //\n+                    // If we had a previous by-value usage without a specific\n+                    // span, use ours instead. Otherwise, keep the first span\n+                    // we encountered, since there isn't an obviously better one.\n+                    ty::UpvarCapture::ByRef(_) | ty::UpvarCapture::ByValue(None) => {\n+                        e.insert(new_capture);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            Entry::Vacant(e) => {\n+                e.insert(new_capture);\n+            }\n+        }\n     }\n \n     /// Indicates that `place_with_id` is being directly mutated (e.g., assigned\n@@ -404,7 +433,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         );\n \n         match upvar_capture {\n-            ty::UpvarCapture::ByValue => {\n+            ty::UpvarCapture::ByValue(_) => {\n                 // Upvar is already by-value, the strongest criteria.\n             }\n             ty::UpvarCapture::ByRef(mut upvar_borrow) => {"}, {"sha": "67f67e64dd47be2c81729dcfb7d2670c5f02345f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=132f5fc2e5247cf5dab74e5a4408135056852c30", "patch": "@@ -331,7 +331,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_upvar_capture_map(&mut self) {\n         for (upvar_id, upvar_capture) in self.fcx.typeck_results.borrow().upvar_capture_map.iter() {\n             let new_upvar_capture = match *upvar_capture {\n-                ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n+                ty::UpvarCapture::ByValue(span) => ty::UpvarCapture::ByValue(span),\n                 ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n                     ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n                         kind: upvar_borrow.kind,"}, {"sha": "e774f2d095d9cc8cd6cb08ebf239d81022f1788c", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=132f5fc2e5247cf5dab74e5a4408135056852c30", "patch": "@@ -559,7 +559,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     var_id,\n                 ));\n                 match upvar_capture {\n-                    ty::UpvarCapture::ByValue => {\n+                    ty::UpvarCapture::ByValue(_) => {\n                         let mode = copy_or_move(&self.mc, &captured_place);\n                         self.delegate.consume(&captured_place, mode);\n                     }"}, {"sha": "6641a0376c6aecabba634a7630bb9ad61bdb290f", "filename": "src/test/ui/moves/issue-75904-move-closure-loop.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Ftest%2Fui%2Fmoves%2Fissue-75904-move-closure-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Ftest%2Fui%2Fmoves%2Fissue-75904-move-closure-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fissue-75904-move-closure-loop.rs?ref=132f5fc2e5247cf5dab74e5a4408135056852c30", "patch": "@@ -0,0 +1,15 @@\n+// Regression test for issue #75904\n+// Tests that we point at an expression\n+// that required the upvar to be moved, rather than just borrowed.\n+\n+struct NotCopy;\n+\n+fn main() {\n+    let mut a = NotCopy;\n+    loop {\n+        || { //~ ERROR use of moved value\n+            &mut a;\n+            a;\n+        };\n+    }\n+}"}, {"sha": "5e427a1fcdc7d77cbb704688066d22edd45f7f7d", "filename": "src/test/ui/moves/issue-75904-move-closure-loop.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Ftest%2Fui%2Fmoves%2Fissue-75904-move-closure-loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/132f5fc2e5247cf5dab74e5a4408135056852c30/src%2Ftest%2Fui%2Fmoves%2Fissue-75904-move-closure-loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fissue-75904-move-closure-loop.stderr?ref=132f5fc2e5247cf5dab74e5a4408135056852c30", "patch": "@@ -0,0 +1,15 @@\n+error[E0382]: use of moved value: `a`\n+  --> $DIR/issue-75904-move-closure-loop.rs:10:9\n+   |\n+LL |     let mut a = NotCopy;\n+   |         ----- move occurs because `a` has type `NotCopy`, which does not implement the `Copy` trait\n+LL |     loop {\n+LL |         || {\n+   |         ^^ value moved into closure here, in previous iteration of loop\n+LL |             &mut a;\n+LL |             a;\n+   |             - use occurs due to use in closure\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}]}