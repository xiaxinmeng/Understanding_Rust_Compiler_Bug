{"sha": "1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c", "node_id": "C_kwDOAAsO6NoAKDFkYzQzYjJlOGI1ZmFiYTBhNWE1YzdlYjg5OWU2ZjYzZTY1NGU0NmM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-01-13T18:16:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-13T18:16:41Z"}, "message": "Rollup merge of #106465 - compiler-errors:bump-IMPLIED_BOUNDS_ENTAILMENT, r=lcnr\n\nBump `IMPLIED_BOUNDS_ENTAILMENT` to Deny + ReportNow\n\nhttps://github.com/rust-lang/rust/pull/105575#issuecomment-1357201969\n\n> and then later in the same cycle increase the lint to `deny` and change it to `FutureCompatReportNow` in this nightly cycle.\n\nr? ```@lcnr``` when they're back from holiday :smile:", "tree": {"sha": "167e9536393b1b6033cd013485a8a1ee27a0f37c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/167e9536393b1b6033cd013485a8a1ee27a0f37c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjwaAJCRBK7hj4Ov3rIwAAQ7kIACF8ZQuTB0Yv3sgMrdtze8JI\nU5836OWpMKZaogkQnUINBWskZ/C7fqRlMn9dH1KgIPMzOso2b/i9p3wnp5iSHpvw\nTTwjLocXAhGCYxSVWHflpVu1FMqGMskbpAiDiU8F3DmM+ihGvJdpfhl1jSrwqJCn\nrE6RX6CeIciUf5sKr/F69Zsb5104QrIuGBkcXUwt1VqFeLC45J04m/0Cw20goKgK\nuN6UXzUuiTmVm7P4VGydyoNEmTzy6xO/e8uD6v1DiIMCbV07fZMbM9D6nsk8r+rA\nXZ+XASh+ZFCg7baslsLXAXex+E/FRjTXWg+/cv3Snc5/1Sub9agbjAs22c6IxvY=\n=H5Dj\n-----END PGP SIGNATURE-----\n", "payload": "tree 167e9536393b1b6033cd013485a8a1ee27a0f37c\nparent 96bb02f35c4f8bef4090185bdbb8f5bc4a898e44\nparent eaa7cc84d358a0113c063d445e5d0d7caeeea94c\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1673633801 +0100\ncommitter GitHub <noreply@github.com> 1673633801 +0100\n\nRollup merge of #106465 - compiler-errors:bump-IMPLIED_BOUNDS_ENTAILMENT, r=lcnr\n\nBump `IMPLIED_BOUNDS_ENTAILMENT` to Deny + ReportNow\n\nhttps://github.com/rust-lang/rust/pull/105575#issuecomment-1357201969\n\n> and then later in the same cycle increase the lint to `deny` and change it to `FutureCompatReportNow` in this nightly cycle.\n\nr? ```@lcnr``` when they're back from holiday :smile:\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c", "html_url": "https://github.com/rust-lang/rust/commit/1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96bb02f35c4f8bef4090185bdbb8f5bc4a898e44", "url": "https://api.github.com/repos/rust-lang/rust/commits/96bb02f35c4f8bef4090185bdbb8f5bc4a898e44", "html_url": "https://github.com/rust-lang/rust/commit/96bb02f35c4f8bef4090185bdbb8f5bc4a898e44"}, {"sha": "eaa7cc84d358a0113c063d445e5d0d7caeeea94c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaa7cc84d358a0113c063d445e5d0d7caeeea94c", "html_url": "https://github.com/rust-lang/rust/commit/eaa7cc84d358a0113c063d445e5d0d7caeeea94c"}], "stats": {"total": 202, "additions": 184, "deletions": 18}, "files": [{"sha": "2cdf75794713fe67666bc377a607976422e188ba", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 148, "deletions": 12, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c", "patch": "@@ -2,7 +2,9 @@ use super::potentially_plural_count;\n use crate::errors::LifetimesOrBoundsMismatchOnTrait;\n use hir::def_id::{DefId, LocalDefId};\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed};\n+use rustc_errors::{\n+    pluralize, struct_span_err, Applicability, DiagnosticId, ErrorGuaranteed, MultiSpan,\n+};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n@@ -320,15 +322,6 @@ fn compare_method_predicate_entailment<'tcx>(\n             ty::Binder::dummy(ty::PredicateKind::WellFormed(unnormalized_impl_fty.into())),\n         ));\n     }\n-    let emit_implied_wf_lint = || {\n-        infcx.tcx.struct_span_lint_hir(\n-            rustc_session::lint::builtin::IMPLIED_BOUNDS_ENTAILMENT,\n-            impl_m_hir_id,\n-            infcx.tcx.def_span(impl_m.def_id),\n-            \"impl method assumes more implied bounds than the corresponding trait method\",\n-            |lint| lint,\n-        );\n-    };\n \n     // Check that all obligations are satisfied by the implementation's\n     // version.\n@@ -346,7 +339,7 @@ fn compare_method_predicate_entailment<'tcx>(\n                 )\n                 .map(|()| {\n                     // If the skip-mode was successful, emit a lint.\n-                    emit_implied_wf_lint();\n+                    emit_implied_wf_lint(infcx.tcx, impl_m, impl_m_hir_id, vec![]);\n                 });\n             }\n             CheckImpliedWfMode::Skip => {\n@@ -382,8 +375,16 @@ fn compare_method_predicate_entailment<'tcx>(\n                     CheckImpliedWfMode::Skip,\n                 )\n                 .map(|()| {\n+                    let bad_args = extract_bad_args_for_implies_lint(\n+                        tcx,\n+                        &errors,\n+                        (trait_m, trait_sig),\n+                        // Unnormalized impl sig corresponds to the HIR types written\n+                        (impl_m, unnormalized_impl_sig),\n+                        impl_m_hir_id,\n+                    );\n                     // If the skip-mode was successful, emit a lint.\n-                    emit_implied_wf_lint();\n+                    emit_implied_wf_lint(tcx, impl_m, impl_m_hir_id, bad_args);\n                 });\n             }\n             CheckImpliedWfMode::Skip => {\n@@ -400,6 +401,141 @@ fn compare_method_predicate_entailment<'tcx>(\n     Ok(())\n }\n \n+fn extract_bad_args_for_implies_lint<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    errors: &[infer::RegionResolutionError<'tcx>],\n+    (trait_m, trait_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n+    (impl_m, impl_sig): (&ty::AssocItem, ty::FnSig<'tcx>),\n+    hir_id: hir::HirId,\n+) -> Vec<(Span, Option<String>)> {\n+    let mut blame_generics = vec![];\n+    for error in errors {\n+        // Look for the subregion origin that contains an input/output type\n+        let origin = match error {\n+            infer::RegionResolutionError::ConcreteFailure(o, ..) => o,\n+            infer::RegionResolutionError::GenericBoundFailure(o, ..) => o,\n+            infer::RegionResolutionError::SubSupConflict(_, _, o, ..) => o,\n+            infer::RegionResolutionError::UpperBoundUniverseConflict(.., o, _) => o,\n+        };\n+        // Extract (possible) input/output types from origin\n+        match origin {\n+            infer::SubregionOrigin::Subtype(trace) => {\n+                if let Some((a, b)) = trace.values.ty() {\n+                    blame_generics.extend([a, b]);\n+                }\n+            }\n+            infer::SubregionOrigin::RelateParamBound(_, ty, _) => blame_generics.push(*ty),\n+            infer::SubregionOrigin::ReferenceOutlivesReferent(ty, _) => blame_generics.push(*ty),\n+            _ => {}\n+        }\n+    }\n+\n+    let fn_decl = tcx.hir().fn_decl_by_hir_id(hir_id).unwrap();\n+    let opt_ret_ty = match fn_decl.output {\n+        hir::FnRetTy::DefaultReturn(_) => None,\n+        hir::FnRetTy::Return(ty) => Some(ty),\n+    };\n+\n+    // Map late-bound regions from trait to impl, so the names are right.\n+    let mapping = std::iter::zip(\n+        tcx.fn_sig(trait_m.def_id).bound_vars(),\n+        tcx.fn_sig(impl_m.def_id).bound_vars(),\n+    )\n+    .filter_map(|(impl_bv, trait_bv)| {\n+        if let ty::BoundVariableKind::Region(impl_bv) = impl_bv\n+            && let ty::BoundVariableKind::Region(trait_bv) = trait_bv\n+        {\n+            Some((impl_bv, trait_bv))\n+        } else {\n+            None\n+        }\n+    })\n+    .collect();\n+\n+    // For each arg, see if it was in the \"blame\" of any of the region errors.\n+    // If so, then try to produce a suggestion to replace the argument type with\n+    // one from the trait.\n+    let mut bad_args = vec![];\n+    for (idx, (ty, hir_ty)) in\n+        std::iter::zip(impl_sig.inputs_and_output, fn_decl.inputs.iter().chain(opt_ret_ty))\n+            .enumerate()\n+    {\n+        let expected_ty = trait_sig.inputs_and_output[idx]\n+            .fold_with(&mut RemapLateBound { tcx, mapping: &mapping });\n+        if blame_generics.iter().any(|blame| ty.contains(*blame)) {\n+            let expected_ty_sugg = expected_ty.to_string();\n+            bad_args.push((\n+                hir_ty.span,\n+                // Only suggest something if it actually changed.\n+                (expected_ty_sugg != ty.to_string()).then_some(expected_ty_sugg),\n+            ));\n+        }\n+    }\n+\n+    bad_args\n+}\n+\n+struct RemapLateBound<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    mapping: &'a FxHashMap<ty::BoundRegionKind, ty::BoundRegionKind>,\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for RemapLateBound<'_, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        if let ty::ReFree(fr) = *r {\n+            self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n+                bound_region: self\n+                    .mapping\n+                    .get(&fr.bound_region)\n+                    .copied()\n+                    .unwrap_or(fr.bound_region),\n+                ..fr\n+            }))\n+        } else {\n+            r\n+        }\n+    }\n+}\n+\n+fn emit_implied_wf_lint<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_m: &ty::AssocItem,\n+    hir_id: hir::HirId,\n+    bad_args: Vec<(Span, Option<String>)>,\n+) {\n+    let span: MultiSpan = if bad_args.is_empty() {\n+        tcx.def_span(impl_m.def_id).into()\n+    } else {\n+        bad_args.iter().map(|(span, _)| *span).collect::<Vec<_>>().into()\n+    };\n+    tcx.struct_span_lint_hir(\n+        rustc_session::lint::builtin::IMPLIED_BOUNDS_ENTAILMENT,\n+        hir_id,\n+        span,\n+        \"impl method assumes more implied bounds than the corresponding trait method\",\n+        |lint| {\n+            let bad_args: Vec<_> =\n+                bad_args.into_iter().filter_map(|(span, sugg)| Some((span, sugg?))).collect();\n+            if !bad_args.is_empty() {\n+                lint.multipart_suggestion(\n+                    format!(\n+                        \"replace {} type{} to make the impl signature compatible\",\n+                        pluralize!(\"this\", bad_args.len()),\n+                        pluralize!(bad_args.len())\n+                    ),\n+                    bad_args,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            lint\n+        },\n+    );\n+}\n+\n #[derive(Debug, PartialEq, Eq)]\n enum CheckImpliedWfMode {\n     /// Checks implied well-formedness of the impl method. If it fails, we will"}, {"sha": "6cdf50970836a99ab5a7c73033a5d68ff202c0bd", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c", "patch": "@@ -4033,10 +4033,10 @@ declare_lint! {\n     ///\n     /// This can be used to implement an unsound API if used incorrectly.\n     pub IMPLIED_BOUNDS_ENTAILMENT,\n-    Warn,\n+    Deny,\n     \"impl method assumes more implied bounds than its corresponding trait method\",\n     @future_incompatible = FutureIncompatibleInfo {\n         reference: \"issue #105572 <https://github.com/rust-lang/rust/issues/105572>\",\n-        reason: FutureIncompatibilityReason::FutureReleaseError,\n+        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n     };\n }"}, {"sha": "ebe07027d2fa1ba036fd2a950a02b388863f6699", "filename": "tests/ui/implied-bounds/impl-implied-bounds-compatibility-unnormalized.stderr", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility-unnormalized.stderr?ref=1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c", "patch": "@@ -1,8 +1,8 @@\n error: impl method assumes more implied bounds than the corresponding trait method\n-  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:13:5\n+  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:13:31\n    |\n LL |     fn get<'s>(s: &'s str, _: <&'static &'s () as Project>::Ty) -> &'static str {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `()`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n@@ -14,3 +14,18 @@ LL | #![deny(implied_bounds_entailment)]\n \n error: aborting due to previous error\n \n+Future incompatibility report: Future breakage diagnostic:\n+error: impl method assumes more implied bounds than the corresponding trait method\n+  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:13:31\n+   |\n+LL |     fn get<'s>(s: &'s str, _: <&'static &'s () as Project>::Ty) -> &'static str {\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `()`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n+note: the lint level is defined here\n+  --> $DIR/impl-implied-bounds-compatibility-unnormalized.rs:1:9\n+   |\n+LL | #![deny(implied_bounds_entailment)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+"}, {"sha": "43d3e058ffeb3f10adc89c2b7a1968f9b781aff1", "filename": "tests/ui/implied-bounds/impl-implied-bounds-compatibility.stderr", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplied-bounds%2Fimpl-implied-bounds-compatibility.stderr?ref=1dc43b2e8b5faba0a5a5c7eb899e6f63e654e46c", "patch": "@@ -1,8 +1,8 @@\n error: impl method assumes more implied bounds than the corresponding trait method\n-  --> $DIR/impl-implied-bounds-compatibility.rs:14:5\n+  --> $DIR/impl-implied-bounds-compatibility.rs:14:35\n    |\n LL |     fn listeners<'b>(&'b self) -> &'a MessageListeners<'b> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `&'b MessageListeners<'b>`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n@@ -14,3 +14,18 @@ LL | #![deny(implied_bounds_entailment)]\n \n error: aborting due to previous error\n \n+Future incompatibility report: Future breakage diagnostic:\n+error: impl method assumes more implied bounds than the corresponding trait method\n+  --> $DIR/impl-implied-bounds-compatibility.rs:14:35\n+   |\n+LL |     fn listeners<'b>(&'b self) -> &'a MessageListeners<'b> {\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: replace this type to make the impl signature compatible: `&'b MessageListeners<'b>`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #105572 <https://github.com/rust-lang/rust/issues/105572>\n+note: the lint level is defined here\n+  --> $DIR/impl-implied-bounds-compatibility.rs:1:9\n+   |\n+LL | #![deny(implied_bounds_entailment)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+"}]}