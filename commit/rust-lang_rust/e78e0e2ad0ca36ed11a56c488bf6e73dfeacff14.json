{"sha": "e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14", "node_id": "C_kwDOAAsO6NoAKGU3OGUwZTJhZDBjYTM2ZWQxMWE1NmM0ODhiZjZlNzNkZmVhY2ZmMTQ", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-06-29T15:46:16Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-04T12:35:20Z"}, "message": "rip out `RegionCtxt` from hir typeck", "tree": {"sha": "0c5b24714985bf16cb3a14d7bcad9057d0fa9117", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c5b24714985bf16cb3a14d7bcad9057d0fa9117"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14", "html_url": "https://github.com/rust-lang/rust/commit/e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68d70fc5bde3f2522f62cfd854939100a706e8ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/68d70fc5bde3f2522f62cfd854939100a706e8ce", "html_url": "https://github.com/rust-lang/rust/commit/68d70fc5bde3f2522f62cfd854939100a706e8ce"}], "stats": {"total": 909, "additions": 13, "deletions": 896}, "files": [{"sha": "aad3c37f84e5a783250e31ad60ad9d512a103c47", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 3, "deletions": 67, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14", "patch": "@@ -1,73 +1,7 @@\n-use crate::infer::at::At;\n-use crate::infer::canonical::OriginalQueryValues;\n-use crate::infer::InferOk;\n-\n-use rustc_middle::ty::subst::GenericArg;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n pub use rustc_middle::traits::query::{DropckConstraint, DropckOutlivesResult};\n \n-pub trait AtExt<'tcx> {\n-    fn dropck_outlives(&self, ty: Ty<'tcx>) -> InferOk<'tcx, Vec<GenericArg<'tcx>>>;\n-}\n-\n-impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n-    /// Given a type `ty` of some value being dropped, computes a set\n-    /// of \"kinds\" (types, regions) that must be outlive the execution\n-    /// of the destructor. These basically correspond to data that the\n-    /// destructor might access. This is used during regionck to\n-    /// impose \"outlives\" constraints on any lifetimes referenced\n-    /// within.\n-    ///\n-    /// The rules here are given by the \"dropck\" RFCs, notably [#1238]\n-    /// and [#1327]. This is a fixed-point computation, where we\n-    /// explore all the data that will be dropped (transitively) when\n-    /// a value of type `ty` is dropped. For each type T that will be\n-    /// dropped and which has a destructor, we must assume that all\n-    /// the types/regions of T are live during the destructor, unless\n-    /// they are marked with a special attribute (`#[may_dangle]`).\n-    ///\n-    /// [#1238]: https://github.com/rust-lang/rfcs/blob/master/text/1238-nonparametric-dropck.md\n-    /// [#1327]: https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md\n-    fn dropck_outlives(&self, ty: Ty<'tcx>) -> InferOk<'tcx, Vec<GenericArg<'tcx>>> {\n-        debug!(\"dropck_outlives(ty={:?}, param_env={:?})\", ty, self.param_env,);\n-\n-        // Quick check: there are a number of cases that we know do not require\n-        // any destructor.\n-        let tcx = self.infcx.tcx;\n-        if trivial_dropck_outlives(tcx, ty) {\n-            return InferOk { value: vec![], obligations: vec![] };\n-        }\n-\n-        let mut orig_values = OriginalQueryValues::default();\n-        let c_ty = self.infcx.canonicalize_query(self.param_env.and(ty), &mut orig_values);\n-        let span = self.cause.span;\n-        debug!(\"c_ty = {:?}\", c_ty);\n-        if let Ok(result) = tcx.dropck_outlives(c_ty)\n-            && result.is_proven()\n-            && let Ok(InferOk { value, obligations }) =\n-                self.infcx.instantiate_query_response_and_region_obligations(\n-                    self.cause,\n-                    self.param_env,\n-                    &orig_values,\n-                    result,\n-                )\n-        {\n-            let ty = self.infcx.resolve_vars_if_possible(ty);\n-            let kinds = value.into_kinds_reporting_overflows(tcx, span, ty);\n-            return InferOk { value: kinds, obligations };\n-        }\n-\n-        // Errors and ambiguity in dropck occur in two cases:\n-        // - unresolved inference variables at the end of typeck\n-        // - non well-formed types where projections cannot be resolved\n-        // Either of these should have created an error before.\n-        tcx.sess.delay_span_bug(span, \"dtorck encountered internal error\");\n-\n-        InferOk { value: vec![], obligations: vec![] }\n-    }\n-}\n-\n /// This returns true if the type `ty` is \"trivial\" for\n /// dropck-outlives -- that is, if it doesn't require any types to\n /// outlive. This is similar but not *quite* the same as the\n@@ -79,6 +13,8 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n ///\n /// Note also that `needs_drop` requires a \"global\" type (i.e., one\n /// with erased regions), but this function does not.\n+///\n+// FIXME(@lcnr): remove this module and move this function somewhere else.\n pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.kind() {\n         // None of these types have a destructor and hence they do not\n@@ -105,7 +41,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, *ty),\n \n         // (T1..Tn) and closures have same properties as T1..Tn --\n-        // check if *any* of those are trivial.\n+        // check if *all* of them are trivial.\n         ty::Tuple(tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t)),\n         ty::Closure(_, ref substs) => {\n             trivial_dropck_outlives(tcx, substs.as_closure().tupled_upvars_ty())"}, {"sha": "72095c408075cdc8fdfeb054d4eedef0cb03729f", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14", "patch": "@@ -1,13 +1,13 @@\n-use crate::check::regionck::RegionCtxt;\n-use crate::hir;\n+// FIXME(@lcnr): Move this module out of `rustc_typeck`.\n+//\n+// We don't do any drop checking during hir typeck.\n use crate::hir::def_id::{DefId, LocalDefId};\n use rustc_errors::{struct_span_err, ErrorGuaranteed};\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::util::IgnoreRegions;\n use rustc_middle::ty::{self, Predicate, Ty, TyCtxt};\n-use rustc_span::Span;\n \n /// This function confirms that the `Drop` implementation identified by\n /// `drop_impl_did` is not any more specialized than the type it is\n@@ -229,19 +229,6 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     result\n }\n \n-/// This function is not only checking that the dropck obligations are met for\n-/// the given type, but it's also currently preventing non-regular recursion in\n-/// types from causing stack overflows (dropck_no_diverge_on_nonregular_*.rs).\n-///\n-/// FIXME: Completely rip out dropck and regionck.\n-pub(crate) fn check_drop_obligations<'a, 'tcx>(\n-    _rcx: &mut RegionCtxt<'a, 'tcx>,\n-    _ty: Ty<'tcx>,\n-    _span: Span,\n-    _body_id: hir::HirId,\n-) {\n-}\n-\n // This is an implementation of the TypeRelation trait with the\n // aim of simply comparing for equality (without side-effects).\n // It is not intended to be used anywhere else other than here."}, {"sha": "dee58791cec1827ac5a40319e0ea04db19a8c3f8", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14", "patch": "@@ -368,7 +368,7 @@ fn typeck_with_fallback<'tcx>(\n \n     let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n-        let (fcx, wf_tys) = if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n+        let fcx = if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n             let fn_sig = if crate::collect::get_infer_ret_ty(&decl.output).is_some() {\n                 let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n                 <dyn AstConv<'_>>::ty_of_fn(&fcx, id, header.unsafety, header.abi, decl, None, None)\n@@ -378,24 +378,15 @@ fn typeck_with_fallback<'tcx>(\n \n             check_abi(tcx, id, span, fn_sig.abi());\n \n-            // When normalizing the function signature, we assume all types are\n-            // well-formed. So, we don't need to worry about the obligations\n-            // from normalization. We could just discard these, but to align with\n-            // compare_method and elsewhere, we just add implied bounds for\n-            // these types.\n-            let mut wf_tys = FxHashSet::default();\n-            // Compute the fty from point of view of inside the fn.\n+            // Compute the function signature from point of view of inside the fn.\n             let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n             let fn_sig = inh.normalize_associated_types_in(\n                 body.value.span,\n                 body_id.hir_id,\n                 param_env,\n                 fn_sig,\n             );\n-            wf_tys.extend(fn_sig.inputs_and_output.iter());\n-\n-            let fcx = check_fn(&inh, param_env, fn_sig, decl, id, body, None, true).0;\n-            (fcx, wf_tys)\n+            check_fn(&inh, param_env, fn_sig, decl, id, body, None, true).0\n         } else {\n             let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n             let expected_type = body_ty\n@@ -458,7 +449,7 @@ fn typeck_with_fallback<'tcx>(\n \n             fcx.write_ty(id, expected_type);\n \n-            (fcx, FxHashSet::default())\n+            fcx\n         };\n \n         let fallback_has_occurred = fcx.type_inference_fallback();\n@@ -490,11 +481,7 @@ fn typeck_with_fallback<'tcx>(\n \n         fcx.check_asms();\n \n-        if fn_sig.is_some() {\n-            fcx.regionck_fn(id, body, wf_tys);\n-        } else {\n-            fcx.regionck_body(body);\n-        }\n+        fcx.infcx.skip_region_resolution();\n \n         fcx.resolve_type_vars_in_body(body)\n     });"}, {"sha": "1c3c5f999bca8ef2e4459dba147bb63652d2f9e7", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 795, "changes": 797, "blob_url": "https://github.com/rust-lang/rust/blob/e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=e78e0e2ad0ca36ed11a56c488bf6e73dfeacff14", "patch": "@@ -1,106 +1,9 @@\n-//! The region check is a final pass that runs over the AST after we have\n-//! inferred the type constraints but before we have actually finalized\n-//! the types. Its purpose is to embed a variety of region constraints.\n-//! Inserting these constraints as a separate pass is good because (1) it\n-//! localizes the code that has to do with region inference and (2) often\n-//! we cannot know what constraints are needed until the basic types have\n-//! been inferred.\n-//!\n-//! ### Interaction with the borrow checker\n-//!\n-//! In general, the job of the borrowck module (which runs later) is to\n-//! check that all soundness criteria are met, given a particular set of\n-//! regions. The job of *this* module is to anticipate the needs of the\n-//! borrow checker and infer regions that will satisfy its requirements.\n-//! It is generally true that the inference doesn't need to be sound,\n-//! meaning that if there is a bug and we inferred bad regions, the borrow\n-//! checker should catch it. This is not entirely true though; for\n-//! example, the borrow checker doesn't check subtyping, and it doesn't\n-//! check that region pointers are always live when they are used. It\n-//! might be worthwhile to fix this so that borrowck serves as a kind of\n-//! verification step -- that would add confidence in the overall\n-//! correctness of the compiler, at the cost of duplicating some type\n-//! checks and effort.\n-//!\n-//! ### Inferring the duration of borrows, automatic and otherwise\n-//!\n-//! Whenever we introduce a borrowed pointer, for example as the result of\n-//! a borrow expression `let x = &data`, the lifetime of the pointer `x`\n-//! is always specified as a region inference variable. `regionck` has the\n-//! job of adding constraints such that this inference variable is as\n-//! narrow as possible while still accommodating all uses (that is, every\n-//! dereference of the resulting pointer must be within the lifetime).\n-//!\n-//! #### Reborrows\n-//!\n-//! Generally speaking, `regionck` does NOT try to ensure that the data\n-//! `data` will outlive the pointer `x`. That is the job of borrowck. The\n-//! one exception is when \"re-borrowing\" the contents of another borrowed\n-//! pointer. For example, imagine you have a borrowed pointer `b` with\n-//! lifetime `L1` and you have an expression `&*b`. The result of this\n-//! expression will be another borrowed pointer with lifetime `L2` (which is\n-//! an inference variable). The borrow checker is going to enforce the\n-//! constraint that `L2 < L1`, because otherwise you are re-borrowing data\n-//! for a lifetime larger than the original loan. However, without the\n-//! routines in this module, the region inferencer would not know of this\n-//! dependency and thus it might infer the lifetime of `L2` to be greater\n-//! than `L1` (issue #3148).\n-//!\n-//! There are a number of troublesome scenarios in the tests\n-//! `region-dependent-*.rs`, but here is one example:\n-//!\n-//!     struct Foo { i: i32 }\n-//!     struct Bar { foo: Foo  }\n-//!     fn get_i<'a>(x: &'a Bar) -> &'a i32 {\n-//!        let foo = &x.foo; // Lifetime L1\n-//!        &foo.i            // Lifetime L2\n-//!     }\n-//!\n-//! Note that this comes up either with `&` expressions, `ref`\n-//! bindings, and `autorefs`, which are the three ways to introduce\n-//! a borrow.\n-//!\n-//! The key point here is that when you are borrowing a value that\n-//! is \"guaranteed\" by a borrowed pointer, you must link the\n-//! lifetime of that borrowed pointer (`L1`, here) to the lifetime of\n-//! the borrow itself (`L2`). What do I mean by \"guaranteed\" by a\n-//! borrowed pointer? I mean any data that is reached by first\n-//! dereferencing a borrowed pointer and then either traversing\n-//! interior offsets or boxes. We say that the guarantor\n-//! of such data is the region of the borrowed pointer that was\n-//! traversed. This is essentially the same as the ownership\n-//! relation, except that a borrowed pointer never owns its\n-//! contents.\n-\n-use crate::check::dropck;\n-use crate::check::FnCtxt;\n-use crate::mem_categorization as mc;\n use crate::outlives::outlives_bounds::InferCtxtExt as _;\n-use hir::def_id::LocalDefId;\n use rustc_data_structures::stable_set::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::PatKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{self, InferCtxt, RegionObligation};\n-use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n-use rustc_middle::ty::adjustment;\n-use rustc_middle::ty::{self, Ty};\n-use rustc_span::Span;\n-use std::ops::Deref;\n-\n-// a variation on try that just returns unit\n-macro_rules! ignore_err {\n-    ($e:expr) => {\n-        match $e {\n-            Ok(e) => e,\n-            Err(_) => {\n-                debug!(\"ignoring mem-categorization error!\");\n-                return ();\n-            }\n-        }\n-    };\n-}\n+use rustc_infer::infer::InferCtxt;\n+use rustc_middle::ty::Ty;\n \n pub(crate) trait OutlivesEnvironmentExt<'tcx> {\n     fn add_implied_bounds(\n@@ -142,699 +45,3 @@ impl<'tcx> OutlivesEnvironmentExt<'tcx> for OutlivesEnvironment<'tcx> {\n         }\n     }\n }\n-\n-///////////////////////////////////////////////////////////////////////////\n-// PUBLIC ENTRY POINTS\n-\n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn regionck_body(&self, body: &'tcx hir::Body<'tcx>) {\n-        let body_owner = self.tcx.hir().body_owner_def_id(body.id());\n-        let mut rcx = RegionCtxt::new(self, body_owner, self.param_env);\n-\n-        // There are no add'l implied bounds when checking a\n-        // standalone body (e.g., the `E` in a type like `[u32; E]`).\n-        rcx.outlives_environment.save_implied_bounds(rcx.body_id());\n-\n-        if !self.errors_reported_since_creation() {\n-            // regionck assumes typeck succeeded\n-            rcx.visit_body(body);\n-            rcx.visit_region_obligations(rcx.body_id());\n-        }\n-        // Checked by NLL\n-        rcx.fcx.skip_region_resolution();\n-    }\n-\n-    /// Region check a function body. Not invoked on closures, but\n-    /// only on the \"root\" fn item (in which closures may be\n-    /// embedded). Walks the function body and adds various add'l\n-    /// constraints that are needed for region inference. This is\n-    /// separated both to isolate \"pure\" region constraints from the\n-    /// rest of type check and because sometimes we need type\n-    /// inference to have completed before we can determine which\n-    /// constraints to add.\n-    pub(crate) fn regionck_fn(\n-        &self,\n-        fn_id: hir::HirId,\n-        body: &'tcx hir::Body<'tcx>,\n-        wf_tys: FxHashSet<Ty<'tcx>>,\n-    ) {\n-        debug!(\"regionck_fn(id={})\", fn_id);\n-        let body_owner = self.tcx.hir().body_owner_def_id(body.id());\n-        let mut rcx = RegionCtxt::new(self, body_owner, self.param_env);\n-        // We need to add the implied bounds from the function signature\n-        rcx.outlives_environment.add_implied_bounds(self, wf_tys, fn_id);\n-        rcx.outlives_environment.save_implied_bounds(fn_id);\n-\n-        if !self.errors_reported_since_creation() {\n-            // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, body);\n-        }\n-\n-        // Checked by NLL\n-        rcx.fcx.skip_region_resolution();\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// INTERNALS\n-\n-pub struct RegionCtxt<'a, 'tcx> {\n-    pub fcx: &'a FnCtxt<'a, 'tcx>,\n-\n-    outlives_environment: OutlivesEnvironment<'tcx>,\n-\n-    body_owner: LocalDefId,\n-}\n-\n-impl<'a, 'tcx> Deref for RegionCtxt<'a, 'tcx> {\n-    type Target = FnCtxt<'a, 'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        self.fcx\n-    }\n-}\n-\n-impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n-    pub fn new(\n-        fcx: &'a FnCtxt<'a, 'tcx>,\n-        body_owner: LocalDefId,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> RegionCtxt<'a, 'tcx> {\n-        let outlives_environment = OutlivesEnvironment::new(param_env);\n-        RegionCtxt { fcx, body_owner, outlives_environment }\n-    }\n-\n-    /// FIXME: Ideally all the callers would deal with\n-    /// `LocalDefId`s as well. Ah well, this code is going\n-    /// to be removed soon anyways \ud83e\udd37\n-    pub fn body_id(&self) -> hir::HirId {\n-        self.tcx.hir().local_def_id_to_hir_id(self.body_owner)\n-    }\n-\n-    /// Try to resolve the type for the given node, returning `t_err` if an error results. Note that\n-    /// we never care about the details of the error, the same error will be detected and reported\n-    /// in the writeback phase.\n-    ///\n-    /// Note one important point: we do not attempt to resolve *region variables* here. This is\n-    /// because regionck is essentially adding constraints to those region variables and so may yet\n-    /// influence how they are resolved.\n-    ///\n-    /// Consider this silly example:\n-    ///\n-    /// ```ignore UNSOLVED (does replacing @i32 with Box<i32> preserve the desired semantics for the example?)\n-    /// fn borrow(x: &i32) -> &i32 {x}\n-    /// fn foo(x: @i32) -> i32 {  // block: B\n-    ///     let b = borrow(x);    // region: <R0>\n-    ///     *b\n-    /// }\n-    /// ```\n-    ///\n-    /// Here, the region of `b` will be `<R0>`. `<R0>` is constrained to be some subregion of the\n-    /// block B and some superregion of the call. If we forced it now, we'd choose the smaller\n-    /// region (the call). But that would make the *b illegal. Since we don't resolve, the type\n-    /// of b will be `&<R0>.i32` and then `*b` will require that `<R0>` be bigger than the let and\n-    /// the `*b` expression, so we will effectively resolve `<R0>` to be the block B.\n-    pub fn resolve_type(&self, unresolved_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.resolve_vars_if_possible(unresolved_ty)\n-    }\n-\n-    /// Try to resolve the type for the given node.\n-    fn resolve_node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n-        let t = self.node_ty(id);\n-        self.resolve_type(t)\n-    }\n-\n-    /// This is the \"main\" function when region-checking a function item or a\n-    /// closure within a function item. It begins by updating various fields\n-    /// (e.g., `outlives_environment`) to be appropriate to the function and\n-    /// then adds constraints derived from the function body.\n-    ///\n-    /// Note that it does **not** restore the state of the fields that\n-    /// it updates! This is intentional, since -- for the main\n-    /// function -- we wish to be able to read the final\n-    /// `outlives_environment` and other fields from the caller. For\n-    /// closures, however, we save and restore any \"scoped state\"\n-    /// before we invoke this function. (See `visit_fn` in the\n-    /// `intravisit::Visitor` impl below.)\n-    fn visit_fn_body(\n-        &mut self,\n-        id: hir::HirId, // the id of the fn itself\n-        body: &'tcx hir::Body<'tcx>,\n-    ) {\n-        // When we enter a function, we can derive\n-        debug!(\"visit_fn_body(id={:?})\", id);\n-        let body_id = body.id();\n-        self.body_owner = self.tcx.hir().body_owner_def_id(body_id);\n-\n-        let Some(fn_sig) = self.typeck_results.borrow().liberated_fn_sigs().get(id) else {\n-            bug!(\"No fn-sig entry for id={:?}\", id);\n-        };\n-\n-        // Collect the types from which we create inferred bounds.\n-        // For the return type, if diverging, substitute `bool` just\n-        // because it will have no effect.\n-        //\n-        // FIXME(#27579) return types should not be implied bounds\n-        let fn_sig_tys: FxHashSet<_> =\n-            fn_sig.inputs().iter().cloned().chain(Some(fn_sig.output())).collect();\n-\n-        self.outlives_environment.add_implied_bounds(self.fcx, fn_sig_tys, body_id.hir_id);\n-        self.outlives_environment.save_implied_bounds(body_id.hir_id);\n-        self.link_fn_params(body.params);\n-        self.visit_body(body);\n-        self.visit_region_obligations(body_id.hir_id);\n-    }\n-\n-    fn visit_inline_const(&mut self, id: hir::HirId, body: &'tcx hir::Body<'tcx>) {\n-        debug!(\"visit_inline_const(id={:?})\", id);\n-\n-        // Save state of current function. We will restore afterwards.\n-        let old_body_owner = self.body_owner;\n-        let env_snapshot = self.outlives_environment.push_snapshot_pre_typeck_child();\n-\n-        let body_id = body.id();\n-        self.body_owner = self.tcx.hir().body_owner_def_id(body_id);\n-\n-        self.outlives_environment.save_implied_bounds(body_id.hir_id);\n-\n-        self.visit_body(body);\n-        self.visit_region_obligations(body_id.hir_id);\n-\n-        // Restore state from previous function.\n-        self.outlives_environment.pop_snapshot_post_typeck_child(env_snapshot);\n-        self.body_owner = old_body_owner;\n-    }\n-\n-    fn visit_region_obligations(&mut self, hir_id: hir::HirId) {\n-        debug!(\"visit_region_obligations: hir_id={:?}\", hir_id);\n-\n-        // region checking can introduce new pending obligations\n-        // which, when processed, might generate new region\n-        // obligations. So make sure we process those.\n-        self.select_all_obligations_or_error();\n-    }\n-\n-    fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat<'_>) {\n-        debug!(\"regionck::visit_pat(pat={:?})\", pat);\n-        pat.each_binding(|_, hir_id, span, _| {\n-            let typ = self.resolve_node_type(hir_id);\n-            let body_id = self.body_id;\n-            dropck::check_drop_obligations(self, typ, span, body_id);\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n-    // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n-    // However, right now we run into an issue whereby some free\n-    // regions are not properly related if they appear within the\n-    // types of arguments that must be inferred. This could be\n-    // addressed by deferring the construction of the region\n-    // hierarchy, and in particular the relationships between free\n-    // regions, until regionck, as described in #3238.\n-\n-    fn visit_fn(\n-        &mut self,\n-        fk: intravisit::FnKind<'tcx>,\n-        _: &'tcx hir::FnDecl<'tcx>,\n-        body_id: hir::BodyId,\n-        _span: Span,\n-        hir_id: hir::HirId,\n-    ) {\n-        assert!(\n-            matches!(fk, intravisit::FnKind::Closure),\n-            \"visit_fn invoked for something other than a closure\"\n-        );\n-\n-        // Save state of current function before invoking\n-        // `visit_fn_body`.  We will restore afterwards.\n-        let old_body_owner = self.body_owner;\n-        let env_snapshot = self.outlives_environment.push_snapshot_pre_typeck_child();\n-\n-        let body = self.tcx.hir().body(body_id);\n-        self.visit_fn_body(hir_id, body);\n-\n-        // Restore state from previous function.\n-        self.outlives_environment.pop_snapshot_post_typeck_child(env_snapshot);\n-        self.body_owner = old_body_owner;\n-    }\n-\n-    //visit_pat: visit_pat, // (..) see above\n-\n-    fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n-        // see above\n-        self.constrain_bindings_in_pat(arm.pat);\n-        intravisit::walk_arm(self, arm);\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        // see above\n-        self.constrain_bindings_in_pat(l.pat);\n-        self.link_local(l);\n-        intravisit::walk_local(self, l);\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n-        // Check any autoderefs or autorefs that appear.\n-        let cmt_result = self.constrain_adjustments(expr);\n-\n-        // If necessary, constrain destructors in this expression. This will be\n-        // the adjusted form if there is an adjustment.\n-        match cmt_result {\n-            Ok(head_cmt) => {\n-                self.check_safety_of_rvalue_destructor_if_necessary(&head_cmt, expr.span);\n-            }\n-            Err(..) => {\n-                self.tcx.sess.delay_span_bug(expr.span, \"cat_expr Errd\");\n-            }\n-        }\n-\n-        match expr.kind {\n-            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref base) => {\n-                self.link_addr_of(expr, m, base);\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::Match(ref discr, arms, _) => {\n-                self.link_match(discr, arms);\n-\n-                intravisit::walk_expr(self, expr);\n-            }\n-\n-            hir::ExprKind::ConstBlock(anon_const) => {\n-                let body = self.tcx.hir().body(anon_const.body);\n-                self.visit_inline_const(anon_const.hir_id, body);\n-            }\n-\n-            _ => intravisit::walk_expr(self, expr),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n-    /// Creates a temporary `MemCategorizationContext` and pass it to the closure.\n-    fn with_mc<F, R>(&self, f: F) -> R\n-    where\n-        F: for<'b> FnOnce(mc::MemCategorizationContext<'b, 'tcx>) -> R,\n-    {\n-        f(mc::MemCategorizationContext::new(\n-            &self.infcx,\n-            self.outlives_environment.param_env,\n-            self.body_owner,\n-            &self.typeck_results.borrow(),\n-        ))\n-    }\n-\n-    /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n-    /// dereferenced, the lifetime of the pointer includes the deref expr.\n-    fn constrain_adjustments(\n-        &mut self,\n-        expr: &hir::Expr<'_>,\n-    ) -> mc::McResult<PlaceWithHirId<'tcx>> {\n-        debug!(\"constrain_adjustments(expr={:?})\", expr);\n-\n-        let mut place = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n-\n-        let typeck_results = self.typeck_results.borrow();\n-        let adjustments = typeck_results.expr_adjustments(expr);\n-        if adjustments.is_empty() {\n-            return Ok(place);\n-        }\n-\n-        debug!(\"constrain_adjustments: adjustments={:?}\", adjustments);\n-\n-        // If necessary, constrain destructors in the unadjusted form of this\n-        // expression.\n-        self.check_safety_of_rvalue_destructor_if_necessary(&place, expr.span);\n-\n-        for adjustment in adjustments {\n-            debug!(\"constrain_adjustments: adjustment={:?}, place={:?}\", adjustment, place);\n-\n-            if let adjustment::Adjust::Deref(Some(deref)) = adjustment.kind {\n-                self.link_region(\n-                    expr.span,\n-                    deref.region,\n-                    ty::BorrowKind::from_mutbl(deref.mutbl),\n-                    &place,\n-                );\n-            }\n-\n-            if let adjustment::Adjust::Borrow(ref autoref) = adjustment.kind {\n-                self.link_autoref(expr, &place, autoref);\n-            }\n-\n-            place = self.with_mc(|mc| mc.cat_expr_adjusted(expr, place, adjustment))?;\n-        }\n-\n-        Ok(place)\n-    }\n-\n-    fn check_safety_of_rvalue_destructor_if_necessary(\n-        &mut self,\n-        place_with_id: &PlaceWithHirId<'tcx>,\n-        span: Span,\n-    ) {\n-        if let PlaceBase::Rvalue = place_with_id.place.base {\n-            if place_with_id.place.projections.is_empty() {\n-                let typ = self.resolve_type(place_with_id.place.ty());\n-                let body_id = self.body_id;\n-                dropck::check_drop_obligations(self, typ, span, body_id);\n-            }\n-        }\n-    }\n-    /// Adds constraints to inference such that `T: 'a` holds (or\n-    /// reports an error if it cannot).\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `origin`, the reason we need this constraint\n-    /// - `ty`, the type `T`\n-    /// - `region`, the region `'a`\n-    pub fn type_must_outlive(\n-        &self,\n-        origin: infer::SubregionOrigin<'tcx>,\n-        ty: Ty<'tcx>,\n-        region: ty::Region<'tcx>,\n-    ) {\n-        self.infcx.register_region_obligation(\n-            self.body_id,\n-            RegionObligation { sub_region: region, sup_type: ty, origin },\n-        );\n-    }\n-\n-    /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the\n-    /// resulting pointer is linked to the lifetime of its guarantor (if any).\n-    fn link_addr_of(\n-        &mut self,\n-        expr: &hir::Expr<'_>,\n-        mutability: hir::Mutability,\n-        base: &hir::Expr<'_>,\n-    ) {\n-        debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n-\n-        let cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(base)));\n-\n-        debug!(\"link_addr_of: cmt={:?}\", cmt);\n-\n-        self.link_region_from_node_type(expr.span, expr.hir_id, mutability, &cmt);\n-    }\n-\n-    /// Computes the guarantors for any ref bindings in a `let` and\n-    /// then ensures that the lifetime of the resulting pointer is\n-    /// linked to the lifetime of the initialization expression.\n-    fn link_local(&self, local: &hir::Local<'_>) {\n-        debug!(\"regionck::for_local()\");\n-        let init_expr = match local.init {\n-            None => {\n-                return;\n-            }\n-            Some(expr) => &*expr,\n-        };\n-        let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(init_expr)));\n-        self.link_pattern(discr_cmt, local.pat);\n-    }\n-\n-    /// Computes the guarantors for any ref bindings in a match and\n-    /// then ensures that the lifetime of the resulting pointer is\n-    /// linked to the lifetime of its guarantor (if any).\n-    fn link_match(&self, discr: &hir::Expr<'_>, arms: &[hir::Arm<'_>]) {\n-        debug!(\"regionck::for_match()\");\n-        let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(discr)));\n-        debug!(\"discr_cmt={:?}\", discr_cmt);\n-        for arm in arms {\n-            self.link_pattern(discr_cmt.clone(), arm.pat);\n-        }\n-    }\n-\n-    /// Computes the guarantors for any ref bindings in a match and\n-    /// then ensures that the lifetime of the resulting pointer is\n-    /// linked to the lifetime of its guarantor (if any).\n-    fn link_fn_params(&self, params: &[hir::Param<'_>]) {\n-        for param in params {\n-            let param_ty = self.node_ty(param.hir_id);\n-            let param_cmt =\n-                self.with_mc(|mc| mc.cat_rvalue(param.hir_id, param.pat.span, param_ty));\n-            debug!(\"param_ty={:?} param_cmt={:?} param={:?}\", param_ty, param_cmt, param);\n-            self.link_pattern(param_cmt, param.pat);\n-        }\n-    }\n-\n-    /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n-    /// in the discriminant, if needed.\n-    fn link_pattern(&self, discr_cmt: PlaceWithHirId<'tcx>, root_pat: &hir::Pat<'_>) {\n-        debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\", discr_cmt, root_pat);\n-        ignore_err!(self.with_mc(|mc| {\n-            mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, hir::Pat { kind, span, hir_id, .. }| {\n-                // `ref x` pattern\n-                if let PatKind::Binding(..) = kind\n-                    && let Some(ty::BindByReference(mutbl)) = mc.typeck_results.extract_binding_mode(self.tcx.sess, *hir_id, *span) {\n-                    self.link_region_from_node_type(*span, *hir_id, mutbl, sub_cmt);\n-                }\n-            })\n-        }));\n-    }\n-\n-    /// Link lifetime of borrowed pointer resulting from autoref to lifetimes in the value being\n-    /// autoref'd.\n-    fn link_autoref(\n-        &self,\n-        expr: &hir::Expr<'_>,\n-        expr_cmt: &PlaceWithHirId<'tcx>,\n-        autoref: &adjustment::AutoBorrow<'tcx>,\n-    ) {\n-        debug!(\"link_autoref(autoref={:?}, expr_cmt={:?})\", autoref, expr_cmt);\n-\n-        match *autoref {\n-            adjustment::AutoBorrow::Ref(r, m) => {\n-                self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m.into()), expr_cmt);\n-            }\n-\n-            adjustment::AutoBorrow::RawPtr(_) => {}\n-        }\n-    }\n-\n-    /// Like `link_region()`, except that the region is extracted from the type of `id`,\n-    /// which must be some reference (`&T`, `&str`, etc).\n-    fn link_region_from_node_type(\n-        &self,\n-        span: Span,\n-        id: hir::HirId,\n-        mutbl: hir::Mutability,\n-        cmt_borrowed: &PlaceWithHirId<'tcx>,\n-    ) {\n-        debug!(\n-            \"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n-            id, mutbl, cmt_borrowed\n-        );\n-\n-        let rptr_ty = self.resolve_node_type(id);\n-        if let ty::Ref(r, _, _) = rptr_ty.kind() {\n-            debug!(\"rptr_ty={}\", rptr_ty);\n-            self.link_region(span, *r, ty::BorrowKind::from_mutbl(mutbl), cmt_borrowed);\n-        }\n-    }\n-\n-    /// Informs the inference engine that `borrow_cmt` is being borrowed with\n-    /// kind `borrow_kind` and lifetime `borrow_region`.\n-    /// In order to ensure borrowck is satisfied, this may create constraints\n-    /// between regions, as explained in `link_reborrowed_region()`.\n-    fn link_region(\n-        &self,\n-        span: Span,\n-        borrow_region: ty::Region<'tcx>,\n-        borrow_kind: ty::BorrowKind,\n-        borrow_place: &PlaceWithHirId<'tcx>,\n-    ) {\n-        let origin = infer::DataBorrowed(borrow_place.place.ty(), span);\n-        self.type_must_outlive(origin, borrow_place.place.ty(), borrow_region);\n-\n-        for pointer_ty in borrow_place.place.deref_tys() {\n-            debug!(\n-                \"link_region(borrow_region={:?}, borrow_kind={:?}, pointer_ty={:?})\",\n-                borrow_region, borrow_kind, borrow_place\n-            );\n-            match *pointer_ty.kind() {\n-                ty::RawPtr(_) => return,\n-                ty::Ref(ref_region, _, ref_mutability) => {\n-                    if self.link_reborrowed_region(span, borrow_region, ref_region, ref_mutability)\n-                    {\n-                        return;\n-                    }\n-                }\n-                _ => assert!(pointer_ty.is_box(), \"unexpected built-in deref type {}\", pointer_ty),\n-            }\n-        }\n-        if let PlaceBase::Upvar(upvar_id) = borrow_place.place.base {\n-            self.link_upvar_region(span, borrow_region, upvar_id);\n-        }\n-    }\n-\n-    /// This is the most complicated case: the path being borrowed is\n-    /// itself the referent of a borrowed pointer. Let me give an\n-    /// example fragment of code to make clear(er) the situation:\n-    ///\n-    /// ```ignore (incomplete Rust code)\n-    /// let r: &'a mut T = ...;  // the original reference \"r\" has lifetime 'a\n-    /// ...\n-    /// &'z *r                   // the reborrow has lifetime 'z\n-    /// ```\n-    ///\n-    /// Now, in this case, our primary job is to add the inference\n-    /// constraint that `'z <= 'a`. Given this setup, let's clarify the\n-    /// parameters in (roughly) terms of the example:\n-    ///\n-    /// ```plain,ignore (pseudo-Rust)\n-    /// A borrow of: `& 'z bk * r` where `r` has type `& 'a bk T`\n-    /// borrow_region   ^~                 ref_region    ^~\n-    /// borrow_kind        ^~               ref_kind        ^~\n-    /// ref_cmt                 ^\n-    /// ```\n-    ///\n-    /// Here `bk` stands for some borrow-kind (e.g., `mut`, `uniq`, etc).\n-    ///\n-    /// There is a complication beyond the simple scenario I just painted: there\n-    /// may in fact be more levels of reborrowing. In the example, I said the\n-    /// borrow was like `&'z *r`, but it might in fact be a borrow like\n-    /// `&'z **q` where `q` has type `&'a &'b mut T`. In that case, we want to\n-    /// ensure that `'z <= 'a` and `'z <= 'b`.\n-    ///\n-    /// The return value of this function indicates whether we *don't* need to\n-    /// the recurse to the next reference up.\n-    ///\n-    /// This is explained more below.\n-    fn link_reborrowed_region(\n-        &self,\n-        span: Span,\n-        borrow_region: ty::Region<'tcx>,\n-        ref_region: ty::Region<'tcx>,\n-        ref_mutability: hir::Mutability,\n-    ) -> bool {\n-        debug!(\"link_reborrowed_region: {:?} <= {:?}\", borrow_region, ref_region);\n-        self.sub_regions(infer::Reborrow(span), borrow_region, ref_region);\n-\n-        // Decide whether we need to recurse and link any regions within\n-        // the `ref_cmt`. This is concerned for the case where the value\n-        // being reborrowed is in fact a borrowed pointer found within\n-        // another borrowed pointer. For example:\n-        //\n-        //    let p: &'b &'a mut T = ...;\n-        //    ...\n-        //    &'z **p\n-        //\n-        // What makes this case particularly tricky is that, if the data\n-        // being borrowed is a `&mut` or `&uniq` borrow, borrowck requires\n-        // not only that `'z <= 'a`, (as before) but also `'z <= 'b`\n-        // (otherwise the user might mutate through the `&mut T` reference\n-        // after `'b` expires and invalidate the borrow we are looking at\n-        // now).\n-        //\n-        // So let's re-examine our parameters in light of this more\n-        // complicated (possible) scenario:\n-        //\n-        //     A borrow of: `& 'z bk * * p` where `p` has type `&'b bk & 'a bk T`\n-        //     borrow_region   ^~                 ref_region             ^~\n-        //     borrow_kind        ^~               ref_kind                 ^~\n-        //     ref_cmt                 ^~~\n-        //\n-        // (Note that since we have not examined `ref_cmt.cat`, we don't\n-        // know whether this scenario has occurred; but I wanted to show\n-        // how all the types get adjusted.)\n-        match ref_mutability {\n-            hir::Mutability::Not => {\n-                // The reference being reborrowed is a shareable ref of\n-                // type `&'a T`. In this case, it doesn't matter where we\n-                // *found* the `&T` pointer, the memory it references will\n-                // be valid and immutable for `'a`. So we can stop here.\n-                true\n-            }\n-\n-            hir::Mutability::Mut => {\n-                // The reference being reborrowed is either an `&mut T`. This is\n-                // the case where recursion is needed.\n-                false\n-            }\n-        }\n-    }\n-\n-    /// An upvar may be behind up to 2 references:\n-    ///\n-    /// * One can come from the reference to a \"by-reference\" upvar.\n-    /// * Another one can come from the reference to the closure itself if it's\n-    ///   a `FnMut` or `Fn` closure.\n-    ///\n-    /// This function links the lifetimes of those references to the lifetime\n-    /// of the borrow that's provided. See [RegionCtxt::link_reborrowed_region] for some\n-    /// more explanation of this in the general case.\n-    ///\n-    /// We also supply a *cause*, and in this case we set the cause to\n-    /// indicate that the reference being \"reborrowed\" is itself an upvar. This\n-    /// provides a nicer error message should something go wrong.\n-    fn link_upvar_region(\n-        &self,\n-        span: Span,\n-        borrow_region: ty::Region<'tcx>,\n-        upvar_id: ty::UpvarId,\n-    ) {\n-        debug!(\"link_upvar_region(borrorw_region={:?}, upvar_id={:?}\", borrow_region, upvar_id);\n-        // A by-reference upvar can't be borrowed for longer than the\n-        // upvar is borrowed from the environment.\n-        let closure_local_def_id = upvar_id.closure_expr_id;\n-        let mut all_captures_are_imm_borrow = true;\n-        for captured_place in self\n-            .typeck_results\n-            .borrow()\n-            .closure_min_captures\n-            .get(&closure_local_def_id.to_def_id())\n-            .and_then(|root_var_min_cap| root_var_min_cap.get(&upvar_id.var_path.hir_id))\n-            .into_iter()\n-            .flatten()\n-        {\n-            match captured_place.info.capture_kind {\n-                ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                    self.sub_regions(\n-                        infer::ReborrowUpvar(span, upvar_id),\n-                        borrow_region,\n-                        captured_place.region.unwrap(),\n-                    );\n-                    if let ty::ImmBorrow = upvar_borrow {\n-                        debug!(\"link_upvar_region: capture by shared ref\");\n-                    } else {\n-                        all_captures_are_imm_borrow = false;\n-                    }\n-                }\n-                ty::UpvarCapture::ByValue => {\n-                    all_captures_are_imm_borrow = false;\n-                }\n-            }\n-        }\n-        if all_captures_are_imm_borrow {\n-            return;\n-        }\n-        let fn_hir_id = self.tcx.hir().local_def_id_to_hir_id(closure_local_def_id);\n-        let ty = self.resolve_node_type(fn_hir_id);\n-        debug!(\"link_upvar_region: ty={:?}\", ty);\n-\n-        // A closure capture can't be borrowed for longer than the\n-        // reference to the closure.\n-        if let ty::Closure(_, substs) = ty.kind() {\n-            match self.infcx.closure_kind(substs) {\n-                Some(ty::ClosureKind::Fn | ty::ClosureKind::FnMut) => {\n-                    // Region of environment pointer\n-                    let env_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                        scope: upvar_id.closure_expr_id.to_def_id(),\n-                        bound_region: ty::BrEnv,\n-                    }));\n-                    self.sub_regions(\n-                        infer::ReborrowUpvar(span, upvar_id),\n-                        borrow_region,\n-                        env_region,\n-                    );\n-                }\n-                Some(ty::ClosureKind::FnOnce) => {}\n-                None => {\n-                    span_bug!(span, \"Have not inferred closure kind before regionck\");\n-                }\n-            }\n-        }\n-    }\n-}"}]}