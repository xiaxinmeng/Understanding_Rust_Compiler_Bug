{"sha": "4cfb885da7090678ebce1dde972e7df612ef03e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZmI4ODVkYTcwOTA2NzhlYmNlMWRkZTk3MmU3ZGY2MTJlZjAzZTU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-02-21T09:13:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-21T09:13:37Z"}, "message": "Merge pull request #1140 from bjorn3/no_more_oldbe\n\nRemove support for the old x86 Cranelift backend", "tree": {"sha": "13d2a9ea28393ce2a8aa2487d90ee65246d6b4a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13d2a9ea28393ce2a8aa2487d90ee65246d6b4a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cfb885da7090678ebce1dde972e7df612ef03e5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgMiRBCRBK7hj4Ov3rIwAAdHIIAJF052tRPNP/fe47qemZAeg0\nePMyevFBvzoDpupw2B6c3Y1T1CWY9XbgLlsoEeG3sj357+OfSbTmc9G/y12fqciK\n/UQ+u0ueXHXMyNjYIvYQo2QRG89No+s1FdxHSAsDe1l9R92HeeNsLebBR2Td8a1S\nYYzAMv+Of0UmyWkNHrSUfwPZ+bXrONAGKgXIwpcfeB0XKhJtn7gNi7e3ZGriefBP\nT9WVQipZC3iSb/QjA2NoaEwVKHCoaCwELKm9VfnS0kmpoQvwjj1s4dkGrolqdzKz\n8usRjN0W53fm6U/oTAv5xrzBd8RH0MHMPCvvCy/caWw/3nVXstfjPGyMYST8c4Q=\n=ygvZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 13d2a9ea28393ce2a8aa2487d90ee65246d6b4a7\nparent 92c1b858ef7855fea75162499fff93d3d04144f1\nparent 537db9a1ef2ad5f195378c7f64676b147f56f57a\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1613898817 +0100\ncommitter GitHub <noreply@github.com> 1613898817 +0100\n\nMerge pull request #1140 from bjorn3/no_more_oldbe\n\nRemove support for the old x86 Cranelift backend"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cfb885da7090678ebce1dde972e7df612ef03e5", "html_url": "https://github.com/rust-lang/rust/commit/4cfb885da7090678ebce1dde972e7df612ef03e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cfb885da7090678ebce1dde972e7df612ef03e5/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92c1b858ef7855fea75162499fff93d3d04144f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/92c1b858ef7855fea75162499fff93d3d04144f1", "html_url": "https://github.com/rust-lang/rust/commit/92c1b858ef7855fea75162499fff93d3d04144f1"}, {"sha": "537db9a1ef2ad5f195378c7f64676b147f56f57a", "url": "https://api.github.com/repos/rust-lang/rust/commits/537db9a1ef2ad5f195378c7f64676b147f56f57a", "html_url": "https://github.com/rust-lang/rust/commit/537db9a1ef2ad5f195378c7f64676b147f56f57a"}], "stats": {"total": 827, "additions": 327, "deletions": 500}, "files": [{"sha": "e6d3375fb1bab6240d6d309259aa84657547a559", "filename": ".github/workflows/main.yml", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fmain.yml?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -12,9 +12,6 @@ jobs:\n       fail-fast: false\n       matrix:\n         os: [ubuntu-latest, macos-latest]\n-        env:\n-          - BACKEND: \"\"\n-          - BACKEND: --oldbe\n \n     steps:\n     - uses: actions/checkout@v2\n@@ -54,7 +51,7 @@ jobs:\n         export COMPILE_RUNS=2\n         export RUN_RUNS=2\n \n-        ./test.sh $BACKEND\n+        ./test.sh\n \n     - name: Package prebuilt cg_clif\n       run: tar cvfJ cg_clif.tar.xz build"}, {"sha": "90b5fcfb3ec108061280330bf095d95587577699", "filename": "Cargo.lock", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -37,16 +37,16 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#5b55ba80537de25d15b66ac04914ddc170d33eec\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#c07ec4c525318afb47b2c6ff24dcddb5d23b5f2a\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#5b55ba80537de25d15b66ac04914ddc170d33eec\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#c07ec4c525318afb47b2c6ff24dcddb5d23b5f2a\"\n dependencies = [\n  \"byteorder\",\n  \"cranelift-bforest\",\n@@ -63,27 +63,27 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#5b55ba80537de25d15b66ac04914ddc170d33eec\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#c07ec4c525318afb47b2c6ff24dcddb5d23b5f2a\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#5b55ba80537de25d15b66ac04914ddc170d33eec\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#c07ec4c525318afb47b2c6ff24dcddb5d23b5f2a\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#5b55ba80537de25d15b66ac04914ddc170d33eec\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#c07ec4c525318afb47b2c6ff24dcddb5d23b5f2a\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#5b55ba80537de25d15b66ac04914ddc170d33eec\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#c07ec4c525318afb47b2c6ff24dcddb5d23b5f2a\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -93,8 +93,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#5b55ba80537de25d15b66ac04914ddc170d33eec\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#c07ec4c525318afb47b2c6ff24dcddb5d23b5f2a\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -111,8 +111,8 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#5b55ba80537de25d15b66ac04914ddc170d33eec\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#c07ec4c525318afb47b2c6ff24dcddb5d23b5f2a\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -123,17 +123,17 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#5b55ba80537de25d15b66ac04914ddc170d33eec\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#c07ec4c525318afb47b2c6ff24dcddb5d23b5f2a\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"target-lexicon\",\n ]\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.69.0\"\n-source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#5b55ba80537de25d15b66ac04914ddc170d33eec\"\n+version = \"0.70.0\"\n+source = \"git+https://github.com/bytecodealliance/wasmtime/?branch=main#c07ec4c525318afb47b2c6ff24dcddb5d23b5f2a\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\","}, {"sha": "9861af1f8eae2cfb384cbaee7ad709937835465a", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -9,7 +9,7 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\", \"x86\", \"x64\"] }\n+cranelift-codegen = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", features = [\"unwind\", \"x64\"] }\n cranelift-frontend = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-module = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\" }\n cranelift-jit = { git = \"https://github.com/bytecodealliance/wasmtime/\", branch = \"main\", optional = true }\n@@ -38,7 +38,6 @@ smallvec = \"1.6.1\"\n default = [\"jit\", \"inline_asm\"]\n jit = [\"cranelift-jit\", \"libloading\"]\n inline_asm = []\n-oldbe = []\n \n [profile.dev]\n # By compiling dependencies with optimizations, performing tests gets much faster."}, {"sha": "090349e54b1484a33856b7e18e39179318ef973c", "filename": "build.sh", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/build.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/build.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.sh?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -5,7 +5,6 @@ set -e\n export CHANNEL=\"release\"\n build_sysroot=\"clif\"\n target_dir='build'\n-oldbe=''\n while [[ $# != 0 ]]; do\n     case $1 in\n         \"--debug\")\n@@ -19,12 +18,9 @@ while [[ $# != 0 ]]; do\n             target_dir=$2\n             shift\n             ;;\n-        \"--oldbe\")\n-            oldbe='--features oldbe'\n-            ;;\n         *)\n             echo \"Unknown flag '$1'\"\n-            echo \"Usage: ./build.sh [--debug] [--sysroot none|clif|llvm] [--target-dir DIR] [--oldbe]\"\n+            echo \"Usage: ./build.sh [--debug] [--sysroot none|clif|llvm] [--target-dir DIR]\"\n             exit 1\n             ;;\n     esac\n@@ -44,9 +40,9 @@ else\n    exit 1\n fi\n if [[ \"$CHANNEL\" == \"release\" ]]; then\n-    cargo build $oldbe --release\n+    cargo build --release\n else\n-    cargo build $oldbe\n+    cargo build\n fi\n \n source scripts/ext_config.sh"}, {"sha": "c90205db0fbd067af3c33691164486277ddc1b56", "filename": "build_sysroot/prepare_sysroot_src.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/build_sysroot%2Fprepare_sysroot_src.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/build_sysroot%2Fprepare_sysroot_src.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2Fprepare_sysroot_src.sh?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -33,7 +33,7 @@ git clone https://github.com/rust-lang/compiler-builtins.git || echo \"rust-lang/\n pushd compiler-builtins\n git checkout -- .\n git checkout 0.1.39\n-git apply ../../crate_patches/0001-compiler-builtins-Remove-rotate_left-from-Int.patch\n+git apply ../../crate_patches/000*-compiler-builtins-*.patch\n popd\n \n echo \"Successfully prepared sysroot source for building\""}, {"sha": "7daea99f5794d2103588c152a0ac02ca1b5b14b1", "filename": "crate_patches/0002-compiler-builtins-Disable-128bit-atomic-operations.patch", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/crate_patches%2F0002-compiler-builtins-Disable-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/crate_patches%2F0002-compiler-builtins-Disable-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crate_patches%2F0002-compiler-builtins-Disable-128bit-atomic-operations.patch?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -0,0 +1,48 @@\n+From 1d574bf5e32d51641dcacaf8ef777e95b44f6f2a Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 18 Feb 2021 18:30:55 +0100\n+Subject: [PATCH] Disable 128bit atomic operations\n+\n+Cranelift doesn't support them yet\n+---\n+ src/mem/mod.rs | 12 ------------\n+ 1 file changed, 12 deletions(-)\n+\n+diff --git a/src/mem/mod.rs b/src/mem/mod.rs\n+index 107762c..2d1ae10 100644\n+--- a/src/mem/mod.rs\n++++ b/src/mem/mod.rs\n+@@ -137,10 +137,6 @@ intrinsics! {\n+     pub extern \"C\" fn __llvm_memcpy_element_unordered_atomic_8(dest: *mut u64, src: *const u64, bytes: usize) -> () {\n+         memcpy_element_unordered_atomic(dest, src, bytes);\n+     }\n+-    #[cfg(target_has_atomic_load_store = \"128\")]\n+-    pub extern \"C\" fn __llvm_memcpy_element_unordered_atomic_16(dest: *mut u128, src: *const u128, bytes: usize) -> () {\n+-        memcpy_element_unordered_atomic(dest, src, bytes);\n+-    }\n+ \n+     #[cfg(target_has_atomic_load_store = \"8\")]\n+     pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_1(dest: *mut u8, src: *const u8, bytes: usize) -> () {\n+@@ -158,10 +154,6 @@ intrinsics! {\n+     pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_8(dest: *mut u64, src: *const u64, bytes: usize) -> () {\n+         memmove_element_unordered_atomic(dest, src, bytes);\n+     }\n+-    #[cfg(target_has_atomic_load_store = \"128\")]\n+-    pub extern \"C\" fn __llvm_memmove_element_unordered_atomic_16(dest: *mut u128, src: *const u128, bytes: usize) -> () {\n+-        memmove_element_unordered_atomic(dest, src, bytes);\n+-    }\n+ \n+     #[cfg(target_has_atomic_load_store = \"8\")]\n+     pub extern \"C\" fn __llvm_memset_element_unordered_atomic_1(s: *mut u8, c: u8, bytes: usize) -> () {\n+@@ -179,8 +171,4 @@ intrinsics! {\n+     pub extern \"C\" fn __llvm_memset_element_unordered_atomic_8(s: *mut u64, c: u8, bytes: usize) -> () {\n+         memset_element_unordered_atomic(s, c, bytes);\n+     }\n+-    #[cfg(target_has_atomic_load_store = \"128\")]\n+-    pub extern \"C\" fn __llvm_memset_element_unordered_atomic_16(s: *mut u128, c: u8, bytes: usize) -> () {\n+-        memset_element_unordered_atomic(s, c, bytes);\n+-    }\n+ }\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "054299e8aab289efed7696bb9e9b24817803ec57", "filename": "patches/0027-Disable-128bit-atomic-operations.patch", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/patches%2F0027-Disable-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/patches%2F0027-Disable-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0027-Disable-128bit-atomic-operations.patch?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -0,0 +1,103 @@\n+From 894e07dfec2624ba539129b1c1d63e1d7d812bda Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 18 Feb 2021 18:45:28 +0100\n+Subject: [PATCH] Disable 128bit atomic operations\n+\n+Cranelift doesn't support them yet\n+---\n+ library/core/src/sync/atomic.rs | 38 ---------------------------------\n+ library/core/tests/atomic.rs    |  4 ----\n+ library/std/src/panic.rs        |  6 ------\n+ 3 files changed, 48 deletions(-)\n+\n+diff --git a/library/core/src/sync/atomic.rs b/library/core/src/sync/atomic.rs\n+index 81c9e1d..65c9503 100644\n+--- a/library/core/src/sync/atomic.rs\n++++ b/library/core/src/sync/atomic.rs\n+@@ -2228,44 +2228,6 @@ atomic_int! {\n+     \"AtomicU64::new(0)\",\n+     u64 AtomicU64 ATOMIC_U64_INIT\n+ }\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-atomic_int! {\n+-    cfg(target_has_atomic = \"128\"),\n+-    cfg(target_has_atomic_equal_alignment = \"128\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    \"i128\", \"../../../std/primitive.i128.html\",\n+-    \"#![feature(integer_atomics)]\\n\\n\",\n+-    atomic_min, atomic_max,\n+-    16,\n+-    \"AtomicI128::new(0)\",\n+-    i128 AtomicI128 ATOMIC_I128_INIT\n+-}\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-atomic_int! {\n+-    cfg(target_has_atomic = \"128\"),\n+-    cfg(target_has_atomic_equal_alignment = \"128\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    rustc_const_stable(feature = \"const_integer_atomics\", since = \"1.34.0\"),\n+-    unstable(feature = \"integer_atomics\", issue = \"32976\"),\n+-    \"u128\", \"../../../std/primitive.u128.html\",\n+-    \"#![feature(integer_atomics)]\\n\\n\",\n+-    atomic_umin, atomic_umax,\n+-    16,\n+-    \"AtomicU128::new(0)\",\n+-    u128 AtomicU128 ATOMIC_U128_INIT\n+-}\n+ \n+ macro_rules! atomic_int_ptr_sized {\n+     ( $($target_pointer_width:literal $align:literal)* ) => { $(\n+diff --git a/library/core/tests/atomic.rs b/library/core/tests/atomic.rs\n+index 2d1e449..cb6da5d 100644\n+--- a/library/core/tests/atomic.rs\n++++ b/library/core/tests/atomic.rs\n+@@ -145,10 +145,6 @@ fn atomic_alignment() {\n+     assert_eq!(align_of::<AtomicU64>(), size_of::<AtomicU64>());\n+     #[cfg(target_has_atomic = \"64\")]\n+     assert_eq!(align_of::<AtomicI64>(), size_of::<AtomicI64>());\n+-    #[cfg(target_has_atomic = \"128\")]\n+-    assert_eq!(align_of::<AtomicU128>(), size_of::<AtomicU128>());\n+-    #[cfg(target_has_atomic = \"128\")]\n+-    assert_eq!(align_of::<AtomicI128>(), size_of::<AtomicI128>());\n+     #[cfg(target_has_atomic = \"ptr\")]\n+     assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n+     #[cfg(target_has_atomic = \"ptr\")]\n+diff --git a/library/std/src/panic.rs b/library/std/src/panic.rs\n+index 89a822a..779fd88 100644\n+--- a/library/std/src/panic.rs\n++++ b/library/std/src/panic.rs\n+@@ -279,9 +279,6 @@ impl RefUnwindSafe for atomic::AtomicI32 {}\n+ #[cfg(target_has_atomic_load_store = \"64\")]\n+ #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+ impl RefUnwindSafe for atomic::AtomicI64 {}\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+-impl RefUnwindSafe for atomic::AtomicI128 {}\n+ \n+ #[cfg(target_has_atomic_load_store = \"ptr\")]\n+ #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+@@ -298,9 +295,6 @@ impl RefUnwindSafe for atomic::AtomicU32 {}\n+ #[cfg(target_has_atomic_load_store = \"64\")]\n+ #[stable(feature = \"integer_atomics_stable\", since = \"1.34.0\")]\n+ impl RefUnwindSafe for atomic::AtomicU64 {}\n+-#[cfg(target_has_atomic_load_store = \"128\")]\n+-#[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n+-impl RefUnwindSafe for atomic::AtomicU128 {}\n+ \n+ #[cfg(target_has_atomic_load_store = \"8\")]\n+ #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n+-- \n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "c2ed2bf256d5980a188421ba69b229777e2c8d16", "filename": "scripts/config.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/scripts%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/scripts%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Fconfig.sh?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -26,7 +26,7 @@ export RUSTC=$dir\"/bin/cg_clif\"\n export RUSTDOCFLAGS=$linker' -Cpanic=abort -Zpanic-abort-tests '\\\n '-Zcodegen-backend='$dir'/lib/librustc_codegen_cranelift.'$dylib_ext' --sysroot '$dir\n \n-# FIXME remove once the atomic shim is gone\n+# FIXME fix `#[linkage = \"extern_weak\"]` without this\n if [[ \"$unamestr\" == 'Darwin' ]]; then\n    export RUSTFLAGS=\"$RUSTFLAGS -Clink-arg=-undefined -Clink-arg=dynamic_lookup\"\n fi"}, {"sha": "674e6d907510a8510607cea2c747a66d17238c74", "filename": "src/atomic_shim.rs", "status": "removed", "additions": 0, "deletions": 185, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/92c1b858ef7855fea75162499fff93d3d04144f1/src%2Fatomic_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92c1b858ef7855fea75162499fff93d3d04144f1/src%2Fatomic_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fatomic_shim.rs?ref=92c1b858ef7855fea75162499fff93d3d04144f1", "patch": "@@ -1,185 +0,0 @@\n-//! Atomic intrinsics are implemented using a global lock for now, as Cranelift doesn't support\n-//! atomic operations yet.\n-\n-// FIXME implement atomic instructions in Cranelift.\n-\n-use crate::prelude::*;\n-\n-#[cfg(all(feature = \"jit\", unix))]\n-#[no_mangle]\n-static mut __cg_clif_global_atomic_mutex: libc::pthread_mutex_t = libc::PTHREAD_MUTEX_INITIALIZER;\n-\n-pub(crate) fn init_global_lock(\n-    module: &mut impl Module,\n-    bcx: &mut FunctionBuilder<'_>,\n-    use_jit: bool,\n-) {\n-    if use_jit {\n-        // When using JIT, dylibs won't find the __cg_clif_global_atomic_mutex data object defined here,\n-        // so instead we define it in the cg_clif dylib.\n-\n-        return;\n-    }\n-\n-    let mut data_ctx = DataContext::new();\n-    data_ctx.define_zeroinit(1024); // 1024 bytes should be big enough on all platforms.\n-    data_ctx.set_align(16);\n-    let atomic_mutex = module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Export,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-    module.define_data(atomic_mutex, &data_ctx).unwrap();\n-\n-    let pthread_mutex_init = module\n-        .declare_function(\n-            \"pthread_mutex_init\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: module.target_config().default_call_conv,\n-                params: vec![\n-                    AbiParam::new(\n-                        module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                    ),\n-                    AbiParam::new(\n-                        module.target_config().pointer_type(), /* *const pthread_mutex_attr_t */\n-                    ),\n-                ],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_init = module.declare_func_in_func(pthread_mutex_init, bcx.func);\n-\n-    let atomic_mutex = module.declare_data_in_func(atomic_mutex, bcx.func);\n-    let atomic_mutex = bcx\n-        .ins()\n-        .global_value(module.target_config().pointer_type(), atomic_mutex);\n-\n-    let nullptr = bcx.ins().iconst(module.target_config().pointer_type(), 0);\n-\n-    bcx.ins().call(pthread_mutex_init, &[atomic_mutex, nullptr]);\n-}\n-\n-pub(crate) fn init_global_lock_constructor(\n-    module: &mut impl Module,\n-    constructor_name: &str,\n-) -> FuncId {\n-    let sig = Signature::new(CallConv::SystemV);\n-    let init_func_id = module\n-        .declare_function(constructor_name, Linkage::Export, &sig)\n-        .unwrap();\n-\n-    let mut ctx = Context::new();\n-    ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n-    {\n-        let mut func_ctx = FunctionBuilderContext::new();\n-        let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n-\n-        let block = bcx.create_block();\n-        bcx.switch_to_block(block);\n-\n-        crate::atomic_shim::init_global_lock(module, &mut bcx, false);\n-\n-        bcx.ins().return_(&[]);\n-        bcx.seal_all_blocks();\n-        bcx.finalize();\n-    }\n-    module\n-        .define_function(\n-            init_func_id,\n-            &mut ctx,\n-            &mut cranelift_codegen::binemit::NullTrapSink {},\n-        )\n-        .unwrap();\n-\n-    init_func_id\n-}\n-\n-pub(crate) fn lock_global_lock(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    let atomic_mutex = fx\n-        .cx\n-        .module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Import,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_lock = fx\n-        .cx\n-        .module\n-        .declare_function(\n-            \"pthread_mutex_lock\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: fx.cx.module.target_config().default_call_conv,\n-                params: vec![AbiParam::new(\n-                    fx.cx.module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                )],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_lock = fx\n-        .cx\n-        .module\n-        .declare_func_in_func(pthread_mutex_lock, fx.bcx.func);\n-\n-    let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx\n-        .bcx\n-        .ins()\n-        .global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n-\n-    fx.bcx.ins().call(pthread_mutex_lock, &[atomic_mutex]);\n-}\n-\n-pub(crate) fn unlock_global_lock(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    let atomic_mutex = fx\n-        .cx\n-        .module\n-        .declare_data(\n-            \"__cg_clif_global_atomic_mutex\",\n-            Linkage::Import,\n-            true,\n-            false,\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_unlock = fx\n-        .cx\n-        .module\n-        .declare_function(\n-            \"pthread_mutex_unlock\",\n-            Linkage::Import,\n-            &cranelift_codegen::ir::Signature {\n-                call_conv: fx.cx.module.target_config().default_call_conv,\n-                params: vec![AbiParam::new(\n-                    fx.cx.module.target_config().pointer_type(), /* *mut pthread_mutex_t */\n-                )],\n-                returns: vec![AbiParam::new(types::I32 /* c_int */)],\n-            },\n-        )\n-        .unwrap();\n-\n-    let pthread_mutex_unlock = fx\n-        .cx\n-        .module\n-        .declare_func_in_func(pthread_mutex_unlock, fx.bcx.func);\n-\n-    let atomic_mutex = fx.cx.module.declare_data_in_func(atomic_mutex, fx.bcx.func);\n-    let atomic_mutex = fx\n-        .bcx\n-        .ins()\n-        .global_value(fx.cx.module.target_config().pointer_type(), atomic_mutex);\n-\n-    fx.bcx.ins().call(pthread_mutex_unlock, &[atomic_mutex]);\n-}"}, {"sha": "a5718244816d229f2d3dc6bddeba7ceb78c2bc31", "filename": "src/backend.rs", "status": "modified", "additions": 1, "deletions": 44, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbackend.rs?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -8,7 +8,7 @@ use rustc_session::Session;\n use cranelift_module::FuncId;\n \n use object::write::*;\n-use object::{RelocationEncoding, RelocationKind, SectionKind, SymbolFlags};\n+use object::{RelocationEncoding, SectionKind, SymbolFlags};\n \n use cranelift_object::{ObjectBuilder, ObjectModule, ObjectProduct};\n \n@@ -118,49 +118,6 @@ impl WriteDebugInfo for ObjectProduct {\n     }\n }\n \n-// FIXME remove once atomic instructions are implemented in Cranelift.\n-pub(crate) trait AddConstructor {\n-    fn add_constructor(&mut self, func_id: FuncId);\n-}\n-\n-impl AddConstructor for ObjectProduct {\n-    fn add_constructor(&mut self, func_id: FuncId) {\n-        let symbol = self.function_symbol(func_id);\n-        let segment = self\n-            .object\n-            .segment_name(object::write::StandardSegment::Data);\n-        let init_array_section =\n-            self.object\n-                .add_section(segment.to_vec(), b\".init_array\".to_vec(), SectionKind::Data);\n-        let address_size = self\n-            .object\n-            .architecture()\n-            .address_size()\n-            .expect(\"address_size must be known\")\n-            .bytes();\n-        self.object.append_section_data(\n-            init_array_section,\n-            &std::iter::repeat(0)\n-                .take(address_size.into())\n-                .collect::<Vec<u8>>(),\n-            8,\n-        );\n-        self.object\n-            .add_relocation(\n-                init_array_section,\n-                object::write::Relocation {\n-                    offset: 0,\n-                    size: address_size * 8,\n-                    kind: RelocationKind::Absolute,\n-                    encoding: RelocationEncoding::Generic,\n-                    symbol,\n-                    addend: 0,\n-                },\n-            )\n-            .unwrap();\n-    }\n-}\n-\n pub(crate) fn with_object(sess: &Session, name: &str, f: impl FnOnce(&mut Object)) -> Vec<u8> {\n     let triple = crate::build_isa(sess).triple().clone();\n "}, {"sha": "03889a4687f82f7373b390f1c06db95a61198b85", "filename": "src/base.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -149,14 +149,12 @@ pub(crate) fn codegen_fn<'tcx>(\n         &clif_comments,\n     );\n \n-    if let Some(mach_compile_result) = &context.mach_compile_result {\n-        if let Some(disasm) = &mach_compile_result.disasm {\n-            crate::pretty_clif::write_ir_file(\n-                tcx,\n-                &format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n-                |file| file.write_all(disasm.as_bytes()),\n-            )\n-        }\n+    if let Some(disasm) = &context.mach_compile_result.as_ref().unwrap().disasm {\n+        crate::pretty_clif::write_ir_file(\n+            tcx,\n+            &format!(\"{}.vcode\", tcx.symbol_name(instance).name),\n+            |file| file.write_all(disasm.as_bytes()),\n+        )\n     }\n \n     // Define debuginfo for function"}, {"sha": "a40f963400c664f643fddc2cc885215a649d215c", "filename": "src/debuginfo/line_info.rs", "status": "modified", "additions": 13, "deletions": 36, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fdebuginfo%2Fline_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fdebuginfo%2Fline_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fline_info.rs?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -129,7 +129,6 @@ impl<'tcx> DebugContext<'tcx> {\n \n     pub(super) fn create_debug_lines(\n         &mut self,\n-        isa: &dyn cranelift_codegen::isa::TargetIsa,\n         symbol: usize,\n         entry_id: UnitEntryId,\n         context: &Context,\n@@ -138,7 +137,6 @@ impl<'tcx> DebugContext<'tcx> {\n     ) -> CodeOffset {\n         let tcx = self.tcx;\n         let line_program = &mut self.dwarf.unit.line_program;\n-        let func = &context.func;\n \n         let line_strings = &mut self.dwarf.line_strings;\n         let mut last_span = None;\n@@ -202,43 +200,22 @@ impl<'tcx> DebugContext<'tcx> {\n \n         let mut func_end = 0;\n \n-        if let Some(ref mcr) = &context.mach_compile_result {\n-            for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n-                line_program.row().address_offset = u64::from(start);\n-                if !loc.is_default() {\n-                    let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n-                    create_row_for_span(line_program, source_info.span);\n-                } else {\n-                    create_row_for_span(line_program, function_span);\n-                }\n-                func_end = end;\n-            }\n-\n-            line_program.end_sequence(u64::from(func_end));\n-\n-            func_end = mcr.buffer.total_size();\n-        } else {\n-            let encinfo = isa.encoding_info();\n-            let mut blocks = func.layout.blocks().collect::<Vec<_>>();\n-            blocks.sort_by_key(|block| func.offsets[*block]); // Ensure inst offsets always increase\n-\n-            for block in blocks {\n-                for (offset, inst, size) in func.inst_offsets(block, &encinfo) {\n-                    let srcloc = func.srclocs[inst];\n-                    line_program.row().address_offset = u64::from(offset);\n-                    if !srcloc.is_default() {\n-                        let source_info =\n-                            *source_info_set.get_index(srcloc.bits() as usize).unwrap();\n-                        create_row_for_span(line_program, source_info.span);\n-                    } else {\n-                        create_row_for_span(line_program, function_span);\n-                    }\n-                    func_end = offset + size;\n-                }\n+        let mcr = context.mach_compile_result.as_ref().unwrap();\n+        for &MachSrcLoc { start, end, loc } in mcr.buffer.get_srclocs_sorted() {\n+            line_program.row().address_offset = u64::from(start);\n+            if !loc.is_default() {\n+                let source_info = *source_info_set.get_index(loc.bits() as usize).unwrap();\n+                create_row_for_span(line_program, source_info.span);\n+            } else {\n+                create_row_for_span(line_program, function_span);\n             }\n-            line_program.end_sequence(u64::from(func_end));\n+            func_end = end;\n         }\n \n+        line_program.end_sequence(u64::from(func_end));\n+\n+        let func_end = mcr.buffer.total_size();\n+\n         assert_ne!(func_end, 0);\n \n         let entry = self.dwarf.unit.get_mut(entry_id);"}, {"sha": "87b1c5fb50e6dd19efbcf2a64c104d6ceb592bb3", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -252,18 +252,13 @@ impl<'tcx> DebugContext<'tcx> {\n             AttributeValue::StringRef(name_id),\n         );\n \n-        let end =\n-            self.create_debug_lines(isa, symbol, entry_id, context, mir.span, source_info_set);\n+        let end = self.create_debug_lines(symbol, entry_id, context, mir.span, source_info_set);\n \n         self.unit_range_list.0.push(Range::StartLength {\n             begin: Address::Symbol { symbol, addend: 0 },\n             length: u64::from(end),\n         });\n \n-        if isa.get_mach_backend().is_some() {\n-            return; // Not yet implemented for the AArch64 backend.\n-        }\n-\n         let func_entry = self.dwarf.unit.get_mut(entry_id);\n         // Gdb requires both DW_AT_low_pc and DW_AT_high_pc. Otherwise the DW_TAG_subprogram is skipped.\n         func_entry.set("}, {"sha": "8085a04184b2bc6217ef61904efbd90979047cd0", "filename": "src/driver/aot.rs", "status": "modified", "additions": 3, "deletions": 39, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Faot.rs?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -12,12 +12,10 @@ use rustc_middle::mir::mono::{CodegenUnit, MonoItem};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{DebugInfo, OutputType};\n \n-use cranelift_object::{ObjectModule, ObjectProduct};\n+use cranelift_object::ObjectModule;\n \n use crate::{prelude::*, BackendConfig};\n \n-use crate::backend::AddConstructor;\n-\n fn new_module(tcx: TyCtxt<'_>, name: String) -> ObjectModule {\n     let module = crate::backend::make_module(tcx.sess, name);\n     assert_eq!(pointer_ty(tcx), module.target_config().pointer_type());\n@@ -39,7 +37,6 @@ fn emit_module(\n     module: ObjectModule,\n     debug: Option<DebugContext<'_>>,\n     unwind_context: UnwindContext<'_>,\n-    map_product: impl FnOnce(ObjectProduct) -> ObjectProduct,\n ) -> ModuleCodegenResult {\n     let mut product = module.finish();\n \n@@ -49,8 +46,6 @@ fn emit_module(\n \n     unwind_context.emit(&mut product);\n \n-    let product = map_product(product);\n-\n     let tmp_file = tcx\n         .output_filenames(LOCAL_CRATE)\n         .temp_path(OutputType::Object, Some(&name));\n@@ -124,30 +119,7 @@ fn module_codegen(\n     let cgu = tcx.codegen_unit(cgu_name);\n     let mono_items = cgu.items_in_deterministic_order(tcx);\n \n-    let mut module = new_module(tcx, cgu_name.as_str().to_string());\n-\n-    // Initialize the global atomic mutex using a constructor for proc-macros.\n-    // FIXME implement atomic instructions in Cranelift.\n-    let mut init_atomics_mutex_from_constructor = None;\n-    if tcx\n-        .sess\n-        .crate_types()\n-        .contains(&rustc_session::config::CrateType::ProcMacro)\n-    {\n-        if mono_items.iter().any(|(mono_item, _)| match mono_item {\n-            rustc_middle::mir::mono::MonoItem::Static(def_id) => tcx\n-                .symbol_name(Instance::mono(tcx, *def_id))\n-                .name\n-                .contains(\"__rustc_proc_macro_decls_\"),\n-            _ => false,\n-        }) {\n-            init_atomics_mutex_from_constructor =\n-                Some(crate::atomic_shim::init_global_lock_constructor(\n-                    &mut module,\n-                    &format!(\"{}_init_atomics_mutex\", cgu_name.as_str()),\n-                ));\n-        }\n-    }\n+    let module = new_module(tcx, cgu_name.as_str().to_string());\n \n     let mut cx = crate::CodegenCx::new(\n         tcx,\n@@ -180,7 +152,7 @@ fn module_codegen(\n     }\n     let (mut module, global_asm, debug, mut unwind_context) =\n         tcx.sess.time(\"finalize CodegenCx\", || cx.finalize());\n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context, false);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module, &mut unwind_context);\n \n     let codegen_result = emit_module(\n         tcx,\n@@ -189,13 +161,6 @@ fn module_codegen(\n         module,\n         debug,\n         unwind_context,\n-        |mut product| {\n-            if let Some(func_id) = init_atomics_mutex_from_constructor {\n-                product.add_constructor(func_id);\n-            }\n-\n-            product\n-        },\n     );\n \n     codegen_global_asm(tcx, &cgu.name().as_str(), &global_asm);\n@@ -275,7 +240,6 @@ pub(super) fn run_aot(\n             allocator_module,\n             None,\n             allocator_unwind_context,\n-            |product| product,\n         );\n         if let Some((id, product)) = work_product {\n             work_products.insert(id, product);"}, {"sha": "4abfcfcd7b19e9ddd75094856fb5bd35eb00ea0a", "filename": "src/driver/jit.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -23,24 +23,6 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`.\");\n     }\n \n-    #[cfg(unix)]\n-    unsafe {\n-        // When not using our custom driver rustc will open us without the RTLD_GLOBAL flag, so\n-        // __cg_clif_global_atomic_mutex will not be exported. We fix this by opening ourself again\n-        // as global.\n-        // FIXME remove once atomic_shim is gone\n-\n-        let mut dl_info: libc::Dl_info = std::mem::zeroed();\n-        assert_ne!(\n-            libc::dladdr(run_jit as *const libc::c_void, &mut dl_info),\n-            0\n-        );\n-        assert_ne!(\n-            libc::dlopen(dl_info.dli_fname, libc::RTLD_NOW | libc::RTLD_GLOBAL),\n-            std::ptr::null_mut(),\n-        );\n-    }\n-\n     let imported_symbols = load_imported_symbols_for_jit(tcx);\n \n     let mut jit_builder = JITBuilder::with_isa(\n@@ -111,7 +93,7 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>, backend_config: BackendConfig) -> ! {\n         tcx.sess.fatal(\"Inline asm is not supported in JIT mode\");\n     }\n \n-    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context, true);\n+    crate::main_shim::maybe_create_entry_wrapper(tcx, &mut jit_module, &mut unwind_context);\n     crate::allocator::codegen(tcx, &mut jit_module, &mut unwind_context);\n \n     tcx.sess.abort_if_errors();"}, {"sha": "4aed09d2b143b865e54860f302c3f70ed8b42615", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 123, "deletions": 115, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -9,6 +9,7 @@ pub(crate) use cpuid::codegen_cpuid_call;\n pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n use crate::prelude::*;\n+use cranelift_codegen::ir::AtomicRmwOp;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n \n macro intrinsic_pat {\n@@ -112,38 +113,6 @@ macro call_intrinsic_match {\n     }\n }\n \n-macro atomic_binop_return_old($fx:expr, $op:ident<$T:ident>($ptr:ident, $src:ident) -> $ret:ident) {\n-    crate::atomic_shim::lock_global_lock($fx);\n-\n-    let clif_ty = $fx.clif_type($T).unwrap();\n-    let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n-    let new = $fx.bcx.ins().$op(old, $src);\n-    $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n-    $ret.write_cvalue($fx, CValue::by_val(old, $fx.layout_of($T)));\n-\n-    crate::atomic_shim::unlock_global_lock($fx);\n-}\n-\n-macro atomic_minmax($fx:expr, $cc:expr, <$T:ident> ($ptr:ident, $src:ident) -> $ret:ident) {\n-    crate::atomic_shim::lock_global_lock($fx);\n-\n-    // Read old\n-    let clif_ty = $fx.clif_type($T).unwrap();\n-    let old = $fx.bcx.ins().load(clif_ty, MemFlags::new(), $ptr, 0);\n-\n-    // Compare\n-    let is_eq = $fx.bcx.ins().icmp(IntCC::SignedGreaterThan, old, $src);\n-    let new = $fx.bcx.ins().select(is_eq, old, $src);\n-\n-    // Write new\n-    $fx.bcx.ins().store(MemFlags::new(), new, $ptr, 0);\n-\n-    let ret_val = CValue::by_val(old, $ret.layout());\n-    $ret.write_cvalue($fx, ret_val);\n-\n-    crate::atomic_shim::unlock_global_lock($fx);\n-}\n-\n macro validate_atomic_type($fx:ident, $intrinsic:ident, $span:ident, $ty:expr) {\n     match $ty.kind() {\n         ty::Uint(_) | ty::Int(_) | ty::RawPtr(..) => {}\n@@ -912,136 +881,175 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n \n         _ if intrinsic.starts_with(\"atomic_fence\"), () {\n-            crate::atomic_shim::lock_global_lock(fx);\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            fx.bcx.ins().fence();\n         };\n         _ if intrinsic.starts_with(\"atomic_singlethreadfence\"), () {\n-            crate::atomic_shim::lock_global_lock(fx);\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            // FIXME use a compiler fence once Cranelift supports it\n+            fx.bcx.ins().fence();\n         };\n-        _ if intrinsic.starts_with(\"atomic_load\"), (c ptr) {\n-            crate::atomic_shim::lock_global_lock(fx);\n+        _ if intrinsic.starts_with(\"atomic_load\"), <T> (v ptr) {\n+            validate_atomic_type!(fx, intrinsic, span, T);\n+            let ty = fx.clif_type(T).unwrap();\n \n-            let inner_layout =\n-                fx.layout_of(ptr.layout().ty.builtin_deref(true).unwrap().ty);\n-            validate_atomic_type!(fx, intrinsic, span, inner_layout.ty);\n-            let val = CValue::by_ref(Pointer::new(ptr.load_scalar(fx)), inner_layout);\n-            ret.write_cvalue(fx, val);\n+            let val = fx.bcx.ins().atomic_load(ty, MemFlags::trusted(), ptr);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let val = CValue::by_val(val, fx.layout_of(T));\n+            ret.write_cvalue(fx, val);\n         };\n         _ if intrinsic.starts_with(\"atomic_store\"), (v ptr, c val) {\n             validate_atomic_type!(fx, intrinsic, span, val.layout().ty);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            let dest = CPlace::for_ptr(Pointer::new(ptr), val.layout());\n-            dest.write_cvalue(fx, val);\n+            let val = val.load_scalar(fx);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            fx.bcx.ins().atomic_store(MemFlags::trusted(), val, ptr);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xchg\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, T);\n-\n-            crate::atomic_shim::lock_global_lock(fx);\n+        _ if intrinsic.starts_with(\"atomic_xchg\"), (v ptr, c new) {\n+            let layout = new.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n-            // Read old\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-            ret.write_cvalue(fx, CValue::by_val(old, fx.layout_of(T)));\n+            let new = new.load_scalar(fx);\n \n-            // Write new\n-            let dest = CPlace::for_ptr(Pointer::new(ptr), src.layout());\n-            dest.write_cvalue(fx, src);\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Xchg, ptr, new);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_cxchg\"), <T> (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n-            validate_atomic_type!(fx, intrinsic, span, T);\n+        _ if intrinsic.starts_with(\"atomic_cxchg\"), (v ptr, c test_old, c new) { // both atomic_cxchg_* and atomic_cxchgweak_*\n+            let layout = new.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n \n             let test_old = test_old.load_scalar(fx);\n             let new = new.load_scalar(fx);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            // Read old\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-\n-            // Compare\n+            let old = fx.bcx.ins().atomic_cas(MemFlags::trusted(), ptr, test_old, new);\n             let is_eq = fx.bcx.ins().icmp(IntCC::Equal, old, test_old);\n-            let new = fx.bcx.ins().select(is_eq, new, old); // Keep old if not equal to test_old\n-\n-            // Write new\n-            fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n \n             let ret_val = CValue::by_val_pair(old, fx.bcx.ins().bint(types::I8, is_eq), ret.layout());\n-            ret.write_cvalue(fx, ret_val);\n-\n-            crate::atomic_shim::unlock_global_lock(fx);\n+            ret.write_cvalue(fx, ret_val)\n         };\n \n-        _ if intrinsic.starts_with(\"atomic_xadd\"), <T> (v ptr, c amount) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xadd\"), (v ptr, c amount) {\n+            let layout = amount.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let amount = amount.load_scalar(fx);\n-            atomic_binop_return_old! (fx, iadd<T>(ptr, amount) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Add, ptr, amount);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xsub\"), <T> (v ptr, c amount) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xsub\"), (v ptr, c amount) {\n+            let layout = amount.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let amount = amount.load_scalar(fx);\n-            atomic_binop_return_old! (fx, isub<T>(ptr, amount) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Sub, ptr, amount);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_and\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_and\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, band<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::And, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_nand\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, T);\n+        _ if intrinsic.starts_with(\"atomic_or\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n             let src = src.load_scalar(fx);\n \n-            crate::atomic_shim::lock_global_lock(fx);\n-\n-            let clif_ty = fx.clif_type(T).unwrap();\n-            let old = fx.bcx.ins().load(clif_ty, MemFlags::new(), ptr, 0);\n-            let and = fx.bcx.ins().band(old, src);\n-            let new = fx.bcx.ins().bnot(and);\n-            fx.bcx.ins().store(MemFlags::new(), new, ptr, 0);\n-            ret.write_cvalue(fx, CValue::by_val(old, fx.layout_of(T)));\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Or, ptr, src);\n \n-            crate::atomic_shim::unlock_global_lock(fx);\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_or\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_xor\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, bor<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Xor, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_xor\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+\n+        // FIXME https://github.com/bytecodealliance/wasmtime/issues/2647\n+        _ if intrinsic.starts_with(\"atomic_nand\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_binop_return_old! (fx, bxor<T>(ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Nand, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n+        _ if intrinsic.starts_with(\"atomic_max\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n \n-        _ if intrinsic.starts_with(\"atomic_max\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::SignedGreaterThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Smax, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umax\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_umax\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::UnsignedGreaterThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Umax, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_min\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_min\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::SignedLessThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Smin, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n-        _ if intrinsic.starts_with(\"atomic_umin\"), <T> (v ptr, c src) {\n-            validate_atomic_type!(fx, intrinsic, span, ret.layout().ty);\n+        _ if intrinsic.starts_with(\"atomic_umin\"), (v ptr, c src) {\n+            let layout = src.layout();\n+            validate_atomic_type!(fx, intrinsic, span, layout.ty);\n+            let ty = fx.clif_type(layout.ty).unwrap();\n+\n             let src = src.load_scalar(fx);\n-            atomic_minmax!(fx, IntCC::UnsignedLessThan, <T> (ptr, src) -> ret);\n+\n+            let old = fx.bcx.ins().atomic_rmw(ty, MemFlags::trusted(), AtomicRmwOp::Umin, ptr, src);\n+\n+            let old = CValue::by_val(old, layout);\n+            ret.write_cvalue(fx, old);\n         };\n \n         minnumf32, (v a, v b) {"}, {"sha": "417934f760326c646469cc459ade6ab362f85880", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -12,8 +12,6 @@\n #![warn(unused_lifetimes)]\n #![warn(unreachable_pub)]\n \n-#[cfg(feature = \"jit\")]\n-extern crate libc;\n extern crate snap;\n #[macro_use]\n extern crate rustc_middle;\n@@ -54,7 +52,6 @@ mod abi;\n mod allocator;\n mod analyze;\n mod archive;\n-mod atomic_shim;\n mod backend;\n mod base;\n mod cast;\n@@ -343,11 +340,7 @@ fn build_isa(sess: &Session) -> Box<dyn isa::TargetIsa + 'static> {\n \n     let flags = settings::Flags::new(flags_builder);\n \n-    let variant = if cfg!(feature = \"oldbe\") {\n-        cranelift_codegen::isa::BackendVariant::Legacy\n-    } else {\n-        cranelift_codegen::isa::BackendVariant::MachInst\n-    };\n+    let variant = cranelift_codegen::isa::BackendVariant::MachInst;\n     let mut isa_builder = cranelift_codegen::isa::lookup_variant(target_triple, variant).unwrap();\n     // Don't use \"haswell\", as it implies `has_lzcnt`.macOS CI is still at Ivy Bridge EP, so `lzcnt`\n     // is interpreted as `bsr`."}, {"sha": "4ea9b9f99530387dc788ef9210f116d3d415d116", "filename": "src/main_shim.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cfb885da7090678ebce1dde972e7df612ef03e5/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=4cfb885da7090678ebce1dde972e7df612ef03e5", "patch": "@@ -9,7 +9,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n     tcx: TyCtxt<'_>,\n     module: &mut impl Module,\n     unwind_context: &mut UnwindContext<'_>,\n-    use_jit: bool,\n ) {\n     let (main_def_id, use_start_lang_item) = match tcx.entry_fn(LOCAL_CRATE) {\n         Some((def_id, entry_ty)) => (\n@@ -33,7 +32,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n         unwind_context,\n         main_def_id,\n         use_start_lang_item,\n-        use_jit,\n     );\n \n     fn create_entry_fn(\n@@ -42,7 +40,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n         unwind_context: &mut UnwindContext<'_>,\n         rust_main_def_id: DefId,\n         use_start_lang_item: bool,\n-        use_jit: bool,\n     ) {\n         let main_ret_ty = tcx.fn_sig(rust_main_def_id).output();\n         // Given that `main()` has no arguments,\n@@ -86,8 +83,6 @@ pub(crate) fn maybe_create_entry_wrapper(\n             let arg_argc = bcx.append_block_param(block, m.target_config().pointer_type());\n             let arg_argv = bcx.append_block_param(block, m.target_config().pointer_type());\n \n-            crate::atomic_shim::init_global_lock(m, &mut bcx, use_jit);\n-\n             let main_func_ref = m.declare_func_in_func(main_func_id, &mut bcx.func);\n \n             let call_inst = if use_start_lang_item {"}]}