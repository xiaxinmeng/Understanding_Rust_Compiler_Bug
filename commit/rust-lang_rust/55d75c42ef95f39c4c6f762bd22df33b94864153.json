{"sha": "55d75c42ef95f39c4c6f762bd22df33b94864153", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZDc1YzQyZWY5NWYzOWM0YzZmNzYyYmQyMmRmMzNiOTQ4NjQxNTM=", "commit": {"author": {"name": "Dylan Maccora", "email": "maccora17@gmail.com", "date": "2017-05-19T23:42:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-19T23:42:37Z"}, "message": "Merge branch 'master' into maccoda/env_docs", "tree": {"sha": "8e910c6f10b632046b37e8f967fa346a237b6d51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e910c6f10b632046b37e8f967fa346a237b6d51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55d75c42ef95f39c4c6f762bd22df33b94864153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55d75c42ef95f39c4c6f762bd22df33b94864153", "html_url": "https://github.com/rust-lang/rust/commit/55d75c42ef95f39c4c6f762bd22df33b94864153", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55d75c42ef95f39c4c6f762bd22df33b94864153/comments", "author": {"login": "maccoda", "id": 15388206, "node_id": "MDQ6VXNlcjE1Mzg4MjA2", "avatar_url": "https://avatars.githubusercontent.com/u/15388206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/maccoda", "html_url": "https://github.com/maccoda", "followers_url": "https://api.github.com/users/maccoda/followers", "following_url": "https://api.github.com/users/maccoda/following{/other_user}", "gists_url": "https://api.github.com/users/maccoda/gists{/gist_id}", "starred_url": "https://api.github.com/users/maccoda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/maccoda/subscriptions", "organizations_url": "https://api.github.com/users/maccoda/orgs", "repos_url": "https://api.github.com/users/maccoda/repos", "events_url": "https://api.github.com/users/maccoda/events{/privacy}", "received_events_url": "https://api.github.com/users/maccoda/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b69b6413afc770a8652096e8753d77eeb99b23bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b69b6413afc770a8652096e8753d77eeb99b23bb", "html_url": "https://github.com/rust-lang/rust/commit/b69b6413afc770a8652096e8753d77eeb99b23bb"}, {"sha": "5dfcd85fd4bae49445383baadf472fbdb414a0e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dfcd85fd4bae49445383baadf472fbdb414a0e6", "html_url": "https://github.com/rust-lang/rust/commit/5dfcd85fd4bae49445383baadf472fbdb414a0e6"}], "stats": {"total": 7522, "additions": 5064, "deletions": 2458}, "files": [{"sha": "1ef3c086a1c232566edfb66c4bcd2b3836542530", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -13,7 +13,7 @@\n \tpath = src/jemalloc\n \turl = https://github.com/rust-lang/jemalloc.git\n [submodule \"src/rust-installer\"]\n-\tpath = src/rust-installer\n+\tpath = src/tools/rust-installer\n \turl = https://github.com/rust-lang/rust-installer.git\n [submodule \"src/liblibc\"]\n \tpath = src/liblibc\n@@ -23,7 +23,7 @@\n \turl = https://github.com/rust-lang-nursery/nomicon.git\n [submodule \"src/tools/cargo\"]\n \tpath = src/tools/cargo\n-\turl = https://github.com/rust-lang/cargo\n+\turl = https://github.com/rust-lang/cargo.git\n [submodule \"reference\"]\n \tpath = src/doc/reference\n \turl = https://github.com/rust-lang-nursery/reference.git\n@@ -32,4 +32,4 @@\n \turl = https://github.com/rust-lang/book.git\n [submodule \"src/tools/rls\"]\n \tpath = src/tools/rls\n-\turl = https://github.com/rust-lang-nursery/rls\n+\turl = https://github.com/rust-lang-nursery/rls.git"}, {"sha": "8f121f8d6ed9b54434c5f1bb4e23a149a42381d6", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -177,7 +177,7 @@ python x.py test src/test/rustdoc\n python x.py build src/libcore --stage 0\n ```\n \n-You can explore the build system throught the various `--help` pages for each\n+You can explore the build system through the various `--help` pages for each\n subcommand. For example to learn more about a command you can run:\n \n ```"}, {"sha": "96de1d90f25e623319f3defd8e2e5e2c0cceb2fe", "filename": "appveyor.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -141,9 +141,9 @@ install:\n   - set PATH=\"C:\\Program Files (x86)\\Inno Setup 5\";%PATH%\n \n   # Help debug some handle issues on AppVeyor\n-  - ps: Invoke-WebRequest -Uri https://download.sysinternals.com/files/Handle.zip -OutFile handle.zip\n+  - appveyor-retry appveyor DownloadFile https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-05-15-Handle.zip\n   - mkdir handle\n-  - ps: Expand-Archive handle.zip -dest handle\n+  - 7z x -ohandle 2017-05-15-Handle.zip\n   - set PATH=%PATH%;%CD%\\handle\n   - handle.exe -accepteula -help\n "}, {"sha": "af59d5b0bb88977d2c512af7fa1f1c096ed398ea", "filename": "configure", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/configure", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -519,6 +519,7 @@ valopt_nosave host \"${CFG_BUILD}\" \"GNUs ./configure syntax LLVM host triples\"\n valopt_nosave target \"${CFG_HOST}\" \"GNUs ./configure syntax LLVM target triples\"\n valopt_nosave mandir \"${CFG_PREFIX}/share/man\" \"install man pages in PATH\"\n valopt_nosave docdir \"${CFG_PREFIX}/share/doc/rust\" \"install documentation in PATH\"\n+valopt_nosave bindir \"${CFG_PREFIX}/bin\" \"install binaries\"\n \n # On Windows this determines root of the subtree for target libraries.\n # Host runtime libs always go to 'bin'.\n@@ -710,6 +711,7 @@ envopt LDFLAGS\n CFG_PREFIX=${CFG_PREFIX%/}\n CFG_MANDIR=${CFG_MANDIR%/}\n CFG_DOCDIR=${CFG_DOCDIR%/}\n+CFG_BINDIR=${CFG_BINDIR%/}\n CFG_HOST=\"$(echo $CFG_HOST | tr ',' ' ')\"\n CFG_TARGET=\"$(echo $CFG_TARGET | tr ',' ' ')\"\n \n@@ -750,6 +752,7 @@ putvar CFG_X86_64_LINUX_ANDROID_NDK\n putvar CFG_NACL_CROSS_PATH\n putvar CFG_MANDIR\n putvar CFG_DOCDIR\n+putvar CFG_BINDIR\n putvar CFG_USING_LIBCPP\n \n msg"}, {"sha": "804fd5807735f619c6cc62a7e01fd4665f3e2602", "filename": "src/Cargo.lock", "status": "modified", "additions": 1213, "deletions": 62, "changes": 1275, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -6,6 +6,23 @@ dependencies = [\n  \"libc 0.0.0\",\n ]\n \n+[[package]]\n+name = \"advapi32-sys\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"aho-corasick\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"aho-corasick\"\n version = \"0.6.3\"\n@@ -49,20 +66,38 @@ name = \"arena\"\n version = \"0.0.0\"\n \n [[package]]\n-name = \"atty\"\n-version = \"0.2.2\"\n+name = \"backtrace\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n+ \"backtrace-sys 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"backtrace-sys\"\n+version = \"0.1.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"gcc 0.3.46 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"bitflags\"\n version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"bitflags\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"bitflags\"\n version = \"0.8.2\"\n@@ -77,17 +112,22 @@ dependencies = [\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.46 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"bufstream\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n- \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -98,23 +138,110 @@ dependencies = [\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"cargo\"\n+version = \"0.20.0\"\n+source = \"git+https://github.com/rust-lang/cargo#2b32084293d8da63b48de56363a0f2e986ec3367\"\n+replace = \"cargo 0.20.0\"\n+\n+[[package]]\n+name = \"cargo\"\n+version = \"0.20.0\"\n+dependencies = [\n+ \"advapi32-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cargotest 0.1.0\",\n+ \"chrono 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"crates-io 0.9.0\",\n+ \"crossbeam 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"docopt 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"fs2 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"git2 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"git2-curl 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"hamcrest 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libgit2-sys 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"psapi-sys 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"semver 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_ignored 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"shell-escape 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tar 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"cargotest\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cargo 0.20.0\",\n+ \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"git2 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"hamcrest 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tar 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"cargotest2\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"cfg-if\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"chrono\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"num 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"time 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"clap\"\n-version = \"2.22.1\"\n+version = \"2.19.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"strsim 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term_size 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-segmentation 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"vec_map 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"vec_map 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"yaml-rust 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -151,23 +278,115 @@ dependencies = [\n  \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"core\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"crates-io\"\n+version = \"0.9.0\"\n+dependencies = [\n+ \"curl 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"crossbeam\"\n+version = \"0.2.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"curl\"\n+version = \"0.4.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"curl-sys 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"curl-sys\"\n+version = \"0.3.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"gcc 0.3.46 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libz-sys 1.0.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"dbghelp-sys\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"derive-new\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"quote 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.8.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"diff\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"docopt\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"dtoa\"\n version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"either\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"enum_primitive\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"env_logger\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"env_logger\"\n version = \"0.4.2\"\n@@ -177,6 +396,14 @@ dependencies = [\n  \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"error-chain\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"backtrace 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"error_index_generator\"\n version = \"0.0.0\"\n@@ -186,7 +413,7 @@ name = \"filetime\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -197,15 +424,48 @@ dependencies = [\n  \"gcc 0.3.46 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"flate2\"\n+version = \"0.2.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"miniz-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"fmt_macros\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"foreign-types\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"fs2\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"gcc\"\n version = \"0.3.46\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"gdi32-sys\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"getopts\"\n version = \"0.0.0\"\n@@ -215,22 +475,93 @@ name = \"getopts\"\n version = \"0.2.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"git2\"\n+version = \"0.6.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libgit2-sys 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"git2-curl\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"curl 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"git2 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"glob\"\n+version = \"0.2.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"graphviz\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"hamcrest\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"num 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"handlebars\"\n-version = \"0.25.2\"\n+version = \"0.25.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"lazy_static 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"quick-error 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quick-error 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 0.9.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 0.9.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"idna\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"matches 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-bidi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-normalization 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"installer\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"clap 2.19.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tar 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"walkdir 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"xz2 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"itertools\"\n+version = \"0.5.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"either 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -247,9 +578,22 @@ dependencies = [\n  \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"languageserver-types\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"lazy_static\"\n-version = \"0.2.5\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -261,9 +605,46 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.21\"\n+version = \"0.2.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"libgit2-sys\"\n+version = \"0.6.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cmake 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"curl-sys 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.46 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libz-sys 1.0.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"libssh2-sys\"\n+version = \"0.2.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cmake 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libz-sys 1.0.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"libz-sys\"\n+version = \"1.0.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"gcc 0.3.46 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"linkchecker\"\n version = \"0.1.0\"\n@@ -273,29 +654,150 @@ name = \"log\"\n version = \"0.3.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"lzma-sys\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.46 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"matches\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"mdbook\"\n version = \"0.0.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"clap 2.22.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.19.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"handlebars 0.25.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"handlebars 0.25.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pulldown-cmark 0.0.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 0.9.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 0.9.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 0.9.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"memchr\"\n+version = \"0.1.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"memchr\"\n version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"miniz-sys\"\n+version = \"0.1.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"gcc 0.3.46 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"miow\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"net2 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"multimap\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"net2\"\n+version = \"0.2.29\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cfg-if 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"num\"\n+version = \"0.1.37\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"num-bigint 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-complex 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-integer 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-iter 0.1.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-rational 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"num-bigint\"\n+version = \"0.1.37\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"num-integer 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"num-complex\"\n+version = \"0.1.37\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"num-integer\"\n+version = \"0.1.34\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"num-iter\"\n+version = \"0.1.33\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"num-integer 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"num-rational\"\n+version = \"0.1.36\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"num-bigint 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-integer 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -308,14 +810,51 @@ name = \"num_cpus\"\n version = \"1.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"open\"\n version = \"1.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"openssl\"\n+version = \"0.9.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"foreign-types 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-sys 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"openssl-probe\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"openssl-sys\"\n+version = \"0.9.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"gcc 0.3.46 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gdi32-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"user32-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"owning_ref\"\n+version = \"0.3.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"panic_abort\"\n version = \"0.0.0\"\n@@ -339,6 +878,11 @@ name = \"pest\"\n version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"pkg-config\"\n+version = \"0.3.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"proc_macro\"\n version = \"0.0.0\"\n@@ -355,6 +899,15 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"psapi-sys\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"pulldown-cmark\"\n version = \"0.0.8\"\n@@ -374,8 +927,32 @@ dependencies = [\n \n [[package]]\n name = \"quick-error\"\n-version = \"1.1.0\"\n+version = \"1.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"quote\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"quote\"\n+version = \"0.3.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"racer\"\n+version = \"2.0.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"clap 2.19.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_errors 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_syntax 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"typed-arena 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n \n [[package]]\n name = \"rand\"\n@@ -384,6 +961,31 @@ dependencies = [\n  \"core 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rand\"\n+version = \"0.3.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"redox_syscall\"\n+version = \"0.1.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"regex\"\n+version = \"0.1.80\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"regex\"\n version = \"0.2.1\"\n@@ -396,6 +998,11 @@ dependencies = [\n  \"utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"regex-syntax\"\n+version = \"0.3.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"regex-syntax\"\n version = \"0.4.0\"\n@@ -409,28 +1016,74 @@ version = \"0.1.0\"\n name = \"remote-test-server\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"rls\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"cargo 0.20.0 (git+https://github.com/rust-lang/cargo)\",\n+ \"derive-new 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"languageserver-types 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"racer 2.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-analysis 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-vfs 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustfmt 0.8.4 (git+https://github.com/rust-lang-nursery/rustfmt)\",\n+ \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rls-analysis\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"derive-new 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rls-data\"\n version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rls-span\"\n version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rls-vfs\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"racer 2.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap 2.22.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"clap 2.19.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"mdbook 0.0.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -442,17 +1095,22 @@ dependencies = [\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n- \"rustc_llvm 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc-demangle\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"rustc-main\"\n version = \"0.0.0\"\n@@ -464,7 +1122,7 @@ dependencies = [\n \n [[package]]\n name = \"rustc-serialize\"\n-version = \"0.3.23\"\n+version = \"0.3.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -552,7 +1210,6 @@ dependencies = [\n  \"rustc_errors 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n  \"rustc_lint 0.0.0\",\n- \"rustc_llvm 0.0.0\",\n  \"rustc_metadata 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"rustc_passes 0.0.0\",\n@@ -626,13 +1283,13 @@ version = \"0.0.0\"\n dependencies = [\n  \"flate 0.0.0\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n- \"rustc_llvm 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_ext 0.0.0\",\n@@ -722,7 +1379,7 @@ dependencies = [\n  \"rls-data 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_typeck 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -734,6 +1391,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"flate 0.0.0\",\n  \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_bitflags 0.0.0\",\n@@ -800,26 +1458,128 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustfmt\"\n+version = \"0.8.4\"\n+source = \"git+https://github.com/rust-lang-nursery/rustfmt#bf9b3fa1d7cab2f7bd541539d397a92b4954ec96\"\n+dependencies = [\n+ \"diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.5.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"multimap 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"strings 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_errors 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_syntax 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-segmentation 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"walkdir 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"same-file\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"semver\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"semver-parser\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"serde\"\n+version = \"0.9.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"serde\"\n-version = \"0.9.11\"\n+version = \"1.0.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"serde_derive\"\n+version = \"1.0.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive_internals 0.15.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"serde_derive_internals\"\n+version = \"0.15.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"serde_ignored\"\n+version = \"0.0.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"serde_json\"\n+version = \"0.9.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"serde_json\"\n-version = \"0.9.9\"\n+version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 0.9.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"serialize\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"shell-escape\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"stable_deref_trait\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"std\"\n version = \"0.0.0\"\n@@ -851,11 +1611,51 @@ dependencies = [\n  \"core 0.0.0\",\n ]\n \n+[[package]]\n+name = \"strings\"\n+version = \"0.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"strsim\"\n+version = \"0.5.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"strsim\"\n version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"syn\"\n+version = \"0.8.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"quote 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-xid 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"syn\"\n+version = \"0.11.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"synom\"\n+version = \"0.11.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"syntax\"\n version = \"0.0.0\"\n@@ -887,17 +1687,113 @@ dependencies = [\n  \"serialize 0.0.0\",\n ]\n \n+[[package]]\n+name = \"syntex_errors\"\n+version = \"0.52.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_pos 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-xid 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"syntex_errors\"\n+version = \"0.58.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_pos 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"syntex_pos\"\n+version = \"0.52.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"syntex_pos\"\n+version = \"0.58.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"syntex_syntax\"\n+version = \"0.52.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_errors 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_pos 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-xid 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"syntex_syntax\"\n+version = \"0.58.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_errors 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syntex_pos 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"tar\"\n+version = \"0.4.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"xattr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"tempdir\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rand 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"term\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"term\"\n+version = \"0.4.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"term_size\"\n version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -911,52 +1807,129 @@ dependencies = [\n \n [[package]]\n name = \"thread-id\"\n-version = \"3.0.0\"\n+version = \"2.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"thread-id\"\n+version = \"3.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"thread_local\"\n+version = \"0.2.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"thread_local\"\n version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"thread-id 3.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"thread-id 3.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unreachable 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"tidy\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"time\"\n+version = \"0.1.37\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"redox_syscall 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"toml\"\n version = \"0.1.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"toml\"\n-version = \"0.3.1\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"toml\"\n+version = \"0.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"serde 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"toml\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"typed-arena\"\n+version = \"1.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"unicode-bidi\"\n+version = \"0.2.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"serde 0.9.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"matches 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"unicode-normalization\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"unicode-segmentation\"\n-version = \"1.1.0\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"unicode-segmentation\"\n+version = \"1.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"unicode-width\"\n version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"unicode-xid\"\n+version = \"0.0.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"unicode-xid\"\n+version = \"0.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"unreachable\"\n version = \"0.1.1\"\n@@ -965,21 +1938,63 @@ dependencies = [\n  \"void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"url\"\n+version = \"1.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"idna 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"matches 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"url_serde\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"user32-sys\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"utf8-ranges\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"utf8-ranges\"\n version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"vec_map\"\n-version = \"0.7.0\"\n+version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"void\"\n version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"walkdir\"\n+version = \"1.0.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"same-file 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"winapi\"\n version = \"0.2.8\"\n@@ -990,53 +2005,189 @@ name = \"winapi-build\"\n version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"ws2_32-sys\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"xattr\"\n+version = \"0.1.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"xz2\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"lzma-sys 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"yaml-rust\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [metadata]\n+\"checksum advapi32-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e06588080cb19d0acb6739808aafa5f26bfb2ca015b2b6370028b44cf7cb8a9a\"\n+\"checksum aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca972c2ea5f742bfce5687b9aef75506a764f61d37f8f649047846a9686ddb66\"\n \"checksum aho-corasick 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"500909c4f87a9e52355b26626d890833e9e1d53ac566db76c36faa984b889699\"\n \"checksum ansi_term 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"23ac7c30002a5accbf7e8987d0632fa6de155b7c3d39d0067317a391e00a2ef6\"\n-\"checksum atty 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d912da0db7fa85514874458ca3651fe2cddace8d0b0505571dbdcd41ab490159\"\n+\"checksum backtrace 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f551bc2ddd53aea015d453ef0b635af89444afa5ed2405dd0b2062ad5d600d80\"\n+\"checksum backtrace-sys 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d192fd129132fbc97497c1f2ec2c2c5174e376b95f535199ef4fe0a293d33842\"\n \"checksum bitflags 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4f67931368edf3a9a51d29886d245f1c3db2f1ef0dcc9e35ff70341b78c10d23\"\n+\"checksum bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aad18937a628ec6abcd26d1489012cc0e18c21798210f491af69ded9b881106d\"\n \"checksum bitflags 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1370e9fc2a6ae53aea8b7a5110edbd08836ed87c88736dfabccade1c2b44bff4\"\n-\"checksum clap 2.22.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e17a4a72ffea176f77d6e2db609c6c919ef221f23862c9915e687fb54d833485\"\n+\"checksum bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f2f382711e76b9de6c744cc00d0497baba02fb00a787f088c879f01d09468e32\"\n+\"checksum cargo 0.20.0 (git+https://github.com/rust-lang/cargo)\" = \"<none>\"\n+\"checksum cfg-if 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"de1e760d7b6535af4241fca8bd8adf68e2e7edacc6b29f5d399050c5e48cf88c\"\n+\"checksum chrono 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9123be86fd2a8f627836c235ecdf331fdd067ecf7ac05aa1a68fbcf2429f056\"\n+\"checksum clap 2.19.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"95b78f3fe0fc94c13c731714363260e04b557a637166f33a4570d3189d642374\"\n \"checksum cmake 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\" = \"92278eb79412c8f75cfc89e707a1bb3a6490b68f7f2e78d15c774f30fe701122\"\n+\"checksum crossbeam 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0c5ea215664ca264da8a9d9c3be80d2eaf30923c259d03e870388eb927508f97\"\n+\"checksum curl 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c90e1240ef340dd4027ade439e5c7c2064dd9dc652682117bd50d1486a3add7b\"\n+\"checksum curl-sys 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"23e7e544dc5e1ba42c4a4a678bd47985e84b9c3f4d3404c29700622a029db9c3\"\n+\"checksum dbghelp-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"97590ba53bcb8ac28279161ca943a924d1fd4a8fb3fa63302591647c4fc5b850\"\n+\"checksum derive-new 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"41be6ca3b99e0c0483fb2389685448f650459c3ecbe4e18d7705d8010ec4ab8e\"\n \"checksum diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a515461b6c8c08419850ced27bc29e86166dcdcde8fbe76f8b1f0589bb49472\"\n+\"checksum docopt 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab32ea6e284d87987066f21a9e809a73c14720571ef34516f0890b3d355ccfd8\"\n \"checksum dtoa 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"80c8b71fd71146990a9742fc06dcbbde19161a267e0ad4e572c35162f4578c90\"\n+\"checksum either 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"18785c1ba806c258137c937e44ada9ee7e69a37e3c72077542cd2f069d78562a\"\n+\"checksum enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be4551092f4d519593039259a9ed8daedf0da12e5109c5280338073eaeb81180\"\n+\"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e3856f1697098606fc6cb97a93de88ca3f3bc35bb878c725920e6e82ecf05e83\"\n+\"checksum error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9435d864e017c3c6afeac1654189b06cdb491cf2ff73dbf0d73b0f292f42ff8\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n+\"checksum flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36df0166e856739905cd3d7e0b210fe818592211a008862599845e012d8d304c\"\n+\"checksum foreign-types 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3e4056b9bd47f8ac5ba12be771f77a0dae796d1bbaaf5fd0b9c2d38b69b8a29d\"\n+\"checksum fs2 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"34edaee07555859dc13ca387e6ae05686bb4d0364c95d649b6dab959511f4baf\"\n \"checksum gcc 0.3.46 (registry+https://github.com/rust-lang/crates.io-index)\" = \"181e3cebba1d663bd92eb90e2da787e10597e027eb00de8d742b260a7850948f\"\n+\"checksum gdi32-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0912515a8ff24ba900422ecda800b52f4016a56251922d397c576bf92c690518\"\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n-\"checksum handlebars 0.25.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"663e1728d8037fb0d4e13bcd1b1909fb5d913690a9929eb385922df157c2ff8f\"\n+\"checksum git2 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9de9df4358c17e448a778d90cd0272e1dab5eae30244502333fa2001c4e24357\"\n+\"checksum git2-curl 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"68676bc784bf0bef83278898929bf64a251e87c0340723d0b93fa096c9c5bf8e\"\n+\"checksum glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8be18de09a56b60ed0edf84bc9df007e30040691af7acd1c41874faac5895bfb\"\n+\"checksum hamcrest 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bf088f042a467089e9baa4972f57f9247e42a0cc549ba264c7a04fbb8ecb89d4\"\n+\"checksum handlebars 0.25.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15bdf598fc3c2de40c6b340213028301c0d225eea55a2294e6cc148074e557a1\"\n+\"checksum idna 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ac85ec3f80c8e4e99d9325521337e14ec7555c458a14e377d189659a427f375\"\n+\"checksum itertools 0.5.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4833d6978da405305126af4ac88569b5d71ff758581ce5a987dbfa3755f694fc\"\n \"checksum itoa 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eb2f404fbc66fd9aac13e998248505e7ecb2ad8e44ab6388684c5fb11c6c251c\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n-\"checksum lazy_static 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4732c563b9a21a406565c4747daa7b46742f082911ae4753f390dc9ec7ee1a97\"\n-\"checksum libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"88ee81885f9f04bff991e306fea7c1c60a5f0f9e409e99f6b40e3311a3363135\"\n+\"checksum languageserver-types 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"97c2985bfcbbcb0189cfa25e1c10c1ac7111df2b6214b652c690127aefdf4e5b\"\n+\"checksum lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3b37545ab726dd833ec6420aaba8231c5b320814b9029ad585555d2a03e94fbf\"\n+\"checksum libc 0.2.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"babb8281da88cba992fa1f4ddec7d63ed96280a1a53ec9b919fd37b53d71e502\"\n+\"checksum libgit2-sys 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd89dd7196d5fa35b659c3eaf3c1b14b9bd961bfd1a07dfca49adeb8a6aa3763\"\n+\"checksum libssh2-sys 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0db4ec23611747ef772db1c4d650f8bd762f07b461727ec998f953c614024b75\"\n+\"checksum libz-sys 1.0.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e5ee912a45d686d393d5ac87fac15ba0ba18daae14e8e7543c63ebf7fb7e970c\"\n \"checksum log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5141eca02775a762cc6cd564d8d2c50f67c0ea3a372cbf1c51592b3e029e10ad\"\n+\"checksum lzma-sys 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fedff6a5cbb24494ec6ee4784e9ac5c187161fede04c7767d49bf87544013afa\"\n+\"checksum matches 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"efd7622e3022e1a6eaa602c4cea8912254e5582c9c692e9167714182244801b1\"\n \"checksum mdbook 0.0.21 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f1e2e9d848514dcfad4195788d0d42ae5153a477c191d75d5b84fab10f222fbd\"\n+\"checksum memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d8b629fb514376c675b98c1421e80b151d3817ac42d7c667717d282761418d20\"\n \"checksum memchr 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1dbccc0e46f1ea47b9f17e6d67c5a96bd27030519c519c9c91327e31275a47b4\"\n+\"checksum miniz-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"28eaee17666671fa872e567547e8428e83308ebe5808cdf6a0e28397dbe2c726\"\n+\"checksum miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f2f3b1cf331de6896aabf6e9d55dca90356cc9960cca7eaaf408a355ae919\"\n+\"checksum multimap 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9223f4774d08e06185e44e555b9a7561243d387bac49c78a6205c42d6975fbf2\"\n+\"checksum net2 0.2.29 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc01404e7568680f1259aa5729539f221cb1e6d047a0d9053cab4be8a73b5d67\"\n+\"checksum num 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"98b15ba84e910ea7a1973bccd3df7b31ae282bf9d8bd2897779950c9b8303d40\"\n+\"checksum num-bigint 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ba6d838b16e56da1b6c383d065ff1ec3c7d7797f65a3e8f6ba7092fd87820bac\"\n+\"checksum num-complex 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"148eb324ca772230853418731ffdf13531738b50f89b30692a01fcdcb0a64677\"\n+\"checksum num-integer 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ef1a4bf6f9174aa5783a9b4cc892cacd11aebad6c69ad027a0b65c6ca5f8aa37\"\n+\"checksum num-iter 0.1.33 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f7d1891bd7b936f12349b7d1403761c8a0b85a18b148e9da4429d5d102c1a41e\"\n+\"checksum num-rational 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c2dc5ea04020a8f18318ae485c751f8cfa1c0e69dcf465c29ddaaa64a313cc44\"\n \"checksum num-traits 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e1cbfa3781f3fe73dc05321bed52a06d2d491eaa764c52335cf4399f046ece99\"\n \"checksum num_cpus 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca313f1862c7ec3e0dfe8ace9fa91b1d9cb5c84ace3d00f5ec4216238e93c167\"\n \"checksum open 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3478ed1686bd1300c8a981a940abc92b06fac9cbef747f4c668d4e032ff7b842\"\n+\"checksum openssl 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb5d1663b73d10c6a3eda53e2e9d0346f822394e7b858d7257718f65f61dfbe2\"\n+\"checksum openssl-probe 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d98df0270d404ccd3c050a41d579c52d1db15375168bb3471e04ec0f5f378daf\"\n+\"checksum openssl-sys 0.9.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a5886d87d3e2a0d890bf62dc8944f5e3769a405f7e1e9ef6e517e47fd7a0897\"\n+\"checksum owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdf84f41639e037b484f93433aa3897863b561ed65c6e59c7073d7c561710f37\"\n \"checksum pest 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a6dda33d67c26f0aac90d324ab2eb7239c819fc7b2552fe9faa4fe88441edc8\"\n+\"checksum pkg-config 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3a8b4c6b8165cd1a1cd4b9b120978131389f64bdaf456435caa41e630edba903\"\n+\"checksum psapi-sys 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"abcd5d1a07d360e29727f757a9decb3ce8bc6e0efa8969cfaad669a8317a2478\"\n \"checksum pulldown-cmark 0.0.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9ab1e588ef8efd702c7ed9d2bd774db5e6f4d878bb5a1a9f371828fbdff6973\"\n \"checksum pulldown-cmark 0.0.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1058d7bb927ca067656537eec4e02c2b4b70eaaa129664c5b90c111e20326f41\"\n-\"checksum quick-error 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0aad603e8d7fb67da22dbdf1f4b826ce8829e406124109e73cf1b2454b93a71c\"\n+\"checksum quick-error 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3c36987d4978eb1be2e422b1e0423a557923a5c3e7e6f31d5699e9aafaefa469\"\n+\"checksum quote 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4c5cf478fe1006dbcc72567121d23dbdae5f1632386068c5c86ff4f645628504\"\n+\"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n+\"checksum racer 2.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b0d72b3afd67882adfca61d609fafb8d7aa5f9e814f12c32fcc6e171995920e8\"\n+\"checksum rand 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"022e0636ec2519ddae48154b028864bdce4eaf7d35226ab8e65c611be97b189d\"\n+\"checksum redox_syscall 0.1.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"29dbdfd4b9df8ab31dec47c6087b7b13cbf4a776f335e4de8efba8288dda075b\"\n+\"checksum regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4fd4ace6a8cf7860714a2c2280d6c1f7e6a413486c13298bbc86fd3da019402f\"\n \"checksum regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4278c17d0f6d62dfef0ab00028feb45bd7d2102843f80763474eeb1be8a10c01\"\n+\"checksum regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f9ec002c35e86791825ed294b50008eea9ddfc8def4420124fbc6b08db834957\"\n \"checksum regex-syntax 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2f9191b1f57603095f105d317e375d19b1c9c5c3185ea9633a99a6dcbed04457\"\n+\"checksum rls-analysis 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a62d88c341375c6f3f8b2e18b9b364896e7d3e7aa916907de717d0267e116506\"\n \"checksum rls-data 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fc4277ce3c57f456b11fe3145b181a844a25201bab5cbaa1978457e6e2f27d47\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n-\"checksum rustc-serialize 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)\" = \"684ce48436d6465300c9ea783b6b14c4361d6b8dcbb1375b486a69cc19e2dfb0\"\n-\"checksum serde 0.9.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a702319c807c016e51f672e5c77d6f0b46afddd744b5e437d6b8436b888b458f\"\n-\"checksum serde_json 0.9.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dbc45439552eb8fb86907a2c41c1fd0ef97458efb87ff7f878db466eb581824e\"\n+\"checksum rls-vfs 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"986eada111517bcb5a7a75205b3f2b70c82e7766653cca61a23f5afce79bdb94\"\n+\"checksum rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3058a43ada2c2d0b92b3ae38007a2d0fa5e9db971be260e0171408a4ff471c95\"\n+\"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n+\"checksum rustfmt 0.8.4 (git+https://github.com/rust-lang-nursery/rustfmt)\" = \"<none>\"\n+\"checksum same-file 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d931a44fdaa43b8637009e7632a02adc4f2b2e0733c08caa4cf00e8da4a117a7\"\n+\"checksum semver 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a3186ec9e65071a2095434b1f5bb24838d4e8e130f584c790f6033c79943537\"\n+\"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n+\"checksum serde 0.9.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"34b623917345a631dc9608d5194cc206b3fe6c3554cd1c75b937e55e285254af\"\n+\"checksum serde 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"38a3db3a5757f68069aba764b793823ea9fb9717c42c016f8903f8add50f508a\"\n+\"checksum serde_derive 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e46ef71ee001a4279a4513e79a6ebbb59da3a4987bf77a6df2e5534cd6f21d82\"\n+\"checksum serde_derive_internals 0.15.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"021c338d22c7e30f957a6ab7e388cb6098499dda9fd4ba1661ee074ca7a180d1\"\n+\"checksum serde_ignored 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c10e798e4405d7dcec3658989e35ee6706f730a9ed7c1184d5ebd84317e82f46\"\n+\"checksum serde_json 0.9.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad8bcf487be7d2e15d3d543f04312de991d631cfe1b43ea0ade69e6a8a5b16a1\"\n+\"checksum serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48b04779552e92037212c3615370f6bd57a40ebba7f20e554ff9f55e41a69a7b\"\n+\"checksum shell-escape 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd5cc96481d54583947bfe88bf30c23d53f883c6cd0145368b69989d97b84ef8\"\n+\"checksum stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15132e0e364248108c5e2c02e3ab539be8d6f5d52a01ca9bbf27ed657316f02b\"\n+\"checksum strings 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"54f86446ab480b4f60782188f4f78886465c5793aee248cbb48b7fdc0d022420\"\n+\"checksum strsim 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"67f84c44fbb2f91db7fef94554e6b2ac05909c9c0b0bc23bb98d3a1aebfe7f7c\"\n \"checksum strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b4d15c810519a91cf877e7e36e63fe068815c678181439f2f29e2562147c3694\"\n+\"checksum syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3b891b9015c88c576343b9b3e41c2c11a51c219ef067b264bd9c8aa9b441dad\"\n+\"checksum syn 0.8.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ae6fb0dcc9bd85f89a1a4adc0df2fd90c90c98849d61433983dd7a9df6363f7\"\n+\"checksum synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a393066ed9010ebaed60b9eafa373d4b1baac186dd7e008555b0f702b51945b6\"\n+\"checksum syntex_errors 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9e52bffe6202cfb67587784cf23e0ec5bf26d331eef4922a16d5c42e12aa1e9b\"\n+\"checksum syntex_errors 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"867cc5c2d7140ae7eaad2ae9e8bf39cb18a67ca651b7834f88d46ca98faadb9c\"\n+\"checksum syntex_pos 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"955ef4b16af4c468e4680d1497f873ff288f557d338180649e18f915af5e15ac\"\n+\"checksum syntex_pos 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"13ad4762fe52abc9f4008e85c4fb1b1fe3aa91ccb99ff4826a439c7c598e1047\"\n+\"checksum syntex_syntax 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"76a302e717e348aa372ff577791c3832395650073b8d8432f8b3cb170b34afde\"\n+\"checksum syntex_syntax 0.58.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6e0e4dbae163dd98989464c23dd503161b338790640e11537686f2ef0f25c791\"\n+\"checksum tar 0.4.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab0ef9ead2fe0aa9e18475a96a207bfd5143f4124779ef7429503a8665416ce8\"\n+\"checksum tempdir 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"87974a6f5c1dfb344d733055601650059a3363de2a6104819293baff662132d6\"\n+\"checksum term 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d168af3930b369cfe245132550579d47dfd873d69470755a19c2c6568dbbd989\"\n \"checksum term_size 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07b6c1ac5b3fffd75073276bca1ceed01f67a28537097a2a9539e116e50fb21a\"\n-\"checksum thread-id 3.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4437c97558c70d129e40629a5b385b3fb1ffac301e63941335e4d354081ec14a\"\n+\"checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03\"\n+\"checksum thread-id 3.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8df7875b676fddfadffd96deea3b1124e5ede707d4884248931077518cf1f773\"\n+\"checksum thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8576dbbfcaef9641452d5cf0df9b0e7eeab7694956dd33bb61515fb8f18cfdd5\"\n \"checksum thread_local 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c85048c6260d17cf486ceae3282d9fb6b90be220bf5b28c400f5485ffc29f0c7\"\n+\"checksum time 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ffd7ccbf969a892bf83f1e441126968a07a3941c24ff522a26af9f9f4585d1a3\"\n \"checksum toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0590d72182e50e879c4da3b11c6488dae18fccb1ae0c7a3eda18e16795844796\"\n-\"checksum toml 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3474f3c6eaf32eedb4f4a66a26214f020f828a6d96c37e38a35e3a379bbcfd11\"\n-\"checksum unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"18127285758f0e2c6cf325bb3f3d138a12fee27de4f23e146cd6a179f26c2cf3\"\n+\"checksum toml 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"736b60249cb25337bc196faa43ee12c705e426f3d55c214d73a4e7be06f92cb4\"\n+\"checksum toml 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bd86ad9ebee246fdedd610e0f6d0587b754a3d81438db930a244d0480ed7878f\"\n+\"checksum toml 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4cc5dbfb20a481e64b99eb7ae280859ec76730c7191570ba5edaa962394edb0a\"\n+\"checksum typed-arena 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8e2f9dc90da4f9d66ffc9ad3ead2c7d57582a26f4a3292d2ce7011bd29965100\"\n+\"checksum unicode-bidi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3a078ebdd62c0e71a709c3d53d2af693fe09fe93fbff8344aebe289b78f9032\"\n+\"checksum unicode-normalization 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e28fa37426fceeb5cf8f41ee273faa7c82c47dc8fba5853402841e665fcd86ff\"\n+\"checksum unicode-segmentation 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c3bc443ded17b11305ffffe6b37e2076f328a5a8cb6aa877b1b98f77699e98b5\"\n+\"checksum unicode-segmentation 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a8083c594e02b8ae1654ae26f0ade5158b119bd88ad0e8227a5d8fcd72407946\"\n \"checksum unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bf3a113775714a22dcb774d8ea3655c53a32debae63a063acc00a91cc586245f\"\n+\"checksum unicode-xid 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36dff09cafb4ec7c8cf0023eb0b686cb6ce65499116a12201c9e11840ca01beb\"\n+\"checksum unicode-xid 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c1f860d7d29cf02cb2f3f359fd35991af3d30bac52c57d265a3c461074cb4dc\"\n \"checksum unreachable 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1f2ae5ddb18e1c92664717616dd9549dde73f539f01bd7b77c2edb2446bdff91\"\n+\"checksum url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f5ba8a749fb4479b043733416c244fa9d1d3af3d7c23804944651c8a448cb87e\"\n+\"checksum url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"74e7d099f1ee52f823d4bdd60c93c3602043c728f5db3b97bdb548467f7bddea\"\n+\"checksum user32-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4ef4711d107b21b410a3a974b1204d9accc8b10dad75d8324b5d755de1617d47\"\n+\"checksum utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a1ca13c08c41c9c3e04224ed9ff80461d97e121589ff27c753a16cb10830ae0f\"\n \"checksum utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"662fab6525a98beff2921d7f61a39e7d59e0b425ebc7d0d9e66d316e55124122\"\n-\"checksum vec_map 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f8cdc8b93bd0198ed872357fb2e667f7125646b1762f16d60b2c96350d361897\"\n+\"checksum vec_map 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cac5efe5cb0fa14ec2f84f83c701c562ee63f6dcc680861b21d65c682adfb05f\"\n \"checksum void 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n+\"checksum walkdir 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bb08f9e670fab86099470b97cd2b252d6527f0b3cc1401acdb595ffc9dd288ff\"\n \"checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n \"checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\"\n+\"checksum ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d59cefebd0c892fa2dd6de581e937301d8552cb44489cdff035c6187cb63fa5e\"\n+\"checksum xattr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5f04de8a1346489a2f9e9bd8526b73d135ec554227b17568456e86aa35b6f3fc\"\n+\"checksum xz2 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e9510bdf100731599107c61f77daf46713a69a568f75458999c1f9dbf6ba25b0\"\n+\"checksum yaml-rust 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e66366e18dc58b46801afbf2ca7661a9f59cc8c5962c29892b6039b4f86fa992\""}, {"sha": "85a6df3573ae120f377870a59a5162b3188c809f", "filename": "src/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -13,10 +13,7 @@ members = [\n   \"tools/build-manifest\",\n   \"tools/remote-test-client\",\n   \"tools/remote-test-server\",\n-]\n-\n-# These projects have their own Cargo.lock\n-exclude = [\n+  \"tools/rust-installer\",\n   \"tools/cargo\",\n   \"tools/rls\",\n ]\n@@ -37,3 +34,6 @@ debug-assertions = false\n [profile.test]\n debug = false\n debug-assertions = false\n+\n+[replace]\n+\"https://github.com/rust-lang/cargo#0.20.0\" = { path = \"tools/cargo\" }"}, {"sha": "eb2cef133a34f2401b014f7a9b545bb7535845ab", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -38,7 +38,24 @@ use std::path::PathBuf;\n use std::process::{Command, ExitStatus};\n \n fn main() {\n-    let args = env::args_os().skip(1).collect::<Vec<_>>();\n+    let mut args = env::args_os().skip(1).collect::<Vec<_>>();\n+\n+    // Append metadata suffix for internal crates. See the corresponding entry\n+    // in bootstrap/lib.rs for details.\n+    if let Ok(s) = env::var(\"RUSTC_METADATA_SUFFIX\") {\n+        for i in 1..args.len() {\n+            // Dirty code for borrowing issues\n+            let mut new = None;\n+            if let Some(current_as_str) = args[i].to_str() {\n+                if (&*args[i - 1] == \"-C\" && current_as_str.starts_with(\"metadata\")) ||\n+                   current_as_str.starts_with(\"-Cmetadata\") {\n+                    new = Some(format!(\"{}-{}\", current_as_str, s));\n+                }\n+            }\n+            if let Some(new) = new { args[i] = new.into(); }\n+        }\n+    }\n+\n     // Detect whether or not we're a build script depending on whether --target\n     // is passed (a bit janky...)\n     let target = args.windows(2)"}, {"sha": "bfba1a0dede24d50cb9929afb0a6d3b1d8b0ec61", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 71, "deletions": 6, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -14,6 +14,7 @@\n import datetime\n import hashlib\n import os\n+import re\n import shutil\n import subprocess\n import sys\n@@ -126,13 +127,13 @@ def unpack(tarball, dst, verbose=False, match=None):\n             shutil.move(tp, fp)\n     shutil.rmtree(os.path.join(dst, fname))\n \n-def run(args, verbose=False, exception=False):\n+def run(args, verbose=False, exception=False, cwd=None):\n     if verbose:\n         print(\"running: \" + ' '.join(args))\n     sys.stdout.flush()\n     # Use Popen here instead of call() as it apparently allows powershell on\n     # Windows to not lock up waiting for input presumably.\n-    ret = subprocess.Popen(args)\n+    ret = subprocess.Popen(args, cwd=cwd)\n     code = ret.wait()\n     if code != 0:\n         err = \"failed to run: \" + ' '.join(args)\n@@ -297,8 +298,10 @@ def bin_root(self):\n \n     def get_toml(self, key):\n         for line in self.config_toml.splitlines():\n-            if line.startswith(key + ' ='):\n-                return self.get_string(line)\n+            match = re.match(r'^{}\\s*=(.*)$'.format(key), line)\n+            if match is not None:\n+                value = match.group(1)\n+                return self.get_string(value) or value.strip()\n         return None\n \n     def get_mk(self, key):\n@@ -329,6 +332,8 @@ def rustc(self):\n \n     def get_string(self, line):\n         start = line.find('\"')\n+        if start == -1:\n+            return None\n         end = start + 1 + line[start + 1:].find('\"')\n         return line[start + 1:end]\n \n@@ -386,12 +391,22 @@ def build_bootstrap(self):\n             args.append(\"--frozen\")\n         self.run(args, env)\n \n-    def run(self, args, env):\n-        proc = subprocess.Popen(args, env=env)\n+    def run(self, args, env=None, cwd=None):\n+        proc = subprocess.Popen(args, env=env, cwd=cwd)\n         ret = proc.wait()\n         if ret != 0:\n             sys.exit(ret)\n \n+    def output(self, args, env=None, cwd=None):\n+        default_encoding = sys.getdefaultencoding()\n+        proc = subprocess.Popen(args, stdout=subprocess.PIPE, env=env, cwd=cwd)\n+        (out, err) = proc.communicate()\n+        ret = proc.wait()\n+        if ret != 0:\n+            print(out)\n+            sys.exit(ret)\n+        return out.decode(default_encoding)\n+\n     def build_triple(self):\n         default_encoding = sys.getdefaultencoding()\n         config = self.get_toml('build')\n@@ -529,6 +544,54 @@ def build_triple(self):\n \n         return \"{}-{}\".format(cputype, ostype)\n \n+    def update_submodules(self):\n+        if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n+            self.get_toml('submodules') == \"false\" or \\\n+            self.get_mk('CFG_DISABLE_MANAGE_SUBMODULES') == \"1\":\n+            return\n+\n+        print('Updating submodules')\n+        output = self.output([\"git\", \"submodule\", \"status\"], cwd=self.rust_root)\n+        submodules = []\n+        for line in output.splitlines():\n+            # NOTE `git submodule status` output looks like this:\n+            #\n+            # -5066b7dcab7e700844b0e2ba71b8af9dc627a59b src/liblibc\n+            # +b37ef24aa82d2be3a3cc0fe89bf82292f4ca181c src/compiler-rt (remotes/origin/..)\n+            #  e058ca661692a8d01f8cf9d35939dfe3105ce968 src/jemalloc (3.6.0-533-ge058ca6)\n+            #\n+            # The first character can be '-', '+' or ' ' and denotes the\n+            # `State` of the submodule Right next to this character is the\n+            # SHA-1 of the submodule HEAD And after that comes the path to the\n+            # submodule\n+            path = line[1:].split(' ')[1]\n+            submodules.append([path, line[0]])\n+\n+        self.run([\"git\", \"submodule\", \"sync\"], cwd=self.rust_root)\n+\n+        for submod in submodules:\n+            path, status = submod\n+            if path.endswith('llvm') and \\\n+                (self.get_toml('llvm-config') or self.get_mk('CFG_LLVM_ROOT')):\n+                continue\n+            if path.endswith('jemalloc') and \\\n+                (self.get_toml('jemalloc') or self.get_mk('CFG_JEMALLOC_ROOT')):\n+                continue\n+            submod_path = os.path.join(self.rust_root, path)\n+\n+            if status == ' ':\n+                self.run([\"git\", \"reset\", \"--hard\"], cwd=submod_path)\n+                self.run([\"git\", \"clean\", \"-fdx\"], cwd=submod_path)\n+            elif status == '+':\n+                self.run([\"git\", \"submodule\", \"update\", path], cwd=self.rust_root)\n+                self.run([\"git\", \"reset\", \"--hard\"], cwd=submod_path)\n+                self.run([\"git\", \"clean\", \"-fdx\"], cwd=submod_path)\n+            elif status == '-':\n+                self.run([\"git\", \"submodule\", \"init\", path], cwd=self.rust_root)\n+                self.run([\"git\", \"submodule\", \"update\", path], cwd=self.rust_root)\n+            else:\n+                raise ValueError('unknown submodule status: ' + status)\n+\n def bootstrap():\n     parser = argparse.ArgumentParser(description='Build rust')\n     parser.add_argument('--config')\n@@ -597,6 +660,8 @@ def bootstrap():\n     else:\n         rb._download_url = 'https://static.rust-lang.org'\n \n+    rb.update_submodules()\n+\n     # Fetch/build the bootstrap\n     rb.build = rb.build_triple()\n     rb.download_stage0()"}, {"sha": "0fb597564e33de15c2bc6defc8fd35273dfb43df", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -99,7 +99,9 @@ pub struct Config {\n     // Fallback musl-root for all targets\n     pub musl_root: Option<PathBuf>,\n     pub prefix: Option<PathBuf>,\n+    pub sysconfdir: Option<PathBuf>,\n     pub docdir: Option<PathBuf>,\n+    pub bindir: Option<PathBuf>,\n     pub libdir: Option<PathBuf>,\n     pub libdir_relative: Option<PathBuf>,\n     pub mandir: Option<PathBuf>,\n@@ -165,9 +167,11 @@ struct Build {\n #[derive(RustcDecodable, Default, Clone)]\n struct Install {\n     prefix: Option<String>,\n-    mandir: Option<String>,\n+    sysconfdir: Option<String>,\n     docdir: Option<String>,\n+    bindir: Option<String>,\n     libdir: Option<String>,\n+    mandir: Option<String>,\n }\n \n /// TOML representation of how the LLVM build is configured.\n@@ -315,9 +319,11 @@ impl Config {\n \n         if let Some(ref install) = toml.install {\n             config.prefix = install.prefix.clone().map(PathBuf::from);\n-            config.mandir = install.mandir.clone().map(PathBuf::from);\n+            config.sysconfdir = install.sysconfdir.clone().map(PathBuf::from);\n             config.docdir = install.docdir.clone().map(PathBuf::from);\n+            config.bindir = install.bindir.clone().map(PathBuf::from);\n             config.libdir = install.libdir.clone().map(PathBuf::from);\n+            config.mandir = install.mandir.clone().map(PathBuf::from);\n         }\n \n         if let Some(ref llvm) = toml.llvm {\n@@ -523,9 +529,15 @@ impl Config {\n                 \"CFG_PREFIX\" => {\n                     self.prefix = Some(PathBuf::from(value));\n                 }\n+                \"CFG_SYSCONFDIR\" => {\n+                    self.sysconfdir = Some(PathBuf::from(value));\n+                }\n                 \"CFG_DOCDIR\" => {\n                     self.docdir = Some(PathBuf::from(value));\n                 }\n+                \"CFG_BINDIR\" => {\n+                    self.bindir = Some(PathBuf::from(value));\n+                }\n                 \"CFG_LIBDIR\" => {\n                     self.libdir = Some(PathBuf::from(value));\n                 }"}, {"sha": "df180be4e27ab0836b6df75d4b939aeac3c4fe7d", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -160,15 +160,22 @@\n # Instead of installing to /usr/local, install to this path instead.\n #prefix = \"/usr/local\"\n \n+# Where to install system configuration files\n+# If this is a relative path, it will get installed in `prefix` above\n+#sysconfdir = \"/etc\"\n+\n+# Where to install documentation in `prefix` above\n+#docdir = \"share/doc/rust\"\n+\n+# Where to install binaries in `prefix` above\n+#bindir = \"bin\"\n+\n # Where to install libraries in `prefix` above\n #libdir = \"lib\"\n \n # Where to install man pages in `prefix` above\n #mandir = \"share/man\"\n \n-# Where to install documentation in `prefix` above\n-#docdir = \"share/doc/rust\"\n-\n # =============================================================================\n # Options for compiling Rust code itself\n # ============================================================================="}, {"sha": "511f2c9e80ec72e732caba01da7cbb468850745b", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 71, "deletions": 70, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -26,12 +26,6 @@ use std::process::{Command, Stdio};\n \n use build_helper::output;\n \n-#[cfg(not(target_os = \"solaris\"))]\n-const SH_CMD: &'static str = \"sh\";\n-// On Solaris, sh is the historical bourne shell, not a POSIX shell, or bash.\n-#[cfg(target_os = \"solaris\")]\n-const SH_CMD: &'static str = \"bash\";\n-\n use {Build, Compiler, Mode};\n use channel;\n use util::{cp_r, libdir, is_dylib, cp_filtered, copy, exe};\n@@ -55,6 +49,10 @@ pub fn tmpdir(build: &Build) -> PathBuf {\n     build.out.join(\"tmp/dist\")\n }\n \n+fn rust_installer(build: &Build) -> Command {\n+    build.tool_cmd(&Compiler::new(0, &build.config.build), \"rust-installer\")\n+}\n+\n /// Builds the `rust-docs` installer component.\n ///\n /// Slurps up documentation from the `stage`'s `host`.\n@@ -74,14 +72,14 @@ pub fn docs(build: &Build, stage: u32, host: &str) {\n     let src = build.out.join(host).join(\"doc\");\n     cp_r(&src, &dst);\n \n-    let mut cmd = Command::new(SH_CMD);\n-    cmd.arg(sanitize_sh(&build.src.join(\"src/rust-installer/gen-installer.sh\")))\n+    let mut cmd = rust_installer(build);\n+    cmd.arg(\"generate\")\n        .arg(\"--product-name=Rust-Documentation\")\n        .arg(\"--rel-manifest-dir=rustlib\")\n        .arg(\"--success-message=Rust-documentation-is-installed.\")\n-       .arg(format!(\"--image-dir={}\", sanitize_sh(&image)))\n-       .arg(format!(\"--work-dir={}\", sanitize_sh(&tmpdir(build))))\n-       .arg(format!(\"--output-dir={}\", sanitize_sh(&distdir(build))))\n+       .arg(\"--image-dir\").arg(&image)\n+       .arg(\"--work-dir\").arg(&tmpdir(build))\n+       .arg(\"--output-dir\").arg(&distdir(build))\n        .arg(format!(\"--package-name={}-{}\", name, host))\n        .arg(\"--component-name=rust-docs\")\n        .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n@@ -124,14 +122,14 @@ pub fn mingw(build: &Build, host: &str) {\n        .arg(host);\n     build.run(&mut cmd);\n \n-    let mut cmd = Command::new(SH_CMD);\n-    cmd.arg(sanitize_sh(&build.src.join(\"src/rust-installer/gen-installer.sh\")))\n+    let mut cmd = rust_installer(build);\n+    cmd.arg(\"generate\")\n        .arg(\"--product-name=Rust-MinGW\")\n        .arg(\"--rel-manifest-dir=rustlib\")\n        .arg(\"--success-message=Rust-MinGW-is-installed.\")\n-       .arg(format!(\"--image-dir={}\", sanitize_sh(&image)))\n-       .arg(format!(\"--work-dir={}\", sanitize_sh(&tmpdir(build))))\n-       .arg(format!(\"--output-dir={}\", sanitize_sh(&distdir(build))))\n+       .arg(\"--image-dir\").arg(&image)\n+       .arg(\"--work-dir\").arg(&tmpdir(build))\n+       .arg(\"--output-dir\").arg(&distdir(build))\n        .arg(format!(\"--package-name={}-{}\", name, host))\n        .arg(\"--component-name=rust-mingw\")\n        .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n@@ -190,15 +188,15 @@ pub fn rustc(build: &Build, stage: u32, host: &str) {\n     }\n \n     // Finally, wrap everything up in a nice tarball!\n-    let mut cmd = Command::new(SH_CMD);\n-    cmd.arg(sanitize_sh(&build.src.join(\"src/rust-installer/gen-installer.sh\")))\n+    let mut cmd = rust_installer(build);\n+    cmd.arg(\"generate\")\n        .arg(\"--product-name=Rust\")\n        .arg(\"--rel-manifest-dir=rustlib\")\n        .arg(\"--success-message=Rust-is-ready-to-roll.\")\n-       .arg(format!(\"--image-dir={}\", sanitize_sh(&image)))\n-       .arg(format!(\"--work-dir={}\", sanitize_sh(&tmpdir(build))))\n-       .arg(format!(\"--output-dir={}\", sanitize_sh(&distdir(build))))\n-       .arg(format!(\"--non-installed-overlay={}\", sanitize_sh(&overlay)))\n+       .arg(\"--image-dir\").arg(&image)\n+       .arg(\"--work-dir\").arg(&tmpdir(build))\n+       .arg(\"--output-dir\").arg(&distdir(build))\n+       .arg(\"--non-installed-overlay\").arg(&overlay)\n        .arg(format!(\"--package-name={}-{}\", name, host))\n        .arg(\"--component-name=rustc\")\n        .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n@@ -300,14 +298,14 @@ pub fn std(build: &Build, compiler: &Compiler, target: &str) {\n     let src = build.sysroot(compiler).join(\"lib/rustlib\");\n     cp_r(&src.join(target), &dst);\n \n-    let mut cmd = Command::new(SH_CMD);\n-    cmd.arg(sanitize_sh(&build.src.join(\"src/rust-installer/gen-installer.sh\")))\n+    let mut cmd = rust_installer(build);\n+    cmd.arg(\"generate\")\n        .arg(\"--product-name=Rust\")\n        .arg(\"--rel-manifest-dir=rustlib\")\n        .arg(\"--success-message=std-is-standing-at-the-ready.\")\n-       .arg(format!(\"--image-dir={}\", sanitize_sh(&image)))\n-       .arg(format!(\"--work-dir={}\", sanitize_sh(&tmpdir(build))))\n-       .arg(format!(\"--output-dir={}\", sanitize_sh(&distdir(build))))\n+       .arg(\"--image-dir\").arg(&image)\n+       .arg(\"--work-dir\").arg(&tmpdir(build))\n+       .arg(\"--output-dir\").arg(&distdir(build))\n        .arg(format!(\"--package-name={}-{}\", name, target))\n        .arg(format!(\"--component-name=rust-std-{}\", target))\n        .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n@@ -356,14 +354,14 @@ pub fn analysis(build: &Build, compiler: &Compiler, target: &str) {\n     println!(\"image_src: {:?}, dst: {:?}\", image_src, dst);\n     cp_r(&image_src, &dst);\n \n-    let mut cmd = Command::new(SH_CMD);\n-    cmd.arg(sanitize_sh(&build.src.join(\"src/rust-installer/gen-installer.sh\")))\n+    let mut cmd = rust_installer(build);\n+    cmd.arg(\"generate\")\n        .arg(\"--product-name=Rust\")\n        .arg(\"--rel-manifest-dir=rustlib\")\n        .arg(\"--success-message=save-analysis-saved.\")\n-       .arg(format!(\"--image-dir={}\", sanitize_sh(&image)))\n-       .arg(format!(\"--work-dir={}\", sanitize_sh(&tmpdir(build))))\n-       .arg(format!(\"--output-dir={}\", sanitize_sh(&distdir(build))))\n+       .arg(\"--image-dir\").arg(&image)\n+       .arg(\"--work-dir\").arg(&tmpdir(build))\n+       .arg(\"--output-dir\").arg(&distdir(build))\n        .arg(format!(\"--package-name={}-{}\", name, target))\n        .arg(format!(\"--component-name=rust-analysis-{}\", target))\n        .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n@@ -471,13 +469,17 @@ pub fn rust_src(build: &Build) {\n     write_file(&plain_dst_src.join(\"version\"), build.rust_version().as_bytes());\n \n     // Create plain source tarball\n-    let tarball = rust_src_location(build);\n+    let mut tarball = rust_src_location(build);\n+    tarball.set_extension(\"\"); // strip .gz\n+    tarball.set_extension(\"\"); // strip .tar\n     if let Some(dir) = tarball.parent() {\n         t!(fs::create_dir_all(dir));\n     }\n-    let mut cmd = Command::new(\"tar\");\n-    cmd.arg(\"-czf\").arg(sanitize_sh(&tarball))\n-       .arg(&plain_name)\n+    let mut cmd = rust_installer(build);\n+    cmd.arg(\"tarball\")\n+       .arg(\"--input\").arg(&plain_name)\n+       .arg(\"--output\").arg(&tarball)\n+       .arg(\"--work-dir=.\")\n        .current_dir(tmpdir(build));\n     build.run(&mut cmd);\n \n@@ -521,14 +523,14 @@ pub fn rust_src(build: &Build) {\n     }\n \n     // Create source tarball in rust-installer format\n-    let mut cmd = Command::new(SH_CMD);\n-    cmd.arg(sanitize_sh(&build.src.join(\"src/rust-installer/gen-installer.sh\")))\n+    let mut cmd = rust_installer(build);\n+    cmd.arg(\"generate\")\n        .arg(\"--product-name=Rust\")\n        .arg(\"--rel-manifest-dir=rustlib\")\n        .arg(\"--success-message=Awesome-Source.\")\n-       .arg(format!(\"--image-dir={}\", sanitize_sh(&image)))\n-       .arg(format!(\"--work-dir={}\", sanitize_sh(&tmpdir(build))))\n-       .arg(format!(\"--output-dir={}\", sanitize_sh(&distdir(build))))\n+       .arg(\"--image-dir\").arg(&image)\n+       .arg(\"--work-dir\").arg(&tmpdir(build))\n+       .arg(\"--output-dir\").arg(&distdir(build))\n        .arg(format!(\"--package-name={}\", name))\n        .arg(\"--component-name=rust-src\")\n        .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n@@ -594,7 +596,7 @@ pub fn cargo(build: &Build, stage: u32, target: &str) {\n \n     // Prepare the image directory\n     t!(fs::create_dir_all(image.join(\"share/zsh/site-functions\")));\n-    t!(fs::create_dir_all(image.join(\"etc/bash_completions.d\")));\n+    t!(fs::create_dir_all(image.join(\"etc/bash_completion.d\")));\n     let cargo = build.cargo_out(&compiler, Mode::Tool, target)\n                      .join(exe(\"cargo\", target));\n     install(&cargo, &image.join(\"bin\"), 0o755);\n@@ -604,7 +606,7 @@ pub fn cargo(build: &Build, stage: u32, target: &str) {\n     }\n     install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n     copy(&etc.join(\"cargo.bashcomp.sh\"),\n-         &image.join(\"etc/bash_completions.d/cargo\"));\n+         &image.join(\"etc/bash_completion.d/cargo\"));\n     let doc = image.join(\"share/doc/cargo\");\n     install(&src.join(\"README.md\"), &doc, 0o644);\n     install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n@@ -622,15 +624,15 @@ pub fn cargo(build: &Build, stage: u32, target: &str) {\n     t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n \n     // Generate the installer tarball\n-    let mut cmd = Command::new(\"sh\");\n-    cmd.arg(sanitize_sh(&build.src.join(\"src/rust-installer/gen-installer.sh\")))\n+    let mut cmd = rust_installer(build);\n+    cmd.arg(\"generate\")\n        .arg(\"--product-name=Rust\")\n        .arg(\"--rel-manifest-dir=rustlib\")\n        .arg(\"--success-message=Rust-is-ready-to-roll.\")\n-       .arg(format!(\"--image-dir={}\", sanitize_sh(&image)))\n-       .arg(format!(\"--work-dir={}\", sanitize_sh(&tmpdir(build))))\n-       .arg(format!(\"--output-dir={}\", sanitize_sh(&distdir(build))))\n-       .arg(format!(\"--non-installed-overlay={}\", sanitize_sh(&overlay)))\n+       .arg(\"--image-dir\").arg(&image)\n+       .arg(\"--work-dir\").arg(&tmpdir(build))\n+       .arg(\"--output-dir\").arg(&distdir(build))\n+       .arg(\"--non-installed-overlay\").arg(&overlay)\n        .arg(format!(\"--package-name={}-{}\", name, target))\n        .arg(\"--component-name=cargo\")\n        .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n@@ -671,15 +673,15 @@ pub fn rls(build: &Build, stage: u32, target: &str) {\n     t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n \n     // Generate the installer tarball\n-    let mut cmd = Command::new(\"sh\");\n-    cmd.arg(sanitize_sh(&build.src.join(\"src/rust-installer/gen-installer.sh\")))\n+    let mut cmd = rust_installer(build);\n+    cmd.arg(\"generate\")\n        .arg(\"--product-name=Rust\")\n        .arg(\"--rel-manifest-dir=rustlib\")\n        .arg(\"--success-message=RLS-ready-to-serve.\")\n-       .arg(format!(\"--image-dir={}\", sanitize_sh(&image)))\n-       .arg(format!(\"--work-dir={}\", sanitize_sh(&tmpdir(build))))\n-       .arg(format!(\"--output-dir={}\", sanitize_sh(&distdir(build))))\n-       .arg(format!(\"--non-installed-overlay={}\", sanitize_sh(&overlay)))\n+       .arg(\"--image-dir\").arg(&image)\n+       .arg(\"--work-dir\").arg(&tmpdir(build))\n+       .arg(\"--output-dir\").arg(&distdir(build))\n+       .arg(\"--non-installed-overlay\").arg(&overlay)\n        .arg(format!(\"--package-name={}-{}\", name, target))\n        .arg(\"--component-name=rls\")\n        .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n@@ -730,29 +732,28 @@ pub fn extended(build: &Build, stage: u32, target: &str) {\n     // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n     // the std files during uninstall. To do this ensure that rustc comes\n     // before rust-std in the list below.\n-    let mut input_tarballs = format!(\"{},{},{},{},{},{}\",\n-                                     sanitize_sh(&rustc_installer),\n-                                     sanitize_sh(&cargo_installer),\n-                                     sanitize_sh(&rls_installer),\n-                                     sanitize_sh(&analysis_installer),\n-                                     sanitize_sh(&docs_installer),\n-                                     sanitize_sh(&std_installer));\n+    let mut tarballs = vec![rustc_installer, cargo_installer, rls_installer,\n+                            analysis_installer, docs_installer, std_installer];\n     if target.contains(\"pc-windows-gnu\") {\n-        input_tarballs.push_str(\",\");\n-        input_tarballs.push_str(&sanitize_sh(&mingw_installer));\n+        tarballs.push(mingw_installer);\n+    }\n+    let mut input_tarballs = tarballs[0].as_os_str().to_owned();\n+    for tarball in &tarballs[1..] {\n+        input_tarballs.push(\",\");\n+        input_tarballs.push(tarball);\n     }\n \n-    let mut cmd = Command::new(SH_CMD);\n-    cmd.arg(sanitize_sh(&build.src.join(\"src/rust-installer/combine-installers.sh\")))\n+    let mut cmd = rust_installer(build);\n+    cmd.arg(\"combine\")\n        .arg(\"--product-name=Rust\")\n        .arg(\"--rel-manifest-dir=rustlib\")\n        .arg(\"--success-message=Rust-is-ready-to-roll.\")\n-       .arg(format!(\"--work-dir={}\", sanitize_sh(&work)))\n-       .arg(format!(\"--output-dir={}\", sanitize_sh(&distdir(build))))\n+       .arg(\"--work-dir\").arg(&work)\n+       .arg(\"--output-dir\").arg(&distdir(build))\n        .arg(format!(\"--package-name={}-{}\", pkgname(build, \"rust\"), target))\n        .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-       .arg(format!(\"--input-tarballs={}\", input_tarballs))\n-       .arg(format!(\"--non-installed-overlay={}\", sanitize_sh(&overlay)));\n+       .arg(\"--input-tarballs\").arg(input_tarballs)\n+       .arg(\"--non-installed-overlay\").arg(&overlay);\n     build.run(&mut cmd);\n \n     let mut license = String::new();"}, {"sha": "dce0b1670e181612c25fb045b992e036154e3d99", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 98, "deletions": 55, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -21,67 +21,110 @@ use std::process::Command;\n use Build;\n use dist::{sanitize_sh, tmpdir};\n \n-/// Installs everything.\n-pub fn install(build: &Build, stage: u32, host: &str) {\n-    let prefix_default = PathBuf::from(\"/usr/local\");\n-    let docdir_default = PathBuf::from(\"share/doc/rust\");\n-    let mandir_default = PathBuf::from(\"share/man\");\n-    let libdir_default = PathBuf::from(\"lib\");\n-    let prefix = build.config.prefix.as_ref().unwrap_or(&prefix_default);\n-    let docdir = build.config.docdir.as_ref().unwrap_or(&docdir_default);\n-    let libdir = build.config.libdir.as_ref().unwrap_or(&libdir_default);\n-    let mandir = build.config.mandir.as_ref().unwrap_or(&mandir_default);\n-\n-    let docdir = prefix.join(docdir);\n-    let libdir = prefix.join(libdir);\n-    let mandir = prefix.join(mandir);\n-\n-    let destdir = env::var_os(\"DESTDIR\").map(PathBuf::from);\n-\n-    let prefix = add_destdir(&prefix, &destdir);\n-    let docdir = add_destdir(&docdir, &destdir);\n-    let libdir = add_destdir(&libdir, &destdir);\n-    let mandir = add_destdir(&mandir, &destdir);\n-\n-    let empty_dir = build.out.join(\"tmp/empty_dir\");\n-    t!(fs::create_dir_all(&empty_dir));\n-    if build.config.docs {\n-        install_sh(&build, \"docs\", \"rust-docs\", &build.rust_package_vers(),\n-                   stage, host, &prefix, &docdir, &libdir, &mandir, &empty_dir);\n-    }\n+pub struct Installer<'a> {\n+    build: &'a Build,\n+    prefix: PathBuf,\n+    sysconfdir: PathBuf,\n+    docdir: PathBuf,\n+    bindir: PathBuf,\n+    libdir: PathBuf,\n+    mandir: PathBuf,\n+}\n \n-    for target in build.config.target.iter() {\n-        install_sh(&build, \"std\", \"rust-std\", &build.rust_package_vers(),\n-                   stage, target, &prefix, &docdir, &libdir, &mandir, &empty_dir);\n-    }\n+impl<'a> Installer<'a> {\n+    pub fn new(build: &'a Build) -> Installer<'a> {\n+        let prefix_default = PathBuf::from(\"/usr/local\");\n+        let sysconfdir_default = PathBuf::from(\"/etc\");\n+        let docdir_default = PathBuf::from(\"share/doc/rust\");\n+        let bindir_default = PathBuf::from(\"bin\");\n+        let libdir_default = PathBuf::from(\"lib\");\n+        let mandir_default = PathBuf::from(\"share/man\");\n+        let prefix = build.config.prefix.as_ref().unwrap_or(&prefix_default);\n+        let sysconfdir = build.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n+        let docdir = build.config.docdir.as_ref().unwrap_or(&docdir_default);\n+        let bindir = build.config.bindir.as_ref().unwrap_or(&bindir_default);\n+        let libdir = build.config.libdir.as_ref().unwrap_or(&libdir_default);\n+        let mandir = build.config.mandir.as_ref().unwrap_or(&mandir_default);\n+\n+        let sysconfdir = prefix.join(sysconfdir);\n+        let docdir = prefix.join(docdir);\n+        let bindir = prefix.join(bindir);\n+        let libdir = prefix.join(libdir);\n+        let mandir = prefix.join(mandir);\n+\n+        let destdir = env::var_os(\"DESTDIR\").map(PathBuf::from);\n \n-    if build.config.extended {\n-        install_sh(&build, \"cargo\", \"cargo\", &build.cargo_package_vers(),\n-                   stage, host, &prefix, &docdir, &libdir, &mandir, &empty_dir);\n-        install_sh(&build, \"rls\", \"rls\", &build.rls_package_vers(),\n-                   stage, host, &prefix, &docdir, &libdir, &mandir, &empty_dir);\n+        let prefix = add_destdir(&prefix, &destdir);\n+        let sysconfdir = add_destdir(&sysconfdir, &destdir);\n+        let docdir = add_destdir(&docdir, &destdir);\n+        let bindir = add_destdir(&bindir, &destdir);\n+        let libdir = add_destdir(&libdir, &destdir);\n+        let mandir = add_destdir(&mandir, &destdir);\n+\n+        Installer {\n+            build,\n+            prefix,\n+            sysconfdir,\n+            docdir,\n+            bindir,\n+            libdir,\n+            mandir,\n+        }\n     }\n \n-    install_sh(&build, \"rustc\", \"rustc\", &build.rust_package_vers(),\n-               stage, host, &prefix, &docdir, &libdir, &mandir, &empty_dir);\n+    /// Installs everything.\n+    pub fn install(&self, stage: u32, host: &str) {\n+        let empty_dir = self.build.out.join(\"tmp/empty_dir\");\n+        t!(fs::create_dir_all(&empty_dir));\n \n-    t!(fs::remove_dir_all(&empty_dir));\n-}\n+        if self.build.config.docs {\n+            self.install_sh(\"docs\", \"rust-docs\", &self.build.rust_package_vers(),\n+                            stage, Some(host), &empty_dir);\n+        }\n \n-fn install_sh(build: &Build, package: &str, name: &str, version: &str, stage: u32, host: &str,\n-              prefix: &Path, docdir: &Path, libdir: &Path, mandir: &Path, empty_dir: &Path) {\n-    println!(\"Install {} stage{} ({})\", package, stage, host);\n-    let package_name = format!(\"{}-{}-{}\", name, version, host);\n-\n-    let mut cmd = Command::new(\"sh\");\n-    cmd.current_dir(empty_dir)\n-       .arg(sanitize_sh(&tmpdir(build).join(&package_name).join(\"install.sh\")))\n-       .arg(format!(\"--prefix={}\", sanitize_sh(prefix)))\n-       .arg(format!(\"--docdir={}\", sanitize_sh(docdir)))\n-       .arg(format!(\"--libdir={}\", sanitize_sh(libdir)))\n-       .arg(format!(\"--mandir={}\", sanitize_sh(mandir)))\n-       .arg(\"--disable-ldconfig\");\n-    build.run(&mut cmd);\n+        for target in self.build.config.target.iter() {\n+            self.install_sh(\"std\", \"rust-std\", &self.build.rust_package_vers(),\n+                            stage, Some(target), &empty_dir);\n+        }\n+\n+        if self.build.config.extended {\n+            self.install_sh(\"cargo\", \"cargo\", &self.build.cargo_package_vers(),\n+                            stage, Some(host), &empty_dir);\n+            self.install_sh(\"rls\", \"rls\", &self.build.rls_package_vers(),\n+                            stage, Some(host), &empty_dir);\n+            self.install_sh(\"analysis\", \"rust-analysis\", &self.build.rust_package_vers(),\n+                            stage, Some(host), &empty_dir);\n+            self.install_sh(\"src\", \"rust-src\", &self.build.rust_package_vers(),\n+                            stage, None, &empty_dir);\n+        }\n+\n+        self.install_sh(\"rustc\", \"rustc\", &self.build.rust_package_vers(),\n+                        stage, Some(host), &empty_dir);\n+\n+        t!(fs::remove_dir_all(&empty_dir));\n+    }\n+\n+    fn install_sh(&self, package: &str, name: &str, version: &str,\n+                  stage: u32, host: Option<&str>,  empty_dir: &Path) {\n+        println!(\"Install {} stage{} ({:?})\", package, stage, host);\n+        let package_name = if let Some(host) = host {\n+            format!(\"{}-{}-{}\", name, version, host)\n+        } else {\n+            format!(\"{}-{}\", name, version)\n+        };\n+\n+        let mut cmd = Command::new(\"sh\");\n+        cmd.current_dir(empty_dir)\n+           .arg(sanitize_sh(&tmpdir(self.build).join(&package_name).join(\"install.sh\")))\n+           .arg(format!(\"--prefix={}\", sanitize_sh(&self.prefix)))\n+           .arg(format!(\"--sysconfdir={}\", sanitize_sh(&self.sysconfdir)))\n+           .arg(format!(\"--docdir={}\", sanitize_sh(&self.docdir)))\n+           .arg(format!(\"--bindir={}\", sanitize_sh(&self.bindir)))\n+           .arg(format!(\"--libdir={}\", sanitize_sh(&self.libdir)))\n+           .arg(format!(\"--mandir={}\", sanitize_sh(&self.mandir)))\n+           .arg(\"--disable-ldconfig\");\n+        self.build.run(&mut cmd);\n+    }\n }\n \n fn add_destdir(path: &Path, destdir: &Option<PathBuf>) -> PathBuf {"}, {"sha": "ca9de43f542193364b1806fe62f8f78be35ebb07", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 24, "deletions": 123, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -82,7 +82,7 @@ use std::env;\n use std::ffi::OsString;\n use std::fs::{self, File};\n use std::io::Read;\n-use std::path::{Component, PathBuf, Path};\n+use std::path::{PathBuf, Path};\n use std::process::Command;\n \n use build_helper::{run_silent, run_suppressed, output, mtime};\n@@ -285,129 +285,12 @@ impl Build {\n             self.verbose(&format!(\"auto-detected local-rebuild {}\", local_release));\n             self.local_rebuild = true;\n         }\n-        self.verbose(\"updating submodules\");\n-        self.update_submodules();\n         self.verbose(\"learning about cargo\");\n         metadata::build(self);\n \n         step::run(self);\n     }\n \n-    /// Updates all git submodules that we have.\n-    ///\n-    /// This will detect if any submodules are out of date an run the necessary\n-    /// commands to sync them all with upstream.\n-    fn update_submodules(&self) {\n-        struct Submodule<'a> {\n-            path: &'a Path,\n-            state: State,\n-        }\n-\n-        enum State {\n-            // The submodule may have staged/unstaged changes\n-            MaybeDirty,\n-            // Or could be initialized but never updated\n-            NotInitialized,\n-            // The submodule, itself, has extra commits but those changes haven't been commited to\n-            // the (outer) git repository\n-            OutOfSync,\n-        }\n-\n-        if !self.src_is_git || !self.config.submodules {\n-            return\n-        }\n-        let git = || {\n-            let mut cmd = Command::new(\"git\");\n-            cmd.current_dir(&self.src);\n-            return cmd\n-        };\n-        let git_submodule = || {\n-            let mut cmd = Command::new(\"git\");\n-            cmd.current_dir(&self.src).arg(\"submodule\");\n-            return cmd\n-        };\n-\n-        // FIXME: this takes a seriously long time to execute on Windows and a\n-        //        nontrivial amount of time on Unix, we should have a better way\n-        //        of detecting whether we need to run all the submodule commands\n-        //        below.\n-        let out = output(git_submodule().arg(\"status\"));\n-        let mut submodules = vec![];\n-        for line in out.lines() {\n-            // NOTE `git submodule status` output looks like this:\n-            //\n-            // -5066b7dcab7e700844b0e2ba71b8af9dc627a59b src/liblibc\n-            // +b37ef24aa82d2be3a3cc0fe89bf82292f4ca181c src/compiler-rt (remotes/origin/..)\n-            //  e058ca661692a8d01f8cf9d35939dfe3105ce968 src/jemalloc (3.6.0-533-ge058ca6)\n-            //\n-            // The first character can be '-', '+' or ' ' and denotes the `State` of the submodule\n-            // Right next to this character is the SHA-1 of the submodule HEAD\n-            // And after that comes the path to the submodule\n-            let path = Path::new(line[1..].split(' ').skip(1).next().unwrap());\n-            let state = if line.starts_with('-') {\n-                State::NotInitialized\n-            } else if line.starts_with('+') {\n-                State::OutOfSync\n-            } else if line.starts_with(' ') {\n-                State::MaybeDirty\n-            } else {\n-                panic!(\"unexpected git submodule state: {:?}\", line.chars().next());\n-            };\n-\n-            submodules.push(Submodule { path: path, state: state })\n-        }\n-\n-        self.run(git_submodule().arg(\"sync\"));\n-\n-        for submodule in submodules {\n-            // If using llvm-root then don't touch the llvm submodule.\n-            if submodule.path.components().any(|c| c == Component::Normal(\"llvm\".as_ref())) &&\n-                self.config.target_config.get(&self.config.build)\n-                    .and_then(|c| c.llvm_config.as_ref()).is_some()\n-            {\n-                continue\n-            }\n-\n-            if submodule.path.components().any(|c| c == Component::Normal(\"jemalloc\".as_ref())) &&\n-                !self.config.use_jemalloc\n-            {\n-                continue\n-            }\n-\n-            // `submodule.path` is the relative path to a submodule (from the repository root)\n-            // `submodule_path` is the path to a submodule from the cwd\n-\n-            // use `submodule.path` when e.g. executing a submodule specific command from the\n-            // repository root\n-            // use `submodule_path` when e.g. executing a normal git command for the submodule\n-            // (set via `current_dir`)\n-            let submodule_path = self.src.join(submodule.path);\n-\n-            match submodule.state {\n-                State::MaybeDirty => {\n-                    // drop staged changes\n-                    self.run(git().current_dir(&submodule_path)\n-                                  .args(&[\"reset\", \"--hard\"]));\n-                    // drops unstaged changes\n-                    self.run(git().current_dir(&submodule_path)\n-                                  .args(&[\"clean\", \"-fdx\"]));\n-                },\n-                State::NotInitialized => {\n-                    self.run(git_submodule().arg(\"init\").arg(submodule.path));\n-                    self.run(git_submodule().arg(\"update\").arg(submodule.path));\n-                },\n-                State::OutOfSync => {\n-                    // drops submodule commits that weren't reported to the (outer) git repository\n-                    self.run(git_submodule().arg(\"update\").arg(submodule.path));\n-                    self.run(git().current_dir(&submodule_path)\n-                                  .args(&[\"reset\", \"--hard\"]));\n-                    self.run(git().current_dir(&submodule_path)\n-                                  .args(&[\"clean\", \"-fdx\"]));\n-                },\n-            }\n-        }\n-    }\n-\n     /// Clear out `dir` if `input` is newer.\n     ///\n     /// After this executes, it will also ensure that `dir` exists.\n@@ -475,12 +358,30 @@ impl Build {\n              .env(\"RUSTDOC_REAL\", self.rustdoc(compiler))\n              .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n \n-        // Tools don't get debuginfo right now, e.g. cargo and rls don't get\n-        // compiled with debuginfo.\n         if mode != Mode::Tool {\n-             cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n-                  .env(\"RUSTC_DEBUGINFO_LINES\", self.config.rust_debuginfo_lines.to_string())\n-                  .env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n+            // Tools don't get debuginfo right now, e.g. cargo and rls don't\n+            // get compiled with debuginfo.\n+            cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n+                 .env(\"RUSTC_DEBUGINFO_LINES\", self.config.rust_debuginfo_lines.to_string())\n+                 .env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n+\n+            // Currently the compiler depends on crates from crates.io, and\n+            // then other crates can depend on the compiler (e.g. proc-macro\n+            // crates). Let's say, for example that rustc itself depends on the\n+            // bitflags crate. If an external crate then depends on the\n+            // bitflags crate as well, we need to make sure they don't\n+            // conflict, even if they pick the same verison of bitflags. We'll\n+            // want to make sure that e.g. a plugin and rustc each get their\n+            // own copy of bitflags.\n+\n+            // Cargo ensures that this works in general through the -C metadata\n+            // flag. This flag will frob the symbols in the binary to make sure\n+            // they're different, even though the source code is the exact\n+            // same. To solve this problem for the compiler we extend Cargo's\n+            // already-passed -C metadata flag with our own. Our rustc.rs\n+            // wrapper around the actual rustc will detect -C metadata being\n+            // passed and frob it with this extra string we're passing in.\n+            cargo.env(\"RUSTC_METADATA_SUFFIX\", \"rustc\");\n         }\n \n         // Enable usage of unstable features"}, {"sha": "57915446e1d1aee8e94586284d7b2546abd5c8fb", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -574,6 +574,10 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .dep(|s| s.name(\"maybe-clean-tools\"))\n          .dep(|s| s.name(\"libstd-tool\"))\n          .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-client\"));\n+    rules.build(\"tool-rust-installer\", \"src/tools/rust-installer\")\n+         .dep(|s| s.name(\"maybe-clean-tools\"))\n+         .dep(|s| s.name(\"libstd-tool\"))\n+         .run(move |s| compile::tool(build, s.stage, s.target, \"rust-installer\"));\n     rules.build(\"tool-cargo\", \"src/tools/cargo\")\n          .host(true)\n          .default(build.config.extended)\n@@ -704,6 +708,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .host(true)\n          .only_host_build(true)\n          .default(true)\n+         .dep(move |s| tool_rust_installer(build, s))\n          .run(move |s| dist::rustc(build, s.stage, s.target));\n     rules.dist(\"dist-std\", \"src/libstd\")\n          .dep(move |s| {\n@@ -718,10 +723,12 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          })\n          .default(true)\n          .only_host_build(true)\n+         .dep(move |s| tool_rust_installer(build, s))\n          .run(move |s| dist::std(build, &s.compiler(), s.target));\n     rules.dist(\"dist-mingw\", \"path/to/nowhere\")\n          .default(true)\n          .only_host_build(true)\n+         .dep(move |s| tool_rust_installer(build, s))\n          .run(move |s| {\n              if s.target.contains(\"pc-windows-gnu\") {\n                  dist::mingw(build, s.target)\n@@ -732,29 +739,34 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .host(true)\n          .only_build(true)\n          .only_host_build(true)\n+         .dep(move |s| tool_rust_installer(build, s))\n          .run(move |_| dist::rust_src(build));\n     rules.dist(\"dist-docs\", \"src/doc\")\n          .default(true)\n          .only_host_build(true)\n          .dep(|s| s.name(\"default:doc\"))\n+         .dep(move |s| tool_rust_installer(build, s))\n          .run(move |s| dist::docs(build, s.stage, s.target));\n     rules.dist(\"dist-analysis\", \"analysis\")\n          .default(build.config.extended)\n          .dep(|s| s.name(\"dist-std\"))\n          .only_host_build(true)\n+         .dep(move |s| tool_rust_installer(build, s))\n          .run(move |s| dist::analysis(build, &s.compiler(), s.target));\n     rules.dist(\"dist-rls\", \"rls\")\n          .host(true)\n          .only_host_build(true)\n          .dep(|s| s.name(\"tool-rls\"))\n+         .dep(move |s| tool_rust_installer(build, s))\n          .run(move |s| dist::rls(build, s.stage, s.target));\n     rules.dist(\"install\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"default:dist\"))\n-         .run(move |s| install::install(build, s.stage, s.target));\n+         .run(move |s| install::Installer::new(build).install(s.stage, s.target));\n     rules.dist(\"dist-cargo\", \"cargo\")\n          .host(true)\n          .only_host_build(true)\n          .dep(|s| s.name(\"tool-cargo\"))\n+         .dep(move |s| tool_rust_installer(build, s))\n          .run(move |s| dist::cargo(build, s.stage, s.target));\n     rules.dist(\"dist-extended\", \"extended\")\n          .default(build.config.extended)\n@@ -767,6 +779,7 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n          .dep(|d| d.name(\"dist-cargo\"))\n          .dep(|d| d.name(\"dist-rls\"))\n          .dep(|d| d.name(\"dist-analysis\"))\n+         .dep(move |s| tool_rust_installer(build, s))\n          .run(move |s| dist::extended(build, s.stage, s.target));\n \n     rules.dist(\"dist-sign\", \"hash-and-sign\")\n@@ -778,6 +791,14 @@ pub fn build_rules<'a>(build: &'a Build) -> Rules {\n \n     rules.verify();\n     return rules;\n+\n+    /// Helper to depend on a stage0 build-only rust-installer tool.\n+    fn tool_rust_installer<'a>(build: &'a Build, step: &Step<'a>) -> Step<'a> {\n+        step.name(\"tool-rust-installer\")\n+            .host(&build.config.build)\n+            .target(&build.config.build)\n+            .stage(0)\n+    }\n }\n \n #[derive(PartialEq, Eq, Hash, Clone, Debug)]"}, {"sha": "627b5062df3334701e4a64c0995bb42ada55c2e0", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -16,6 +16,12 @@ for example:\n \n Images will output artifacts in an `obj` dir at the root of a repository.\n \n+## Filesystem layout\n+\n+- Each directory, excluding `scripts` and `disabled`, corresponds to a docker image\n+- `scripts` contains files shared by docker images\n+- `disabled` contains images that are not build travis\n+\n ## Cross toolchains\n \n A number of these images take quite a long time to compile as they're building"}, {"sha": "2a928c5ec7e894b4a1f331e879be3db19e15441d", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -2,52 +2,44 @@ FROM ubuntu:16.04\n \n RUN apt-get update && \\\n     apt-get install -y --no-install-recommends \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n   g++ \\\n+  git \\\n+  libssl-dev \\\n   make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n+  pkg-config \\\n   python2.7 \\\n-  git \\\n-  cmake \\\n-  unzip \\\n   sudo \\\n-  xz-utils \\\n-  libssl-dev \\\n-  pkg-config\n-\n-RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n-    dpkg -i dumb-init_*.deb && \\\n-    rm dumb-init_*.deb\n+  unzip \\\n+  xz-utils\n \n-RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-05-12-sccache-x86_64-unknown-linux-musl && \\\n-    chmod +x /usr/local/bin/sccache\n+# dumb-init\n+COPY scripts/dumb-init.sh /scripts/\n+RUN sh /scripts/dumb-init.sh\n \n-# Install NDK\n-COPY install-ndk.sh /tmp\n-RUN . /tmp/install-ndk.sh && \\\n-    download_ndk android-ndk-r13b-linux-x86_64.zip && \\\n-    make_standalone_toolchain arm 9 && \\\n-    remove_ndk\n+# ndk\n+COPY scripts/android-ndk.sh /scripts/\n+RUN . /scripts/android-ndk.sh && \\\n+    download_and_make_toolchain android-ndk-r13b-linux-x86_64.zip arm 9\n \n-# Install SDK\n+# sdk\n RUN dpkg --add-architecture i386 && \\\n     apt-get update && \\\n     apt-get install -y --no-install-recommends \\\n-  openjdk-9-jre-headless \\\n-  tzdata \\\n-  libstdc++6:i386 \\\n   libgl1-mesa-glx \\\n-  libpulse0\n+  libpulse0 \\\n+  libstdc++6:i386 \\\n+  openjdk-9-jre-headless \\\n+  tzdata\n \n-COPY install-sdk.sh /tmp\n-RUN . /tmp/install-sdk.sh && \\\n-    download_sdk tools_r25.2.5-linux.zip && \\\n-    download_sysimage armeabi-v7a 18 && \\\n-    create_avd armeabi-v7a 18\n+COPY scripts/android-sdk.sh /scripts/\n+RUN . /scripts/android-sdk.sh && \\\n+    download_and_create_avd tools_r25.2.5-linux.zip armeabi-v7a 18\n \n-# Setup env\n+# env\n ENV PATH=$PATH:/android/sdk/tools\n ENV PATH=$PATH:/android/sdk/platform-tools\n \n@@ -57,8 +49,12 @@ ENV RUST_CONFIGURE_ARGS \\\n       --target=$TARGETS \\\n       --arm-linux-androideabi-ndk=/android/ndk/arm-9\n \n-ENV SCRIPT python2.7 ../x.py test --target $TARGETS --verbose\n+ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n+\n+# sccache\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n \n-# Entrypoint\n-COPY start-emulator.sh /android/\n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\", \"/android/start-emulator.sh\"]\n+# init\n+COPY scripts/android-start-emulator.sh /scripts/\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\", \"/scripts/android-start-emulator.sh\"]"}, {"sha": "80818721199838adf8fa0a6b509739366098e9c5", "filename": "src/ci/docker/arm-android/install-ndk.sh", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b69b6413afc770a8652096e8753d77eeb99b23bb/src%2Fci%2Fdocker%2Farm-android%2Finstall-ndk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/b69b6413afc770a8652096e8753d77eeb99b23bb/src%2Fci%2Fdocker%2Farm-android%2Finstall-ndk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2Finstall-ndk.sh?ref=b69b6413afc770a8652096e8753d77eeb99b23bb", "patch": "@@ -1,35 +0,0 @@\n-#!/bin/sh\n-# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-\n-URL=https://dl.google.com/android/repository\n-\n-download_ndk() {\n-    mkdir -p /android/ndk\n-    cd /android/ndk\n-    curl -O $URL/$1\n-    unzip -q $1\n-    rm $1\n-    mv android-ndk-* ndk\n-}\n-\n-make_standalone_toolchain() {\n-    # See https://developer.android.com/ndk/guides/standalone_toolchain.html\n-    python2.7 /android/ndk/ndk/build/tools/make_standalone_toolchain.py \\\n-        --install-dir /android/ndk/$1-$2 \\\n-        --arch $1 \\\n-        --api $2\n-}\n-\n-remove_ndk() {\n-    rm -rf /android/ndk/ndk\n-}"}, {"sha": "03e0b78ba89b3d83a8c3e2b6444aa0c7fe54b25d", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -31,7 +31,7 @@ WORKDIR /build\n # The `vexpress_config` config file was a previously generated config file for\n # the kernel. This file was generated by running `make vexpress_defconfig`\n # followed by `make menuconfig` and then enabling the IPv6 protocol page.\n-COPY vexpress_config /build/.config\n+COPY armhf-gnu/vexpress_config /build/.config\n RUN curl https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.4.42.tar.xz | \\\n       tar xJf - && \\\n       cd /build/linux-4.4.42 && \\\n@@ -63,11 +63,11 @@ RUN curl http://cdimage.ubuntu.com/ubuntu-base/releases/16.04/release/ubuntu-bas\n \n # Copy over our init script, which starts up our test server and also a few\n # other misc tasks.\n-COPY rcS rootfs/etc/init.d/rcS\n+COPY armhf-gnu/rcS rootfs/etc/init.d/rcS\n RUN chmod +x rootfs/etc/init.d/rcS\n \n # Helper to quickly fill the entropy pool in the kernel.\n-COPY addentropy.c /tmp/\n+COPY armhf-gnu/addentropy.c /tmp/\n RUN arm-linux-gnueabihf-gcc addentropy.c -o rootfs/addentropy -static\n \n # TODO: What is this?!"}, {"sha": "7759d91e1bb635c41ba6b89a426616ebda65a293", "filename": "src/ci/docker/cross/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -32,10 +32,10 @@ ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n WORKDIR /tmp\n \n-COPY build-rumprun.sh /tmp/\n+COPY cross/build-rumprun.sh /tmp/\n RUN ./build-rumprun.sh\n \n-COPY build-arm-musl.sh /tmp/\n+COPY cross/build-arm-musl.sh /tmp/\n RUN ./build-arm-musl.sh\n \n # originally from"}, {"sha": "918d2911ae28f5a5ba301294068740568e8a29e4", "filename": "src/ci/docker/disabled/dist-aarch64-android/Dockerfile", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -2,36 +2,30 @@ FROM ubuntu:16.04\n \n RUN apt-get update && \\\n     apt-get install -y --no-install-recommends \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n   g++ \\\n+  git \\\n+  libssl-dev \\\n   make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n+  pkg-config \\\n   python2.7 \\\n-  git \\\n-  cmake \\\n-  unzip \\\n   sudo \\\n-  xz-utils \\\n-  libssl-dev \\\n-  pkg-config\n-\n-RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n-    dpkg -i dumb-init_*.deb && \\\n-    rm dumb-init_*.deb\n-\n-RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-05-12-sccache-x86_64-unknown-linux-musl && \\\n-      chmod +x /usr/local/bin/sccache\n+  unzip \\\n+  xz-utils\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+# dumb-init\n+COPY scripts/dumb-init.sh /scripts/\n+RUN sh /scripts/dumb-init.sh\n \n-COPY android-ndk.sh /\n-RUN . /android-ndk.sh && \\\n-    download_ndk android-ndk-r13b-linux-x86_64.zip && \\\n-    make_standalone_toolchain arm64 21 && \\\n-    remove_ndk\n+# ndk\n+COPY scripts/android-ndk.sh /scripts/\n+RUN . /scripts/android-ndk.sh && \\\n+    download_and_make_toolchain android-ndk-r13b-linux-x86_64.zip arm64 21\n \n+# env\n ENV PATH=$PATH:/android/ndk/arm64-21/bin\n \n ENV DEP_Z_ROOT=/android/ndk/arm64-21/sysroot/usr/\n@@ -47,3 +41,10 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-cargo-openssl-static\n \n ENV SCRIPT python2.7 ../x.py dist --target $HOSTS --host $HOSTS\n+\n+# sccache\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# init\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "aed82e6c13872d6a276aeddd974cb6e81654b769", "filename": "src/ci/docker/disabled/dist-armv7-android/Dockerfile", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -2,37 +2,36 @@ FROM ubuntu:16.04\n \n RUN apt-get update && \\\n     apt-get install -y --no-install-recommends \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n   g++ \\\n+  git \\\n+  libssl-dev \\\n   make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n+  pkg-config \\\n   python2.7 \\\n-  git \\\n-  cmake \\\n-  unzip \\\n   sudo \\\n-  xz-utils \\\n-  libssl-dev \\\n-  pkg-config\n-\n-RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n-    dpkg -i dumb-init_*.deb && \\\n-    rm dumb-init_*.deb\n-\n-RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-05-12-sccache-x86_64-unknown-linux-musl && \\\n-      chmod +x /usr/local/bin/sccache\n+  unzip \\\n+  xz-utils\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+# dumb-init\n+COPY scripts/dumb-init.sh /scripts/\n+RUN sh /scripts/dumb-init.sh\n \n-COPY android-ndk.sh /\n-RUN . /android-ndk.sh && \\\n+# ndk\n+COPY scripts/android-ndk.sh /scripts/\n+RUN . /scripts/android-ndk.sh && \\\n     download_ndk android-ndk-r13b-linux-x86_64.zip && \\\n     make_standalone_toolchain arm 9 && \\\n     make_standalone_toolchain arm 21 && \\\n     remove_ndk\n \n+RUN chmod 777 /android/ndk && \\\n+    ln -s /android/ndk/arm-21 /android/ndk/arm\n+\n+# env\n ENV PATH=$PATH:/android/ndk/arm-9/bin\n \n ENV DEP_Z_ROOT=/android/ndk/arm-9/sysroot/usr/\n@@ -54,12 +53,16 @@ ENV RUST_CONFIGURE_ARGS \\\n # level 9), the default linker behavior is to generate an error, to allow the\n # build to finish we use --warn-unresolved-symbols. Note that the missing\n # symbols does not affect std, only the compiler (llvm) and cargo (openssl).\n-RUN chmod 777 /android/ndk && \\\n-    ln -s /android/ndk/arm-21 /android/ndk/arm\n-\n ENV SCRIPT \\\n   python2.7 ../x.py build src/llvm --host $HOSTS --target $HOSTS && \\\n   (export RUSTFLAGS=\"\\\"-C link-arg=-Wl,--warn-unresolved-symbols\\\"\"; \\\n     rm /android/ndk/arm && \\\n     ln -s /android/ndk/arm-9 /android/ndk/arm && \\\n     python2.7 ../x.py dist --host $HOSTS --target $HOSTS)\n+\n+# sccache\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# init\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "f012e869e7885fb4963e33f09bd616b9f64c7383", "filename": "src/ci/docker/disabled/dist-i686-android/Dockerfile", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -2,37 +2,36 @@ FROM ubuntu:16.04\n \n RUN apt-get update && \\\n     apt-get install -y --no-install-recommends \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n   g++ \\\n+  git \\\n+  libssl-dev \\\n   make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n+  pkg-config \\\n   python2.7 \\\n-  git \\\n-  cmake \\\n-  unzip \\\n   sudo \\\n-  xz-utils \\\n-  libssl-dev \\\n-  pkg-config\n-\n-RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n-    dpkg -i dumb-init_*.deb && \\\n-    rm dumb-init_*.deb\n-\n-RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-05-12-sccache-x86_64-unknown-linux-musl && \\\n-      chmod +x /usr/local/bin/sccache\n+  unzip \\\n+  xz-utils\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+# dumb-init\n+COPY scripts/dumb-init.sh /scripts/\n+RUN sh /scripts/dumb-init.sh\n \n-COPY android-ndk.sh /\n-RUN . /android-ndk.sh && \\\n+# ndk\n+COPY scripts/android-ndk.sh /scripts/\n+RUN . /scripts/android-ndk.sh && \\\n     download_ndk android-ndk-r13b-linux-x86_64.zip && \\\n     make_standalone_toolchain x86 9 && \\\n     make_standalone_toolchain x86 21 && \\\n     remove_ndk\n \n+RUN chmod 777 /android/ndk && \\\n+    ln -s /android/ndk/x86-21 /android/ndk/x86\n+\n+# env\n ENV PATH=$PATH:/android/ndk/x86-9/bin\n \n ENV DEP_Z_ROOT=/android/ndk/x86-9/sysroot/usr/\n@@ -54,12 +53,16 @@ ENV RUST_CONFIGURE_ARGS \\\n # level 9), the default linker behavior is to generate an error, to allow the\n # build to finish we use --warn-unresolved-symbols. Note that the missing\n # symbols does not affect std, only the compiler (llvm) and cargo (openssl).\n-RUN chmod 777 /android/ndk && \\\n-    ln -s /android/ndk/x86-21 /android/ndk/x86\n-\n ENV SCRIPT \\\n   python2.7 ../x.py build src/llvm --host $HOSTS --target $HOSTS && \\\n   (export RUSTFLAGS=\"\\\"-C link-arg=-Wl,--warn-unresolved-symbols\\\"\"; \\\n     rm /android/ndk/x86 && \\\n     ln -s /android/ndk/x86-9 /android/ndk/x86 && \\\n     python2.7 ../x.py dist --host $HOSTS --target $HOSTS)\n+\n+# sccache\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# init\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "0c586452840f97afa0e098c8d3c85516bc9d5953", "filename": "src/ci/docker/disabled/dist-x86_64-android/Dockerfile", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -2,36 +2,30 @@ FROM ubuntu:16.04\n \n RUN apt-get update && \\\n     apt-get install -y --no-install-recommends \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n   g++ \\\n+  git \\\n+  libssl-dev \\\n   make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n+  pkg-config \\\n   python2.7 \\\n-  git \\\n-  cmake \\\n-  unzip \\\n   sudo \\\n-  xz-utils \\\n-  libssl-dev \\\n-  pkg-config\n-\n-RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n-    dpkg -i dumb-init_*.deb && \\\n-    rm dumb-init_*.deb\n-\n-RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-05-12-sccache-x86_64-unknown-linux-musl && \\\n-      chmod +x /usr/local/bin/sccache\n+  unzip \\\n+  xz-utils\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+# dumb-init\n+COPY scripts/dumb-init.sh /scripts/\n+RUN sh /scripts/dumb-init.sh\n \n-COPY android-ndk.sh /\n-RUN . /android-ndk.sh && \\\n-    download_ndk android-ndk-r13b-linux-x86_64.zip && \\\n-    make_standalone_toolchain x86_64 21 && \\\n-    remove_ndk\n+# ndk\n+COPY scripts/android-ndk.sh /scripts/\n+RUN . /scripts/android-ndk.sh && \\\n+    download_and_make_toolchain android-ndk-r13b-linux-x86_64.zip x86_64 21\n \n+# env\n ENV PATH=$PATH:/android/ndk/x86_64-21/bin\n \n ENV DEP_Z_ROOT=/android/ndk/x86_64-21/sysroot/usr/\n@@ -47,3 +41,10 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-cargo-openssl-static\n \n ENV SCRIPT python2.7 ../x.py dist --target $HOSTS --host $HOSTS\n+\n+# sccache\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# init\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "0134a5407932ad08906e86e786fcaa5da3a05700", "filename": "src/ci/docker/dist-aarch64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -56,7 +56,7 @@ RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n USER rustbuild\n WORKDIR /tmp\n \n-COPY aarch64-linux-gnu.config build-toolchains.sh /tmp/\n+COPY dist-aarch64-linux/aarch64-linux-gnu.config dist-aarch64-linux/build-toolchains.sh /tmp/\n RUN ./build-toolchains.sh\n \n USER root"}, {"sha": "31389dd148a8ae0cd23dc3f95f775226d4a5038f", "filename": "src/ci/docker/dist-android/Dockerfile", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -2,40 +2,35 @@ FROM ubuntu:16.04\n \n RUN apt-get update && \\\n     apt-get install -y --no-install-recommends \\\n+  ca-certificates \\\n+  cmake \\\n+  curl \\\n+  file \\\n   g++ \\\n+  git \\\n+  libssl-dev \\\n   make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n+  pkg-config \\\n   python2.7 \\\n-  git \\\n-  cmake \\\n-  unzip \\\n   sudo \\\n-  xz-utils \\\n-  libssl-dev \\\n-  pkg-config\n-\n-RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n-    dpkg -i dumb-init_*.deb && \\\n-    rm dumb-init_*.deb\n-\n-RUN curl -o /usr/local/bin/sccache \\\n-      https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-05-12-sccache-x86_64-unknown-linux-musl && \\\n-    chmod +x /usr/local/bin/sccache\n+  unzip \\\n+  xz-utils\n \n-ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+# dumb-init\n+COPY scripts/dumb-init.sh /scripts/\n+RUN sh /scripts/dumb-init.sh\n \n-# Install NDK\n-COPY install-ndk.sh /tmp\n-RUN . /tmp/install-ndk.sh && \\\n+# ndk\n+COPY scripts/android-ndk.sh /scripts/\n+RUN . /scripts/android-ndk.sh && \\\n     download_ndk android-ndk-r13b-linux-x86_64.zip && \\\n     make_standalone_toolchain arm 9 && \\\n     make_standalone_toolchain x86 9 && \\\n     make_standalone_toolchain arm64 21 && \\\n     make_standalone_toolchain x86_64 21 && \\\n     remove_ndk\n \n+# env\n ENV TARGETS=arm-linux-androideabi\n ENV TARGETS=$TARGETS,armv7-linux-androideabi\n ENV TARGETS=$TARGETS,i686-linux-android\n@@ -52,3 +47,10 @@ ENV RUST_CONFIGURE_ARGS \\\n       --x86_64-linux-android-ndk=/android/ndk/x86_64-21\n \n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n+\n+# cache\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# init\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]"}, {"sha": "80818721199838adf8fa0a6b509739366098e9c5", "filename": "src/ci/docker/dist-android/install-ndk.sh", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b69b6413afc770a8652096e8753d77eeb99b23bb/src%2Fci%2Fdocker%2Fdist-android%2Finstall-ndk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/b69b6413afc770a8652096e8753d77eeb99b23bb/src%2Fci%2Fdocker%2Fdist-android%2Finstall-ndk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-android%2Finstall-ndk.sh?ref=b69b6413afc770a8652096e8753d77eeb99b23bb", "patch": "@@ -1,35 +0,0 @@\n-#!/bin/sh\n-# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-\n-URL=https://dl.google.com/android/repository\n-\n-download_ndk() {\n-    mkdir -p /android/ndk\n-    cd /android/ndk\n-    curl -O $URL/$1\n-    unzip -q $1\n-    rm $1\n-    mv android-ndk-* ndk\n-}\n-\n-make_standalone_toolchain() {\n-    # See https://developer.android.com/ndk/guides/standalone_toolchain.html\n-    python2.7 /android/ndk/ndk/build/tools/make_standalone_toolchain.py \\\n-        --install-dir /android/ndk/$1-$2 \\\n-        --arch $1 \\\n-        --api $2\n-}\n-\n-remove_ndk() {\n-    rm -rf /android/ndk/ndk\n-}"}, {"sha": "862818a7c918250b43f6d7ac20287cd829520a3e", "filename": "src/ci/docker/dist-arm-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -56,7 +56,7 @@ RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n USER rustbuild\n WORKDIR /tmp\n \n-COPY arm-linux-gnueabi.config build-toolchains.sh /tmp/\n+COPY dist-arm-linux/arm-linux-gnueabi.config dist-arm-linux/build-toolchains.sh /tmp/\n RUN ./build-toolchains.sh\n \n USER root"}, {"sha": "7f1f91f844c771ba31c15fa22029ab6a5ddfecdf", "filename": "src/ci/docker/dist-armhf-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -56,7 +56,7 @@ RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n USER rustbuild\n WORKDIR /tmp\n \n-COPY arm-linux-gnueabihf.config build-toolchains.sh /tmp/\n+COPY dist-armhf-linux/arm-linux-gnueabihf.config dist-armhf-linux/build-toolchains.sh /tmp/\n RUN ./build-toolchains.sh\n \n USER root"}, {"sha": "030fd24ebcdd0c1daa5d69b724175d65c21c4933", "filename": "src/ci/docker/dist-armv7-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -56,7 +56,7 @@ RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n USER rustbuild\n WORKDIR /tmp\n \n-COPY build-toolchains.sh armv7-linux-gnueabihf.config /tmp/\n+COPY dist-armv7-linux/build-toolchains.sh dist-armv7-linux/armv7-linux-gnueabihf.config /tmp/\n RUN ./build-toolchains.sh\n \n USER root"}, {"sha": "d1d9767d35e631c9c70f572b55a2ebc07f90a4ba", "filename": "src/ci/docker/dist-fuchsia/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-fuchsia%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -21,7 +21,7 @@ RUN curl -L https://cmake.org/files/v3.8/cmake-3.8.0-rc1-Linux-x86_64.tar.gz | \\\n       tar xzf - -C /usr/local --strip-components=1\n \n WORKDIR /tmp\n-COPY shared.sh build-toolchain.sh compiler-rt-dso-handle.patch /tmp/\n+COPY dist-fuchsia/shared.sh dist-fuchsia/build-toolchain.sh dist-fuchsia/compiler-rt-dso-handle.patch /tmp/\n RUN /tmp/build-toolchain.sh\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "805d238de1f9b5c78dcc4a9d7d281e07c38ca717", "filename": "src/ci/docker/dist-i586-gnu-i686-musl/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i686-musl%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -17,7 +17,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   pkg-config\n \n WORKDIR /build/\n-COPY musl-libunwind-patch.patch build-musl.sh /build/\n+COPY dist-i586-gnu-i686-musl/musl-libunwind-patch.patch dist-i586-gnu-i686-musl/build-musl.sh /build/\n RUN sh /build/build-musl.sh && rm -rf /build\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "9c4d43bfa92bc600899cc8acd0881bd343f4b2cb", "filename": "src/ci/docker/dist-i686-freebsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -16,7 +16,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   libssl-dev \\\n   pkg-config\n \n-COPY build-toolchain.sh /tmp/\n+COPY dist-i686-freebsd/build-toolchain.sh /tmp/\n RUN /tmp/build-toolchain.sh i686\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "a3c08e93ed158ce47175d05deef91f95bd5feaf5", "filename": "src/ci/docker/dist-i686-linux/Dockerfile", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -29,13 +29,13 @@ ENV PATH=/rustroot/bin:$PATH\n ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib\n ENV PKG_CONFIG_PATH=/rustroot/lib/pkgconfig\n WORKDIR /tmp\n-COPY shared.sh build-binutils.sh /tmp/\n+COPY dist-i686-linux/shared.sh dist-i686-linux/build-binutils.sh /tmp/\n \n # We need a build of openssl which supports SNI to download artifacts from\n # static.rust-lang.org. This'll be used to link into libcurl below (and used\n # later as well), so build a copy of OpenSSL with dynamic libraries into our\n # generic root.\n-COPY build-openssl.sh /tmp/\n+COPY dist-i686-linux/build-openssl.sh /tmp/\n RUN ./build-openssl.sh\n \n # The `curl` binary on CentOS doesn't support SNI which is needed for fetching\n@@ -44,7 +44,7 @@ RUN ./build-openssl.sh\n #\n # Note that we also disable a bunch of optional features of curl that we don't\n # really need.\n-COPY build-curl.sh /tmp/\n+COPY dist-i686-linux/build-curl.sh /tmp/\n RUN ./build-curl.sh\n \n # binutils < 2.22 has a bug where the 32-bit executables it generates\n@@ -54,26 +54,26 @@ RUN ./build-curl.sh\n RUN ./build-binutils.sh\n \n # Need a newer version of gcc than centos has to compile LLVM nowadays\n-COPY build-gcc.sh /tmp/\n+COPY dist-i686-linux/build-gcc.sh /tmp/\n RUN ./build-gcc.sh\n \n # CentOS 5.5 has Python 2.4 by default, but LLVM needs 2.7+\n-COPY build-python.sh /tmp/\n+COPY dist-i686-linux/build-python.sh /tmp/\n RUN ./build-python.sh\n \n # Apparently CentOS 5.5 desn't have `git` in yum, but we're gonna need it for\n # cloning, so download and build it here.\n-COPY build-git.sh /tmp/\n+COPY dist-i686-linux/build-git.sh /tmp/\n RUN ./build-git.sh\n \n # libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n # only has 2.6.4, so build our own\n-COPY build-cmake.sh /tmp/\n+COPY dist-i686-linux/build-cmake.sh /tmp/\n RUN ./build-cmake.sh\n \n # for sanitizers, we need kernel headers files newer than the ones CentOS ships\n # with so we install newer ones here\n-COPY build-headers.sh /tmp/\n+COPY dist-i686-linux/build-headers.sh /tmp/\n RUN ./build-headers.sh\n \n RUN curl -Lo /rustroot/dumb-init \\"}, {"sha": "0074665f34f7ed54f0ddff57da78bfa71dfbf89e", "filename": "src/ci/docker/dist-powerpc-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -56,8 +56,8 @@ RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n USER rustbuild\n WORKDIR /tmp\n \n-COPY patches/ /tmp/patches/\n-COPY powerpc-linux-gnu.config build-powerpc-toolchain.sh /tmp/\n+COPY dist-powerpc-linux/patches/ /tmp/patches/\n+COPY dist-powerpc-linux/powerpc-linux-gnu.config dist-powerpc-linux/build-powerpc-toolchain.sh /tmp/\n RUN ./build-powerpc-toolchain.sh\n \n USER root"}, {"sha": "bd38ee0c111582a2f88dbf4f53d2ddb87b7eac57", "filename": "src/ci/docker/dist-powerpc64-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -56,8 +56,8 @@ RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n USER rustbuild\n WORKDIR /tmp\n \n-COPY patches/ /tmp/patches/\n-COPY shared.sh powerpc64-linux-gnu.config build-powerpc64-toolchain.sh /tmp/\n+COPY dist-powerpc64-linux/patches/ /tmp/patches/\n+COPY dist-powerpc64-linux/shared.sh dist-powerpc64-linux/powerpc64-linux-gnu.config dist-powerpc64-linux/build-powerpc64-toolchain.sh /tmp/\n RUN ./build-powerpc64-toolchain.sh\n \n USER root"}, {"sha": "cbded156b4cbde53f26d4ce6508eaeeb9e74395b", "filename": "src/ci/docker/dist-powerpc64le-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -59,7 +59,7 @@ WORKDIR /tmp\n USER root\n \n RUN apt-get install -y --no-install-recommends rpm2cpio cpio\n-COPY shared.sh build-powerpc64le-toolchain.sh /tmp/\n+COPY dist-powerpc64le-linux/shared.sh dist-powerpc64le-linux/build-powerpc64le-toolchain.sh /tmp/\n RUN ./build-powerpc64le-toolchain.sh\n \n RUN curl -o /usr/local/bin/sccache \\"}, {"sha": "5c00287107aa3be399eda238a718a0050ec65b82", "filename": "src/ci/docker/dist-s390x-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -56,8 +56,8 @@ RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n USER rustbuild\n WORKDIR /tmp\n \n-COPY patches/ /tmp/patches/\n-COPY s390x-linux-gnu.config build-s390x-toolchain.sh /tmp/\n+COPY dist-s390x-linux/patches/ /tmp/patches/\n+COPY dist-s390x-linux/s390x-linux-gnu.config dist-s390x-linux/build-s390x-toolchain.sh /tmp/\n RUN ./build-s390x-toolchain.sh\n \n USER root"}, {"sha": "a6c4eee5e812c5407e07fdce89ee73c4864e60de", "filename": "src/ci/docker/dist-x86_64-freebsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -16,7 +16,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   libssl-dev \\\n   pkg-config\n \n-COPY build-toolchain.sh /tmp/\n+COPY dist-x86_64-freebsd/build-toolchain.sh /tmp/\n RUN /tmp/build-toolchain.sh x86_64\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "e2e42836dcdaf136786b7ad9b0194493d817cc83", "filename": "src/ci/docker/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -29,13 +29,13 @@ ENV PATH=/rustroot/bin:$PATH\n ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib\n ENV PKG_CONFIG_PATH=/rustroot/lib/pkgconfig\n WORKDIR /tmp\n-COPY shared.sh build-binutils.sh /tmp/\n+COPY dist-x86_64-linux/shared.sh dist-x86_64-linux/build-binutils.sh /tmp/\n \n # We need a build of openssl which supports SNI to download artifacts from\n # static.rust-lang.org. This'll be used to link into libcurl below (and used\n # later as well), so build a copy of OpenSSL with dynamic libraries into our\n # generic root.\n-COPY build-openssl.sh /tmp/\n+COPY dist-x86_64-linux/build-openssl.sh /tmp/\n RUN ./build-openssl.sh\n \n # The `curl` binary on CentOS doesn't support SNI which is needed for fetching\n@@ -44,7 +44,7 @@ RUN ./build-openssl.sh\n #\n # Note that we also disable a bunch of optional features of curl that we don't\n # really need.\n-COPY build-curl.sh /tmp/\n+COPY dist-x86_64-linux/build-curl.sh /tmp/\n RUN ./build-curl.sh\n \n # binutils < 2.22 has a bug where the 32-bit executables it generates\n@@ -54,26 +54,26 @@ RUN ./build-curl.sh\n RUN ./build-binutils.sh\n \n # Need a newer version of gcc than centos has to compile LLVM nowadays\n-COPY build-gcc.sh /tmp/\n+COPY dist-x86_64-linux/build-gcc.sh /tmp/\n RUN ./build-gcc.sh\n \n # CentOS 5.5 has Python 2.4 by default, but LLVM needs 2.7+\n-COPY build-python.sh /tmp/\n+COPY dist-x86_64-linux/build-python.sh /tmp/\n RUN ./build-python.sh\n \n # Apparently CentOS 5.5 desn't have `git` in yum, but we're gonna need it for\n # cloning, so download and build it here.\n-COPY build-git.sh /tmp/\n+COPY dist-x86_64-linux/build-git.sh /tmp/\n RUN ./build-git.sh\n \n # libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n # only has 2.6.4, so build our own\n-COPY build-cmake.sh /tmp/\n+COPY dist-x86_64-linux/build-cmake.sh /tmp/\n RUN ./build-cmake.sh\n \n # for sanitizers, we need kernel headers files newer than the ones CentOS ships\n # with so we install newer ones here\n-COPY build-headers.sh /tmp/\n+COPY dist-x86_64-linux/build-headers.sh /tmp/\n RUN ./build-headers.sh\n \n RUN curl -Lo /rustroot/dumb-init \\"}, {"sha": "2eea5ab1469728e210795b257e85ce33f2fb56db", "filename": "src/ci/docker/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -17,7 +17,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   pkg-config\n \n WORKDIR /build/\n-COPY build-musl.sh /build/\n+COPY dist-x86_64-musl/build-musl.sh /build/\n RUN sh /build/build-musl.sh && rm -rf /build\n \n RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\"}, {"sha": "f76e6271f4c8c22eddfbb4eec38760f60570fac3", "filename": "src/ci/docker/dist-x86_64-netbsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -56,7 +56,7 @@ RUN mkdir /x-tools && chown rustbuild:rustbuild /x-tools\n USER rustbuild\n WORKDIR /tmp\n \n-COPY build-netbsd-toolchain.sh /tmp/\n+COPY dist-x86_64-netbsd/build-netbsd-toolchain.sh /tmp/\n RUN ./build-netbsd-toolchain.sh\n \n USER root"}, {"sha": "0f0e5b69c32cf787d2a2fafb6dacbd370bce6c7a", "filename": "src/ci/docker/emscripten/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Femscripten%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Femscripten%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Femscripten%2FDockerfile?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -24,7 +24,7 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n WORKDIR /tmp\n-COPY build-emscripten.sh /tmp/\n+COPY emscripten/build-emscripten.sh /tmp/\n RUN ./build-emscripten.sh\n ENV PATH=$PATH:/tmp/emsdk_portable\n ENV PATH=$PATH:/tmp/emsdk_portable/clang/tag-e1.37.10/build_tag-e1.37.10_32/bin"}, {"sha": "bb9a860574dd2f175245cd6e8e97fc911d8787c7", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -26,7 +26,8 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       build \\\n       --rm \\\n       -t rust-ci \\\n-      \"$docker_dir/$image\"\n+      -f \"$docker_dir/$image/Dockerfile\" \\\n+      \"$docker_dir\"\n elif [ -f \"$docker_dir/disabled/$image/Dockerfile\" ]; then\n     if [ -n \"$TRAVIS_OS_NAME\" ]; then\n         echo Cannot run disabled images on travis!"}, {"sha": "c3d83c087e52fee5a5ccec4206a6e936656d99f1", "filename": "src/ci/docker/scripts/android-ndk.sh", "status": "renamed", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-ndk.sh?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -1,4 +1,3 @@\n-#!/bin/sh\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT.\n@@ -33,3 +32,9 @@ make_standalone_toolchain() {\n remove_ndk() {\n     rm -rf /android/ndk/ndk\n }\n+\n+download_and_make_toolchain() {\n+    download_ndk $1 && \\\n+    make_standalone_toolchain $2 $3 && \\\n+    remove_ndk\n+}", "previous_filename": "src/ci/docker/android-ndk.sh"}, {"sha": "7d8110efedec936d2ac49c8813c0b445193f21d7", "filename": "src/ci/docker/scripts/android-sdk.sh", "status": "renamed", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -1,4 +1,3 @@\n-#!/bin/sh\n # Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT.\n@@ -47,3 +46,8 @@ create_avd() {\n             --abi $abi\n }\n \n+download_and_create_avd() {\n+    download_sdk $1\n+    download_sysimage $2 $3\n+    create_avd $2 $3\n+}", "previous_filename": "src/ci/docker/arm-android/install-sdk.sh"}, {"sha": "cd3369d5eaddc7da93f844b4fa3fd7ceceee021f", "filename": "src/ci/docker/scripts/android-start-emulator.sh", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fscripts%2Fandroid-start-emulator.sh", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fscripts%2Fandroid-start-emulator.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-start-emulator.sh?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "previous_filename": "src/ci/docker/arm-android/start-emulator.sh"}, {"sha": "839c390799278c98ef227d6c63b2f440e2cb421e", "filename": "src/ci/docker/scripts/dumb-init.sh", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fscripts%2Fdumb-init.sh", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fscripts%2Fdumb-init.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fdumb-init.sh?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,15 @@\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb\n+dpkg -i dumb-init_*.deb\n+rm dumb-init_*.deb"}, {"sha": "7a2befaf6715ff692a9c7d49409a6294c030d49a", "filename": "src/ci/docker/scripts/sccache.sh", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,16 @@\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+curl -o /usr/local/bin/sccache \\\n+  https://s3.amazonaws.com/rust-lang-ci/rust-ci-mirror/2017-05-12-sccache-x86_64-unknown-linux-musl\n+\n+chmod +x /usr/local/bin/sccache"}, {"sha": "97422981c53a00f7c3d6584d363443117f179fff", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -1 +1 @@\n-Subproject commit ad7de198561b3a12217ea2da76d796d9c7fc0ed3\n+Subproject commit 97422981c53a00f7c3d6584d363443117f179fff"}, {"sha": "f7a108dfa9e90b07821700c55d01f08a9adf005c", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -1 +1 @@\n-Subproject commit 6b0de90d87dda15e323ef24cdf7ed873ac5cf4d3\n+Subproject commit f7a108dfa9e90b07821700c55d01f08a9adf005c"}, {"sha": "39f800591483bdbf05528244bf24281e76c992d2", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -217,6 +217,7 @@\n     - [unique](library-features/unique.md)\n     - [unsize](library-features/unsize.md)\n     - [utf8_error_error_len](library-features/utf8-error-error-len.md)\n+    - [vec_resize_default](library-features/vec-resize-default.md)\n     - [vec_remove_item](library-features/vec-remove-item.md)\n     - [windows_c](library-features/windows-c.md)\n     - [windows_handle](library-features/windows-handle.md)"}, {"sha": "e8256469b145078be9889c75600c86e64081012c", "filename": "src/doc/unstable-book/src/language-features/advanced-slice-patterns.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fadvanced-slice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fadvanced-slice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fadvanced-slice-patterns.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -4,7 +4,7 @@ The tracking issue for this feature is: [#23121]\n \n [#23121]: https://github.com/rust-lang/rust/issues/23121\n \n-See also [`slice_patterns`](slice-patterns.html).\n+See also [`slice_patterns`](language-features/slice-patterns.html).\n \n ------------------------\n "}, {"sha": "8deb8f462562063f67cac3e1bb1ac85621444ba7", "filename": "src/doc/unstable-book/src/language-features/asm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fasm.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -190,4 +190,4 @@ constraints, etc.\n [llvm-docs]: http://llvm.org/docs/LangRef.html#inline-assembler-expressions\n \n If you need more power and don't mind losing some of the niceties of\n-`asm!`, check out [global_asm](global_asm.html).\n+`asm!`, check out [global_asm](language-features/global_asm.html)."}, {"sha": "0896627acae1b3203a39d1463bcae4d6e470fa19", "filename": "src/doc/unstable-book/src/language-features/box-patterns.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-patterns.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -4,7 +4,7 @@ The tracking issue for this feature is: [#29641]\n \n [#29641]: https://github.com/rust-lang/rust/issues/29641\n \n-See also [`box_syntax`](box-syntax.html)\n+See also [`box_syntax`](language-features/box-syntax.html)\n \n ------------------------\n "}, {"sha": "50e59231a4df22d19608d91d470f54fceb645a83", "filename": "src/doc/unstable-book/src/language-features/box-syntax.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -4,7 +4,7 @@ The tracking issue for this feature is: [#27779]\n \n [#27779]: https://github.com/rust-lang/rust/issues/27779\n \n-See also [`box_patterns`](box-patterns.html)\n+See also [`box_patterns`](language-features/box-patterns.html)\n \n ------------------------\n "}, {"sha": "f1ef74a63b513acedd4ff96396812640b451ac9b", "filename": "src/doc/unstable-book/src/language-features/global_asm.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal_asm.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal_asm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal_asm.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -74,5 +74,5 @@ usages and placed the larger, single usage in the crate root.\n \n If you don't need quite as much power and flexibility as\n `global_asm!` provides, and you don't mind restricting your inline\n-assembly to `fn` bodies only, you might try the [asm](asm.html)\n-feature instead.\n+assembly to `fn` bodies only, you might try the\n+[asm](language-features/asm.html) feature instead."}, {"sha": "e8fefe3b73344b4376cfce092dc8b9d37cf21bff", "filename": "src/doc/unstable-book/src/language-features/loop-break-value.md", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Floop-break-value.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Floop-break-value.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Floop-break-value.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -4,7 +4,80 @@ The tracking issue for this feature is: [#37339]\n \n [#37339]: https://github.com/rust-lang/rust/issues/37339\n \n+Documentation to be appended to section G of the book.\n+\n ------------------------\n \n+### Loops as expressions\n+\n+Like most things in Rust, loops are expressions, and have a value; normally `()` unless the loop\n+never exits.\n+A `loop` can instead evaluate to a useful value via *break with value*:\n+\n+```rust\n+#![feature(loop_break_value)]\n+\n+// Find the first square number over 1000:\n+let mut n = 1;\n+let square = loop {\n+    if n * n > 1000 {\n+        break n * n;\n+    }\n+    n += 1;\n+};\n+```\n+\n+The evaluation type may be specified externally:\n+\n+```rust\n+#![feature(loop_break_value)]\n+\n+// Declare that value returned is unsigned 64-bit:\n+let n: u64 = loop {\n+    break 1;\n+};\n+```\n+\n+It is an error if types do not agree, either between a \"break\" value and an external requirement,\n+or between multiple \"break\" values:\n+\n+```no_compile\n+#![feature(loop_break_value)]\n+\n+loop {\n+    if true {\n+        break 1u32;\n+    } else {\n+        break 0u8;  // error: types do not agree\n+    }\n+};\n+\n+let n: i32 = loop {\n+    break 0u32; // error: type does not agree with external requirement\n+};\n+```\n+\n+#### Break: label, value\n+\n+Four forms of `break` are available, where EXPR is some expression which evaluates to a value:\n+\n+1.  `break;`\n+2.  `break 'label;`\n+3.  `break EXPR;`\n+4.  `break 'label EXPR;`\n+\n+When no value is given, the value `()` is assumed, thus `break;` is equivalent to `break ();`.\n+\n+Using a label allows returning a value from an inner loop:\n \n+```rust\n+#![feature(loop_break_value)]\n \n+let result = 'outer: loop {\n+    for n in 1..10 {\n+        if n > 4 {\n+            break 'outer n;\n+        }\n+    }\n+};\n+```"}, {"sha": "b16e2ac2d221c97941e4f4ba0c01b31781335bed", "filename": "src/doc/unstable-book/src/language-features/plugin-registrar.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin-registrar.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin-registrar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin-registrar.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,6 +8,6 @@ This feature is part of \"compiler plugins.\" It will often be used with the\n [`plugin`] and `rustc_private` features as well. For more details, see\n their docs.\n \n-[`plugin`]: plugin.html\n+[`plugin`]: language-features/plugin.html\n \n ------------------------"}, {"sha": "4b8603e3c445045147c42de687955d1582c44e7d", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,7 +8,7 @@ The tracking issue for this feature is: [#29597]\n This feature is part of \"compiler plugins.\" It will often be used with the\n [`plugin_registrar`] and `rustc_private` features.\n \n-[`plugin_registrar`]: plugin-registrar.html\n+[`plugin_registrar`]: language-features/plugin-registrar.html\n \n ------------------------\n "}, {"sha": "1bd8c41629eea01712d001f940d2e797ee47138f", "filename": "src/doc/unstable-book/src/language-features/proc-macro.md", "status": "modified", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -6,5 +6,236 @@ The tracking issue for this feature is: [#38356]\n \n ------------------------\n \n+This feature flag guards the new procedural macro features as laid out by [RFC 1566], which alongside the now-stable \n+[custom derives], provide stabilizable alternatives to the compiler plugin API (which requires the use of \n+perma-unstable internal APIs) for programmatically modifying Rust code at compile-time.\n \n+The two new procedural macro kinds are:\n+ \n+* Function-like procedural macros which are invoked like regular declarative macros, and:\n \n+* Attribute-like procedural macros which can be applied to any item which built-in attributes can\n+be applied to, and which can take arguments in their invocation as well.\n+\n+Additionally, this feature flag implicitly enables the [`use_extern_macros`](language-features/use-extern-macros.html) feature,\n+which allows macros to be imported like any other item with `use` statements, as compared to \n+applying `#[macro_use]` to an `extern crate` declaration. It is important to note that procedural macros may\n+**only** be imported in this manner, and will throw an error otherwise.\n+\n+You **must** declare the `proc_macro` feature in both the crate declaring these new procedural macro kinds as well as \n+in any crates that use them.\n+\n+### Common Concepts\n+\n+As with custom derives, procedural macros may only be declared in crates of the `proc-macro` type, and must be public\n+functions. No other public items may be declared in `proc-macro` crates, but private items are fine.\n+\n+To declare your crate as a `proc-macro` crate, simply add:\n+\n+```toml\n+[lib]\n+proc-macro = true\n+```\n+\n+to your `Cargo.toml`. \n+\n+Unlike custom derives, however, the name of the function implementing the procedural macro is used directly as the \n+procedural macro's name, so choose carefully.\n+\n+Additionally, both new kinds of procedural macros return a `TokenStream` which *wholly* replaces the original \n+invocation and its input.\n+\n+#### Importing\n+\n+As referenced above, the new procedural macros are not meant to be imported via `#[macro_use]` and will throw an \n+error if they are. Instead, they are meant to be imported like any other item in Rust, with `use` statements:\n+\n+```rust,ignore\n+#![feature(proc_macro)]\n+\n+// Where `my_proc_macros` is some crate of type `proc_macro`\n+extern crate my_proc_macros;\n+\n+// And declares a `#[proc_macro] pub fn my_bang_macro()` at its root.\n+use my_proc_macros::my_bang_macro;\n+\n+fn main() {\n+    println!(\"{}\", my_bang_macro!());\n+}\n+```\n+\n+#### Error Reporting\n+\n+Any panics in a procedural macro implementation will be caught by the compiler and turned into an error message pointing \n+to the problematic invocation. Thus, it is important to make your panic messages as informative as possible: use \n+`Option::expect` instead of `Option::unwrap` and `Result::expect` instead of `Result::unwrap`, and inform the user of \n+the error condition as unambiguously as you can.\n+ \n+#### `TokenStream`\n+\n+The `proc_macro::TokenStream` type is hardcoded into the signatures of procedural macro functions for both input and \n+output. It is a wrapper around the compiler's internal representation for a given chunk of Rust code.\n+\n+### Function-like Procedural Macros\n+\n+These are procedural macros that are invoked like regular declarative macros. They are declared as public functions in \n+crates of the `proc_macro` type and using the `#[proc_macro]` attribute. The name of the declared function becomes the \n+name of the macro as it is to be imported and used. The function must be of the kind `fn(TokenStream) -> TokenStream` \n+where the sole argument is the input to the macro and the return type is the macro's output.\n+\n+This kind of macro can expand to anything that is valid for the context it is invoked in, including expressions and\n+statements, as well as items.\n+\n+**Note**: invocations of this kind of macro require a wrapping `[]`, `{}` or `()` like regular macros, but these do not \n+appear in the input, only the tokens between them. The tokens between the braces do not need to be valid Rust syntax.\n+\n+<span class=\"filename\">my_macro_crate/src/lib.rs</span>\n+\n+```rust,ignore\n+#![feature(proc_macro)]\n+\n+// This is always necessary to get the `TokenStream` typedef.\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn say_hello(_input: TokenStream) -> TokenStream {\n+    // This macro will accept any input because it ignores it. \n+    // To enforce correctness in macros which don't take input,\n+    // you may want to add `assert!(_input.to_string().is_empty());`.\n+    \"println!(\\\"Hello, world!\\\")\".parse().unwrap()\n+}\n+```\n+\n+<span class=\"filename\">my_macro_user/Cargo.toml</span>\n+\n+```toml\n+[dependencies]\n+my_macro_crate = { path = \"<relative path to my_macro_crate>\" }\n+```\n+\n+<span class=\"filename\">my_macro_user/src/lib.rs</span>\n+\n+```rust,ignore\n+#![feature(proc_macro)]\n+\n+extern crate my_macro_crate;\n+\n+use my_macro_crate::say_hello;\n+\n+fn main() {\n+    say_hello!();\n+}\n+```\n+\n+As expected, this prints `Hello, world!`.\n+\n+### Attribute-like Procedural Macros\n+\n+These are arguably the most powerful flavor of procedural macro as they can be applied anywhere attributes are allowed. \n+\n+They are declared as public functions in crates of the `proc-macro` type, using the `#[proc_macro_attribute]` attribute. \n+The name of the function becomes the name of the attribute as it is to be imported and used. The function must be of the \n+kind `fn(TokenStream, TokenStream) -> TokenStream` where:\n+\n+The first argument represents any metadata for the attribute (see [the reference chapter on attributes][refr-attr]). \n+Only the metadata itself will appear in this argument, for example:\n+ \n+ * `#[my_macro]` will get an empty string.\n+ * `#[my_macro = \"string\"]` will get `= \"string\"`.\n+ * `#[my_macro(ident)]` will get `(ident)`.\n+ * etc.\n+ \n+The second argument is the item that the attribute is applied to. It can be a function, a type definition, \n+an impl block, an `extern` block, or a module\u2014attribute invocations can take the inner form (`#![my_attr]`) \n+or outer form (`#[my_attr]`).\n+\n+The return type is the output of the macro which *wholly* replaces the item it was applied to. Thus, if your intention\n+is to merely modify an item, it *must* be copied to the output. The output must be an item; expressions, statements\n+and bare blocks are not allowed.\n+\n+There is no restriction on how many items an attribute-like procedural macro can emit as long as they are valid in \n+the given context.\n+\n+<span class=\"filename\">my_macro_crate/src/lib.rs</span>\n+\n+```rust,ignore\n+#![feature(proc_macro)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+/// Adds a `/// ### Panics` docstring to the end of the input's documentation\n+///\n+/// Does not assert that its receiver is a function or method.\n+#[proc_macro_attribute]\n+pub fn panics_note(args: TokenStream, input: TokenStream) -> TokenStream {\n+    let args = args.to_string();\n+    let mut input = input.to_string();\n+\n+    assert!(args.starts_with(\"= \\\"\"), \"`#[panics_note]` requires an argument of the form \\\n+                                       `#[panics_note = \\\"panic note here\\\"]`\");\n+\n+    // Get just the bare note string\n+    let panics_note = args.trim_matches(&['=', ' ', '\"'][..]);\n+\n+    // The input will include all docstrings regardless of where the attribute is placed,\n+    // so we need to find the last index before the start of the item\n+    let insert_idx = idx_after_last_docstring(&input);\n+\n+    // And insert our `### Panics` note there so it always appears at the end of an item's docs\n+    input.insert_str(insert_idx, &format!(\"/// # Panics \\n/// {}\\n\", panics_note));\n+\n+    input.parse().unwrap()\n+}\n+\n+// `proc-macro` crates can contain any kind of private item still\n+fn idx_after_last_docstring(input: &str) -> usize {\n+    // Skip docstring lines to find the start of the item proper\n+    input.lines().skip_while(|line| line.trim_left().starts_with(\"///\")).next()\n+        // Find the index of the first non-docstring line in the input\n+        // Note: assumes this exact line is unique in the input\n+        .and_then(|line_after| input.find(line_after))\n+        // No docstrings in the input\n+        .unwrap_or(0)\n+}\n+```\n+\n+<span class=\"filename\">my_macro_user/Cargo.toml</span>\n+\n+```toml\n+[dependencies]\n+my_macro_crate = { path = \"<relative path to my_macro_crate>\" }\n+```\n+\n+<span class=\"filename\">my_macro_user/src/lib.rs</span>\n+\n+```rust,ignore\n+#![feature(proc_macro)]\n+\n+extern crate my_macro_crate;\n+\n+use my_macro_crate::panics_note;\n+\n+/// Do the `foo` thing.\n+#[panics_note = \"Always.\"]\n+pub fn foo() {\n+    panic!()\n+}\n+```\n+\n+Then the rendered documentation for `pub fn foo` will look like this:\n+\n+> `pub fn foo()`\n+> \n+> ----\n+> Do the `foo` thing.\n+> # Panics\n+> Always.\n+\n+[RFC 1566]: https://github.com/rust-lang/rfcs/blob/master/text/1566-proc-macros.md\n+[custom derives]: https://doc.rust-lang.org/book/procedural-macros.html\n+[rust-lang/rust#41430]: https://github.com/rust-lang/rust/issues/41430\n+[refr-attr]: https://doc.rust-lang.org/reference/attributes.html"}, {"sha": "69857297582da4068b9c3c464d818657c7ce6877", "filename": "src/doc/unstable-book/src/language-features/slice-patterns.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -4,7 +4,8 @@ The tracking issue for this feature is: [#23121]\n \n [#23121]: https://github.com/rust-lang/rust/issues/23121\n \n-See also [`advanced_slice_patterns`](advanced-slice-patterns.html).\n+See also\n+[`advanced_slice_patterns`](language-features/advanced-slice-patterns.html).\n \n ------------------------\n "}, {"sha": "18ff838dd32b961743f14b03a95d13d0d14790f9", "filename": "src/doc/unstable-book/src/library-features/alloc-jemalloc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -4,7 +4,7 @@ The tracking issue for this feature is: [#33082]\n \n [#33082]: https://github.com/rust-lang/rust/issues/33082\n \n-See also [`alloc_system`](alloc-system.html).\n+See also [`alloc_system`](library-features/alloc-system.html).\n \n ------------------------\n "}, {"sha": "1d261db6ba1b3f810a08aa3892837c99cdeaf280", "filename": "src/doc/unstable-book/src/library-features/alloc-system.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -4,7 +4,7 @@ The tracking issue for this feature is: [#33082]\n \n [#33082]: https://github.com/rust-lang/rust/issues/33082\n \n-See also [`alloc_jemalloc`](alloc-jemalloc.html).\n+See also [`alloc_jemalloc`](library-features/alloc-jemalloc.html).\n \n ------------------------\n "}, {"sha": "8467cb68862f7996cb8c6bc8a660d29e3a2fde56", "filename": "src/doc/unstable-book/src/library-features/iterator-step-by.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fiterator-step-by.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fiterator-step-by.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fiterator-step-by.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,7 @@\n+# `iterator_step_by`\n+\n+The tracking issue for this feature is: [#27741]\n+\n+[#27741]: https://github.com/rust-lang/rust/issues/27741\n+\n+------------------------"}, {"sha": "5803d3215a54b93bbfbcbe84a2be995fa494b2bb", "filename": "src/doc/unstable-book/src/library-features/vec-resize-default.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fvec-resize-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fvec-resize-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fvec-resize-default.md?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,7 @@\n+# `vec_resize_default`\n+\n+The tracking issue for this feature is: [#41758]\n+\n+[#41758]: https://github.com/rust-lang/rust/issues/41758\n+\n+------------------------"}, {"sha": "fc4063fae927754353d5e736099f0a365b0dd2d7", "filename": "src/libcollections/benches/str.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcollections%2Fbenches%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcollections%2Fbenches%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbenches%2Fstr.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -195,30 +195,34 @@ fn bench_contains_equal(b: &mut Bencher) {\n     })\n }\n \n+\n macro_rules! make_test_inner {\n-    ($s:ident, $code:expr, $name:ident, $str:expr) => {\n+    ($s:ident, $code:expr, $name:ident, $str:expr, $iters:expr) => {\n         #[bench]\n         fn $name(bencher: &mut Bencher) {\n             let mut $s = $str;\n             black_box(&mut $s);\n-            bencher.iter(|| $code);\n+            bencher.iter(|| for _ in 0..$iters { black_box($code); });\n         }\n     }\n }\n \n macro_rules! make_test {\n     ($name:ident, $s:ident, $code:expr) => {\n+        make_test!($name, $s, $code, 1);\n+    };\n+    ($name:ident, $s:ident, $code:expr, $iters:expr) => {\n         mod $name {\n             use test::Bencher;\n             use test::black_box;\n \n             // Short strings: 65 bytes each\n             make_test_inner!($s, $code, short_ascii,\n-                \"Mary had a little lamb, Little lamb Mary had a littl lamb, lamb!\");\n+                \"Mary had a little lamb, Little lamb Mary had a littl lamb, lamb!\", $iters);\n             make_test_inner!($s, $code, short_mixed,\n-                \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lam!\");\n+                \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lam!\", $iters);\n             make_test_inner!($s, $code, short_pile_of_poo,\n-                \"\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9!\");\n+                \"\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9!\", $iters);\n             make_test_inner!($s, $code, long_lorem_ipsum,\"\\\n Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n@@ -253,7 +257,7 @@ Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas\n feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n-malesuada sollicitudin quam eu fermentum!\");\n+malesuada sollicitudin quam eu fermentum!\", $iters);\n         }\n     }\n }\n@@ -288,6 +292,13 @@ make_test!(find_zzz_char, s, s.find('\\u{1F4A4}'));\n make_test!(rfind_zzz_char, s, s.rfind('\\u{1F4A4}'));\n make_test!(find_zzz_str, s, s.find(\"\\u{1F4A4}\"));\n \n+make_test!(starts_with_ascii_char, s, s.starts_with('/'), 1024);\n+make_test!(ends_with_ascii_char, s, s.ends_with('/'), 1024);\n+make_test!(starts_with_unichar, s, s.starts_with('\\u{1F4A4}'), 1024);\n+make_test!(ends_with_unichar, s, s.ends_with('\\u{1F4A4}'), 1024);\n+make_test!(starts_with_str, s, s.starts_with(\"\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\"), 1024);\n+make_test!(ends_with_str, s, s.ends_with(\"\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\"), 1024);\n+\n make_test!(split_space_char, s, s.split(' ').count());\n make_test!(split_terminator_space_char, s, s.split_terminator(' ').count());\n "}, {"sha": "7e67befb700dbcd16a5039cf6bdb26716417744b", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -813,6 +813,7 @@ impl str {\n     /// assert!(!bananas.contains(\"apples\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n         core_str::StrExt::contains(self, pat)\n     }\n@@ -900,6 +901,7 @@ impl str {\n     /// assert_eq!(s.find(x), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n         core_str::StrExt::find(self, pat)\n     }\n@@ -944,6 +946,7 @@ impl str {\n     /// assert_eq!(s.rfind(x), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n@@ -1057,6 +1060,7 @@ impl str {\n     ///\n     /// [`split_whitespace`]: #method.split_whitespace\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n         core_str::StrExt::split(self, pat)\n     }\n@@ -1106,6 +1110,7 @@ impl str {\n     /// assert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n@@ -1152,6 +1157,7 @@ impl str {\n     /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n         core_str::StrExt::split_terminator(self, pat)\n     }\n@@ -1195,6 +1201,7 @@ impl str {\n     /// assert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn rsplit_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplitTerminator<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n@@ -1247,6 +1254,7 @@ impl str {\n     /// assert_eq!(v, [\"abc\", \"defXghi\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn splitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> SplitN<'a, P> {\n         core_str::StrExt::splitn(self, n, pat)\n     }\n@@ -1294,6 +1302,7 @@ impl str {\n     /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, n: usize, pat: P) -> RSplitN<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n@@ -1334,6 +1343,7 @@ impl str {\n     /// assert_eq!(v, [\"1\", \"2\", \"3\"]);\n     /// ```\n     #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n+    #[inline]\n     pub fn matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> Matches<'a, P> {\n         core_str::StrExt::matches(self, pat)\n     }\n@@ -1370,6 +1380,7 @@ impl str {\n     /// assert_eq!(v, [\"3\", \"2\", \"1\"]);\n     /// ```\n     #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n+    #[inline]\n     pub fn rmatches<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatches<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n@@ -1415,6 +1426,7 @@ impl str {\n     /// assert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n     /// ```\n     #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n+    #[inline]\n     pub fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n         core_str::StrExt::match_indices(self, pat)\n     }\n@@ -1457,6 +1469,7 @@ impl str {\n     /// assert_eq!(v, [(2, \"aba\")]); // only the last `aba`\n     /// ```\n     #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n+    #[inline]\n     pub fn rmatch_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> RMatchIndices<'a, P>\n         where P::Searcher: ReverseSearcher<'a>\n     {\n@@ -1737,6 +1750,7 @@ impl str {\n     /// assert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String {\n         let mut result = String::new();\n         let mut last_end = 0;"}, {"sha": "1cf713290d8e8b7e7ea65b6b9af21f961a73c337", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 95, "deletions": 33, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -1220,11 +1220,14 @@ impl<T> Vec<T> {\n }\n \n impl<T: Clone> Vec<T> {\n-    /// Resizes the `Vec` in-place so that `len()` is equal to `new_len`.\n+    /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n     ///\n-    /// If `new_len` is greater than `len()`, the `Vec` is extended by the\n+    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n     /// difference, with each additional slot filled with `value`.\n-    /// If `new_len` is less than `len()`, the `Vec` is simply truncated.\n+    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n+    ///\n+    /// This method requires `Clone` to clone the passed value. If you'd\n+    /// rather create a value with `Default` instead, see [`resize_default`].\n     ///\n     /// # Examples\n     ///\n@@ -1237,19 +1240,100 @@ impl<T: Clone> Vec<T> {\n     /// vec.resize(2, 0);\n     /// assert_eq!(vec, [1, 2]);\n     /// ```\n+    ///\n+    /// [`resize_default`]: #method.resize_default\n     #[stable(feature = \"vec_resize\", since = \"1.5.0\")]\n     pub fn resize(&mut self, new_len: usize, value: T) {\n         let len = self.len();\n \n         if new_len > len {\n-            self.extend_with_element(new_len - len, value);\n+            self.extend_with(new_len - len, ExtendElement(value))\n+        } else {\n+            self.truncate(new_len);\n+        }\n+    }\n+\n+    /// Clones and appends all elements in a slice to the `Vec`.\n+    ///\n+    /// Iterates over the slice `other`, clones each element, and then appends\n+    /// it to this `Vec`. The `other` vector is traversed in-order.\n+    ///\n+    /// Note that this function is same as `extend` except that it is\n+    /// specialized to work with slices instead. If and when Rust gets\n+    /// specialization this function will likely be deprecated (but still\n+    /// available).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut vec = vec![1];\n+    /// vec.extend_from_slice(&[2, 3, 4]);\n+    /// assert_eq!(vec, [1, 2, 3, 4]);\n+    /// ```\n+    #[stable(feature = \"vec_extend_from_slice\", since = \"1.6.0\")]\n+    pub fn extend_from_slice(&mut self, other: &[T]) {\n+        self.spec_extend(other.iter())\n+    }\n+}\n+\n+impl<T: Default> Vec<T> {\n+    /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n+    ///\n+    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n+    /// difference, with each additional slot filled with `Default::default()`.\n+    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n+    ///\n+    /// This method uses `Default` to create new values on every push. If\n+    /// you'd rather `Clone` a given value, use [`resize`].\n+    ///\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_resize_default)]\n+    ///\n+    /// let mut vec = vec![1, 2, 3];\n+    /// vec.resize_default(5);\n+    /// assert_eq!(vec, [1, 2, 3, 0, 0]);\n+    ///\n+    /// let mut vec = vec![1, 2, 3, 4];\n+    /// vec.resize_default(2);\n+    /// assert_eq!(vec, [1, 2]);\n+    /// ```\n+    ///\n+    /// [`resize`]: #method.resize\n+    #[unstable(feature = \"vec_resize_default\", issue = \"41758\")]\n+    pub fn resize_default(&mut self, new_len: usize) {\n+        let len = self.len();\n+\n+        if new_len > len {\n+            self.extend_with(new_len - len, ExtendDefault);\n         } else {\n             self.truncate(new_len);\n         }\n     }\n+}\n \n-    /// Extend the vector by `n` additional clones of `value`.\n-    fn extend_with_element(&mut self, n: usize, value: T) {\n+// This code generalises `extend_with_{element,default}`.\n+trait ExtendWith<T> {\n+    fn next(&self) -> T;\n+    fn last(self) -> T;\n+}\n+\n+struct ExtendElement<T>(T);\n+impl<T: Clone> ExtendWith<T> for ExtendElement<T> {\n+    fn next(&self) -> T { self.0.clone() }\n+    fn last(self) -> T { self.0 }\n+}\n+\n+struct ExtendDefault;\n+impl<T: Default> ExtendWith<T> for ExtendDefault {\n+    fn next(&self) -> T { Default::default() }\n+    fn last(self) -> T { Default::default() }\n+}\n+impl<T> Vec<T> {\n+    /// Extend the vector by `n` values, using the given generator.\n+    fn extend_with<E: ExtendWith<T>>(&mut self, n: usize, value: E) {\n         self.reserve(n);\n \n         unsafe {\n@@ -1261,43 +1345,21 @@ impl<T: Clone> Vec<T> {\n \n             // Write all elements except the last one\n             for _ in 1..n {\n-                ptr::write(ptr, value.clone());\n+                ptr::write(ptr, value.next());\n                 ptr = ptr.offset(1);\n-                // Increment the length in every step in case clone() panics\n+                // Increment the length in every step in case next() panics\n                 local_len.increment_len(1);\n             }\n \n             if n > 0 {\n                 // We can write the last element directly without cloning needlessly\n-                ptr::write(ptr, value);\n+                ptr::write(ptr, value.last());\n                 local_len.increment_len(1);\n             }\n \n             // len set by scope guard\n         }\n     }\n-\n-    /// Clones and appends all elements in a slice to the `Vec`.\n-    ///\n-    /// Iterates over the slice `other`, clones each element, and then appends\n-    /// it to this `Vec`. The `other` vector is traversed in-order.\n-    ///\n-    /// Note that this function is same as `extend` except that it is\n-    /// specialized to work with slices instead. If and when Rust gets\n-    /// specialization this function will likely be deprecated (but still\n-    /// available).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut vec = vec![1];\n-    /// vec.extend_from_slice(&[2, 3, 4]);\n-    /// assert_eq!(vec, [1, 2, 3, 4]);\n-    /// ```\n-    #[stable(feature = \"vec_extend_from_slice\", since = \"1.6.0\")]\n-    pub fn extend_from_slice(&mut self, other: &[T]) {\n-        self.spec_extend(other.iter())\n-    }\n }\n \n // Set the length of the vec when the `SetLenOnDrop` value goes out of scope.\n@@ -1389,7 +1451,7 @@ trait SpecFromElem: Sized {\n impl<T: Clone> SpecFromElem for T {\n     default fn from_elem(elem: Self, n: usize) -> Vec<Self> {\n         let mut v = Vec::with_capacity(n);\n-        v.extend_with_element(n, elem);\n+        v.extend_with(n, ExtendElement(elem));\n         v\n     }\n }\n@@ -1424,7 +1486,7 @@ macro_rules! impl_spec_from_elem {\n                     }\n                 }\n                 let mut v = Vec::with_capacity(n);\n-                v.extend_with_element(n, elem);\n+                v.extend_with(n, ExtendElement(elem));\n                 v\n             }\n         }"}, {"sha": "4825c2aa132640abc14c27cc5e2f7ce040ed3928", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -21,7 +21,7 @@ fn float_to_decimal_common_exact<T>(fmt: &mut Formatter, num: &T,\n {\n     unsafe {\n         let mut buf: [u8; 1024] = mem::uninitialized(); // enough for f32 and f64\n-        let mut parts: [flt2dec::Part; 5] = mem::uninitialized();\n+        let mut parts: [flt2dec::Part; 4] = mem::uninitialized();\n         let formatted = flt2dec::to_exact_fixed_str(flt2dec::strategy::grisu::format_exact,\n                                                     *num, sign, precision,\n                                                     false, &mut buf, &mut parts);\n@@ -39,7 +39,7 @@ fn float_to_decimal_common_shortest<T>(fmt: &mut Formatter,\n     unsafe {\n         // enough for f32 and f64\n         let mut buf: [u8; flt2dec::MAX_SIG_DIGITS] = mem::uninitialized();\n-        let mut parts: [flt2dec::Part; 5] = mem::uninitialized();\n+        let mut parts: [flt2dec::Part; 4] = mem::uninitialized();\n         let formatted = flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest,\n                                                  *num, sign, 0, false, &mut buf, &mut parts);\n         fmt.pad_formatted_parts(&formatted)\n@@ -75,7 +75,7 @@ fn float_to_exponential_common_exact<T>(fmt: &mut Formatter, num: &T,\n {\n     unsafe {\n         let mut buf: [u8; 1024] = mem::uninitialized(); // enough for f32 and f64\n-        let mut parts: [flt2dec::Part; 7] = mem::uninitialized();\n+        let mut parts: [flt2dec::Part; 6] = mem::uninitialized();\n         let formatted = flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact,\n                                                   *num, sign, precision,\n                                                   upper, &mut buf, &mut parts);\n@@ -94,7 +94,7 @@ fn float_to_exponential_common_shortest<T>(fmt: &mut Formatter,\n     unsafe {\n         // enough for f32 and f64\n         let mut buf: [u8; flt2dec::MAX_SIG_DIGITS] = mem::uninitialized();\n-        let mut parts: [flt2dec::Part; 7] = mem::uninitialized();\n+        let mut parts: [flt2dec::Part; 6] = mem::uninitialized();\n         let formatted = flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest,\n                                                      *num, sign, (0, 0), upper,\n                                                      &mut buf, &mut parts);"}, {"sha": "77cbdb98c830480ff55f4e245c51cbae4fd5ef87", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -11,7 +11,7 @@\n use cmp::Ordering;\n \n use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, FlatMap, Fuse};\n-use super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, Take, TakeWhile, Rev};\n+use super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile, Rev};\n use super::{Zip, Sum, Product};\n use super::{ChainState, FromIterator, ZipImpl};\n \n@@ -258,6 +258,39 @@ pub trait Iterator {\n         None\n     }\n \n+    /// Creates an iterator starting at the same point, but stepping by\n+    /// the given amount at each iteration.\n+    ///\n+    /// Note that it will always return the first element of the range,\n+    /// regardless of the step given.\n+    ///\n+    /// # Panics\n+    ///\n+    /// The method will panic if the given step is `0`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iterator_step_by)]\n+    /// let a = [0, 1, 2, 3, 4, 5];\n+    /// let mut iter = a.into_iter().step_by(2);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&0));\n+    /// assert_eq!(iter.next(), Some(&2));\n+    /// assert_eq!(iter.next(), Some(&4));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iterator_step_by\",\n+               reason = \"unstable replacement of Range::step_by\",\n+               issue = \"27741\")]\n+    fn step_by(self, step: usize) -> StepBy<Self> where Self: Sized {\n+        assert!(step != 0);\n+        StepBy{iter: self, step: step - 1, first_take: true}\n+    }\n+\n     /// Takes two iterators and creates a new iterator over both in sequence.\n     ///\n     /// `chain()` will return a new iterator which will first iterate over"}, {"sha": "420ff0f71193b47bdcf843db68558b27836c8e90", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -313,7 +313,7 @@ pub use self::iterator::Iterator;\n pub use self::range::Step;\n #[unstable(feature = \"step_by\", reason = \"recent addition\",\n            issue = \"27741\")]\n-pub use self::range::StepBy;\n+pub use self::range::StepBy as DeprecatedStepBy;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::sources::{Repeat, repeat};\n@@ -520,6 +520,41 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}\n \n+/// An iterator that steps by n elements every iteration.\n+///\n+/// This `struct` is created by the [`step_by`] method on [`Iterator`]. See\n+/// its documentation for more.\n+///\n+/// [`step_by`]: trait.Iterator.html#method.step_by\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n+#[unstable(feature = \"iterator_step_by\",\n+           reason = \"unstable replacement of Range::step_by\",\n+           issue = \"27741\")]\n+#[derive(Clone, Debug)]\n+pub struct StepBy<I> {\n+    iter: I,\n+    step: usize,\n+    first_take: bool,\n+}\n+\n+#[unstable(feature = \"iterator_step_by\",\n+           reason = \"unstable replacement of Range::step_by\",\n+           issue = \"27741\")]\n+impl<I> Iterator for StepBy<I> where I: Iterator {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.first_take {\n+            self.first_take = false;\n+            self.iter.next()\n+        } else {\n+            self.iter.nth(self.step)\n+        }\n+    }\n+}\n+\n /// An iterator that strings two iterators together.\n ///\n /// This `struct` is created by the [`chain`] method on [`Iterator`]. See its"}, {"sha": "74b9e7bf37d5110a754d51a532d2eef5e9ea8d00", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -410,8 +410,8 @@ fn determine_sign(sign: Sign, decoded: &FullDecoded, negative: bool) -> &'static\n /// it will only print given digits and nothing else.\n ///\n /// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n-/// There should be at least 5 parts available, due to the worst case like\n-/// `[+][0.][0000][45][0000]` with `frac_digits = 10`.\n+/// There should be at least 4 parts available, due to the worst case like\n+/// `[+][0.][0000][2][0000]` with `frac_digits = 10`.\n pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n                                  sign: Sign, frac_digits: usize, _upper: bool,\n                                  buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n@@ -465,8 +465,8 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n /// cannot be in this range, avoiding any confusion.\n ///\n /// The byte buffer should be at least `MAX_SIG_DIGITS` bytes long.\n-/// There should be at least 7 parts available, due to the worst case like\n-/// `[+][1][.][2345][e][-][67]`.\n+/// There should be at least 6 parts available, due to the worst case like\n+/// `[+][1][.][2345][e][-][6]`.\n pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,\n                                      sign: Sign, dec_bounds: (i16, i16), upper: bool,\n                                      buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n@@ -544,8 +544,8 @@ fn estimate_max_buf_len(exp: i16) -> usize {\n /// The byte buffer should be at least `ndigits` bytes long unless `ndigits` is\n /// so large that only the fixed number of digits will be ever written.\n /// (The tipping point for `f64` is about 800, so 1000 bytes should be enough.)\n-/// There should be at least 7 parts available, due to the worst case like\n-/// `[+][1][.][2345][e][-][67]`.\n+/// There should be at least 6 parts available, due to the worst case like\n+/// `[+][1][.][2345][e][-][6]`.\n pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n                                   sign: Sign, ndigits: usize, upper: bool,\n                                   buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>\n@@ -600,8 +600,8 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n /// The byte buffer should be enough for the output unless `frac_digits` is\n /// so large that only the fixed number of digits will be ever written.\n /// (The tipping point for `f64` is about 800, and 1000 bytes should be enough.)\n-/// There should be at least 5 parts available, due to the worst case like\n-/// `[+][0.][0000][45][0000]` with `frac_digits = 10`.\n+/// There should be at least 4 parts available, due to the worst case like\n+/// `[+][0.][0000][2][0000]` with `frac_digits = 10`.\n pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n                                     sign: Sign, frac_digits: usize, _upper: bool,\n                                     buf: &'a mut [u8], parts: &'a mut [Part<'a>]) -> Formatted<'a>"}, {"sha": "6cc374b13b7b3042257f13190f47f0bf95bdbd08", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -12,6 +12,7 @@ use super::Wrapping;\n \n use ops::*;\n \n+#[allow(unused_macros)]\n macro_rules! sh_impl_signed {\n     ($t:ident, $f:ident) => (\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "fc3af096b183880c4b3a61910e4fe5eae73e904d", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -799,6 +799,7 @@ macro_rules! neg_impl_numeric {\n     ($($t:ty)*) => { neg_impl_core!{ x => -x, $($t)*} }\n }\n \n+#[allow(unused_macros)]\n macro_rules! neg_impl_unsigned {\n     ($($t:ty)*) => {\n         neg_impl_core!{ x => {"}, {"sha": "4918e37eb35f08a266122920a2def0a07bb2ea81", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -429,7 +429,33 @@ impl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}\n \n /// Searches for chars that are equal to a given char\n impl<'a> Pattern<'a> for char {\n-    pattern_methods!(CharSearcher<'a>, CharEqPattern, CharSearcher);\n+    type Searcher = CharSearcher<'a>;\n+\n+    #[inline]\n+    fn into_searcher(self, haystack: &'a str) -> Self::Searcher {\n+        CharSearcher(CharEqPattern(self).into_searcher(haystack))\n+    }\n+\n+    #[inline]\n+    fn is_contained_in(self, haystack: &'a str) -> bool {\n+        if (self as u32) < 128 {\n+            haystack.as_bytes().contains(&(self as u8))\n+        } else {\n+            let mut buffer = [0u8; 4];\n+            self.encode_utf8(&mut buffer).is_contained_in(haystack)\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_prefix_of(self, haystack: &'a str) -> bool {\n+        CharEqPattern(self).is_prefix_of(haystack)\n+    }\n+\n+    #[inline]\n+    fn is_suffix_of(self, haystack: &'a str) -> bool where Self::Searcher: ReverseSearcher<'a>\n+    {\n+        CharEqPattern(self).is_suffix_of(haystack)\n+    }\n }\n \n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "ad91ba9be58f210f87032b2b62e4f597c108cfe1", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -144,6 +144,33 @@ fn test_iterator_chain_find() {\n     assert_eq!(iter.next(), None);\n }\n \n+#[test]\n+fn test_iterator_step_by() {\n+    // Identity\n+    // Replace with (0..).step_by(1) after Range::step_by gets removed\n+    let mut it = Iterator::step_by((0..), 1).take(3);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next(), Some(1));\n+    assert_eq!(it.next(), Some(2));\n+    assert_eq!(it.next(), None);\n+\n+    // Replace with (0..).step_by(3) after Range::step_by gets removed\n+    let mut it = Iterator::step_by((0..), 3).take(4);\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next(), Some(3));\n+    assert_eq!(it.next(), Some(6));\n+    assert_eq!(it.next(), Some(9));\n+    assert_eq!(it.next(), None);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_iterator_step_by_zero() {\n+    // Replace with (0..).step_by(0) after Range::step_by gets removed\n+    let mut it = Iterator::step_by((0..), 0);\n+    it.next();\n+}\n+\n #[test]\n fn test_filter_map() {\n     let it = (0..).step_by(1).take(10)\n@@ -1119,4 +1146,4 @@ fn test_step_replace_no_between() {\n     let y = x.replace_one();\n     assert_eq!(x, 1);\n     assert_eq!(y, 5);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "c52155ead4f0b2774fe73db9cb4f73048a475dc4", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -20,6 +20,7 @@\n #![feature(fixed_size_array)]\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n+#![feature(iterator_step_by)]\n #![feature(i128_type)]\n #![feature(iter_rfind)]\n #![feature(libc)]"}, {"sha": "09675564291a248b4ded93dddccee6aa6371a73f", "filename": "src/libproc_macro_plugin/quote.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibproc_macro_plugin%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibproc_macro_plugin%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Fquote.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -133,6 +133,14 @@ impl<'a> Quote for &'a str {\n     }\n }\n \n+impl Quote for usize {\n+    fn quote(&self) -> TokenStream {\n+        let integer_symbol = Symbol::intern(&self.to_string());\n+        TokenTree::Token(DUMMY_SP, Token::Literal(token::Lit::Integer(integer_symbol), None))\n+            .into()\n+    }\n+}\n+\n impl Quote for Ident {\n     fn quote(&self) -> TokenStream {\n         // FIXME(jseyfried) quote hygiene\n@@ -193,15 +201,17 @@ impl Quote for token::BinOpToken {\n impl Quote for Lit {\n     fn quote(&self) -> TokenStream {\n         macro_rules! gen_match {\n-            ($($i:ident),*) => {\n+            ($($i:ident),*; $($raw:ident),*) => {\n                 match *self {\n                     $( Lit::$i(lit) => quote!(::syntax::parse::token::Lit::$i((quote lit))), )*\n-                    _ => panic!(\"Unsupported literal\"),\n+                    $( Lit::$raw(lit, n) => {\n+                        quote!(::syntax::parse::token::Lit::$raw((quote lit), (quote n)))\n+                    })*\n                 }\n             }\n         }\n \n-        gen_match!(Byte, Char, Float, Str_, Integer, ByteStr)\n+        gen_match!(Byte, Char, Float, Str_, Integer, ByteStr; StrRaw, ByteStrRaw)\n     }\n }\n "}, {"sha": "9d64f511914d6d3c2ec5b16a95a28886a2f3c8ba", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -13,12 +13,12 @@ arena = { path = \"../libarena\" }\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.3\"\n+owning_ref = \"0.3.3\"\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n-rustc_llvm = { path = \"../librustc_llvm\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "15c4469b74694c98d3108c0002a9840329f6b53f", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -106,6 +106,8 @@ pub enum DepNode<D: Clone + Debug> {\n     UsedTraitImports(D),\n     ConstEval(D),\n     SymbolName(D),\n+    SpecializationGraph(D),\n+    ObjectSafety(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -116,6 +118,8 @@ pub enum DepNode<D: Clone + Debug> {\n     // than changes in the impl body.\n     TraitImpls(D),\n \n+    AllLocalTraitImpls,\n+\n     // Nodes representing caches. To properly handle a true cache, we\n     // don't use a DepTrackingMap, but rather we push a task node.\n     // Otherwise the write into the map would be incorrectly\n@@ -262,7 +266,10 @@ impl<D: Clone + Debug> DepNode<D> {\n             UsedTraitImports(ref d) => op(d).map(UsedTraitImports),\n             ConstEval(ref d) => op(d).map(ConstEval),\n             SymbolName(ref d) => op(d).map(SymbolName),\n+            SpecializationGraph(ref d) => op(d).map(SpecializationGraph),\n+            ObjectSafety(ref d) => op(d).map(ObjectSafety),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n+            AllLocalTraitImpls => Some(AllLocalTraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),\n             TraitSelect { ref trait_def_id, ref input_def_id } => {"}, {"sha": "470dcb4bd61e10e431bf8e3392e3734c288081c7", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -409,6 +409,67 @@ RFC. It is, however, [currently unimplemented][iss15872].\n [iss15872]: https://github.com/rust-lang/rust/issues/15872\n \"##,\n \n+E0119: r##\"\n+There are conflicting trait implementations for the same type.\n+Example of erroneous code:\n+\n+```compile_fail,E0119\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+\n+struct Foo {\n+    value: usize\n+}\n+\n+impl MyTrait for Foo { // error: conflicting implementations of trait\n+                       //        `MyTrait` for type `Foo`\n+    fn get(&self) -> usize { self.value }\n+}\n+```\n+\n+When looking for the implementation for the trait, the compiler finds\n+both the `impl<T> MyTrait for T` where T is all types and the `impl\n+MyTrait for Foo`. Since a trait cannot be implemented multiple times,\n+this is an error. So, when you write:\n+\n+```\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+```\n+\n+This makes the trait implemented on all types in the scope. So if you\n+try to implement it on another one after that, the implementations will\n+conflict. Example:\n+\n+```\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+\n+struct Foo;\n+\n+fn main() {\n+    let f = Foo;\n+\n+    f.get(); // the trait is implemented so we can use it\n+}\n+```\n+\"##,\n+\n E0133: r##\"\n Unsafe code was used outside of an unsafe function or block.\n "}, {"sha": "9537b40b28a0bec7234ccf31c8aec309c0dd135b", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -16,6 +16,7 @@\n \n use hir;\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, DefIndexAddressSpace};\n+use ich::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::StableHasher;\n@@ -34,7 +35,7 @@ use util::nodemap::NodeMap;\n pub struct DefPathTable {\n     index_to_key: [Vec<DefKey>; 2],\n     key_to_index: FxHashMap<DefKey, DefIndex>,\n-    def_path_hashes: [Vec<u64>; 2],\n+    def_path_hashes: [Vec<Fingerprint>; 2],\n }\n \n // Unfortunately we have to provide a manual impl of Clone because of the\n@@ -55,7 +56,7 @@ impl DefPathTable {\n \n     fn allocate(&mut self,\n                 key: DefKey,\n-                def_path_hash: u64,\n+                def_path_hash: Fingerprint,\n                 address_space: DefIndexAddressSpace)\n                 -> DefIndex {\n         let index = {\n@@ -79,7 +80,7 @@ impl DefPathTable {\n     }\n \n     #[inline(always)]\n-    pub fn def_path_hash(&self, index: DefIndex) -> u64 {\n+    pub fn def_path_hash(&self, index: DefIndex) -> Fingerprint {\n         self.def_path_hashes[index.address_space().index()]\n                             [index.as_array_index()]\n     }\n@@ -146,8 +147,8 @@ impl Decodable for DefPathTable {\n         let index_to_key_lo: Vec<DefKey> = Decodable::decode(d)?;\n         let index_to_key_hi: Vec<DefKey> = Decodable::decode(d)?;\n \n-        let def_path_hashes_lo: Vec<u64> = Decodable::decode(d)?;\n-        let def_path_hashes_hi: Vec<u64> = Decodable::decode(d)?;\n+        let def_path_hashes_lo: Vec<Fingerprint> = Decodable::decode(d)?;\n+        let def_path_hashes_hi: Vec<Fingerprint> = Decodable::decode(d)?;\n \n         let index_to_key = [index_to_key_lo, index_to_key_hi];\n         let def_path_hashes = [def_path_hashes_lo, def_path_hashes_hi];\n@@ -210,7 +211,7 @@ pub struct DefKey {\n }\n \n impl DefKey {\n-    fn compute_stable_hash(&self, parent_hash: u64) -> u64 {\n+    fn compute_stable_hash(&self, parent_hash: Fingerprint) -> Fingerprint {\n         let mut hasher = StableHasher::new();\n \n         // We hash a 0u8 here to disambiguate between regular DefPath hashes,\n@@ -221,7 +222,7 @@ impl DefKey {\n         hasher.finish()\n     }\n \n-    fn root_parent_stable_hash(crate_name: &str, crate_disambiguator: &str) -> u64 {\n+    fn root_parent_stable_hash(crate_name: &str, crate_disambiguator: &str) -> Fingerprint {\n         let mut hasher = StableHasher::new();\n         // Disambiguate this from a regular DefPath hash,\n         // see compute_stable_hash() above.\n@@ -396,7 +397,7 @@ impl Definitions {\n     }\n \n     #[inline(always)]\n-    pub fn def_path_hash(&self, index: DefIndex) -> u64 {\n+    pub fn def_path_hash(&self, index: DefIndex) -> Fingerprint {\n         self.table.def_path_hash(index)\n     }\n "}, {"sha": "868730edfedda83b1d4d10ef586ca3f37b75dc58", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -497,15 +497,15 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn trait_impls(&self, trait_did: DefId) -> &'hir [NodeId] {\n-        self.dep_graph.read(DepNode::TraitImpls(trait_did));\n+        self.dep_graph.read(DepNode::AllLocalTraitImpls);\n \n         // NB: intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_impls.get(&trait_did).map_or(&[], |xs| &xs[..])\n     }\n \n     pub fn trait_default_impl(&self, trait_did: DefId) -> Option<NodeId> {\n-        self.dep_graph.read(DepNode::TraitImpls(trait_did));\n+        self.dep_graph.read(DepNode::AllLocalTraitImpls);\n \n         // NB: intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here"}, {"sha": "a947f6aeff709af0ebc9ec71a47658cc2988e084", "filename": "src/librustc/ich/fingerprint.rs", "status": "modified", "additions": 33, "deletions": 45, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Ffingerprint.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -10,87 +10,75 @@\n \n use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n use rustc_data_structures::stable_hasher;\n-use rustc_data_structures::ToHex;\n-\n-const FINGERPRINT_LENGTH: usize = 16;\n+use std::mem;\n+use std::slice;\n \n #[derive(Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Clone, Copy)]\n-pub struct Fingerprint(pub [u8; FINGERPRINT_LENGTH]);\n+pub struct Fingerprint(u64, u64);\n \n impl Fingerprint {\n     #[inline]\n     pub fn zero() -> Fingerprint {\n-        Fingerprint([0; FINGERPRINT_LENGTH])\n+        Fingerprint(0, 0)\n     }\n \n+    #[inline]\n     pub fn from_smaller_hash(hash: u64) -> Fingerprint {\n-        let mut result = Fingerprint::zero();\n-        result.0[0] = (hash >>  0) as u8;\n-        result.0[1] = (hash >>  8) as u8;\n-        result.0[2] = (hash >> 16) as u8;\n-        result.0[3] = (hash >> 24) as u8;\n-        result.0[4] = (hash >> 32) as u8;\n-        result.0[5] = (hash >> 40) as u8;\n-        result.0[6] = (hash >> 48) as u8;\n-        result.0[7] = (hash >> 56) as u8;\n-        result\n+        Fingerprint(hash, hash)\n     }\n \n+    #[inline]\n     pub fn to_smaller_hash(&self) -> u64 {\n-        ((self.0[0] as u64) <<  0) |\n-        ((self.0[1] as u64) <<  8) |\n-        ((self.0[2] as u64) << 16) |\n-        ((self.0[3] as u64) << 24) |\n-        ((self.0[4] as u64) << 32) |\n-        ((self.0[5] as u64) << 40) |\n-        ((self.0[6] as u64) << 48) |\n-        ((self.0[7] as u64) << 56)\n+        self.0\n     }\n \n     pub fn to_hex(&self) -> String {\n-        self.0.to_hex()\n+        format!(\"{:x}{:x}\", self.0, self.1)\n     }\n }\n \n impl Encodable for Fingerprint {\n     #[inline]\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        for &byte in &self.0 {\n-            s.emit_u8(byte)?;\n-        }\n-        Ok(())\n+        s.emit_u64(self.0.to_le())?;\n+        s.emit_u64(self.1.to_le())\n     }\n }\n \n impl Decodable for Fingerprint {\n     #[inline]\n     fn decode<D: Decoder>(d: &mut D) -> Result<Fingerprint, D::Error> {\n-        let mut result = Fingerprint([0u8; FINGERPRINT_LENGTH]);\n-        for byte in &mut result.0 {\n-            *byte = d.read_u8()?;\n-        }\n-        Ok(result)\n+        let _0 = u64::from_le(d.read_u64()?);\n+        let _1 = u64::from_le(d.read_u64()?);\n+        Ok(Fingerprint(_0, _1))\n     }\n }\n \n impl ::std::fmt::Display for Fingerprint {\n     fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        for i in 0 .. self.0.len() {\n-            if i > 0 {\n-                write!(formatter, \"::\")?;\n-            }\n-\n-            write!(formatter, \"{}\", self.0[i])?;\n-        }\n-        Ok(())\n+        write!(formatter, \"{:x}-{:x}\", self.0, self.1)\n     }\n }\n \n-\n impl stable_hasher::StableHasherResult for Fingerprint {\n     fn finish(mut hasher: stable_hasher::StableHasher<Self>) -> Self {\n-        let mut fingerprint = Fingerprint::zero();\n-        fingerprint.0.copy_from_slice(hasher.finalize());\n-        fingerprint\n+        let hash_bytes: &[u8] = hasher.finalize();\n+\n+        assert!(hash_bytes.len() >= mem::size_of::<u64>() * 2);\n+        let hash_bytes: &[u64] = unsafe {\n+            slice::from_raw_parts(hash_bytes.as_ptr() as *const u64, 2)\n+        };\n+\n+        // The bytes returned bytes the Blake2B hasher are always little-endian.\n+        Fingerprint(u64::from_le(hash_bytes[0]), u64::from_le(hash_bytes[1]))\n+    }\n+}\n+\n+impl<CTX> stable_hasher::HashStable<CTX> for Fingerprint {\n+    #[inline]\n+    fn hash_stable<W: stable_hasher::StableHasherResult>(&self,\n+                                          _: &mut CTX,\n+                                          hasher: &mut stable_hasher::StableHasher<W>) {\n+        ::std::hash::Hash::hash(self, hasher);\n     }\n }"}, {"sha": "f25ec8ecd4d71beee729bf73ba0107d38cc38fa8", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -16,7 +16,7 @@ use ty;\n use util::nodemap::NodeMap;\n \n use std::hash as std_hash;\n-use std::collections::{HashMap, HashSet};\n+use std::collections::{HashMap, HashSet, BTreeMap};\n \n use syntax::ast;\n use syntax::attr;\n@@ -110,7 +110,7 @@ impl<'a, 'tcx: 'a> StableHashingContext<'a, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn def_path_hash(&mut self, def_id: DefId) -> u64 {\n+    pub fn def_path_hash(&mut self, def_id: DefId) -> ich::Fingerprint {\n         self.tcx.def_path_hash(def_id)\n     }\n \n@@ -348,3 +348,25 @@ pub fn hash_stable_nodemap<'a, 'tcx, V, W>(hcx: &mut StableHashingContext<'a, 't\n         hcx.tcx.hir.definitions().node_to_hir_id(*node_id).local_id\n     });\n }\n+\n+\n+pub fn hash_stable_btreemap<'a, 'tcx, K, V, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                                      hasher: &mut StableHasher<W>,\n+                                                      map: &BTreeMap<K, V>,\n+                                                      extract_stable_key: F)\n+    where K: Eq + Ord,\n+          V: HashStable<StableHashingContext<'a, 'tcx>>,\n+          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          W: StableHasherResult,\n+{\n+    let mut keys: Vec<_> = map.keys()\n+                              .map(|k| (extract_stable_key(hcx, k), k))\n+                              .collect();\n+    keys.sort_unstable_by_key(|&(ref stable_key, _)| stable_key.clone());\n+    keys.len().hash_stable(hcx, hasher);\n+    for (stable_key, key) in keys {\n+        stable_key.hash_stable(hcx, hasher);\n+        map[key].hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "5b23809085053d09b2cf6a821a25140dc9315602", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -13,7 +13,8 @@\n pub use self::fingerprint::Fingerprint;\n pub use self::caching_codemap_view::CachingCodemapView;\n pub use self::hcx::{StableHashingContext, NodeIdHashingMode, hash_stable_hashmap,\n-                    hash_stable_hashset, hash_stable_nodemap};\n+                    hash_stable_hashset, hash_stable_nodemap,\n+                    hash_stable_btreemap};\n mod fingerprint;\n mod caching_codemap_view;\n mod hcx;"}, {"sha": "aabb6aff55140c4138efecfa741db1245b2e0e4b", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -39,10 +39,12 @@ use super::sub::Sub;\n use super::InferCtxt;\n use super::{MiscVariable, TypeTrace};\n \n+use hir::def_id::DefId;\n use ty::{IntType, UintType};\n use ty::{self, Ty, TyCtxt};\n use ty::error::TypeError;\n use ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use ty::subst::Substs;\n use traits::{Obligation, PredicateObligations};\n \n use syntax::ast;\n@@ -336,6 +338,23 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n         Ok(ty::Binder(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n \n+    fn relate_item_substs(&mut self,\n+                          item_def_id: DefId,\n+                          a_subst: &'tcx Substs<'tcx>,\n+                          b_subst: &'tcx Substs<'tcx>)\n+                          -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n+    {\n+        if self.ambient_variance == ty::Variance::Invariant {\n+            // Avoid fetching the variance if we are in an invariant\n+            // context; no need, and it can induce dependency cycles\n+            // (e.g. #41849).\n+            relate::relate_substs(self, None, a_subst, b_subst)\n+        } else {\n+            let opt_variances = self.tcx().variances_of(item_def_id);\n+            relate::relate_substs(self, Some(&opt_variances), a_subst, b_subst)\n+        }\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n                                              variance: ty::Variance,\n                                              a: &T,"}, {"sha": "f32ee7900646b0e4f1c82e9b415362e85dbc533d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -54,7 +54,7 @@ extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n extern crate libc;\n-extern crate rustc_llvm as llvm;\n+extern crate owning_ref;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n extern crate serialize;"}, {"sha": "07140f71aebaa1b68253f71e3aef28372800d397", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -76,6 +76,12 @@ declare_lint! {\n     \"detects unreachable patterns\"\n }\n \n+declare_lint! {\n+    pub UNUSED_MACROS,\n+    Warn,\n+    \"detects macros that were not used\"\n+}\n+\n declare_lint! {\n     pub WARNINGS,\n     Warn,\n@@ -259,6 +265,7 @@ impl LintPass for HardwiredLints {\n             DEAD_CODE,\n             UNREACHABLE_CODE,\n             UNREACHABLE_PATTERNS,\n+            UNUSED_MACROS,\n             WARNINGS,\n             UNUSED_FEATURES,\n             STABLE_FEATURES,"}, {"sha": "9d5ba2c8f950101547a810d5ea2a398f044249f0", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -49,6 +49,7 @@ use hir;\n use hir::def_id::LOCAL_CRATE;\n use hir::intravisit as hir_visit;\n use syntax::visit as ast_visit;\n+use syntax::tokenstream::ThinTokenStream;\n \n /// Information about the registered lints.\n ///\n@@ -1125,6 +1126,13 @@ impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n     fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n         run_lints!(self, check_attribute, early_passes, attr);\n     }\n+\n+    fn visit_mac_def(&mut self, _mac: &'a ThinTokenStream, id: ast::NodeId) {\n+        let lints = self.sess.lints.borrow_mut().take(id);\n+        for early_lint in lints {\n+            self.early_lint(&early_lint);\n+        }\n+    }\n }\n \n enum CheckLintNameResult {"}, {"sha": "8ad1db7859566d41d26147eeb7777084321e5dd1", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -36,8 +36,9 @@ use session::search_paths::PathKind;\n use util::nodemap::{NodeSet, DefIdMap};\n \n use std::any::Any;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::rc::Rc;\n+use owning_ref::ErasedBoxRef;\n use syntax::ast;\n use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n@@ -201,11 +202,33 @@ impl EncodedMetadataHashes {\n     }\n }\n \n+/// The backend's way to give the crate store access to the metadata in a library.\n+/// Note that it returns the raw metadata bytes stored in the library file, whether\n+/// it is compressed, uncompressed, some weird mix, etc.\n+/// rmeta files are backend independent and not handled here.\n+///\n+/// At the time of this writing, there is only one backend and one way to store\n+/// metadata in library -- this trait just serves to decouple rustc_metadata from\n+/// the archive reader, which depends on LLVM.\n+pub trait MetadataLoader {\n+    fn get_rlib_metadata(&self,\n+                         target: &Target,\n+                         filename: &Path)\n+                         -> Result<ErasedBoxRef<[u8]>, String>;\n+    fn get_dylib_metadata(&self,\n+                          target: &Target,\n+                          filename: &Path)\n+                          -> Result<ErasedBoxRef<[u8]>, String>;\n+}\n+\n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n pub trait CrateStore {\n     fn crate_data_as_rc_any(&self, krate: CrateNum) -> Rc<Any>;\n \n+    // access to the metadata loader\n+    fn metadata_loader(&self) -> &MetadataLoader;\n+\n     // item info\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::Ref<'a, DefIdMap<DefId>>;\n@@ -259,7 +282,7 @@ pub trait CrateStore {\n                     -> Option<DefId>;\n     fn def_key(&self, def: DefId) -> DefKey;\n     fn def_path(&self, def: DefId) -> hir_map::DefPath;\n-    fn def_path_hash(&self, def: DefId) -> u64;\n+    fn def_path_hash(&self, def: DefId) -> ich::Fingerprint;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<def::Export>;\n     fn load_macro(&self, did: DefId, sess: &Session) -> LoadedMacro;\n@@ -275,8 +298,6 @@ pub trait CrateStore {\n     fn used_link_args(&self) -> Vec<String>;\n \n     // utility functions\n-    fn metadata_filename(&self) -> &str;\n-    fn metadata_section_name(&self, target: &Target) -> &str;\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>;\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n@@ -393,7 +414,7 @@ impl CrateStore for DummyCrateStore {\n     fn def_path(&self, def: DefId) -> hir_map::DefPath {\n         bug!(\"relative_def_path\")\n     }\n-    fn def_path_hash(&self, def: DefId) -> u64 {\n+    fn def_path_hash(&self, def: DefId) -> ich::Fingerprint {\n         bug!(\"wa\")\n     }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { bug!(\"struct_field_names\") }\n@@ -413,8 +434,6 @@ impl CrateStore for DummyCrateStore {\n     fn used_link_args(&self) -> Vec<String> { vec![] }\n \n     // utility functions\n-    fn metadata_filename(&self) -> &str { bug!(\"metadata_filename\") }\n-    fn metadata_section_name(&self, target: &Target) -> &str { bug!(\"metadata_section_name\") }\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n         { vec![] }\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n@@ -427,6 +446,9 @@ impl CrateStore for DummyCrateStore {\n         bug!(\"encode_metadata\")\n     }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n+\n+    // access to the metadata loader\n+    fn metadata_loader(&self) -> &MetadataLoader { bug!(\"metadata_loader\") }\n }\n \n pub trait CrateLoader {"}, {"sha": "7cb5f2510d5c7acdc363048165bca73f44d2d85d", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -328,7 +328,7 @@ top_level_options!(\n     }\n );\n \n-#[derive(Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum PrintRequest {\n     FileNames,\n     Sysroot,\n@@ -824,9 +824,9 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n     linker: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"system linker to link outputs with\"),\n     link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n-        \"a single extra argument to pass to the linker (can be used several times)\"),\n+        \"a single extra argument to append to the linker invocation (can be used several times)\"),\n     link_args: Option<Vec<String>> = (None, parse_opt_list, [UNTRACKED],\n-        \"extra arguments to pass to the linker (space separated)\"),\n+        \"extra arguments to append to the linker invocation (space separated)\"),\n     link_dead_code: bool = (false, parse_bool, [UNTRACKED],\n         \"don't let linker strip dead code (turning it on can be used for code coverage)\"),\n     lto: bool = (false, parse_bool, [TRACKED],\n@@ -963,7 +963,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"attempt to recover from parse errors (experimental)\"),\n     incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"enable incremental compilation (experimental)\"),\n-    incremental_cc: bool = (false, parse_bool, [UNTRACKED],\n+    incremental_cc: bool = (true, parse_bool, [UNTRACKED],\n           \"enable cross-crate incremental compilation (even more experimental)\"),\n     incremental_info: bool = (false, parse_bool, [UNTRACKED],\n         \"print high-level information about incremental reuse (or the lack thereof)\"),\n@@ -1029,6 +1029,10 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"add a mapping target to the file path remapping config\"),\n     force_unstable_if_unmarked: bool = (false, parse_bool, [TRACKED],\n         \"force all crates to be `rustc_private` unstable\"),\n+    pre_link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n+        \"a single extra argument to prepend the linker invocation (can be used several times)\"),\n+    pre_link_args: Option<Vec<String>> = (None, parse_opt_list, [UNTRACKED],\n+        \"extra arguments to prepend to the linker invocation (space separated)\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "47b988a21b4c1d402628ff043556310704bd3b7c", "filename": "src/librustc/session/filesearch.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Ffilesearch.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -159,9 +159,14 @@ pub fn get_or_default_sysroot() -> PathBuf {\n         })\n     }\n \n-    match canonicalize(env::current_exe().ok()) {\n-        Some(mut p) => { p.pop(); p.pop(); p }\n-        None => bug!(\"can't determine value for sysroot\")\n+    match env::current_exe() {\n+        Ok(exe) => {\n+            match canonicalize(Some(exe)) {\n+                Some(mut p) => { p.pop(); p.pop(); return p; },\n+                None => bug!(\"can't determine value for sysroot\")\n+            }\n+        }\n+        Err(ref e) => panic!(format!(\"failed to get current_exe: {}\", e))\n     }\n }\n "}, {"sha": "814246330a4c2f7b8da5e640ebbb536c83910423", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -37,19 +37,16 @@ use syntax_pos::{Span, MultiSpan, FileMap};\n use rustc_back::{LinkerFlavor, PanicStrategy};\n use rustc_back::target::Target;\n use rustc_data_structures::flock;\n-use llvm;\n \n use std::path::{Path, PathBuf};\n use std::cell::{self, Cell, RefCell};\n use std::collections::HashMap;\n use std::env;\n-use std::ffi::CString;\n use std::io::Write;\n use std::rc::Rc;\n use std::fmt;\n use std::time::Duration;\n use std::sync::Arc;\n-use libc::c_int;\n \n mod code_stats;\n pub mod config;\n@@ -713,8 +710,6 @@ pub fn build_session_(sopts: config::Options,\n         out_of_fuel: Cell::new(false),\n     };\n \n-    init_llvm(&sess);\n-\n     sess\n }\n \n@@ -743,55 +738,6 @@ pub enum IncrCompSession {\n     }\n }\n \n-fn init_llvm(sess: &Session) {\n-    unsafe {\n-        // Before we touch LLVM, make sure that multithreading is enabled.\n-        use std::sync::Once;\n-        static INIT: Once = Once::new();\n-        static mut POISONED: bool = false;\n-        INIT.call_once(|| {\n-            if llvm::LLVMStartMultithreaded() != 1 {\n-                // use an extra bool to make sure that all future usage of LLVM\n-                // cannot proceed despite the Once not running more than once.\n-                POISONED = true;\n-            }\n-\n-            configure_llvm(sess);\n-        });\n-\n-        if POISONED {\n-            bug!(\"couldn't enable multi-threaded LLVM\");\n-        }\n-    }\n-}\n-\n-unsafe fn configure_llvm(sess: &Session) {\n-    let mut llvm_c_strs = Vec::new();\n-    let mut llvm_args = Vec::new();\n-\n-    {\n-        let mut add = |arg: &str| {\n-            let s = CString::new(arg).unwrap();\n-            llvm_args.push(s.as_ptr());\n-            llvm_c_strs.push(s);\n-        };\n-        add(\"rustc\"); // fake program name\n-        if sess.time_llvm_passes() { add(\"-time-passes\"); }\n-        if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n-\n-        for arg in &sess.opts.cg.llvm_args {\n-            add(&(*arg));\n-        }\n-    }\n-\n-    llvm::LLVMInitializePasses();\n-\n-    llvm::initialize_available_targets();\n-\n-    llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n-                                 llvm_args.as_ptr());\n-}\n-\n pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n     let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {"}, {"sha": "1823373348badfb8ef177602d852f4ed29ff0217", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -619,8 +619,6 @@ pub fn get_vtable_methods<'a, 'tcx>(\n     debug!(\"get_vtable_methods({:?})\", trait_ref);\n \n     supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n-        tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-\n         let trait_methods = tcx.associated_items(trait_ref.def_id())\n             .filter(|item| item.kind == ty::AssociatedKind::Method);\n \n@@ -782,3 +780,19 @@ impl<'tcx> TraitObligation<'tcx> {\n         ty::Binder(self.predicate.skip_binder().self_ty())\n     }\n }\n+\n+pub fn provide(providers: &mut ty::maps::Providers) {\n+    *providers = ty::maps::Providers {\n+        is_object_safe: object_safety::is_object_safe_provider,\n+        specialization_graph_of: specialize::specialization_graph_provider,\n+        ..*providers\n+    };\n+}\n+\n+pub fn provide_extern(providers: &mut ty::maps::Providers) {\n+    *providers = ty::maps::Providers {\n+        is_object_safe: object_safety::is_object_safe_provider,\n+        specialization_graph_of: specialize::specialization_graph_provider,\n+        ..*providers\n+    };\n+}"}, {"sha": "0e3a53129d157fe2af455cacd25a59597c87b22f", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -77,25 +77,6 @@ pub enum MethodViolationCode {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn is_object_safe(self, trait_def_id: DefId) -> bool {\n-        // Because we query yes/no results frequently, we keep a cache:\n-        let def = self.trait_def(trait_def_id);\n-\n-        let result = def.object_safety().unwrap_or_else(|| {\n-            let result = self.object_safety_violations(trait_def_id).is_empty();\n-\n-            // Record just a yes/no result in the cache; this is what is\n-            // queried most frequently. Note that this may overwrite a\n-            // previous result, but always with the same thing.\n-            def.set_object_safety(result);\n-\n-            result\n-        });\n-\n-        debug!(\"is_object_safe({:?}) = {}\", trait_def_id, result);\n-\n-        result\n-    }\n \n     /// Returns the object safety violations that affect\n     /// astconv - currently, Self in supertraits. This is needed\n@@ -391,3 +372,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         error\n     }\n }\n+\n+pub(super) fn is_object_safe_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                         trait_def_id: DefId)\n+                                         -> bool {\n+    tcx.object_safety_violations(trait_def_id).is_empty()\n+}"}, {"sha": "d7911870f391a541dfd36297c3437999350603b1", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 89, "deletions": 129, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -900,96 +900,50 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                 // In either case, we handle this by not adding a\n                 // candidate for an impl if it contains a `default`\n                 // type.\n-                let opt_node_item = assoc_ty_def(selcx,\n-                                                 impl_data.impl_def_id,\n-                                                 obligation.predicate.item_name);\n-                let new_candidate = if let Some(node_item) = opt_node_item {\n-                    let is_default = if node_item.node.is_from_trait() {\n-                        // If true, the impl inherited a `type Foo = Bar`\n-                        // given in the trait, which is implicitly default.\n-                        // Otherwise, the impl did not specify `type` and\n-                        // neither did the trait:\n-                        //\n-                        // ```rust\n-                        // trait Foo { type T; }\n-                        // impl Foo for Bar { }\n-                        // ```\n-                        //\n-                        // This is an error, but it will be\n-                        // reported in `check_impl_items_against_trait`.\n-                        // We accept it here but will flag it as\n-                        // an error when we confirm the candidate\n-                        // (which will ultimately lead to `normalize_to_error`\n-                        // being invoked).\n-                        node_item.item.defaultness.has_value()\n-                    } else {\n-                        node_item.item.defaultness.is_default() ||\n-                        selcx.tcx().impl_is_default(node_item.node.def_id())\n-                    };\n-\n-                    // Only reveal a specializable default if we're past type-checking\n-                    // and the obligations is monomorphic, otherwise passes such as\n-                    // transmute checking and polymorphic MIR optimizations could\n-                    // get a result which isn't correct for all monomorphizations.\n-                    if !is_default {\n+                let node_item = assoc_ty_def(selcx,\n+                                             impl_data.impl_def_id,\n+                                             obligation.predicate.item_name);\n+\n+                let is_default = if node_item.node.is_from_trait() {\n+                    // If true, the impl inherited a `type Foo = Bar`\n+                    // given in the trait, which is implicitly default.\n+                    // Otherwise, the impl did not specify `type` and\n+                    // neither did the trait:\n+                    //\n+                    // ```rust\n+                    // trait Foo { type T; }\n+                    // impl Foo for Bar { }\n+                    // ```\n+                    //\n+                    // This is an error, but it will be\n+                    // reported in `check_impl_items_against_trait`.\n+                    // We accept it here but will flag it as\n+                    // an error when we confirm the candidate\n+                    // (which will ultimately lead to `normalize_to_error`\n+                    // being invoked).\n+                    node_item.item.defaultness.has_value()\n+                } else {\n+                    node_item.item.defaultness.is_default() ||\n+                    selcx.tcx().impl_is_default(node_item.node.def_id())\n+                };\n+\n+                // Only reveal a specializable default if we're past type-checking\n+                // and the obligations is monomorphic, otherwise passes such as\n+                // transmute checking and polymorphic MIR optimizations could\n+                // get a result which isn't correct for all monomorphizations.\n+                let new_candidate = if !is_default {\n+                    Some(ProjectionTyCandidate::Select)\n+                } else if selcx.projection_mode() == Reveal::All {\n+                    assert!(!poly_trait_ref.needs_infer());\n+                    if !poly_trait_ref.needs_subst() {\n                         Some(ProjectionTyCandidate::Select)\n-                    } else if selcx.projection_mode() == Reveal::All {\n-                        assert!(!poly_trait_ref.needs_infer());\n-                        if !poly_trait_ref.needs_subst() {\n-                            Some(ProjectionTyCandidate::Select)\n-                        } else {\n-                            None\n-                        }\n                     } else {\n                         None\n                     }\n                 } else {\n-                    // This is saying that neither the trait nor\n-                    // the impl contain a definition for this\n-                    // associated type.  Normally this situation\n-                    // could only arise through a compiler bug --\n-                    // if the user wrote a bad item name, it\n-                    // should have failed in astconv. **However**,\n-                    // at coherence-checking time, we only look at\n-                    // the topmost impl (we don't even consider\n-                    // the trait itself) for the definition -- and\n-                    // so in that case it may be that the trait\n-                    // *DOES* have a declaration, but we don't see\n-                    // it, and we end up in this branch.\n-                    //\n-                    // This is kind of tricky to handle actually.\n-                    // For now, we just unconditionally ICE,\n-                    // because otherwise, examples like the\n-                    // following will succeed:\n-                    //\n-                    // ```\n-                    // trait Assoc {\n-                    //     type Output;\n-                    // }\n-                    //\n-                    // impl<T> Assoc for T {\n-                    //     default type Output = bool;\n-                    // }\n-                    //\n-                    // impl Assoc for u8 {}\n-                    // impl Assoc for u16 {}\n-                    //\n-                    // trait Foo {}\n-                    // impl Foo for <u8 as Assoc>::Output {}\n-                    // impl Foo for <u16 as Assoc>::Output {}\n-                    //     return None;\n-                    // }\n-                    // ```\n-                    //\n-                    // The essential problem here is that the\n-                    // projection fails, leaving two unnormalized\n-                    // types, which appear not to unify -- so the\n-                    // overlap check succeeds, when it should\n-                    // fail.\n-                    span_bug!(obligation.cause.span,\n-                              \"Tried to project an inherited associated type during \\\n-                               coherence checking, which is currently not supported.\");\n+                    None\n                 };\n+\n                 candidate_set.vec.extend(new_candidate);\n             }\n             super::VtableParam(..) => {\n@@ -1274,35 +1228,25 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     let VtableImplData { substs, nested, impl_def_id } = impl_vtable;\n \n     let tcx = selcx.tcx();\n-    let trait_ref = obligation.predicate.trait_ref;\n     let assoc_ty = assoc_ty_def(selcx, impl_def_id, obligation.predicate.item_name);\n \n-    match assoc_ty {\n-        Some(node_item) => {\n-            let ty = if !node_item.item.defaultness.has_value() {\n-                // This means that the impl is missing a definition for the\n-                // associated type. This error will be reported by the type\n-                // checker method `check_impl_items_against_trait`, so here we\n-                // just return TyError.\n-                debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n-                       node_item.item.name,\n-                       obligation.predicate.trait_ref);\n-                tcx.types.err\n-            } else {\n-                tcx.type_of(node_item.item.def_id)\n-            };\n-            let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n-            Progress {\n-                ty: ty.subst(tcx, substs),\n-                obligations: nested,\n-                cacheable: true\n-            }\n-        }\n-        None => {\n-            span_bug!(obligation.cause.span,\n-                      \"No associated type for {:?}\",\n-                      trait_ref);\n-        }\n+    let ty = if !assoc_ty.item.defaultness.has_value() {\n+        // This means that the impl is missing a definition for the\n+        // associated type. This error will be reported by the type\n+        // checker method `check_impl_items_against_trait`, so here we\n+        // just return TyError.\n+        debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n+               assoc_ty.item.name,\n+               obligation.predicate.trait_ref);\n+        tcx.types.err\n+    } else {\n+        tcx.type_of(assoc_ty.item.def_id)\n+    };\n+    let substs = translate_substs(selcx.infcx(), impl_def_id, substs, assoc_ty.node);\n+    Progress {\n+        ty: ty.subst(tcx, substs),\n+        obligations: nested,\n+        cacheable: true\n     }\n }\n \n@@ -1315,27 +1259,43 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     selcx: &SelectionContext<'cx, 'gcx, 'tcx>,\n     impl_def_id: DefId,\n     assoc_ty_name: ast::Name)\n-    -> Option<specialization_graph::NodeItem<ty::AssociatedItem>>\n+    -> specialization_graph::NodeItem<ty::AssociatedItem>\n {\n-    let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n-    let trait_def = selcx.tcx().trait_def(trait_def_id);\n-\n-    if !trait_def.is_complete(selcx.tcx()) {\n-        let impl_node = specialization_graph::Node::Impl(impl_def_id);\n-        for item in impl_node.items(selcx.tcx()) {\n-            if item.kind == ty::AssociatedKind::Type && item.name == assoc_ty_name {\n-                return Some(specialization_graph::NodeItem {\n-                    node: specialization_graph::Node::Impl(impl_def_id),\n-                    item: item,\n-                });\n-            }\n+    let tcx = selcx.tcx();\n+    let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n+    let trait_def = tcx.trait_def(trait_def_id);\n+\n+    // This function may be called while we are still building the\n+    // specialization graph that is queried below (via TraidDef::ancestors()),\n+    // so, in order to avoid unnecessary infinite recursion, we manually look\n+    // for the associated item at the given impl.\n+    // If there is no such item in that impl, this function will fail with a\n+    // cycle error if the specialization graph is currently being built.\n+    let impl_node = specialization_graph::Node::Impl(impl_def_id);\n+    for item in impl_node.items(tcx) {\n+        if item.kind == ty::AssociatedKind::Type && item.name == assoc_ty_name {\n+            return specialization_graph::NodeItem {\n+                node: specialization_graph::Node::Impl(impl_def_id),\n+                item: item,\n+            };\n         }\n-        None\n+    }\n+\n+    if let Some(assoc_item) = trait_def\n+        .ancestors(tcx, impl_def_id)\n+        .defs(tcx, assoc_ty_name, ty::AssociatedKind::Type)\n+        .next() {\n+        assoc_item\n     } else {\n-        trait_def\n-            .ancestors(impl_def_id)\n-            .defs(selcx.tcx(), assoc_ty_name, ty::AssociatedKind::Type)\n-            .next()\n+        // This is saying that neither the trait nor\n+        // the impl contain a definition for this\n+        // associated type.  Normally this situation\n+        // could only arise through a compiler bug --\n+        // if the user wrote a bad item name, it\n+        // should have failed in astconv.\n+        bug!(\"No associated type `{}` for {}\",\n+             assoc_ty_name,\n+             tcx.item_path_str(impl_def_id))\n     }\n }\n "}, {"sha": "0e5779f9d17935b291fc1d72aec74fd879166c0f", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -27,6 +27,7 @@ use ty::subst::{Subst, Substs};\n use traits::{self, Reveal, ObligationCause};\n use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n+use std::rc::Rc;\n \n pub mod specialization_graph;\n \n@@ -118,7 +119,7 @@ pub fn find_associated_item<'a, 'tcx>(\n     let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n     let trait_def = tcx.trait_def(trait_def_id);\n \n-    let ancestors = trait_def.ancestors(impl_data.impl_def_id);\n+    let ancestors = trait_def.ancestors(tcx, impl_data.impl_def_id);\n     match ancestors.defs(tcx, item.name, item.kind).next() {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n@@ -285,3 +286,62 @@ impl SpecializesCache {\n         self.map.insert((a, b), result);\n     }\n }\n+\n+// Query provider for `specialization_graph_of`.\n+pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                      trait_id: DefId)\n+                                                      -> Rc<specialization_graph::Graph> {\n+    let mut sg = specialization_graph::Graph::new();\n+\n+    let mut trait_impls: Vec<DefId> = tcx.trait_impls_of(trait_id).iter().collect();\n+\n+    // The coherence checking implementation seems to rely on impls being\n+    // iterated over (roughly) in definition order, so we are sorting by\n+    // negated CrateNum (so remote definitions are visited first) and then\n+    // by a flattend version of the DefIndex.\n+    trait_impls.sort_unstable_by_key(|def_id| {\n+        (-(def_id.krate.as_u32() as i64),\n+         def_id.index.address_space().index(),\n+         def_id.index.as_array_index())\n+    });\n+\n+    for impl_def_id in trait_impls {\n+        if impl_def_id.is_local() {\n+            // This is where impl overlap checking happens:\n+            let insert_result = sg.insert(tcx, impl_def_id);\n+            // Report error if there was one.\n+            if let Err(overlap) = insert_result {\n+                let mut err = struct_span_err!(tcx.sess,\n+                                               tcx.span_of_impl(impl_def_id).unwrap(),\n+                                               E0119,\n+                                               \"conflicting implementations of trait `{}`{}:\",\n+                                               overlap.trait_desc,\n+                                               overlap.self_desc.clone().map_or(String::new(),\n+                                                                                |ty| {\n+                    format!(\" for type `{}`\", ty)\n+                }));\n+\n+                match tcx.span_of_impl(overlap.with_impl) {\n+                    Ok(span) => {\n+                        err.span_label(span, format!(\"first implementation here\"));\n+                        err.span_label(tcx.span_of_impl(impl_def_id).unwrap(),\n+                                       format!(\"conflicting implementation{}\",\n+                                                overlap.self_desc\n+                                                    .map_or(String::new(),\n+                                                            |ty| format!(\" for `{}`\", ty))));\n+                    }\n+                    Err(cname) => {\n+                        err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n+                    }\n+                }\n+\n+                err.emit();\n+            }\n+        } else {\n+            let parent = tcx.impl_parent(impl_def_id).unwrap_or(trait_id);\n+            sg.record_impl_from_cstore(tcx, parent, impl_def_id)\n+        }\n+    }\n+\n+    Rc::new(sg)\n+}"}, {"sha": "87c98a0ef0ed6daf16839d7a96f712dd99bde1f4", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -12,8 +12,9 @@ use super::{OverlapError, specializes};\n \n use hir::def_id::DefId;\n use traits::{self, Reveal};\n-use ty::{self, TyCtxt, TraitDef, TypeFoldable};\n+use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n+use std::rc::Rc;\n use syntax::ast::Name;\n use util::nodemap::{DefIdMap, FxHashMap};\n \n@@ -301,18 +302,19 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n }\n \n-pub struct Ancestors<'a> {\n-    trait_def: &'a TraitDef,\n+pub struct Ancestors {\n+    trait_def_id: DefId,\n+    specialization_graph: Rc<Graph>,\n     current_source: Option<Node>,\n }\n \n-impl<'a> Iterator for Ancestors<'a> {\n+impl Iterator for Ancestors {\n     type Item = Node;\n     fn next(&mut self) -> Option<Node> {\n         let cur = self.current_source.take();\n         if let Some(Node::Impl(cur_impl)) = cur {\n-            let parent = self.trait_def.specialization_graph.borrow().parent(cur_impl);\n-            if parent == self.trait_def.def_id {\n+            let parent = self.specialization_graph.parent(cur_impl);\n+            if parent == self.trait_def_id {\n                 self.current_source = Some(Node::Trait(parent));\n             } else {\n                 self.current_source = Some(Node::Impl(parent));\n@@ -336,7 +338,7 @@ impl<T> NodeItem<T> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Ancestors<'a> {\n+impl<'a, 'gcx, 'tcx> Ancestors {\n     /// Search the items from the given ancestors, returning each definition\n     /// with the given name and the given kind.\n     #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n@@ -351,9 +353,14 @@ impl<'a, 'gcx, 'tcx> Ancestors<'a> {\n \n /// Walk up the specialization ancestors of a given impl, starting with that\n /// impl itself.\n-pub fn ancestors<'a>(trait_def: &'a TraitDef, start_from_impl: DefId) -> Ancestors<'a> {\n+pub fn ancestors(tcx: TyCtxt,\n+                 trait_def_id: DefId,\n+                 start_from_impl: DefId)\n+                 -> Ancestors {\n+    let specialization_graph = tcx.specialization_graph_of(trait_def_id);\n     Ancestors {\n-        trait_def: trait_def,\n+        trait_def_id,\n+        specialization_graph,\n         current_source: Some(Node::Impl(start_from_impl)),\n     }\n }"}, {"sha": "85462bd9b1273ca2a40946ace10c0355abcb9212", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -18,10 +18,12 @@ use middle::region::RegionMaps;\n use mir;\n use mir::transform::{MirSuite, MirPassIndex};\n use session::CompileResult;\n+use traits::specialization_graph;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use ty::item_path;\n use ty::steal::Steal;\n use ty::subst::Substs;\n+use ty::fast_reject::SimplifiedType;\n use util::nodemap::{DefIdSet, NodeSet};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -98,6 +100,15 @@ impl Key for (CrateNum, DefId) {\n     }\n }\n \n+impl Key for (DefId, SimplifiedType) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}\n+\n impl<'tcx> Key for (DefId, &'tcx Substs<'tcx>) {\n     fn map_crate(&self) -> CrateNum {\n         self.0.krate\n@@ -391,6 +402,24 @@ impl<'tcx> QueryDescription for queries::is_mir_available<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::trait_impls_of<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"trait impls of `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::relevant_trait_impls_for<'tcx> {\n+    fn describe(tcx: TyCtxt, (def_id, ty): (DefId, SimplifiedType)) -> String {\n+        format!(\"relevant impls for: `({}, {:?})`\", tcx.item_path_str(def_id), ty)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_object_safe<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -592,7 +621,7 @@ macro_rules! define_map_struct {\n      output: $output:tt) => {\n         define_map_struct! {\n             tcx: $tcx,\n-            ready: ([pub] $attrs $name),\n+            ready: ([] $attrs $name),\n             input: ($($input)*),\n             output: $output\n         }\n@@ -820,6 +849,13 @@ define_maps! { <'tcx>\n     [] item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> Rc<BTreeMap<hir::BodyId, hir::Body>>,\n     [] const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n     [] is_mir_available: IsMirAvailable(DefId) -> bool,\n+\n+    [] trait_impls_of: TraitImpls(DefId) -> ty::trait_def::TraitImpls,\n+    // Note that TraitDef::for_each_relevant_impl() will do type simplication for you.\n+    [] relevant_trait_impls_for: relevant_trait_impls_for((DefId, SimplifiedType))\n+        -> ty::trait_def::TraitImpls,\n+    [] specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n+    [] is_object_safe: ObjectSafety(DefId) -> bool,\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -859,3 +895,7 @@ fn mir_keys(_: CrateNum) -> DepNode<DefId> {\n fn crate_variances(_: CrateNum) -> DepNode<DefId> {\n     DepNode::CrateVariances\n }\n+\n+fn relevant_trait_impls_for((def_id, _): (DefId, SimplifiedType)) -> DepNode<DefId> {\n+    DepNode::TraitImpls(def_id)\n+}"}, {"sha": "359722ce96ec9786f0131c197805fac38806bfe7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -19,7 +19,7 @@ use dep_graph::DepNode;\n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use ich::StableHashingContext;\n+use ich::{self, StableHashingContext};\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n@@ -80,7 +80,7 @@ pub use self::context::{Lift, TypeckTables};\n \n pub use self::instance::{Instance, InstanceDef};\n \n-pub use self::trait_def::{TraitDef, TraitFlags};\n+pub use self::trait_def::TraitDef;\n \n pub use self::maps::queries;\n \n@@ -2248,7 +2248,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn def_path_hash(self, def_id: DefId) -> u64 {\n+    pub fn def_path_hash(self, def_id: DefId) -> ich::Fingerprint {\n         if def_id.is_local() {\n             self.hir.definitions().def_path_hash(def_id.index)\n         } else {\n@@ -2324,37 +2324,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn trait_has_default_impl(self, trait_def_id: DefId) -> bool {\n-        let def = self.trait_def(trait_def_id);\n-        def.flags.get().intersects(TraitFlags::HAS_DEFAULT_IMPL)\n-    }\n-\n-    /// Populates the type context with all the implementations for the given\n-    /// trait if necessary.\n-    pub fn populate_implementations_for_trait_if_necessary(self, trait_id: DefId) {\n-        if trait_id.is_local() {\n-            return\n-        }\n-\n-        // The type is not local, hence we are reading this out of\n-        // metadata and don't need to track edges.\n-        let _ignore = self.dep_graph.in_ignore();\n-\n-        let def = self.trait_def(trait_id);\n-        if def.flags.get().intersects(TraitFlags::HAS_REMOTE_IMPLS) {\n-            return;\n-        }\n-\n-        debug!(\"populate_implementations_for_trait_if_necessary: searching for {:?}\", def);\n-\n-        for impl_def_id in self.sess.cstore.implementations_of_trait(Some(trait_id)) {\n-            let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n-\n-            // Record the trait->implementation mapping.\n-            let parent = self.impl_parent(impl_def_id).unwrap_or(trait_id);\n-            def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n-        }\n-\n-        def.flags.set(def.flags.get() | TraitFlags::HAS_REMOTE_IMPLS);\n+        self.trait_def(trait_def_id).has_default_impl\n     }\n \n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n@@ -2603,6 +2573,8 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         adt_dtorck_constraint,\n         def_span,\n         trait_of_item,\n+        trait_impls_of: trait_def::trait_impls_of_provider,\n+        relevant_trait_impls_for: trait_def::relevant_trait_impls_provider,\n         ..*providers\n     };\n }\n@@ -2611,6 +2583,8 @@ pub fn provide_extern(providers: &mut ty::maps::Providers) {\n     *providers = ty::maps::Providers {\n         adt_sized_constraint,\n         adt_dtorck_constraint,\n+        trait_impls_of: trait_def::trait_impls_of_provider,\n+        relevant_trait_impls_for: trait_def::relevant_trait_impls_provider,\n         ..*providers\n     };\n }"}, {"sha": "348d164af4190af2d12ba7592cdfb06bf8b8b0c7", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -29,6 +29,7 @@ use util::nodemap::FxHashMap;\n use serialize;\n \n use hir;\n+use ich;\n \n use self::InferTy::*;\n use self::TypeVariants::*;\n@@ -849,7 +850,7 @@ impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n         self.item_name // safe to skip the binder to access a name\n     }\n \n-    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (u64, InternedString) {\n+    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (ich::Fingerprint, InternedString) {\n         // We want something here that is stable across crate boundaries.\n         // The DefId isn't but the `deterministic_hash` of the corresponding\n         // DefPath is.\n@@ -884,7 +885,7 @@ impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n         self.skip_binder().item_name()\n     }\n \n-    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (u64, InternedString) {\n+    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (ich::Fingerprint, InternedString) {\n         self.skip_binder().sort_key(tcx)\n     }\n "}, {"sha": "86774136bd6cbc0c07741dd3c83b22b4a8ee8395", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 142, "deletions": 252, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,18 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::DepNode;\n-use hir::def_id::{DefId, LOCAL_CRATE};\n-use traits::{self, specialization_graph};\n-use ty;\n+use hir::def_id::DefId;\n+use ich::Fingerprint;\n+use traits::specialization_graph;\n use ty::fast_reject;\n-use ty::{Ty, TyCtxt, TraitRef};\n-use std::cell::{Cell, RefCell};\n+use ty::fold::TypeFoldable;\n+use ty::{Ty, TyCtxt};\n+use std::rc::Rc;\n use hir;\n-use util::nodemap::FxHashMap;\n-\n-use syntax::ast;\n-use syntax_pos::DUMMY_SP;\n \n /// A trait's definition with type information.\n pub struct TraitDef {\n@@ -33,237 +29,93 @@ pub struct TraitDef {\n     /// be usable with the sugar (or without it).\n     pub paren_sugar: bool,\n \n-    // Impls of a trait. To allow for quicker lookup, the impls are indexed by a\n-    // simplified version of their `Self` type: impls with a simplifiable `Self`\n-    // are stored in `nonblanket_impls` keyed by it, while all other impls are\n-    // stored in `blanket_impls`.\n-    //\n-    // A similar division is used within `specialization_graph`, but the ones\n-    // here are (1) stored as a flat list for the trait and (2) populated prior\n-    // to -- and used while -- determining specialization order.\n-    //\n-    // FIXME: solve the reentrancy issues and remove these lists in favor of the\n-    // ones in `specialization_graph`.\n-    //\n-    // These lists are tracked by `DepNode::TraitImpls`; we don't use\n-    // a DepTrackingMap but instead have the `TraitDef` insert the\n-    // required reads/writes.\n-\n-    /// Impls of the trait.\n-    nonblanket_impls: RefCell<\n-        FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n-    >,\n-\n-    /// Blanket impls associated with the trait.\n-    blanket_impls: RefCell<Vec<DefId>>,\n-\n-    /// The specialization order for impls of this trait.\n-    pub specialization_graph: RefCell<traits::specialization_graph::Graph>,\n-\n-    /// Various flags\n-    pub flags: Cell<TraitFlags>,\n-\n-    /// The number of impls we've added from the local crate.\n-    /// When this number matches up the list in the HIR map,\n-    /// we're done, and the specialization graph is correct.\n-    local_impl_count: Cell<usize>,\n+    pub has_default_impl: bool,\n \n     /// The ICH of this trait's DefPath, cached here so it doesn't have to be\n     /// recomputed all the time.\n-    pub def_path_hash: u64,\n+    pub def_path_hash: Fingerprint,\n }\n \n-impl<'a, 'gcx, 'tcx> TraitDef {\n-    pub fn new(def_id: DefId,\n-               unsafety: hir::Unsafety,\n-               paren_sugar: bool,\n-               def_path_hash: u64)\n-               -> TraitDef {\n-        TraitDef {\n-            def_id: def_id,\n-            paren_sugar: paren_sugar,\n-            unsafety: unsafety,\n-            nonblanket_impls: RefCell::new(FxHashMap()),\n-            blanket_impls: RefCell::new(vec![]),\n-            flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n-            local_impl_count: Cell::new(0),\n-            specialization_graph: RefCell::new(traits::specialization_graph::Graph::new()),\n-            def_path_hash: def_path_hash,\n-        }\n-    }\n+// We don't store the list of impls in a flat list because each cached list of\n+// `relevant_impls_for` we would then duplicate all blanket impls. By keeping\n+// blanket and non-blanket impls separate, we can share the list of blanket\n+// impls.\n+#[derive(Clone)]\n+pub struct TraitImpls {\n+    blanket_impls: Rc<Vec<DefId>>,\n+    non_blanket_impls: Rc<Vec<DefId>>,\n+}\n \n-    // returns None if not yet calculated\n-    pub fn object_safety(&self) -> Option<bool> {\n-        if self.flags.get().intersects(TraitFlags::OBJECT_SAFETY_VALID) {\n-            Some(self.flags.get().intersects(TraitFlags::IS_OBJECT_SAFE))\n-        } else {\n-            None\n+impl TraitImpls {\n+    pub fn iter(&self) -> TraitImplsIter {\n+        TraitImplsIter {\n+            blanket_impls: self.blanket_impls.clone(),\n+            non_blanket_impls: self.non_blanket_impls.clone(),\n+            index: 0\n         }\n     }\n+}\n \n-    pub fn set_object_safety(&self, is_safe: bool) {\n-        assert!(self.object_safety().map(|cs| cs == is_safe).unwrap_or(true));\n-        self.flags.set(\n-            self.flags.get() | if is_safe {\n-                TraitFlags::OBJECT_SAFETY_VALID | TraitFlags::IS_OBJECT_SAFE\n-            } else {\n-                TraitFlags::OBJECT_SAFETY_VALID\n-            }\n-        );\n-    }\n-\n-    fn write_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n-        tcx.dep_graph.write(DepNode::TraitImpls(self.def_id));\n-    }\n-\n-    fn read_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n-        tcx.dep_graph.read(DepNode::TraitImpls(self.def_id));\n-    }\n-\n-    /// Records a basic trait-to-implementation mapping.\n-    ///\n-    /// Returns `true` iff the impl has not previously been recorded.\n-    fn record_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                   impl_def_id: DefId,\n-                   impl_trait_ref: TraitRef<'tcx>)\n-                   -> bool {\n-        debug!(\"TraitDef::record_impl for {:?}, from {:?}\",\n-               self, impl_trait_ref);\n+#[derive(Clone)]\n+pub struct TraitImplsIter {\n+    blanket_impls: Rc<Vec<DefId>>,\n+    non_blanket_impls: Rc<Vec<DefId>>,\n+    index: usize,\n+}\n \n-        // Record the write into the impl set, but only for local\n-        // impls: external impls are handled differently.\n-        if impl_def_id.is_local() {\n-            self.write_trait_impls(tcx);\n-        }\n+impl Iterator for TraitImplsIter {\n+    type Item = DefId;\n \n-        // We don't want to borrow_mut after we already populated all impls,\n-        // so check if an impl is present with an immutable borrow first.\n-        if let Some(sty) = fast_reject::simplify_type(tcx,\n-                                                      impl_trait_ref.self_ty(), false) {\n-            if let Some(is) = self.nonblanket_impls.borrow().get(&sty) {\n-                if is.contains(&impl_def_id) {\n-                    return false; // duplicate - skip\n-                }\n-            }\n-\n-            self.nonblanket_impls.borrow_mut().entry(sty).or_insert(vec![]).push(impl_def_id)\n+    fn next(&mut self) -> Option<DefId> {\n+        if self.index < self.blanket_impls.len() {\n+            let bi_index = self.index;\n+            self.index += 1;\n+            Some(self.blanket_impls[bi_index])\n         } else {\n-            if self.blanket_impls.borrow().contains(&impl_def_id) {\n-                return false; // duplicate - skip\n+            let nbi_index = self.index - self.blanket_impls.len();\n+            if nbi_index < self.non_blanket_impls.len() {\n+                self.index += 1;\n+                Some(self.non_blanket_impls[nbi_index])\n+            } else {\n+                None\n             }\n-            self.blanket_impls.borrow_mut().push(impl_def_id)\n         }\n-\n-        true\n-    }\n-\n-    /// Records a trait-to-implementation mapping for a crate-local impl.\n-    pub fn record_local_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                             impl_def_id: DefId,\n-                             impl_trait_ref: TraitRef<'tcx>) {\n-        assert!(impl_def_id.is_local());\n-        let was_new = self.record_impl(tcx, impl_def_id, impl_trait_ref);\n-        assert!(was_new);\n-\n-        self.local_impl_count.set(self.local_impl_count.get() + 1);\n     }\n \n-    /// Records a trait-to-implementation mapping.\n-    pub fn record_has_default_impl(&self) {\n-        self.flags.set(self.flags.get() | TraitFlags::HAS_DEFAULT_IMPL);\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let items_left = (self.blanket_impls.len() + self.non_blanket_impls.len()) - self.index;\n+        (items_left, Some(items_left))\n     }\n+}\n \n-    /// Records a trait-to-implementation mapping for a non-local impl.\n-    ///\n-    /// The `parent_impl` is the immediately-less-specialized impl, or the\n-    /// trait's def ID if the impl is not a specialization -- information that\n-    /// should be pulled from the metadata.\n-    pub fn record_remote_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                              impl_def_id: DefId,\n-                              impl_trait_ref: TraitRef<'tcx>,\n-                              parent_impl: DefId) {\n-        assert!(!impl_def_id.is_local());\n+impl ExactSizeIterator for TraitImplsIter {}\n \n-        // if the impl has not previously been recorded\n-        if self.record_impl(tcx, impl_def_id, impl_trait_ref) {\n-            // if the impl is non-local, it's placed directly into the\n-            // specialization graph using parent information drawn from metadata.\n-            self.specialization_graph.borrow_mut()\n-                .record_impl_from_cstore(tcx, parent_impl, impl_def_id)\n+impl<'a, 'gcx, 'tcx> TraitDef {\n+    pub fn new(def_id: DefId,\n+               unsafety: hir::Unsafety,\n+               paren_sugar: bool,\n+               has_default_impl: bool,\n+               def_path_hash: Fingerprint)\n+               -> TraitDef {\n+        TraitDef {\n+            def_id,\n+            paren_sugar,\n+            unsafety,\n+            has_default_impl,\n+            def_path_hash,\n         }\n     }\n \n-    /// Adds a local impl into the specialization graph, returning an error with\n-    /// overlap information if the impl overlaps but does not specialize an\n-    /// existing impl.\n-    pub fn add_impl_for_specialization(&self,\n-                                       tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                       impl_def_id: DefId)\n-                                       -> Result<(), traits::OverlapError> {\n-        assert!(impl_def_id.is_local());\n-\n-        self.specialization_graph.borrow_mut()\n-            .insert(tcx, impl_def_id)\n-    }\n-\n-    pub fn ancestors(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a> {\n-        specialization_graph::ancestors(self, of_impl)\n-    }\n-\n-    /// Whether the impl set and specialization graphs are complete.\n-    pub fn is_complete(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n-        ty::queries::coherent_trait::try_get(tcx, DUMMY_SP, (LOCAL_CRATE, self.def_id)).is_ok()\n-    }\n-\n-    /// If any local impls haven't been added yet, returns\n-    /// Some(list of local impls for this trait).\n-    fn missing_local_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                           -> Option<&'gcx [ast::NodeId]> {\n-        if self.flags.get().intersects(TraitFlags::HAS_LOCAL_IMPLS) {\n-            return None;\n-        }\n-\n-        if self.is_complete(tcx) {\n-            self.flags.set(self.flags.get() | TraitFlags::HAS_LOCAL_IMPLS);\n-            return None;\n-        }\n-\n-        let impls = tcx.hir.trait_impls(self.def_id);\n-        assert!(self.local_impl_count.get() <= impls.len());\n-        if self.local_impl_count.get() == impls.len() {\n-            self.flags.set(self.flags.get() | TraitFlags::HAS_LOCAL_IMPLS);\n-            return None;\n-        }\n-\n-        Some(impls)\n+    pub fn ancestors(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                     of_impl: DefId)\n+                     -> specialization_graph::Ancestors {\n+        specialization_graph::ancestors(tcx, self.def_id, of_impl)\n     }\n \n     pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, mut f: F) {\n-        self.read_trait_impls(tcx);\n-        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n-\n-        let local_impls = self.missing_local_impls(tcx);\n-        if let Some(impls) = local_impls {\n-            for &id in impls {\n-                f(tcx.hir.local_def_id(id));\n-            }\n-        }\n-        let mut f = |def_id: DefId| {\n-            if !(local_impls.is_some() && def_id.is_local()) {\n-                f(def_id);\n-            }\n-        };\n-\n-        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+        for impl_def_id in tcx.trait_impls_of(self.def_id).iter() {\n             f(impl_def_id);\n         }\n-\n-        for v in self.nonblanket_impls.borrow().values() {\n-            for &impl_def_id in v {\n-                f(impl_def_id);\n-            }\n-        }\n     }\n \n     /// Iterate over every impl that could possibly match the\n@@ -273,25 +125,6 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n                                                    self_ty: Ty<'tcx>,\n                                                    mut f: F)\n     {\n-        self.read_trait_impls(tcx);\n-        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n-\n-        let local_impls = self.missing_local_impls(tcx);\n-        if let Some(impls) = local_impls {\n-            for &id in impls {\n-                f(tcx.hir.local_def_id(id));\n-            }\n-        }\n-        let mut f = |def_id: DefId| {\n-            if !(local_impls.is_some() && def_id.is_local()) {\n-                f(def_id);\n-            }\n-        };\n-\n-        for &impl_def_id in self.blanket_impls.borrow().iter() {\n-            f(impl_def_id);\n-        }\n-\n         // simplify_type(.., false) basically replaces type parameters and\n         // projections with infer-variables. This is, of course, done on\n         // the impl trait-ref when it is instantiated, but not on the\n@@ -304,29 +137,86 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n         // replace `S` with anything - this impl of course can't be\n         // selected, and as there are hundreds of similar impls,\n         // considering them would significantly harm performance.\n-        if let Some(simp) = fast_reject::simplify_type(tcx, self_ty, true) {\n-            if let Some(impls) = self.nonblanket_impls.borrow().get(&simp) {\n-                for &impl_def_id in impls {\n-                    f(impl_def_id);\n-                }\n-            }\n+        let relevant_impls = if let Some(simplified_self_ty) =\n+                fast_reject::simplify_type(tcx, self_ty, true) {\n+            tcx.relevant_trait_impls_for((self.def_id, simplified_self_ty))\n         } else {\n-            for v in self.nonblanket_impls.borrow().values() {\n-                for &impl_def_id in v {\n-                    f(impl_def_id);\n-                }\n-            }\n+            tcx.trait_impls_of(self.def_id)\n+        };\n+\n+        for impl_def_id in relevant_impls.iter() {\n+            f(impl_def_id);\n         }\n     }\n }\n \n-bitflags! {\n-    flags TraitFlags: u32 {\n-        const NO_TRAIT_FLAGS        = 0,\n-        const HAS_DEFAULT_IMPL      = 1 << 0,\n-        const IS_OBJECT_SAFE        = 1 << 1,\n-        const OBJECT_SAFETY_VALID   = 1 << 2,\n-        const HAS_REMOTE_IMPLS      = 1 << 3,\n-        const HAS_LOCAL_IMPLS       = 1 << 4,\n+// Query provider for `trait_impls_of`.\n+pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                trait_id: DefId)\n+                                                -> TraitImpls {\n+    let remote_impls = if trait_id.is_local() {\n+        // Traits defined in the current crate can't have impls in upstream\n+        // crates, so we don't bother querying the cstore.\n+        Vec::new()\n+    } else {\n+        tcx.sess.cstore.implementations_of_trait(Some(trait_id))\n+    };\n+\n+    let mut blanket_impls = Vec::new();\n+    let mut non_blanket_impls = Vec::new();\n+\n+    let local_impls = tcx.hir\n+                         .trait_impls(trait_id)\n+                         .into_iter()\n+                         .map(|&node_id| tcx.hir.local_def_id(node_id));\n+\n+     for impl_def_id in local_impls.chain(remote_impls.into_iter()) {\n+        let impl_self_ty = tcx.type_of(impl_def_id);\n+        if impl_def_id.is_local() && impl_self_ty.references_error() {\n+            continue\n+        }\n+\n+        if fast_reject::simplify_type(tcx, impl_self_ty, false).is_some() {\n+            non_blanket_impls.push(impl_def_id);\n+        } else {\n+            blanket_impls.push(impl_def_id);\n+        }\n+    }\n+\n+    TraitImpls {\n+        blanket_impls: Rc::new(blanket_impls),\n+        non_blanket_impls: Rc::new(non_blanket_impls),\n+    }\n+}\n+\n+// Query provider for `relevant_trait_impls_for`.\n+pub(super) fn relevant_trait_impls_provider<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    (trait_id, self_ty): (DefId, fast_reject::SimplifiedType))\n+    -> TraitImpls\n+{\n+    let all_trait_impls = tcx.trait_impls_of(trait_id);\n+\n+    let relevant: Vec<DefId> = all_trait_impls\n+        .non_blanket_impls\n+        .iter()\n+        .cloned()\n+        .filter(|&impl_def_id| {\n+            let impl_self_ty = tcx.type_of(impl_def_id);\n+            let impl_simple_self_ty = fast_reject::simplify_type(tcx,\n+                                                                 impl_self_ty,\n+                                                                 false).unwrap();\n+            impl_simple_self_ty == self_ty\n+        })\n+        .collect();\n+\n+    if all_trait_impls.non_blanket_impls.len() == relevant.len() {\n+        // If we didn't filter anything out, re-use the existing vec.\n+        all_trait_impls\n+    } else {\n+        TraitImpls {\n+            blanket_impls: all_trait_impls.blanket_impls.clone(),\n+            non_blanket_impls: Rc::new(relevant),\n+        }\n     }\n }"}, {"sha": "17564671a1e364f45eed26442e33e6b9e8231b06", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -116,6 +116,7 @@ pub fn record_time<T, F>(accu: &Cell<Duration>, f: F) -> T where\n }\n \n // Like std::macros::try!, but for Option<>.\n+#[cfg(unix)]\n macro_rules! option_try(\n     ($e:expr) => (match $e { Some(e) => e, None => return None })\n );"}, {"sha": "2e949f48c175ee7e44c9126d771043367b352e30", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -22,7 +22,6 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_lint = { path = \"../librustc_lint\" }\n-rustc_llvm = { path = \"../librustc_llvm\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_passes = { path = \"../librustc_passes\" }"}, {"sha": "bca82ff9a46dfb803dfa7ec8947763c66ad5a468", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -22,6 +22,7 @@ use rustc::middle::{self, dependency_format, stability, reachable};\n use rustc::middle::privacy::AccessLevels;\n use rustc::mir::transform::{MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED, Passes};\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n+use rustc::traits;\n use rustc::util::common::time;\n use rustc::util::nodemap::NodeSet;\n use rustc::util::fs::rename_or_copy_remove;\n@@ -699,6 +700,8 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n \n         let krate = ecx.monotonic_expander().expand_crate(krate);\n \n+        ecx.check_unused_macros();\n+\n         let mut missing_fragment_specifiers: Vec<_> =\n             ecx.parse_sess.missing_fragment_specifiers.borrow().iter().cloned().collect();\n         missing_fragment_specifiers.sort();\n@@ -892,6 +895,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     trans::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n+    traits::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_const_eval::provide(&mut local_providers);\n     middle::region::provide(&mut local_providers);\n@@ -900,6 +904,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     cstore::provide(&mut extern_providers);\n     trans::provide(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n+    traits::provide_extern(&mut extern_providers);\n     // FIXME(eddyb) get rid of this once we replace const_eval with miri.\n     rustc_const_eval::provide(&mut extern_providers);\n "}, {"sha": "18a57f78a503719e7bcc48fb26362977f8a79bcd", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -56,7 +56,6 @@ extern crate rustc_save_analysis;\n extern crate rustc_trans;\n extern crate rustc_typeck;\n extern crate serialize;\n-extern crate rustc_llvm as llvm;\n #[macro_use]\n extern crate log;\n extern crate syntax;\n@@ -70,7 +69,7 @@ use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n use rustc_trans::back::link;\n-use rustc_trans::back::write::{create_target_machine, RELOC_MODEL_ARGS, CODE_GEN_MODEL_ARGS};\n+use rustc_trans::back::write::{RELOC_MODEL_ARGS, CODE_GEN_MODEL_ARGS};\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::config::{Input, PrintRequest, OutputType, ErrorOutputType};\n@@ -182,7 +181,7 @@ pub fn run_compiler<'a>(args: &[String],\n     let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n \n     if sopts.debugging_opts.debug_llvm {\n-        unsafe { llvm::LLVMRustSetDebug(1); }\n+        rustc_trans::enable_llvm_debug();\n     }\n \n     let descriptions = diagnostics_registry();\n@@ -204,13 +203,14 @@ pub fn run_compiler<'a>(args: &[String],\n     };\n \n     let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n \n     let loader = file_loader.unwrap_or(box RealFileLoader);\n     let codemap = Rc::new(CodeMap::with_file_loader(loader, sopts.file_path_mapping()));\n     let mut sess = session::build_session_with_codemap(\n         sopts, &dep_graph, input_file_path, descriptions, cstore.clone(), codemap, emitter_dest,\n     );\n+    rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess, cfg);\n@@ -409,12 +409,13 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     return None;\n                 }\n                 let dep_graph = DepGraph::new(sopts.build_dep_graph());\n-                let cstore = Rc::new(CStore::new(&dep_graph));\n+                let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n                 let mut sess = build_session(sopts.clone(),\n                     &dep_graph,\n                     None,\n                     descriptions.clone(),\n                     cstore.clone());\n+                rustc_trans::init(&sess);\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let mut cfg = config::build_configuration(&sess, cfg.clone());\n                 target_features::add_configuration(&mut cfg, &sess);\n@@ -558,7 +559,11 @@ impl RustcDefaultCalls {\n                 &Input::File(ref ifile) => {\n                     let path = &(*ifile);\n                     let mut v = Vec::new();\n-                    locator::list_file_metadata(&sess.target.target, path, &mut v).unwrap();\n+                    locator::list_file_metadata(&sess.target.target,\n+                                                path,\n+                                                sess.cstore.metadata_loader(),\n+                                                &mut v)\n+                            .unwrap();\n                     println!(\"{}\", String::from_utf8(v).unwrap());\n                 }\n                 &Input::Str { .. } => {\n@@ -665,14 +670,6 @@ impl RustcDefaultCalls {\n                         println!(\"{}\", cfg);\n                     }\n                 }\n-                PrintRequest::TargetCPUs => {\n-                    let tm = create_target_machine(sess);\n-                    unsafe { llvm::LLVMRustPrintTargetCPUs(tm); }\n-                }\n-                PrintRequest::TargetFeatures => {\n-                    let tm = create_target_machine(sess);\n-                    unsafe { llvm::LLVMRustPrintTargetFeatures(tm); }\n-                }\n                 PrintRequest::RelocationModels => {\n                     println!(\"Available relocation models:\");\n                     for &(name, _) in RELOC_MODEL_ARGS.iter() {\n@@ -687,6 +684,9 @@ impl RustcDefaultCalls {\n                     }\n                     println!(\"\");\n                 }\n+                PrintRequest::TargetCPUs | PrintRequest::TargetFeatures => {\n+                    rustc_trans::print(*req, sess);\n+                }\n             }\n         }\n         return Compilation::Stop;\n@@ -724,10 +724,7 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n         println!(\"commit-date: {}\", unw(commit_date_str()));\n         println!(\"host: {}\", config::host_triple());\n         println!(\"release: {}\", unw(release_str()));\n-        unsafe {\n-            println!(\"LLVM version: {}.{}\",\n-                     llvm::LLVMRustVersionMajor(), llvm::LLVMRustVersionMinor());\n-        }\n+        rustc_trans::print_version();\n     }\n }\n \n@@ -1020,9 +1017,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.contains(&\"passes=list\".to_string()) {\n-        unsafe {\n-            ::llvm::LLVMRustPrintPasses();\n-        }\n+        rustc_trans::print_passes();\n         return None;\n     }\n \n@@ -1153,9 +1148,18 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     Registry::new(&all_errors)\n }\n \n+fn get_args() -> Vec<String> {\n+    env::args_os().enumerate()\n+        .map(|(i, arg)| arg.into_string().unwrap_or_else(|arg| {\n+             early_error(ErrorOutputType::default(),\n+                         &format!(\"Argument {} is not valid Unicode: {:?}\", i, arg))\n+         }))\n+        .collect()\n+}\n+\n pub fn main() {\n     env_logger::init().unwrap();\n-    let result = run(|| run_compiler(&env::args().collect::<Vec<_>>(),\n+    let result = run(|| run_compiler(&get_args(),\n                                      &mut RustcDefaultCalls,\n                                      None,\n                                      None));"}, {"sha": "bee61bb398029756511fcc1a2300c1209b9ac618", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 4, "deletions": 30, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -9,46 +9,20 @@\n // except according to those terms.\n \n use syntax::ast;\n-use llvm::LLVMRustHasFeature;\n use rustc::session::Session;\n-use rustc_trans::back::write::create_target_machine;\n use syntax::symbol::Symbol;\n-use libc::c_char;\n-\n-// WARNING: the features must be known to LLVM or the feature\n-// detection code will walk past the end of the feature array,\n-// leading to crashes.\n-\n-const ARM_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"vfp2\\0\", \"vfp3\\0\", \"vfp4\\0\"];\n-\n-const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bmi2\\0\", \"sse\\0\",\n-                                                 \"sse2\\0\", \"sse3\\0\", \"sse4.1\\0\", \"sse4.2\\0\",\n-                                                 \"ssse3\\0\", \"tbm\\0\", \"lzcnt\\0\", \"popcnt\\0\",\n-                                                 \"sse4a\\0\", \"rdrnd\\0\", \"rdseed\\0\", \"fma\\0\"];\n-\n-const HEXAGON_WHITELIST: &'static [&'static str] = &[\"hvx\\0\", \"hvx-double\\0\"];\n+use rustc_trans;\n \n /// Add `target_feature = \"...\"` cfgs for a variety of platform\n /// specific features (SSE, NEON etc.).\n ///\n /// This is performed by checking whether a whitelisted set of\n /// features is available on the target machine, by querying LLVM.\n pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n-    let target_machine = create_target_machine(sess);\n-\n-    let whitelist = match &*sess.target.target.arch {\n-        \"arm\" => ARM_WHITELIST,\n-        \"x86\" | \"x86_64\" => X86_WHITELIST,\n-        \"hexagon\" => HEXAGON_WHITELIST,\n-        _ => &[],\n-    };\n-\n     let tf = Symbol::intern(\"target_feature\");\n-    for feat in whitelist {\n-        assert_eq!(feat.chars().last(), Some('\\0'));\n-        if unsafe { LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n-            cfg.insert((tf, Some(Symbol::intern(&feat[..feat.len() - 1]))));\n-        }\n+\n+    for feat in rustc_trans::target_features(sess) {\n+        cfg.insert((tf, Some(feat)));\n     }\n \n     let requested_features = sess.opts.cg.target_feature.split(',');"}, {"sha": "1d236a96bf62ed97c313cfad34909734a9def2aa", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -14,6 +14,7 @@ use driver;\n use rustc::dep_graph::DepGraph;\n use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n+use rustc_trans;\n use rustc::middle::lang_items;\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::region::{CodeExtent, RegionMaps};\n@@ -104,13 +105,14 @@ fn test_env<F>(source_string: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n     let sess = session::build_session_(options,\n                                        &dep_graph,\n                                        None,\n                                        diagnostic_handler,\n                                        Rc::new(CodeMap::new(FilePathMapping::empty())),\n                                        cstore.clone());\n+    rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n         name: driver::anon_src(),"}, {"sha": "c9ed9ad3c7d2d4d2027ab5b31fee1bac4259980d", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -36,9 +36,10 @@ use rustc::hir::def_id::{LOCAL_CRATE, CRATE_DEF_INDEX, DefId};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ich::{Fingerprint, StableHashingContext};\n use rustc::ty::TyCtxt;\n+use rustc::util::common::record_time;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc::util::common::record_time;\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n pub type IchHasher = StableHasher<Fingerprint>;\n \n@@ -159,6 +160,11 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n                                         // difference, filter them out.\n                                         return None\n                                     }\n+                                    DepNode::AllLocalTraitImpls => {\n+                                        // These are already covered by hashing\n+                                        // the HIR.\n+                                        return None\n+                                    }\n                                     ref other => {\n                                         bug!(\"Found unexpected DepNode during \\\n                                               SVH computation: {:?}\",\n@@ -213,6 +219,49 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n                                                  true,\n                                                  (module, (span, attrs)));\n     }\n+\n+    fn compute_and_store_ich_for_trait_impls(&mut self, krate: &'tcx hir::Crate)\n+    {\n+        let tcx = self.hcx.tcx();\n+\n+        let mut impls: Vec<(Fingerprint, Fingerprint)> = krate\n+            .trait_impls\n+            .iter()\n+            .map(|(&trait_id, impls)| {\n+                let trait_id = tcx.def_path_hash(trait_id);\n+                let mut impls: AccumulateVec<[_; 32]> = impls\n+                    .iter()\n+                    .map(|&node_id| {\n+                        let def_id = tcx.hir.local_def_id(node_id);\n+                        tcx.def_path_hash(def_id)\n+                    })\n+                    .collect();\n+\n+                impls.sort_unstable();\n+                let mut hasher = StableHasher::new();\n+                impls.hash_stable(&mut self.hcx, &mut hasher);\n+                (trait_id, hasher.finish())\n+            })\n+            .collect();\n+\n+        impls.sort_unstable();\n+\n+        let mut default_impls: AccumulateVec<[_; 32]> = krate\n+            .trait_default_impl\n+            .iter()\n+            .map(|(&trait_def_id, &impl_node_id)| {\n+                let impl_def_id = tcx.hir.local_def_id(impl_node_id);\n+                (tcx.def_path_hash(trait_def_id), tcx.def_path_hash(impl_def_id))\n+            })\n+            .collect();\n+\n+        default_impls.sort_unstable();\n+\n+        let mut hasher = StableHasher::new();\n+        impls.hash_stable(&mut self.hcx, &mut hasher);\n+\n+        self.hashes.insert(DepNode::AllLocalTraitImpls, hasher.finish());\n+    }\n }\n \n impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for ComputeItemHashesVisitor<'a, 'tcx> {\n@@ -235,6 +284,8 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for ComputeItemHashesVisitor<'a, 'tcx>\n     }\n }\n \n+\n+\n pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                                     -> IncrementalHashesMap {\n     let _ignore = tcx.dep_graph.in_ignore();\n@@ -272,6 +323,8 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n             let fingerprint = hasher.finish();\n             visitor.hashes.insert(dep_node, fingerprint);\n         }\n+\n+        visitor.compute_and_store_ich_for_trait_impls(krate);\n     });\n \n     tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);"}, {"sha": "044b143e306250944542e6b7fb12b3c73a090a21", "filename": "src/librustc_incremental/persist/preds/compress/test_macro.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Ftest_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Ftest_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fcompress%2Ftest_macro.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -37,14 +37,3 @@ macro_rules! graph {\n         }\n     }\n }\n-\n-macro_rules! set {\n-    ($( $value:expr ),*) => {\n-        {\n-            use $crate::rustc_data_structures::fx::FxHashSet;\n-            let mut set = FxHashSet();\n-            $(set.insert($value);)*\n-            set\n-        }\n-    }\n-}"}, {"sha": "479c7206cb4cb95b150c5b0adcb0b40daf86c0de", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -171,7 +171,8 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     UNUSED_MUST_USE,\n                     UNUSED_UNSAFE,\n                     PATH_STATEMENTS,\n-                    UNUSED_ATTRIBUTES);\n+                    UNUSED_ATTRIBUTES,\n+                    UNUSED_MACROS);\n \n     // Guidelines for creating a future incompatibility lint:\n     //"}, {"sha": "f47788ee036dc5e312d4a05754a3f4b0cd8c7143", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -11,13 +11,13 @@ crate-type = [\"dylib\"]\n [dependencies]\n flate = { path = \"../libflate\" }\n log = \"0.3\"\n+owning_ref = \"0.3.3\"\n proc_macro = { path = \"../libproc_macro\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n-rustc_llvm = { path = \"../librustc_llvm\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }"}, {"sha": "ec6947b4a486c31ebcaa1444fc827d2115c72f04", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -315,11 +315,20 @@ impl<'a> CrateLoader<'a> {\n         let exported_symbols = crate_root.exported_symbols\n                                          .map(|x| x.decode(&metadata).collect());\n \n+        let trait_impls = crate_root\n+            .impls\n+            .map(|impls| {\n+                impls.decode(&metadata)\n+                     .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n+                     .collect()\n+            });\n+\n         let mut cmeta = cstore::CrateMetadata {\n             name: name,\n             extern_crate: Cell::new(None),\n             def_path_table: def_path_table,\n             exported_symbols: exported_symbols,\n+            trait_impls: trait_impls,\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {\n                 self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n             }),\n@@ -393,6 +402,7 @@ impl<'a> CrateLoader<'a> {\n                 rejected_via_filename: vec![],\n                 should_match_name: true,\n                 is_proc_macro: Some(false),\n+                metadata_loader: &*self.cstore.metadata_loader,\n             };\n \n             self.load(&mut locate_ctxt).or_else(|| {\n@@ -554,6 +564,7 @@ impl<'a> CrateLoader<'a> {\n             rejected_via_filename: vec![],\n             should_match_name: true,\n             is_proc_macro: None,\n+            metadata_loader: &*self.cstore.metadata_loader,\n         };\n         let library = self.load(&mut locate_ctxt).or_else(|| {\n             if !is_cross {"}, {"sha": "64fccb0314e97d67743a613a58406568dbcde43f", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -11,21 +11,20 @@\n // The crate store - a central repo for information collected about external\n // crates and libraries\n \n-use locator;\n use schema::{self, Tracked};\n \n use rustc::dep_graph::{DepGraph, DepNode, GlobalMetaDataKind};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefIndex, DefId};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir::svh::Svh;\n-use rustc::middle::cstore::{DepKind, ExternCrate};\n+use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FxHashMap, FxHashSet, NodeMap, DefIdMap};\n \n use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n-use flate::Bytes;\n+use owning_ref::ErasedBoxRef;\n use syntax::{ast, attr};\n use syntax::ext::base::SyntaxExtension;\n use syntax::symbol::Symbol;\n@@ -43,11 +42,7 @@ pub use cstore_impl::provide;\n // own crate numbers.\n pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n-pub enum MetadataBlob {\n-    Inflated(Bytes),\n-    Archive(locator::ArchiveMetadata),\n-    Raw(Vec<u8>),\n-}\n+pub struct MetadataBlob(pub ErasedBoxRef<[u8]>);\n \n /// Holds information about a syntax_pos::FileMap imported from another crate.\n /// See `imported_filemaps()` for more information.\n@@ -85,6 +80,8 @@ pub struct CrateMetadata {\n \n     pub exported_symbols: Tracked<FxHashSet<DefIndex>>,\n \n+    pub trait_impls: Tracked<FxHashMap<(u32, DefIndex), schema::LazySeq<DefIndex>>>,\n+\n     pub dep_kind: Cell<DepKind>,\n     pub source: CrateSource,\n \n@@ -103,10 +100,11 @@ pub struct CStore {\n     statically_included_foreign_items: RefCell<FxHashSet<DefIndex>>,\n     pub dllimport_foreign_items: RefCell<FxHashSet<DefIndex>>,\n     pub visible_parent_map: RefCell<DefIdMap<DefId>>,\n+    pub metadata_loader: Box<MetadataLoader>,\n }\n \n impl CStore {\n-    pub fn new(dep_graph: &DepGraph) -> CStore {\n+    pub fn new(dep_graph: &DepGraph, metadata_loader: Box<MetadataLoader>) -> CStore {\n         CStore {\n             dep_graph: dep_graph.clone(),\n             metas: RefCell::new(FxHashMap()),\n@@ -116,6 +114,7 @@ impl CStore {\n             statically_included_foreign_items: RefCell::new(FxHashSet()),\n             dllimport_foreign_items: RefCell::new(FxHashSet()),\n             visible_parent_map: RefCell::new(FxHashMap()),\n+            metadata_loader: metadata_loader,\n         }\n     }\n "}, {"sha": "7478f902e061a321614af006535e68a6f129dcae", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -10,14 +10,14 @@\n \n use cstore;\n use encoder;\n-use locator;\n use schema;\n \n use rustc::dep_graph::DepTrackingMapConfig;\n use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind,\n-                            ExternCrate, NativeLibrary, LinkMeta,\n+                            ExternCrate, NativeLibrary, MetadataLoader, LinkMeta,\n                             LinkagePreference, LoadedMacro, EncodedMetadata};\n use rustc::hir::def;\n+use rustc::ich;\n use rustc::middle::lang_items;\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n@@ -38,7 +38,6 @@ use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, NO_EXPANSION};\n use rustc::hir::svh::Svh;\n-use rustc_back::target::Target;\n use rustc::hir;\n \n macro_rules! provide {\n@@ -135,6 +134,10 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(krate)\n     }\n \n+    fn metadata_loader(&self) -> &MetadataLoader {\n+        &*self.metadata_loader\n+    }\n+\n     fn visibility(&self, def: DefId) -> ty::Visibility {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_visibility(def.index)\n@@ -147,10 +150,8 @@ impl CrateStore for cstore::CStore {\n \n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>\n     {\n-        if let Some(def_id) = filter {\n-            self.dep_graph.read(DepNode::MetaData(def_id));\n-        }\n         let mut result = vec![];\n+\n         self.iter_crate_data(|_, cdata| {\n             cdata.get_implementations_for_trait(filter, &self.dep_graph, &mut result)\n         });\n@@ -337,7 +338,7 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).def_path(def.index)\n     }\n \n-    fn def_path_hash(&self, def: DefId) -> u64 {\n+    fn def_path_hash(&self, def: DefId) -> ich::Fingerprint {\n         self.get_crate_data(def.krate).def_path_hash(def.index)\n     }\n \n@@ -420,17 +421,6 @@ impl CrateStore for cstore::CStore {\n     {\n         self.get_used_link_args().borrow().clone()\n     }\n-\n-    fn metadata_filename(&self) -> &str\n-    {\n-        locator::METADATA_FILENAME\n-    }\n-\n-    fn metadata_section_name(&self, target: &Target) -> &str\n-    {\n-        locator::meta_section_name(target)\n-    }\n-\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n     {\n         self.do_get_used_crates(prefer)\n@@ -522,4 +512,4 @@ impl CrateStore for cstore::CStore {\n         drop(visible_parent_map);\n         self.visible_parent_map.borrow()\n     }\n-}\n+}\n\\ No newline at end of file"}, {"sha": "d8826d87d4d0f4fd0752b05e5b4ff0dd7197d907", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -16,6 +16,7 @@ use schema::*;\n use rustc::dep_graph::{DepGraph, DepNode, GlobalMetaDataKind};\n use rustc::hir::map::{DefKey, DefPath, DefPathData};\n use rustc::hir;\n+use rustc::ich;\n \n use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n@@ -77,11 +78,7 @@ pub trait Metadata<'a, 'tcx>: Copy {\n \n impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {\n     fn raw_bytes(self) -> &'a [u8] {\n-        match *self {\n-            MetadataBlob::Inflated(ref vec) => vec,\n-            MetadataBlob::Archive(ref ar) => ar.as_slice(),\n-            MetadataBlob::Raw(ref vec) => vec,\n-        }\n+        &self.0\n     }\n }\n \n@@ -505,16 +502,11 @@ impl<'a, 'tcx> CrateMetadata {\n             _ => bug!(),\n         };\n \n-        let def = ty::TraitDef::new(self.local_def_id(item_id),\n-                                    data.unsafety,\n-                                    data.paren_sugar,\n-                                    self.def_path_table.def_path_hash(item_id));\n-\n-        if data.has_default_impl {\n-            def.record_has_default_impl();\n-        }\n-\n-        def\n+        ty::TraitDef::new(self.local_def_id(item_id),\n+                          data.unsafety,\n+                          data.paren_sugar,\n+                          data.has_default_impl,\n+                          self.def_path_table.def_path_hash(item_id))\n     }\n \n     fn get_variant(&self, item: &Entry, index: DefIndex) -> ty::VariantDef {\n@@ -961,17 +953,17 @@ impl<'a, 'tcx> CrateMetadata {\n             None => None,\n         };\n \n-        // FIXME(eddyb) Make this O(1) instead of O(n).\n         let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Impls);\n-        for trait_impls in self.root.impls.get(dep_graph, dep_node).decode(self) {\n-            if filter.is_some() && filter != Some(trait_impls.trait_id) {\n-                continue;\n-            }\n-\n-            result.extend(trait_impls.impls.decode(self).map(|index| self.local_def_id(index)));\n \n-            if filter.is_some() {\n-                break;\n+        if let Some(filter) = filter {\n+            if let Some(impls) = self.trait_impls\n+                                     .get(dep_graph, dep_node)\n+                                     .get(&filter) {\n+                result.extend(impls.decode(self).map(|idx| self.local_def_id(idx)));\n+            }\n+        } else {\n+            for impls in self.trait_impls.get(dep_graph, dep_node).values() {\n+                result.extend(impls.decode(self).map(|idx| self.local_def_id(idx)));\n             }\n         }\n     }\n@@ -1115,7 +1107,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     #[inline]\n-    pub fn def_path_hash(&self, index: DefIndex) -> u64 {\n+    pub fn def_path_hash(&self, index: DefIndex) -> ich::Fingerprint {\n         self.def_path_table.def_path_hash(index)\n     }\n "}, {"sha": "93fcdc455e5dd3762dc7dfe7d6f78e13c4e66ea0", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -943,7 +943,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 let trait_ref = tcx.impl_trait_ref(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n                     let trait_def = tcx.trait_def(trait_ref.def_id);\n-                    trait_def.ancestors(def_id).skip(1).next().and_then(|node| {\n+                    trait_def.ancestors(tcx, def_id).skip(1).next().and_then(|node| {\n                         match node {\n                             specialization_graph::Node::Impl(parent) => Some(parent),\n                             _ => None,\n@@ -1295,23 +1295,37 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     /// Encodes an index, mapping each trait to its (local) implementations.\n     fn encode_impls(&mut self, _: ()) -> LazySeq<TraitImpls> {\n+        debug!(\"IsolatedEncoder::encode_impls()\");\n+        let tcx = self.tcx;\n         let mut visitor = ImplVisitor {\n-            tcx: self.tcx,\n+            tcx: tcx,\n             impls: FxHashMap(),\n         };\n-        self.tcx.hir.krate().visit_all_item_likes(&mut visitor);\n+        tcx.hir.krate().visit_all_item_likes(&mut visitor);\n+\n+        let mut all_impls: Vec<_> = visitor.impls.into_iter().collect();\n \n-        let all_impls: Vec<_> = visitor.impls\n+        // Bring everything into deterministic order for hashing\n+        all_impls.sort_unstable_by_key(|&(trait_def_id, _)| {\n+            tcx.def_path_hash(trait_def_id)\n+        });\n+\n+        let all_impls: Vec<_> = all_impls\n             .into_iter()\n-            .map(|(trait_def_id, impls)| {\n+            .map(|(trait_def_id, mut impls)| {\n+                // Bring everything into deterministic order for hashing\n+                impls.sort_unstable_by_key(|&def_index| {\n+                    tcx.hir.definitions().def_path_hash(def_index)\n+                });\n+\n                 TraitImpls {\n                     trait_id: (trait_def_id.krate.as_u32(), trait_def_id.index),\n-                    impls: self.lazy_seq(impls),\n+                    impls: self.lazy_seq_from_slice(&impls[..]),\n                 }\n             })\n             .collect();\n \n-        self.lazy_seq(all_impls)\n+        self.lazy_seq_from_slice(&all_impls[..])\n     }\n \n     // Encodes all symbols exported from this crate into the metadata."}, {"sha": "56c150fd4c82f27608f2c6bc57da9df72c08762a", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -29,6 +29,7 @@\n \n #![cfg_attr(stage0, unstable(feature = \"rustc_private\", issue = \"27812\"))]\n #![cfg_attr(stage0, feature(staged_api))]\n+#![feature(sort_unstable)]\n \n #[macro_use]\n extern crate log;\n@@ -37,6 +38,7 @@ extern crate syntax;\n extern crate syntax_pos;\n extern crate flate;\n extern crate serialize as rustc_serialize; // used by deriving\n+extern crate owning_ref;\n extern crate rustc_errors as errors;\n extern crate syntax_ext;\n extern crate proc_macro;\n@@ -46,7 +48,6 @@ extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_const_math;\n extern crate rustc_data_structures;\n-extern crate rustc_llvm;\n \n mod diagnostics;\n "}, {"sha": "34b07af9f01f439cf84e551c5ff5cd629b6bcf98", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 61, "deletions": 164, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -224,15 +224,12 @@ use creader::Library;\n use schema::{METADATA_HEADER, rustc_version};\n \n use rustc::hir::svh::Svh;\n+use rustc::middle::cstore::MetadataLoader;\n use rustc::session::{config, Session};\n use rustc::session::filesearch::{FileSearch, FileMatches, FileDoesntMatch};\n use rustc::session::search_paths::PathKind;\n-use rustc::util::common;\n use rustc::util::nodemap::FxHashMap;\n \n-use rustc_llvm as llvm;\n-use rustc_llvm::{False, ObjectFile, mk_section_iter};\n-use rustc_llvm::archive_ro::ArchiveRO;\n use errors::DiagnosticBuilder;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -243,11 +240,10 @@ use std::fmt;\n use std::fs::{self, File};\n use std::io::{self, Read};\n use std::path::{Path, PathBuf};\n-use std::ptr;\n-use std::slice;\n use std::time::Instant;\n \n use flate;\n+use owning_ref::{ErasedBoxRef, OwningRef};\n \n pub struct CrateMismatch {\n     path: PathBuf,\n@@ -272,12 +268,7 @@ pub struct Context<'a> {\n     pub rejected_via_filename: Vec<CrateMismatch>,\n     pub should_match_name: bool,\n     pub is_proc_macro: Option<bool>,\n-}\n-\n-pub struct ArchiveMetadata {\n-    _archive: ArchiveRO,\n-    // points into self._archive\n-    data: *const [u8],\n+    pub metadata_loader: &'a MetadataLoader,\n }\n \n pub struct CratePaths {\n@@ -287,8 +278,6 @@ pub struct CratePaths {\n     pub rmeta: Option<PathBuf>,\n }\n \n-pub const METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n-\n #[derive(Copy, Clone, PartialEq)]\n enum CrateFlavor {\n     Rlib,\n@@ -596,20 +585,21 @@ impl<'a> Context<'a> {\n         let mut err: Option<DiagnosticBuilder> = None;\n         for (lib, kind) in m {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n-            let (hash, metadata) = match get_metadata_section(self.target, flavor, &lib) {\n-                Ok(blob) => {\n-                    if let Some(h) = self.crate_matches(&blob, &lib) {\n-                        (h, blob)\n-                    } else {\n-                        info!(\"metadata mismatch\");\n+            let (hash, metadata) =\n+                match get_metadata_section(self.target, flavor, &lib, self.metadata_loader) {\n+                    Ok(blob) => {\n+                        if let Some(h) = self.crate_matches(&blob, &lib) {\n+                            (h, blob)\n+                        } else {\n+                            info!(\"metadata mismatch\");\n+                            continue;\n+                        }\n+                    }\n+                    Err(err) => {\n+                        info!(\"no metadata found: {}\", err);\n                         continue;\n                     }\n-                }\n-                Err(err) => {\n-                    info!(\"no metadata found: {}\", err);\n-                    continue;\n-                }\n-            };\n+                };\n             // If we see multiple hashes, emit an error about duplicate candidates.\n             if slot.as_ref().map_or(false, |s| s.0 != hash) {\n                 let mut e = struct_span_err!(self.sess,\n@@ -833,50 +823,14 @@ pub fn note_crate_name(err: &mut DiagnosticBuilder, name: &str) {\n     err.note(&format!(\"crate name: {}\", name));\n }\n \n-impl ArchiveMetadata {\n-    fn new(ar: ArchiveRO) -> Option<ArchiveMetadata> {\n-        let data = {\n-            let section = ar.iter()\n-                .filter_map(|s| s.ok())\n-                .find(|sect| sect.name() == Some(METADATA_FILENAME));\n-            match section {\n-                Some(s) => s.data() as *const [u8],\n-                None => {\n-                    debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n-                    return None;\n-                }\n-            }\n-        };\n-\n-        Some(ArchiveMetadata {\n-            _archive: ar,\n-            data: data,\n-        })\n-    }\n-\n-    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n-        unsafe { &*self.data }\n-    }\n-}\n-\n-fn verify_decompressed_encoding_version(blob: &MetadataBlob,\n-                                        filename: &Path)\n-                                        -> Result<(), String> {\n-    if !blob.is_compatible() {\n-        Err((format!(\"incompatible metadata version found: '{}'\",\n-                     filename.display())))\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n // Just a small wrapper to time how long reading metadata takes.\n fn get_metadata_section(target: &Target,\n                         flavor: CrateFlavor,\n-                        filename: &Path)\n+                        filename: &Path,\n+                        loader: &MetadataLoader)\n                         -> Result<MetadataBlob, String> {\n     let start = Instant::now();\n-    let ret = get_metadata_section_imp(target, flavor, filename);\n+    let ret = get_metadata_section_imp(target, flavor, filename, loader);\n     info!(\"reading {:?} => {:?}\",\n           filename.file_name().unwrap(),\n           start.elapsed());\n@@ -885,118 +839,61 @@ fn get_metadata_section(target: &Target,\n \n fn get_metadata_section_imp(target: &Target,\n                             flavor: CrateFlavor,\n-                            filename: &Path)\n+                            filename: &Path,\n+                            loader: &MetadataLoader)\n                             -> Result<MetadataBlob, String> {\n     if !filename.exists() {\n         return Err(format!(\"no such file: '{}'\", filename.display()));\n     }\n-    if flavor == CrateFlavor::Rlib {\n-        // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n-        // internally to read the file. We also avoid even using a memcpy by\n-        // just keeping the archive along while the metadata is in use.\n-        let archive = match ArchiveRO::open(filename) {\n-            Some(ar) => ar,\n-            None => {\n-                debug!(\"llvm didn't like `{}`\", filename.display());\n-                return Err(format!(\"failed to read rlib metadata: '{}'\", filename.display()));\n+    let raw_bytes: ErasedBoxRef<[u8]> = match flavor {\n+        CrateFlavor::Rlib => loader.get_rlib_metadata(target, filename)?,\n+        CrateFlavor::Dylib => {\n+            let buf = loader.get_dylib_metadata(target, filename)?;\n+            // The header is uncompressed\n+            let header_len = METADATA_HEADER.len();\n+            debug!(\"checking {} bytes of metadata-version stamp\", header_len);\n+            let header = &buf[..cmp::min(header_len, buf.len())];\n+            if header != METADATA_HEADER {\n+                return Err(format!(\"incompatible metadata version found: '{}'\",\n+                                   filename.display()));\n             }\n-        };\n-        return match ArchiveMetadata::new(archive).map(|ar| MetadataBlob::Archive(ar)) {\n-            None => Err(format!(\"failed to read rlib metadata: '{}'\", filename.display())),\n-            Some(blob) => {\n-                verify_decompressed_encoding_version(&blob, filename)?;\n-                Ok(blob)\n-            }\n-        };\n-    } else if flavor == CrateFlavor::Rmeta {\n-        let mut file = File::open(filename).map_err(|_|\n-            format!(\"could not open file: '{}'\", filename.display()))?;\n-        let mut buf = vec![];\n-        file.read_to_end(&mut buf).map_err(|_|\n-            format!(\"failed to read rlib metadata: '{}'\", filename.display()))?;\n-        let blob = MetadataBlob::Raw(buf);\n-        verify_decompressed_encoding_version(&blob, filename)?;\n-        return Ok(blob);\n-    }\n-    unsafe {\n-        let buf = common::path2cstr(filename);\n-        let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n-        if mb as isize == 0 {\n-            return Err(format!(\"error reading library: '{}'\", filename.display()));\n-        }\n-        let of = match ObjectFile::new(mb) {\n-            Some(of) => of,\n-            _ => {\n-                return Err((format!(\"provided path not an object file: '{}'\", filename.display())))\n-            }\n-        };\n-        let si = mk_section_iter(of.llof);\n-        while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n-            let mut name_buf = ptr::null();\n-            let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n-            let name = slice::from_raw_parts(name_buf as *const u8, name_len as usize).to_vec();\n-            let name = String::from_utf8(name).unwrap();\n-            debug!(\"get_metadata_section: name {}\", name);\n-            if read_meta_section_name(target) == name {\n-                let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n-                let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n-                let cvbuf: *const u8 = cbuf as *const u8;\n-                let vlen = METADATA_HEADER.len();\n-                debug!(\"checking {} bytes of metadata-version stamp\", vlen);\n-                let minsz = cmp::min(vlen, csz);\n-                let buf0 = slice::from_raw_parts(cvbuf, minsz);\n-                let version_ok = buf0 == METADATA_HEADER;\n-                if !version_ok {\n-                    return Err((format!(\"incompatible metadata version found: '{}'\",\n-                                        filename.display())));\n-                }\n \n-                let cvbuf1 = cvbuf.offset(vlen as isize);\n-                debug!(\"inflating {} bytes of compressed metadata\", csz - vlen);\n-                let bytes = slice::from_raw_parts(cvbuf1, csz - vlen);\n-                match flate::inflate_bytes(bytes) {\n-                    Ok(inflated) => {\n-                        let blob = MetadataBlob::Inflated(inflated);\n-                        verify_decompressed_encoding_version(&blob, filename)?;\n-                        return Ok(blob);\n-                    }\n-                    Err(_) => {}\n+            // Header is okay -> inflate the actual metadata\n+            let compressed_bytes = &buf[header_len..];\n+            debug!(\"inflating {} bytes of compressed metadata\", compressed_bytes.len());\n+            match flate::inflate_bytes(compressed_bytes) {\n+                Ok(inflated) => {\n+                    let buf = unsafe { OwningRef::new_assert_stable_address(inflated) };\n+                    buf.map_owner_box().erase_owner()\n+                }\n+                Err(_) => {\n+                    return Err(format!(\"failed to decompress metadata: {}\", filename.display()));\n                 }\n             }\n-            llvm::LLVMMoveToNextSection(si.llsi);\n         }\n-        Err(format!(\"metadata not found: '{}'\", filename.display()))\n-    }\n-}\n-\n-pub fn meta_section_name(target: &Target) -> &'static str {\n-    // Historical note:\n-    //\n-    // When using link.exe it was seen that the section name `.note.rustc`\n-    // was getting shortened to `.note.ru`, and according to the PE and COFF\n-    // specification:\n-    //\n-    // > Executable images do not use a string table and do not support\n-    // > section names longer than 8\u00a0characters\n-    //\n-    // https://msdn.microsoft.com/en-us/library/windows/hardware/gg463119.aspx\n-    //\n-    // As a result, we choose a slightly shorter name! As to why\n-    // `.note.rustc` works on MinGW, that's another good question...\n-\n-    if target.options.is_like_osx {\n-        \"__DATA,.rustc\"\n+        CrateFlavor::Rmeta => {\n+            let mut file = File::open(filename).map_err(|_|\n+                format!(\"could not open file: '{}'\", filename.display()))?;\n+            let mut buf = vec![];\n+            file.read_to_end(&mut buf).map_err(|_|\n+                format!(\"failed to read rmeta metadata: '{}'\", filename.display()))?;\n+            OwningRef::new(buf).map_owner_box().erase_owner()\n+        }\n+    };\n+    let blob = MetadataBlob(raw_bytes);\n+    if blob.is_compatible() {\n+        Ok(blob)\n     } else {\n-        \".rustc\"\n+        Err(format!(\"incompatible metadata version found: '{}'\", filename.display()))\n     }\n }\n \n-pub fn read_meta_section_name(_target: &Target) -> &'static str {\n-    \".rustc\"\n-}\n-\n // A diagnostic function for dumping crate metadata to an output stream\n-pub fn list_file_metadata(target: &Target, path: &Path, out: &mut io::Write) -> io::Result<()> {\n+pub fn list_file_metadata(target: &Target,\n+                          path: &Path,\n+                          loader: &MetadataLoader,\n+                          out: &mut io::Write)\n+                          -> io::Result<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n     let flavor = if filename.ends_with(\".rlib\") {\n         CrateFlavor::Rlib\n@@ -1005,7 +902,7 @@ pub fn list_file_metadata(target: &Target, path: &Path, out: &mut io::Write) ->\n     } else {\n         CrateFlavor::Dylib\n     };\n-    match get_metadata_section(target, flavor, path) {\n+    match get_metadata_section(target, flavor, path, loader) {\n         Ok(metadata) => metadata.list_crate_metadata(out),\n         Err(msg) => write!(out, \"{}\\n\", msg),\n     }"}, {"sha": "91a22d922199da6d2e6f3e35192ec9957a9491e1", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -221,6 +221,20 @@ impl<T> Tracked<T> {\n     }\n }\n \n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for Tracked<T>\n+    where T: HashStable<StableHashingContext<'a, 'tcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let Tracked {\n+            ref state\n+        } = *self;\n+\n+        state.hash_stable(hcx, hasher);\n+    }\n+}\n+\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct CrateRoot {"}, {"sha": "eaba573dcd2e582d21dfdc056e87ba601d820e94", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -324,7 +324,9 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n         MirSource::Promoted(_, i) => write!(w, \"{:?} in\", i)?\n     }\n \n-    write!(w, \" {}\", tcx.node_path_str(src.item_id()))?;\n+    item_path::with_forced_impl_filename_line(|| { // see notes on #41697 elsewhere\n+        write!(w, \" {}\", tcx.node_path_str(src.item_id()))\n+    })?;\n \n     if let MirSource::Fn(_) = src {\n         write!(w, \"(\")?;"}, {"sha": "3027489d65be2ea1f955e5e3c5e1c8e611b66280", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -103,7 +103,8 @@ impl<'a> Registry<'a> {\n         }\n         self.syntax_exts.push((name, match extension {\n             NormalTT(ext, _, allow_internal_unstable) => {\n-                NormalTT(ext, Some(self.krate_span), allow_internal_unstable)\n+                let nid = ast::CRATE_NODE_ID;\n+                NormalTT(ext, Some((nid, self.krate_span)), allow_internal_unstable)\n             }\n             IdentTT(ext, _, allow_internal_unstable) => {\n                 IdentTT(ext, Some(self.krate_span), allow_internal_unstable)"}, {"sha": "6ea666e21dcdd28fd24ab0bcd4af1e893269d753", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -1187,6 +1187,10 @@ pub struct Resolver<'a> {\n     pub whitelisted_legacy_custom_derives: Vec<Name>,\n     pub found_unresolved_macro: bool,\n \n+    // List of crate local macros that we need to warn about as being unused.\n+    // Right now this only includes macro_rules! macros.\n+    unused_macros: FxHashSet<DefId>,\n+\n     // Maps the `Mark` of an expansion to its containing module or block.\n     invocations: FxHashMap<Mark, &'a InvocationData<'a>>,\n \n@@ -1392,6 +1396,7 @@ impl<'a> Resolver<'a> {\n             potentially_unused_imports: Vec::new(),\n             struct_constructors: DefIdMap(),\n             found_unresolved_macro: false,\n+            unused_macros: FxHashSet(),\n         }\n     }\n "}, {"sha": "231d30cd2a22decfdd8729f4f68f46dfa16fe305", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -16,7 +16,7 @@ use resolve_imports::ImportResolver;\n use rustc::hir::def_id::{DefId, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefIndex};\n use rustc::hir::def::{Def, Export};\n use rustc::hir::map::{self, DefCollector};\n-use rustc::ty;\n+use rustc::{ty, lint};\n use syntax::ast::{self, Name, Ident};\n use syntax::attr::{self, HasAttrs};\n use syntax::errors::DiagnosticBuilder;\n@@ -291,12 +291,32 @@ impl<'a> base::Resolver for Resolver<'a> {\n             },\n         };\n         self.macro_defs.insert(invoc.expansion_data.mark, def.def_id());\n+        self.unused_macros.remove(&def.def_id());\n         Ok(Some(self.get_macro(def)))\n     }\n \n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n-        self.resolve_macro_to_def(scope, path, kind, force).map(|def| self.get_macro(def))\n+        self.resolve_macro_to_def(scope, path, kind, force).map(|def| {\n+            self.unused_macros.remove(&def.def_id());\n+            self.get_macro(def)\n+        })\n+    }\n+\n+    fn check_unused_macros(&self) {\n+        for did in self.unused_macros.iter() {\n+            let id_span = match *self.macro_map[did] {\n+                SyntaxExtension::NormalTT(_, isp, _) => isp,\n+                _ => None,\n+            };\n+            if let Some((id, span)) = id_span {\n+                let lint = lint::builtin::UNUSED_MACROS;\n+                let msg = \"unused macro definition\".to_string();\n+                self.session.add_lint(lint, id, span, msg);\n+            } else {\n+                bug!(\"attempted to create unused macro error, but span not available\");\n+            }\n+        }\n     }\n }\n \n@@ -687,6 +707,8 @@ impl<'a> Resolver<'a> {\n         if attr::contains_name(&item.attrs, \"macro_export\") {\n             let def = Def::Macro(def_id, MacroKind::Bang);\n             self.macro_exports.push(Export { name: ident.name, def: def, span: item.span });\n+        } else {\n+            self.unused_macros.insert(def_id);\n         }\n     }\n "}, {"sha": "4ccc85257f3c990ba313df23fa87a9de43476721", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -12,6 +12,7 @@ test = false\n [dependencies]\n flate = { path = \"../libflate\" }\n log = \"0.3\"\n+owning_ref = \"0.3.3\"\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }"}, {"sha": "902065c8688d0d808fb6c2c29d25c82d8bbd219a", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -20,6 +20,7 @@ use std::str;\n use libc;\n use llvm::archive_ro::{ArchiveRO, Child};\n use llvm::{self, ArchiveKind};\n+use metadata::METADATA_FILENAME;\n use rustc::session::Session;\n \n pub struct ArchiveConfig<'a> {\n@@ -158,11 +159,9 @@ impl<'a> ArchiveBuilder<'a> {\n         // Ignoring all bytecode files, no matter of\n         // name\n         let bc_ext = \".bytecode.deflate\";\n-        let metadata_filename =\n-            self.config.sess.cstore.metadata_filename().to_owned();\n \n         self.add_archive(rlib, move |fname: &str| {\n-            if fname.ends_with(bc_ext) || fname == metadata_filename {\n+            if fname.ends_with(bc_ext) || fname == METADATA_FILENAME {\n                 return true\n             }\n "}, {"sha": "f85d3f9f54dfd7cd8b63ad152089bfa10e10eca0", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -13,6 +13,7 @@ use super::linker::Linker;\n use super::rpath::RPathConfig;\n use super::rpath;\n use super::msvc;\n+use metadata::METADATA_FILENAME;\n use session::config;\n use session::config::NoDebugInfo;\n use session::config::{OutputFilenames, Input, OutputType};\n@@ -521,7 +522,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // contain the metadata in a separate file. We use a temp directory\n             // here so concurrent builds in the same directory don't try to use\n             // the same filename for metadata (stomping over one another)\n-            let metadata = tmpdir.join(sess.cstore.metadata_filename());\n+            let metadata = tmpdir.join(METADATA_FILENAME);\n             emit_metadata(sess, trans, &metadata);\n             ab.add_file(&metadata);\n \n@@ -714,6 +715,10 @@ fn link_natively(sess: &Session,\n     if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n         cmd.args(args);\n     }\n+    if let Some(ref args) = sess.opts.debugging_opts.pre_link_args {\n+        cmd.args(args);\n+    }\n+    cmd.args(&sess.opts.debugging_opts.pre_link_arg);\n \n     let pre_link_objects = if crate_type == config::CrateTypeExecutable {\n         &sess.target.target.options.pre_link_objects_exe\n@@ -1141,8 +1146,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n         archive.update_symbols();\n \n         for f in archive.src_files() {\n-            if f.ends_with(\"bytecode.deflate\") ||\n-                f == sess.cstore.metadata_filename() {\n+            if f.ends_with(\"bytecode.deflate\") || f == METADATA_FILENAME {\n                     archive.remove_file(&f);\n                     continue\n                 }\n@@ -1217,8 +1221,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n \n             let mut any_objects = false;\n             for f in archive.src_files() {\n-                if f.ends_with(\"bytecode.deflate\") ||\n-                   f == sess.cstore.metadata_filename() {\n+                if f.ends_with(\"bytecode.deflate\") || f == METADATA_FILENAME {\n                     archive.remove_file(&f);\n                     continue\n                 }"}, {"sha": "437ced85b2e4ad48ec97d7186ea54f5d50820764", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -34,6 +34,7 @@ use back::linker::LinkerInfo;\n use back::symbol_export::{self, ExportedSymbols};\n use llvm::{ContextRef, Linkage, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n+use metadata;\n use rustc::hir::def_id::LOCAL_CRATE;\n use middle::lang_items::StartFnLangItem;\n use middle::cstore::EncodedMetadata;\n@@ -778,8 +779,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n-        let section_name =\n-            tcx.sess.cstore.metadata_section_name(&tcx.sess.target.target);\n+        let section_name = metadata::metadata_section_name(&tcx.sess.target.target);\n         let name = CString::new(section_name).unwrap();\n         llvm::LLVMSetSection(llglobal, name.as_ptr());\n "}, {"sha": "c2f2c63790a4c64d04ec9e9ca93ffb175364fc24", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -375,7 +375,10 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n \n             let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n                 let dctx = debuginfo::CrateDebugContext::new(llmod);\n-                debuginfo::metadata::compile_unit_metadata(shared, &dctx, shared.tcx.sess);\n+                debuginfo::metadata::compile_unit_metadata(shared,\n+                                                           codegen_unit.name(),\n+                                                           &dctx,\n+                                                           shared.tcx.sess);\n                 Some(dctx)\n             } else {\n                 None"}, {"sha": "7d8b8161abe0282e2751b87ab95e20be3cb1c8e4", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -762,31 +762,38 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn compile_unit_metadata(scc: &SharedCrateContext,\n+                             codegen_unit_name: &str,\n                              debug_context: &CrateDebugContext,\n                              sess: &Session)\n                              -> DIDescriptor {\n-    let compile_unit_name = match sess.local_crate_source_file {\n-        None => fallback_path(scc),\n-        Some(ref path) => {\n-            CString::new(&path[..]).unwrap()\n-        }\n+    let mut name_in_debuginfo = match sess.local_crate_source_file {\n+        Some(ref path) => path.clone(),\n+        None => scc.tcx().crate_name(LOCAL_CRATE).to_string(),\n     };\n \n-    debug!(\"compile_unit_metadata: {:?}\", compile_unit_name);\n+    // The OSX linker has an idiosyncrasy where it will ignore some debuginfo\n+    // if multiple object files with the same DW_AT_name are linked together.\n+    // As a workaround we generate unique names for each object file. Those do\n+    // not correspond to an actual source file but that should be harmless.\n+    if scc.sess().target.target.options.is_like_osx {\n+        name_in_debuginfo.push_str(\"@\");\n+        name_in_debuginfo.push_str(codegen_unit_name);\n+    }\n+\n+    debug!(\"compile_unit_metadata: {:?}\", name_in_debuginfo);\n     // FIXME(#41252) Remove \"clang LLVM\" if we can get GDB and LLVM to play nice.\n     let producer = format!(\"clang LLVM (rustc version {})\",\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n-    let compile_unit_name = compile_unit_name.as_ptr();\n-\n+    let name_in_debuginfo = CString::new(name_in_debuginfo).unwrap();\n     let work_dir = CString::new(&sess.working_dir.0[..]).unwrap();\n     let producer = CString::new(producer).unwrap();\n     let flags = \"\\0\";\n     let split_name = \"\\0\";\n \n     unsafe {\n         let file_metadata = llvm::LLVMRustDIBuilderCreateFile(\n-            debug_context.builder, compile_unit_name, work_dir.as_ptr());\n+            debug_context.builder, name_in_debuginfo.as_ptr(), work_dir.as_ptr());\n \n         return llvm::LLVMRustDIBuilderCreateCompileUnit(\n             debug_context.builder,\n@@ -798,10 +805,6 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n             0,\n             split_name.as_ptr() as *const _)\n     };\n-\n-    fn fallback_path(scc: &SharedCrateContext) -> CString {\n-        CString::new(scc.tcx().crate_name(LOCAL_CRATE).to_string()).unwrap()\n-    }\n }\n \n struct MetadataCreationResult {"}, {"sha": "3ac0d88b90d7b7be0f6894313951a6b6595cf235", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -45,6 +45,7 @@ use syntax_pos::symbol::Symbol;\n \n extern crate flate;\n extern crate libc;\n+extern crate owning_ref;\n #[macro_use] extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n@@ -70,6 +71,9 @@ pub use rustc::util;\n pub use base::trans_crate;\n pub use back::symbol_names::provide;\n \n+pub use metadata::LlvmMetadataLoader;\n+pub use llvm_util::{init, target_features, print_version, print_passes, print, enable_llvm_debug};\n+\n pub mod back {\n     pub use rustc::hir::svh;\n \n@@ -119,7 +123,9 @@ mod debuginfo;\n mod declare;\n mod glue;\n mod intrinsic;\n+mod llvm_util;\n mod machine;\n+mod metadata;\n mod meth;\n mod mir;\n mod monomorphize;"}, {"sha": "15f56036b0c1b933aebe49308108f51080d3f441", "filename": "src/librustc_trans/llvm_util.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax_pos::symbol::Symbol;\n+use back::write::create_target_machine;\n+use llvm;\n+use rustc::session::Session;\n+use rustc::session::config::PrintRequest;\n+use libc::{c_int, c_char};\n+use std::ffi::CString;\n+\n+use std::sync::atomic::{AtomicBool, Ordering};\n+use std::sync::Once;\n+\n+pub fn init(sess: &Session) {\n+    unsafe {\n+        // Before we touch LLVM, make sure that multithreading is enabled.\n+        static POISONED: AtomicBool = AtomicBool::new(false);\n+        static INIT: Once = Once::new();\n+        INIT.call_once(|| {\n+            if llvm::LLVMStartMultithreaded() != 1 {\n+                // use an extra bool to make sure that all future usage of LLVM\n+                // cannot proceed despite the Once not running more than once.\n+                POISONED.store(true, Ordering::SeqCst);\n+            }\n+\n+            configure_llvm(sess);\n+        });\n+\n+        if POISONED.load(Ordering::SeqCst) {\n+            bug!(\"couldn't enable multi-threaded LLVM\");\n+        }\n+    }\n+}\n+\n+unsafe fn configure_llvm(sess: &Session) {\n+    let mut llvm_c_strs = Vec::new();\n+    let mut llvm_args = Vec::new();\n+\n+    {\n+        let mut add = |arg: &str| {\n+            let s = CString::new(arg).unwrap();\n+            llvm_args.push(s.as_ptr());\n+            llvm_c_strs.push(s);\n+        };\n+        add(\"rustc\"); // fake program name\n+        if sess.time_llvm_passes() { add(\"-time-passes\"); }\n+        if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n+\n+        for arg in &sess.opts.cg.llvm_args {\n+            add(&(*arg));\n+        }\n+    }\n+\n+    llvm::LLVMInitializePasses();\n+\n+    llvm::initialize_available_targets();\n+\n+    llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n+                                 llvm_args.as_ptr());\n+}\n+\n+// WARNING: the features must be known to LLVM or the feature\n+// detection code will walk past the end of the feature array,\n+// leading to crashes.\n+\n+const ARM_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"vfp2\\0\", \"vfp3\\0\", \"vfp4\\0\"];\n+\n+const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bmi2\\0\", \"sse\\0\",\n+                                                 \"sse2\\0\", \"sse3\\0\", \"sse4.1\\0\", \"sse4.2\\0\",\n+                                                 \"ssse3\\0\", \"tbm\\0\", \"lzcnt\\0\", \"popcnt\\0\",\n+                                                 \"sse4a\\0\", \"rdrnd\\0\", \"rdseed\\0\", \"fma\\0\"];\n+\n+const HEXAGON_WHITELIST: &'static [&'static str] = &[\"hvx\\0\", \"hvx-double\\0\"];\n+\n+pub fn target_features(sess: &Session) -> Vec<Symbol> {\n+    let target_machine = create_target_machine(sess);\n+\n+    let whitelist = match &*sess.target.target.arch {\n+        \"arm\" => ARM_WHITELIST,\n+        \"x86\" | \"x86_64\" => X86_WHITELIST,\n+        \"hexagon\" => HEXAGON_WHITELIST,\n+        _ => &[],\n+    };\n+\n+    let mut features = Vec::new();\n+    for feat in whitelist {\n+        assert_eq!(feat.chars().last(), Some('\\0'));\n+        if unsafe { llvm::LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n+            features.push(Symbol::intern(&feat[..feat.len() - 1]));\n+        }\n+    }\n+    features\n+}\n+\n+pub fn print_version() {\n+    unsafe {\n+        println!(\"LLVM version: {}.{}\",\n+                 llvm::LLVMRustVersionMajor(), llvm::LLVMRustVersionMinor());\n+    }\n+}\n+\n+pub fn print_passes() {\n+    unsafe { llvm::LLVMRustPrintPasses(); }\n+}\n+\n+pub fn print(req: PrintRequest, sess: &Session) {\n+    let tm = create_target_machine(sess);\n+    unsafe {\n+        match req {\n+            PrintRequest::TargetCPUs => llvm::LLVMRustPrintTargetCPUs(tm),\n+            PrintRequest::TargetFeatures => llvm::LLVMRustPrintTargetFeatures(tm),\n+            _ => bug!(\"rustc_trans can't handle print request: {:?}\", req),\n+        }\n+    }\n+}\n+\n+pub fn enable_llvm_debug() {\n+    unsafe { llvm::LLVMRustSetDebug(1); }\n+}"}, {"sha": "2c0148dfbb371851958c0e4b0c10464818ab0b65", "filename": "src/librustc_trans/metadata.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_trans%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmetadata.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::util::common;\n+use rustc::middle::cstore::MetadataLoader;\n+use rustc_back::target::Target;\n+use llvm;\n+use llvm::{False, ObjectFile, mk_section_iter};\n+use llvm::archive_ro::ArchiveRO;\n+\n+use owning_ref::{ErasedBoxRef, OwningRef};\n+use std::path::Path;\n+use std::ptr;\n+use std::slice;\n+\n+pub const METADATA_FILENAME: &str = \"rust.metadata.bin\";\n+\n+pub struct LlvmMetadataLoader;\n+\n+impl MetadataLoader for LlvmMetadataLoader {\n+    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<ErasedBoxRef<[u8]>, String> {\n+        // Use ArchiveRO for speed here, it's backed by LLVM and uses mmap\n+        // internally to read the file. We also avoid even using a memcpy by\n+        // just keeping the archive along while the metadata is in use.\n+        let archive = ArchiveRO::open(filename)\n+            .map(|ar| OwningRef::new(box ar))\n+            .ok_or_else(|| {\n+                            debug!(\"llvm didn't like `{}`\", filename.display());\n+                            format!(\"failed to read rlib metadata: '{}'\", filename.display())\n+                        })?;\n+        let buf: OwningRef<_, [u8]> = archive\n+            .try_map(|ar| {\n+                ar.iter()\n+                    .filter_map(|s| s.ok())\n+                    .find(|sect| sect.name() == Some(METADATA_FILENAME))\n+                    .map(|s| s.data())\n+                    .ok_or_else(|| {\n+                                    debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n+                                    format!(\"failed to read rlib metadata: '{}'\",\n+                                            filename.display())\n+                                })\n+            })?;\n+        Ok(buf.erase_owner())\n+    }\n+\n+    fn get_dylib_metadata(&self,\n+                          target: &Target,\n+                          filename: &Path)\n+                          -> Result<ErasedBoxRef<[u8]>, String> {\n+        unsafe {\n+            let buf = common::path2cstr(filename);\n+            let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n+            if mb as isize == 0 {\n+                return Err(format!(\"error reading library: '{}'\", filename.display()));\n+            }\n+            let of = ObjectFile::new(mb)\n+                .map(|of| OwningRef::new(box of))\n+                .ok_or_else(|| format!(\"provided path not an object file: '{}'\",\n+                                        filename.display()))?;\n+            let buf = of.try_map(|of| search_meta_section(of, target, filename))?;\n+            Ok(buf.erase_owner())\n+        }\n+    }\n+}\n+\n+fn search_meta_section<'a>(of: &'a ObjectFile,\n+                           target: &Target,\n+                           filename: &Path)\n+                           -> Result<&'a [u8], String> {\n+    unsafe {\n+        let si = mk_section_iter(of.llof);\n+        while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n+            let mut name_buf = ptr::null();\n+            let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n+            let name = slice::from_raw_parts(name_buf as *const u8, name_len as usize).to_vec();\n+            let name = String::from_utf8(name).unwrap();\n+            debug!(\"get_metadata_section: name {}\", name);\n+            if read_metadata_section_name(target) == name {\n+                let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n+                let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n+                // The buffer is valid while the object file is around\n+                let buf: &'a [u8] = slice::from_raw_parts(cbuf as *const u8, csz);\n+                return Ok(buf);\n+            }\n+            llvm::LLVMMoveToNextSection(si.llsi);\n+        }\n+    }\n+    Err(format!(\"metadata not found: '{}'\", filename.display()))\n+}\n+\n+pub fn metadata_section_name(target: &Target) -> &'static str {\n+    // Historical note:\n+    //\n+    // When using link.exe it was seen that the section name `.note.rustc`\n+    // was getting shortened to `.note.ru`, and according to the PE and COFF\n+    // specification:\n+    //\n+    // > Executable images do not use a string table and do not support\n+    // > section names longer than 8\u00a0characters\n+    //\n+    // https://msdn.microsoft.com/en-us/library/windows/hardware/gg463119.aspx\n+    //\n+    // As a result, we choose a slightly shorter name! As to why\n+    // `.note.rustc` works on MinGW, that's another good question...\n+\n+    if target.options.is_like_osx {\n+        \"__DATA,.rustc\"\n+    } else {\n+        \".rustc\"\n+    }\n+}\n+\n+fn read_metadata_section_name(_target: &Target) -> &'static str {\n+    \".rustc\"\n+}"}, {"sha": "7e70bb92cd6e0f011b57c3baf236412490b09641", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -251,9 +251,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let bound_list = unsatisfied_predicates.iter()\n                         .map(|p| format!(\"`{} : {}`\", p.self_ty(), p))\n                         .collect::<Vec<_>>()\n-                        .join(\", \");\n+                        .join(\"\\n\");\n                     err.note(&format!(\"the method `{}` exists but the following trait bounds \\\n-                                       were not satisfied: {}\",\n+                                       were not satisfied:\\n{}\",\n                                       item_name,\n                                       bound_list));\n                 }"}, {"sha": "d304d79bc52c8342b8ce1ad65cf1226f2cfb277a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -1200,7 +1200,7 @@ fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            impl_id: DefId,\n                                            impl_item: &hir::ImplItem)\n {\n-    let ancestors = trait_def.ancestors(impl_id);\n+    let ancestors = trait_def.ancestors(tcx, impl_id);\n \n     let kind = match impl_item.node {\n         hir::ImplItemKind::Const(..) => ty::AssociatedKind::Const,\n@@ -1330,7 +1330,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut invalidated_items = Vec::new();\n     let associated_type_overridden = overridden_associated_type.is_some();\n     for trait_item in tcx.associated_items(impl_trait_ref.def_id) {\n-        let is_implemented = trait_def.ancestors(impl_id)\n+        let is_implemented = trait_def.ancestors(tcx, impl_id)\n             .defs(tcx, trait_item.name, trait_item.kind)\n             .next()\n             .map(|node_item| !node_item.node.is_from_trait())"}, {"sha": "556bd618c78cbb22e49b90b503f1daad2577d4a6", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -249,6 +249,45 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     return err_info;\n                 }\n \n+                // Here we are considering a case of converting\n+                // `S<P0...Pn>` to S<Q0...Qn>`. As an example, let's imagine a struct `Foo<T, U>`,\n+                // which acts like a pointer to `U`, but carries along some extra data of type `T`:\n+                //\n+                //     struct Foo<T, U> {\n+                //         extra: T,\n+                //         ptr: *mut U,\n+                //     }\n+                //\n+                // We might have an impl that allows (e.g.) `Foo<T, [i32; 3]>` to be unsized\n+                // to `Foo<T, [i32]>`. That impl would look like:\n+                //\n+                //   impl<T, U: Unsize<V>, V> CoerceUnsized<Foo<T, V>> for Foo<T, U> {}\n+                //\n+                // Here `U = [i32; 3]` and `V = [i32]`. At runtime,\n+                // when this coercion occurs, we would be changing the\n+                // field `ptr` from a thin pointer of type `*mut [i32;\n+                // 3]` to a fat pointer of type `*mut [i32]` (with\n+                // extra data `3`).  **The purpose of this check is to\n+                // make sure that we know how to do this conversion.**\n+                //\n+                // To check if this impl is legal, we would walk down\n+                // the fields of `Foo` and consider their types with\n+                // both substitutes. We are looking to find that\n+                // exactly one (non-phantom) field has changed its\n+                // type, which we will expect to be the pointer that\n+                // is becoming fat (we could probably generalize this\n+                // to mutiple thin pointers of the same type becoming\n+                // fat, but we don't). In this case:\n+                //\n+                // - `extra` has type `T` before and type `T` after\n+                // - `ptr` has type `*mut U` before and type `*mut V` after\n+                //\n+                // Since just one field changed, we would then check\n+                // that `*mut U: CoerceUnsized<*mut V>` is implemented\n+                // (in other words, that we know how to do this\n+                // conversion). This will work out because `U:\n+                // Unsize<V>`, and we have a builtin rule that `*mut\n+                // U` can be coerced to `*mut V` if `U: Unsize<V>`.\n                 let fields = &def_a.struct_variant().fields;\n                 let diff_fields = fields.iter()\n                     .enumerate()\n@@ -260,8 +299,16 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             return None;\n                         }\n \n-                        // Ignore fields that aren't significantly changed\n-                        if let Ok(ok) = infcx.sub_types(false, &cause, b, a) {\n+                        // Ignore fields that aren't changed; it may\n+                        // be that we could get away with subtyping or\n+                        // something more accepting, but we use\n+                        // equality because we want to be able to\n+                        // perform this check without computing\n+                        // variance where possible. (This is because\n+                        // we may have to evaluate constraint\n+                        // expressions in the course of execution.)\n+                        // See e.g. #41936.\n+                        if let Ok(ok) = infcx.eq_types(false, &cause, b, a) {\n                             if ok.obligations.is_empty() {\n                                 return None;\n                             }"}, {"sha": "165be49f7603de1d73ff00a03519187585980996", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -46,8 +46,6 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n         }\n \n         enforce_trait_manually_implementable(tcx, impl_def_id, trait_ref.def_id);\n-        let trait_def = tcx.trait_def(trait_ref.def_id);\n-        trait_def.record_local_impl(tcx, impl_def_id, trait_ref);\n     }\n }\n \n@@ -117,8 +115,6 @@ pub fn provide(providers: &mut Providers) {\n \n fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             (_, def_id): (CrateNum, DefId)) {\n-    tcx.populate_implementations_for_trait_if_necessary(def_id);\n-\n     let impls = tcx.hir.trait_impls(def_id);\n     for &impl_id in impls {\n         check_impl(tcx, impl_id);"}, {"sha": "ba1d7b18e8c7faeb29dcc40e41f84cf13426d211", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -41,39 +41,10 @@ pub fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n     let _task =\n         tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n \n-    let def = tcx.trait_def(trait_def_id);\n-\n-    // attempt to insert into the specialization graph\n-    let insert_result = def.add_impl_for_specialization(tcx, impl_def_id);\n-\n-    // insertion failed due to overlap\n-    if let Err(overlap) = insert_result {\n-        let mut err = struct_span_err!(tcx.sess,\n-                                       tcx.span_of_impl(impl_def_id).unwrap(),\n-                                       E0119,\n-                                       \"conflicting implementations of trait `{}`{}:\",\n-                                       overlap.trait_desc,\n-                                       overlap.self_desc.clone().map_or(String::new(),\n-                                                                        |ty| {\n-            format!(\" for type `{}`\", ty)\n-        }));\n-\n-        match tcx.span_of_impl(overlap.with_impl) {\n-            Ok(span) => {\n-                err.span_label(span, \"first implementation here\");\n-                err.span_label(tcx.span_of_impl(impl_def_id).unwrap(),\n-                               format!(\"conflicting implementation{}\",\n-                                        overlap.self_desc\n-                                            .map_or(String::new(),\n-                                                    |ty| format!(\" for `{}`\", ty))));\n-            }\n-            Err(cname) => {\n-                err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n-            }\n-        }\n+    // Trigger building the specialization graph for the trait of this impl.\n+    // This will detect any overlap errors.\n+    tcx.specialization_graph_of(trait_def_id);\n \n-        err.emit();\n-    }\n \n     // check for overlap with the automatic `impl Trait for Trait`\n     if let ty::TyDynamic(ref data, ..) = trait_ref.self_ty().sty {"}, {"sha": "cb1bd3e099d54c31ef6b468cf0cc619a1cb69e4a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -749,12 +749,12 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let def_path_hash = tcx.def_path_hash(def_id);\n-    let def = ty::TraitDef::new(def_id, unsafety, paren_sugar, def_path_hash);\n-\n-    if tcx.hir.trait_is_auto(def_id) {\n-        def.record_has_default_impl();\n-    }\n-\n+    let has_default_impl = tcx.hir.trait_is_auto(def_id);\n+    let def = ty::TraitDef::new(def_id,\n+                                unsafety,\n+                                paren_sugar,\n+                                has_default_impl,\n+                                def_path_hash);\n     tcx.alloc_trait_def(def)\n }\n "}, {"sha": "f9ebe3fff5beb951478ecbe9f8442cc48b8cf679", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -1524,67 +1524,6 @@ impl TypeWrapper {\n ```\n \"##,\n \n-E0119: r##\"\n-There are conflicting trait implementations for the same type.\n-Example of erroneous code:\n-\n-```compile_fail,E0119\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-\n-struct Foo {\n-    value: usize\n-}\n-\n-impl MyTrait for Foo { // error: conflicting implementations of trait\n-                       //        `MyTrait` for type `Foo`\n-    fn get(&self) -> usize { self.value }\n-}\n-```\n-\n-When looking for the implementation for the trait, the compiler finds\n-both the `impl<T> MyTrait for T` where T is all types and the `impl\n-MyTrait for Foo`. Since a trait cannot be implemented multiple times,\n-this is an error. So, when you write:\n-\n-```\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-```\n-\n-This makes the trait implemented on all types in the scope. So if you\n-try to implement it on another one after that, the implementations will\n-conflict. Example:\n-\n-```\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-\n-struct Foo;\n-\n-fn main() {\n-    let f = Foo;\n-\n-    f.get(); // the trait is implemented so we can use it\n-}\n-```\n-\"##,\n-\n E0120: r##\"\n An attempt was made to implement Drop on a trait, which is not allowed: only\n structs and enums can implement Drop. An example causing this error:"}, {"sha": "9a689ed079ee259f8240a652942966c3ddd7ec57", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -19,6 +19,7 @@ use rustc::ty::{self, TyCtxt, GlobalArenas};\n use rustc::hir::map as hir_map;\n use rustc::lint;\n use rustc::util::nodemap::FxHashMap;\n+use rustc_trans;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n@@ -138,10 +139,11 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, &dep_graph, cpath, diagnostic_handler, codemap, cstore.clone()\n     );\n+    rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs));"}, {"sha": "612793e2567f1c35dbf5bd47684578559e0d8fde", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -1177,7 +1177,6 @@ impl fmt::Display for AbiSpace {\n         let quot = if f.alternate() { \"\\\"\" } else { \"&quot;\" };\n         match self.0 {\n             Abi::Rust => Ok(()),\n-            Abi::C => write!(f, \"extern \"),\n             abi => write!(f, \"extern {0}{1}{0} \", quot, abi.name()),\n         }\n     }"}, {"sha": "53e341226af3ecc6c681b7c62334cd018a1f924d", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -215,14 +215,14 @@\n         } else if (ev.target.tagName === 'SPAN' && hasClass(ev.target.parentNode, 'line-numbers')) {\n             var prev_id = 0;\n \n-            function set_fragment(name) {\n+            var set_fragment = function (name) {\n                 if (browserSupportsHistoryApi()) {\n                     history.replaceState(null, null, '#' + name);\n                     window.hashchange();\n                 } else {\n                     location.replace('#' + name);\n                 }\n-            }\n+            };\n \n             var cur_id = parseInt(ev.target.id, 10);\n \n@@ -685,7 +685,7 @@\n         }\n \n         function escape(content) {\n-            let h1 = document.createElement('h1');\n+            var h1 = document.createElement('h1');\n             h1.textContent = content;\n             return h1.innerHTML;\n         }\n@@ -1083,10 +1083,10 @@\n                 code.innerHTML = structs[j];\n \n                 var x = code.getElementsByTagName('a');\n-                for (var i = 0; i < x.length; i++) {\n-                    var href = x[i].href;\n+                for (var k = 0; k < x.length; k++) {\n+                    var href = x[k].getAttribute('href');\n                     if (href && href.indexOf('http') !== 0) {\n-                        x[i].href = rootPath + href;\n+                        x[k].setAttribute('href', rootPath + href);\n                     }\n                 }\n                 var li = document.createElement('li');"}, {"sha": "570a1980782131131ff3c05dbe52e6ad0fa621a1", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -617,6 +617,11 @@ a.test-arrow:hover{\n \ttop: 0;\n }\n \n+h3 > .collapse-toggle, h4 > .collapse-toggle {\n+\tfont-size: 0.8em;\n+\ttop: 5px;\n+}\n+\n .toggle-wrapper > .collapse-toggle {\n \tleft: -24px;\n \tmargin-top: 0px;"}, {"sha": "f682f6aa763c5cd43e94f38f35724eeadd668256", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -107,12 +107,19 @@ pub fn main() {\n     const STACK_SIZE: usize = 32_000_000; // 32MB\n     env_logger::init().unwrap();\n     let res = std::thread::Builder::new().stack_size(STACK_SIZE).spawn(move || {\n-        let s = env::args().collect::<Vec<_>>();\n-        main_args(&s)\n+        get_args().map(|args| main_args(&args)).unwrap_or(1)\n     }).unwrap().join().unwrap_or(101);\n     process::exit(res as i32);\n }\n \n+fn get_args() -> Option<Vec<String>> {\n+    env::args_os().enumerate()\n+        .map(|(i, arg)| arg.into_string().map_err(|arg| {\n+             print_error(format!(\"Argument {} is not valid Unicode: {:?}\", i, arg));\n+        }).ok())\n+        .collect()\n+}\n+\n fn stable(g: getopts::OptGroup) -> RustcOptGroup { RustcOptGroup::stable(g) }\n fn unstable(g: getopts::OptGroup) -> RustcOptGroup { RustcOptGroup::unstable(g) }\n "}, {"sha": "cfe2fad0fa4695a59d1b840da41c493305086a6c", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -34,6 +34,7 @@ use rustc_driver::{self, driver, Compilation};\n use rustc_driver::driver::phase_2_configure_and_expand;\n use rustc_metadata::cstore::CStore;\n use rustc_resolve::MakeGlobMap;\n+use rustc_trans;\n use rustc_trans::back::link;\n use syntax::ast;\n use syntax::codemap::CodeMap;\n@@ -81,10 +82,11 @@ pub fn run(input: &str,\n \n     let dep_graph = DepGraph::new(false);\n     let _ignore = dep_graph.in_ignore();\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, &dep_graph, Some(input_path.clone()), handler, codemap.clone(), cstore.clone(),\n     );\n+    rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     sess.parse_sess.config =\n         config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n@@ -229,10 +231,11 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     let diagnostic_handler = errors::Handler::with_emitter(true, false, box emitter);\n \n     let dep_graph = DepGraph::new(false);\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n         sessopts, &dep_graph, None, diagnostic_handler, codemap, cstore.clone(),\n     );\n+    rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let outdir = Mutex::new(TempDir::new(\"rustdoctest\").ok().expect(\"rustdoc needs a tempdir\"));"}, {"sha": "5d2bb9daf17ef1c893d83430da940f737fe5b345", "filename": "src/libstd/env.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -50,16 +50,19 @@ use sys::os as os_imp;\n /// use std::env;\n ///\n /// // We assume that we are in a valid directory.\n-/// let p = env::current_dir().unwrap();\n-/// println!(\"The current directory is {}\", p.display());\n+/// let path = env::current_dir().unwrap();\n+/// println!(\"The current directory is {}\", path.display());\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn current_dir() -> io::Result<PathBuf> {\n     os_imp::getcwd()\n }\n \n-/// Changes the current working directory to the specified path, returning\n-/// whether the change was completed successfully or not.\n+/// Changes the current working directory to the specified path.\n+///\n+/// Returns an [`Err`] if the operation fails.\n+///\n+/// [`Err`]: ../../std/result/enum.Result.html#method.err\n ///\n /// # Examples\n ///\n@@ -72,8 +75,8 @@ pub fn current_dir() -> io::Result<PathBuf> {\n /// println!(\"Successfully changed working directory to {}!\", root.display());\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn set_current_dir<P: AsRef<Path>>(p: P) -> io::Result<()> {\n-    os_imp::chdir(p.as_ref())\n+pub fn set_current_dir<P: AsRef<Path>>(path: P) -> io::Result<()> {\n+    os_imp::chdir(path.as_ref())\n }\n \n /// An iterator over a snapshot of the environment variables of this process.\n@@ -206,7 +209,7 @@ pub fn var<K: AsRef<OsStr>>(key: K) -> Result<String, VarError> {\n fn _var(key: &OsStr) -> Result<String, VarError> {\n     match var_os(key) {\n         Some(s) => s.into_string().map_err(VarError::NotUnicode),\n-        None => Err(VarError::NotPresent)\n+        None => Err(VarError::NotPresent),\n     }\n }\n "}, {"sha": "d0e7defbbbb9a15f0b9af79925d319c8d8e22d59", "filename": "src/libstd/process.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -754,6 +754,13 @@ impl fmt::Debug for Stdio {\n }\n \n /// Describes the result of a process after it has terminated.\n+///\n+/// This `struct` is used to represent the exit status of a child process.\n+/// Child processes are created via the [`Command`] struct and their exit\n+/// status is exposed through the [`status`] method.\n+///\n+/// [`Command`]: struct.Command.html\n+/// [`status`]: struct.Command.html#method.status\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ExitStatus(imp::ExitStatus);\n@@ -788,6 +795,22 @@ impl ExitStatus {\n     /// On Unix, this will return `None` if the process was terminated\n     /// by a signal; `std::os::unix` provides an extension trait for\n     /// extracting the signal and other details from the `ExitStatus`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::process::Command;\n+    ///\n+    /// let status = Command::new(\"mkdir\")\n+    ///                      .arg(\"projects\")\n+    ///                      .status()\n+    ///                      .expect(\"failed to execute mkdir\");\n+    ///\n+    /// match status.code() {\n+    ///     Some(code) => println!(\"Exited with status code: {}\", code),\n+    ///     None       => println!(\"Process terminated by signal\")\n+    /// }\n+    /// ```\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn code(&self) -> Option<i32> {\n         self.0.code()"}, {"sha": "284a5fbd9d5066dcc87353daca96e9e2dbaee58e", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -1067,7 +1067,7 @@ impl<T> Receiver<T> {\n         Receiver { inner: UnsafeCell::new(inner) }\n     }\n \n-    /// Attempts to return a pending value on this receiver without blocking\n+    /// Attempts to return a pending value on this receiver without blocking.\n     ///\n     /// This method will never block the caller in order to wait for data to\n     /// become available. Instead, this will always return immediately with a"}, {"sha": "8e41fd009be675db4954e19aae6da513f546913f", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -253,7 +253,12 @@ pub fn current_exe() -> io::Result<PathBuf> {\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\", target_os = \"emscripten\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n-    ::fs::read_link(\"/proc/self/exe\")\n+    let selfexe = PathBuf::from(\"/proc/self/exe\");\n+    if selfexe.exists() {\n+        ::fs::read_link(selfexe)\n+    } else {\n+        Err(io::Error::new(io::ErrorKind::Other, \"no /proc/self/exe available. Is /proc mounted?\"))\n+    }\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]"}, {"sha": "3f6c2827a3f937242b2522ccf29904545e6b39d8", "filename": "src/libstd/sys/windows/ext/ffi.rs", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -26,8 +26,22 @@ pub trait OsStringExt {\n     /// Creates an `OsString` from a potentially ill-formed UTF-16 slice of\n     /// 16-bit code units.\n     ///\n-    /// This is lossless: calling `.encode_wide()` on the resulting string\n+    /// This is lossless: calling [`encode_wide`] on the resulting string\n     /// will always return the original code units.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::OsString;\n+    /// use std::os::windows::prelude::*;\n+    ///\n+    /// // UTF-16 encoding for \"Unicode\".\n+    /// let source = [0x0055, 0x006E, 0x0069, 0x0063, 0x006F, 0x0064, 0x0065];\n+    ///\n+    /// let string = OsString::from_wide(&source[..]);\n+    /// ```\n+    ///\n+    /// [`encode_wide`]: ./trait.OsStrExt.html#tymethod.encode_wide\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from_wide(wide: &[u16]) -> Self;\n }\n@@ -42,11 +56,29 @@ impl OsStringExt for OsString {\n /// Windows-specific extensions to `OsStr`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait OsStrExt {\n-    /// Re-encodes an `OsStr` as a wide character sequence,\n-    /// i.e. potentially ill-formed UTF-16.\n+    /// Re-encodes an `OsStr` as a wide character sequence, i.e. potentially\n+    /// ill-formed UTF-16.\n+    ///\n+    /// This is lossless: calling [`OsString::from_wide`] and then\n+    /// `encode_wide` on the result will yield the original code units.\n+    /// Note that the encoding does not add a final null terminator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::ffi::OsString;\n+    /// use std::os::windows::prelude::*;\n+    ///\n+    /// // UTF-16 encoding for \"Unicode\".\n+    /// let source = [0x0055, 0x006E, 0x0069, 0x0063, 0x006F, 0x0064, 0x0065];\n+    ///\n+    /// let string = OsString::from_wide(&source[..]);\n+    ///\n+    /// let result: Vec<u16> = string.encode_wide().collect();\n+    /// assert_eq!(&source[..], &result[..]);\n+    /// ```\n     ///\n-    /// This is lossless. Note that the encoding does not include a final\n-    /// null.\n+    /// [`OsString::from_wide`]: ./trait.OsStringExt.html#tymethod.from_wide\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn encode_wide(&self) -> EncodeWide;\n }"}, {"sha": "2d00cb38ec4fcb9ba20d85f642c60c1c6140f22d", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 243, "deletions": 48, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Windows-specific extensions for the primitives in `std::fs`\n+//! Windows-specific extensions for the primitives in the `std::fs` module.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -18,7 +18,9 @@ use path::Path;\n use sys;\n use sys_common::{AsInnerMut, AsInner};\n \n-/// Windows-specific extensions to `File`\n+/// Windows-specific extensions to [`File`].\n+///\n+/// [`File`]: ../../../fs/struct.File.html\n #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n pub trait FileExt {\n     /// Seeks to a given position and reads a number of bytes.\n@@ -35,6 +37,24 @@ pub trait FileExt {\n     /// Note that similar to `File::read`, it is not an error to return with a\n     /// short read. When returning from such a short read, the file pointer is\n     /// still updated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::fs::File;\n+    /// use std::os::windows::prelude::*;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut file = File::open(\"foo.txt\")?;\n+    /// let mut buffer = [0; 10];\n+    ///\n+    /// // Read 10 bytes, starting 72 bytes from the\n+    /// // start of the file.\n+    /// file.seek_read(&mut buffer[..], 72)?;\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     fn seek_read(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;\n \n@@ -52,6 +72,22 @@ pub trait FileExt {\n     /// Note that similar to `File::write`, it is not an error to return a\n     /// short write. When returning from such a short write, the file pointer\n     /// is still updated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::os::windows::prelude::*;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut buffer = File::create(\"foo.txt\")?;\n+    ///\n+    /// // Write a byte string starting 72 bytes from\n+    /// // the start of the file.\n+    /// buffer.seek_write(b\"some bytes\", 72)?;\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n     fn seek_write(&self, buf: &[u8], offset: u64) -> io::Result<usize>;\n }\n@@ -67,81 +103,94 @@ impl FileExt for fs::File {\n     }\n }\n \n-/// Windows-specific extensions to `OpenOptions`\n+/// Windows-specific extensions to [`OpenOptions`].\n+///\n+/// [`OpenOptions`]: ../../../fs/struct.OpenOptions.html\n #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n pub trait OpenOptionsExt {\n-    /// Overrides the `dwDesiredAccess` argument to the call to `CreateFile`\n+    /// Overrides the `dwDesiredAccess` argument to the call to [`CreateFile`]\n     /// with the specified value.\n     ///\n     /// This will override the `read`, `write`, and `append` flags on the\n     /// `OpenOptions` structure. This method provides fine-grained control over\n     /// the permissions to read, write and append data, attributes (like hidden\n-    /// and system) and extended attributes.\n+    /// and system), and extended attributes.\n     ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::fs::OpenOptions;\n-    /// use std::os::windows::fs::OpenOptionsExt;\n+    /// use std::os::windows::prelude::*;\n     ///\n     /// // Open without read and write permission, for example if you only need\n-    /// // to call `stat()` on the file\n+    /// // to call `stat` on the file\n     /// let file = OpenOptions::new().access_mode(0).open(\"foo.txt\");\n     /// ```\n+    ///\n+    /// [`CreateFile`]: https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx\n     #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n     fn access_mode(&mut self, access: u32) -> &mut Self;\n \n-    /// Overrides the `dwShareMode` argument to the call to `CreateFile` with\n+    /// Overrides the `dwShareMode` argument to the call to [`CreateFile`] with\n     /// the specified value.\n     ///\n     /// By default `share_mode` is set to\n-    /// `FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE`. Specifying\n-    /// less permissions denies others to read from, write to and/or delete the\n-    /// file while it is open.\n+    /// `FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE`. This allows\n+    /// other processes to to read, write, and delete/rename the same file\n+    /// while it is open. Removing any of the flags will prevent other\n+    /// processes from performing the corresponding operation until the file\n+    /// handle is closed.\n     ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::fs::OpenOptions;\n-    /// use std::os::windows::fs::OpenOptionsExt;\n+    /// use std::os::windows::prelude::*;\n     ///\n     /// // Do not allow others to read or modify this file while we have it open\n-    /// // for writing\n-    /// let file = OpenOptions::new().write(true)\n-    ///                              .share_mode(0)\n-    ///                              .open(\"foo.txt\");\n+    /// // for writing.\n+    /// let file = OpenOptions::new()\n+    ///     .write(true)\n+    ///     .share_mode(0)\n+    ///     .open(\"foo.txt\");\n     /// ```\n+    ///\n+    /// [`CreateFile`]: https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx\n     #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n     fn share_mode(&mut self, val: u32) -> &mut Self;\n \n     /// Sets extra flags for the `dwFileFlags` argument to the call to\n-    /// `CreateFile2` (or combines it with `attributes` and `security_qos_flags`\n-    /// to set the `dwFlagsAndAttributes` for `CreateFile`).\n+    /// [`CreateFile2`] to the specified value (or combines it with\n+    /// `attributes` and `security_qos_flags` to set the `dwFlagsAndAttributes`\n+    /// for [`CreateFile`]).\n     ///\n-    /// Custom flags can only set flags, not remove flags set by Rusts options.\n-    /// This options overwrites any previously set custom flags.\n+    /// Custom flags can only set flags, not remove flags set by Rust's options.\n+    /// This option overwrites any previously set custom flags.\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,ignore\n+    /// ```ignore\n     /// extern crate winapi;\n+    ///\n     /// use std::fs::OpenOptions;\n-    /// use std::os::windows::fs::OpenOptionsExt;\n-    ///\n-    /// let mut options = OpenOptions::new();\n-    /// options.create(true).write(true);\n-    /// if cfg!(windows) {\n-    ///     options.custom_flags(winapi::FILE_FLAG_DELETE_ON_CLOSE);\n-    /// }\n-    /// let file = options.open(\"foo.txt\");\n+    /// use std::os::windows::prelude::*;\n+    ///\n+    /// let file = OpenOptions::new()\n+    ///     .create(true)\n+    ///     .write(true)\n+    ///     .custom_flags(winapi::FILE_FLAG_DELETE_ON_CLOSE)\n+    ///     .open(\"foo.txt\");\n     /// ```\n+    ///\n+    /// [`CreateFile`]: https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx\n+    /// [`CreateFile2`]: https://msdn.microsoft.com/en-us/library/windows/desktop/hh449422.aspx\n     #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n     fn custom_flags(&mut self, flags: u32) -> &mut Self;\n \n-    /// Sets the `dwFileAttributes` argument to the call to `CreateFile2` to\n+    /// Sets the `dwFileAttributes` argument to the call to [`CreateFile2`] to\n     /// the specified value (or combines it with `custom_flags` and\n     /// `security_qos_flags` to set the `dwFlagsAndAttributes` for\n-    /// `CreateFile`).\n+    /// [`CreateFile`]).\n     ///\n     /// If a _new_ file is created because it does not yet exist and\n     /// `.create(true)` or `.create_new(true)` are specified, the new file is\n@@ -155,21 +204,52 @@ pub trait OpenOptionsExt {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust,ignore\n+    /// ```ignore\n     /// extern crate winapi;\n+    ///\n     /// use std::fs::OpenOptions;\n-    /// use std::os::windows::fs::OpenOptionsExt;\n+    /// use std::os::windows::prelude::*;\n     ///\n-    /// let file = OpenOptions::new().write(true).create(true)\n-    ///                              .attributes(winapi::FILE_ATTRIBUTE_HIDDEN)\n-    ///                              .open(\"foo.txt\");\n+    /// let file = OpenOptions::new()\n+    ///     .write(true)\n+    ///     .create(true)\n+    ///     .attributes(winapi::FILE_ATTRIBUTE_HIDDEN)\n+    ///     .open(\"foo.txt\");\n     /// ```\n+    ///\n+    /// [`CreateFile`]: https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx\n+    /// [`CreateFile2`]: https://msdn.microsoft.com/en-us/library/windows/desktop/hh449422.aspx\n     #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n     fn attributes(&mut self, val: u32) -> &mut Self;\n \n-    /// Sets the `dwSecurityQosFlags` argument to the call to `CreateFile2` to\n+    /// Sets the `dwSecurityQosFlags` argument to the call to [`CreateFile2`] to\n     /// the specified value (or combines it with `custom_flags` and `attributes`\n-    /// to set the `dwFlagsAndAttributes` for `CreateFile`).\n+    /// to set the `dwFlagsAndAttributes` for [`CreateFile`]).\n+    ///\n+    /// By default, `security_qos_flags` is set to `SECURITY_ANONYMOUS`. For\n+    /// information about possible values, see [Impersonation Levels] on the\n+    /// Windows Dev Center site.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::windows::prelude::*;\n+    ///\n+    /// let file = OpenOptions::new()\n+    ///     .write(true)\n+    ///     .create(true)\n+    ///\n+    ///     // Sets the flag value to `SecurityIdentification`.\n+    ///     .security_qos_flags(1)\n+    ///\n+    ///     .open(\"foo.txt\");\n+    /// ```\n+    ///\n+    /// [`CreateFile`]: https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858.aspx\n+    /// [`CreateFile2`]: https://msdn.microsoft.com/en-us/library/windows/desktop/hh449422.aspx\n+    /// [Impersonation Levels]:\n+    ///     https://msdn.microsoft.com/en-us/library/windows/desktop/aa379572.aspx\n     #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n     fn security_qos_flags(&mut self, flags: u32) -> &mut OpenOptions;\n }\n@@ -197,42 +277,157 @@ impl OpenOptionsExt for OpenOptions {\n     }\n }\n \n-/// Extension methods for `fs::Metadata` to access the raw fields contained\n+/// Extension methods for [`fs::Metadata`] to access the raw fields contained\n /// within.\n+///\n+/// The data members that this trait exposes correspond to the members\n+/// of the [`BY_HANDLE_FILE_INFORMATION`] structure.\n+///\n+/// [`fs::Metadata`]: ../../../fs/struct.Metadata.html\n+/// [`BY_HANDLE_FILE_INFORMATION`]:\n+///     https://msdn.microsoft.com/en-us/library/windows/desktop/aa363788.aspx\n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n pub trait MetadataExt {\n     /// Returns the value of the `dwFileAttributes` field of this metadata.\n     ///\n     /// This field contains the file system attribute information for a file\n-    /// or directory.\n+    /// or directory. For possible values and their descriptions, see\n+    /// [File Attribute Constants] in the Windows Dev Center.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::fs;\n+    /// use std::os::windows::prelude::*;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let metadata = fs::metadata(\"foo.txt\")?;\n+    /// let attributes = metadata.file_attributes();\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n+    ///\n+    /// [File Attribute Constants]:\n+    ///     https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n     fn file_attributes(&self) -> u32;\n \n     /// Returns the value of the `ftCreationTime` field of this metadata.\n     ///\n-    /// The returned 64-bit value represents the number of 100-nanosecond\n-    /// intervals since January 1, 1601 (UTC).\n+    /// The returned 64-bit value is equivalent to a [`FILETIME`] struct,\n+    /// which represents the number of 100-nanosecond intervals since\n+    /// January 1, 1601 (UTC). The struct is automatically\n+    /// converted to a `u64` value, as that is the recommended way\n+    /// to use it.\n+    ///\n+    /// If the underlying filesystem does not support creation time, the\n+    /// returned value is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::fs;\n+    /// use std::os::windows::prelude::*;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let metadata = fs::metadata(\"foo.txt\")?;\n+    /// let creation_time = metadata.creation_time();\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n+    ///\n+    /// [`FILETIME`]: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n     fn creation_time(&self) -> u64;\n \n     /// Returns the value of the `ftLastAccessTime` field of this metadata.\n     ///\n-    /// The returned 64-bit value represents the number of 100-nanosecond\n-    /// intervals since January 1, 1601 (UTC).\n+    /// The returned 64-bit value is equivalent to a [`FILETIME`] struct,\n+    /// which represents the number of 100-nanosecond intervals since\n+    /// January 1, 1601 (UTC). The struct is automatically\n+    /// converted to a `u64` value, as that is the recommended way\n+    /// to use it.\n+    ///\n+    /// For a file, the value specifies the last time that a file was read\n+    /// from or written to. For a directory, the value specifies when\n+    /// the directory was created. For both files and directories, the\n+    /// specified date is correct, but the time of day is always set to\n+    /// midnight.\n+    ///\n+    /// If the underlying filesystem does not support last access time, the\n+    /// returned value is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::fs;\n+    /// use std::os::windows::prelude::*;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let metadata = fs::metadata(\"foo.txt\")?;\n+    /// let last_access_time = metadata.last_access_time();\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n+    ///\n+    /// [`FILETIME`]: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n     fn last_access_time(&self) -> u64;\n \n     /// Returns the value of the `ftLastWriteTime` field of this metadata.\n     ///\n-    /// The returned 64-bit value represents the number of 100-nanosecond\n-    /// intervals since January 1, 1601 (UTC).\n+    /// The returned 64-bit value is equivalent to a [`FILETIME`] struct,\n+    /// which represents the number of 100-nanosecond intervals since\n+    /// January 1, 1601 (UTC). The struct is automatically\n+    /// converted to a `u64` value, as that is the recommended way\n+    /// to use it.\n+    ///\n+    /// For a file, the value specifies the last time that a file was written\n+    /// to. For a directory, the structure specifies when the directory was\n+    /// created.\n+    ///\n+    /// If the underlying filesystem does not support the last write time\n+    /// time, the returned value is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::fs;\n+    /// use std::os::windows::prelude::*;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let metadata = fs::metadata(\"foo.txt\")?;\n+    /// let last_write_time = metadata.last_write_time();\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n+    ///\n+    /// [`FILETIME`]: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724284.aspx\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n     fn last_write_time(&self) -> u64;\n \n     /// Returns the value of the `nFileSize{High,Low}` fields of this\n     /// metadata.\n     ///\n     /// The returned value does not have meaning for directories.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::fs;\n+    /// use std::os::windows::prelude::*;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let metadata = fs::metadata(\"foo.txt\")?;\n+    /// let file_size = metadata.file_size();\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n     fn file_size(&self) -> u64;\n }\n@@ -253,7 +448,7 @@ impl MetadataExt for Metadata {\n ///\n /// # Examples\n ///\n-/// ```ignore\n+/// ```no_run\n /// use std::os::windows::fs;\n ///\n /// # fn foo() -> std::io::Result<()> {\n@@ -274,7 +469,7 @@ pub fn symlink_file<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q)\n ///\n /// # Examples\n ///\n-/// ```ignore\n+/// ```no_run\n /// use std::os::windows::fs;\n ///\n /// # fn foo() -> std::io::Result<()> {"}, {"sha": "11b1337a8aec0b933965d39c9cb1b070ad0a44a5", "filename": "src/libstd/sys/windows/ext/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Experimental extensions to `std` for Windows.\n+//! Platform-specific extensions to `std` for Windows.\n //!\n-//! For now, this module is limited to extracting handles, file\n-//! descriptors, and sockets, but its functionality will grow over\n-//! time.\n+//! Provides access to platform-level information for Windows, and exposes\n+//! Windows-specific idioms that would otherwise be inappropriate as part\n+//! the core `std` library. These extensions allow developers to use\n+//! `std` types and idioms with Windows in a way that the normal\n+//! platform-agnostic idioms would not normally support.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "df5e4ef1d886e9f589e413b2ba46d54beb4be1be", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -750,6 +750,7 @@ impl<'a> Iterator for Wtf8CodePoints<'a> {\n     }\n }\n \n+/// Generates a wide character sequence for potentially ill-formed UTF-16.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct EncodeWide<'a> {"}, {"sha": "c2c6e6cf87dff4ad71fcde7e8f721f342ef3d37c", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -19,16 +19,16 @@ use mem;\n /// A thread local storage key which owns its contents.\n ///\n /// This key uses the fastest possible implementation available to it for the\n-/// target platform. It is instantiated with the `thread_local!` macro and the\n-/// primary method is the `with` method.\n+/// target platform. It is instantiated with the [`thread_local!`] macro and the\n+/// primary method is the [`with`] method.\n ///\n-/// The `with` method yields a reference to the contained value which cannot be\n+/// The [`with`] method yields a reference to the contained value which cannot be\n /// sent across threads or escape the given closure.\n ///\n /// # Initialization and Destruction\n ///\n-/// Initialization is dynamically performed on the first call to `with()`\n-/// within a thread, and values that implement `Drop` get destructed when a\n+/// Initialization is dynamically performed on the first call to [`with`]\n+/// within a thread, and values that implement [`Drop`] get destructed when a\n /// thread exits. Some caveats apply, which are explained below.\n ///\n /// # Examples\n@@ -77,6 +77,10 @@ use mem;\n /// 3. On macOS, initializing TLS during destruction of other TLS slots can\n ///    sometimes cancel *all* destructors for the current thread, whether or not\n ///    the slots have already had their destructors run or not.\n+///\n+/// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n+/// [`thread_local!`]: ../../std/macro.thread_local.html\n+/// [`Drop`]: ../../std/ops/trait.Drop.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LocalKey<T: 'static> {\n     // This outer `LocalKey<T>` type is what's going to be stored in statics,\n@@ -106,7 +110,7 @@ impl<T: 'static> fmt::Debug for LocalKey<T> {\n     }\n }\n \n-/// Declare a new thread local storage key of type `std::thread::LocalKey`.\n+/// Declare a new thread local storage key of type [`std::thread::LocalKey`].\n ///\n /// # Syntax\n ///\n@@ -124,8 +128,10 @@ impl<T: 'static> fmt::Debug for LocalKey<T> {\n /// # fn main() {}\n /// ```\n ///\n-/// See [LocalKey documentation](thread/struct.LocalKey.html) for more\n+/// See [LocalKey documentation][`std::thread::LocalKey`] for more\n /// information.\n+///\n+/// [`std::thread::LocalKey`]: ../std/thread/struct.LocalKey.html\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable]\n@@ -195,11 +201,13 @@ macro_rules! __thread_local_inner {\n #[derive(Debug, Eq, PartialEq, Copy, Clone)]\n pub enum LocalKeyState {\n     /// All keys are in this state whenever a thread starts. Keys will\n-    /// transition to the `Valid` state once the first call to `with` happens\n+    /// transition to the `Valid` state once the first call to [`with`] happens\n     /// and the initialization expression succeeds.\n     ///\n     /// Keys in the `Uninitialized` state will yield a reference to the closure\n-    /// passed to `with` so long as the initialization routine does not panic.\n+    /// passed to [`with`] so long as the initialization routine does not panic.\n+    ///\n+    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n     Uninitialized,\n \n     /// Once a key has been accessed successfully, it will enter the `Valid`\n@@ -208,15 +216,19 @@ pub enum LocalKeyState {\n     /// `Destroyed` state.\n     ///\n     /// Keys in the `Valid` state will be guaranteed to yield a reference to the\n-    /// closure passed to `with`.\n+    /// closure passed to [`with`].\n+    ///\n+    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n     Valid,\n \n     /// When a thread exits, the destructors for keys will be run (if\n     /// necessary). While a destructor is running, and possibly after a\n     /// destructor has run, a key is in the `Destroyed` state.\n     ///\n     /// Keys in the `Destroyed` states will trigger a panic when accessed via\n-    /// `with`.\n+    /// [`with`].\n+    ///\n+    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n     Destroyed,\n }\n \n@@ -283,23 +295,26 @@ impl<T: 'static> LocalKey<T> {\n     /// Query the current state of this key.\n     ///\n     /// A key is initially in the `Uninitialized` state whenever a thread\n-    /// starts. It will remain in this state up until the first call to `with`\n+    /// starts. It will remain in this state up until the first call to [`with`]\n     /// within a thread has run the initialization expression successfully.\n     ///\n     /// Once the initialization expression succeeds, the key transitions to the\n-    /// `Valid` state which will guarantee that future calls to `with` will\n+    /// `Valid` state which will guarantee that future calls to [`with`] will\n     /// succeed within the thread.\n     ///\n     /// When a thread exits, each key will be destroyed in turn, and as keys are\n     /// destroyed they will enter the `Destroyed` state just before the\n     /// destructor starts to run. Keys may remain in the `Destroyed` state after\n     /// destruction has completed. Keys without destructors (e.g. with types\n-    /// that are `Copy`), may never enter the `Destroyed` state.\n+    /// that are [`Copy`]), may never enter the `Destroyed` state.\n     ///\n     /// Keys in the `Uninitialized` state can be accessed so long as the\n     /// initialization does not panic. Keys in the `Valid` state are guaranteed\n     /// to be able to be accessed. Keys in the `Destroyed` state will panic on\n-    /// any call to `with`.\n+    /// any call to [`with`].\n+    ///\n+    /// [`with`]: ../../std/thread/struct.LocalKey.html#method.with\n+    /// [`Copy`]: ../../std/marker/trait.Copy.html\n     #[unstable(feature = \"thread_local_state\",\n                reason = \"state querying was recently added\",\n                issue = \"27716\")]"}, {"sha": "154406a1d8bd78ca29965e9f54f49f4af51fc896", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 61, "deletions": 11, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -180,8 +180,33 @@ pub use self::local::{LocalKey, LocalKeyState};\n // Builder\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// Thread configuration. Provides detailed control over the properties\n-/// and behavior of new threads.\n+/// Thread factory, which can be used in order to configure the properties of\n+/// a new thread.\n+///\n+/// Methods can be chained on it in order to configure it.\n+///\n+/// The two configurations available are:\n+///\n+/// - [`name`]: allows to give a name to the thread which is currently\n+///   only used in `panic` messages.\n+/// - [`stack_size`]: specifies the desired stack size. Note that this can\n+///   be overriden by the OS.\n+///\n+/// If the [`stack_size`] field is not specified, the stack size\n+/// will be the `RUST_MIN_STACK` environment variable. If it is\n+/// not specified either, a sensible default will be set.\n+///\n+/// If the [`name`] field is not specified, the thread will not be named.\n+///\n+/// The [`spawn`] method will take ownership of the builder and create an\n+/// [`io::Result`] to the thread handle with the given configuration.\n+///\n+/// The [`thread::spawn`] free function uses a `Builder` with default\n+/// configuration and [`unwrap`]s its return value.\n+///\n+/// You may want to use [`spawn`] instead of [`thread::spawn`], when you want\n+/// to recover from a failure to launch a thread, indeed the free function will\n+/// panick where the `Builder` method will return a [`io::Result`].\n ///\n /// # Examples\n ///\n@@ -196,6 +221,13 @@ pub use self::local::{LocalKey, LocalKeyState};\n ///\n /// handler.join().unwrap();\n /// ```\n+///\n+/// [`thread::spawn`]: ../../std/thread/fn.spawn.html\n+/// [`stack_size`]: ../../std/thread/struct.Builder.html#method.stack_size\n+/// [`name`]: ../../std/thread/struct.Builder.html#method.name\n+/// [`spawn`]: ../../std/thread/struct.Builder.html#method.spawn\n+/// [`io::Result`]: ../../std/io/type.Result.html\n+/// [`unwrap`]: ../../std/result/enum.Result.html#method.unwrap\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Builder {\n@@ -209,11 +241,6 @@ impl Builder {\n     /// Generates the base configuration for spawning a thread, from which\n     /// configuration methods can be chained.\n     ///\n-    /// If the [`stack_size`] field is not specified, the stack size\n-    /// will be the `RUST_MIN_STACK` environment variable.  If it is\n-    /// not specified either, a sensible default will be set (2MB as\n-    /// of the writting of this doc).\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -229,8 +256,6 @@ impl Builder {\n     ///\n     /// handler.join().unwrap();\n     /// ```\n-    ///\n-    /// [`stack_size`]: ../../std/thread/struct.Builder.html#method.stack_size\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Builder {\n         Builder {\n@@ -280,9 +305,10 @@ impl Builder {\n         self\n     }\n \n-    /// Spawns a new thread, and returns a join handle for it.\n+    /// Spawns a new thread by taking ownership of the `Builder`, and returns an\n+    /// [`io::Result`] to its [`JoinHandle`].\n     ///\n-    /// The child thread may outlive the parent (unless the parent thread\n+    /// The spawned thread may outlive the caller (unless the caller thread\n     /// is the main thread; the whole process is terminated when the main\n     /// thread finishes). The join handle can be used to block on\n     /// termination of the child thread, including recovering its panics.\n@@ -297,6 +323,7 @@ impl Builder {\n     ///\n     /// [`spawn`]: ../../std/thread/fn.spawn.html\n     /// [`io::Result`]: ../../std/io/type.Result.html\n+    /// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n     ///\n     /// # Examples\n     ///\n@@ -468,13 +495,36 @@ pub fn current() -> Thread {\n \n /// Cooperatively gives up a timeslice to the OS scheduler.\n ///\n+/// This is used when the programmer knows that the thread will have nothing\n+/// to do for some time, and thus avoid wasting computing time.\n+///\n+/// For example when polling on a resource, it is common to check that it is\n+/// available, and if not to yield in order to avoid busy waiting.\n+///\n+/// Thus the pattern of `yield`ing after a failed poll is rather common when\n+/// implementing low-level shared resources or synchronization primitives.\n+///\n+/// However programmers will usualy prefer to use, [`channel`]s, [`Condvar`]s,\n+/// [`Mutex`]es or [`join`] for their synchronisation routines, as they avoid\n+/// thinking about thread schedulling.\n+///\n+/// Note that [`channel`]s for example are implemented using this primitive.\n+/// Indeed when you call `send` or `recv`, which are blocking, they will yield\n+/// if the channel is not available.\n+///\n /// # Examples\n ///\n /// ```\n /// use std::thread;\n ///\n /// thread::yield_now();\n /// ```\n+///\n+/// [`channel`]: ../../std/sync/mpsc/index.html\n+/// [`spawn`]: ../../std/thread/fn.spawn.html\n+/// [`join`]: ../../std/thread/struct.JoinHandle.html#method.join\n+/// [`Mutex`]: ../../std/sync/struct.Mutex.html\n+/// [`Condvar`]: ../../std/sync/struct.Condvar.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn yield_now() {\n     imp::Thread::yield_now()"}, {"sha": "24ce99208ed11bc9e89cda6408003e12fa3207d2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -715,7 +715,7 @@ impl Stmt {\n             StmtKind::Mac(mac) => StmtKind::Mac(mac.map(|(mac, _style, attrs)| {\n                 (mac, MacStmtStyle::Semicolon, attrs)\n             })),\n-            node @ _ => node,\n+            node => node,\n         };\n         self\n     }\n@@ -1076,16 +1076,16 @@ impl LitKind {\n     pub fn is_unsuffixed(&self) -> bool {\n         match *self {\n             // unsuffixed variants\n-            LitKind::Str(..) => true,\n-            LitKind::ByteStr(..) => true,\n-            LitKind::Byte(..) => true,\n-            LitKind::Char(..) => true,\n-            LitKind::Int(_, LitIntType::Unsuffixed) => true,\n-            LitKind::FloatUnsuffixed(..) => true,\n+            LitKind::Str(..) |\n+            LitKind::ByteStr(..) |\n+            LitKind::Byte(..) |\n+            LitKind::Char(..) |\n+            LitKind::Int(_, LitIntType::Unsuffixed) |\n+            LitKind::FloatUnsuffixed(..) |\n             LitKind::Bool(..) => true,\n             // suffixed variants\n-            LitKind::Int(_, LitIntType::Signed(..)) => false,\n-            LitKind::Int(_, LitIntType::Unsigned(..)) => false,\n+            LitKind::Int(_, LitIntType::Signed(..)) |\n+            LitKind::Int(_, LitIntType::Unsigned(..)) |\n             LitKind::Float(..) => false,\n         }\n     }"}, {"sha": "45f891d8dc56db911f325fd6ff90b4034066e834", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -112,15 +112,15 @@ impl NestedMetaItem {\n     /// Returns the MetaItem if self is a NestedMetaItemKind::MetaItem.\n     pub fn meta_item(&self) -> Option<&MetaItem> {\n         match self.node {\n-            NestedMetaItemKind::MetaItem(ref item) => Some(&item),\n+            NestedMetaItemKind::MetaItem(ref item) => Some(item),\n             _ => None\n         }\n     }\n \n     /// Returns the Lit if self is a NestedMetaItemKind::Literal.\n     pub fn literal(&self) -> Option<&Lit> {\n         match self.node {\n-            NestedMetaItemKind::Literal(ref lit) => Some(&lit),\n+            NestedMetaItemKind::Literal(ref lit) => Some(lit),\n             _ => None\n         }\n     }\n@@ -259,7 +259,7 @@ impl MetaItem {\n         match self.node {\n             MetaItemKind::NameValue(ref v) => {\n                 match v.node {\n-                    LitKind::Str(ref s, _) => Some((*s).clone()),\n+                    LitKind::Str(ref s, _) => Some(*s),\n                     _ => None,\n                 }\n             },\n@@ -1217,9 +1217,10 @@ impl LitKind {\n                 Token::Literal(token::Lit::Float(symbol), Some(Symbol::intern(ty.ty_to_string())))\n             }\n             LitKind::FloatUnsuffixed(symbol) => Token::Literal(token::Lit::Float(symbol), None),\n-            LitKind::Bool(value) => Token::Ident(Ident::with_empty_ctxt(Symbol::intern(match value {\n-                true => \"true\",\n-                false => \"false\",\n+            LitKind::Bool(value) => Token::Ident(Ident::with_empty_ctxt(Symbol::intern(if value {\n+                \"true\"\n+            } else {\n+                \"false\"\n             }))),\n         }\n     }\n@@ -1261,7 +1262,7 @@ impl<T: HasAttrs> HasAttrs for Spanned<T> {\n \n impl HasAttrs for Vec<Attribute> {\n     fn attrs(&self) -> &[Attribute] {\n-        &self\n+        self\n     }\n     fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n         f(self)\n@@ -1270,7 +1271,7 @@ impl HasAttrs for Vec<Attribute> {\n \n impl HasAttrs for ThinVec<Attribute> {\n     fn attrs(&self) -> &[Attribute] {\n-        &self\n+        self\n     }\n     fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n         f(self.into()).into()"}, {"sha": "d32c3ec5f46b1f063bbcfa26ebea609d7b158178", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -485,7 +485,7 @@ impl CodeMap {\n         match self.span_to_snippet(sp) {\n             Ok(snippet) => {\n                 let snippet = snippet.split(c).nth(0).unwrap_or(\"\").trim_right();\n-                if snippet.len() > 0 && !snippet.contains('\\n') {\n+                if !snippet.is_empty() && !snippet.contains('\\n') {\n                     Span { hi: BytePos(sp.lo.0 + snippet.len() as u32), ..sp }\n                 } else {\n                     sp\n@@ -502,7 +502,7 @@ impl CodeMap {\n     pub fn get_filemap(&self, filename: &str) -> Option<Rc<FileMap>> {\n         for fm in self.files.borrow().iter() {\n             if filename == fm.name {\n-               (self.dep_tracking_callback.borrow())(&fm);\n+               (self.dep_tracking_callback.borrow())(fm);\n                 return Some(fm.clone());\n             }\n         }"}, {"sha": "2e98c7d962606cf524f7cbd718f008f507591b4e", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -123,7 +123,7 @@ impl<'a> StripUnconfigured<'a> {\n                 return false;\n             }\n \n-            let mis = if !is_cfg(&attr) {\n+            let mis = if !is_cfg(attr) {\n                 return true;\n             } else if let Some(mis) = attr.meta_item_list() {\n                 mis\n@@ -150,7 +150,7 @@ impl<'a> StripUnconfigured<'a> {\n         // flag the offending attributes\n         for attr in attrs.iter() {\n             if !self.features.map(|features| features.stmt_expr_attributes).unwrap_or(true) {\n-                let mut err = feature_err(&self.sess,\n+                let mut err = feature_err(self.sess,\n                                           \"stmt_expr_attributes\",\n                                           attr.span,\n                                           GateIssue::Language,\n@@ -258,7 +258,7 @@ impl<'a> StripUnconfigured<'a> {\n     pub fn configure_struct_expr_field(&mut self, field: ast::Field) -> Option<ast::Field> {\n         if !self.features.map(|features| features.struct_field_attributes).unwrap_or(true) {\n             if !field.attrs.is_empty() {\n-                let mut err = feature_err(&self.sess,\n+                let mut err = feature_err(self.sess,\n                                           \"struct_field_attributes\",\n                                           field.span,\n                                           GateIssue::Language,\n@@ -290,7 +290,7 @@ impl<'a> StripUnconfigured<'a> {\n         for attr in attrs.iter() {\n             if !self.features.map(|features| features.struct_field_attributes).unwrap_or(true) {\n                 let mut err = feature_err(\n-                    &self.sess,\n+                    self.sess,\n                     \"struct_field_attributes\",\n                     attr.span,\n                     GateIssue::Language,"}, {"sha": "73aeb40df840064ae0ffd2ea79ee369a9939d498", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -120,7 +120,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n \n         // URLs can be unavoidably longer than the line limit, so we allow them.\n         // Allowed format is: `[name]: https://www.rust-lang.org/`\n-        let is_url = |l: &str| l.starts_with('[') && l.contains(\"]:\") && l.contains(\"http\");\n+        let is_url = |l: &str| l.starts_with(\"[\") && l.contains(\"]:\") && l.contains(\"http\");\n \n         if msg.lines().any(|line| line.len() > MAX_DESCRIPTION_WIDTH && !is_url(line)) {\n             ecx.span_err(span, &format!(\n@@ -177,7 +177,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n             if let Err(e) = output_metadata(ecx,\n                                             &target_triple,\n                                             &crate_name.name.as_str(),\n-                                            &diagnostics) {\n+                                            diagnostics) {\n                 ecx.span_bug(span, &format!(\n                     \"error writing metadata for triple `{}` and crate `{}`, error: {}, \\\n                      cause: {:?}\",\n@@ -227,7 +227,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n \n     MacEager::items(SmallVector::many(vec![\n         P(ast::Item {\n-            ident: name.clone(),\n+            ident: *name,\n             attrs: Vec::new(),\n             id: ast::DUMMY_NODE_ID,\n             node: ast::ItemKind::Const("}, {"sha": "1930f61121bb028113f2dc37d5b037f6ca9f2a47", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -535,7 +535,7 @@ pub enum SyntaxExtension {\n     ///\n     /// The `bool` dictates whether the contents of the macro can\n     /// directly use `#[unstable]` things (true == yes).\n-    NormalTT(Box<TTMacroExpander>, Option<Span>, bool),\n+    NormalTT(Box<TTMacroExpander>, Option<(ast::NodeId, Span)>, bool),\n \n     /// A function-like syntax extension that has an extra ident before\n     /// the block.\n@@ -589,6 +589,7 @@ pub trait Resolver {\n                      -> Result<Option<Rc<SyntaxExtension>>, Determinacy>;\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy>;\n+    fn check_unused_macros(&self);\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -618,6 +619,7 @@ impl Resolver for DummyResolver {\n                      _force: bool) -> Result<Rc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)\n     }\n+    fn check_unused_macros(&self) {}\n }\n \n #[derive(Clone)]\n@@ -635,8 +637,8 @@ pub struct ExpansionData {\n }\n \n /// One of these is made during expansion and incrementally updated as we go;\n-/// when a macro expansion occurs, the resulting nodes have the backtrace()\n-/// -> expn_info of their expansion context stored into their span.\n+/// when a macro expansion occurs, the resulting nodes have the `backtrace()\n+/// -> expn_info` of their expansion context stored into their span.\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub ecfg: expand::ExpansionConfig<'a>,\n@@ -698,7 +700,7 @@ impl<'a> ExtCtxt<'a> {\n     /// Returns span for the macro which originally caused the current expansion to happen.\n     ///\n     /// Stops backtracing at include! boundary.\n-    pub fn expansion_cause(&self) -> Span {\n+    pub fn expansion_cause(&self) -> Option<Span> {\n         let mut ctxt = self.backtrace();\n         let mut last_macro = None;\n         loop {\n@@ -709,12 +711,12 @@ impl<'a> ExtCtxt<'a> {\n                 }\n                 ctxt = info.call_site.ctxt;\n                 last_macro = Some(info.call_site);\n-                return Some(());\n+                Some(())\n             }).is_none() {\n                 break\n             }\n         }\n-        last_macro.expect(\"missing expansion backtrace\")\n+        last_macro\n     }\n \n     pub fn struct_span_warn(&self,\n@@ -770,9 +772,9 @@ impl<'a> ExtCtxt<'a> {\n     }\n     pub fn trace_macros_diag(&self) {\n         for (sp, notes) in self.expansions.iter() {\n-            let mut db = self.parse_sess.span_diagnostic.span_note_diag(*sp, &\"trace_macro\");\n+            let mut db = self.parse_sess.span_diagnostic.span_note_diag(*sp, \"trace_macro\");\n             for note in notes {\n-                db.note(&note);\n+                db.note(note);\n             }\n             db.emit();\n         }\n@@ -795,11 +797,15 @@ impl<'a> ExtCtxt<'a> {\n             v.push(self.ident_of(s));\n         }\n         v.extend(components.iter().map(|s| self.ident_of(s)));\n-        return v\n+        v\n     }\n     pub fn name_of(&self, st: &str) -> ast::Name {\n         Symbol::intern(st)\n     }\n+\n+    pub fn check_unused_macros(&self) {\n+        self.resolver.check_unused_macros();\n+    }\n }\n \n /// Extract a string literal from the macro expanded version of `expr`,"}, {"sha": "25e0aed220ab3fb036e5fb37b890b95bb448d671", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -415,19 +415,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         match *ext {\n             MultiModifier(ref mac) => {\n-                let meta = panictry!(attr.parse_meta(&self.cx.parse_sess));\n+                let meta = panictry!(attr.parse_meta(self.cx.parse_sess));\n                 let item = mac.expand(self.cx, attr.span, &meta, item);\n                 kind.expect_from_annotatables(item)\n             }\n             MultiDecorator(ref mac) => {\n                 let mut items = Vec::new();\n-                let meta = panictry!(attr.parse_meta(&self.cx.parse_sess));\n+                let meta = panictry!(attr.parse_meta(self.cx.parse_sess));\n                 mac.expand(self.cx, attr.span, &meta, &item, &mut |item| items.push(item));\n                 items.push(item);\n                 kind.expect_from_annotatables(items)\n             }\n             SyntaxExtension::AttrProcMacro(ref mac) => {\n-                let item_toks = stream_for_item(&item, &self.cx.parse_sess);\n+                let item_toks = stream_for_item(&item, self.cx.parse_sess);\n \n                 let span = Span { ctxt: self.cx.backtrace(), ..attr.span };\n                 let tok_result = mac.expand(self.cx, attr.span, attr.tokens, item_toks);\n@@ -439,7 +439,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n             _ => {\n                 let msg = &format!(\"macro `{}` may not be used in attributes\", attr.path);\n-                self.cx.span_err(attr.span, &msg);\n+                self.cx.span_err(attr.span, msg);\n                 kind.dummy(attr.span)\n             }\n         }\n@@ -454,7 +454,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n         let path = &mac.node.path;\n \n-        let ident = ident.unwrap_or(keywords::Invalid.ident());\n+        let ident = ident.unwrap_or_else(|| keywords::Invalid.ident());\n         let marked_tts = noop_fold_tts(mac.node.stream(), &mut Marker(mark));\n         let opt_expanded = match *ext {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n@@ -469,7 +469,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     call_site: span,\n                     callee: NameAndSpan {\n                         format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n-                        span: exp_span,\n+                        span: exp_span.map(|(_, s)| s),\n                         allow_internal_unstable: allow_internal_unstable,\n                     },\n                 });\n@@ -591,7 +591,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n             _ => {\n                 let msg = &format!(\"macro `{}` may not be used for derive attributes\", attr.path);\n-                self.cx.span_err(span, &msg);\n+                self.cx.span_err(span, msg);\n                 kind.dummy(span)\n             }\n         }\n@@ -749,19 +749,15 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn check_attributes(&mut self, attrs: &[ast::Attribute]) {\n         let features = self.cx.ecfg.features.unwrap();\n         for attr in attrs.iter() {\n-            feature_gate::check_attribute(&attr, &self.cx.parse_sess, features);\n+            feature_gate::check_attribute(attr, self.cx.parse_sess, features);\n         }\n     }\n }\n \n pub fn find_attr_invoc(attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n-    for i in 0 .. attrs.len() {\n-        if !attr::is_known(&attrs[i]) && !is_builtin_attr(&attrs[i]) {\n-             return Some(attrs.remove(i));\n-        }\n-    }\n-\n-    None\n+    attrs.iter()\n+         .position(|a| !attr::is_known(a) && !is_builtin_attr(a))\n+         .map(|i| attrs.remove(i))\n }\n \n // These are pretty nasty. Ideally, we would keep the tokens around, linked from\n@@ -923,7 +919,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 let result = noop_fold_item(item, self);\n                 self.cx.current_expansion.module = orig_module;\n                 self.cx.current_expansion.directory_ownership = orig_directory_ownership;\n-                return result;\n+                result\n             }\n             // Ensure that test functions are accessible from the test harness.\n             ast::ItemKind::Fn(..) if self.cx.ecfg.should_test => {"}, {"sha": "f8fac847a053ef63c68e00b8ca7bcb7d4c4f2ebd", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 22, "deletions": 38, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -23,7 +23,7 @@ use tokenstream::{TokenStream, TokenTree};\n ///\n /// This is registered as a set of expression syntax extension called quote!\n /// that lifts its argument token-tree to an AST representing the\n-/// construction of the same token tree, with token::SubstNt interpreted\n+/// construction of the same token tree, with `token::SubstNt` interpreted\n /// as antiquotes (splices).\n \n pub mod rt {\n@@ -389,7 +389,7 @@ pub fn unflatten(tts: Vec<TokenTree>) -> Vec<TokenTree> {\n                 result = results.pop().unwrap();\n                 result.push(tree);\n             }\n-            tree @ _ => result.push(tree),\n+            tree => result.push(tree),\n         }\n     }\n     result\n@@ -612,16 +612,20 @@ fn mk_delim(cx: &ExtCtxt, sp: Span, delim: token::DelimToken) -> P<ast::Expr> {\n #[allow(non_upper_case_globals)]\n fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n     macro_rules! mk_lit {\n-        ($name: expr, $suffix: expr, $($args: expr),*) => {{\n-            let inner = cx.expr_call(sp, mk_token_path(cx, sp, $name), vec![$($args),*]);\n+        ($name: expr, $suffix: expr, $content: expr $(, $count: expr)*) => {{\n+            let name = mk_name(cx, sp, ast::Ident::with_empty_ctxt($content));\n+            let inner = cx.expr_call(sp, mk_token_path(cx, sp, $name), vec![\n+                name $(, cx.expr_usize(sp, $count))*\n+            ]);\n             let suffix = match $suffix {\n                 Some(name) => cx.expr_some(sp, mk_name(cx, sp, ast::Ident::with_empty_ctxt(name))),\n                 None => cx.expr_none(sp)\n             };\n             cx.expr_call(sp, mk_token_path(cx, sp, \"Literal\"), vec![inner, suffix])\n         }}\n     }\n-    match *tok {\n+\n+    let name = match *tok {\n         token::BinOp(binop) => {\n             return cx.expr_call(sp, mk_token_path(cx, sp, \"BinOp\"), vec![mk_binop(cx, sp, binop)]);\n         }\n@@ -639,34 +643,14 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n                                 vec![mk_delim(cx, sp, delim)]);\n         }\n \n-        token::Literal(token::Byte(i), suf) => {\n-            let e_byte = mk_name(cx, sp, ast::Ident::with_empty_ctxt(i));\n-            return mk_lit!(\"Byte\", suf, e_byte);\n-        }\n-\n-        token::Literal(token::Char(i), suf) => {\n-            let e_char = mk_name(cx, sp, ast::Ident::with_empty_ctxt(i));\n-            return mk_lit!(\"Char\", suf, e_char);\n-        }\n-\n-        token::Literal(token::Integer(i), suf) => {\n-            let e_int = mk_name(cx, sp, ast::Ident::with_empty_ctxt(i));\n-            return mk_lit!(\"Integer\", suf, e_int);\n-        }\n-\n-        token::Literal(token::Float(fident), suf) => {\n-            let e_fident = mk_name(cx, sp, ast::Ident::with_empty_ctxt(fident));\n-            return mk_lit!(\"Float\", suf, e_fident);\n-        }\n-\n-        token::Literal(token::Str_(ident), suf) => {\n-            return mk_lit!(\"Str_\", suf, mk_name(cx, sp, ast::Ident::with_empty_ctxt(ident)))\n-        }\n-\n-        token::Literal(token::StrRaw(ident, n), suf) => {\n-            return mk_lit!(\"StrRaw\", suf, mk_name(cx, sp, ast::Ident::with_empty_ctxt(ident)),\n-                           cx.expr_usize(sp, n))\n-        }\n+        token::Literal(token::Byte(i), suf) => return mk_lit!(\"Byte\", suf, i),\n+        token::Literal(token::Char(i), suf) => return mk_lit!(\"Char\", suf, i),\n+        token::Literal(token::Integer(i), suf) => return mk_lit!(\"Integer\", suf, i),\n+        token::Literal(token::Float(i), suf) => return mk_lit!(\"Float\", suf, i),\n+        token::Literal(token::Str_(i), suf) => return mk_lit!(\"Str_\", suf, i),\n+        token::Literal(token::StrRaw(i, n), suf) => return mk_lit!(\"StrRaw\", suf, i, n),\n+        token::Literal(token::ByteStr(i), suf) => return mk_lit!(\"ByteStr\", suf, i),\n+        token::Literal(token::ByteStrRaw(i, n), suf) => return mk_lit!(\"ByteStrRaw\", suf, i, n),\n \n         token::Ident(ident) => {\n             return cx.expr_call(sp,\n@@ -688,10 +672,6 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n \n         token::Interpolated(_) => panic!(\"quote! with interpolated token\"),\n \n-        _ => ()\n-    }\n-\n-    let name = match *tok {\n         token::Eq           => \"Eq\",\n         token::Lt           => \"Lt\",\n         token::Le           => \"Le\",\n@@ -706,6 +686,7 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         token::At           => \"At\",\n         token::Dot          => \"Dot\",\n         token::DotDot       => \"DotDot\",\n+        token::DotDotDot    => \"DotDotDot\",\n         token::Comma        => \"Comma\",\n         token::Semi         => \"Semi\",\n         token::Colon        => \"Colon\",\n@@ -718,7 +699,10 @@ fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         token::Question     => \"Question\",\n         token::Underscore   => \"Underscore\",\n         token::Eof          => \"Eof\",\n-        _                   => panic!(\"unhandled token in quote!\"),\n+\n+        token::Whitespace | token::SubstNt(_) | token::Comment | token::Shebang(_) => {\n+            panic!(\"unhandled token in quote!\");\n+        }\n     };\n     mk_token_path(cx, sp, name)\n }"}, {"sha": "3cdd3a4b2c31d8a313c863cde1311e5b1a5c8a17", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -35,7 +35,7 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                    -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n-    let topmost = cx.expansion_cause();\n+    let topmost = cx.expansion_cause().unwrap_or(sp);\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n \n     base::MacEager::expr(cx.expr_u32(topmost, loc.line as u32))\n@@ -46,7 +46,7 @@ pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                   -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"column!\");\n \n-    let topmost = cx.expansion_cause();\n+    let topmost = cx.expansion_cause().unwrap_or(sp);\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n \n     base::MacEager::expr(cx.expr_u32(topmost, loc.col.to_usize() as u32))\n@@ -59,7 +59,7 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                    -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n-    let topmost = cx.expansion_cause();\n+    let topmost = cx.expansion_cause().unwrap_or(sp);\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n     base::MacEager::expr(cx.expr_str(topmost, Symbol::intern(&loc.file.name)))\n }\n@@ -150,7 +150,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n             cx.span_err(sp,\n                         &format!(\"{} wasn't a utf-8 file\",\n                                 file.display()));\n-            return DummyResult::expr(sp);\n+            DummyResult::expr(sp)\n         }\n     }\n }\n@@ -167,7 +167,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n         Err(e) => {\n             cx.span_err(sp,\n                         &format!(\"couldn't read {}: {}\", file.display(), e));\n-            return DummyResult::expr(sp);\n+            DummyResult::expr(sp)\n         }\n         Ok(..) => {\n             // Add this input file to the code map to make it available as"}, {"sha": "bf66aa0f00bed42409ffbdc7ffe8cc3341d2a787", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -36,43 +36,47 @@\n //! repetitions indicated by Kleene stars. It only advances or calls out to the\n //! real Rust parser when no `cur_eis` items remain\n //!\n-//! Example: Start parsing `a a a a b` against [\u00b7 a $( a )* a b].\n+//! Example:\n //!\n-//! Remaining input: `a a a a b`\n+//! ```text, ignore\n+//! Start parsing a a a a b against [\u00b7 a $( a )* a b].\n+//!\n+//! Remaining input: a a a a b\n //! next_eis: [\u00b7 a $( a )* a b]\n //!\n-//! - - - Advance over an `a`. - - -\n+//! - - - Advance over an a. - - -\n //!\n-//! Remaining input: `a a a b`\n+//! Remaining input: a a a b\n //! cur: [a \u00b7 $( a )* a b]\n //! Descend/Skip (first item).\n //! next: [a $( \u00b7 a )* a b]  [a $( a )* \u00b7 a b].\n //!\n-//! - - - Advance over an `a`. - - -\n+//! - - - Advance over an a. - - -\n //!\n-//! Remaining input: `a a b`\n+//! Remaining input: a a b\n //! cur: [a $( a \u00b7 )* a b]  next: [a $( a )* a \u00b7 b]\n //! Finish/Repeat (first item)\n //! next: [a $( a )* \u00b7 a b]  [a $( \u00b7 a )* a b]  [a $( a )* a \u00b7 b]\n //!\n-//! - - - Advance over an `a`. - - - (this looks exactly like the last step)\n+//! - - - Advance over an a. - - - (this looks exactly like the last step)\n //!\n-//! Remaining input: `a b`\n+//! Remaining input: a b\n //! cur: [a $( a \u00b7 )* a b]  next: [a $( a )* a \u00b7 b]\n //! Finish/Repeat (first item)\n //! next: [a $( a )* \u00b7 a b]  [a $( \u00b7 a )* a b]  [a $( a )* a \u00b7 b]\n //!\n-//! - - - Advance over an `a`. - - - (this looks exactly like the last step)\n+//! - - - Advance over an a. - - - (this looks exactly like the last step)\n //!\n-//! Remaining input: `b`\n+//! Remaining input: b\n //! cur: [a $( a \u00b7 )* a b]  next: [a $( a )* a \u00b7 b]\n //! Finish/Repeat (first item)\n //! next: [a $( a )* \u00b7 a b]  [a $( \u00b7 a )* a b]\n //!\n-//! - - - Advance over a `b`. - - -\n+//! - - - Advance over a b. - - -\n //!\n-//! Remaining input: ``\n+//! Remaining input: ''\n //! eof: [a $( a )* a b \u00b7]\n+//! ```\n \n pub use self::NamedMatch::*;\n pub use self::ParseResult::*;\n@@ -178,20 +182,20 @@ fn initial_matcher_pos(ms: Vec<TokenTree>, lo: BytePos) -> Box<MatcherPos> {\n     })\n }\n \n-/// NamedMatch is a pattern-match result for a single token::MATCH_NONTERMINAL:\n+/// `NamedMatch` is a pattern-match result for a single `token::MATCH_NONTERMINAL`:\n /// so it is associated with a single ident in a parse, and all\n-/// `MatchedNonterminal`s in the NamedMatch have the same nonterminal type\n-/// (expr, item, etc). Each leaf in a single NamedMatch corresponds to a\n-/// single token::MATCH_NONTERMINAL in the TokenTree that produced it.\n+/// `MatchedNonterminal`s in the `NamedMatch` have the same nonterminal type\n+/// (expr, item, etc). Each leaf in a single `NamedMatch` corresponds to a\n+/// single `token::MATCH_NONTERMINAL` in the `TokenTree` that produced it.\n ///\n-/// The in-memory structure of a particular NamedMatch represents the match\n+/// The in-memory structure of a particular `NamedMatch` represents the match\n /// that occurred when a particular subset of a matcher was applied to a\n /// particular token tree.\n ///\n-/// The width of each MatchedSeq in the NamedMatch, and the identity of the\n-/// `MatchedNonterminal`s, will depend on the token tree it was applied to:\n-/// each MatchedSeq corresponds to a single TTSeq in the originating\n-/// token tree. The depth of the NamedMatch structure will therefore depend\n+/// The width of each `MatchedSeq` in the `NamedMatch`, and the identity of\n+/// the `MatchedNonterminal`s, will depend on the token tree it was applied\n+/// to: each `MatchedSeq` corresponds to a single `TTSeq` in the originating\n+/// token tree. The depth of the `NamedMatch` structure will therefore depend\n /// only on the nesting depth of `ast::TTSeq`s in the originating\n /// token tree it was derived from.\n \n@@ -267,11 +271,12 @@ pub fn parse_failure_msg(tok: Token) -> String {\n \n /// Perform a token equality check, ignoring syntax context (that is, an unhygienic comparison)\n fn token_name_eq(t1 : &Token, t2 : &Token) -> bool {\n-    match (t1,t2) {\n-        (&token::Ident(id1),&token::Ident(id2))\n-        | (&token::Lifetime(id1),&token::Lifetime(id2)) =>\n-            id1.name == id2.name,\n-        _ => *t1 == *t2\n+    if let (Some(id1), Some(id2)) = (t1.ident(), t2.ident()) {\n+        id1.name == id2.name\n+    } else if let (&token::Lifetime(id1), &token::Lifetime(id2)) = (t1, t2) {\n+        id1.name == id2.name\n+    } else {\n+        *t1 == *t2\n     }\n }\n \n@@ -334,7 +339,7 @@ fn inner_parse_loop(sess: &ParseSess,\n                 // Check if we need a separator\n                 if idx == len && ei.sep.is_some() {\n                     // We have a separator, and it is the current token.\n-                    if ei.sep.as_ref().map(|ref sep| token_name_eq(&token, sep)).unwrap_or(false) {\n+                    if ei.sep.as_ref().map(|sep| token_name_eq(token, sep)).unwrap_or(false) {\n                         ei.idx += 1;\n                         next_eis.push(ei);\n                     }\n@@ -401,7 +406,7 @@ fn inner_parse_loop(sess: &ParseSess,\n                     cur_eis.push(ei);\n                 }\n                 TokenTree::Token(_, ref t) => {\n-                    if token_name_eq(t, &token) {\n+                    if token_name_eq(t, token) {\n                         ei.idx += 1;\n                         next_eis.push(ei);\n                     }\n@@ -485,11 +490,8 @@ pub fn parse(sess: &ParseSess, tts: TokenStream, ms: &[TokenTree], directory: Op\n }\n \n fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n-    match name {\n-        \"tt\" => {\n-            return token::NtTT(p.parse_token_tree());\n-        }\n-        _ => {}\n+    if name == \"tt\" {\n+        return token::NtTT(p.parse_token_tree());\n     }\n     // check at the beginning and the parser checks after each bump\n     p.process_potential_macro_variable();"}, {"sha": "a208f530602a5f0b05677e27c261e29971871e78", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -94,7 +94,7 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n                           -> Box<MacResult+'cx> {\n     if cx.trace_macros() {\n         let sp = sp.macro_backtrace().last().map(|trace| trace.call_site).unwrap_or(sp);\n-        let mut values: &mut Vec<String> = cx.expansions.entry(sp).or_insert(vec![]);\n+        let mut values: &mut Vec<String> = cx.expansions.entry(sp).or_insert_with(Vec::new);\n         values.push(format!(\"expands to `{}! {{ {} }}`\", name, arg));\n     }\n \n@@ -206,7 +206,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n     let mut valid = true;\n \n     // Extract the arguments:\n-    let lhses = match **argument_map.get(&lhs_nm).unwrap() {\n+    let lhses = match *argument_map[&lhs_nm] {\n         MatchedSeq(ref s, _) => {\n             s.iter().map(|m| {\n                 if let MatchedNonterminal(ref nt) = **m {\n@@ -222,7 +222,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n         _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n     };\n \n-    let rhses = match **argument_map.get(&rhs_nm).unwrap() {\n+    let rhses = match *argument_map[&rhs_nm] {\n         MatchedSeq(ref s, _) => {\n             s.iter().map(|m| {\n                 if let MatchedNonterminal(ref nt) = **m {\n@@ -252,21 +252,22 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n         valid: valid,\n     });\n \n-    NormalTT(exp, Some(def.span), attr::contains_name(&def.attrs, \"allow_internal_unstable\"))\n+    NormalTT(exp,\n+             Some((def.id, def.span)),\n+             attr::contains_name(&def.attrs, \"allow_internal_unstable\"))\n }\n \n fn check_lhs_nt_follows(sess: &ParseSess,\n                         features: &RefCell<Features>,\n                         lhs: &quoted::TokenTree) -> bool {\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n-    match lhs {\n-        &quoted::TokenTree::Delimited(_, ref tts) => check_matcher(sess, features, &tts.tts),\n-        _ => {\n-            let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n-            sess.span_diagnostic.span_err(lhs.span(), msg);\n-            false\n-        }\n+    if let quoted::TokenTree::Delimited(_, ref tts) = *lhs {\n+        check_matcher(sess, features, &tts.tts)\n+    } else {\n+        let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n+        sess.span_diagnostic.span_err(lhs.span(), msg);\n+        false\n     }\n     // we don't abort on errors on rejection, the driver will do that for us\n     // after parsing/expansion. we can report every error in every macro this way.\n@@ -283,17 +284,15 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[quoted::TokenTree]) -> bool {\n                 return false;\n             },\n             TokenTree::Sequence(span, ref seq) => {\n-                if seq.separator.is_none() {\n-                    if seq.tts.iter().all(|seq_tt| {\n-                        match *seq_tt {\n-                            TokenTree::Sequence(_, ref sub_seq) =>\n-                                sub_seq.op == quoted::KleeneOp::ZeroOrMore,\n-                            _ => false,\n-                        }\n-                    }) {\n-                        sess.span_diagnostic.span_err(span, \"repetition matches empty token tree\");\n-                        return false;\n+                if seq.separator.is_none() && seq.tts.iter().all(|seq_tt| {\n+                    match *seq_tt {\n+                        TokenTree::Sequence(_, ref sub_seq) =>\n+                            sub_seq.op == quoted::KleeneOp::ZeroOrMore,\n+                        _ => false,\n                     }\n+                }) {\n+                    sess.span_diagnostic.span_err(span, \"repetition matches empty token tree\");\n+                    return false;\n                 }\n                 if !check_lhs_no_empty_seq(sess, &seq.tts) {\n                     return false;\n@@ -407,7 +406,7 @@ impl FirstSets {\n                 }\n             }\n \n-            return first;\n+            first\n         }\n     }\n \n@@ -469,7 +468,7 @@ impl FirstSets {\n         // we only exit the loop if `tts` was empty or if every\n         // element of `tts` matches the empty sequence.\n         assert!(first.maybe_empty);\n-        return first;\n+        first\n     }\n }\n \n@@ -579,7 +578,7 @@ fn check_matcher_core(sess: &ParseSess,\n         let build_suffix_first = || {\n             let mut s = first_sets.first(suffix);\n             if s.maybe_empty { s.add_all(follow); }\n-            return s;\n+            s\n         };\n \n         // (we build `suffix_first` on demand below; you can tell\n@@ -861,6 +860,7 @@ fn quoted_tt_to_string(tt: &quoted::TokenTree) -> String {\n     match *tt {\n         quoted::TokenTree::Token(_, ref tok) => ::print::pprust::token_to_string(tok),\n         quoted::TokenTree::MetaVarDecl(_, name, kind) => format!(\"${}:{}\", name, kind),\n-        _ => panic!(\"unexpected quoted::TokenTree::{Sequence or Delimited} in follow set checker\"),\n+        _ => panic!(\"unexpected quoted::TokenTree::{{Sequence or Delimited}} \\\n+                     in follow set checker\"),\n     }\n }"}, {"sha": "fa65e9501c2bb793aa34c64956aaff717bb4227d", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -96,6 +96,17 @@ impl TokenTree {\n         }\n     }\n \n+    pub fn is_empty(&self) -> bool {\n+        match *self {\n+            TokenTree::Delimited(_, ref delimed) => match delimed.delim {\n+                token::NoDelim => delimed.tts.is_empty(),\n+                _ => false,\n+            },\n+            TokenTree::Sequence(_, ref seq) => seq.tts.is_empty(),\n+            _ => true,\n+        }\n+    }\n+\n     pub fn get_tt(&self, index: usize) -> TokenTree {\n         match (self, index) {\n             (&TokenTree::Delimited(_, ref delimed), _) if delimed.delim == token::NoDelim => {\n@@ -144,9 +155,9 @@ pub fn parse(input: tokenstream::TokenStream, expect_matchers: bool, sess: &Pars\n                             }\n                             _ => end_sp,\n                         },\n-                        tree @ _ => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(span),\n+                        tree => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(span),\n                     },\n-                    tree @ _ => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(start_sp),\n+                    tree => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(start_sp),\n                 };\n                 sess.missing_fragment_specifiers.borrow_mut().insert(span);\n                 result.push(TokenTree::MetaVarDecl(span, ident, keywords::Invalid.ident()));\n@@ -228,10 +239,10 @@ fn parse_sep_and_kleene_op<I>(input: &mut I, span: Span, sess: &ParseSess)\n                     Some(op) => return (Some(tok), op),\n                     None => span,\n                 },\n-                tree @ _ => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(span),\n+                tree => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(span),\n             }\n         },\n-        tree @ _ => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(span),\n+        tree => tree.as_ref().map(tokenstream::TokenTree::span).unwrap_or(span),\n     };\n \n     sess.span_diagnostic.span_err(span, \"expected `*` or `+`\");"}, {"sha": "2a435bdea107f2d11d2bf22a0f20005dc0f589aa", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -121,20 +121,20 @@ pub fn transcribe(sp_diag: &Handler,\n                                          &repeats) {\n                     LockstepIterSize::Unconstrained => {\n                         panic!(sp_diag.span_fatal(\n-                            sp.clone(), /* blame macro writer */\n+                            sp, /* blame macro writer */\n                             \"attempted to repeat an expression \\\n                              containing no syntax \\\n                              variables matched as repeating at this depth\"));\n                     }\n                     LockstepIterSize::Contradiction(ref msg) => {\n                         // FIXME #2887 blame macro invoker instead\n-                        panic!(sp_diag.span_fatal(sp.clone(), &msg[..]));\n+                        panic!(sp_diag.span_fatal(sp, &msg[..]));\n                     }\n                     LockstepIterSize::Constraint(len, _) => {\n                         if len == 0 {\n                             if seq.op == quoted::KleeneOp::OneOrMore {\n                                 // FIXME #2887 blame invoker\n-                                panic!(sp_diag.span_fatal(sp.clone(),\n+                                panic!(sp_diag.span_fatal(sp,\n                                                           \"this must repeat at least once\"));\n                             }\n                         } else {"}, {"sha": "09090ab87313087ac393082c21f6f95a0c335a83", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -472,7 +472,7 @@ pub enum Stability {\n impl ::std::fmt::Debug for AttributeGate {\n     fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n         match *self {\n-            Gated(ref stab, ref name, ref expl, _) =>\n+            Gated(ref stab, name, expl, _) =>\n                 write!(fmt, \"Gated({:?}, {}, {})\", stab, name, expl),\n             Ungated => write!(fmt, \"Ungated\")\n         }\n@@ -816,7 +816,7 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n ];\n \n // cfg(...)'s that are feature gated\n-const GATED_CFGS: &'static [(&'static str, &'static str, fn(&Features) -> bool)] = &[\n+const GATED_CFGS: &[(&str, &str, fn(&Features) -> bool)] = &[\n     // (name in cfg, feature, function to check if the feature is enabled)\n     (\"target_feature\", \"cfg_target_feature\", cfg_fn!(cfg_target_feature)),\n     (\"target_vendor\", \"cfg_target_vendor\", cfg_fn!(cfg_target_vendor)),\n@@ -881,7 +881,7 @@ impl<'a> Context<'a> {\n         let name = unwrap_or!(attr.name(), return).as_str();\n         for &(n, ty, ref gateage) in BUILTIN_ATTRIBUTES {\n             if name == n {\n-                if let &Gated(_, ref name, ref desc, ref has_feature) = gateage {\n+                if let Gated(_, name, desc, ref has_feature) = *gateage {\n                     gate_feature_fn!(self, has_feature, attr.span, name, desc);\n                 }\n                 debug!(\"check_attribute: {:?} is builtin, {:?}, {:?}\", attr.path, ty, gateage);\n@@ -1098,7 +1098,7 @@ fn contains_novel_literal(item: &ast::MetaItem) -> bool {\n         NameValue(ref lit) => !lit.node.is_str(),\n         List(ref list) => list.iter().any(|li| {\n             match li.node {\n-                MetaItem(ref mi) => contains_novel_literal(&mi),\n+                MetaItem(ref mi) => contains_novel_literal(mi),\n                 Literal(_) => true,\n             }\n         }),\n@@ -1120,7 +1120,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             return\n         }\n \n-        let meta = panictry!(attr.parse_meta(&self.context.parse_sess));\n+        let meta = panictry!(attr.parse_meta(self.context.parse_sess));\n         if contains_novel_literal(&meta) {\n             gate_feature_post!(&self, attr_literals, attr.span,\n                                \"non-string literals in attributes, or string \\\n@@ -1216,14 +1216,11 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Impl(_, polarity, defaultness, _, _, _, _) => {\n-                match polarity {\n-                    ast::ImplPolarity::Negative => {\n-                        gate_feature_post!(&self, optin_builtin_traits,\n-                                           i.span,\n-                                           \"negative trait bounds are not yet fully implemented; \\\n-                                            use marker types for now\");\n-                    },\n-                    _ => {}\n+                if polarity == ast::ImplPolarity::Negative {\n+                    gate_feature_post!(&self, optin_builtin_traits,\n+                                       i.span,\n+                                       \"negative trait bounds are not yet fully implemented; \\\n+                                        use marker types for now\");\n                 }\n \n                 if let ast::Defaultness::Default = defaultness {\n@@ -1272,11 +1269,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n     fn visit_fn_ret_ty(&mut self, ret_ty: &'a ast::FunctionRetTy) {\n         if let ast::FunctionRetTy::Ty(ref output_ty) = *ret_ty {\n-            match output_ty.node {\n-                ast::TyKind::Never => return,\n-                _ => (),\n-            };\n-            self.visit_ty(output_ty)\n+            if output_ty.node != ast::TyKind::Never {\n+                self.visit_ty(output_ty)\n+            }\n         }\n     }\n \n@@ -1373,17 +1368,14 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 span: Span,\n                 _node_id: NodeId) {\n         // check for const fn declarations\n-        match fn_kind {\n-            FnKind::ItemFn(_, _, _, Spanned { node: ast::Constness::Const, .. }, _, _, _) => {\n-                gate_feature_post!(&self, const_fn, span, \"const fn is unstable\");\n-            }\n-            _ => {\n-                // stability of const fn methods are covered in\n-                // visit_trait_item and visit_impl_item below; this is\n-                // because default methods don't pass through this\n-                // point.\n-            }\n+        if let FnKind::ItemFn(_, _, _, Spanned { node: ast::Constness::Const, .. }, _, _, _) =\n+            fn_kind {\n+            gate_feature_post!(&self, const_fn, span, \"const fn is unstable\");\n         }\n+        // stability of const fn methods are covered in\n+        // visit_trait_item and visit_impl_item below; this is\n+        // because default methods don't pass through this\n+        // point.\n \n         match fn_kind {\n             FnKind::ItemFn(_, _, _, _, abi, _, _) |"}, {"sha": "f37dcfdde8985f7594b3381e8e7cf4e57a2a889f", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -337,7 +337,7 @@ impl DiagnosticSpanLine {\n                       })\n                      .collect()\n              })\n-            .unwrap_or(vec![])\n+            .unwrap_or_else(|_| vec![])\n     }\n }\n "}, {"sha": "082930777e598cfe4a9392e1dd7e18106ff648fa", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -62,7 +62,7 @@ impl<'a> Parser<'a> {\n                 _ => break,\n             }\n         }\n-        return Ok(attrs);\n+        Ok(attrs)\n     }\n \n     /// Matches `attribute = # ! [ meta_item ]`\n@@ -182,7 +182,7 @@ impl<'a> Parser<'a> {\n                     }\n \n                     let attr = self.parse_attribute(true)?;\n-                    assert!(attr.style == ast::AttrStyle::Inner);\n+                    assert_eq!(attr.style, ast::AttrStyle::Inner);\n                     attrs.push(attr);\n                 }\n                 token::DocComment(s) => {"}, {"sha": "0c6f09ba7666cb0ed6b5896194c75794f1f2d5d1", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -43,14 +43,14 @@ pub fn expr_is_simple_block(e: &ast::Expr) -> bool {\n }\n \n /// this statement requires a semicolon after it.\n-/// note that in one case (stmt_semi), we've already\n+/// note that in one case (`stmt_semi`), we've already\n /// seen the semicolon, and thus don't need another.\n pub fn stmt_ends_with_semi(stmt: &ast::StmtKind) -> bool {\n     match *stmt {\n         ast::StmtKind::Local(_) => true,\n-        ast::StmtKind::Item(_) => false,\n         ast::StmtKind::Expr(ref e) => expr_requires_semi_to_be_stmt(e),\n-        ast::StmtKind::Semi(..) => false,\n+        ast::StmtKind::Item(_) |\n+        ast::StmtKind::Semi(..) |\n         ast::StmtKind::Mac(..) => false,\n     }\n }"}, {"sha": "fe931f7cf6a645f4025baea781dc4e5a89ac2460", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -12,7 +12,7 @@\n \n use parse::token;\n \n-/// SeqSep : a sequence separator (token)\n+/// `SeqSep` : a sequence separator (token)\n /// and whether a trailing separator is allowed.\n pub struct SeqSep {\n     pub sep: Option<token::Token>,"}, {"sha": "8b545d3b909e823c472a1224219a723ce53731cf", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -77,7 +77,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         while j > i && lines[j - 1].trim().is_empty() {\n             j -= 1;\n         }\n-        lines[i..j].iter().cloned().collect()\n+        lines[i..j].to_vec()\n     }\n \n     /// remove a \"[ \\t]*\\*\" block from each line, if possible"}, {"sha": "0bcd457851890c6db66ecbae0d988c990cbf3865", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -144,7 +144,7 @@ impl<'a> StringReader<'a> {\n \n impl<'a> StringReader<'a> {\n     /// For comments.rs, which hackily pokes into next_pos and ch\n-    pub fn new_raw<'b>(sess: &'a ParseSess, filemap: Rc<syntax_pos::FileMap>) -> Self {\n+    pub fn new_raw(sess: &'a ParseSess, filemap: Rc<syntax_pos::FileMap>) -> Self {\n         let mut sr = StringReader::new_raw_internal(sess, filemap);\n         sr.bump();\n         sr\n@@ -180,7 +180,7 @@ impl<'a> StringReader<'a> {\n \n     pub fn new(sess: &'a ParseSess, filemap: Rc<syntax_pos::FileMap>) -> Self {\n         let mut sr = StringReader::new_raw(sess, filemap);\n-        if let Err(_) = sr.advance_token() {\n+        if sr.advance_token().is_err() {\n             sr.emit_fatal_errors();\n             panic!(FatalError);\n         }\n@@ -205,7 +205,7 @@ impl<'a> StringReader<'a> {\n \n         sr.bump();\n \n-        if let Err(_) = sr.advance_token() {\n+        if sr.advance_token().is_err() {\n             sr.emit_fatal_errors();\n             panic!(FatalError);\n         }\n@@ -525,7 +525,7 @@ impl<'a> StringReader<'a> {\n                         self.bump();\n                     }\n \n-                    return if doc_comment {\n+                    if doc_comment {\n                         self.with_str_from(start_bpos, |string| {\n                             // comments with only more \"/\"s are not doc comments\n                             let tok = if is_doc_comment(string) {\n@@ -544,7 +544,7 @@ impl<'a> StringReader<'a> {\n                             tok: token::Comment,\n                             sp: mk_sp(start_bpos, self.pos),\n                         })\n-                    };\n+                    }\n                 }\n                 Some('*') => {\n                     self.bump();\n@@ -764,7 +764,7 @@ impl<'a> StringReader<'a> {\n             }\n             let pos = self.pos;\n             self.check_float_base(start_bpos, pos, base);\n-            return token::Float(self.name_from(start_bpos));\n+            token::Float(self.name_from(start_bpos))\n         } else {\n             // it might be a float if it has an exponent\n             if self.ch_is('e') || self.ch_is('E') {\n@@ -774,7 +774,7 @@ impl<'a> StringReader<'a> {\n                 return token::Float(self.name_from(start_bpos));\n             }\n             // but we certainly have an integer!\n-            return token::Integer(self.name_from(start_bpos));\n+            token::Integer(self.name_from(start_bpos))\n         }\n     }\n \n@@ -1051,9 +1051,9 @@ impl<'a> StringReader<'a> {\n         self.bump();\n         if self.ch_is('=') {\n             self.bump();\n-            return token::BinOpEq(op);\n+            token::BinOpEq(op)\n         } else {\n-            return token::BinOp(op);\n+            token::BinOp(op)\n         }\n     }\n \n@@ -1100,15 +1100,15 @@ impl<'a> StringReader<'a> {\n             // One-byte tokens.\n             ';' => {\n                 self.bump();\n-                return Ok(token::Semi);\n+                Ok(token::Semi)\n             }\n             ',' => {\n                 self.bump();\n-                return Ok(token::Comma);\n+                Ok(token::Comma)\n             }\n             '.' => {\n                 self.bump();\n-                return if self.ch_is('.') {\n+                if self.ch_is('.') {\n                     self.bump();\n                     if self.ch_is('.') {\n                         self.bump();\n@@ -1118,105 +1118,105 @@ impl<'a> StringReader<'a> {\n                     }\n                 } else {\n                     Ok(token::Dot)\n-                };\n+                }\n             }\n             '(' => {\n                 self.bump();\n-                return Ok(token::OpenDelim(token::Paren));\n+                Ok(token::OpenDelim(token::Paren))\n             }\n             ')' => {\n                 self.bump();\n-                return Ok(token::CloseDelim(token::Paren));\n+                Ok(token::CloseDelim(token::Paren))\n             }\n             '{' => {\n                 self.bump();\n-                return Ok(token::OpenDelim(token::Brace));\n+                Ok(token::OpenDelim(token::Brace))\n             }\n             '}' => {\n                 self.bump();\n-                return Ok(token::CloseDelim(token::Brace));\n+                Ok(token::CloseDelim(token::Brace))\n             }\n             '[' => {\n                 self.bump();\n-                return Ok(token::OpenDelim(token::Bracket));\n+                Ok(token::OpenDelim(token::Bracket))\n             }\n             ']' => {\n                 self.bump();\n-                return Ok(token::CloseDelim(token::Bracket));\n+                Ok(token::CloseDelim(token::Bracket))\n             }\n             '@' => {\n                 self.bump();\n-                return Ok(token::At);\n+                Ok(token::At)\n             }\n             '#' => {\n                 self.bump();\n-                return Ok(token::Pound);\n+                Ok(token::Pound)\n             }\n             '~' => {\n                 self.bump();\n-                return Ok(token::Tilde);\n+                Ok(token::Tilde)\n             }\n             '?' => {\n                 self.bump();\n-                return Ok(token::Question);\n+                Ok(token::Question)\n             }\n             ':' => {\n                 self.bump();\n                 if self.ch_is(':') {\n                     self.bump();\n-                    return Ok(token::ModSep);\n+                    Ok(token::ModSep)\n                 } else {\n-                    return Ok(token::Colon);\n+                    Ok(token::Colon)\n                 }\n             }\n \n             '$' => {\n                 self.bump();\n-                return Ok(token::Dollar);\n+                Ok(token::Dollar)\n             }\n \n             // Multi-byte tokens.\n             '=' => {\n                 self.bump();\n                 if self.ch_is('=') {\n                     self.bump();\n-                    return Ok(token::EqEq);\n+                    Ok(token::EqEq)\n                 } else if self.ch_is('>') {\n                     self.bump();\n-                    return Ok(token::FatArrow);\n+                    Ok(token::FatArrow)\n                 } else {\n-                    return Ok(token::Eq);\n+                    Ok(token::Eq)\n                 }\n             }\n             '!' => {\n                 self.bump();\n                 if self.ch_is('=') {\n                     self.bump();\n-                    return Ok(token::Ne);\n+                    Ok(token::Ne)\n                 } else {\n-                    return Ok(token::Not);\n+                    Ok(token::Not)\n                 }\n             }\n             '<' => {\n                 self.bump();\n                 match self.ch.unwrap_or('\\x00') {\n                     '=' => {\n                         self.bump();\n-                        return Ok(token::Le);\n+                        Ok(token::Le)\n                     }\n                     '<' => {\n-                        return Ok(self.binop(token::Shl));\n+                        Ok(self.binop(token::Shl))\n                     }\n                     '-' => {\n                         self.bump();\n                         match self.ch.unwrap_or('\\x00') {\n                             _ => {\n-                                return Ok(token::LArrow);\n+                                Ok(token::LArrow)\n                             }\n                         }\n                     }\n                     _ => {\n-                        return Ok(token::Lt);\n+                        Ok(token::Lt)\n                     }\n                 }\n             }\n@@ -1225,13 +1225,13 @@ impl<'a> StringReader<'a> {\n                 match self.ch.unwrap_or('\\x00') {\n                     '=' => {\n                         self.bump();\n-                        return Ok(token::Ge);\n+                        Ok(token::Ge)\n                     }\n                     '>' => {\n-                        return Ok(self.binop(token::Shr));\n+                        Ok(self.binop(token::Shr))\n                     }\n                     _ => {\n-                        return Ok(token::Gt);\n+                        Ok(token::Gt)\n                     }\n                 }\n             }\n@@ -1301,7 +1301,7 @@ impl<'a> StringReader<'a> {\n                 };\n                 self.bump(); // advance ch past token\n                 let suffix = self.scan_optional_raw_name();\n-                return Ok(token::Literal(token::Char(id), suffix));\n+                Ok(token::Literal(token::Char(id), suffix))\n             }\n             'b' => {\n                 self.bump();\n@@ -1312,7 +1312,7 @@ impl<'a> StringReader<'a> {\n                     _ => unreachable!(),  // Should have been a token::Ident above.\n                 };\n                 let suffix = self.scan_optional_raw_name();\n-                return Ok(token::Literal(lit, suffix));\n+                Ok(token::Literal(lit, suffix))\n             }\n             '\"' => {\n                 let start_bpos = self.pos;\n@@ -1343,7 +1343,7 @@ impl<'a> StringReader<'a> {\n                 };\n                 self.bump();\n                 let suffix = self.scan_optional_raw_name();\n-                return Ok(token::Literal(token::Str_(id), suffix));\n+                Ok(token::Literal(token::Str_(id), suffix))\n             }\n             'r' => {\n                 let start_bpos = self.pos;\n@@ -1414,52 +1414,52 @@ impl<'a> StringReader<'a> {\n                     Symbol::intern(\"??\")\n                 };\n                 let suffix = self.scan_optional_raw_name();\n-                return Ok(token::Literal(token::StrRaw(id, hash_count), suffix));\n+                Ok(token::Literal(token::StrRaw(id, hash_count), suffix))\n             }\n             '-' => {\n                 if self.nextch_is('>') {\n                     self.bump();\n                     self.bump();\n-                    return Ok(token::RArrow);\n+                    Ok(token::RArrow)\n                 } else {\n-                    return Ok(self.binop(token::Minus));\n+                    Ok(self.binop(token::Minus))\n                 }\n             }\n             '&' => {\n                 if self.nextch_is('&') {\n                     self.bump();\n                     self.bump();\n-                    return Ok(token::AndAnd);\n+                    Ok(token::AndAnd)\n                 } else {\n-                    return Ok(self.binop(token::And));\n+                    Ok(self.binop(token::And))\n                 }\n             }\n             '|' => {\n                 match self.nextch() {\n                     Some('|') => {\n                         self.bump();\n                         self.bump();\n-                        return Ok(token::OrOr);\n+                        Ok(token::OrOr)\n                     }\n                     _ => {\n-                        return Ok(self.binop(token::Or));\n+                        Ok(self.binop(token::Or))\n                     }\n                 }\n             }\n             '+' => {\n-                return Ok(self.binop(token::Plus));\n+                Ok(self.binop(token::Plus))\n             }\n             '*' => {\n-                return Ok(self.binop(token::Star));\n+                Ok(self.binop(token::Star))\n             }\n             '/' => {\n-                return Ok(self.binop(token::Slash));\n+                Ok(self.binop(token::Slash))\n             }\n             '^' => {\n-                return Ok(self.binop(token::Caret));\n+                Ok(self.binop(token::Caret))\n             }\n             '%' => {\n-                return Ok(self.binop(token::Percent));\n+                Ok(self.binop(token::Percent))\n             }\n             c => {\n                 let last_bpos = self.pos;\n@@ -1468,7 +1468,7 @@ impl<'a> StringReader<'a> {\n                                                           bpos,\n                                                           \"unknown start of token\",\n                                                           c);\n-                unicode_chars::check_for_substitution(&self, c, &mut err);\n+                unicode_chars::check_for_substitution(self, c, &mut err);\n                 self.fatal_errs.push(err);\n                 Err(())\n             }\n@@ -1490,14 +1490,14 @@ impl<'a> StringReader<'a> {\n         if self.ch_is('\\n') {\n             self.bump();\n         }\n-        return val;\n+        val\n     }\n \n     fn read_one_line_comment(&mut self) -> String {\n         let val = self.read_to_eol();\n         assert!((val.as_bytes()[0] == b'/' && val.as_bytes()[1] == b'/') ||\n                 (val.as_bytes()[0] == b'#' && val.as_bytes()[1] == b'!'));\n-        return val;\n+        val\n     }\n \n     fn consume_non_eol_whitespace(&mut self) {\n@@ -1541,7 +1541,7 @@ impl<'a> StringReader<'a> {\n             Symbol::intern(\"?\")\n         };\n         self.bump(); // advance ch past token\n-        return token::Byte(id);\n+        token::Byte(id)\n     }\n \n     fn scan_byte_escape(&mut self, delim: char, below_0x7f_only: bool) -> bool {\n@@ -1574,7 +1574,7 @@ impl<'a> StringReader<'a> {\n             Symbol::intern(\"??\")\n         };\n         self.bump();\n-        return token::ByteStr(id);\n+        token::ByteStr(id)\n     }\n \n     fn scan_raw_byte_string(&mut self) -> token::Lit {\n@@ -1627,8 +1627,8 @@ impl<'a> StringReader<'a> {\n             self.bump();\n         }\n         self.bump();\n-        return token::ByteStrRaw(self.name_from_to(content_start_bpos, content_end_bpos),\n-                                 hash_count);\n+        token::ByteStrRaw(self.name_from_to(content_start_bpos, content_end_bpos),\n+                                 hash_count)\n     }\n }\n \n@@ -1646,7 +1646,7 @@ fn in_range(c: Option<char>, lo: char, hi: char) -> bool {\n }\n \n fn is_dec_digit(c: Option<char>) -> bool {\n-    return in_range(c, '0', '9');\n+    in_range(c, '0', '9')\n }\n \n pub fn is_doc_comment(s: &str) -> bool {"}, {"sha": "1eff819d755493f33f713b6281100591bab78413", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 68, "deletions": 79, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -107,48 +107,48 @@ pub fn parse_crate_attrs_from_file<'a>(input: &Path, sess: &'a ParseSess)\n     parser.parse_inner_attributes()\n }\n \n-pub fn parse_crate_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n-                                       -> PResult<'a, ast::Crate> {\n+pub fn parse_crate_from_source_str(name: String, source: String, sess: &ParseSess)\n+                                       -> PResult<ast::Crate> {\n     new_parser_from_source_str(sess, name, source).parse_crate_mod()\n }\n \n-pub fn parse_crate_attrs_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n-                                             -> PResult<'a, Vec<ast::Attribute>> {\n+pub fn parse_crate_attrs_from_source_str(name: String, source: String, sess: &ParseSess)\n+                                             -> PResult<Vec<ast::Attribute>> {\n     new_parser_from_source_str(sess, name, source).parse_inner_attributes()\n }\n \n-pub fn parse_expr_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n-                                      -> PResult<'a, P<ast::Expr>> {\n+pub fn parse_expr_from_source_str(name: String, source: String, sess: &ParseSess)\n+                                      -> PResult<P<ast::Expr>> {\n     new_parser_from_source_str(sess, name, source).parse_expr()\n }\n \n /// Parses an item.\n ///\n /// Returns `Ok(Some(item))` when successful, `Ok(None)` when no item was found, and`Err`\n /// when a syntax error occurred.\n-pub fn parse_item_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n-                                      -> PResult<'a, Option<P<ast::Item>>> {\n+pub fn parse_item_from_source_str(name: String, source: String, sess: &ParseSess)\n+                                      -> PResult<Option<P<ast::Item>>> {\n     new_parser_from_source_str(sess, name, source).parse_item()\n }\n \n-pub fn parse_meta_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n-                                      -> PResult<'a, ast::MetaItem> {\n+pub fn parse_meta_from_source_str(name: String, source: String, sess: &ParseSess)\n+                                      -> PResult<ast::MetaItem> {\n     new_parser_from_source_str(sess, name, source).parse_meta_item()\n }\n \n-pub fn parse_stmt_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n-                                      -> PResult<'a, Option<ast::Stmt>> {\n+pub fn parse_stmt_from_source_str(name: String, source: String, sess: &ParseSess)\n+                                      -> PResult<Option<ast::Stmt>> {\n     new_parser_from_source_str(sess, name, source).parse_stmt()\n }\n \n-pub fn parse_stream_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n+pub fn parse_stream_from_source_str(name: String, source: String, sess: &ParseSess)\n                                         -> TokenStream {\n     filemap_to_stream(sess, sess.codemap().new_filemap(name, source))\n }\n \n // Create a new parser from a source string\n-pub fn new_parser_from_source_str<'a>(sess: &'a ParseSess, name: String, source: String)\n-                                      -> Parser<'a> {\n+pub fn new_parser_from_source_str(sess: &ParseSess, name: String, source: String)\n+                                      -> Parser {\n     filemap_to_parser(sess, sess.codemap().new_filemap(name, source))\n }\n \n@@ -173,7 +173,7 @@ pub fn new_sub_parser_from_file<'a>(sess: &'a ParseSess,\n }\n \n /// Given a filemap and config, return a parser\n-pub fn filemap_to_parser<'a>(sess: &'a ParseSess, filemap: Rc<FileMap>, ) -> Parser<'a> {\n+pub fn filemap_to_parser(sess: & ParseSess, filemap: Rc<FileMap>, ) -> Parser {\n     let end_pos = filemap.end_pos;\n     let mut parser = stream_to_parser(sess, filemap_to_stream(sess, filemap));\n \n@@ -186,7 +186,7 @@ pub fn filemap_to_parser<'a>(sess: &'a ParseSess, filemap: Rc<FileMap>, ) -> Par\n \n // must preserve old name for now, because quote! from the *existing*\n // compiler expands into it\n-pub fn new_parser_from_tts<'a>(sess: &'a ParseSess, tts: Vec<TokenTree>) -> Parser<'a> {\n+pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser {\n     stream_to_parser(sess, tts.into_iter().collect())\n }\n \n@@ -216,8 +216,8 @@ pub fn filemap_to_stream(sess: &ParseSess, filemap: Rc<FileMap>) -> TokenStream\n     panictry!(srdr.parse_all_token_trees())\n }\n \n-/// Given stream and the ParseSess, produce a parser\n-pub fn stream_to_parser<'a>(sess: &'a ParseSess, stream: TokenStream) -> Parser<'a> {\n+/// Given stream and the `ParseSess`, produce a parser\n+pub fn stream_to_parser(sess: &ParseSess, stream: TokenStream) -> Parser {\n     Parser::new(sess, stream, None, false)\n }\n \n@@ -251,7 +251,7 @@ pub fn char_lit(lit: &str) -> (char, isize) {\n             (c, 4)\n         }\n         'u' => {\n-            assert!(lit.as_bytes()[2] == b'{');\n+            assert_eq!(lit.as_bytes()[2], b'{');\n             let idx = lit.find('}').unwrap();\n             let v = u32::from_str_radix(&lit[3..idx], 16).unwrap();\n             let c = char::from_u32(v).unwrap();\n@@ -287,51 +287,46 @@ pub fn str_lit(lit: &str) -> String {\n     }\n \n     let mut chars = lit.char_indices().peekable();\n-    loop {\n-        match chars.next() {\n-            Some((i, c)) => {\n-                match c {\n-                    '\\\\' => {\n-                        let ch = chars.peek().unwrap_or_else(|| {\n-                            panic!(\"{}\", error(i))\n-                        }).1;\n-\n-                        if ch == '\\n' {\n-                            eat(&mut chars);\n-                        } else if ch == '\\r' {\n-                            chars.next();\n-                            let ch = chars.peek().unwrap_or_else(|| {\n-                                panic!(\"{}\", error(i))\n-                            }).1;\n-\n-                            if ch != '\\n' {\n-                                panic!(\"lexer accepted bare CR\");\n-                            }\n-                            eat(&mut chars);\n-                        } else {\n-                            // otherwise, a normal escape\n-                            let (c, n) = char_lit(&lit[i..]);\n-                            for _ in 0..n - 1 { // we don't need to move past the first \\\n-                                chars.next();\n-                            }\n-                            res.push(c);\n-                        }\n-                    },\n-                    '\\r' => {\n-                        let ch = chars.peek().unwrap_or_else(|| {\n-                            panic!(\"{}\", error(i))\n-                        }).1;\n+    while let Some((i, c)) = chars.next() {\n+        match c {\n+            '\\\\' => {\n+                let ch = chars.peek().unwrap_or_else(|| {\n+                    panic!(\"{}\", error(i))\n+                }).1;\n+\n+                if ch == '\\n' {\n+                    eat(&mut chars);\n+                } else if ch == '\\r' {\n+                    chars.next();\n+                    let ch = chars.peek().unwrap_or_else(|| {\n+                        panic!(\"{}\", error(i))\n+                    }).1;\n \n-                        if ch != '\\n' {\n-                            panic!(\"lexer accepted bare CR\");\n-                        }\n+                    if ch != '\\n' {\n+                        panic!(\"lexer accepted bare CR\");\n+                    }\n+                    eat(&mut chars);\n+                } else {\n+                    // otherwise, a normal escape\n+                    let (c, n) = char_lit(&lit[i..]);\n+                    for _ in 0..n - 1 { // we don't need to move past the first \\\n                         chars.next();\n-                        res.push('\\n');\n                     }\n-                    c => res.push(c),\n+                    res.push(c);\n                 }\n             },\n-            None => break\n+            '\\r' => {\n+                let ch = chars.peek().unwrap_or_else(|| {\n+                    panic!(\"{}\", error(i))\n+                }).1;\n+\n+                if ch != '\\n' {\n+                    panic!(\"lexer accepted bare CR\");\n+                }\n+                chars.next();\n+                res.push('\\n');\n+            }\n+            c => res.push(c),\n         }\n     }\n \n@@ -346,22 +341,16 @@ pub fn raw_str_lit(lit: &str) -> String {\n     debug!(\"raw_str_lit: given {}\", escape_default(lit));\n     let mut res = String::with_capacity(lit.len());\n \n-    // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n     let mut chars = lit.chars().peekable();\n-    loop {\n-        match chars.next() {\n-            Some(c) => {\n-                if c == '\\r' {\n-                    if *chars.peek().unwrap() != '\\n' {\n-                        panic!(\"lexer accepted bare CR\");\n-                    }\n-                    chars.next();\n-                    res.push('\\n');\n-                } else {\n-                    res.push(c);\n-                }\n-            },\n-            None => break\n+    while let Some(c) = chars.next() {\n+        if c == '\\r' {\n+            if *chars.peek().unwrap() != '\\n' {\n+                panic!(\"lexer accepted bare CR\");\n+            }\n+            chars.next();\n+            res.push('\\n');\n+        } else {\n+            res.push(c);\n         }\n     }\n \n@@ -459,7 +448,7 @@ pub fn byte_lit(lit: &str) -> (u8, usize) {\n     if lit.len() == 1 {\n         (lit.as_bytes()[0], 1)\n     } else {\n-        assert!(lit.as_bytes()[0] == b'\\\\', err(0));\n+        assert_eq!(lit.as_bytes()[0], b'\\\\', \"{}\", err(0));\n         let b = match lit.as_bytes()[1] {\n             b'\"' => b'\"',\n             b'n' => b'\\n',\n@@ -480,7 +469,7 @@ pub fn byte_lit(lit: &str) -> (u8, usize) {\n                 }\n             }\n         };\n-        return (b, 2);\n+        (b, 2)\n     }\n }\n \n@@ -491,7 +480,7 @@ pub fn byte_str_lit(lit: &str) -> Rc<Vec<u8>> {\n     let error = |i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace\n-    fn eat<'a, I: Iterator<Item=(usize, u8)>>(it: &mut iter::Peekable<I>) {\n+    fn eat<I: Iterator<Item=(usize, u8)>>(it: &mut iter::Peekable<I>) {\n         loop {\n             match it.peek().map(|x| x.1) {\n                 Some(b' ') | Some(b'\\n') | Some(b'\\r') | Some(b'\\t') => {\n@@ -578,7 +567,7 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, diag: Option<(Span, &Handler\n             if let Some(err) = err {\n                 err!(diag, |span, diag| diag.span_err(span, err));\n             }\n-            return filtered_float_lit(Symbol::intern(&s), Some(suf), diag)\n+            return filtered_float_lit(Symbol::intern(s), Some(suf), diag)\n         }\n     }\n "}, {"sha": "078e86aa2941f36a8c28332986dcf3772177c15a", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -59,7 +59,7 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n \n         if !self.obsolete_set.contains(&kind) &&\n             (error || self.sess.span_diagnostic.can_emit_warnings) {\n-            err.note(&format!(\"{}\", desc));\n+            err.note(desc);\n             self.obsolete_set.insert(kind);\n         }\n         err.emit();"}, {"sha": "4741f896d3cc0c8c6ce38501dd2e1cb1a7dcfe0e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -248,7 +248,7 @@ impl TokenCursor {\n     fn next_desugared(&mut self) -> TokenAndSpan {\n         let (sp, name) = match self.next() {\n             TokenAndSpan { sp, tok: token::DocComment(name) } => (sp, name),\n-            tok @ _ => return tok,\n+            tok => return tok,\n         };\n \n         let stripped = strip_doc_comment_decoration(&name.as_str());\n@@ -354,7 +354,7 @@ pub enum Error {\n }\n \n impl Error {\n-    pub fn span_err<'a>(self, sp: Span, handler: &'a errors::Handler) -> DiagnosticBuilder<'a> {\n+    pub fn span_err(self, sp: Span, handler: &errors::Handler) -> DiagnosticBuilder {\n         match self {\n             Error::FileNotFoundForModule { ref mod_name,\n                                            ref default_path,\n@@ -478,9 +478,10 @@ impl<'a> Parser<'a> {\n     }\n \n     fn next_tok(&mut self) -> TokenAndSpan {\n-        let mut next = match self.desugar_doc_comments {\n-            true => self.token_cursor.next_desugared(),\n-            false => self.token_cursor.next(),\n+        let mut next = if self.desugar_doc_comments {\n+            self.token_cursor.next_desugared()\n+        } else {\n+            self.token_cursor.next()\n         };\n         if next.sp == syntax_pos::DUMMY_SP {\n             next.sp = self.prev_span;\n@@ -551,7 +552,7 @@ impl<'a> Parser<'a> {\n             // This might be a sign we need a connect method on Iterator.\n             let b = i.next()\n                      .map_or(\"\".to_string(), |t| t.to_string());\n-            i.enumerate().fold(b, |mut b, (i, ref a)| {\n+            i.enumerate().fold(b, |mut b, (i, a)| {\n                 if tokens.len() > 2 && i == tokens.len() - 2 {\n                     b.push_str(\", or \");\n                 } else if tokens.len() == 2 && i == tokens.len() - 2 {\n@@ -985,18 +986,15 @@ impl<'a> Parser<'a> {\n                 token::CloseDelim(..) | token::Eof => break,\n                 _ => {}\n             };\n-            match sep.sep {\n-                Some(ref t) => {\n-                    if first {\n-                        first = false;\n-                    } else {\n-                        if let Err(e) = self.expect(t) {\n-                            fe(e);\n-                            break;\n-                        }\n+            if let Some(ref t) = sep.sep {\n+                if first {\n+                    first = false;\n+                } else {\n+                    if let Err(e) = self.expect(t) {\n+                        fe(e);\n+                        break;\n                     }\n                 }\n-                _ => ()\n             }\n             if sep.trailing_sep_allowed && kets.iter().any(|k| self.check(k)) {\n                 break;\n@@ -1493,7 +1491,7 @@ impl<'a> Parser<'a> {\n         let sum_span = ty.span.to(self.prev_span);\n \n         let mut err = struct_span_err!(self.sess.span_diagnostic, sum_span, E0178,\n-            \"expected a path on the left-hand side of `+`, not `{}`\", pprust::ty_to_string(&ty));\n+            \"expected a path on the left-hand side of `+`, not `{}`\", pprust::ty_to_string(ty));\n \n         match ty.node {\n             TyKind::Rptr(ref lifetime, ref mut_ty) => {\n@@ -1547,7 +1545,7 @@ impl<'a> Parser<'a> {\n \n     pub fn is_named_argument(&mut self) -> bool {\n         let offset = match self.token {\n-            token::BinOp(token::And) => 1,\n+            token::BinOp(token::And) |\n             token::AndAnd => 1,\n             _ if self.token.is_keyword(keywords::Mut) => 1,\n             _ => 0\n@@ -3154,10 +3152,11 @@ impl<'a> Parser<'a> {\n \n         let attrs = self.parse_outer_attributes()?;\n         let pats = self.parse_pats()?;\n-        let mut guard = None;\n-        if self.eat_keyword(keywords::If) {\n-            guard = Some(self.parse_expr()?);\n-        }\n+        let guard = if self.eat_keyword(keywords::If) {\n+            Some(self.parse_expr()?)\n+        } else {\n+            None\n+        };\n         self.expect(&token::FatArrow)?;\n         let expr = self.parse_expr_res(RESTRICTION_STMT_EXPR, None)?;\n \n@@ -3600,10 +3599,11 @@ impl<'a> Parser<'a> {\n         let lo = self.span;\n         let pat = self.parse_pat()?;\n \n-        let mut ty = None;\n-        if self.eat(&token::Colon) {\n-            ty = Some(self.parse_ty()?);\n-        }\n+        let ty = if self.eat(&token::Colon) {\n+            Some(self.parse_ty()?)\n+        } else {\n+            None\n+        };\n         let init = self.parse_initializer()?;\n         Ok(P(ast::Local {\n             ty: ty,\n@@ -3929,7 +3929,7 @@ impl<'a> Parser<'a> {\n                 },\n                 None => {\n                     let unused_attrs = |attrs: &[_], s: &mut Self| {\n-                        if attrs.len() > 0 {\n+                        if !attrs.is_empty() {\n                             if s.prev_token_kind == PrevTokenKind::DocComment {\n                                 s.span_fatal_err(s.prev_span, Error::UselessDocComment).emit();\n                             } else {\n@@ -4815,7 +4815,7 @@ impl<'a> Parser<'a> {\n                 self.expect(&token::Not)?;\n             }\n \n-            self.complain_if_pub_macro(&vis, prev_span);\n+            self.complain_if_pub_macro(vis, prev_span);\n \n             // eat a matched-delimiter token tree:\n             *at_end = true;\n@@ -4917,13 +4917,10 @@ impl<'a> Parser<'a> {\n                 }\n             }\n         } else {\n-            match polarity {\n-                ast::ImplPolarity::Negative => {\n-                    // This is a negated type implementation\n-                    // `impl !MyType {}`, which is not allowed.\n-                    self.span_err(neg_span, \"inherent implementation can't be negated\");\n-                },\n-                _ => {}\n+            if polarity == ast::ImplPolarity::Negative {\n+                // This is a negated type implementation\n+                // `impl !MyType {}`, which is not allowed.\n+                self.span_err(neg_span, \"inherent implementation can't be negated\");\n             }\n             None\n         };\n@@ -5185,7 +5182,7 @@ impl<'a> Parser<'a> {\n                 let path_span = self.prev_span;\n                 let help_msg = format!(\"make this visible only to module `{}` with `in`:\", path);\n                 self.expect(&token::CloseDelim(token::Paren))?;  // `)`\n-                let mut err = self.span_fatal_help(path_span, &msg, &suggestion);\n+                let mut err = self.span_fatal_help(path_span, msg, suggestion);\n                 err.span_suggestion(path_span, &help_msg, format!(\"in {}\", path));\n                 err.emit();  // emit diagnostic, but continue with public visibility\n             }"}, {"sha": "77db604c56e118c0596364536b3b1ed3674a2f24", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -53,6 +53,10 @@ impl DelimToken {\n     pub fn len(self) -> usize {\n         if self == NoDelim { 0 } else { 1 }\n     }\n+\n+    pub fn is_empty(self) -> bool {\n+        self == NoDelim\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -198,17 +202,17 @@ impl Token {\n     pub fn can_begin_expr(&self) -> bool {\n         match *self {\n             Ident(ident)                => ident_can_begin_expr(ident), // value name or keyword\n-            OpenDelim(..)               => true, // tuple, array or block\n-            Literal(..)                 => true, // literal\n-            Not                         => true, // operator not\n-            BinOp(Minus)                => true, // unary minus\n-            BinOp(Star)                 => true, // dereference\n-            BinOp(Or) | OrOr            => true, // closure\n-            BinOp(And)                  => true, // reference\n-            AndAnd                      => true, // double reference\n-            DotDot | DotDotDot          => true, // range notation\n-            Lt | BinOp(Shl)             => true, // associated path\n-            ModSep                      => true, // global path\n+            OpenDelim(..)               | // tuple, array or block\n+            Literal(..)                 | // literal\n+            Not                         | // operator not\n+            BinOp(Minus)                | // unary minus\n+            BinOp(Star)                 | // dereference\n+            BinOp(Or) | OrOr            | // closure\n+            BinOp(And)                  | // reference\n+            AndAnd                      | // double reference\n+            DotDot | DotDotDot          | // range notation\n+            Lt | BinOp(Shl)             | // associated path\n+            ModSep                      | // global path\n             Pound                       => true, // expression attributes\n             Interpolated(ref nt) => match **nt {\n                 NtIdent(..) | NtExpr(..) | NtBlock(..) | NtPath(..) => true,\n@@ -222,16 +226,16 @@ impl Token {\n     pub fn can_begin_type(&self) -> bool {\n         match *self {\n             Ident(ident)                => ident_can_begin_type(ident), // type name or keyword\n-            OpenDelim(Paren)            => true, // tuple\n-            OpenDelim(Bracket)          => true, // array\n-            Underscore                  => true, // placeholder\n-            Not                         => true, // never\n-            BinOp(Star)                 => true, // raw pointer\n-            BinOp(And)                  => true, // reference\n-            AndAnd                      => true, // double reference\n-            Question                    => true, // maybe bound in trait object\n-            Lifetime(..)                => true, // lifetime bound in trait object\n-            Lt | BinOp(Shl)             => true, // associated path\n+            OpenDelim(Paren)            | // tuple\n+            OpenDelim(Bracket)          | // array\n+            Underscore                  | // placeholder\n+            Not                         | // never\n+            BinOp(Star)                 | // raw pointer\n+            BinOp(And)                  | // reference\n+            AndAnd                      | // double reference\n+            Question                    | // maybe bound in trait object\n+            Lifetime(..)                | // lifetime bound in trait object\n+            Lt | BinOp(Shl)             | // associated path\n             ModSep                      => true, // global path\n             Interpolated(ref nt) => match **nt {\n                 NtIdent(..) | NtTy(..) | NtPath(..) => true,"}, {"sha": "e893c859247c6110790921f528c04c99f9403fae", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -113,22 +113,22 @@\n //! between using 'left' and 'right' terms to denote the wrapped-to-ring-buffer\n //! and point-in-infinite-stream senses freely.\n //!\n-//! There is a parallel ring buffer, 'size', that holds the calculated size of\n+//! There is a parallel ring buffer, `size`, that holds the calculated size of\n //! each token. Why calculated? Because for Begin/End pairs, the \"size\"\n //! includes everything between the pair. That is, the \"size\" of Begin is\n //! actually the sum of the sizes of everything between Begin and the paired\n-//! End that follows. Since that is arbitrarily far in the future, 'size' is\n+//! End that follows. Since that is arbitrarily far in the future, `size` is\n //! being rewritten regularly while the printer runs; in fact most of the\n-//! machinery is here to work out 'size' entries on the fly (and give up when\n+//! machinery is here to work out `size` entries on the fly (and give up when\n //! they're so obviously over-long that \"infinity\" is a good enough\n //! approximation for purposes of line breaking).\n //!\n //! The \"input side\" of the printer is managed as an abstract process called\n-//! SCAN, which uses 'scan_stack', to manage calculating 'size'. SCAN is, in\n+//! SCAN, which uses `scan_stack`, to manage calculating `size`. SCAN is, in\n //! other words, the process of calculating 'size' entries.\n //!\n //! The \"output side\" of the printer is managed by an abstract process called\n-//! PRINT, which uses 'print_stack', 'margin' and 'space' to figure out what to\n+//! PRINT, which uses `print_stack`, `margin` and `space` to figure out what to\n //! do with each token/size pair it consumes as it goes. It's trying to consume\n //! the entire buffered window, but can't output anything until the size is >=\n //! 0 (sizes are set to negative while they're pending calculation).\n@@ -409,7 +409,7 @@ impl<'a> Printer<'a> {\n     pub fn advance_right(&mut self) {\n         self.right += 1;\n         self.right %= self.buf_len;\n-        assert!(self.right != self.left);\n+        assert_ne!(self.right, self.left);\n     }\n     pub fn advance_left(&mut self) -> io::Result<()> {\n         debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,"}, {"sha": "83c289ff80b9251bd2df854ebed1207b7f5a09f0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 137, "deletions": 156, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -233,7 +233,7 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::CloseDelim(token::Bracket) => \"]\".to_string(),\n         token::OpenDelim(token::Brace) => \"{\".to_string(),\n         token::CloseDelim(token::Brace) => \"}\".to_string(),\n-        token::OpenDelim(token::NoDelim) => \" \".to_string(),\n+        token::OpenDelim(token::NoDelim) |\n         token::CloseDelim(token::NoDelim) => \" \".to_string(),\n         token::Pound                => \"#\".to_string(),\n         token::Dollar               => \"$\".to_string(),\n@@ -244,7 +244,7 @@ pub fn token_to_string(tok: &Token) -> String {\n             let mut out = match lit {\n                 token::Byte(b)           => format!(\"b'{}'\", b),\n                 token::Char(c)           => format!(\"'{}'\", c),\n-                token::Float(c)          => c.to_string(),\n+                token::Float(c)          |\n                 token::Integer(c)        => c.to_string(),\n                 token::Str_(s)           => format!(\"\\\"{}\\\"\", s),\n                 token::StrRaw(s, n)      => format!(\"r{delim}\\\"{string}\\\"{delim}\",\n@@ -277,23 +277,23 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Shebang(s)           => format!(\"/* shebang: {}*/\", s),\n \n         token::Interpolated(ref nt) => match **nt {\n-            token::NtExpr(ref e)        => expr_to_string(&e),\n-            token::NtMeta(ref e)        => meta_item_to_string(&e),\n-            token::NtTy(ref e)          => ty_to_string(&e),\n-            token::NtPath(ref e)        => path_to_string(&e),\n-            token::NtItem(ref e)        => item_to_string(&e),\n-            token::NtBlock(ref e)       => block_to_string(&e),\n-            token::NtStmt(ref e)        => stmt_to_string(&e),\n-            token::NtPat(ref e)         => pat_to_string(&e),\n+            token::NtExpr(ref e)        => expr_to_string(e),\n+            token::NtMeta(ref e)        => meta_item_to_string(e),\n+            token::NtTy(ref e)          => ty_to_string(e),\n+            token::NtPath(ref e)        => path_to_string(e),\n+            token::NtItem(ref e)        => item_to_string(e),\n+            token::NtBlock(ref e)       => block_to_string(e),\n+            token::NtStmt(ref e)        => stmt_to_string(e),\n+            token::NtPat(ref e)         => pat_to_string(e),\n             token::NtIdent(ref e)       => ident_to_string(e.node),\n             token::NtTT(ref tree)       => tt_to_string(tree.clone()),\n-            token::NtArm(ref e)         => arm_to_string(&e),\n-            token::NtImplItem(ref e)    => impl_item_to_string(&e),\n-            token::NtTraitItem(ref e)   => trait_item_to_string(&e),\n-            token::NtGenerics(ref e)    => generics_to_string(&e),\n-            token::NtWhereClause(ref e) => where_clause_to_string(&e),\n-            token::NtArg(ref e)         => arg_to_string(&e),\n-            token::NtVis(ref e)         => vis_to_string(&e),\n+            token::NtArm(ref e)         => arm_to_string(e),\n+            token::NtImplItem(ref e)    => impl_item_to_string(e),\n+            token::NtTraitItem(ref e)   => trait_item_to_string(e),\n+            token::NtGenerics(ref e)    => generics_to_string(e),\n+            token::NtWhereClause(ref e) => where_clause_to_string(e),\n+            token::NtArg(ref e)         => arg_to_string(e),\n+            token::NtVis(ref e)         => vis_to_string(e),\n         }\n     }\n }\n@@ -520,8 +520,7 @@ pub trait PrintState<'a> {\n \n         let mut result = None;\n \n-        if let &Some(ref lits) = self.literals()\n-        {\n+        if let Some(ref lits) = *self.literals() {\n             while cur_lit < lits.len() {\n                 let ltrl = (*lits)[cur_lit].clone();\n                 if ltrl.pos > pos { break; }\n@@ -618,11 +617,8 @@ pub trait PrintState<'a> {\n \n     fn print_literal(&mut self, lit: &ast::Lit) -> io::Result<()> {\n         self.maybe_print_comment(lit.span.lo)?;\n-        match self.next_lit(lit.span.lo) {\n-            Some(ref ltrl) => {\n-                return word(self.writer(), &(*ltrl).lit);\n-            }\n-            _ => ()\n+        if let Some(ref ltrl) = self.next_lit(lit.span.lo) {\n+            return word(self.writer(), &(*ltrl).lit);\n         }\n         match lit.node {\n             ast::LitKind::Str(st, style) => self.print_string(&st.as_str(), style),\n@@ -799,7 +795,7 @@ pub trait PrintState<'a> {\n                 self.popen()?;\n                 self.commasep(Consistent,\n                               &items[..],\n-                              |s, i| s.print_meta_list_item(&i))?;\n+                              |s, i| s.print_meta_list_item(i))?;\n                 self.pclose()?;\n             }\n         }\n@@ -982,14 +978,14 @@ impl<'a> State<'a> {\n \n     pub fn commasep_exprs(&mut self, b: Breaks,\n                           exprs: &[P<ast::Expr>]) -> io::Result<()> {\n-        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&e), |e| e.span)\n+        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(e), |e| e.span)\n     }\n \n     pub fn print_mod(&mut self, _mod: &ast::Mod,\n                      attrs: &[ast::Attribute]) -> io::Result<()> {\n         self.print_inner_attributes(attrs)?;\n         for item in &_mod.items {\n-            self.print_item(&item)?;\n+            self.print_item(item)?;\n         }\n         Ok(())\n     }\n@@ -1018,7 +1014,7 @@ impl<'a> State<'a> {\n         match ty.node {\n             ast::TyKind::Slice(ref ty) => {\n                 word(&mut self.s, \"[\")?;\n-                self.print_type(&ty)?;\n+                self.print_type(ty)?;\n                 word(&mut self.s, \"]\")?;\n             }\n             ast::TyKind::Ptr(ref mt) => {\n@@ -1040,15 +1036,15 @@ impl<'a> State<'a> {\n             ast::TyKind::Tup(ref elts) => {\n                 self.popen()?;\n                 self.commasep(Inconsistent, &elts[..],\n-                              |s, ty| s.print_type(&ty))?;\n+                              |s, ty| s.print_type(ty))?;\n                 if elts.len() == 1 {\n                     word(&mut self.s, \",\")?;\n                 }\n                 self.pclose()?;\n             }\n             ast::TyKind::Paren(ref typ) => {\n                 self.popen()?;\n-                self.print_type(&typ)?;\n+                self.print_type(typ)?;\n                 self.pclose()?;\n             }\n             ast::TyKind::BareFn(ref f) => {\n@@ -1081,14 +1077,14 @@ impl<'a> State<'a> {\n             }\n             ast::TyKind::Array(ref ty, ref v) => {\n                 word(&mut self.s, \"[\")?;\n-                self.print_type(&ty)?;\n+                self.print_type(ty)?;\n                 word(&mut self.s, \"; \")?;\n-                self.print_expr(&v)?;\n+                self.print_expr(v)?;\n                 word(&mut self.s, \"]\")?;\n             }\n             ast::TyKind::Typeof(ref e) => {\n                 word(&mut self.s, \"typeof(\")?;\n-                self.print_expr(&e)?;\n+                self.print_expr(e)?;\n                 word(&mut self.s, \")\")?;\n             }\n             ast::TyKind::Infer => {\n@@ -1130,7 +1126,7 @@ impl<'a> State<'a> {\n                 }\n                 self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n-                self.print_type(&t)?;\n+                self.print_type(t)?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end the head-ibox\n                 self.end() // end the outer cbox\n@@ -1187,7 +1183,7 @@ impl<'a> State<'a> {\n                 self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n                 if let Some(p) = *optional_path {\n                     let val = p.as_str();\n-                    if val.contains(\"-\") {\n+                    if val.contains('-') {\n                         self.print_string(&val, ast::StrStyle::Cooked)?;\n                     } else {\n                         self.print_name(p)?;\n@@ -1203,7 +1199,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::Use(ref vp) => {\n                 self.head(&visibility_qualified(&item.vis, \"use\"))?;\n-                self.print_view_path(&vp)?;\n+                self.print_view_path(vp)?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n@@ -1215,25 +1211,25 @@ impl<'a> State<'a> {\n                 }\n                 self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n-                self.print_type(&ty)?;\n+                self.print_type(ty)?;\n                 space(&mut self.s)?;\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n-                self.print_expr(&expr)?;\n+                self.print_expr(expr)?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end the outer cbox\n             }\n             ast::ItemKind::Const(ref ty, ref expr) => {\n                 self.head(&visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_ident(item.ident)?;\n                 self.word_space(\":\")?;\n-                self.print_type(&ty)?;\n+                self.print_type(ty)?;\n                 space(&mut self.s)?;\n                 self.end()?; // end the head-ibox\n \n                 self.word_space(\"=\")?;\n-                self.print_expr(&expr)?;\n+                self.print_expr(expr)?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end the outer cbox\n             }\n@@ -1249,7 +1245,7 @@ impl<'a> State<'a> {\n                     &item.vis\n                 )?;\n                 word(&mut self.s, \" \")?;\n-                self.print_block_with_attrs(&body, &item.attrs)?;\n+                self.print_block_with_attrs(body, &item.attrs)?;\n             }\n             ast::ItemKind::Mod(ref _mod) => {\n                 self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n@@ -1282,7 +1278,7 @@ impl<'a> State<'a> {\n                 self.print_where_clause(&params.where_clause)?;\n                 space(&mut self.s)?;\n                 self.word_space(\"=\")?;\n-                self.print_type(&ty)?;\n+                self.print_type(ty)?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end the outer ibox\n             }\n@@ -1297,11 +1293,11 @@ impl<'a> State<'a> {\n             }\n             ast::ItemKind::Struct(ref struct_def, ref generics) => {\n                 self.head(&visibility_qualified(&item.vis, \"struct\"))?;\n-                self.print_struct(&struct_def, generics, item.ident, item.span, true)?;\n+                self.print_struct(struct_def, generics, item.ident, item.span, true)?;\n             }\n             ast::ItemKind::Union(ref struct_def, ref generics) => {\n                 self.head(&visibility_qualified(&item.vis, \"union\"))?;\n-                self.print_struct(&struct_def, generics, item.ident, item.span, true)?;\n+                self.print_struct(struct_def, generics, item.ident, item.span, true)?;\n             }\n             ast::ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n                 self.head(\"\")?;\n@@ -1333,11 +1329,8 @@ impl<'a> State<'a> {\n                     space(&mut self.s)?;\n                 }\n \n-                match polarity {\n-                    ast::ImplPolarity::Negative => {\n-                        word(&mut self.s, \"!\")?;\n-                    },\n-                    _ => {}\n+                if polarity == ast::ImplPolarity::Negative {\n+                    word(&mut self.s, \"!\")?;\n                 }\n \n                 if let Some(ref t) = *opt_trait {\n@@ -1346,7 +1339,7 @@ impl<'a> State<'a> {\n                     self.word_space(\"for\")?;\n                 }\n \n-                self.print_type(&ty)?;\n+                self.print_type(ty)?;\n                 self.print_where_clause(&generics.where_clause)?;\n \n                 space(&mut self.s)?;\n@@ -1543,7 +1536,7 @@ impl<'a> State<'a> {\n             Some(ref d) => {\n                 space(&mut self.s)?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(&d)\n+                self.print_expr(d)\n             }\n             _ => Ok(())\n         }\n@@ -1571,7 +1564,7 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&ti.attrs)?;\n         match ti.node {\n             ast::TraitItemKind::Const(ref ty, ref default) => {\n-                self.print_associated_const(ti.ident, &ty,\n+                self.print_associated_const(ti.ident, ty,\n                                             default.as_ref().map(|expr| &**expr),\n                                             &ast::Visibility::Inherited)?;\n             }\n@@ -1614,7 +1607,7 @@ impl<'a> State<'a> {\n         self.print_defaultness(ii.defaultness)?;\n         match ii.node {\n             ast::ImplItemKind::Const(ref ty, ref expr) => {\n-                self.print_associated_const(ii.ident, &ty, Some(&expr), &ii.vis)?;\n+                self.print_associated_const(ii.ident, ty, Some(expr), &ii.vis)?;\n             }\n             ast::ImplItemKind::Method(ref sig, ref body) => {\n                 self.head(\"\")?;\n@@ -1650,38 +1643,38 @@ impl<'a> State<'a> {\n                 self.word_nbsp(\"let\")?;\n \n                 self.ibox(INDENT_UNIT)?;\n-                self.print_local_decl(&loc)?;\n+                self.print_local_decl(loc)?;\n                 self.end()?;\n                 if let Some(ref init) = loc.init {\n                     self.nbsp()?;\n                     self.word_space(\"=\")?;\n-                    self.print_expr(&init)?;\n+                    self.print_expr(init)?;\n                 }\n                 word(&mut self.s, \";\")?;\n                 self.end()?;\n             }\n-            ast::StmtKind::Item(ref item) => self.print_item(&item)?,\n+            ast::StmtKind::Item(ref item) => self.print_item(item)?,\n             ast::StmtKind::Expr(ref expr) => {\n                 self.space_if_not_bol()?;\n-                self.print_expr_outer_attr_style(&expr, false)?;\n+                self.print_expr_outer_attr_style(expr, false)?;\n                 if parse::classify::expr_requires_semi_to_be_stmt(expr) {\n                     word(&mut self.s, \";\")?;\n                 }\n             }\n             ast::StmtKind::Semi(ref expr) => {\n                 self.space_if_not_bol()?;\n-                self.print_expr_outer_attr_style(&expr, false)?;\n+                self.print_expr_outer_attr_style(expr, false)?;\n                 word(&mut self.s, \";\")?;\n             }\n             ast::StmtKind::Mac(ref mac) => {\n                 let (ref mac, style, ref attrs) = **mac;\n                 self.space_if_not_bol()?;\n-                self.print_outer_attributes(&attrs)?;\n+                self.print_outer_attributes(attrs)?;\n                 let delim = match style {\n                     ast::MacStmtStyle::Braces => token::Brace,\n                     _ => token::Paren\n                 };\n-                self.print_mac(&mac, delim)?;\n+                self.print_mac(mac, delim)?;\n                 if style == ast::MacStmtStyle::Semicolon {\n                     word(&mut self.s, \";\")?;\n                 }\n@@ -1735,7 +1728,7 @@ impl<'a> State<'a> {\n                 ast::StmtKind::Expr(ref expr) if i == blk.stmts.len() - 1 => {\n                     self.maybe_print_comment(st.span.lo)?;\n                     self.space_if_not_bol()?;\n-                    self.print_expr_outer_attr_style(&expr, false)?;\n+                    self.print_expr_outer_attr_style(expr, false)?;\n                     self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi))?;\n                 }\n                 _ => self.print_stmt(st)?,\n@@ -1755,30 +1748,30 @@ impl<'a> State<'a> {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n                         word(&mut self.s, \" else if \")?;\n-                        self.print_expr(&i)?;\n+                        self.print_expr(i)?;\n                         space(&mut self.s)?;\n-                        self.print_block(&then)?;\n+                        self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"another else-if-let\"\n                     ast::ExprKind::IfLet(ref pat, ref expr, ref then, ref e) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n                         word(&mut self.s, \" else if let \")?;\n-                        self.print_pat(&pat)?;\n+                        self.print_pat(pat)?;\n                         space(&mut self.s)?;\n                         self.word_space(\"=\")?;\n-                        self.print_expr(&expr)?;\n+                        self.print_expr(expr)?;\n                         space(&mut self.s)?;\n-                        self.print_block(&then)?;\n+                        self.print_block(then)?;\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n                     ast::ExprKind::Block(ref b) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n                         word(&mut self.s, \" else \")?;\n-                        self.print_block(&b)\n+                        self.print_block(b)\n                     }\n                     // BLEAH, constraints would be great here\n                     _ => {\n@@ -1844,12 +1837,8 @@ impl<'a> State<'a> {\n                                       binop: ast::BinOp) -> bool {\n         match sub_expr.node {\n             ast::ExprKind::Binary(ref sub_op, _, _) => {\n-                if AssocOp::from_ast_binop(sub_op.node).precedence() <\n-                    AssocOp::from_ast_binop(binop.node).precedence() {\n-                    true\n-                } else {\n-                    false\n-                }\n+                AssocOp::from_ast_binop(sub_op.node).precedence() <\n+                    AssocOp::from_ast_binop(binop.node).precedence()\n             }\n             _ => true\n         }\n@@ -1929,7 +1918,7 @@ impl<'a> State<'a> {\n                     space(&mut self.s)?;\n                 }\n                 word(&mut self.s, \"..\")?;\n-                self.print_expr(&expr)?;\n+                self.print_expr(expr)?;\n                 self.end()?;\n             }\n             _ => if !fields.is_empty() {\n@@ -1969,7 +1958,7 @@ impl<'a> State<'a> {\n         if !tys.is_empty() {\n             word(&mut self.s, \"::<\")?;\n             self.commasep(Inconsistent, tys,\n-                          |s, ty| s.print_type(&ty))?;\n+                          |s, ty| s.print_type(ty))?;\n             word(&mut self.s, \">\")?;\n         }\n         self.print_call_post(base_args)\n@@ -2038,7 +2027,7 @@ impl<'a> State<'a> {\n                 self.print_expr_vec(&exprs[..], attrs)?;\n             }\n             ast::ExprKind::Repeat(ref element, ref count) => {\n-                self.print_expr_repeat(&element, &count, attrs)?;\n+                self.print_expr_repeat(element, count, attrs)?;\n             }\n             ast::ExprKind::Struct(ref path, ref fields, ref wth) => {\n                 self.print_expr_struct(path, &fields[..], wth, attrs)?;\n@@ -2047,79 +2036,79 @@ impl<'a> State<'a> {\n                 self.print_expr_tup(&exprs[..], attrs)?;\n             }\n             ast::ExprKind::Call(ref func, ref args) => {\n-                self.print_expr_call(&func, &args[..])?;\n+                self.print_expr_call(func, &args[..])?;\n             }\n             ast::ExprKind::MethodCall(ident, ref tys, ref args) => {\n                 self.print_expr_method_call(ident, &tys[..], &args[..])?;\n             }\n             ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-                self.print_expr_binary(op, &lhs, &rhs)?;\n+                self.print_expr_binary(op, lhs, rhs)?;\n             }\n             ast::ExprKind::Unary(op, ref expr) => {\n-                self.print_expr_unary(op, &expr)?;\n+                self.print_expr_unary(op, expr)?;\n             }\n             ast::ExprKind::AddrOf(m, ref expr) => {\n-                self.print_expr_addr_of(m, &expr)?;\n+                self.print_expr_addr_of(m, expr)?;\n             }\n             ast::ExprKind::Lit(ref lit) => {\n-                self.print_literal(&lit)?;\n+                self.print_literal(lit)?;\n             }\n             ast::ExprKind::Cast(ref expr, ref ty) => {\n                 if let ast::ExprKind::Cast(..) = expr.node {\n-                    self.print_expr(&expr)?;\n+                    self.print_expr(expr)?;\n                 } else {\n-                    self.print_expr_maybe_paren(&expr)?;\n+                    self.print_expr_maybe_paren(expr)?;\n                 }\n                 space(&mut self.s)?;\n                 self.word_space(\"as\")?;\n-                self.print_type(&ty)?;\n+                self.print_type(ty)?;\n             }\n             ast::ExprKind::Type(ref expr, ref ty) => {\n-                self.print_expr(&expr)?;\n+                self.print_expr(expr)?;\n                 self.word_space(\":\")?;\n-                self.print_type(&ty)?;\n+                self.print_type(ty)?;\n             }\n             ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n-                self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e))?;\n+                self.print_if(test, blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n             ast::ExprKind::IfLet(ref pat, ref expr, ref blk, ref elseopt) => {\n-                self.print_if_let(&pat, &expr, &blk, elseopt.as_ref().map(|e| &**e))?;\n+                self.print_if_let(pat, expr, blk, elseopt.as_ref().map(|e| &**e))?;\n             }\n             ast::ExprKind::While(ref test, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     self.print_ident(ident.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n-                self.print_expr(&test)?;\n+                self.print_expr(test)?;\n                 space(&mut self.s)?;\n-                self.print_block_with_attrs(&blk, attrs)?;\n+                self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     self.print_ident(ident.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while let\")?;\n-                self.print_pat(&pat)?;\n+                self.print_pat(pat)?;\n                 space(&mut self.s)?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(&expr)?;\n+                self.print_expr(expr)?;\n                 space(&mut self.s)?;\n-                self.print_block_with_attrs(&blk, attrs)?;\n+                self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     self.print_ident(ident.node)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"for\")?;\n-                self.print_pat(&pat)?;\n+                self.print_pat(pat)?;\n                 space(&mut self.s)?;\n                 self.word_space(\"in\")?;\n-                self.print_expr(&iter)?;\n+                self.print_expr(iter)?;\n                 space(&mut self.s)?;\n-                self.print_block_with_attrs(&blk, attrs)?;\n+                self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::Loop(ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n@@ -2128,13 +2117,13 @@ impl<'a> State<'a> {\n                 }\n                 self.head(\"loop\")?;\n                 space(&mut self.s)?;\n-                self.print_block_with_attrs(&blk, attrs)?;\n+                self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::Match(ref expr, ref arms) => {\n                 self.cbox(INDENT_UNIT)?;\n                 self.ibox(4)?;\n                 self.word_nbsp(\"match\")?;\n-                self.print_expr(&expr)?;\n+                self.print_expr(expr)?;\n                 space(&mut self.s)?;\n                 self.bopen()?;\n                 self.print_inner_attributes_no_trailing_hardbreak(attrs)?;\n@@ -2146,7 +2135,7 @@ impl<'a> State<'a> {\n             ast::ExprKind::Closure(capture_clause, ref decl, ref body, _) => {\n                 self.print_capture_clause(capture_clause)?;\n \n-                self.print_fn_block_args(&decl)?;\n+                self.print_fn_block_args(decl)?;\n                 space(&mut self.s)?;\n                 self.print_expr(body)?;\n                 self.end()?; // need to close a box\n@@ -2161,48 +2150,48 @@ impl<'a> State<'a> {\n                 self.cbox(INDENT_UNIT)?;\n                 // head-box, will be closed by print-block after {\n                 self.ibox(0)?;\n-                self.print_block_with_attrs(&blk, attrs)?;\n+                self.print_block_with_attrs(blk, attrs)?;\n             }\n             ast::ExprKind::Assign(ref lhs, ref rhs) => {\n-                self.print_expr(&lhs)?;\n+                self.print_expr(lhs)?;\n                 space(&mut self.s)?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(&rhs)?;\n+                self.print_expr(rhs)?;\n             }\n             ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-                self.print_expr(&lhs)?;\n+                self.print_expr(lhs)?;\n                 space(&mut self.s)?;\n                 word(&mut self.s, op.node.to_string())?;\n                 self.word_space(\"=\")?;\n-                self.print_expr(&rhs)?;\n+                self.print_expr(rhs)?;\n             }\n             ast::ExprKind::Field(ref expr, id) => {\n-                self.print_expr(&expr)?;\n+                self.print_expr(expr)?;\n                 word(&mut self.s, \".\")?;\n                 self.print_ident(id.node)?;\n             }\n             ast::ExprKind::TupField(ref expr, id) => {\n-                self.print_expr(&expr)?;\n+                self.print_expr(expr)?;\n                 word(&mut self.s, \".\")?;\n                 self.print_usize(id.node)?;\n             }\n             ast::ExprKind::Index(ref expr, ref index) => {\n-                self.print_expr(&expr)?;\n+                self.print_expr(expr)?;\n                 word(&mut self.s, \"[\")?;\n-                self.print_expr(&index)?;\n+                self.print_expr(index)?;\n                 word(&mut self.s, \"]\")?;\n             }\n             ast::ExprKind::Range(ref start, ref end, limits) => {\n-                if let &Some(ref e) = start {\n-                    self.print_expr(&e)?;\n+                if let Some(ref e) = *start {\n+                    self.print_expr(e)?;\n                 }\n                 if limits == ast::RangeLimits::HalfOpen {\n                     word(&mut self.s, \"..\")?;\n                 } else {\n                     word(&mut self.s, \"...\")?;\n                 }\n-                if let &Some(ref e) = end {\n-                    self.print_expr(&e)?;\n+                if let Some(ref e) = *end {\n+                    self.print_expr(e)?;\n                 }\n             }\n             ast::ExprKind::Path(None, ref path) => {\n@@ -2233,12 +2222,9 @@ impl<'a> State<'a> {\n             }\n             ast::ExprKind::Ret(ref result) => {\n                 word(&mut self.s, \"return\")?;\n-                match *result {\n-                    Some(ref expr) => {\n-                        word(&mut self.s, \" \")?;\n-                        self.print_expr(&expr)?;\n-                    }\n-                    _ => ()\n+                if let Some(ref expr) = *result {\n+                    word(&mut self.s, \" \")?;\n+                    self.print_expr(expr)?;\n                 }\n             }\n             ast::ExprKind::InlineAsm(ref a) => {\n@@ -2268,7 +2254,7 @@ impl<'a> State<'a> {\n                 self.commasep(Inconsistent, &a.inputs, |s, &(co, ref o)| {\n                     s.print_string(&co.as_str(), ast::StrStyle::Cooked)?;\n                     s.popen()?;\n-                    s.print_expr(&o)?;\n+                    s.print_expr(o)?;\n                     s.pclose()?;\n                     Ok(())\n                 })?;\n@@ -2308,7 +2294,7 @@ impl<'a> State<'a> {\n             ast::ExprKind::Paren(ref e) => {\n                 self.popen()?;\n                 self.print_inner_attributes_inline(attrs)?;\n-                self.print_expr(&e)?;\n+                self.print_expr(e)?;\n                 self.pclose()?;\n             },\n             ast::ExprKind::Try(ref e) => {\n@@ -2318,7 +2304,7 @@ impl<'a> State<'a> {\n             ast::ExprKind::Catch(ref blk) => {\n                 self.head(\"do catch\")?;\n                 space(&mut self.s)?;\n-                self.print_block_with_attrs(&blk, attrs)?\n+                self.print_block_with_attrs(blk, attrs)?\n             }\n         }\n         self.ann.post(self, NodeExpr(expr))?;\n@@ -2329,7 +2315,7 @@ impl<'a> State<'a> {\n         self.print_pat(&loc.pat)?;\n         if let Some(ref ty) = loc.ty {\n             self.word_space(\":\")?;\n-            self.print_type(&ty)?;\n+            self.print_type(ty)?;\n         }\n         Ok(())\n     }\n@@ -2397,7 +2383,7 @@ impl<'a> State<'a> {\n             space(&mut self.s)?;\n             self.word_space(\"as\")?;\n             let depth = path.segments.len() - qself.position;\n-            self.print_path(&path, false, depth, false)?;\n+            self.print_path(path, false, depth, false)?;\n         }\n         word(&mut self.s, \">\")?;\n         word(&mut self.s, \"::\")?;\n@@ -2438,7 +2424,7 @@ impl<'a> State<'a> {\n                     self.commasep(\n                         Inconsistent,\n                         &data.types,\n-                        |s, ty| s.print_type(&ty))?;\n+                        |s, ty| s.print_type(ty))?;\n                         comma = true;\n                 }\n \n@@ -2461,13 +2447,13 @@ impl<'a> State<'a> {\n                 self.commasep(\n                     Inconsistent,\n                     &data.inputs,\n-                    |s, ty| s.print_type(&ty))?;\n+                    |s, ty| s.print_type(ty))?;\n                 word(&mut self.s, \")\")?;\n \n                 if let Some(ref ty) = data.output {\n                     self.space_if_not_bol()?;\n                     self.word_space(\"->\")?;\n-                    self.print_type(&ty)?;\n+                    self.print_type(ty)?;\n                 }\n             }\n         }\n@@ -2496,24 +2482,24 @@ impl<'a> State<'a> {\n                 self.print_ident(path1.node)?;\n                 if let Some(ref p) = *sub {\n                     word(&mut self.s, \"@\")?;\n-                    self.print_pat(&p)?;\n+                    self.print_pat(p)?;\n                 }\n             }\n             PatKind::TupleStruct(ref path, ref elts, ddpos) => {\n                 self.print_path(path, true, 0, false)?;\n                 self.popen()?;\n                 if let Some(ddpos) = ddpos {\n-                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p))?;\n+                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(p))?;\n                     if ddpos != 0 {\n                         self.word_space(\",\")?;\n                     }\n                     word(&mut self.s, \"..\")?;\n                     if ddpos != elts.len() {\n                         word(&mut self.s, \",\")?;\n-                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n+                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(p))?;\n                     }\n                 } else {\n-                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p))?;\n+                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p))?;\n                 }\n                 self.pclose()?;\n             }\n@@ -2549,17 +2535,17 @@ impl<'a> State<'a> {\n             PatKind::Tuple(ref elts, ddpos) => {\n                 self.popen()?;\n                 if let Some(ddpos) = ddpos {\n-                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p))?;\n+                    self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(p))?;\n                     if ddpos != 0 {\n                         self.word_space(\",\")?;\n                     }\n                     word(&mut self.s, \"..\")?;\n                     if ddpos != elts.len() {\n                         word(&mut self.s, \",\")?;\n-                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(&p))?;\n+                        self.commasep(Inconsistent, &elts[ddpos..], |s, p| s.print_pat(p))?;\n                     }\n                 } else {\n-                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p))?;\n+                    self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(p))?;\n                     if elts.len() == 1 {\n                         word(&mut self.s, \",\")?;\n                     }\n@@ -2568,41 +2554,41 @@ impl<'a> State<'a> {\n             }\n             PatKind::Box(ref inner) => {\n                 word(&mut self.s, \"box \")?;\n-                self.print_pat(&inner)?;\n+                self.print_pat(inner)?;\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n                 word(&mut self.s, \"&\")?;\n                 if mutbl == ast::Mutability::Mutable {\n                     word(&mut self.s, \"mut \")?;\n                 }\n-                self.print_pat(&inner)?;\n+                self.print_pat(inner)?;\n             }\n             PatKind::Lit(ref e) => self.print_expr(&**e)?,\n             PatKind::Range(ref begin, ref end, ref end_kind) => {\n-                self.print_expr(&begin)?;\n+                self.print_expr(begin)?;\n                 space(&mut self.s)?;\n                 match *end_kind {\n                     RangeEnd::Included => word(&mut self.s, \"...\")?,\n                     RangeEnd::Excluded => word(&mut self.s, \"..\")?,\n                 }\n-                self.print_expr(&end)?;\n+                self.print_expr(end)?;\n             }\n             PatKind::Slice(ref before, ref slice, ref after) => {\n                 word(&mut self.s, \"[\")?;\n                 self.commasep(Inconsistent,\n                                    &before[..],\n-                                   |s, p| s.print_pat(&p))?;\n+                                   |s, p| s.print_pat(p))?;\n                 if let Some(ref p) = *slice {\n                     if !before.is_empty() { self.word_space(\",\")?; }\n                     if p.node != PatKind::Wild {\n-                        self.print_pat(&p)?;\n+                        self.print_pat(p)?;\n                     }\n                     word(&mut self.s, \"..\")?;\n                     if !after.is_empty() { self.word_space(\",\")?; }\n                 }\n                 self.commasep(Inconsistent,\n                                    &after[..],\n-                                   |s, p| s.print_pat(&p))?;\n+                                   |s, p| s.print_pat(p))?;\n                 word(&mut self.s, \"]\")?;\n             }\n             PatKind::Mac(ref m) => self.print_mac(m, token::Paren)?,\n@@ -2628,20 +2614,20 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n                 self.word_space(\"|\")?;\n             }\n-            self.print_pat(&p)?;\n+            self.print_pat(p)?;\n         }\n         space(&mut self.s)?;\n         if let Some(ref e) = arm.guard {\n             self.word_space(\"if\")?;\n-            self.print_expr(&e)?;\n+            self.print_expr(e)?;\n             space(&mut self.s)?;\n         }\n         self.word_space(\"=>\")?;\n \n         match arm.body.node {\n             ast::ExprKind::Block(ref blk) => {\n                 // the block will close the pattern's ibox\n-                self.print_block_unclosed_indent(&blk, INDENT_UNIT)?;\n+                self.print_block_unclosed_indent(blk, INDENT_UNIT)?;\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n@@ -2673,7 +2659,7 @@ impl<'a> State<'a> {\n                 self.print_mutability(m)?;\n                 word(&mut self.s, \"self\")?;\n                 self.word_space(\":\")?;\n-                self.print_type(&typ)\n+                self.print_type(typ)\n             }\n         }\n     }\n@@ -2725,7 +2711,7 @@ impl<'a> State<'a> {\n         self.word_space(\"->\")?;\n         match decl.output {\n             ast::FunctionRetTy::Ty(ref ty) => {\n-                self.print_type(&ty)?;\n+                self.print_type(ty)?;\n                 self.maybe_print_comment(ty.span.lo)\n             }\n             ast::FunctionRetTy::Default(..) => unreachable!(),\n@@ -2839,7 +2825,7 @@ impl<'a> State<'a> {\n             Some(ref default) => {\n                 space(&mut self.s)?;\n                 self.word_space(\"=\")?;\n-                self.print_type(&default)\n+                self.print_type(default)\n             }\n             _ => Ok(())\n         }\n@@ -2865,7 +2851,7 @@ impl<'a> State<'a> {\n                                                                              ref bounds,\n                                                                              ..}) => {\n                     self.print_formal_lifetime_list(bound_lifetimes)?;\n-                    self.print_type(&bounded_ty)?;\n+                    self.print_type(bounded_ty)?;\n                     self.print_bounds(\":\", bounds)?;\n                 }\n                 ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n@@ -2977,7 +2963,7 @@ impl<'a> State<'a> {\n         match decl.output {\n             ast::FunctionRetTy::Default(..) => unreachable!(),\n             ast::FunctionRetTy::Ty(ref ty) =>\n-                self.print_type(&ty)?\n+                self.print_type(ty)?\n         }\n         self.end()?;\n \n@@ -3044,14 +3030,9 @@ impl<'a> State<'a> {\n         if self.next_comment().is_none() {\n             hardbreak(&mut self.s)?;\n         }\n-        loop {\n-            match self.next_comment() {\n-                Some(ref cmnt) => {\n-                    self.print_comment(cmnt)?;\n-                    self.cur_cmnt_and_lit.cur_cmnt += 1;\n-                }\n-                _ => break\n-            }\n+        while let Some(ref cmnt) = self.next_comment() {\n+            self.print_comment(cmnt)?;\n+            self.cur_cmnt_and_lit.cur_cmnt += 1;\n         }\n         Ok(())\n     }"}, {"sha": "8e257102e1c13367d281d01cce701e94bb0bacf5", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -18,7 +18,7 @@ use ptr::P;\n use tokenstream::TokenStream;\n \n /// Craft a span that will be ignored by the stability lint's\n-/// call to codemap's is_internal check.\n+/// call to codemap's `is_internal` check.\n /// The expanded code uses the unstable `#[prelude_import]` attribute.\n fn ignored_span(sp: Span) -> Span {\n     let mark = Mark::fresh();\n@@ -49,7 +49,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<Strin\n         None => return krate,\n     };\n \n-    let crate_name = Symbol::intern(&alt_std_name.unwrap_or(name.to_string()));\n+    let crate_name = Symbol::intern(&alt_std_name.unwrap_or_else(|| name.to_string()));\n \n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![attr::mk_attr_outer(DUMMY_SP,"}, {"sha": "bb1a6ff65a596018a263bc7aa94e941e24da1b78", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -106,9 +106,8 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         // Add a special __test module to the crate that will contain code\n         // generated for the test harness\n         let (mod_, reexport) = mk_test_module(&mut self.cx);\n-        match reexport {\n-            Some(re) => folded.module.items.push(re),\n-            None => {}\n+        if let Some(re) = reexport {\n+            folded.module.items.push(re)\n         }\n         folded.module.items.push(mod_);\n         folded\n@@ -257,7 +256,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n     let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n     cx.ext_cx.current_expansion.mark = cx.ext_cx.resolver.get_module_scope(parent);\n     let it = cx.ext_cx.monotonic_expander().fold_item(P(ast::Item {\n-        ident: sym.clone(),\n+        ident: sym,\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ItemKind::Mod(reexport_mod),\n@@ -308,7 +307,7 @@ fn generate_test_harness(sess: &ParseSess,\n }\n \n /// Craft a span that will be ignored by the stability lint's\n-/// call to codemap's is_internal check.\n+/// call to codemap's `is_internal` check.\n /// The expanded code calls some unstable functions in the test crate.\n fn ignored_span(cx: &TestCtxt, sp: Span) -> Span {\n     Span { ctxt: cx.ctxt, ..sp }\n@@ -354,7 +353,7 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n         }\n     }\n \n-    return has_test_attr && has_test_signature(i) == Yes;\n+    has_test_attr && has_test_signature(i) == Yes\n }\n \n fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n@@ -385,7 +384,7 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n                       `fn(&mut Bencher) -> ()`\");\n     }\n \n-    return has_bench_attr && has_test_signature(i);\n+    has_bench_attr && has_test_signature(i)\n }\n \n fn is_ignored(i: &ast::Item) -> bool {\n@@ -504,16 +503,14 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n                            ast::Unsafety::Normal,\n                            dummy_spanned(ast::Constness::NotConst),\n                            ::abi::Abi::Rust, ast::Generics::default(), main_body);\n-    let main = P(ast::Item {\n+    P(ast::Item {\n         ident: Ident::from_str(\"main\"),\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n         vis: ast::Visibility::Public,\n         span: sp\n-    });\n-\n-    return main;\n+    })\n }\n \n fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {"}, {"sha": "9c1371a31fec7a9287f9f874c5d59defe042056e", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -10,16 +10,16 @@\n \n //! # Token Streams\n //!\n-//! TokenStreams represent syntactic objects before they are converted into ASTs.\n+//! `TokenStream`s represent syntactic objects before they are converted into ASTs.\n //! A `TokenStream` is, roughly speaking, a sequence (eg stream) of `TokenTree`s,\n //! which are themselves a single `Token` or a `Delimited` subsequence of tokens.\n //!\n //! ## Ownership\n-//! TokenStreams are persistent data structures constructed as ropes with reference\n-//! counted-children. In general, this means that calling an operation on a TokenStream\n-//! (such as `slice`) produces an entirely new TokenStream from the borrowed reference to\n-//! the original. This essentially coerces TokenStreams into 'views' of their subparts,\n-//! and a borrowed TokenStream is sufficient to build an owned TokenStream without taking\n+//! `TokenStreams` are persistent data structures constructed as ropes with reference\n+//! counted-children. In general, this means that calling an operation on a `TokenStream`\n+//! (such as `slice`) produces an entirely new `TokenStream` from the borrowed reference to\n+//! the original. This essentially coerces `TokenStream`s into 'views' of their subparts,\n+//! and a borrowed `TokenStream` is sufficient to build an owned `TokenStream` without taking\n //! ownership of the original.\n \n use syntax_pos::{BytePos, Span, DUMMY_SP};\n@@ -88,7 +88,7 @@ impl Delimited {\n /// If the syntax extension is an MBE macro, it will attempt to match its\n /// LHS token tree against the provided token tree, and if it finds a\n /// match, will transcribe the RHS token tree, splicing in any captured\n-/// macro_parser::matched_nonterminals into the `SubstNt`s it finds.\n+/// `macro_parser::matched_nonterminals` into the `SubstNt`s it finds.\n ///\n /// The RHS of an MBE macro is the only place `SubstNt`s are substituted.\n /// Nothing special happens to misnamed or misplaced `SubstNt`s."}, {"sha": "9307f3c58d4b0eb5d6942e9e8e6ee5ac23769688", "filename": "src/libsyntax/util/lev_distance.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Flev_distance.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -53,9 +53,10 @@ pub fn find_best_match_for_name<'a, T>(iter_names: T,\n     iter_names\n     .filter_map(|&name| {\n         let dist = lev_distance(lookup, &name.as_str());\n-        match dist <= max_dist {    // filter the unwanted cases\n-            true => Some((name, dist)),\n-            false => None,\n+        if dist <= max_dist {    // filter the unwanted cases\n+            Some((name, dist))\n+        } else {\n+            None\n         }\n     })\n     .min_by_key(|&(_, val)| val)    // extract the tuple containing the minimum edit distance"}, {"sha": "8cc37afa354ffbeed217349ae7d96cf01f1f0f28", "filename": "src/libsyntax/util/move_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Futil%2Fmove_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Futil%2Fmove_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fmove_map.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -37,10 +37,10 @@ impl<T> MoveMap<T> for Vec<T> {\n                 // move the read_i'th item out of the vector and map it\n                 // to an iterator\n                 let e = ptr::read(self.get_unchecked(read_i));\n-                let mut iter = f(e).into_iter();\n+                let iter = f(e).into_iter();\n                 read_i += 1;\n \n-                while let Some(e) = iter.next() {\n+                for e in iter {\n                     if write_i < read_i {\n                         ptr::write(self.get_unchecked_mut(write_i), e);\n                         write_i += 1;\n@@ -93,10 +93,10 @@ impl<T> MoveMap<T> for SmallVector<T> {\n                 // move the read_i'th item out of the vector and map it\n                 // to an iterator\n                 let e = ptr::read(self.get_unchecked(read_i));\n-                let mut iter = f(e).into_iter();\n+                let iter = f(e).into_iter();\n                 read_i += 1;\n \n-                while let Some(e) = iter.next() {\n+                for e in iter {\n                     if write_i < read_i {\n                         ptr::write(self.get_unchecked_mut(write_i), e);\n                         write_i += 1;"}, {"sha": "0fa0753b22c8298276987aa44eff0d5d6c39f5bd", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -27,6 +27,7 @@ use abi::Abi;\n use ast::*;\n use syntax_pos::Span;\n use codemap::Spanned;\n+use tokenstream::ThinTokenStream;\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n@@ -112,6 +113,9 @@ pub trait Visitor<'ast>: Sized {\n         // definition in your trait impl:\n         // visit::walk_mac(self, _mac)\n     }\n+    fn visit_mac_def(&mut self, _mac: &'ast ThinTokenStream, _id: NodeId) {\n+        // Nothing to do\n+    }\n     fn visit_path(&mut self, path: &'ast Path, _id: NodeId) {\n         walk_path(self, path)\n     }\n@@ -290,7 +294,7 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             walk_list!(visitor, visit_trait_item, methods);\n         }\n         ItemKind::Mac(ref mac) => visitor.visit_mac(mac),\n-        ItemKind::MacroDef(..) => {},\n+        ItemKind::MacroDef(ref ts) => visitor.visit_mac_def(ts, item.id),\n     }\n     walk_list!(visitor, visit_attribute, &item.attrs);\n }\n@@ -345,9 +349,7 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n             visitor.visit_ty(ty);\n             visitor.visit_expr(expression)\n         }\n-        TyKind::TraitObject(ref bounds) => {\n-            walk_list!(visitor, visit_ty_param_bound, bounds);\n-        }\n+        TyKind::TraitObject(ref bounds) |\n         TyKind::ImplTrait(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n@@ -542,7 +544,7 @@ pub fn walk_fn<'a, V>(visitor: &mut V, kind: FnKind<'a>, declaration: &'a FnDecl\n             walk_fn_decl(visitor, declaration);\n             visitor.visit_block(body);\n         }\n-        FnKind::Method(_, ref sig, _, body) => {\n+        FnKind::Method(_, sig, _, body) => {\n             visitor.visit_generics(&sig.generics);\n             walk_fn_decl(visitor, declaration);\n             visitor.visit_block(body);\n@@ -778,7 +780,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         }\n         ExprKind::InlineAsm(ref ia) => {\n             for &(_, ref input) in &ia.inputs {\n-                visitor.visit_expr(&input)\n+                visitor.visit_expr(input)\n             }\n             for output in &ia.outputs {\n                 visitor.visit_expr(&output.expr)"}, {"sha": "ef048ac8ca355f9ea0e43f3bc5c1cb9774de0fb4", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -542,6 +542,7 @@ struct ConsoleTestState<T> {\n     passed: usize,\n     failed: usize,\n     ignored: usize,\n+    filtered_out: usize,\n     measured: usize,\n     metrics: MetricMap,\n     failures: Vec<(TestDesc, Vec<u8>)>,\n@@ -570,6 +571,7 @@ impl<T: Write> ConsoleTestState<T> {\n             passed: 0,\n             failed: 0,\n             ignored: 0,\n+            filtered_out: 0,\n             measured: 0,\n             metrics: MetricMap::new(),\n             failures: Vec::new(),\n@@ -775,11 +777,12 @@ impl<T: Write> ConsoleTestState<T> {\n         } else {\n             self.write_pretty(\"FAILED\", term::color::RED)?;\n         }\n-        let s = format!(\". {} passed; {} failed; {} ignored; {} measured\\n\\n\",\n+        let s = format!(\". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n                         self.passed,\n                         self.failed,\n                         self.ignored,\n-                        self.measured);\n+                        self.measured,\n+                        self.filtered_out);\n         self.write_plain(&s)?;\n         return Ok(success);\n     }\n@@ -875,6 +878,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n     fn callback<T: Write>(event: &TestEvent, st: &mut ConsoleTestState<T>) -> io::Result<()> {\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n+            TeFilteredOut(filtered_out) => Ok(st.filtered_out = filtered_out),\n             TeWait(ref test, padding) => st.write_test_start(test, padding),\n             TeTimeout(ref test) => st.write_timeout(test),\n             TeResult(test, result, stdout) => {\n@@ -957,6 +961,7 @@ fn should_sort_failures_before_printing_them() {\n         passed: 0,\n         failed: 0,\n         ignored: 0,\n+        filtered_out: 0,\n         measured: 0,\n         max_name_len: 10,\n         metrics: MetricMap::new(),\n@@ -1017,6 +1022,7 @@ pub enum TestEvent {\n     TeWait(TestDesc, NamePadding),\n     TeResult(TestDesc, TestResult, Vec<u8>),\n     TeTimeout(TestDesc),\n+    TeFilteredOut(usize),\n }\n \n pub type MonitorMsg = (TestDesc, TestResult, Vec<u8>);\n@@ -1028,11 +1034,16 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n     use std::collections::HashMap;\n     use std::sync::mpsc::RecvTimeoutError;\n \n+    let tests_len = tests.len();\n+\n     let mut filtered_tests = filter_tests(opts, tests);\n     if !opts.bench_benchmarks {\n         filtered_tests = convert_benchmarks_to_tests(filtered_tests);\n     }\n \n+    let filtered_out = tests_len - filtered_tests.len();\n+    callback(TeFilteredOut(filtered_out))?;\n+\n     let filtered_descs = filtered_tests.iter()\n                                        .map(|t| t.desc.clone())\n                                        .collect();"}, {"sha": "2e6417f6af5218a29a8ee72ed17af085560b9b9c", "filename": "src/rust-installer", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frust-installer?ref=b69b6413afc770a8652096e8753d77eeb99b23bb", "patch": "@@ -1 +0,0 @@\n-Subproject commit 2e6417f6af5218a29a8ee72ed17af085560b9b9c"}, {"sha": "ddd8631f02e62b4c0f4974539847f41b7afadb9a", "filename": "src/test/compile-fail-fulldeps/proc-macro/resolve-error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fresolve-error.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -14,6 +14,7 @@\n // aux-build:bang_proc_macro.rs\n \n #![feature(proc_macro)]\n+#![allow(unused_macros)]\n \n #[macro_use]\n extern crate derive_foo;"}, {"sha": "5d7f33967402c217b27edb2b860b3c188e7179bb", "filename": "src/test/compile-fail/coherence-inherited-assoc-ty-cycle-err.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fcoherence-inherited-assoc-ty-cycle-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fcoherence-inherited-assoc-ty-cycle-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-inherited-assoc-ty-cycle-err.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Formerly this ICEd with the following message:\n+// Tried to project an inherited associated type during coherence checking,\n+// which is currently not supported.\n+//\n+// No we expect to run into a more user-friendly cycle error instead.\n+\n+#![feature(specialization)]\n+\n+trait Trait<T> { type Assoc; }\n+//~^ unsupported cyclic reference between types/traits detected [E0391]\n+\n+impl<T> Trait<T> for Vec<T> {\n+    type Assoc = ();\n+}\n+\n+impl Trait<u8> for Vec<u8> {}\n+\n+impl<T> Trait<T> for String {\n+    type Assoc = ();\n+}\n+\n+impl Trait<<Vec<u8> as Trait<u8>>::Assoc> for String {}\n+\n+fn main() {}"}, {"sha": "9af501b141955f97d777a210afcf40c1e0a4914e", "filename": "src/test/compile-fail/feature-gate-allow-internal-unstable-nested-macro.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-nested-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-nested-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable-nested-macro.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -10,6 +10,8 @@\n \n // gate-test-allow_internal_unstable\n \n+#![allow(unused_macros)]\n+\n macro_rules! bar {\n     () => {\n         // more layers don't help:"}, {"sha": "61a362cb37fb2c0d8d674447ba9af2b348bcf586", "filename": "src/test/compile-fail/feature-gate-allow-internal-unstable.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unstable.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(unused_macros)]\n+\n #[allow_internal_unstable] //~ ERROR allow_internal_unstable side-steps\n macro_rules! foo {\n     () => {}"}, {"sha": "d710f5647dd9f97591f57c0740993bc551b3e4c7", "filename": "src/test/compile-fail/invalid-macro-matcher.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Finvalid-macro-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Finvalid-macro-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finvalid-macro-matcher.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(unused_macros)]\n+\n macro_rules! invalid {\n     _ => (); //~ ERROR invalid macro matcher\n }"}, {"sha": "f66c09291cc9e4b74539de7bde5193c9f7310225", "filename": "src/test/compile-fail/issue-21356.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fissue-21356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fissue-21356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21356.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(unused_macros)]\n+\n macro_rules! test { ($wrong:t_ty ..) => () }\n                   //~^ ERROR: invalid fragment specifier `t_ty`\n "}, {"sha": "15eef429eab974667e3ea77daaada669acb10ccc", "filename": "src/test/compile-fail/issue-39388.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fissue-39388.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fissue-39388.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39388.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(unused_macros)]\n+\n macro_rules! assign {\n     (($($a:tt)*) = ($($b:tt))*) => { //~ ERROR expected `*` or `+`\n         $($a)* = $($b)*"}, {"sha": "8b49772494a6687e1f34a106ec6bb5ab4ed87b91", "filename": "src/test/compile-fail/issue-39404.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fissue-39404.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fissue-39404.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39404.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![deny(missing_fragment_specifier)] //~ NOTE lint level defined here\n+#![allow(unused_macros)]\n \n macro_rules! m { ($i) => {} }\n //~^ ERROR missing fragment specifier"}, {"sha": "5f108e0a1ed813565fb3df0bf38ba9083d8832f7", "filename": "src/test/compile-fail/issue-41776.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fissue-41776.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fissue-41776.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-41776.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    include!(line!()); //~ ERROR argument must be a string literal\n+}"}, {"sha": "267362f902d720faeed69655bb5cc382215bd4db", "filename": "src/test/compile-fail/issue-5067.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fissue-5067.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fissue-5067.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5067.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(unused_macros)]\n+\n macro_rules! foo {\n     ( $()* ) => {};\n     //~^ ERROR repetition matches empty token tree"}, {"sha": "06f2d86e5d9bae93be3b5e23dbeea9ba5d34aaa8", "filename": "src/test/compile-fail/macro-expansion-tests.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-expansion-tests.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(unused_macros)]\n+\n mod macros_cant_escape_fns {\n     fn f() {\n         macro_rules! m { () => { 3 + 4 } }"}, {"sha": "6e80e9b574bcfae9c3932c8551a2cecc5e621ad9", "filename": "src/test/compile-fail/macro-follow.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fmacro-follow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fmacro-follow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-follow.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -10,6 +10,8 @@\n //\n // Check the macro follow sets (see corresponding rpass test).\n \n+#![allow(unused_macros)]\n+\n // FOLLOW(pat) = {FatArrow, Comma, Eq, Or, Ident(if), Ident(in)}\n macro_rules! follow_pat {\n     ($p:pat ()) => {};       //~ERROR  `$p:pat` is followed by `(`"}, {"sha": "21cc946ded60563a48b5fa7ab8f713a841c23d98", "filename": "src/test/compile-fail/macro-followed-by-seq-bad.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fmacro-followed-by-seq-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fmacro-followed-by-seq-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-followed-by-seq-bad.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -11,6 +11,8 @@\n // Regression test for issue #25436: check that things which can be\n // followed by any token also permit X* to come afterwards.\n \n+#![allow(unused_macros)]\n+\n macro_rules! foo {\n   ( $a:expr $($b:tt)* ) => { }; //~ ERROR not allowed for `expr` fragments\n   ( $a:ty $($b:tt)* ) => { };   //~ ERROR not allowed for `ty` fragments"}, {"sha": "e5fdba63b0f152859c0a1f82614d57515b10716f", "filename": "src/test/compile-fail/macro-input-future-proofing.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fmacro-input-future-proofing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fmacro-input-future-proofing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-input-future-proofing.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(unused_macros)]\n+\n macro_rules! errors_everywhere {\n     ($ty:ty <) => (); //~ ERROR `$ty:ty` is followed by `<`, which is not allowed for `ty`\n     ($ty:ty < foo ,) => (); //~ ERROR `$ty:ty` is followed by `<`, which is not allowed for `ty`"}, {"sha": "f5e7305e4ea9e61ba37d0429cfe9a1f5e58d4ca5", "filename": "src/test/compile-fail/macro-shadowing.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fmacro-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fmacro-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-shadowing.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -10,6 +10,8 @@\n \n // aux-build:two_macros.rs\n \n+#![allow(unused_macros)]\n+\n macro_rules! foo { () => {} }\n macro_rules! macro_one { () => {} }\n #[macro_use(macro_two)] extern crate two_macros;"}, {"sha": "28a69e6f9e29beb5f900c78dbac33655681e0a95", "filename": "src/test/compile-fail/unused-macro-with-bad-frag-spec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Funused-macro-with-bad-frag-spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Funused-macro-with-bad-frag-spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-macro-with-bad-frag-spec.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(unused_macros)]\n+\n // Issue #21370\n \n macro_rules! test {"}, {"sha": "dda0d3fc9557dd79afd0b0e895691892a816af06", "filename": "src/test/compile-fail/unused-macro-with-follow-violation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Funused-macro-with-follow-violation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Funused-macro-with-follow-violation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-macro-with-follow-violation.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(unused_macros)]\n+\n macro_rules! test {\n     ($e:expr +) => () //~ ERROR not allowed for `expr` fragments\n }"}, {"sha": "5e401c09bda597ea340caae3faea955efec496b8", "filename": "src/test/compile-fail/unused-macro.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Funused-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Funused-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-macro.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(unused_macros)]\n+\n+// Most simple case\n+macro_rules! unused { //~ ERROR: unused macro definition\n+    () => {};\n+}\n+\n+// Test macros created by macros\n+macro_rules! create_macro {\n+    () => {\n+        macro_rules! m { //~ ERROR: unused macro definition\n+            () => {};\n+        }\n+    };\n+}\n+create_macro!();\n+\n+#[allow(unused_macros)]\n+mod bar {\n+    // Test that putting the #[deny] close to the macro's definition\n+    // works.\n+\n+    #[deny(unused_macros)]\n+    macro_rules! unused { //~ ERROR: unused macro definition\n+        () => {};\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "02e1a585fa89d054d267c206ca636f4ff4f5c093", "filename": "src/test/compile-fail/user-defined-macro-rules.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fuser-defined-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fcompile-fail%2Fuser-defined-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuser-defined-macro-rules.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,4 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(unused_macros)]\n+\n macro_rules! macro_rules { () => {} } //~ ERROR user-defined macros may not be named `macro_rules`"}, {"sha": "f4f9f92396f2c20d3fb822eba05b41b247cc116a", "filename": "src/test/debuginfo/multi-cgu.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fdebuginfo%2Fmulti-cgu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fdebuginfo%2Fmulti-cgu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmulti-cgu.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case makes sure that we get proper break points for binaries\n+// compiled with multiple codegen units. (see #39160)\n+\n+\n+// min-lldb-version: 310\n+\n+// compile-flags:-g -Ccodegen-units=2\n+\n+// === GDB TESTS ===============================================================\n+\n+// gdb-command:run\n+\n+// gdb-command:print xxx\n+// gdb-check:$1 = 12345\n+// gdb-command:continue\n+\n+// gdb-command:print yyy\n+// gdb-check:$2 = 67890\n+// gdb-command:continue\n+\n+\n+// === LLDB TESTS ==============================================================\n+\n+// lldb-command:run\n+\n+// lldb-command:print xxx\n+// lldb-check:[...]$0 = 12345\n+// lldb-command:continue\n+\n+// lldb-command:print yyy\n+// lldb-check:[...]$1 = 67890\n+// lldb-command:continue\n+\n+\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+\n+mod a {\n+    pub fn foo(xxx: u32) {\n+        super::_zzz(); // #break\n+    }\n+}\n+\n+mod b {\n+    pub fn bar(yyy: u64) {\n+        super::_zzz(); // #break\n+    }\n+}\n+\n+fn main() {\n+    a::foo(12345);\n+    b::bar(67890);\n+}\n+\n+#[inline(never)]\n+fn _zzz() {}"}, {"sha": "adc2b23441ef817355c6af0d2ff05a4cb878c388", "filename": "src/test/incremental/add_private_fn_at_krate_root_cc/auxiliary/point.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fauxiliary%2Fpoint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fauxiliary%2Fpoint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fadd_private_fn_at_krate_root_cc%2Fauxiliary%2Fpoint.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z incremental-cc\n-\n pub struct Point {\n     pub x: f32,\n     pub y: f32,"}, {"sha": "d802c9a8352eb675af47f076a0036fa7d2dc9ac8", "filename": "src/test/incremental/callee_caller_cross_crate/auxiliary/a.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fauxiliary%2Fa.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z incremental-cc\n-\n #![crate_type=\"rlib\"]\n \n #[cfg(rpass1)]"}, {"sha": "dcc1ced635fbf8b6a08a7c03410ef7eff95f2867", "filename": "src/test/incremental/change_private_fn_cc/auxiliary/point.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fauxiliary%2Fpoint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fauxiliary%2Fpoint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_fn_cc%2Fauxiliary%2Fpoint.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z incremental-cc\n-\n pub struct Point {\n     pub x: f32,\n     pub y: f32,"}, {"sha": "8df1cf54da2b97c3e34abb97abcba9b802f2b239", "filename": "src/test/incremental/change_private_impl_method_cc/auxiliary/point.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fauxiliary%2Fpoint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fauxiliary%2Fpoint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_private_impl_method_cc%2Fauxiliary%2Fpoint.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z incremental-cc\n-\n pub struct Point {\n     pub x: f32,\n     pub y: f32,"}, {"sha": "1483bf92c9708ec30bd567f7a37563c37f144ca2", "filename": "src/test/incremental/remapped_paths_cc/auxiliary/extern_crate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -10,7 +10,6 @@\n \n // ignore-tidy-linelength\n \n-// aux-build:extern_crate.rs\n //[rpass1] compile-flags: -g\n //[rpass2] compile-flags: -g\n //[rpass3] compile-flags: -g -Zremap-path-prefix-from={{src-base}} -Zremap-path-prefix-to=/the/src"}, {"sha": "be4764c7d9948288d25bc00493f4e5706a48dccd", "filename": "src/test/incremental/remapped_paths_cc/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // revisions:rpass1 rpass2 rpass3\n-// compile-flags: -Z query-dep-graph -g\n+// compile-flags: -Z query-dep-graph -g -Zincremental-cc\n // aux-build:extern_crate.rs\n \n "}, {"sha": "4d84e844dedbbc6ff84839eff5207d872072176d", "filename": "src/test/incremental/remove-private-item-cross-crate/auxiliary/a.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremove-private-item-cross-crate%2Fauxiliary%2Fa.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z incremental-cc\n-\n #![allow(warnings)]\n #![crate_name = \"a\"]\n #![crate_type = \"rlib\"]"}, {"sha": "ff5fd634714497bf53a38f11bc1aa323844a5a8c", "filename": "src/test/incremental/rlib_cross_crate/auxiliary/a.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z incremental-cc\n // no-prefer-dynamic\n \n #![crate_type=\"rlib\"]"}, {"sha": "2ddcaf157210dfef38201bad5d729743d5527db4", "filename": "src/test/incremental/struct_change_field_type_cross_crate/auxiliary/a.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fauxiliary%2Fa.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z incremental-cc\n-\n #![crate_type=\"rlib\"]\n \n  #[cfg(rpass1)]"}, {"sha": "e1dba1317703d6c448b969d1327a3884b8cc113c", "filename": "src/test/incremental/type_alias_cross_crate/auxiliary/a.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z incremental-cc\n-\n #![crate_type=\"rlib\"]\n \n #[cfg(rpass1)]"}, {"sha": "47eeffe35a83e81bc9c0a0dea74af798b38edaa9", "filename": "src/test/mir-opt/issue-41697.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fmir-opt%2Fissue-41697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fmir-opt%2Fissue-41697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41697.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags:-Zdump-mir=NEVER_MATCHED\n-\n // Regression test for #41697. Using dump-mir was triggering\n // artificial cycles: during type-checking, we had to get the MIR for\n // the constant expressions in `[u8; 2]`, which in turn would trigger", "previous_filename": "src/test/run-pass/issue-41697.rs"}, {"sha": "e96588c6e5aea6a3978b4ea67d4f46ed4d903d3a", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -15,6 +15,7 @@ extern crate rustc_driver;\n extern crate rustc_lint;\n extern crate rustc_metadata;\n extern crate rustc_errors;\n+extern crate rustc_trans;\n extern crate syntax;\n \n use rustc::dep_graph::DepGraph;\n@@ -58,8 +59,9 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n     let dep_graph = DepGraph::new(opts.build_dep_graph());\n-    let cstore = Rc::new(CStore::new(&dep_graph));\n+    let cstore = Rc::new(CStore::new(&dep_graph, Box::new(rustc_trans::LlvmMetadataLoader)));\n     let sess = build_session(opts, &dep_graph, None, descriptions, cstore.clone());\n+    rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     (sess, cstore)\n }"}, {"sha": "37aab2bbd059aa61579de5e914b41bdb71381abc", "filename": "src/test/run-make/llvm-pass/plugin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frun-make%2Fllvm-pass%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frun-make%2Fllvm-pass%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-pass%2Fplugin.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -14,6 +14,7 @@\n \n extern crate rustc;\n extern crate rustc_plugin;\n+extern crate rustc_trans;\n \n #[link(name = \"llvm-function-pass\", kind = \"static\")]\n #[link(name = \"llvm-module-pass\", kind = \"static\")]"}, {"sha": "0a4c15a9236b9bc6042b4f510b228a119aed5e95", "filename": "src/test/run-pass-fulldeps/issue-35829.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frun-pass-fulldeps%2Fissue-35829.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frun-pass-fulldeps%2Fissue-35829.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-35829.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage1\n+// ignore-cross-compile\n+#![feature(quote, rustc_private)]\n+\n+extern crate syntax;\n+\n+use syntax::ext::base::{ExtCtxt, DummyResolver};\n+use syntax::ext::expand::ExpansionConfig;\n+use syntax::parse::ParseSess;\n+use syntax::codemap::{FilePathMapping, dummy_spanned};\n+use syntax::print::pprust::expr_to_string;\n+use syntax::ast::{Expr, ExprKind, LitKind, StrStyle, RangeLimits};\n+use syntax::symbol::Symbol;\n+use syntax::ptr::P;\n+\n+use std::rc::Rc;\n+\n+fn main() {\n+    let parse_sess = ParseSess::new(FilePathMapping::empty());\n+    let exp_cfg = ExpansionConfig::default(\"issue_35829\".to_owned());\n+    let mut resolver = DummyResolver;\n+    let cx = ExtCtxt::new(&parse_sess, exp_cfg, &mut resolver);\n+\n+    // check byte string\n+    let byte_string = quote_expr!(&cx, b\"one\");\n+    let byte_string_lit_kind = LitKind::ByteStr(Rc::new(b\"one\".to_vec()));\n+    assert_eq!(byte_string.node, ExprKind::Lit(P(dummy_spanned(byte_string_lit_kind))));\n+\n+    // check raw byte string\n+    let raw_byte_string = quote_expr!(&cx, br###\"#\"two\"#\"###);\n+    let raw_byte_string_lit_kind = LitKind::ByteStr(Rc::new(b\"#\\\"two\\\"#\".to_vec()));\n+    assert_eq!(raw_byte_string.node, ExprKind::Lit(P(dummy_spanned(raw_byte_string_lit_kind))));\n+\n+    // check dotdotdot\n+    let closed_range = quote_expr!(&cx, 0 ... 1);\n+    assert_eq!(closed_range.node, ExprKind::Range(\n+        Some(quote_expr!(&cx, 0)),\n+        Some(quote_expr!(&cx, 1)),\n+        RangeLimits::Closed\n+    ));\n+\n+    // test case from 35829\n+    let expr_35829 = quote_expr!(&cx, std::io::stdout().write(b\"one\"));\n+    assert_eq!(expr_to_string(&expr_35829), r#\"std::io::stdout().write(b\"one\")\"#);\n+}"}, {"sha": "e7d0a83017be004c4128d318ea1978515e18ed22", "filename": "src/test/run-pass-fulldeps/macro-quote-1.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -17,11 +17,24 @@\n extern crate syntax;\n extern crate syntax_pos;\n \n-use syntax::ast::Ident;\n-use syntax::parse::token;\n+use syntax::ast::{Ident, Name};\n+use syntax::parse::token::{self, Token, Lit};\n use syntax::tokenstream::TokenTree;\n \n fn main() {\n     let true_tok = token::Ident(Ident::from_str(\"true\"));\n     assert!(quote!(true).eq_unspanned(&true_tok.into()));\n+\n+    // issue #35829, extended check to proc_macro.\n+    let triple_dot_tok = Token::DotDotDot;\n+    assert!(quote!(...).eq_unspanned(&triple_dot_tok.into()));\n+\n+    let byte_str_tok = Token::Literal(Lit::ByteStr(Name::intern(\"one\")), None);\n+    assert!(quote!(b\"one\").eq_unspanned(&byte_str_tok.into()));\n+\n+    let byte_str_raw_tok = Token::Literal(Lit::ByteStrRaw(Name::intern(\"#\\\"two\\\"#\"), 3), None);\n+    assert!(quote!(br###\"#\"two\"#\"###).eq_unspanned(&byte_str_raw_tok.into()));\n+\n+    let str_raw_tok = Token::Literal(Lit::StrRaw(Name::intern(\"#\\\"three\\\"#\"), 2), None);\n+    assert!(quote!(r##\"#\"three\"#\"##).eq_unspanned(&str_raw_tok.into()));\n }"}, {"sha": "e18b4204584e386c590720dc15ced0169a874355", "filename": "src/test/run-pass/issue-41803.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frun-pass%2Fissue-41803.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frun-pass%2Fissue-41803.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41803.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// A compile-time map from identifiers to arbitrary (heterogeneous) expressions\n+macro_rules! ident_map {\n+    ( $name:ident = { $($key:ident => $e:expr,)* } ) => {\n+        macro_rules! $name {\n+            $(\n+                ( $key ) => { $e };\n+            )*\n+            // Empty invocation expands to nothing. Needed when the map is empty.\n+            () => {};\n+        }\n+    };\n+}\n+\n+ident_map!(my_map = {\n+    main => 0,\n+});\n+\n+fn main() {\n+    my_map!(main);\n+}"}, {"sha": "bfbead87891784e123ba6ae6ad5dd5ff3f797e5d", "filename": "src/test/run-pass/issue-41936-variance-coerce-unsized-cycle.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frun-pass%2Fissue-41936-variance-coerce-unsized-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frun-pass%2Fissue-41936-variance-coerce-unsized-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41936-variance-coerce-unsized-cycle.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #41936. The coerce-unsized trait check in\n+// coherence was using subtyping, which triggered variance\n+// computation, which failed because it required type info for fields\n+// that had not (yet) been computed.\n+\n+#![feature(unsize)]\n+#![feature(coerce_unsized)]\n+\n+use std::{marker,ops};\n+\n+// Change the array to a non-array, and error disappears\n+// Adding a new field to the end keeps the error\n+struct LogDataBuf([u8;8]);\n+\n+struct Aref<T: ?Sized>\n+{\n+    // Inner structure triggers the error, removing the inner removes the message.\n+    ptr: Box<ArefInner<T>>,\n+}\n+impl<T: ?Sized + marker::Unsize<U>, U: ?Sized> ops::CoerceUnsized<Aref<U>> for Aref<T> {}\n+\n+struct ArefInner<T: ?Sized>\n+{\n+    // Even with this field commented out, the error is raised.\n+    data: T,\n+}\n+\n+fn main(){}"}, {"sha": "a65dcf33d85b1a2d77fba47eab0fcc3833c4358a", "filename": "src/test/run-pass/specialization/assoc-ty-graph-cycle.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frun-pass%2Fspecialization%2Fassoc-ty-graph-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frun-pass%2Fspecialization%2Fassoc-ty-graph-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fassoc-ty-graph-cycle.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure we don't crash with a cycle error during coherence.\n+\n+#![feature(specialization)]\n+\n+trait Trait<T> {\n+    type Assoc;\n+}\n+\n+impl<T> Trait<T> for Vec<T> {\n+    default type Assoc = ();\n+}\n+\n+impl Trait<u8> for Vec<u8> {\n+    type Assoc = u8;\n+}\n+\n+impl<T> Trait<T> for String {\n+    type Assoc = ();\n+}\n+\n+impl Trait<<Vec<u8> as Trait<u8>>::Assoc> for String {}\n+\n+fn main() {}"}, {"sha": "5c64b4118c3ab1a748e2175b3f74c82baa123efc", "filename": "src/test/rustdoc/extern-impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frustdoc%2Fextern-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frustdoc%2Fextern-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fextern-impl.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -18,9 +18,9 @@ impl Foo {\n     pub fn rust0() {}\n     // @has - '//code' 'fn rust1()'\n     pub extern \"Rust\" fn rust1() {}\n-    // @has - '//code' 'extern fn c0()'\n+    // @has - '//code' 'extern \"C\" fn c0()'\n     pub extern fn c0() {}\n-    // @has - '//code' 'extern fn c1()'\n+    // @has - '//code' 'extern \"C\" fn c1()'\n     pub extern \"C\" fn c1() {}\n     // @has - '//code' 'extern \"system\" fn system0()'\n     pub extern \"system\" fn system0() {}\n@@ -31,7 +31,7 @@ pub trait Bar {}\n \n // @has - '//code' 'impl Bar for fn()'\n impl Bar for fn() {}\n-// @has - '//code' 'impl Bar for extern fn()'\n+// @has - '//code' 'impl Bar for extern \"C\" fn()'\n impl Bar for extern fn() {}\n // @has - '//code' 'impl Bar for extern \"system\" fn()'\n impl Bar for extern \"system\" fn() {}"}, {"sha": "8511d461703de58dfc9cf656656f0ec2b1839e53", "filename": "src/test/rustdoc/ffi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frustdoc%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frustdoc%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fffi.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -13,10 +13,10 @@\n \n extern crate rustdoc_ffi as lib;\n \n-// @has ffi/fn.foreigner.html //pre 'pub unsafe extern fn foreigner(cold_as_ice: u32)'\n+// @has ffi/fn.foreigner.html //pre 'pub unsafe extern \"C\" fn foreigner(cold_as_ice: u32)'\n pub use lib::foreigner;\n \n extern \"C\" {\n-    // @has ffi/fn.another.html //pre 'pub unsafe extern fn another(cold_as_ice: u32)'\n+    // @has ffi/fn.another.html //pre 'pub unsafe extern \"C\" fn another(cold_as_ice: u32)'\n     pub fn another(cold_as_ice: u32);\n }"}, {"sha": "75df53589454f6d3927e8d8fc382d9f3b4f7fc9d", "filename": "src/test/rustdoc/issue-22038.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frustdoc%2Fissue-22038.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frustdoc%2Fissue-22038.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-22038.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -10,7 +10,7 @@\n \n extern {\n     // @has issue_22038/fn.foo1.html \\\n-    //      '//*[@class=\"rust fn\"]' 'pub unsafe extern fn foo1()'\n+    //      '//*[@class=\"rust fn\"]' 'pub unsafe extern \"C\" fn foo1()'\n     pub fn foo1();\n }\n \n@@ -21,7 +21,7 @@ extern \"system\" {\n }\n \n // @has issue_22038/fn.bar.html \\\n-//      '//*[@class=\"rust fn\"]' 'pub extern fn bar()'\n+//      '//*[@class=\"rust fn\"]' 'pub extern \"C\" fn bar()'\n pub extern fn bar() {}\n \n // @has issue_22038/fn.baz.html \\"}, {"sha": "6ba776ba4679f845c2dd9f3f880e586f7d056b34", "filename": "src/test/rustdoc/variadic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frustdoc%2Fvariadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Frustdoc%2Fvariadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fvariadic.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n extern \"C\" {\n-    // @has variadic/fn.foo.html //pre 'pub unsafe extern fn foo(x: i32, ...)'\n+    // @has variadic/fn.foo.html //pre 'pub unsafe extern \"C\" fn foo(x: i32, ...)'\n     pub fn foo(x: i32, ...);\n }"}, {"sha": "78e0f7e619b12791e7f52b917eb205959da36f9f", "filename": "src/test/ui/mismatched_types/issue-36053-2.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -4,7 +4,9 @@ error: no method named `count` found for type `std::iter::Filter<std::iter::Fuse\n 17 |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n    |                                                       ^^^^^\n    |\n-   = note: the method `count` exists but the following trait bounds were not satisfied: `[closure@$DIR/issue-36053-2.rs:17:39: 17:53] : std::ops::FnMut<(&_,)>`, `std::iter::Filter<std::iter::Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:17:39: 17:53]> : std::iter::Iterator`\n+   = note: the method `count` exists but the following trait bounds were not satisfied:\n+           `[closure@$DIR/issue-36053-2.rs:17:39: 17:53] : std::ops::FnMut<(&_,)>`\n+           `std::iter::Filter<std::iter::Fuse<std::iter::Once<&str>>, [closure@$DIR/issue-36053-2.rs:17:39: 17:53]> : std::iter::Iterator`\n \n error[E0281]: type mismatch: `[closure@$DIR/issue-36053-2.rs:17:39: 17:53]` implements the trait `for<'r> std::ops::FnMut<(&'r str,)>`, but the trait `for<'r> std::ops::FnMut<(&'r &str,)>` is required\n   --> $DIR/issue-36053-2.rs:17:32"}, {"sha": "a4eb4455551129a8d6c7e589acdedf8c0e8168e6", "filename": "src/test/ui/mismatched_types/method-help-unsatisfied-bound.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -14,5 +14,5 @@ fn main() {\n     let a: Result<(), Foo> = Ok(());\n     a.unwrap();\n     //~^ ERROR no method named `unwrap` found for type `std::result::Result<(), Foo>`\n-    //~| NOTE the following trait bounds were not satisfied: `Foo : std::fmt::Debug`\n+    //~| NOTE the method `unwrap` exists but the following trait bounds were not satisfied\n }", "previous_filename": "src/test/compile-fail/method-help-unsatisfied-bound.rs"}, {"sha": "2bd786c20fef0285d8050e44ab0eec7f1c1969d7", "filename": "src/test/ui/mismatched_types/method-help-unsatisfied-bound.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmethod-help-unsatisfied-bound.stderr?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1,11 @@\n+error: no method named `unwrap` found for type `std::result::Result<(), Foo>` in the current scope\n+  --> $DIR/method-help-unsatisfied-bound.rs:15:7\n+   |\n+15 |     a.unwrap();\n+   |       ^^^^^^\n+   |\n+   = note: the method `unwrap` exists but the following trait bounds were not satisfied:\n+           `Foo : std::fmt::Debug`\n+\n+error: aborting due to previous error\n+"}, {"sha": "397359840ecad02d5fe69b2a0cf328e98235ffea", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -1 +1 @@\n-Subproject commit 13d92c64d0153d95dbabeb49b828bbbef4b1bb34\n+Subproject commit 397359840ecad02d5fe69b2a0cf328e98235ffea"}, {"sha": "1b55dc792c2e5d1ec77182504fc4454acb151ca2", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 33, "deletions": 56, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -41,7 +41,7 @@ macro_rules! t {\n }\n \n fn main() {\n-    let docs = env::args().nth(1).unwrap();\n+    let docs = env::args_os().nth(1).unwrap();\n     let docs = env::current_dir().unwrap().join(docs);\n     let mut errors = false;\n     walk(&mut HashMap::new(), &docs, &docs, &mut errors);\n@@ -65,15 +65,14 @@ enum Redirect {\n struct FileEntry {\n     source: String,\n     ids: HashSet<String>,\n-    names: HashSet<String>,\n }\n \n type Cache = HashMap<PathBuf, FileEntry>;\n \n impl FileEntry {\n     fn parse_ids(&mut self, file: &Path, contents: &str, errors: &mut bool) {\n         if self.ids.is_empty() {\n-            with_attrs_in_source(contents, \" id\", |fragment, i| {\n+            with_attrs_in_source(contents, \" id\", |fragment, i, _| {\n                 let frag = fragment.trim_left_matches(\"#\").to_owned();\n                 if !self.ids.insert(frag) {\n                     *errors = true;\n@@ -82,15 +81,6 @@ impl FileEntry {\n             });\n         }\n     }\n-\n-    fn parse_names(&mut self, contents: &str) {\n-        if self.names.is_empty() {\n-            with_attrs_in_source(contents, \" name\", |fragment, _| {\n-                let frag = fragment.trim_left_matches(\"#\").to_owned();\n-                self.names.insert(frag);\n-            });\n-        }\n-    }\n }\n \n fn walk(cache: &mut Cache, root: &Path, dir: &Path, errors: &mut bool) {\n@@ -116,15 +106,8 @@ fn check(cache: &mut Cache,\n          file: &Path,\n          errors: &mut bool)\n          -> Option<PathBuf> {\n-    // ignore js files as they are not prone to errors as the rest of the\n-    // documentation is and they otherwise bring up false positives.\n-    if file.extension().and_then(|s| s.to_str()) == Some(\"js\") {\n-        return None;\n-    }\n-\n-    // ignore handlebars files as they use {{}} to build links, we only\n-    // want to test the generated files\n-    if file.extension().and_then(|s| s.to_str()) == Some(\"hbs\") {\n+    // Ignore none HTML files.\n+    if file.extension().and_then(|s| s.to_str()) != Some(\"html\") {\n         return None;\n     }\n \n@@ -147,13 +130,7 @@ fn check(cache: &mut Cache,\n         return None;\n     }\n \n-    // mdbook uses the HTML <base> tag to handle links for subdirectories, which\n-    // linkchecker doesn't support\n-    if file.to_str().unwrap().contains(\"unstable-book\") {\n-        return None;\n-    }\n-\n-    let res = load_file(cache, root, PathBuf::from(file), SkipRedirect);\n+    let res = load_file(cache, root, file, SkipRedirect);\n     let (pretty_file, contents) = match res {\n         Ok(res) => res,\n         Err(_) => return None,\n@@ -162,13 +139,10 @@ fn check(cache: &mut Cache,\n         cache.get_mut(&pretty_file)\n              .unwrap()\n              .parse_ids(&pretty_file, &contents, errors);\n-        cache.get_mut(&pretty_file)\n-             .unwrap()\n-             .parse_names(&contents);\n     }\n \n     // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n-    with_attrs_in_source(&contents, \" href\", |url, i| {\n+    with_attrs_in_source(&contents, \" href\", |url, i, base| {\n         // Ignore external URLs\n         if url.starts_with(\"http:\") || url.starts_with(\"https:\") ||\n            url.starts_with(\"javascript:\") || url.starts_with(\"ftp:\") ||\n@@ -184,9 +158,9 @@ fn check(cache: &mut Cache,\n         // Once we've plucked out the URL, parse it using our base url and\n         // then try to extract a file path.\n         let mut path = file.to_path_buf();\n-        if !url.is_empty() {\n+        if !base.is_empty() || !url.is_empty() {\n             path.pop();\n-            for part in Path::new(url).components() {\n+            for part in Path::new(base).join(url).components() {\n                 match part {\n                     Component::Prefix(_) |\n                     Component::RootDir => panic!(),\n@@ -197,13 +171,6 @@ fn check(cache: &mut Cache,\n             }\n         }\n \n-        if let Some(extension) = path.extension() {\n-            // don't check these files\n-            if extension == \"png\" {\n-                return;\n-            }\n-        }\n-\n         // Alright, if we've found a file name then this file had better\n         // exist! If it doesn't then we register and print an error.\n         if path.exists() {\n@@ -218,11 +185,17 @@ fn check(cache: &mut Cache,\n                          pretty_path.display());\n                 return;\n             }\n-            let res = load_file(cache, root, path.clone(), FromRedirect(false));\n+            if let Some(extension) = path.extension() {\n+                // Ignore none HTML files.\n+                if extension != \"html\" {\n+                    return;\n+                }\n+            }\n+            let res = load_file(cache, root, &path, FromRedirect(false));\n             let (pretty_path, contents) = match res {\n                 Ok(res) => res,\n                 Err(LoadError::IOError(err)) => {\n-                    panic!(format!(\"error loading {}: {}\", path.display(), err));\n+                    panic!(\"error loading {}: {}\", path.display(), err);\n                 }\n                 Err(LoadError::BrokenRedirect(target, _)) => {\n                     *errors = true;\n@@ -245,11 +218,10 @@ fn check(cache: &mut Cache,\n \n                 let entry = &mut cache.get_mut(&pretty_path).unwrap();\n                 entry.parse_ids(&pretty_path, &contents, errors);\n-                entry.parse_names(&contents);\n \n-                if !(entry.ids.contains(*fragment) || entry.names.contains(*fragment)) {\n+                if !entry.ids.contains(*fragment) {\n                     *errors = true;\n-                    print!(\"{}:{}: broken link fragment  \",\n+                    print!(\"{}:{}: broken link fragment \",\n                            pretty_file.display(),\n                            i + 1);\n                     println!(\"`#{}` pointing to `{}`\", fragment, pretty_path.display());\n@@ -267,7 +239,7 @@ fn check(cache: &mut Cache,\n \n fn load_file(cache: &mut Cache,\n              root: &Path,\n-             mut file: PathBuf,\n+             file: &Path,\n              redirect: Redirect)\n              -> Result<(PathBuf, String), LoadError> {\n     let mut contents = String::new();\n@@ -279,9 +251,9 @@ fn load_file(cache: &mut Cache,\n             None\n         }\n         Entry::Vacant(entry) => {\n-            let mut fp = File::open(file.clone()).map_err(|err| {\n+            let mut fp = File::open(file).map_err(|err| {\n                 if let FromRedirect(true) = redirect {\n-                    LoadError::BrokenRedirect(file.clone(), err)\n+                    LoadError::BrokenRedirect(file.to_path_buf(), err)\n                 } else {\n                     LoadError::IOError(err)\n                 }\n@@ -297,17 +269,14 @@ fn load_file(cache: &mut Cache,\n                 entry.insert(FileEntry {\n                     source: contents.clone(),\n                     ids: HashSet::new(),\n-                    names: HashSet::new(),\n                 });\n             }\n             maybe\n         }\n     };\n-    file.pop();\n-    match maybe_redirect.map(|url| file.join(url)) {\n+    match maybe_redirect.map(|url| file.parent().unwrap().join(url)) {\n         Some(redirect_file) => {\n-            let path = PathBuf::from(redirect_file);\n-            load_file(cache, root, path, FromRedirect(true))\n+            load_file(cache, root, &redirect_file, FromRedirect(true))\n         }\n         None => Ok((pretty_file, contents)),\n     }\n@@ -329,10 +298,14 @@ fn maybe_redirect(source: &str) -> Option<String> {\n     })\n }\n \n-fn with_attrs_in_source<F: FnMut(&str, usize)>(contents: &str, attr: &str, mut f: F) {\n+fn with_attrs_in_source<F: FnMut(&str, usize, &str)>(contents: &str, attr: &str, mut f: F) {\n+    let mut base = \"\";\n     for (i, mut line) in contents.lines().enumerate() {\n         while let Some(j) = line.find(attr) {\n             let rest = &line[j + attr.len()..];\n+            // The base tag should always be the first link in the document so\n+            // we can get away with using one pass.\n+            let is_base = line[..j].ends_with(\"<base\");\n             line = rest;\n             let pos_equals = match rest.find(\"=\") {\n                 Some(i) => i,\n@@ -358,7 +331,11 @@ fn with_attrs_in_source<F: FnMut(&str, usize)>(contents: &str, attr: &str, mut f\n                 Some(i) => &rest[..i],\n                 None => continue,\n             };\n-            f(url, i)\n+            if is_base {\n+                base = url;\n+                continue;\n+            }\n+            f(url, i, base)\n         }\n     }\n }"}, {"sha": "daa2a05ebe7b8d07a309e8891ebc548652362954", "filename": "src/tools/rust-installer", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -0,0 +1 @@\n+Subproject commit daa2a05ebe7b8d07a309e8891ebc548652362954"}, {"sha": "ba02ee0c6d73b7a39cfa9caf95695cec951b10f2", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -32,6 +32,7 @@ static EXCEPTIONS: &'static [&'static str] = &[\n     \"openssl\", // BSD+advertising clause, cargo, mdbook\n     \"pest\", // MPL2, mdbook via handlebars\n     \"thread-id\", // Apache-2.0, mdbook\n+    \"strings\", // this is actually MIT/Apache-2.0 but it's not in the manifest yet\n ];\n \n pub fn check(path: &Path, bad: &mut bool) {"}, {"sha": "6b666fa809f7a8cbfeb1d099ff25289eaed5834f", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55d75c42ef95f39c4c6f762bd22df33b94864153/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=55d75c42ef95f39c4c6f762bd22df33b94864153", "patch": "@@ -81,12 +81,12 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/libbacktrace\",\n         \"src/compiler-rt\",\n         \"src/rustllvm\",\n-        \"src/rust-installer\",\n         \"src/liblibc\",\n         \"src/vendor\",\n         \"src/rt/hoedown\",\n         \"src/tools/cargo\",\n         \"src/tools/rls\",\n+        \"src/tools/rust-installer\",\n     ];\n     skip.iter().any(|p| path.ends_with(p))\n }"}]}