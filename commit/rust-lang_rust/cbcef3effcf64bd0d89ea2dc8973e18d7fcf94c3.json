{"sha": "cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiY2VmM2VmZmNmNjRiZDBkODllYTJkYzg5NzNlMThkN2ZjZjk0YzM=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-06-11T14:49:57Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-08-14T16:34:30Z"}, "message": "Rework `rustc_serialize`\n\n- Move the type parameter from `encode` and `decode` methods to\n  the trait.\n- Remove `UseSpecialized(En|De)codable` traits.\n- Remove blanket impls for references.\n- Add `RefDecodable` trait to allow deserializing to arena-allocated\n  references safely.\n- Remove ability to (de)serialize HIR.\n- Create proc-macros `(Ty)?(En|De)codable` to help implement these new\n  traits.", "tree": {"sha": "cf11d5e77bdfe87b0a19d5f93ff251b256770325", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf11d5e77bdfe87b0a19d5f93ff251b256770325"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "html_url": "https://github.com/rust-lang/rust/commit/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55b9adfafa11b2ced5c0477c949fd875b19b3877", "url": "https://api.github.com/repos/rust-lang/rust/commits/55b9adfafa11b2ced5c0477c949fd875b19b3877", "html_url": "https://github.com/rust-lang/rust/commit/55b9adfafa11b2ced5c0477c949fd875b19b3877"}], "stats": {"total": 3844, "additions": 1907, "deletions": 1937}, "files": [{"sha": "564c3da522342071c4d87781d69d96a7e18aa0ff", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -3334,6 +3334,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_incremental\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n@@ -3364,6 +3365,7 @@ dependencies = [\n  \"rustc-rayon-core\",\n  \"rustc_graphviz\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_serialize\",\n  \"smallvec 1.4.0\",\n  \"stable_deref_trait\",\n@@ -3416,6 +3418,7 @@ dependencies = [\n  \"annotate-snippets 0.8.0\",\n  \"atty\",\n  \"rustc_data_structures\",\n+ \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"termcolor\",\n@@ -3437,6 +3440,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_lexer\",\n+ \"rustc_macros\",\n  \"rustc_parse\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n@@ -3499,6 +3503,7 @@ dependencies = [\n  \"rustc_fs_util\",\n  \"rustc_graphviz\",\n  \"rustc_hir\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n@@ -3511,6 +3516,7 @@ name = \"rustc_index\"\n version = \"0.0.0\"\n dependencies = [\n  \"arrayvec 0.5.1\",\n+ \"rustc_macros\",\n  \"rustc_serialize\",\n ]\n \n@@ -3640,6 +3646,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_hir_pretty\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n  \"rustc_session\",\n@@ -3815,6 +3822,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"smallvec 1.4.0\",\n@@ -3884,6 +3892,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_fs_util\",\n+ \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\","}, {"sha": "6dff02486ff197a0d58a178b19a0c0d46758fe43", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 119, "deletions": 119, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -53,7 +53,7 @@ mod tests;\n /// ```\n ///\n /// `'outer` is a label.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Copy, HashStable_Generic)]\n pub struct Label {\n     pub ident: Ident,\n }\n@@ -66,7 +66,7 @@ impl fmt::Debug for Label {\n \n /// A \"Lifetime\" is an annotation of the scope in which variable\n /// can be used, e.g. `'a` in `&'a i32`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, Encodable, Decodable, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -90,7 +90,7 @@ impl fmt::Display for Lifetime {\n /// along with a bunch of supporting information.\n ///\n /// E.g., `std::cmp::PartialEq`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Path {\n     pub span: Span,\n     /// The segments in the path: the things separated by `::`.\n@@ -128,7 +128,7 @@ impl Path {\n /// A segment of a path: an identifier, an optional lifetime, and a set of types.\n ///\n /// E.g., `std`, `String` or `Box<T>`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub ident: Ident,\n@@ -156,7 +156,7 @@ impl PathSegment {\n /// The arguments of a path segment.\n ///\n /// E.g., `<A, B>` as in `Foo<A, B>` or `(A, B)` as in `Foo(A, B)`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum GenericArgs {\n     /// The `<'a, A, B, C>` in `foo::bar::baz::<'a, A, B, C>`.\n     AngleBracketed(AngleBracketedArgs),\n@@ -188,7 +188,7 @@ impl GenericArgs {\n }\n \n /// Concrete argument in the sequence of generic args.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum GenericArg {\n     /// `'a` in `Foo<'a>`\n     Lifetime(Lifetime),\n@@ -209,7 +209,7 @@ impl GenericArg {\n }\n \n /// A path like `Foo<'a, T>`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default)]\n+#[derive(Clone, Encodable, Decodable, Debug, Default)]\n pub struct AngleBracketedArgs {\n     /// The overall span.\n     pub span: Span,\n@@ -219,7 +219,7 @@ pub struct AngleBracketedArgs {\n \n /// Either an argument for a parameter e.g., `'a`, `Vec<u8>`, `0`,\n /// or a constraint on an associated item, e.g., `Item = String` or `Item: Bound`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AngleBracketedArg {\n     /// Argument for a generic parameter.\n     Arg(GenericArg),\n@@ -240,7 +240,7 @@ impl Into<Option<P<GenericArgs>>> for ParenthesizedArgs {\n }\n \n /// A path like `Foo(A, B) -> C`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct ParenthesizedArgs {\n     /// Overall span\n     pub span: Span,\n@@ -269,7 +269,7 @@ pub use crate::node_id::{NodeId, CRATE_NODE_ID, DUMMY_NODE_ID};\n /// A modifier on a bound, e.g., `?Sized` or `?const Trait`.\n ///\n /// Negative bounds should also be handled here.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug)]\n pub enum TraitBoundModifier {\n     /// No modifiers\n     None,\n@@ -290,7 +290,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum GenericBound {\n     Trait(PolyTraitRef, TraitBoundModifier),\n     Outlives(Lifetime),\n@@ -357,7 +357,7 @@ impl fmt::Display for ParamKindOrd {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum GenericParamKind {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime,\n@@ -371,7 +371,7 @@ pub enum GenericParamKind {\n     },\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct GenericParam {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -383,7 +383,7 @@ pub struct GenericParam {\n \n /// Represents lifetime, type and const parameters attached to a declaration of\n /// a function, enum, trait, etc.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Generics {\n     pub params: Vec<GenericParam>,\n     pub where_clause: WhereClause,\n@@ -406,7 +406,7 @@ impl Default for Generics {\n }\n \n /// A where-clause in a definition.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct WhereClause {\n     /// `true` if we ate a `where` token: this can happen\n     /// if we parsed no predicates (e.g. `struct Foo where {}`).\n@@ -418,7 +418,7 @@ pub struct WhereClause {\n }\n \n /// A single predicate in a where-clause.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum WherePredicate {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n     BoundPredicate(WhereBoundPredicate),\n@@ -441,7 +441,7 @@ impl WherePredicate {\n /// A type bound.\n ///\n /// E.g., `for<'c> Foo: Send + Clone + 'c`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n@@ -455,7 +455,7 @@ pub struct WhereBoundPredicate {\n /// A lifetime predicate.\n ///\n /// E.g., `'a: 'b + 'c`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n@@ -465,15 +465,15 @@ pub struct WhereRegionPredicate {\n /// An equality predicate (unsupported).\n ///\n /// E.g., `T = int`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n     pub span: Span,\n     pub lhs_ty: P<Ty>,\n     pub rhs_ty: P<Ty>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n@@ -490,7 +490,7 @@ pub struct Crate {\n /// Possible values inside of compile-time attribute lists.\n ///\n /// E.g., the '..' in `#[name(..)]`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum NestedMetaItem {\n     /// A full MetaItem, for recursive meta items.\n     MetaItem(MetaItem),\n@@ -503,7 +503,7 @@ pub enum NestedMetaItem {\n /// A spanned compile-time attribute item.\n ///\n /// E.g., `#[test]`, `#[derive(..)]`, `#[rustfmt::skip]` or `#[feature = \"foo\"]`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct MetaItem {\n     pub path: Path,\n     pub kind: MetaItemKind,\n@@ -513,7 +513,7 @@ pub struct MetaItem {\n /// A compile-time attribute item.\n ///\n /// E.g., `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MetaItemKind {\n     /// Word meta item.\n     ///\n@@ -532,7 +532,7 @@ pub enum MetaItemKind {\n /// A block (`{ .. }`).\n ///\n /// E.g., `{ .. }` as in `fn foo() { .. }`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Block {\n     /// The statements in the block.\n     pub stmts: Vec<Stmt>,\n@@ -545,7 +545,7 @@ pub struct Block {\n /// A match pattern.\n ///\n /// Patterns appear in match statements and some other contexts, such as `let` and `if let`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Pat {\n     pub id: NodeId,\n     pub kind: PatKind,\n@@ -636,7 +636,7 @@ impl Pat {\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except is_shorthand is true\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FieldPat {\n     /// The identifier for the field\n     pub ident: Ident,\n@@ -649,27 +649,27 @@ pub struct FieldPat {\n     pub is_placeholder: bool,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n pub enum BindingMode {\n     ByRef(Mutability),\n     ByValue(Mutability),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum RangeEnd {\n     Included(RangeSyntax),\n     Excluded,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum RangeSyntax {\n     /// `...`\n     DotDotDot,\n     /// `..=`\n     DotDotEq,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum PatKind {\n     /// Represents a wildcard pattern (`_`).\n     Wild,\n@@ -736,8 +736,8 @@ pub enum PatKind {\n     MacCall(MacCall),\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug, Copy)]\n-#[derive(HashStable_Generic)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Copy)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum Mutability {\n     Mut,\n     Not,\n@@ -770,7 +770,7 @@ impl Mutability {\n /// The kind of borrow in an `AddrOf` expression,\n /// e.g., `&place` or `&raw const place`.\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum BorrowKind {\n     /// A normal borrow, `&$expr` or `&mut $expr`.\n     /// The resulting type is either `&'a T` or `&'a mut T`\n@@ -782,7 +782,7 @@ pub enum BorrowKind {\n     Raw,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n pub enum BinOpKind {\n     /// The `+` operator (addition)\n     Add,\n@@ -881,7 +881,7 @@ pub type BinOp = Spanned<BinOpKind>;\n /// Unary operator.\n ///\n /// Note that `&data` is not an operator, it's an `AddrOf` expression.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, Encodable, Decodable, Debug, Copy)]\n pub enum UnOp {\n     /// The `*` operator for dereferencing\n     Deref,\n@@ -910,7 +910,7 @@ impl UnOp {\n }\n \n /// A statement\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Stmt {\n     pub id: NodeId,\n     pub kind: StmtKind,\n@@ -944,7 +944,7 @@ impl Stmt {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum StmtKind {\n     /// A local (let) binding.\n     Local(P<Local>),\n@@ -960,7 +960,7 @@ pub enum StmtKind {\n     MacCall(P<(MacCall, MacStmtStyle, AttrVec)>),\n }\n \n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug)]\n pub enum MacStmtStyle {\n     /// The macro statement had a trailing semicolon (e.g., `foo! { ... };`\n     /// `foo!(...);`, `foo![...];`).\n@@ -974,7 +974,7 @@ pub enum MacStmtStyle {\n }\n \n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Local {\n     pub id: NodeId,\n     pub pat: P<Pat>,\n@@ -995,7 +995,7 @@ pub struct Local {\n ///     _ => { println!(\"no match!\") },\n /// }\n /// ```\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n     /// Match arm pattern, e.g. `10` in `match foo { 10 => {}, _ => {} }`\n@@ -1010,7 +1010,7 @@ pub struct Arm {\n }\n \n /// Access of a named (e.g., `obj.foo`) or unnamed (e.g., `obj.0`) struct field.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Field {\n     pub attrs: AttrVec,\n     pub id: NodeId,\n@@ -1021,13 +1021,13 @@ pub struct Field {\n     pub is_placeholder: bool,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n pub enum BlockCheckMode {\n     Default,\n     Unsafe(UnsafeSource),\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n@@ -1038,14 +1038,14 @@ pub enum UnsafeSource {\n /// These are usually found nested inside types (e.g., array lengths)\n /// or expressions (e.g., repeat counts), and also used to define\n /// explicit discriminant values for enum variants.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct AnonConst {\n     pub id: NodeId,\n     pub value: P<Expr>,\n }\n \n /// An expression.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Expr {\n     pub id: NodeId,\n     pub kind: ExprKind,\n@@ -1204,15 +1204,15 @@ impl Expr {\n }\n \n /// Limit types of a range (inclusive or exclusive)\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Decodable, Debug)]\n pub enum RangeLimits {\n     /// Inclusive at the beginning, exclusive at the end\n     HalfOpen,\n     /// Inclusive at the beginning and end\n     Closed,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n@@ -1369,7 +1369,7 @@ pub enum ExprKind {\n ///  ^~~~~    ^\n ///  ty       position = 0\n /// ```\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct QSelf {\n     pub ty: P<Ty>,\n \n@@ -1381,7 +1381,7 @@ pub struct QSelf {\n }\n \n /// A capture clause used in closures and `async` blocks.\n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum CaptureBy {\n     /// `move |x| y + x`.\n     Value,\n@@ -1391,7 +1391,7 @@ pub enum CaptureBy {\n \n /// The movability of a generator / closure literal:\n /// whether a generator contains self-references, causing it to be `!Unpin`.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable, Debug, Copy)]\n #[derive(HashStable_Generic)]\n pub enum Movability {\n     /// May contain self-references, `!Unpin`.\n@@ -1402,7 +1402,7 @@ pub enum Movability {\n \n /// Represents a macro invocation. The `path` indicates which macro\n /// is being invoked, and the `args` are arguments passed to it.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct MacCall {\n     pub path: Path,\n     pub args: P<MacArgs>,\n@@ -1416,7 +1416,7 @@ impl MacCall {\n }\n \n /// Arguments passed to an attribute or a function-like macro.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MacArgs {\n     /// No arguments - `#[attr]`.\n     Empty,\n@@ -1477,7 +1477,7 @@ impl MacArgs {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MacDelimiter {\n     Parenthesis,\n     Bracket,\n@@ -1504,14 +1504,14 @@ impl MacDelimiter {\n }\n \n /// Represents a macro definition.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct MacroDef {\n     pub body: P<MacArgs>,\n     /// `true` if macro was defined with `macro_rules`.\n     pub macro_rules: bool,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, Eq, PartialEq)]\n+#[derive(Clone, Encodable, Decodable, Debug, Copy, Hash, Eq, PartialEq)]\n #[derive(HashStable_Generic)]\n pub enum StrStyle {\n     /// A regular string, like `\"foo\"`.\n@@ -1523,7 +1523,7 @@ pub enum StrStyle {\n }\n \n /// An AST literal.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct Lit {\n     /// The original literal token as written in source code.\n     pub token: token::Lit,\n@@ -1535,7 +1535,7 @@ pub struct Lit {\n }\n \n /// Same as `Lit`, but restricted to string literals.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub struct StrLit {\n     /// The original literal token as written in source code.\n     pub style: StrStyle,\n@@ -1562,7 +1562,7 @@ impl StrLit {\n }\n \n /// Type of the integer literal based on provided suffix.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, Hash, Eq, PartialEq)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug, Hash, Eq, PartialEq)]\n #[derive(HashStable_Generic)]\n pub enum LitIntType {\n     /// e.g. `42_i32`.\n@@ -1574,7 +1574,7 @@ pub enum LitIntType {\n }\n \n /// Type of the float literal based on provided suffix.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, Hash, Eq, PartialEq)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug, Hash, Eq, PartialEq)]\n #[derive(HashStable_Generic)]\n pub enum LitFloatType {\n     /// A float literal with a suffix (`1f32` or `1E10f32`).\n@@ -1586,7 +1586,7 @@ pub enum LitFloatType {\n /// Literal kind.\n ///\n /// E.g., `\"foo\"`, `42`, `12.34`, or `bool`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Hash, Eq, PartialEq, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, Hash, Eq, PartialEq, HashStable_Generic)]\n pub enum LitKind {\n     /// A string literal (`\"foo\"`).\n     Str(Symbol, StrStyle),\n@@ -1658,22 +1658,22 @@ impl LitKind {\n \n // N.B., If you change this, you'll probably want to change the corresponding\n // type structure in `middle/ty.rs` as well.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct MutTy {\n     pub ty: P<Ty>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a function's signature in a trait declaration,\n /// trait implementation, or free function.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FnSig {\n     pub header: FnHeader,\n     pub decl: P<FnDecl>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum FloatTy {\n     F32,\n     F64,\n@@ -1702,8 +1702,8 @@ impl FloatTy {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum IntTy {\n     Isize,\n     I8,\n@@ -1767,8 +1767,8 @@ impl IntTy {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Copy, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Debug)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum UintTy {\n     Usize,\n     U8,\n@@ -1831,7 +1831,7 @@ impl UintTy {\n \n /// A constraint on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n /// `A: TraitA + TraitB` in `Foo<A: TraitA + TraitB>`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct AssocTyConstraint {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -1840,22 +1840,22 @@ pub struct AssocTyConstraint {\n }\n \n /// The kinds of an `AssocTyConstraint`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AssocTyConstraintKind {\n     /// E.g., `A = Bar` in `Foo<A = Bar>`.\n     Equality { ty: P<Ty> },\n     /// E.g. `A: TraitA + TraitB` in `Foo<A: TraitA + TraitB>`.\n     Bound { bounds: GenericBounds },\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Ty {\n     pub id: NodeId,\n     pub kind: TyKind,\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct BareFnTy {\n     pub unsafety: Unsafe,\n     pub ext: Extern,\n@@ -1864,7 +1864,7 @@ pub struct BareFnTy {\n }\n \n /// The various kinds of type recognized by the compiler.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum TyKind {\n     /// A variable-length slice (`[T]`).\n     Slice(P<Ty>),\n@@ -1923,7 +1923,7 @@ impl TyKind {\n }\n \n /// Syntax used to declare a trait object.\n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug)]\n pub enum TraitObjectSyntax {\n     Dyn,\n     None,\n@@ -1932,14 +1932,14 @@ pub enum TraitObjectSyntax {\n /// Inline assembly operand explicit register or register class.\n ///\n /// E.g., `\"eax\"` as in `asm!(\"mov eax, 2\", out(\"eax\") result)`.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub enum InlineAsmRegOrRegClass {\n     Reg(Symbol),\n     RegClass(Symbol),\n }\n \n bitflags::bitflags! {\n-    #[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+    #[derive(Encodable, Decodable, HashStable_Generic)]\n     pub struct InlineAsmOptions: u8 {\n         const PURE = 1 << 0;\n         const NOMEM = 1 << 1;\n@@ -1951,7 +1951,7 @@ bitflags::bitflags! {\n     }\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum InlineAsmTemplatePiece {\n     String(String),\n     Placeholder { operand_idx: usize, modifier: Option<char>, span: Span },\n@@ -1995,7 +1995,7 @@ impl InlineAsmTemplatePiece {\n /// Inline assembly operand.\n ///\n /// E.g., `out(\"eax\") result` as in `asm!(\"mov eax, 2\", out(\"eax\") result)`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum InlineAsmOperand {\n     In {\n         reg: InlineAsmRegOrRegClass,\n@@ -2028,7 +2028,7 @@ pub enum InlineAsmOperand {\n /// Inline assembly.\n ///\n /// E.g., `asm!(\"NOP\");`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct InlineAsm {\n     pub template: Vec<InlineAsmTemplatePiece>,\n     pub operands: Vec<(InlineAsmOperand, Span)>,\n@@ -2039,7 +2039,7 @@ pub struct InlineAsm {\n /// Inline assembly dialect.\n ///\n /// E.g., `\"intel\"` as in `llvm_asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy, HashStable_Generic)]\n pub enum LlvmAsmDialect {\n     Att,\n     Intel,\n@@ -2048,7 +2048,7 @@ pub enum LlvmAsmDialect {\n /// LLVM-style inline assembly.\n ///\n /// E.g., `\"={eax}\"(result)` as in `llvm_asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct LlvmInlineAsmOutput {\n     pub constraint: Symbol,\n     pub expr: P<Expr>,\n@@ -2059,7 +2059,7 @@ pub struct LlvmInlineAsmOutput {\n /// LLVM-style inline assembly.\n ///\n /// E.g., `llvm_asm!(\"NOP\");`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct LlvmInlineAsm {\n     pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n@@ -2074,7 +2074,7 @@ pub struct LlvmInlineAsm {\n /// A parameter in a function header.\n ///\n /// E.g., `bar: usize` as in `fn foo(bar: usize)`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Param {\n     pub attrs: AttrVec,\n     pub ty: P<Ty>,\n@@ -2087,7 +2087,7 @@ pub struct Param {\n /// Alternative representation for `Arg`s describing `self` parameter of methods.\n ///\n /// E.g., `&mut self` as in `fn foo(&mut self)`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum SelfKind {\n     /// `self`, `mut self`\n     Value(Mutability),\n@@ -2165,7 +2165,7 @@ impl Param {\n ///\n /// Please note that it's different from `FnHeader` structure\n /// which contains metadata about function safety, asyncness, constness and ABI.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct FnDecl {\n     pub inputs: Vec<Param>,\n     pub output: FnRetTy,\n@@ -2187,20 +2187,20 @@ impl FnDecl {\n }\n \n /// Is the trait definition an auto trait?\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum IsAuto {\n     Yes,\n     No,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable, Debug)]\n #[derive(HashStable_Generic)]\n pub enum Unsafe {\n     Yes(Span),\n     No,\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug)]\n pub enum Async {\n     Yes { span: Span, closure_id: NodeId, return_impl_trait_id: NodeId },\n     No,\n@@ -2220,7 +2220,7 @@ impl Async {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Encodable, Decodable, Debug)]\n #[derive(HashStable_Generic)]\n pub enum Const {\n     Yes(Span),\n@@ -2229,13 +2229,13 @@ pub enum Const {\n \n /// Item defaultness.\n /// For details see the [RFC #2532](https://github.com/rust-lang/rfcs/pull/2532).\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum Defaultness {\n     Default(Span),\n     Final,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub enum ImplPolarity {\n     /// `impl Trait for Type`\n     Positive,\n@@ -2252,7 +2252,7 @@ impl fmt::Debug for ImplPolarity {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum FnRetTy {\n     /// Returns type is not specified.\n     ///\n@@ -2275,7 +2275,7 @@ impl FnRetTy {\n /// Module declaration.\n ///\n /// E.g., `mod foo;` or `mod foo { .. }`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default)]\n+#[derive(Clone, Encodable, Decodable, Debug, Default)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -2289,7 +2289,7 @@ pub struct Mod {\n /// Foreign module declaration.\n ///\n /// E.g., `extern { .. }` or `extern C { .. }`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct ForeignMod {\n     pub abi: Option<StrLit>,\n     pub items: Vec<P<ForeignItem>>,\n@@ -2298,17 +2298,17 @@ pub struct ForeignMod {\n /// Global inline assembly.\n ///\n /// Also known as \"module-level assembly\" or \"file-scoped assembly\".\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, Encodable, Decodable, Debug, Copy)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct EnumDef {\n     pub variants: Vec<Variant>,\n }\n /// Enum variant.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Variant {\n     /// Attributes of the variant.\n     pub attrs: Vec<Attribute>,\n@@ -2330,7 +2330,7 @@ pub struct Variant {\n }\n \n /// Part of `use` item to the right of its prefix.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum UseTreeKind {\n     /// `use prefix` or `use prefix as rename`\n     ///\n@@ -2345,7 +2345,7 @@ pub enum UseTreeKind {\n \n /// A tree of paths sharing common prefixes.\n /// Used in `use` items both at top-level and inside of braces in import groups.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct UseTree {\n     pub prefix: Path,\n     pub kind: UseTreeKind,\n@@ -2367,7 +2367,7 @@ impl UseTree {\n /// Distinguishes between `Attribute`s that decorate items and Attributes that\n /// are contained as statements within items. These two cases need to be\n /// distinguished for pretty-printing.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy, HashStable_Generic)]\n pub enum AttrStyle {\n     Outer,\n     Inner,\n@@ -2380,19 +2380,19 @@ rustc_index::newtype_index! {\n     }\n }\n \n-impl rustc_serialize::Encodable for AttrId {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> rustc_serialize::Encodable<S> for AttrId {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_unit()\n     }\n }\n \n-impl rustc_serialize::Decodable for AttrId {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<AttrId, D::Error> {\n+impl<D: Decoder> rustc_serialize::Decodable<D> for AttrId {\n+    fn decode(d: &mut D) -> Result<AttrId, D::Error> {\n         d.read_nil().map(|_| crate::attr::mk_attr_id())\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct AttrItem {\n     pub path: Path,\n     pub args: MacArgs,\n@@ -2402,7 +2402,7 @@ pub struct AttrItem {\n pub type AttrVec = ThinVec<Attribute>;\n \n /// Metadata associated with an item.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Attribute {\n     pub kind: AttrKind,\n     pub id: AttrId,\n@@ -2412,7 +2412,7 @@ pub struct Attribute {\n     pub span: Span,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AttrKind {\n     /// A normal attribute.\n     Normal(AttrItem),\n@@ -2429,13 +2429,13 @@ pub enum AttrKind {\n /// that the `ref_id` is for. The `impl_id` maps to the \"self type\" of this impl.\n /// If this impl is an `ItemKind::Impl`, the `impl_id` is redundant (it could be the\n /// same as the impl's `NodeId`).\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct TraitRef {\n     pub path: Path,\n     pub ref_id: NodeId,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`.\n     pub bound_generic_params: Vec<GenericParam>,\n@@ -2456,7 +2456,7 @@ impl PolyTraitRef {\n     }\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum CrateSugar {\n     /// Source is `pub(crate)`.\n     PubCrate,\n@@ -2467,7 +2467,7 @@ pub enum CrateSugar {\n \n pub type Visibility = Spanned<VisibilityKind>;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum VisibilityKind {\n     Public,\n     Crate(CrateSugar),\n@@ -2484,7 +2484,7 @@ impl VisibilityKind {\n /// Field of a struct.\n ///\n /// E.g., `bar: usize` as in `struct Foo { bar: usize }`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct StructField {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n@@ -2497,7 +2497,7 @@ pub struct StructField {\n }\n \n /// Fields and constructor ids of enum variants and structs.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum VariantData {\n     /// Struct variant.\n     ///\n@@ -2532,7 +2532,7 @@ impl VariantData {\n }\n \n /// An item definition.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct Item<K = ItemKind> {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n@@ -2569,7 +2569,7 @@ impl<K: Into<ItemKind>> Item<K> {\n }\n \n /// `extern` qualifier on a function item or function type.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub enum Extern {\n     None,\n     Implicit,\n@@ -2586,7 +2586,7 @@ impl Extern {\n ///\n /// All the information between the visibility and the name of the function is\n /// included in this struct (e.g., `async unsafe fn` or `const extern \"C\" fn`).\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub struct FnHeader {\n     pub unsafety: Unsafe,\n     pub asyncness: Async,\n@@ -2616,7 +2616,7 @@ impl Default for FnHeader {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ItemKind {\n     /// An `extern crate` item, with the optional *original* crate name if the crate was renamed.\n     ///\n@@ -2755,7 +2755,7 @@ pub type AssocItem = Item<AssocItemKind>;\n /// In an implementation, all items must be provided.\n /// The `Option`s below denote the bodies, where `Some(_)`\n /// means \"provided\" and conversely `None` means \"required\".\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum AssocItemKind {\n     /// An associated constant, `const $ident: $ty $def?;` where `def ::= \"=\" $expr? ;`.\n     /// If `def` is parsed, then the constant is provided, and otherwise required.\n@@ -2803,7 +2803,7 @@ impl TryFrom<ItemKind> for AssocItemKind {\n }\n \n /// An item in `extern` block.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ForeignItemKind {\n     /// A foreign static item (`static FOO: u8`).\n     Static(P<Ty>, Mutability, Option<P<Expr>>),"}, {"sha": "bd7d85167140dfe4e28a712edf85a4d17dfbf8dc", "filename": "src/librustc_ast/crate_disambiguator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_ast%2Fcrate_disambiguator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_ast%2Fcrate_disambiguator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fcrate_disambiguator.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -9,7 +9,7 @@ use std::fmt;\n /// Hash value constructed out of all the `-C metadata` arguments passed to the\n /// compiler. Together with the crate-name forms a unique global identifier for\n /// the crate.\n-#[derive(Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Clone, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Clone, Copy, Encodable, Decodable)]\n pub struct CrateDisambiguator(Fingerprint);\n \n impl CrateDisambiguator {"}, {"sha": "fb5ce3118262782fc9e264f47a1264fd9f0d7f96", "filename": "src/librustc_ast/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_ast%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_ast%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Flib.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -18,8 +18,7 @@\n #![feature(unicode_internals)]\n #![recursion_limit = \"256\"]\n \n-// FIXME(#56935): Work around ICEs during cross-compilation.\n-#[allow(unused)]\n+#[macro_use]\n extern crate rustc_macros;\n \n #[macro_export]"}, {"sha": "1035e945538f5b10136b7b4547f8728ed9c6a646", "filename": "src/librustc_ast/node_id.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_ast%2Fnode_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_ast%2Fnode_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fnode_id.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -1,10 +1,8 @@\n-use rustc_serialize::{Decoder, Encoder};\n use rustc_span::ExpnId;\n use std::fmt;\n \n rustc_index::newtype_index! {\n     pub struct NodeId {\n-        ENCODABLE = custom\n         DEBUG_FORMAT = \"NodeId({})\"\n     }\n }\n@@ -34,15 +32,3 @@ impl fmt::Display for NodeId {\n         fmt::Display::fmt(&self.as_u32(), f)\n     }\n }\n-\n-impl rustc_serialize::UseSpecializedEncodable for NodeId {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u32(self.as_u32())\n-    }\n-}\n-\n-impl rustc_serialize::UseSpecializedDecodable for NodeId {\n-    fn default_decode<D: Decoder>(d: &mut D) -> Result<NodeId, D::Error> {\n-        d.read_u32().map(NodeId::from_u32)\n-    }\n-}"}, {"sha": "e4a3cccb7ead1c9c30efed20cb687f30759fac55", "filename": "src/librustc_ast/ptr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_ast%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_ast%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fptr.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -114,14 +114,14 @@ impl<T> fmt::Pointer for P<T> {\n     }\n }\n \n-impl<T: 'static + Decodable> Decodable for P<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<P<T>, D::Error> {\n+impl<D: Decoder, T: 'static + Decodable<D>> Decodable<D> for P<T> {\n+    fn decode(d: &mut D) -> Result<P<T>, D::Error> {\n         Decodable::decode(d).map(P)\n     }\n }\n \n-impl<T: Encodable> Encodable for P<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for P<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n@@ -197,14 +197,14 @@ impl<'a, T> IntoIterator for &'a P<[T]> {\n     }\n }\n \n-impl<T: Encodable> Encodable for P<[T]> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for P<[T]> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         Encodable::encode(&**self, s)\n     }\n }\n \n-impl<T: Decodable> Decodable for P<[T]> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<P<[T]>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for P<[T]> {\n+    fn decode(d: &mut D) -> Result<P<[T]>, D::Error> {\n         Ok(P::from_vec(Decodable::decode(d)?))\n     }\n }"}, {"sha": "46c4be0a33bf76af3b9ae1e8e287ac4792bda563", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -17,13 +17,13 @@ use rustc_span::{self, Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::{fmt, mem};\n \n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum CommentKind {\n     Line,\n     Block,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Hash, Debug, Copy)]\n #[derive(HashStable_Generic)]\n pub enum BinOpToken {\n     Plus,\n@@ -39,7 +39,7 @@ pub enum BinOpToken {\n }\n \n /// A delimiter token.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Debug, Copy)]\n #[derive(HashStable_Generic)]\n pub enum DelimToken {\n     /// A round parenthesis (i.e., `(` or `)`).\n@@ -62,7 +62,7 @@ impl DelimToken {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum LitKind {\n     Bool, // AST only, must never appear in a `Token`\n     Byte,\n@@ -77,7 +77,7 @@ pub enum LitKind {\n }\n \n /// A literal token.\n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct Lit {\n     pub kind: LitKind,\n     pub symbol: Symbol,\n@@ -188,7 +188,7 @@ fn ident_can_begin_type(name: Symbol, span: Span, is_raw: bool) -> bool {\n             .contains(&name)\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum TokenKind {\n     /* Expression-operator symbols. */\n     Eq,\n@@ -267,7 +267,7 @@ pub enum TokenKind {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(TokenKind, 16);\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct Token {\n     pub kind: TokenKind,\n     pub span: Span,\n@@ -688,7 +688,7 @@ impl PartialEq<TokenKind> for Token {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Encodable, Decodable)]\n /// For interpolation during macro expansion.\n pub enum Nonterminal {\n     NtItem(P<ast::Item>),\n@@ -711,7 +711,7 @@ pub enum Nonterminal {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(Nonterminal, 40);\n \n-#[derive(Debug, Copy, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, PartialEq, Encodable, Decodable)]\n pub enum NonterminalKind {\n     Item,\n     Block,"}, {"sha": "151acddae840e567c171362311ce6813f6603c5b", "filename": "src/librustc_ast/tokenstream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_ast%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_ast%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftokenstream.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -35,7 +35,7 @@ use std::{iter, mem};\n ///\n /// The RHS of an MBE macro is the only place `SubstNt`s are substituted.\n /// Nothing special happens to misnamed or misplaced `SubstNt`s.\n-#[derive(Debug, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Debug, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub enum TokenTree {\n     /// A single token\n     Token(Token),\n@@ -124,7 +124,7 @@ where\n /// The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s\n /// instead of a representation of the abstract syntax tree.\n /// Today's `TokenTree`s can still contain AST via `token::Interpolated` for back-compat.\n-#[derive(Clone, Debug, Default, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Default, Encodable, Decodable)]\n pub struct TokenStream(pub Lrc<Vec<TreeAndJoint>>);\n \n pub type TreeAndJoint = (TokenTree, IsJoint);\n@@ -133,7 +133,7 @@ pub type TreeAndJoint = (TokenTree, IsJoint);\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(TokenStream, 8);\n \n-#[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Encodable, Decodable)]\n pub enum IsJoint {\n     Joint,\n     NonJoint,\n@@ -408,7 +408,7 @@ impl Cursor {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub struct DelimSpan {\n     pub open: Span,\n     pub close: Span,"}, {"sha": "3ddabcc17f8b696a86e088e2cd9fd8430e398993", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -67,15 +67,15 @@ fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n     }\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Encodable, Decodable)]\n pub enum InlineAttr {\n     None,\n     Hint,\n     Always,\n     Never,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Encodable, Decodable)]\n pub enum OptimizeAttr {\n     None,\n     Speed,\n@@ -130,15 +130,15 @@ pub fn find_unwind_attr(sess: &Session, attrs: &[Attribute]) -> Option<UnwindAtt\n ///\n /// - `#[stable]`\n /// - `#[unstable]`\n-#[derive(RustcEncodable, RustcDecodable, Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Encodable, Decodable, Copy, Clone, Debug, PartialEq, Eq, Hash)]\n #[derive(HashStable_Generic)]\n pub struct Stability {\n     pub level: StabilityLevel,\n     pub feature: Symbol,\n }\n \n /// Represents the `#[rustc_const_unstable]` and `#[rustc_const_stable]` attributes.\n-#[derive(RustcEncodable, RustcDecodable, Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Encodable, Decodable, Copy, Clone, Debug, PartialEq, Eq, Hash)]\n #[derive(HashStable_Generic)]\n pub struct ConstStability {\n     pub level: StabilityLevel,\n@@ -150,7 +150,7 @@ pub struct ConstStability {\n }\n \n /// The available stability levels.\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Copy, Clone, Debug, Eq, Hash)]\n+#[derive(Encodable, Decodable, PartialEq, PartialOrd, Copy, Clone, Debug, Eq, Hash)]\n #[derive(HashStable_Generic)]\n pub enum StabilityLevel {\n     // Reason for the current stability level and the relevant rust-lang issue\n@@ -632,7 +632,7 @@ pub fn eval_condition(\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Clone, HashStable_Generic)]\n+#[derive(Encodable, Decodable, Clone, HashStable_Generic)]\n pub struct Deprecation {\n     pub since: Option<Symbol>,\n     /// The note to issue a reason.\n@@ -797,7 +797,7 @@ where\n     depr\n }\n \n-#[derive(PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n+#[derive(PartialEq, Debug, Encodable, Decodable, Copy, Clone)]\n pub enum ReprAttr {\n     ReprInt(IntType),\n     ReprC,\n@@ -808,7 +808,8 @@ pub enum ReprAttr {\n     ReprNoNiche,\n }\n \n-#[derive(Eq, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, Clone, HashStable_Generic)]\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum IntType {\n     SignedInt(ast::IntTy),\n     UnsignedInt(ast::UintTy),"}, {"sha": "149a950f7d417ca3977f15c5bacd141ab5863176", "filename": "src/librustc_attr/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_attr%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_attr%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Flib.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -6,8 +6,7 @@\n \n #![feature(or_patterns)]\n \n-// FIXME(#56935): Work around ICEs during cross-compilation.\n-#[allow(unused)]\n+#[macro_use]\n extern crate rustc_macros;\n \n mod builtin;"}, {"sha": "ff9dac372ab956911fd6fcf3124318ef4af12f38", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -33,5 +33,6 @@ rustc_fs_util = { path = \"../librustc_fs_util\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_index = { path = \"../librustc_index\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "5100ef8ad4fd7cb5ab7590c6284c19c0bc59debd", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -35,7 +35,7 @@ pub fn disable_localization(linker: &mut Command) {\n \n /// For all the linkers we support, and information they might\n /// need out of the shared crate context before we get rid of it.\n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Encodable, Decodable)]\n pub struct LinkerInfo {\n     exports: FxHashMap<CrateType, Vec<String>>,\n }"}, {"sha": "6bfbda0f1d7f29d1c21ff75c8e610ee5e1cf8303", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -16,6 +16,8 @@\n //! The backend-agnostic functions of this crate use functions defined in various traits that\n //! have to be implemented by each backends.\n \n+#[macro_use]\n+extern crate rustc_macros;\n #[macro_use]\n extern crate log;\n #[macro_use]\n@@ -74,7 +76,7 @@ impl<M> ModuleCodegen<M> {\n     }\n }\n \n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Encodable, Decodable)]\n pub struct CompiledModule {\n     pub name: String,\n     pub kind: ModuleKind,\n@@ -87,7 +89,7 @@ pub struct CachedModuleCodegen {\n     pub source: WorkProduct,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Encodable, Decodable)]\n pub enum ModuleKind {\n     Regular,\n     Metadata,\n@@ -110,7 +112,7 @@ bitflags::bitflags! {\n /// identifiers (`CrateNum`) to `CrateSource`. The other fields map `CrateNum` to the crate's own\n /// additional properties, so that effectively we can retrieve each dependent crate's `CrateSource`\n /// and the corresponding properties without referencing information outside of a `CrateInfo`.\n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Encodable, Decodable)]\n pub struct CrateInfo {\n     pub panic_runtime: Option<CrateNum>,\n     pub compiler_builtins: Option<CrateNum>,\n@@ -128,7 +130,7 @@ pub struct CrateInfo {\n     pub dependency_formats: Lrc<Dependencies>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Encodable, Decodable)]\n pub struct CodegenResults {\n     pub crate_name: Symbol,\n     pub modules: Vec<CompiledModule>,"}, {"sha": "1926dbf06e726aa50e37a9b001d3873602bb0d47", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -17,6 +17,7 @@ jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }\n lazy_static = \"1\"\n once_cell = { version = \"1\", features = [\"parking_lot\"] }\n rustc_serialize = { path = \"../librustc_serialize\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_graphviz = { path = \"../librustc_graphviz\" }\n cfg-if = \"0.1.2\"\n crossbeam-utils = { version = \"0.7\", features = [\"nightly\"] }"}, {"sha": "f8d631ce01e78139b7dd6c11abc9229a51b76813", "filename": "src/librustc_data_structures/fingerprint.rs", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_data_structures%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_data_structures%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffingerprint.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -1,5 +1,8 @@\n use crate::stable_hasher;\n-use rustc_serialize::opaque::{Decoder, EncodeResult, Encoder};\n+use rustc_serialize::{\n+    opaque::{self, EncodeResult},\n+    Decodable, Encodable,\n+};\n use std::mem;\n \n #[derive(Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Clone, Copy)]\n@@ -49,14 +52,14 @@ impl Fingerprint {\n         format!(\"{:x}{:x}\", self.0, self.1)\n     }\n \n-    pub fn encode_opaque(&self, encoder: &mut Encoder) -> EncodeResult {\n+    pub fn encode_opaque(&self, encoder: &mut opaque::Encoder) -> EncodeResult {\n         let bytes: [u8; 16] = unsafe { mem::transmute([self.0.to_le(), self.1.to_le()]) };\n \n         encoder.emit_raw_bytes(&bytes);\n         Ok(())\n     }\n \n-    pub fn decode_opaque(decoder: &mut Decoder<'_>) -> Result<Fingerprint, String> {\n+    pub fn decode_opaque(decoder: &mut opaque::Decoder<'_>) -> Result<Fingerprint, String> {\n         let mut bytes = [0; 16];\n \n         decoder.read_raw_bytes(&mut bytes)?;\n@@ -83,18 +86,45 @@ impl stable_hasher::StableHasherResult for Fingerprint {\n \n impl_stable_hash_via_hash!(Fingerprint);\n \n-impl rustc_serialize::UseSpecializedEncodable for Fingerprint {}\n+impl<E: rustc_serialize::Encoder> Encodable<E> for Fingerprint {\n+    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n+        s.encode_fingerprint(self)\n+    }\n+}\n \n-impl rustc_serialize::UseSpecializedDecodable for Fingerprint {}\n+impl<D: rustc_serialize::Decoder> Decodable<D> for Fingerprint {\n+    fn decode(d: &mut D) -> Result<Self, D::Error> {\n+        d.decode_fingerprint()\n+    }\n+}\n \n-impl rustc_serialize::SpecializedEncoder<Fingerprint> for Encoder {\n-    fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n+pub trait FingerprintEncoder: rustc_serialize::Encoder {\n+    fn encode_fingerprint(&mut self, f: &Fingerprint) -> Result<(), Self::Error>;\n+}\n+\n+pub trait FingerprintDecoder: rustc_serialize::Decoder {\n+    fn decode_fingerprint(&mut self) -> Result<Fingerprint, Self::Error>;\n+}\n+\n+impl<E: rustc_serialize::Encoder> FingerprintEncoder for E {\n+    default fn encode_fingerprint(&mut self, _: &Fingerprint) -> Result<(), E::Error> {\n+        panic!(\"Cannot encode `Fingerprint` with `{}`\", std::any::type_name::<E>());\n+    }\n+}\n+\n+impl FingerprintEncoder for opaque::Encoder {\n+    fn encode_fingerprint(&mut self, f: &Fingerprint) -> EncodeResult {\n         f.encode_opaque(self)\n     }\n }\n \n-impl<'a> rustc_serialize::SpecializedDecoder<Fingerprint> for Decoder<'a> {\n-    fn specialized_decode(&mut self) -> Result<Fingerprint, Self::Error> {\n+impl<D: rustc_serialize::Decoder> FingerprintDecoder for D {\n+    default fn decode_fingerprint(&mut self) -> Result<Fingerprint, D::Error> {\n+        panic!(\"Cannot decode `Fingerprint` with `{}`\", std::any::type_name::<D>());\n+    }\n+}\n+impl FingerprintDecoder for opaque::Decoder<'_> {\n+    fn decode_fingerprint(&mut self) -> Result<Fingerprint, String> {\n         Fingerprint::decode_opaque(self)\n     }\n }"}, {"sha": "017511cc50d20fd1498ea16a208e2e76f17d91d8", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -29,6 +29,8 @@\n extern crate log;\n #[macro_use]\n extern crate cfg_if;\n+#[macro_use]\n+extern crate rustc_macros;\n \n #[inline(never)]\n #[cold]"}, {"sha": "856eb73e6297a79ac5cc48051fb241080baab0c9", "filename": "src/librustc_data_structures/sorted_map.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_data_structures%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_data_structures%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -16,18 +16,7 @@ pub use index_map::SortedIndexMultiMap;\n /// stores data in a more compact way. It also supports accessing contiguous\n /// ranges of elements as a slice, and slices of already sorted elements can be\n /// inserted efficiently.\n-#[derive(\n-    Clone,\n-    PartialEq,\n-    Eq,\n-    PartialOrd,\n-    Ord,\n-    Hash,\n-    Default,\n-    Debug,\n-    RustcEncodable,\n-    RustcDecodable\n-)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default, Debug, Encodable, Decodable)]\n pub struct SortedMap<K: Ord, V> {\n     data: Vec<(K, V)>,\n }"}, {"sha": "02103de2e8df913d15a8ca458cce1b3e4d7d39c8", "filename": "src/librustc_data_structures/svh.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_data_structures%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_data_structures%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsvh.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -48,14 +48,14 @@ impl fmt::Display for Svh {\n     }\n }\n \n-impl Encodable for Svh {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for Svh {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u64(self.as_u64().to_le())\n     }\n }\n \n-impl Decodable for Svh {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Svh, D::Error> {\n+impl<D: Decoder> Decodable<D> for Svh {\n+    fn decode(d: &mut D) -> Result<Svh, D::Error> {\n         d.read_u64().map(u64::from_le).map(Svh::new)\n     }\n }"}, {"sha": "4d673fd5cf98307ddc40b1e96779a6cbabb5e819", "filename": "src/librustc_data_structures/thin_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_data_structures%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_data_structures%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fthin_vec.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -3,7 +3,7 @@ use crate::stable_hasher::{HashStable, StableHasher};\n /// A vector type optimized for cases where this size is usually 0 (cf. `SmallVector`).\n /// The `Option<Box<..>>` wrapping allows us to represent a zero sized vector with `None`,\n /// which uses only a single (null) pointer.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug)]\n pub struct ThinVec<T>(Option<Box<Vec<T>>>);\n \n impl<T> ThinVec<T> {"}, {"sha": "fe60a99dde07205f2b88c1d5a35c9c5df1d15292", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 2, "deletions": 67, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -1,8 +1,6 @@\n use crate::fx::FxIndexSet;\n-use crate::stable_hasher::{HashStable, StableHasher};\n use crate::sync::Lock;\n use rustc_index::bit_set::BitMatrix;\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::mem;\n@@ -42,10 +40,10 @@ impl<T: Eq + Hash> Default for TransitiveRelation<T> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]\n struct Index(usize);\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n struct Edge {\n     source: Index,\n     target: Index,\n@@ -402,66 +400,3 @@ fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix<usize, usize>) {\n         candidates.truncate(j - dead);\n     }\n }\n-\n-impl<T> Encodable for TransitiveRelation<T>\n-where\n-    T: Clone + Encodable + Debug + Eq + Hash + Clone,\n-{\n-    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_struct(\"TransitiveRelation\", 2, |s| {\n-            s.emit_struct_field(\"elements\", 0, |s| self.elements.encode(s))?;\n-            s.emit_struct_field(\"edges\", 1, |s| self.edges.encode(s))?;\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<T> Decodable for TransitiveRelation<T>\n-where\n-    T: Clone + Decodable + Debug + Eq + Hash + Clone,\n-{\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n-        d.read_struct(\"TransitiveRelation\", 2, |d| {\n-            Ok(TransitiveRelation {\n-                elements: d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?,\n-                edges: d.read_struct_field(\"edges\", 1, |d| Decodable::decode(d))?,\n-                closure: Lock::new(None),\n-            })\n-        })\n-    }\n-}\n-\n-impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n-where\n-    T: HashStable<CTX> + Eq + Debug + Clone + Hash,\n-{\n-    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        // We are assuming here that the relation graph has been built in a\n-        // deterministic way and we can just hash it the way it is.\n-        let TransitiveRelation {\n-            ref elements,\n-            ref edges,\n-            // \"closure\" is just a copy of the data above\n-            closure: _,\n-        } = *self;\n-\n-        elements.hash_stable(hcx, hasher);\n-        edges.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for Edge {\n-    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        let Edge { ref source, ref target } = *self;\n-\n-        source.hash_stable(hcx, hasher);\n-        target.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<CTX> HashStable<CTX> for Index {\n-    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        let Index(idx) = *self;\n-        idx.hash_stable(hcx, hasher);\n-    }\n-}"}, {"sha": "c17d61dae9faf2be4791631abd44e9ec04b6457a", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -13,6 +13,7 @@ doctest = false\n log = { package = \"tracing\", version = \"0.1\" }\n rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_span = { path = \"../librustc_span\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n unicode-width = \"0.1.4\"\n atty = \"0.2\""}, {"sha": "cd4b5d56f36e6e7190a075aee564a8bc31e3ebb5", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -9,7 +9,7 @@ use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n \n #[must_use]\n-#[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub struct Diagnostic {\n     pub level: Level,\n     pub message: Vec<(String, Style)>,\n@@ -24,14 +24,14 @@ pub struct Diagnostic {\n     pub sort_span: Span,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n pub enum DiagnosticId {\n     Error(String),\n     Lint(String),\n }\n \n /// For example a note attached to an error.\n-#[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub struct SubDiagnostic {\n     pub level: Level,\n     pub message: Vec<(String, Style)>,"}, {"sha": "750d36d3d891a2804c116894187c1764c38a8dba", "filename": "src/librustc_errors/json.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_errors%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_errors%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fjson.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -145,7 +145,7 @@ impl Emitter for JsonEmitter {\n \n // The following data types are provided just for serialisation.\n \n-#[derive(RustcEncodable)]\n+#[derive(Encodable)]\n struct Diagnostic {\n     /// The primary error message.\n     message: String,\n@@ -159,7 +159,7 @@ struct Diagnostic {\n     rendered: Option<String>,\n }\n \n-#[derive(RustcEncodable)]\n+#[derive(Encodable)]\n struct DiagnosticSpan {\n     file_name: String,\n     byte_start: u32,\n@@ -186,7 +186,7 @@ struct DiagnosticSpan {\n     expansion: Option<Box<DiagnosticSpanMacroExpansion>>,\n }\n \n-#[derive(RustcEncodable)]\n+#[derive(Encodable)]\n struct DiagnosticSpanLine {\n     text: String,\n \n@@ -196,7 +196,7 @@ struct DiagnosticSpanLine {\n     highlight_end: usize,\n }\n \n-#[derive(RustcEncodable)]\n+#[derive(Encodable)]\n struct DiagnosticSpanMacroExpansion {\n     /// span where macro was applied to generate this code; note that\n     /// this may itself derive from a macro (if\n@@ -210,15 +210,15 @@ struct DiagnosticSpanMacroExpansion {\n     def_site_span: DiagnosticSpan,\n }\n \n-#[derive(RustcEncodable)]\n+#[derive(Encodable)]\n struct DiagnosticCode {\n     /// The code itself.\n     code: String,\n     /// An explanation for the code.\n     explanation: Option<&'static str>,\n }\n \n-#[derive(RustcEncodable)]\n+#[derive(Encodable)]\n struct ArtifactNotification<'a> {\n     /// The path of the artifact.\n     artifact: &'a Path,"}, {"sha": "e69e868c8ede5fa413a3588540e81f13ee47a94e", "filename": "src/librustc_errors/json/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_errors%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_errors%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fjson%2Ftests.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -10,12 +10,12 @@ use rustc_span::{BytePos, Span};\n \n use std::str;\n \n-#[derive(RustcDecodable, Debug, PartialEq, Eq)]\n+#[derive(Decodable, Debug, PartialEq, Eq)]\n struct TestData {\n     spans: Vec<SpanTestData>,\n }\n \n-#[derive(RustcDecodable, Debug, PartialEq, Eq)]\n+#[derive(Decodable, Debug, PartialEq, Eq)]\n struct SpanTestData {\n     pub byte_start: u32,\n     pub byte_end: u32,"}, {"sha": "98e9972530ebd1d0c17a722a6151af22d1f62d4b", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -6,6 +6,9 @@\n #![feature(crate_visibility_modifier)]\n #![feature(nll)]\n \n+#[macro_use]\n+extern crate rustc_macros;\n+\n pub use emitter::ColorConfig;\n \n use log::debug;\n@@ -50,7 +53,7 @@ rustc_data_structures::static_assert_size!(PResult<'_, bool>, 16);\n /// All suggestions are marked with an `Applicability`. Tools use the applicability of a suggestion\n /// to determine whether it should be automatically applied or if the user should be consulted\n /// before applying the suggestion.\n-#[derive(Copy, Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub enum Applicability {\n     /// The suggestion is definitely what the user intended. This suggestion should be\n     /// automatically applied.\n@@ -69,7 +72,7 @@ pub enum Applicability {\n     Unspecified,\n }\n \n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, Encodable, Decodable)]\n pub enum SuggestionStyle {\n     /// Hide the suggested code when displaying this suggestion inline.\n     HideCodeInline,\n@@ -94,7 +97,7 @@ impl SuggestionStyle {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub struct CodeSuggestion {\n     /// Each substitute can have multiple variants due to multiple\n     /// applicable suggestions\n@@ -129,13 +132,13 @@ pub struct CodeSuggestion {\n     pub applicability: Applicability,\n }\n \n-#[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n /// See the docs on `CodeSuggestion::substitutions`\n pub struct Substitution {\n     pub parts: Vec<SubstitutionPart>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub struct SubstitutionPart {\n     pub span: Span,\n     pub snippet: String,\n@@ -943,7 +946,7 @@ impl HandlerInner {\n     }\n }\n \n-#[derive(Copy, PartialEq, Clone, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, PartialEq, Clone, Hash, Debug, Encodable, Decodable)]\n pub enum Level {\n     Bug,\n     Fatal,\n@@ -1012,7 +1015,7 @@ macro_rules! pluralize {\n \n // Useful type to use with `Result<>` indicate that an error has already\n // been reported to the user, so no need to continue checking.\n-#[derive(Clone, Copy, Debug, RustcEncodable, RustcDecodable, Hash, PartialEq, Eq)]\n+#[derive(Clone, Copy, Debug, Encodable, Decodable, Hash, PartialEq, Eq)]\n pub struct ErrorReported;\n \n rustc_data_structures::impl_stable_hash_via_hash!(ErrorReported);"}, {"sha": "160bf57779970a58ab0b6369a5736534c634c5e4", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -173,7 +173,7 @@ pub struct StyledString {\n     pub style: Style,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub enum Style {\n     MainHeaderMsg,\n     HeaderMsg,"}, {"sha": "fbdb65b558790d4432003f63fb9f8b37b9aee521", "filename": "src/librustc_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2FCargo.toml?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -20,6 +20,7 @@ rustc_attr = { path = \"../librustc_attr\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_feature = { path = \"../librustc_feature\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_lexer = { path = \"../librustc_lexer\" }\n rustc_parse = { path = \"../librustc_parse\" }\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "7f631cb71afa86b9ff56b04acc2aadccb5c1854f", "filename": "src/librustc_expand/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_expand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_expand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Flib.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -8,6 +8,9 @@\n #![feature(proc_macro_span)]\n #![feature(try_blocks)]\n \n+#[macro_use]\n+extern crate rustc_macros;\n+\n extern crate proc_macro as pm;\n \n mod placeholders;"}, {"sha": "9920e0650a7f7a1742b2c3c9a30854bb0daec8e5", "filename": "src/librustc_expand/mbe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_expand%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_expand%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -19,7 +19,7 @@ use rustc_data_structures::sync::Lrc;\n \n /// Contains the sub-token-trees of a \"delimited\" token tree, such as the contents of `(`. Note\n /// that the delimiter itself might be `NoDelim`.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug)]\n struct Delimited {\n     delim: token::DelimToken,\n     tts: Vec<TokenTree>,\n@@ -37,7 +37,7 @@ impl Delimited {\n     }\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug)]\n struct SequenceRepetition {\n     /// The sequence of token trees\n     tts: Vec<TokenTree>,\n@@ -49,7 +49,7 @@ struct SequenceRepetition {\n     num_captures: usize,\n }\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n struct KleeneToken {\n     span: Span,\n     op: KleeneOp,\n@@ -63,7 +63,7 @@ impl KleeneToken {\n \n /// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n /// for token sequences.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug, Copy)]\n enum KleeneOp {\n     /// Kleene star (`*`) for zero or more repetitions\n     ZeroOrMore,\n@@ -75,7 +75,7 @@ enum KleeneOp {\n \n /// Similar to `tokenstream::TokenTree`, except that `$i`, `$i:ident`, and `$(...)`\n /// are \"first-class\" token trees. Useful for parsing macros.\n-#[derive(Debug, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Clone, PartialEq, Encodable, Decodable)]\n enum TokenTree {\n     Token(Token),\n     Delimited(DelimSpan, Lrc<Delimited>),"}, {"sha": "c4877be3f6415bb2c21b288e3327351805bdf0d6", "filename": "src/librustc_hir/def.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_hir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_hir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdef.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -9,7 +9,7 @@ use rustc_span::hygiene::MacroKind;\n use std::fmt::Debug;\n \n /// Encodes if a `DefKind::Ctor` is the constructor of an enum variant or a struct.\n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum CtorOf {\n     /// This `DefKind::Ctor` is a synthesized constructor of a tuple or unit struct.\n@@ -18,7 +18,7 @@ pub enum CtorOf {\n     Variant,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum CtorKind {\n     /// Constructor function automatically created by a tuple struct/variant.\n@@ -29,7 +29,7 @@ pub enum CtorKind {\n     Fictive,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum NonMacroAttrKind {\n     /// Single-segment attribute defined by the language (`#[inline]`)\n@@ -42,7 +42,7 @@ pub enum NonMacroAttrKind {\n     Registered,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum DefKind {\n     // Type namespace\n@@ -191,7 +191,7 @@ impl DefKind {\n }\n \n /// The resolution of a path or export.\n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum Res<Id = hir::HirId> {\n     Def(DefKind, DefId),"}, {"sha": "5604e3a8dcaf95b074ad1e688521e44d1a79058a", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -23,7 +23,7 @@ use std::hash::Hash;\n /// Internally the `DefPathTable` holds a tree of `DefKey`s, where each `DefKey`\n /// stores the `DefIndex` of its parent.\n /// There is one `DefPathTable` for each crate.\n-#[derive(Clone, Default, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Default, Decodable, Encodable)]\n pub struct DefPathTable {\n     index_to_key: IndexVec<DefIndex, DefKey>,\n     def_path_hashes: IndexVec<DefIndex, DefPathHash>,\n@@ -92,7 +92,7 @@ pub struct Definitions {\n /// A unique identifier that we can use to lookup a definition\n /// precisely. It combines the index of the definition's parent (if\n /// any) with a `DisambiguatedDefPathData`.\n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, Encodable, Decodable)]\n pub struct DefKey {\n     /// The parent path.\n     pub parent: Option<DefIndex>,\n@@ -143,13 +143,13 @@ impl DefKey {\n /// between them. This introduces some artificial ordering dependency\n /// but means that if you have, e.g., two impls for the same type in\n /// the same module, they do get distinct `DefId`s.\n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, Encodable, Decodable)]\n pub struct DisambiguatedDefPathData {\n     pub data: DefPathData,\n     pub disambiguator: u32,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Encodable, Decodable)]\n pub struct DefPath {\n     /// The path leading from the crate root to the item.\n     pub data: Vec<DisambiguatedDefPathData>,\n@@ -244,7 +244,7 @@ impl DefPath {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function."}, {"sha": "928235adac30c15685203a59fa7a696e958f35b7", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 108, "deletions": 117, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -23,7 +23,7 @@ use smallvec::SmallVec;\n use std::collections::{BTreeMap, BTreeSet};\n use std::fmt;\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, HashStable_Generic)]\n pub struct Lifetime {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -37,7 +37,7 @@ pub struct Lifetime {\n     pub name: LifetimeName,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Debug, Clone, PartialEq, Eq, Encodable, Hash, Copy)]\n #[derive(HashStable_Generic)]\n pub enum ParamName {\n     /// Some user-given name like `T` or `'x`.\n@@ -83,7 +83,7 @@ impl ParamName {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Debug, Clone, PartialEq, Eq, Encodable, Hash, Copy)]\n #[derive(HashStable_Generic)]\n pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n@@ -182,7 +182,7 @@ impl Lifetime {\n /// A `Path` is essentially Rust's notion of a name; for instance,\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Path<'hir> {\n     pub span: Span,\n     /// The resolution for the path.\n@@ -199,7 +199,7 @@ impl Path<'_> {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct PathSegment<'hir> {\n     /// The identifier portion of this path segment.\n     #[stable_hasher(project(name))]\n@@ -242,13 +242,13 @@ impl<'hir> PathSegment<'hir> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, HashStable_Generic)]\n pub struct ConstArg {\n     pub value: AnonConst,\n     pub span: Span,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum GenericArg<'hir> {\n     Lifetime(Lifetime),\n     Type(Ty<'hir>),\n@@ -288,7 +288,7 @@ impl GenericArg<'_> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct GenericArgs<'hir> {\n     /// The generic arguments for this path segment.\n     pub args: &'hir [GenericArg<'hir>],\n@@ -348,7 +348,7 @@ impl GenericArgs<'_> {\n \n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n /// modifier is `Maybe`. Negative bounds should also be handled here.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum TraitBoundModifier {\n     None,\n@@ -360,7 +360,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum GenericBound<'hir> {\n     Trait(PolyTraitRef<'hir>, TraitBoundModifier),\n     Outlives(Lifetime),\n@@ -384,7 +384,7 @@ impl GenericBound<'_> {\n \n pub type GenericBounds<'hir> = &'hir [GenericBound<'hir>];\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n pub enum LifetimeParamKind {\n     // Indicates that the lifetime definition was explicitly declared (e.g., in\n     // `fn foo<'a>(x: &'a u8) -> &'a u8 { x }`).\n@@ -403,7 +403,7 @@ pub enum LifetimeParamKind {\n     Error,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum GenericParamKind<'hir> {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime {\n@@ -418,7 +418,7 @@ pub enum GenericParamKind<'hir> {\n     },\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct GenericParam<'hir> {\n     pub hir_id: HirId,\n     pub name: ParamName,\n@@ -448,7 +448,7 @@ pub struct GenericParamCount {\n \n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Generics<'hir> {\n     pub params: &'hir [GenericParam<'hir>],\n     pub where_clause: WhereClause<'hir>,\n@@ -501,14 +501,14 @@ impl Generics<'hir> {\n \n /// Synthetic type parameters are converted to another form during lowering; this allows\n /// us to track the original form they had, and is useful for error messages.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum SyntheticTyParamKind {\n     ImplTrait,\n }\n \n /// A where-clause in a definition.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct WhereClause<'hir> {\n     pub predicates: &'hir [WherePredicate<'hir>],\n     // Only valid if predicates aren't empty.\n@@ -535,7 +535,7 @@ impl WhereClause<'_> {\n }\n \n /// A single predicate in a where-clause.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum WherePredicate<'hir> {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n     BoundPredicate(WhereBoundPredicate<'hir>),\n@@ -556,7 +556,7 @@ impl WherePredicate<'_> {\n }\n \n /// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct WhereBoundPredicate<'hir> {\n     pub span: Span,\n     /// Any generics from a `for` binding.\n@@ -568,23 +568,23 @@ pub struct WhereBoundPredicate<'hir> {\n }\n \n /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct WhereRegionPredicate<'hir> {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds<'hir>,\n }\n \n /// An equality predicate (e.g., `T = int`); currently unsupported.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct WhereEqPredicate<'hir> {\n     pub hir_id: HirId,\n     pub span: Span,\n     pub lhs_ty: &'hir Ty<'hir>,\n     pub rhs_ty: &'hir Ty<'hir>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, HashStable_Generic)]\n pub struct ModuleItems {\n     // Use BTreeSets here so items are in the same order as in the\n     // list of all items in Crate\n@@ -594,7 +594,7 @@ pub struct ModuleItems {\n }\n \n /// A type representing only the top-level module.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, HashStable_Generic)]\n pub struct CrateItem<'hir> {\n     pub module: Mod<'hir>,\n     pub attrs: &'hir [Attribute],\n@@ -607,7 +607,7 @@ pub struct CrateItem<'hir> {\n /// For more details, see the [rustc dev guide].\n ///\n /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Debug)]\n pub struct Crate<'hir> {\n     pub item: CrateItem<'hir>,\n     pub exported_macros: &'hir [MacroDef<'hir>],\n@@ -715,7 +715,7 @@ impl Crate<'_> {\n /// A macro definition, in this crate or imported from another.\n ///\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct MacroDef<'hir> {\n     pub ident: Ident,\n     pub vis: Visibility<'hir>,\n@@ -728,7 +728,7 @@ pub struct MacroDef<'hir> {\n /// A block of statements `{ .. }`, which may have a label (in this case the\n /// `targeted_by_break` field will be `true`) and may be `unsafe` by means of\n /// the `rules` being anything but `DefaultBlock`.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Block<'hir> {\n     /// Statements in a block.\n     pub stmts: &'hir [Stmt<'hir>],\n@@ -746,7 +746,7 @@ pub struct Block<'hir> {\n     pub targeted_by_break: bool,\n }\n \n-#[derive(Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Pat<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -824,7 +824,7 @@ impl Pat<'_> {\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except `is_shorthand` is true.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct FieldPat<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -840,7 +840,7 @@ pub struct FieldPat<'hir> {\n /// Explicit binding annotations given in the HIR for a binding. Note\n /// that this is not the final binding *mode* that we infer after type\n /// inference.\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum BindingAnnotation {\n     /// No binding annotation given: this means that the final binding mode\n     /// will depend on whether we have skipped through a `&` reference\n@@ -861,7 +861,7 @@ pub enum BindingAnnotation {\n     RefMut,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum RangeEnd {\n     Included,\n     Excluded,\n@@ -876,7 +876,7 @@ impl fmt::Display for RangeEnd {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum PatKind<'hir> {\n     /// Represents a wildcard pattern (i.e., `_`).\n     Wild,\n@@ -932,7 +932,7 @@ pub enum PatKind<'hir> {\n     Slice(&'hir [&'hir Pat<'hir>], Option<&'hir Pat<'hir>>, &'hir [&'hir Pat<'hir>]),\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum BinOpKind {\n     /// The `+` operator (addition).\n     Add,\n@@ -1066,7 +1066,7 @@ impl Into<ast::BinOpKind> for BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum UnOp {\n     /// The `*` operator (deferencing).\n     UnDeref,\n@@ -1095,15 +1095,15 @@ impl UnOp {\n }\n \n /// A statement.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Stmt<'hir> {\n     pub hir_id: HirId,\n     pub kind: StmtKind<'hir>,\n     pub span: Span,\n }\n \n /// The contents of a statement.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum StmtKind<'hir> {\n     /// A local (`let`) binding.\n     Local(&'hir Local<'hir>),\n@@ -1129,7 +1129,7 @@ impl StmtKind<'hir> {\n }\n \n /// Represents a `let` statement (i.e., `let <pat>:<ty> = <expr>;`).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Local<'hir> {\n     pub pat: &'hir Pat<'hir>,\n     /// Type annotation, if any (otherwise the type will be inferred).\n@@ -1146,7 +1146,7 @@ pub struct Local<'hir> {\n \n /// Represents a single arm of a `match` expression, e.g.\n /// `<pat> (if <guard>) => <body>`.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Arm<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1160,12 +1160,12 @@ pub struct Arm<'hir> {\n     pub body: &'hir Expr<'hir>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum Guard<'hir> {\n     If(&'hir Expr<'hir>),\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Field<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1175,21 +1175,21 @@ pub struct Field<'hir> {\n     pub is_shorthand: bool,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n     PushUnsafeBlock(UnsafeSource),\n     PopUnsafeBlock(UnsafeSource),\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Hash, Debug)]\n pub struct BodyId {\n     pub hir_id: HirId,\n }\n@@ -1215,7 +1215,7 @@ pub struct BodyId {\n ///\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Debug)]\n pub struct Body<'hir> {\n     pub params: &'hir [Param<'hir>],\n     pub value: Expr<'hir>,\n@@ -1233,7 +1233,7 @@ impl Body<'hir> {\n }\n \n /// The type of source expression that caused this generator to be created.\n-#[derive(Clone, PartialEq, Eq, HashStable_Generic, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, HashStable_Generic, Encodable, Decodable, Debug, Copy)]\n pub enum GeneratorKind {\n     /// An explicit `async` block or the body of an async function.\n     Async(AsyncGeneratorKind),\n@@ -1256,7 +1256,7 @@ impl fmt::Display for GeneratorKind {\n ///\n /// This helps error messages but is also used to drive coercions in\n /// type-checking (see #60424).\n-#[derive(Clone, PartialEq, Eq, HashStable_Generic, RustcEncodable, RustcDecodable, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, HashStable_Generic, Encodable, Decodable, Debug, Copy)]\n pub enum AsyncGeneratorKind {\n     /// An explicit `async` block written by the user.\n     Block,\n@@ -1357,14 +1357,14 @@ pub type Lit = Spanned<LitKind>;\n /// These are usually found nested inside types (e.g., array lengths)\n /// or expressions (e.g., repeat counts), and also used to define\n /// explicit discriminant values for enum variants.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n pub struct AnonConst {\n     pub hir_id: HirId,\n     pub body: BodyId,\n }\n \n /// An expression.\n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug)]\n pub struct Expr<'hir> {\n     pub hir_id: HirId,\n     pub kind: ExprKind<'hir>,\n@@ -1543,7 +1543,7 @@ pub fn is_range_literal(sm: &SourceMap, expr: &Expr<'_>) -> bool {\n     false\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum ExprKind<'hir> {\n     /// A `box x` expression.\n     Box(&'hir Expr<'hir>),\n@@ -1660,7 +1660,7 @@ pub enum ExprKind<'hir> {\n /// To resolve the path to a `DefId`, call [`qpath_res`].\n ///\n /// [`qpath_res`]: ../rustc_middle/ty/struct.TypeckResults.html#method.qpath_res\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum QPath<'hir> {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n@@ -1680,7 +1680,7 @@ pub enum QPath<'hir> {\n }\n \n /// Hints at the original code for a let statement.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n pub enum LocalSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -1702,7 +1702,7 @@ pub enum LocalSource {\n }\n \n /// Hints at the original code for a `match _ { .. }`.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum MatchSource {\n     /// A `match _ { .. }`.\n@@ -1739,7 +1739,7 @@ impl MatchSource {\n }\n \n /// The loop type that yielded an `ExprKind::Loop`.\n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum LoopSource {\n     /// A `loop { .. }` loop.\n     Loop,\n@@ -1761,7 +1761,7 @@ impl LoopSource {\n     }\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n pub enum LoopIdError {\n     OutsideLoopScope,\n     UnlabeledCfInWhileCondition,\n@@ -1780,7 +1780,7 @@ impl fmt::Display for LoopIdError {\n     }\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n pub struct Destination {\n     // This is `Some(_)` iff there is an explicit user-specified `label\n     pub label: Option<Label>,\n@@ -1791,7 +1791,7 @@ pub struct Destination {\n }\n \n /// The yield kind that caused an `ExprKind::Yield`.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Encodable, Decodable, HashStable_Generic)]\n pub enum YieldSource {\n     /// An `<expr>.await`.\n     Await { expr: Option<HirId> },\n@@ -1829,15 +1829,15 @@ impl From<GeneratorKind> for YieldSource {\n \n // N.B., if you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct MutTy<'hir> {\n     pub ty: &'hir Ty<'hir>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a function's signature in a trait declaration,\n /// trait implementation, or a free function.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct FnSig<'hir> {\n     pub header: FnHeader,\n     pub decl: &'hir FnDecl<'hir>,\n@@ -1846,7 +1846,7 @@ pub struct FnSig<'hir> {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the node-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug)]\n pub struct TraitItemId {\n     pub hir_id: HirId,\n }\n@@ -1855,7 +1855,7 @@ pub struct TraitItemId {\n /// possibly including a default implementation. A trait item is\n /// either required (meaning it doesn't have an implementation, just a\n /// signature) or provided (meaning it has a default implementation).\n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Debug)]\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n     pub hir_id: HirId,\n@@ -1866,7 +1866,7 @@ pub struct TraitItem<'hir> {\n }\n \n /// Represents a trait method's body (or just argument names).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, HashStable_Generic)]\n pub enum TraitFn<'hir> {\n     /// No default body in the trait, just a signature.\n     Required(&'hir [Ident]),\n@@ -1876,7 +1876,7 @@ pub enum TraitFn<'hir> {\n }\n \n /// Represents a trait method or associated constant or type\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum TraitItemKind<'hir> {\n     /// An associated constant with an optional value (otherwise `impl`s must contain a value).\n     Const(&'hir Ty<'hir>, Option<BodyId>),\n@@ -1890,13 +1890,13 @@ pub enum TraitItemKind<'hir> {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the node-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Debug)]\n pub struct ImplItemId {\n     pub hir_id: HirId,\n }\n \n /// Represents anything within an `impl` block.\n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Debug)]\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n     pub hir_id: HirId,\n@@ -1909,7 +1909,7 @@ pub struct ImplItem<'hir> {\n }\n \n /// Represents various kinds of content within an `impl`.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum ImplItemKind<'hir> {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression.\n@@ -1947,7 +1947,7 @@ pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n ///    Binding(...),\n /// }\n /// ```\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct TypeBinding<'hir> {\n     pub hir_id: HirId,\n     #[stable_hasher(project(name))]\n@@ -1957,7 +1957,7 @@ pub struct TypeBinding<'hir> {\n }\n \n // Represents the two kinds of type bindings.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum TypeBindingKind<'hir> {\n     /// E.g., `Foo<Bar: Send>`.\n     Constraint { bounds: &'hir [GenericBound<'hir>] },\n@@ -1974,15 +1974,15 @@ impl TypeBinding<'_> {\n     }\n }\n \n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug)]\n pub struct Ty<'hir> {\n     pub hir_id: HirId,\n     pub kind: TyKind<'hir>,\n     pub span: Span,\n }\n \n /// Not represented directly in the AST; referred to by name through a `ty_path`.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum PrimTy {\n     Int(IntTy),\n@@ -1993,7 +1993,7 @@ pub enum PrimTy {\n     Char,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct BareFnTy<'hir> {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n@@ -2002,7 +2002,7 @@ pub struct BareFnTy<'hir> {\n     pub param_names: &'hir [Ident],\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct OpaqueTy<'hir> {\n     pub generics: Generics<'hir>,\n     pub bounds: GenericBounds<'hir>,\n@@ -2011,7 +2011,7 @@ pub struct OpaqueTy<'hir> {\n }\n \n /// From whence the opaque type came.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum OpaqueTyOrigin {\n     /// `-> impl Trait`\n     FnReturn,\n@@ -2024,7 +2024,7 @@ pub enum OpaqueTyOrigin {\n }\n \n /// The various kinds of types recognized by the compiler.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum TyKind<'hir> {\n     /// A variable length slice (i.e., `[T]`).\n     Slice(&'hir Ty<'hir>),\n@@ -2063,7 +2063,7 @@ pub enum TyKind<'hir> {\n     Err,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum InlineAsmOperand<'hir> {\n     In {\n         reg: InlineAsmRegOrRegClass,\n@@ -2105,15 +2105,15 @@ impl<'hir> InlineAsmOperand<'hir> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct InlineAsm<'hir> {\n     pub template: &'hir [InlineAsmTemplatePiece],\n     pub operands: &'hir [InlineAsmOperand<'hir>],\n     pub options: InlineAsmOptions,\n     pub line_spans: &'hir [Span],\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic, PartialEq)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, HashStable_Generic, PartialEq)]\n pub struct LlvmInlineAsmOutput {\n     pub constraint: Symbol,\n     pub is_rw: bool,\n@@ -2122,8 +2122,9 @@ pub struct LlvmInlineAsmOutput {\n }\n \n // NOTE(eddyb) This is used within MIR as well, so unlike the rest of the HIR,\n-// it needs to be `Clone` and use plain `Vec<T>` instead of arena-allocated slice.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic, PartialEq)]\n+// it needs to be `Clone` and `Decodable` and use plain `Vec<T>` instead of\n+// arena-allocated slice.\n+#[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic, PartialEq)]\n pub struct LlvmInlineAsmInner {\n     pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n@@ -2135,15 +2136,15 @@ pub struct LlvmInlineAsmInner {\n     pub dialect: LlvmAsmDialect,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct LlvmInlineAsm<'hir> {\n     pub inner: LlvmInlineAsmInner,\n     pub outputs_exprs: &'hir [Expr<'hir>],\n     pub inputs_exprs: &'hir [Expr<'hir>],\n }\n \n /// Represents a parameter in a function header.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Param<'hir> {\n     pub attrs: &'hir [Attribute],\n     pub hir_id: HirId,\n@@ -2153,7 +2154,7 @@ pub struct Param<'hir> {\n }\n \n /// Represents the header (not the body) of a function declaration.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct FnDecl<'hir> {\n     /// The types of the function's parameters.\n     ///\n@@ -2166,7 +2167,7 @@ pub struct FnDecl<'hir> {\n }\n \n /// Represents what type of implicit self a function has, if any.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum ImplicitSelfKind {\n     /// Represents a `fn x(self);`.\n     Imm,\n@@ -2191,24 +2192,14 @@ impl ImplicitSelfKind {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Decodable, Debug)]\n #[derive(HashStable_Generic)]\n pub enum IsAsync {\n     Async,\n     NotAsync,\n }\n \n-#[derive(\n-    Copy,\n-    Clone,\n-    PartialEq,\n-    RustcEncodable,\n-    RustcDecodable,\n-    Debug,\n-    HashStable_Generic,\n-    Eq,\n-    Hash\n-)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Encodable, Decodable, HashStable_Generic)]\n pub enum Defaultness {\n     Default { has_value: bool },\n     Final,\n@@ -2234,7 +2225,7 @@ impl Defaultness {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum FnRetTy<'hir> {\n     /// Return type is not specified.\n     ///\n@@ -2255,7 +2246,7 @@ impl FnRetTy<'_> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Encodable, Debug)]\n pub struct Mod<'hir> {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -2264,23 +2255,23 @@ pub struct Mod<'hir> {\n     pub item_ids: &'hir [ItemId],\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct ForeignMod<'hir> {\n     pub abi: Abi,\n     pub items: &'hir [ForeignItem<'hir>],\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, HashStable_Generic)]\n pub struct GlobalAsm {\n     pub asm: Symbol,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct EnumDef<'hir> {\n     pub variants: &'hir [Variant<'hir>],\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct Variant<'hir> {\n     /// Name of the variant.\n     #[stable_hasher(project(name))]\n@@ -2297,7 +2288,7 @@ pub struct Variant<'hir> {\n     pub span: Span,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum UseKind {\n     /// One import, e.g., `use foo::bar` or `use foo::bar as baz`.\n     /// Also produced for each element of a list `use`, e.g.\n@@ -2319,7 +2310,7 @@ pub enum UseKind {\n /// that the `ref_id` is for. Note that `ref_id`'s value is not the `HirId` of the\n /// trait being referred to but just a unique `HirId` that serves as a key\n /// within the resolution map.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct TraitRef<'hir> {\n     pub path: &'hir Path<'hir>,\n     // Don't hash the `ref_id`. It is tracked via the thing it is used to access.\n@@ -2338,7 +2329,7 @@ impl TraitRef<'_> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct PolyTraitRef<'hir> {\n     /// The `'a` in `for<'a> Foo<&'a T>`.\n     pub bound_generic_params: &'hir [GenericParam<'hir>],\n@@ -2351,7 +2342,7 @@ pub struct PolyTraitRef<'hir> {\n \n pub type Visibility<'hir> = Spanned<VisibilityKind<'hir>>;\n \n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Debug)]\n pub enum VisibilityKind<'hir> {\n     Public,\n     Crate(CrateSugar),\n@@ -2384,7 +2375,7 @@ impl VisibilityKind<'_> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct StructField<'hir> {\n     pub span: Span,\n     #[stable_hasher(project(name))]\n@@ -2404,7 +2395,7 @@ impl StructField<'_> {\n }\n \n /// Fields and constructor IDs of enum variants and structs.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum VariantData<'hir> {\n     /// A struct variant.\n     ///\n@@ -2441,15 +2432,15 @@ impl VariantData<'hir> {\n // The bodies for items are stored \"out of line\", in a separate\n // hashmap in the `Crate`. Here we just record the node-id of the item\n // so it can fetched later.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, Encodable, Debug)]\n pub struct ItemId {\n     pub id: HirId,\n }\n \n /// An item\n ///\n /// The name might be a dummy name in case of anonymous items\n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Debug)]\n pub struct Item<'hir> {\n     pub ident: Ident,\n     pub hir_id: HirId,\n@@ -2460,7 +2451,7 @@ pub struct Item<'hir> {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum Unsafety {\n     Unsafe,\n     Normal,\n@@ -2485,13 +2476,13 @@ impl fmt::Display for Unsafety {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum Constness {\n     Const,\n     NotConst,\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub constness: Constness,\n@@ -2508,7 +2499,7 @@ impl FnHeader {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum ItemKind<'hir> {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n@@ -2590,7 +2581,7 @@ impl ItemKind<'_> {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Encodable, Debug, HashStable_Generic)]\n pub struct TraitItemRef {\n     pub id: TraitItemId,\n     #[stable_hasher(project(name))]\n@@ -2606,7 +2597,7 @@ pub struct TraitItemRef {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct ImplItemRef<'hir> {\n     pub id: ImplItemId,\n     #[stable_hasher(project(name))]\n@@ -2617,14 +2608,14 @@ pub struct ImplItemRef<'hir> {\n     pub defaultness: Defaultness,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n pub enum AssocItemKind {\n     Const,\n     Fn { has_self: bool },\n     Type,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub struct ForeignItem<'hir> {\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n@@ -2636,7 +2627,7 @@ pub struct ForeignItem<'hir> {\n }\n \n /// An item within an `extern` block.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+#[derive(Debug, HashStable_Generic)]\n pub enum ForeignItemKind<'hir> {\n     /// A foreign function.\n     Fn(&'hir FnDecl<'hir>, &'hir [Ident], Generics<'hir>),\n@@ -2647,7 +2638,7 @@ pub enum ForeignItemKind<'hir> {\n }\n \n /// A variable captured by a closure.\n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, Encodable, HashStable_Generic)]\n pub struct Upvar {\n     // First span where it is accessed (there can be multiple).\n     pub span: Span,\n@@ -2658,7 +2649,7 @@ pub type CaptureModeMap = NodeMap<CaptureBy>;\n // The TraitCandidate's import_ids is empty if the trait is defined in the same module, and\n // has length > 0 if the trait is found through an chain of imports, starting with the\n // import/use statement in the scope where the trait is used.\n-#[derive(RustcEncodable, RustcDecodable, Clone, Debug)]\n+#[derive(Encodable, Decodable, Clone, Debug)]\n pub struct TraitCandidate {\n     pub def_id: DefId,\n     pub import_ids: SmallVec<[LocalDefId; 1]>,"}, {"sha": "fea850c12d9b0102d0423850ba384e6f50d6f3f4", "filename": "src/librustc_hir/hir_id.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_hir%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_hir%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir_id.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -11,7 +11,8 @@ use std::fmt;\n /// the `local_id` part of the `HirId` changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n+#[derive(Encodable, Decodable)]\n pub struct HirId {\n     pub owner: LocalDefId,\n     pub local_id: ItemLocalId,"}, {"sha": "b09657bd9b4a41962e74de68678e5593f0df30cb", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -45,7 +45,7 @@ macro_rules! language_item_table {\n \n         enum_from_u32! {\n             /// A representation of all the valid language items in Rust.\n-            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Encodable, Decodable)]\n             pub enum LangItem {\n                 $($variant,)*\n             }"}, {"sha": "a64565b20e7f48d30bf16b0f9a8f9e82776554de", "filename": "src/librustc_hir/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_hir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_hir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flib.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -7,9 +7,11 @@\n #![feature(const_panic)]\n #![feature(in_band_lifetimes)]\n #![feature(or_patterns)]\n-#![feature(min_specialization)]\n #![recursion_limit = \"256\"]\n \n+#[macro_use]\n+extern crate rustc_macros;\n+\n #[macro_use]\n extern crate rustc_data_structures;\n "}, {"sha": "2b597c7da80cbcbe7183bdc76c12f801abd54e51", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -18,6 +18,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "81e5410978d5df55b4afa6da578d71ba429bb321", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -1,8 +1,9 @@\n //! The data that we will serialize and deserialize.\n \n+use rustc_macros::{Decodable, Encodable};\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n \n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Encodable, Decodable)]\n pub struct SerializedWorkProduct {\n     /// node that produced the work-product\n     pub id: WorkProductId,"}, {"sha": "8aaf1cb9cbc58057037bafedcf082b5810fc2af1", "filename": "src/librustc_index/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2FCargo.toml?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -10,5 +10,6 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-rustc_serialize = { path = \"../librustc_serialize\" }\n arrayvec = \"0.5.1\"\n+rustc_serialize = { path = \"../librustc_serialize\" }\n+rustc_macros = { path = \"../librustc_macros\" }"}, {"sha": "c43d1a6830d1d8818887754f8b0b468d832eb2f5", "filename": "src/librustc_index/bit_set.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_index%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_index%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fbit_set.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -7,6 +7,8 @@ use std::mem;\n use std::ops::{BitAnd, BitAndAssign, BitOrAssign, Not, Range, Shl};\n use std::slice;\n \n+use rustc_macros::{Decodable, Encodable};\n+\n #[cfg(test)]\n mod tests;\n \n@@ -26,7 +28,7 @@ pub const WORD_BITS: usize = WORD_BYTES * 8;\n /// will panic if the bitsets have differing domain sizes.\n ///\n /// [`GrowableBitSet`]: struct.GrowableBitSet.html\n-#[derive(Clone, Eq, PartialEq, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Eq, PartialEq, Decodable, Encodable)]\n pub struct BitSet<T: Idx> {\n     domain_size: usize,\n     words: Vec<Word>,\n@@ -700,7 +702,7 @@ impl<T: Idx> GrowableBitSet<T> {\n ///\n /// All operations that involve a row and/or column index will panic if the\n /// index exceeds the relevant bound.\n-#[derive(Clone, Eq, PartialEq, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Eq, PartialEq, Decodable, Encodable)]\n pub struct BitMatrix<R: Idx, C: Idx> {\n     num_rows: usize,\n     num_columns: usize,\n@@ -1108,7 +1110,7 @@ impl std::fmt::Debug for FiniteBitSet<u128> {\n \n /// A fixed-sized bitset type represented by an integer type. Indices outwith than the range\n /// representable by `T` are considered set.\n-#[derive(Copy, Clone, Eq, PartialEq, RustcDecodable, RustcEncodable)]\n+#[derive(Copy, Clone, Eq, PartialEq, Decodable, Encodable)]\n pub struct FiniteBitSet<T: FiniteBitSetTy>(pub T);\n \n impl<T: FiniteBitSetTy> FiniteBitSet<T> {"}, {"sha": "63f63133a2c95b830f0fae6c17f784c9cf9ef7eb", "filename": "src/librustc_index/vec.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_index%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_index%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fvec.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -320,14 +320,14 @@ macro_rules! newtype_index {\n                    derive [$($derives:ident,)+]\n                    $($tokens:tt)*) => (\n         $crate::newtype_index!(\n-            @derives      [$($derives,)+ RustcEncodable,]\n+            @derives      [$($derives,)+]\n             @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n             @debug_format [$debug_format]\n                           $($tokens)*);\n-        $crate::newtype_index!(@decodable $type);\n+        $crate::newtype_index!(@serializable $type);\n     );\n \n     // The case where no derives are added, but encodable is overridden. Don't\n@@ -357,22 +357,27 @@ macro_rules! newtype_index {\n      @debug_format [$debug_format:tt]\n                    $($tokens:tt)*) => (\n         $crate::newtype_index!(\n-            @derives      [RustcEncodable,]\n+            @derives      []\n             @attrs        [$(#[$attrs])*]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n             @debug_format [$debug_format]\n                           $($tokens)*);\n-        $crate::newtype_index!(@decodable $type);\n+        $crate::newtype_index!(@serializable $type);\n     );\n \n-    (@decodable $type:ident) => (\n-        impl ::rustc_serialize::Decodable for $type {\n-            fn decode<D: ::rustc_serialize::Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+    (@serializable $type:ident) => (\n+        impl<D: ::rustc_serialize::Decoder> ::rustc_serialize::Decodable<D> for $type {\n+            fn decode(d: &mut D) -> Result<Self, D::Error> {\n                 d.read_u32().map(Self::from_u32)\n             }\n         }\n+        impl<E: ::rustc_serialize::Encoder> ::rustc_serialize::Encodable<E> for $type {\n+            fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+                e.emit_u32(self.private)\n+            }\n+        }\n     );\n \n     // Rewrite final without comma to one that includes comma\n@@ -483,14 +488,20 @@ pub struct IndexVec<I: Idx, T> {\n // not the phantom data.\n unsafe impl<I: Idx, T> Send for IndexVec<I, T> where T: Send {}\n \n-impl<I: Idx, T: Encodable> Encodable for IndexVec<I, T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, I: Idx, T: Encodable<S>> Encodable<S> for IndexVec<I, T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        Encodable::encode(&self.raw, s)\n+    }\n+}\n+\n+impl<S: Encoder, I: Idx, T: Encodable<S>> Encodable<S> for &IndexVec<I, T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         Encodable::encode(&self.raw, s)\n     }\n }\n \n-impl<I: Idx, T: Decodable> Decodable for IndexVec<I, T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+impl<D: Decoder, I: Idx, T: Decodable<D>> Decodable<D> for IndexVec<I, T> {\n+    fn decode(d: &mut D) -> Result<Self, D::Error> {\n         Decodable::decode(d).map(|v| IndexVec { raw: v, _marker: PhantomData })\n     }\n }"}, {"sha": "ffe5fb172bea3ec4096a6e9d65e8a50414a46420", "filename": "src/librustc_infer/infer/free_regions.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -7,17 +7,14 @@ use rustc_data_structures::transitive_relation::TransitiveRelation;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::{self, Lift, Region, TyCtxt};\n \n-/// Combines a `region::ScopeTree` (which governs relationships between\n-/// scopes) and a `FreeRegionMap` (which governs relationships between\n-/// free regions) to yield a complete relation between concrete\n-/// regions.\n+/// Combines a `FreeRegionMap` and a `TyCtxt`.\n ///\n /// This stuff is a bit convoluted and should be refactored, but as we\n /// transition to NLL, it'll all go away anyhow.\n pub struct RegionRelations<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n-    /// The context used to fetch the region maps.\n+    /// The context used for debug messages\n     pub context: DefId,\n \n     /// Free-region relationships.\n@@ -34,7 +31,7 @@ impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default, HashStable)]\n+#[derive(Clone, Debug, Default)]\n pub struct FreeRegionMap<'tcx> {\n     // Stores the relation `a < b`, where `a` and `b` are regions.\n     //"}, {"sha": "7fb3b0e7ea6accba63fc307028c7426286fcfe05", "filename": "src/librustc_macros/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Flib.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -8,6 +8,7 @@ use proc_macro::TokenStream;\n mod hash_stable;\n mod lift;\n mod query;\n+mod serialize;\n mod symbols;\n mod type_foldable;\n \n@@ -27,5 +28,11 @@ decl_derive!(\n     hash_stable::hash_stable_generic_derive\n );\n \n+decl_derive!([Decodable] => serialize::decodable_derive);\n+decl_derive!([Encodable] => serialize::encodable_derive);\n+decl_derive!([TyDecodable] => serialize::type_decodable_derive);\n+decl_derive!([TyEncodable] => serialize::type_encodable_derive);\n+decl_derive!([MetadataDecodable] => serialize::meta_decodable_derive);\n+decl_derive!([MetadataEncodable] => serialize::meta_encodable_derive);\n decl_derive!([TypeFoldable, attributes(type_foldable)] => type_foldable::type_foldable_derive);\n decl_derive!([Lift, attributes(lift)] => lift::lift_derive);"}, {"sha": "dbeb3c755044f543bdb2a64eceea3bc5f4ae7e2b", "filename": "src/librustc_macros/src/serialize.rs", "status": "added", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fserialize.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -0,0 +1,290 @@\n+use proc_macro2::TokenStream;\n+use quote::quote;\n+use syn::parse_quote;\n+\n+pub fn type_decodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    let decoder_ty = quote! { __D };\n+    if !s.ast().generics.lifetimes().any(|lt| lt.lifetime.ident == \"tcx\") {\n+        s.add_impl_generic(parse_quote! { 'tcx });\n+    }\n+    s.add_impl_generic(parse_quote! {#decoder_ty: ::rustc_middle::ty::codec::TyDecoder<'tcx>});\n+    s.add_bounds(synstructure::AddBounds::Generics);\n+\n+    decodable_body(s, decoder_ty)\n+}\n+\n+pub fn meta_decodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    if !s.ast().generics.lifetimes().any(|lt| lt.lifetime.ident == \"tcx\") {\n+        s.add_impl_generic(parse_quote! { 'tcx });\n+    }\n+    s.add_impl_generic(parse_quote! { '__a });\n+    let decoder_ty = quote! { DecodeContext<'__a, 'tcx> };\n+    s.add_bounds(synstructure::AddBounds::Generics);\n+\n+    decodable_body(s, decoder_ty)\n+}\n+\n+pub fn decodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    let decoder_ty = quote! { __D };\n+    s.add_impl_generic(parse_quote! {#decoder_ty: ::rustc_serialize::Decoder});\n+    s.add_bounds(synstructure::AddBounds::Generics);\n+\n+    decodable_body(s, decoder_ty)\n+}\n+\n+fn decodable_body(\n+    s: synstructure::Structure<'_>,\n+    decoder_ty: TokenStream,\n+) -> proc_macro2::TokenStream {\n+    if let syn::Data::Union(_) = s.ast().data {\n+        panic!(\"cannot derive on union\")\n+    }\n+    let ty_name = s.ast().ident.to_string();\n+    let decode_body = match s.variants() {\n+        [vi] => {\n+            let construct = vi.construct(|field, index| decode_field(field, index, true));\n+            let n_fields = vi.ast().fields.len();\n+            quote! {\n+                ::rustc_serialize::Decoder::read_struct(\n+                    __decoder,\n+                    #ty_name,\n+                    #n_fields,\n+                    |__decoder| { ::std::result::Result::Ok(#construct) },\n+                )\n+            }\n+        }\n+        variants => {\n+            let match_inner: TokenStream = variants\n+                .iter()\n+                .enumerate()\n+                .map(|(idx, vi)| {\n+                    let construct = vi.construct(|field, index| decode_field(field, index, false));\n+                    quote! { #idx => { ::std::result::Result::Ok(#construct) } }\n+                })\n+                .collect();\n+            let names: TokenStream = variants\n+                .iter()\n+                .map(|vi| {\n+                    let variant_name = vi.ast().ident.to_string();\n+                    quote!(#variant_name,)\n+                })\n+                .collect();\n+            let message = format!(\n+                \"invalid enum variant tag while decoding `{}`, expected 0..{}\",\n+                ty_name,\n+                variants.len()\n+            );\n+            quote! {\n+                ::rustc_serialize::Decoder::read_enum(\n+                    __decoder,\n+                    #ty_name,\n+                    |__decoder| {\n+                        ::rustc_serialize::Decoder::read_enum_variant(\n+                            __decoder,\n+                            &[#names],\n+                            |__decoder, __variant_idx| {\n+                                match __variant_idx {\n+                                    #match_inner\n+                                    _ => return ::std::result::Result::Err(\n+                                        ::rustc_serialize::Decoder::error(__decoder, #message)),\n+                                }\n+                            })\n+                    }\n+                )\n+            }\n+        }\n+    };\n+\n+    s.bound_impl(\n+        quote!(::rustc_serialize::Decodable<#decoder_ty>),\n+        quote! {\n+            fn decode(\n+                __decoder: &mut #decoder_ty,\n+            ) -> ::std::result::Result<Self, <#decoder_ty as ::rustc_serialize::Decoder>::Error> {\n+                #decode_body\n+            }\n+        },\n+    )\n+}\n+\n+fn decode_field(field: &syn::Field, index: usize, is_struct: bool) -> proc_macro2::TokenStream {\n+    let decode_inner_method = if let syn::Type::Reference(_) = field.ty {\n+        quote! { ::rustc_middle::ty::codec::RefDecodable::decode }\n+    } else {\n+        quote! { ::rustc_serialize::Decodable::decode }\n+    };\n+    let (decode_method, opt_field_name) = if is_struct {\n+        let field_name = field.ident.as_ref().map_or_else(|| index.to_string(), |i| i.to_string());\n+        (\n+            proc_macro2::Ident::new(\"read_struct_field\", proc_macro2::Span::call_site()),\n+            quote! { #field_name, },\n+        )\n+    } else {\n+        (\n+            proc_macro2::Ident::new(\"read_enum_variant_arg\", proc_macro2::Span::call_site()),\n+            quote! {},\n+        )\n+    };\n+\n+    quote! {\n+        match ::rustc_serialize::Decoder::#decode_method(\n+            __decoder, #opt_field_name #index, #decode_inner_method) {\n+            ::std::result::Result::Ok(__res) => __res,\n+            ::std::result::Result::Err(__err) => return ::std::result::Result::Err(__err),\n+        }\n+    }\n+}\n+\n+pub fn type_encodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    if !s.ast().generics.lifetimes().any(|lt| lt.lifetime.ident == \"tcx\") {\n+        s.add_impl_generic(parse_quote! {'tcx});\n+    }\n+    let encoder_ty = quote! { __E };\n+    s.add_impl_generic(parse_quote! {#encoder_ty: ::rustc_middle::ty::codec::TyEncoder<'tcx>});\n+    s.add_bounds(synstructure::AddBounds::Generics);\n+\n+    encodable_body(s, encoder_ty, false)\n+}\n+\n+pub fn meta_encodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    if !s.ast().generics.lifetimes().any(|lt| lt.lifetime.ident == \"tcx\") {\n+        s.add_impl_generic(parse_quote! {'tcx});\n+    }\n+    s.add_impl_generic(parse_quote! { '__a });\n+    let encoder_ty = quote! { EncodeContext<'__a, 'tcx> };\n+    s.add_bounds(synstructure::AddBounds::Generics);\n+\n+    encodable_body(s, encoder_ty, true)\n+}\n+\n+pub fn encodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n+    let encoder_ty = quote! { __E };\n+    s.add_impl_generic(parse_quote! { #encoder_ty: ::rustc_serialize::Encoder});\n+    s.add_bounds(synstructure::AddBounds::Generics);\n+\n+    encodable_body(s, encoder_ty, false)\n+}\n+\n+fn encodable_body(\n+    mut s: synstructure::Structure<'_>,\n+    encoder_ty: TokenStream,\n+    allow_unreachable_code: bool,\n+) -> proc_macro2::TokenStream {\n+    if let syn::Data::Union(_) = s.ast().data {\n+        panic!(\"cannot derive on union\")\n+    }\n+\n+    s.bind_with(|binding| {\n+        // Handle the lack of a blanket reference impl.\n+        if let syn::Type::Reference(_) = binding.ast().ty {\n+            synstructure::BindStyle::Move\n+        } else {\n+            synstructure::BindStyle::Ref\n+        }\n+    });\n+\n+    let ty_name = s.ast().ident.to_string();\n+    let encode_body = match s.variants() {\n+        [_] => {\n+            let mut field_idx = 0usize;\n+            let encode_inner = s.each_variant(|vi| {\n+                vi.bindings()\n+                    .iter()\n+                    .map(|binding| {\n+                        let bind_ident = &binding.binding;\n+                        let field_name = binding\n+                            .ast()\n+                            .ident\n+                            .as_ref()\n+                            .map_or_else(|| field_idx.to_string(), |i| i.to_string());\n+                        let result = quote! {\n+                            match ::rustc_serialize::Encoder::emit_struct_field(\n+                                __encoder,\n+                                #field_name,\n+                                #field_idx,\n+                                |__encoder|\n+                                ::rustc_serialize::Encodable::encode(#bind_ident, __encoder),\n+                            ) {\n+                                ::std::result::Result::Ok(()) => (),\n+                                ::std::result::Result::Err(__err)\n+                                    => return ::std::result::Result::Err(__err),\n+                            }\n+                        };\n+                        field_idx += 1;\n+                        result\n+                    })\n+                    .collect::<TokenStream>()\n+            });\n+            quote! {\n+                ::rustc_serialize::Encoder::emit_struct(__encoder, #ty_name, #field_idx, |__encoder| {\n+                    ::std::result::Result::Ok(match *self { #encode_inner })\n+                })\n+            }\n+        }\n+        _ => {\n+            let mut variant_idx = 0usize;\n+            let encode_inner = s.each_variant(|vi| {\n+                let variant_name = vi.ast().ident.to_string();\n+                let mut field_idx = 0usize;\n+\n+                let encode_fields: TokenStream = vi\n+                    .bindings()\n+                    .iter()\n+                    .map(|binding| {\n+                        let bind_ident = &binding.binding;\n+                        let result = quote! {\n+                            match ::rustc_serialize::Encoder::emit_enum_variant_arg(\n+                                __encoder,\n+                                #field_idx,\n+                                |__encoder|\n+                                ::rustc_serialize::Encodable::encode(#bind_ident, __encoder),\n+                            ) {\n+                                ::std::result::Result::Ok(()) => (),\n+                                ::std::result::Result::Err(__err)\n+                                    => return ::std::result::Result::Err(__err),\n+                            }\n+                        };\n+                        field_idx += 1;\n+                        result\n+                    })\n+                    .collect();\n+\n+                let result = quote! { ::rustc_serialize::Encoder::emit_enum_variant(\n+                    __encoder,\n+                   #variant_name,\n+                   #variant_idx,\n+                   #field_idx,\n+                   |__encoder| { ::std::result::Result::Ok({ #encode_fields }) }\n+                ) };\n+                variant_idx += 1;\n+                result\n+            });\n+            quote! {\n+                ::rustc_serialize::Encoder::emit_enum(__encoder, #ty_name, |__encoder| {\n+                    match *self {\n+                        #encode_inner\n+                    }\n+                })\n+            }\n+        }\n+    };\n+\n+    let lints = if allow_unreachable_code {\n+        quote! { #![allow(unreachable_code)] }\n+    } else {\n+        quote! {}\n+    };\n+\n+    s.bound_impl(\n+        quote!(::rustc_serialize::Encodable<#encoder_ty>),\n+        quote! {\n+            fn encode(\n+                &self,\n+                __encoder: &mut #encoder_ty,\n+            ) -> ::std::result::Result<(), <#encoder_ty as ::rustc_serialize::Encoder>::Error> {\n+                #lints\n+                #encode_body\n+            }\n+        },\n+    )\n+}"}, {"sha": "352665f0ab199e2d216e31f2b4e0b9d129e340d2", "filename": "src/librustc_macros/src/symbols.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fsymbols.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -167,7 +167,7 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n             }\n         }\n \n-        macro_rules! symbols {\n+        macro_rules! define_symbols {\n             () => {\n                 #symbols_stream\n "}, {"sha": "6e3e4e55e42fd0539e3e4129cc4c94ad89d1e99d", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -23,6 +23,7 @@ rustc_hir = { path = \"../librustc_hir\" }\n rustc_hir_pretty = { path = \"../librustc_hir_pretty\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_index = { path = \"../librustc_index\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_serialize = { path = \"../librustc_serialize\" }\n stable_deref_trait = \"1.0.0\"\n rustc_ast = { path = \"../librustc_ast\" }"}, {"sha": "e50fa34554d51acbed0fc7e135651bc6d912f045", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -15,6 +15,8 @@\n \n extern crate proc_macro;\n \n+#[macro_use]\n+extern crate rustc_macros;\n #[macro_use]\n extern crate rustc_middle;\n #[macro_use]"}, {"sha": "27f59ec26383f4c5c66ce8911dc6700a0bafc286", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 113, "deletions": 123, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -7,15 +7,15 @@ use crate::rmeta::*;\n use rustc_ast::ast;\n use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::fingerprint::{Fingerprint, FingerprintDecoder};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{AtomicCell, Lock, LockGuard, Lrc, OnceCell};\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, ProcMacroDerive};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathTable;\n use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc_hir::lang_items;\n@@ -26,11 +26,11 @@ use rustc_middle::middle::cstore::{CrateSource, ExternCrate};\n use rustc_middle::middle::cstore::{ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use rustc_middle::mir::{self, interpret, Body, Promoted};\n+use rustc_middle::mir::{self, Body, Promoted};\n use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::util::common::record_time;\n-use rustc_serialize::{opaque, Decodable, Decoder, SpecializedDecoder, UseSpecializedDecodable};\n+use rustc_serialize::{opaque, Decodable, Decoder};\n use rustc_session::Session;\n use rustc_span::hygiene::ExpnDataDecodeMode;\n use rustc_span::source_map::{respan, Spanned};\n@@ -229,15 +229,15 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, TyCtxt<'tcx>) {\n     }\n }\n \n-impl<'a, 'tcx, T: Decodable> Lazy<T, ()> {\n+impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Lazy<T> {\n     fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> T {\n         let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n         T::decode(&mut dcx).unwrap()\n     }\n }\n \n-impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable> Lazy<[T], usize> {\n+impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable<DecodeContext<'a, 'tcx>>> Lazy<[T]> {\n     fn decode<M: Metadata<'a, 'tcx>>(\n         self,\n         metadata: M,\n@@ -278,6 +278,8 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n+    const CLEAR_CROSS_CRATE: bool = true;\n+\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n@@ -351,81 +353,105 @@ impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n     fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {\n         if cnum == LOCAL_CRATE { self.cdata().cnum } else { self.cdata().cnum_map[cnum] }\n     }\n-}\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T, ()>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n-        self.read_lazy_with_meta(())\n+    fn decode_alloc_id(&mut self) -> Result<rustc_middle::mir::interpret::AllocId, Self::Error> {\n+        if let Some(alloc_decoding_session) = self.alloc_decoding_session {\n+            alloc_decoding_session.decode_alloc_id(self)\n+        } else {\n+            bug!(\"Attempting to decode interpret::AllocId without CrateMetadata\")\n+        }\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<[T], usize>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Lazy<[T]>, Self::Error> {\n-        let len = self.read_usize()?;\n-        if len == 0 { Ok(Lazy::empty()) } else { self.read_lazy_with_meta(len) }\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for CrateNum {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<CrateNum, String> {\n+        let cnum = CrateNum::from_u32(d.read_u32()?);\n+        Ok(d.map_encoded_cnum_to_current(cnum))\n     }\n }\n \n-impl<'a, 'tcx, I: Idx, T> SpecializedDecoder<Lazy<Table<I, T>, usize>> for DecodeContext<'a, 'tcx>\n-where\n-    Option<T>: FixedSizeEncoding,\n-{\n-    fn specialized_decode(&mut self) -> Result<Lazy<Table<I, T>>, Self::Error> {\n-        let len = self.read_usize()?;\n-        self.read_lazy_with_meta(len)\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefIndex {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<DefIndex, String> {\n+        Ok(DefIndex::from_u32(d.read_u32()?))\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<DefId> for DecodeContext<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n-        let krate = CrateNum::decode(self)?;\n-        let index = DefIndex::decode(self)?;\n-\n-        Ok(DefId { krate, index })\n+impl<'a, 'tcx> FingerprintDecoder for DecodeContext<'a, 'tcx> {\n+    fn decode_fingerprint(&mut self) -> Result<Fingerprint, String> {\n+        Fingerprint::decode_opaque(&mut self.opaque)\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<DefIndex> for DecodeContext<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<DefIndex, Self::Error> {\n-        Ok(DefIndex::from_u32(self.read_u32()?))\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for SyntaxContext {\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<SyntaxContext, String> {\n+        let cdata = decoder.cdata();\n+        let sess = decoder.sess.unwrap();\n+        let cname = cdata.root.name;\n+        rustc_span::hygiene::decode_syntax_context(decoder, &cdata.hygiene_context, |_, id| {\n+            debug!(\"SpecializedDecoder<SyntaxContext>: decoding {}\", id);\n+            Ok(cdata\n+                .root\n+                .syntax_contexts\n+                .get(&cdata, id)\n+                .unwrap_or_else(|| panic!(\"Missing SyntaxContext {:?} for crate {:?}\", id, cname))\n+                .decode((&cdata, sess)))\n+        })\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for DecodeContext<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<LocalDefId, Self::Error> {\n-        Ok(DefId::decode(self)?.expect_local())\n-    }\n-}\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<ExpnId, String> {\n+        let local_cdata = decoder.cdata();\n+        let sess = decoder.sess.unwrap();\n+        let expn_cnum = Cell::new(None);\n+        let get_ctxt = |cnum| {\n+            expn_cnum.set(Some(cnum));\n+            if cnum == LOCAL_CRATE {\n+                &local_cdata.hygiene_context\n+            } else {\n+                &local_cdata.cstore.get_crate_data(cnum).cdata.hygiene_context\n+            }\n+        };\n \n-impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n-        if let Some(alloc_decoding_session) = self.alloc_decoding_session {\n-            alloc_decoding_session.decode_alloc_id(self)\n-        } else {\n-            bug!(\"Attempting to decode interpret::AllocId without CrateMetadata\")\n-        }\n+        rustc_span::hygiene::decode_expn_id(\n+            decoder,\n+            ExpnDataDecodeMode::Metadata(get_ctxt),\n+            |_this, index| {\n+                let cnum = expn_cnum.get().unwrap();\n+                // Lookup local `ExpnData`s in our own crate data. Foreign `ExpnData`s\n+                // are stored in the owning crate, to avoid duplication.\n+                let crate_data = if cnum == LOCAL_CRATE {\n+                    local_cdata\n+                } else {\n+                    local_cdata.cstore.get_crate_data(cnum)\n+                };\n+                Ok(crate_data\n+                    .root\n+                    .expn_data\n+                    .get(&crate_data, index)\n+                    .unwrap()\n+                    .decode((&crate_data, sess)))\n+            },\n+        )\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n-        let tag = u8::decode(self)?;\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Span {\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<Span, String> {\n+        let tag = u8::decode(decoder)?;\n \n         if tag == TAG_INVALID_SPAN {\n             return Ok(DUMMY_SP);\n         }\n \n         debug_assert!(tag == TAG_VALID_SPAN_LOCAL || tag == TAG_VALID_SPAN_FOREIGN);\n \n-        let lo = BytePos::decode(self)?;\n-        let len = BytePos::decode(self)?;\n-        let ctxt = SyntaxContext::decode(self)?;\n+        let lo = BytePos::decode(decoder)?;\n+        let len = BytePos::decode(decoder)?;\n+        let ctxt = SyntaxContext::decode(decoder)?;\n         let hi = lo + len;\n \n-        let sess = if let Some(sess) = self.sess {\n+        let sess = if let Some(sess) = decoder.sess {\n             sess\n         } else {\n             bug!(\"Cannot decode Span without Session.\")\n@@ -460,22 +486,22 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         // we can call `imported_source_files` for the proper crate, and binary search\n         // through the returned slice using our span.\n         let imported_source_files = if tag == TAG_VALID_SPAN_LOCAL {\n-            self.cdata().imported_source_files(sess)\n+            decoder.cdata().imported_source_files(sess)\n         } else {\n             // When we encode a proc-macro crate, all `Span`s should be encoded\n             // with `TAG_VALID_SPAN_LOCAL`\n-            if self.cdata().root.is_proc_macro_crate() {\n+            if decoder.cdata().root.is_proc_macro_crate() {\n                 // Decode `CrateNum` as u32 - using `CrateNum::decode` will ICE\n                 // since we don't have `cnum_map` populated.\n-                let cnum = u32::decode(self)?;\n+                let cnum = u32::decode(decoder)?;\n                 panic!(\n                     \"Decoding of crate {:?} tried to access proc-macro dep {:?}\",\n-                    self.cdata().root.name,\n+                    decoder.cdata().root.name,\n                     cnum\n                 );\n             }\n             // tag is TAG_VALID_SPAN_FOREIGN, checked by `debug_assert` above\n-            let cnum = CrateNum::decode(self)?;\n+            let cnum = CrateNum::decode(decoder)?;\n             debug!(\n                 \"SpecializedDecoder<Span>::specialized_decode: loading source files from cnum {:?}\",\n                 cnum\n@@ -485,16 +511,16 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             // not worth it to maintain a per-CrateNum cache for `last_source_file_index`.\n             // We just set it to 0, to ensure that we don't try to access something out\n             // of bounds for our initial 'guess'\n-            self.last_source_file_index = 0;\n+            decoder.last_source_file_index = 0;\n \n-            let foreign_data = self.cdata().cstore.get_crate_data(cnum);\n+            let foreign_data = decoder.cdata().cstore.get_crate_data(cnum);\n             foreign_data.imported_source_files(sess)\n         };\n \n         let source_file = {\n             // Optimize for the case that most spans within a translated item\n             // originate from the same source_file.\n-            let last_source_file = &imported_source_files[self.last_source_file_index];\n+            let last_source_file = &imported_source_files[decoder.last_source_file_index];\n \n             if lo >= last_source_file.original_start_pos && lo <= last_source_file.original_end_pos\n             {\n@@ -507,7 +533,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n                 // Don't try to cache the index for foreign spans,\n                 // as this would require a map from CrateNums to indices\n                 if tag == TAG_VALID_SPAN_LOCAL {\n-                    self.last_source_file_index = index;\n+                    decoder.last_source_file_index = index;\n                 }\n                 &imported_source_files[index]\n             }\n@@ -540,19 +566,37 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Fingerprint, Self::Error> {\n-        Fingerprint::decode_opaque(&mut self.opaque)\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n+        ty::codec::RefDecodable::decode(d)\n+    }\n+}\n+\n+impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Decodable<DecodeContext<'a, 'tcx>>\n+    for Lazy<T>\n+{\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n+        decoder.read_lazy_with_meta(())\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<mir::ClearCrossCrate<T>> for DecodeContext<'a, 'tcx>\n+impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Decodable<DecodeContext<'a, 'tcx>>\n+    for Lazy<[T]>\n+{\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n+        let len = decoder.read_usize()?;\n+        if len == 0 { Ok(Lazy::empty()) } else { decoder.read_lazy_with_meta(len) }\n+    }\n+}\n+\n+impl<'a, 'tcx, I: Idx, T: Decodable<DecodeContext<'a, 'tcx>>> Decodable<DecodeContext<'a, 'tcx>>\n+    for Lazy<Table<I, T>>\n where\n-    mir::ClearCrossCrate<T>: UseSpecializedDecodable,\n+    Option<T>: FixedSizeEncoding,\n {\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<mir::ClearCrossCrate<T>, Self::Error> {\n-        Ok(mir::ClearCrossCrate::Clear)\n+    fn decode(decoder: &mut DecodeContext<'a, 'tcx>) -> Result<Self, String> {\n+        let len = decoder.read_usize()?;\n+        decoder.read_lazy_with_meta(len)\n     }\n }\n \n@@ -1840,57 +1884,3 @@ fn macro_kind(raw: &ProcMacro) -> MacroKind {\n         ProcMacro::Bang { .. } => MacroKind::Bang,\n     }\n }\n-\n-impl<'a, 'tcx> SpecializedDecoder<SyntaxContext> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<SyntaxContext, Self::Error> {\n-        let cdata = self.cdata();\n-        let sess = self.sess.unwrap();\n-        let cname = cdata.root.name;\n-        rustc_span::hygiene::decode_syntax_context(self, &cdata.hygiene_context, |_, id| {\n-            debug!(\"SpecializedDecoder<SyntaxContext>: decoding {}\", id);\n-            Ok(cdata\n-                .root\n-                .syntax_contexts\n-                .get(&cdata, id)\n-                .unwrap_or_else(|| panic!(\"Missing SyntaxContext {:?} for crate {:?}\", id, cname))\n-                .decode((&cdata, sess)))\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedDecoder<ExpnId> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<ExpnId, Self::Error> {\n-        let local_cdata = self.cdata();\n-        let sess = self.sess.unwrap();\n-        let expn_cnum = Cell::new(None);\n-        let get_ctxt = |cnum| {\n-            expn_cnum.set(Some(cnum));\n-            if cnum == LOCAL_CRATE {\n-                &local_cdata.hygiene_context\n-            } else {\n-                &local_cdata.cstore.get_crate_data(cnum).cdata.hygiene_context\n-            }\n-        };\n-\n-        rustc_span::hygiene::decode_expn_id(\n-            self,\n-            ExpnDataDecodeMode::Metadata(get_ctxt),\n-            |_this, index| {\n-                let cnum = expn_cnum.get().unwrap();\n-                // Lookup local `ExpnData`s in our own crate data. Foreign `ExpnData`s\n-                // are stored in the owning crate, to avoid duplication.\n-                let crate_data = if cnum == LOCAL_CRATE {\n-                    local_cdata\n-                } else {\n-                    local_cdata.cstore.get_crate_data(cnum)\n-                };\n-                Ok(crate_data\n-                    .root\n-                    .expn_data\n-                    .get(&crate_data, index)\n-                    .unwrap()\n-                    .decode((&crate_data, sess)))\n-            },\n-        )\n-    }\n-}"}, {"sha": "e97e598765e98374d363a490a163f9f17e89c507", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 92, "deletions": 118, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -3,7 +3,7 @@ use crate::rmeta::*;\n \n use log::{debug, trace};\n use rustc_ast::ast;\n-use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::fingerprint::{Fingerprint, FingerprintEncoder};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{join, Lrc};\n@@ -23,11 +23,11 @@ use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::{\n     metadata_symbol_name, ExportedSymbol, SymbolExportLevel,\n };\n-use rustc_middle::mir::{self, interpret};\n+use rustc_middle::mir::interpret;\n use rustc_middle::traits::specialization_graph;\n-use rustc_middle::ty::codec::{self as ty_codec, TyEncoder};\n+use rustc_middle::ty::codec::TyEncoder;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n-use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder, UseSpecializedEncodable};\n+use rustc_serialize::{opaque, Encodable, Encoder};\n use rustc_session::config::CrateType;\n use rustc_span::hygiene::{ExpnDataEncodeMode, HygieneEncodeContext};\n use rustc_span::source_map::Spanned;\n@@ -38,7 +38,7 @@ use std::hash::Hash;\n use std::num::NonZeroUsize;\n use std::path::Path;\n \n-struct EncodeContext<'a, 'tcx> {\n+pub(super) struct EncodeContext<'a, 'tcx> {\n     opaque: opaque::Encoder,\n     tcx: TyCtxt<'tcx>,\n \n@@ -107,100 +107,87 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedEncoder<Lazy<T, ()>> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, lazy: &Lazy<T>) -> Result<(), Self::Error> {\n-        self.emit_lazy_distance(*lazy)\n+impl<'a, 'tcx, T: Encodable<EncodeContext<'a, 'tcx>>> Encodable<EncodeContext<'a, 'tcx>>\n+    for Lazy<T>\n+{\n+    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        e.emit_lazy_distance(*self)\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedEncoder<Lazy<[T], usize>> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, lazy: &Lazy<[T]>) -> Result<(), Self::Error> {\n-        self.emit_usize(lazy.meta)?;\n-        if lazy.meta == 0 {\n+impl<'a, 'tcx, T: Encodable<EncodeContext<'a, 'tcx>>> Encodable<EncodeContext<'a, 'tcx>>\n+    for Lazy<[T]>\n+{\n+    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        e.emit_usize(self.meta)?;\n+        if self.meta == 0 {\n             return Ok(());\n         }\n-        self.emit_lazy_distance(*lazy)\n+        e.emit_lazy_distance(*self)\n     }\n }\n \n-impl<'a, 'tcx, I: Idx, T> SpecializedEncoder<Lazy<Table<I, T>, usize>> for EncodeContext<'a, 'tcx>\n+impl<'a, 'tcx, I: Idx, T: Encodable<EncodeContext<'a, 'tcx>>> Encodable<EncodeContext<'a, 'tcx>>\n+    for Lazy<Table<I, T>>\n where\n     Option<T>: FixedSizeEncoding,\n {\n-    fn specialized_encode(&mut self, lazy: &Lazy<Table<I, T>>) -> Result<(), Self::Error> {\n-        self.emit_usize(lazy.meta)?;\n-        self.emit_lazy_distance(*lazy)\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedEncoder<CrateNum> for EncodeContext<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n-        self.emit_u32(cnum.as_u32())\n+    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        e.emit_usize(self.meta)?;\n+        e.emit_lazy_distance(*self)\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<DefId> for EncodeContext<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_encode(&mut self, def_id: &DefId) -> Result<(), Self::Error> {\n-        let DefId { krate, index } = *def_id;\n-\n-        krate.encode(self)?;\n-        index.encode(self)\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for DefIndex {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        s.emit_u32(self.as_u32())\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<SyntaxContext> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, ctxt: &SyntaxContext) -> Result<(), Self::Error> {\n-        rustc_span::hygiene::raw_encode_syntax_context(*ctxt, &self.hygiene_ctxt, self)\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for SyntaxContext {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        rustc_span::hygiene::raw_encode_syntax_context(*self, &s.hygiene_ctxt, s)\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<ExpnId> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, expn: &ExpnId) -> Result<(), Self::Error> {\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for ExpnId {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n         rustc_span::hygiene::raw_encode_expn_id(\n-            *expn,\n-            &self.hygiene_ctxt,\n+            *self,\n+            &s.hygiene_ctxt,\n             ExpnDataEncodeMode::Metadata,\n-            self,\n+            s,\n         )\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<DefIndex> for EncodeContext<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_encode(&mut self, def_index: &DefIndex) -> Result<(), Self::Error> {\n-        self.emit_u32(def_index.as_u32())\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n-        if span.is_dummy() {\n-            return TAG_INVALID_SPAN.encode(self);\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        if self.is_dummy() {\n+            return TAG_INVALID_SPAN.encode(s);\n         }\n \n-        let span = span.data();\n+        let span = self.data();\n \n         // The Span infrastructure should make sure that this invariant holds:\n         debug_assert!(span.lo <= span.hi);\n \n-        if !self.source_file_cache.0.contains(span.lo) {\n-            let source_map = self.tcx.sess.source_map();\n+        if !s.source_file_cache.0.contains(span.lo) {\n+            let source_map = s.tcx.sess.source_map();\n             let source_file_index = source_map.lookup_source_file_idx(span.lo);\n-            self.source_file_cache =\n+            s.source_file_cache =\n                 (source_map.files()[source_file_index].clone(), source_file_index);\n         }\n \n-        if !self.source_file_cache.0.contains(span.hi) {\n+        if !s.source_file_cache.0.contains(span.hi) {\n             // Unfortunately, macro expansion still sometimes generates Spans\n             // that malformed in this way.\n-            return TAG_INVALID_SPAN.encode(self);\n+            return TAG_INVALID_SPAN.encode(s);\n         }\n \n-        let source_files = self.required_source_files.as_mut().expect(\"Already encoded SourceMap!\");\n+        let source_files = s.required_source_files.as_mut().expect(\"Already encoded SourceMap!\");\n         // Record the fact that we need to encode the data for this `SourceFile`\n-        source_files.insert(self.source_file_cache.1);\n+        source_files.insert(s.source_file_cache.1);\n \n         // There are two possible cases here:\n         // 1. This span comes from a 'foreign' crate - e.g. some crate upstream of the\n@@ -218,7 +205,7 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n         // if we're a proc-macro crate.\n         // This allows us to avoid loading the dependencies of proc-macro crates: all of\n         // the information we need to decode `Span`s is stored in the proc-macro crate.\n-        let (tag, lo, hi) = if self.source_file_cache.0.is_imported() && !self.is_proc_macro {\n+        let (tag, lo, hi) = if s.source_file_cache.0.is_imported() && !s.is_proc_macro {\n             // To simplify deserialization, we 'rebase' this span onto the crate it originally came from\n             // (the crate that 'owns' the file it references. These rebased 'lo' and 'hi' values\n             // are relative to the source map information for the 'foreign' crate whose CrateNum\n@@ -230,26 +217,26 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n             // Span that can be used without any additional trouble.\n             let external_start_pos = {\n                 // Introduce a new scope so that we drop the 'lock()' temporary\n-                match &*self.source_file_cache.0.external_src.lock() {\n+                match &*s.source_file_cache.0.external_src.lock() {\n                     ExternalSource::Foreign { original_start_pos, .. } => *original_start_pos,\n                     src => panic!(\"Unexpected external source {:?}\", src),\n                 }\n             };\n-            let lo = (span.lo - self.source_file_cache.0.start_pos) + external_start_pos;\n-            let hi = (span.hi - self.source_file_cache.0.start_pos) + external_start_pos;\n+            let lo = (span.lo - s.source_file_cache.0.start_pos) + external_start_pos;\n+            let hi = (span.hi - s.source_file_cache.0.start_pos) + external_start_pos;\n \n             (TAG_VALID_SPAN_FOREIGN, lo, hi)\n         } else {\n             (TAG_VALID_SPAN_LOCAL, span.lo, span.hi)\n         };\n \n-        tag.encode(self)?;\n-        lo.encode(self)?;\n+        tag.encode(s)?;\n+        lo.encode(s)?;\n \n         // Encode length which is usually less than span.hi and profits more\n         // from the variable-length integer encoding that we use.\n         let len = hi - lo;\n-        len.encode(self)?;\n+        len.encode(s)?;\n \n         // Don't serialize any `SyntaxContext`s from a proc-macro crate,\n         // since we don't load proc-macro dependencies during serialization.\n@@ -282,101 +269,85 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n         // IMPORTANT: If this is ever changed, be sure to update\n         // `rustc_span::hygiene::raw_encode_expn_id` to handle\n         // encoding `ExpnData` for proc-macro crates.\n-        if self.is_proc_macro {\n-            SyntaxContext::root().encode(self)?;\n+        if s.is_proc_macro {\n+            SyntaxContext::root().encode(s)?;\n         } else {\n-            span.ctxt.encode(self)?;\n+            span.ctxt.encode(s)?;\n         }\n \n         if tag == TAG_VALID_SPAN_FOREIGN {\n-            // This needs to be two lines to avoid holding the `self.source_file_cache`\n-            // while calling `cnum.encode(self)`\n-            let cnum = self.source_file_cache.0.cnum;\n-            cnum.encode(self)?;\n+            // This needs to be two lines to avoid holding the `s.source_file_cache`\n+            // while calling `cnum.encode(s)`\n+            let cnum = s.source_file_cache.0.cnum;\n+            cnum.encode(s)?;\n         }\n \n         Ok(())\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<LocalDefId> for EncodeContext<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_encode(&mut self, def_id: &LocalDefId) -> Result<(), Self::Error> {\n-        self.specialized_encode(&def_id.to_def_id())\n+impl<'a, 'tcx> FingerprintEncoder for EncodeContext<'a, 'tcx> {\n+    fn encode_fingerprint(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n+        f.encode_opaque(&mut self.opaque)\n     }\n }\n \n-impl<'a, 'b, 'c, 'tcx> SpecializedEncoder<&'a ty::TyS<'b>> for EncodeContext<'c, 'tcx>\n-where\n-    &'a ty::TyS<'b>: UseSpecializedEncodable,\n-{\n-    fn specialized_encode(&mut self, ty: &&'a ty::TyS<'b>) -> Result<(), Self::Error> {\n-        debug_assert!(self.tcx.lift(ty).is_some());\n-        let ty = unsafe { std::mem::transmute::<&&'a ty::TyS<'b>, &&'tcx ty::TyS<'tcx>>(ty) };\n-        ty_codec::encode_with_shorthand(self, ty, |ecx| &mut ecx.type_shorthands)\n+impl<'a, 'tcx> TyEncoder<'tcx> for EncodeContext<'a, 'tcx> {\n+    const CLEAR_CROSS_CRATE: bool = true;\n+\n+    fn position(&self) -> usize {\n+        self.opaque.position()\n     }\n-}\n \n-impl<'a, 'b, 'tcx> SpecializedEncoder<ty::Predicate<'b>> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, predicate: &ty::Predicate<'b>) -> Result<(), Self::Error> {\n-        debug_assert!(self.tcx.lift(predicate).is_some());\n-        let predicate =\n-            unsafe { std::mem::transmute::<&ty::Predicate<'b>, &ty::Predicate<'tcx>>(predicate) };\n-        ty_codec::encode_with_shorthand(self, predicate, |encoder| {\n-            &mut encoder.predicate_shorthands\n-        })\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n     }\n-}\n \n-impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n-        let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n-        index.encode(self)\n+    fn type_shorthands(&mut self) -> &mut FxHashMap<Ty<'tcx>, usize> {\n+        &mut self.type_shorthands\n     }\n-}\n \n-impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n-        f.encode_opaque(&mut self.opaque)\n+    fn predicate_shorthands(&mut self) -> &mut FxHashMap<rustc_middle::ty::Predicate<'tcx>, usize> {\n+        &mut self.predicate_shorthands\n     }\n-}\n \n-impl<'a, 'tcx, T> SpecializedEncoder<mir::ClearCrossCrate<T>> for EncodeContext<'a, 'tcx>\n-where\n-    mir::ClearCrossCrate<T>: UseSpecializedEncodable,\n-{\n-    fn specialized_encode(&mut self, _: &mir::ClearCrossCrate<T>) -> Result<(), Self::Error> {\n-        Ok(())\n+    fn encode_alloc_id(\n+        &mut self,\n+        alloc_id: &rustc_middle::mir::interpret::AllocId,\n+    ) -> Result<(), Self::Error> {\n+        let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n+\n+        index.encode(self)\n     }\n }\n \n-impl<'a, 'tcx> TyEncoder for EncodeContext<'a, 'tcx> {\n-    fn position(&self) -> usize {\n-        self.opaque.position()\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n+    fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        (**self).encode(s)\n     }\n }\n \n /// Helper trait to allow overloading `EncodeContext::lazy` for iterators.\n-trait EncodeContentsForLazy<T: ?Sized + LazyMeta> {\n+trait EncodeContentsForLazy<'a, 'tcx, T: ?Sized + LazyMeta> {\n     fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'a, 'tcx>) -> T::Meta;\n }\n \n-impl<T: Encodable> EncodeContentsForLazy<T> for &T {\n+impl<'a, 'tcx, T: Encodable<EncodeContext<'a, 'tcx>>> EncodeContentsForLazy<'a, 'tcx, T> for &T {\n     fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'a, 'tcx>) {\n         self.encode(ecx).unwrap()\n     }\n }\n \n-impl<T: Encodable> EncodeContentsForLazy<T> for T {\n+impl<'a, 'tcx, T: Encodable<EncodeContext<'a, 'tcx>>> EncodeContentsForLazy<'a, 'tcx, T> for T {\n     fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'a, 'tcx>) {\n         self.encode(ecx).unwrap()\n     }\n }\n \n-impl<I, T: Encodable> EncodeContentsForLazy<[T]> for I\n+impl<'a, 'tcx, I, T: Encodable<EncodeContext<'a, 'tcx>>> EncodeContentsForLazy<'a, 'tcx, [T]> for I\n where\n     I: IntoIterator,\n-    I::Item: EncodeContentsForLazy<T>,\n+    I::Item: EncodeContentsForLazy<'a, 'tcx, T>,\n {\n     fn encode_contents_for_lazy(self, ecx: &mut EncodeContext<'a, 'tcx>) -> usize {\n         self.into_iter().map(|value| value.encode_contents_for_lazy(ecx)).count()\n@@ -421,7 +392,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.emit_usize(distance)\n     }\n \n-    fn lazy<T: ?Sized + LazyMeta>(&mut self, value: impl EncodeContentsForLazy<T>) -> Lazy<T> {\n+    fn lazy<T: ?Sized + LazyMeta>(\n+        &mut self,\n+        value: impl EncodeContentsForLazy<'a, 'tcx, T>,\n+    ) -> Lazy<T> {\n         let pos = NonZeroUsize::new(self.position()).unwrap();\n \n         assert_eq!(self.lazy_state, LazyState::NoNode);"}, {"sha": "b15c20e515f495f2d7454ceee44706ae554a2cd0", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -26,8 +26,10 @@ use rustc_target::spec::{PanicStrategy, TargetTriple};\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n \n+use decoder::DecodeContext;\n pub use decoder::{provide, provide_extern};\n crate use decoder::{CrateMetadata, CrateNumMap, MetadataBlob};\n+use encoder::EncodeContext;\n use rustc_span::hygiene::SyntaxContextData;\n \n mod decoder;\n@@ -141,9 +143,6 @@ impl<T: ?Sized + LazyMeta> Clone for Lazy<T> {\n     }\n }\n \n-impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedEncodable for Lazy<T> {}\n-impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedDecodable for Lazy<T> {}\n-\n /// Encoding / decoding state for `Lazy`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum LazyState {\n@@ -172,7 +171,7 @@ macro_rules! Lazy {\n type SyntaxContextTable = Lazy<Table<u32, Lazy<SyntaxContextData>>>;\n type ExpnDataTable = Lazy<Table<u32, Lazy<ExpnData>>>;\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(MetadataEncodable, MetadataDecodable)]\n crate struct CrateRoot<'tcx> {\n     name: Symbol,\n     triple: TargetTriple,\n@@ -221,7 +220,7 @@ crate struct CrateRoot<'tcx> {\n     symbol_mangling_version: SymbolManglingVersion,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Encodable, Decodable)]\n crate struct CrateDep {\n     pub name: Symbol,\n     pub hash: Svh,\n@@ -230,7 +229,7 @@ crate struct CrateDep {\n     pub extra_filename: String,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(MetadataEncodable, MetadataDecodable)]\n crate struct TraitImpls {\n     trait_id: (u32, DefIndex),\n     impls: Lazy<[(DefIndex, Option<ty::fast_reject::SimplifiedType>)]>,\n@@ -239,7 +238,7 @@ crate struct TraitImpls {\n /// Define `LazyTables` and `TableBuilders` at the same time.\n macro_rules! define_tables {\n     ($($name:ident: Table<DefIndex, $T:ty>),+ $(,)?) => {\n-        #[derive(RustcEncodable, RustcDecodable)]\n+        #[derive(MetadataEncodable, MetadataDecodable)]\n         crate struct LazyTables<'tcx> {\n             $($name: Lazy!(Table<DefIndex, $T>)),+\n         }\n@@ -288,7 +287,7 @@ define_tables! {\n     unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u32>>>,\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, MetadataEncodable, MetadataDecodable)]\n enum EntryKind {\n     AnonConst(mir::ConstQualifs, Lazy<RenderedConst>),\n     Const(mir::ConstQualifs, Lazy<RenderedConst>),\n@@ -324,23 +323,23 @@ enum EntryKind {\n \n /// Contains a constant which has been rendered to a String.\n /// Used by rustdoc.\n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Encodable, Decodable)]\n struct RenderedConst(String);\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(MetadataEncodable, MetadataDecodable)]\n struct ModData {\n     reexports: Lazy<[Export<hir::HirId>]>,\n     expansion: ExpnId,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(MetadataEncodable, MetadataDecodable)]\n struct FnData {\n     asyncness: hir::IsAsync,\n     constness: hir::Constness,\n     param_names: Lazy<[Ident]>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(TyEncodable, TyDecodable)]\n struct VariantData {\n     ctor_kind: CtorKind,\n     discr: ty::VariantDiscr,\n@@ -349,7 +348,7 @@ struct VariantData {\n     is_non_exhaustive: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(TyEncodable, TyDecodable)]\n struct TraitData {\n     unsafety: hir::Unsafety,\n     paren_sugar: bool,\n@@ -358,7 +357,7 @@ struct TraitData {\n     specialization_kind: ty::trait_def::TraitSpecializationKind,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(TyEncodable, TyDecodable)]\n struct ImplData {\n     polarity: ty::ImplPolarity,\n     defaultness: hir::Defaultness,\n@@ -372,7 +371,7 @@ struct ImplData {\n /// Describes whether the container of an associated item\n /// is a trait or an impl and whether, in a trait, it has\n /// a default, or an in impl, whether it's marked \"default\".\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, TyEncodable, TyDecodable)]\n enum AssocContainer {\n     TraitRequired,\n     TraitWithDefault,\n@@ -404,14 +403,14 @@ impl AssocContainer {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(MetadataEncodable, MetadataDecodable)]\n struct AssocFnData {\n     fn_data: FnData,\n     container: AssocContainer,\n     has_self: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(TyEncodable, TyDecodable)]\n struct GeneratorData<'tcx> {\n     layout: mir::GeneratorLayout<'tcx>,\n }"}, {"sha": "728ab0015d1e4e773618dcff0d967426496af680", "filename": "src/librustc_metadata/rmeta/table.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Ftable.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -2,7 +2,7 @@ use crate::rmeta::*;\n \n use log::debug;\n use rustc_index::vec::Idx;\n-use rustc_serialize::{opaque::Encoder, Encodable};\n+use rustc_serialize::opaque::Encoder;\n use std::convert::TryInto;\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n@@ -78,7 +78,7 @@ impl FixedSizeEncoding for u32 {\n // NOTE(eddyb) there could be an impl for `usize`, which would enable a more\n // generic `Lazy<T>` impl, but in the general case we might not need / want to\n // fit every `usize` in `u32`.\n-impl<T: Encodable> FixedSizeEncoding for Option<Lazy<T>> {\n+impl<T> FixedSizeEncoding for Option<Lazy<T>> {\n     fixed_size_encoding_byte_len_and_defaults!(u32::BYTE_LEN);\n \n     fn from_bytes(b: &[u8]) -> Self {\n@@ -93,7 +93,7 @@ impl<T: Encodable> FixedSizeEncoding for Option<Lazy<T>> {\n     }\n }\n \n-impl<T: Encodable> FixedSizeEncoding for Option<Lazy<[T]>> {\n+impl<T> FixedSizeEncoding for Option<Lazy<[T]>> {\n     fixed_size_encoding_byte_len_and_defaults!(u32::BYTE_LEN * 2);\n \n     fn from_bytes(b: &[u8]) -> Self {"}, {"sha": "a08941469edd9c218e560d828994201b2033d5ff", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -47,7 +47,7 @@ macro_rules! arena_types {\n             [decode] unsafety_check_result: rustc_middle::mir::UnsafetyCheckResult, rustc_middle::mir::UnsafetyCheckResult;\n             [] const_allocs: rustc_middle::mir::interpret::Allocation, rustc_middle::mir::interpret::Allocation;\n             // Required for the incremental on-disk cache\n-            [few, decode] mir_keys: rustc_hir::def_id::DefIdSet, rustc_hir::def_id::DefIdSet;\n+            [few] mir_keys: rustc_hir::def_id::DefIdSet, rustc_hir::def_id::DefIdSet;\n             [] region_scope_tree: rustc_middle::middle::region::ScopeTree, rustc_middle::middle::region::ScopeTree;\n             [] dropck_outlives:\n                 rustc_middle::infer::canonical::Canonical<'tcx,"}, {"sha": "a61b9af9bace43368b821c711dd4d577d520ee17", "filename": "src/librustc_middle/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fdep_node.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -110,8 +110,7 @@ macro_rules! define_dep_nodes {\n         $variant:ident $(( $tuple_arg_ty:ty $(,)? ))*\n       ,)*\n     ) => (\n-        #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n-                 RustcEncodable, RustcDecodable)]\n+        #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n         #[allow(non_camel_case_types)]\n         pub enum DepKind {\n             $($variant),*"}, {"sha": "be9e38aca65d10feeceb8e1d50b7fb208ef86ea5", "filename": "src/librustc_middle/hir/exports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fhir%2Fexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fhir%2Fexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fexports.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -13,7 +13,7 @@ use std::fmt::Debug;\n /// within.\n pub type ExportMap<Id> = FxHashMap<LocalDefId, Vec<Export<Id>>>;\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct Export<Id> {\n     /// The name of the target.\n     pub ident: Ident,"}, {"sha": "bcb56fae1709d94e2ca05ba1e0b4bed411260d1f", "filename": "src/librustc_middle/hir/place.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fhir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fhir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fplace.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -4,7 +4,7 @@ use crate::ty::Ty;\n use rustc_hir::HirId;\n use rustc_target::abi::VariantIdx;\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub enum PlaceBase {\n     /// A temporary variable\n     Rvalue,\n@@ -16,7 +16,7 @@ pub enum PlaceBase {\n     Upvar(ty::UpvarId),\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub enum ProjectionKind {\n     /// A dereference of a pointer, reference or `Box<T>` of the given type\n     Deref,\n@@ -36,7 +36,7 @@ pub enum ProjectionKind {\n     Subslice,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub struct Projection<'tcx> {\n     /// Type after the projection is being applied.\n     pub ty: Ty<'tcx>,\n@@ -48,7 +48,7 @@ pub struct Projection<'tcx> {\n /// A `Place` represents how a value is located in memory.\n ///\n /// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub struct Place<'tcx> {\n     /// The type of the `PlaceBase`\n     pub base_ty: Ty<'tcx>,\n@@ -61,7 +61,7 @@ pub struct Place<'tcx> {\n /// A `PlaceWithHirId` represents how a value is located in memory.\n ///\n /// This is an HIR version of `mir::Place`\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub struct PlaceWithHirId<'tcx> {\n     /// `HirId` of the expression or pattern producing this value.\n     pub hir_id: HirId,"}, {"sha": "1e15ae49a0c384e1a25ad4fcc6dd9ed5e56b3a16", "filename": "src/librustc_middle/infer/canonical.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Finfer%2Fcanonical.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -26,14 +26,13 @@ use crate::ty::subst::GenericArg;\n use crate::ty::{self, BoundVar, List, Region, TyCtxt};\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n-use rustc_serialize::UseSpecializedDecodable;\n use smallvec::SmallVec;\n use std::ops::Index;\n \n /// A \"canonicalized\" type `V` is one where all free inference\n /// variables have been rewritten to \"canonical vars\". These are\n /// numbered starting from 0 in order of first appearance.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n pub struct Canonical<'tcx, V> {\n     pub max_universe: ty::UniverseIndex,\n@@ -43,8 +42,6 @@ pub struct Canonical<'tcx, V> {\n \n pub type CanonicalVarInfos<'tcx> = &'tcx List<CanonicalVarInfo>;\n \n-impl<'tcx> UseSpecializedDecodable for CanonicalVarInfos<'tcx> {}\n-\n /// A set of values corresponding to the canonical variables from some\n /// `Canonical`. You can give these values to\n /// `canonical_value.substitute` to substitute them into the canonical\n@@ -54,7 +51,7 @@ impl<'tcx> UseSpecializedDecodable for CanonicalVarInfos<'tcx> {}\n /// vectors with the original values that were replaced by canonical\n /// variables. You will need to supply it later to instantiate the\n /// canonicalized query response.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n pub struct CanonicalVarValues<'tcx> {\n     pub var_values: IndexVec<BoundVar, GenericArg<'tcx>>,\n@@ -90,7 +87,7 @@ impl Default for OriginalQueryValues<'tcx> {\n /// canonical value. This is sufficient information for code to create\n /// a copy of the canonical value in some other inference context,\n /// with fresh inference variables replacing the canonical values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable, HashStable)]\n pub struct CanonicalVarInfo {\n     pub kind: CanonicalVarKind,\n }\n@@ -115,7 +112,7 @@ impl CanonicalVarInfo {\n /// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n /// in the type-theory sense of the term -- i.e., a \"meta\" type system\n /// that analyzes type-like values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable, HashStable)]\n pub enum CanonicalVarKind {\n     /// Some kind of type inference variable.\n     Ty(CanonicalTyVarKind),\n@@ -160,7 +157,7 @@ impl CanonicalVarKind {\n /// 22.) can only be instantiated with integral/float types (e.g.,\n /// usize or f32). In order to faithfully reproduce a type, we need to\n /// know what set of types a given type variable can be unified with.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyDecodable, TyEncodable, HashStable)]\n pub enum CanonicalTyVarKind {\n     /// General type variable `?T` that can be unified with arbitrary types.\n     General(ty::UniverseIndex),"}, {"sha": "43712de34e90a51e8646d8e32266bff3b31c9fb6", "filename": "src/librustc_middle/middle/codegen_fn_attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmiddle%2Fcodegen_fn_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmiddle%2Fcodegen_fn_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fcodegen_fn_attrs.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -3,7 +3,7 @@ use rustc_attr::{InlineAttr, OptimizeAttr};\n use rustc_session::config::SanitizerSet;\n use rustc_span::symbol::Symbol;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Encodable, Decodable, HashStable)]\n pub struct CodegenFnAttrs {\n     pub flags: CodegenFnAttrFlags,\n     /// Parsed representation of the `#[inline]` attribute\n@@ -37,7 +37,7 @@ pub struct CodegenFnAttrs {\n }\n \n bitflags! {\n-    #[derive(RustcEncodable, RustcDecodable, HashStable)]\n+    #[derive(Encodable, Decodable, HashStable)]\n     pub struct CodegenFnAttrFlags: u32 {\n         /// `#[cold]`: a hint to LLVM that this function, when called, is never on\n         /// the hot path."}, {"sha": "6a8f6c3e202038eb66cfb8c14441e95d1068bf9a", "filename": "src/librustc_middle/middle/cstore.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -25,7 +25,7 @@ use std::path::{Path, PathBuf};\n \n /// Where a crate came from on the local filesystem. One of these three options\n /// must be non-None.\n-#[derive(PartialEq, Clone, Debug, HashStable, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Clone, Debug, HashStable, Encodable, Decodable)]\n pub struct CrateSource {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n@@ -38,7 +38,7 @@ impl CrateSource {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n+#[derive(Encodable, Decodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n #[derive(HashStable)]\n pub enum CrateDepKind {\n     /// A dependency that is only used for its macros.\n@@ -60,7 +60,7 @@ impl CrateDepKind {\n     }\n }\n \n-#[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Clone, Debug, Encodable, Decodable)]\n pub enum LibSource {\n     Some(PathBuf),\n     MetadataOnly,\n@@ -80,13 +80,13 @@ impl LibSource {\n     }\n }\n \n-#[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Debug, PartialEq, Clone, Encodable, Decodable, HashStable)]\n pub enum LinkagePreference {\n     RequireDynamic,\n     RequireStatic,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, Encodable, Decodable, HashStable)]\n pub struct NativeLib {\n     pub kind: NativeLibKind,\n     pub name: Option<Symbol>,\n@@ -95,7 +95,7 @@ pub struct NativeLib {\n     pub wasm_import_module: Option<Symbol>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable)]\n pub struct ForeignModule {\n     pub foreign_items: Vec<DefId>,\n     pub def_id: DefId,\n@@ -145,7 +145,7 @@ pub enum ExternCrateSource {\n     Path,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Encodable, Decodable)]\n pub struct EncodedMetadata {\n     pub raw_data: Vec<u8>,\n }"}, {"sha": "e079843bfbc3c9dbfbf372f6e664576a373ace02", "filename": "src/librustc_middle/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fdependency_format.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -19,7 +19,7 @@ pub type DependencyList = Vec<Linkage>;\n /// This is local to the tcx, and is generally relevant to one session.\n pub type Dependencies = Vec<(CrateType, DependencyList)>;\n \n-#[derive(Copy, Clone, PartialEq, Debug, HashStable, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable, Encodable, Decodable)]\n pub enum Linkage {\n     NotLinked,\n     IncludedFromDylib,"}, {"sha": "f961cdd90862f4516cf323abea0fc767f0652223", "filename": "src/librustc_middle/middle/exported_symbols.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fexported_symbols.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -8,7 +8,7 @@ use rustc_macros::HashStable;\n /// kind of crate, including cdylibs which export very few things.\n /// `Rust` will only be exported if the crate produced is a Rust\n /// dylib.\n-#[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Eq, PartialEq, Debug, Copy, Clone, Encodable, Decodable, HashStable)]\n pub enum SymbolExportLevel {\n     C,\n     Rust,\n@@ -21,7 +21,7 @@ impl SymbolExportLevel {\n     }\n }\n \n-#[derive(Eq, PartialEq, Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Eq, PartialEq, Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n pub enum ExportedSymbol<'tcx> {\n     NonGeneric(DefId),\n     Generic(DefId, SubstsRef<'tcx>),"}, {"sha": "4c6ac82060485c9bb0ccb040cc76c6df75c634a3", "filename": "src/librustc_middle/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fregion.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -80,7 +80,7 @@ use std::fmt;\n // placate the same deriving in `ty::FreeRegion`, but we may want to\n // actually attach a more meaningful ordering to scopes than the one\n // generated via deriving here.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct Scope {\n     pub id: hir::ItemLocalId,\n@@ -104,7 +104,7 @@ impl fmt::Debug for Scope {\n     }\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum ScopeData {\n     Node,\n@@ -324,7 +324,7 @@ pub struct ScopeTree {\n     pub body_expr_count: FxHashMap<hir::BodyId, usize>,\n }\n \n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n pub struct YieldData {\n     /// The `Span` of the yield.\n     pub span: Span,"}, {"sha": "3d0144e9c8a9903e4b2d0f4545da5a6f5487fa2a", "filename": "src/librustc_middle/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fresolve_lifetime.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -11,7 +11,7 @@ use rustc_macros::HashStable;\n /// The origin of a named lifetime definition.\n ///\n /// This is used to prevent the usage of in-band lifetimes in `Fn`/`fn` syntax.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum LifetimeDefOrigin {\n     // Explicit binders like `fn foo<'a>(x: &'a u8)` or elided like `impl Foo<&u32>`\n     ExplicitOrElided,\n@@ -35,7 +35,7 @@ impl LifetimeDefOrigin {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum Region {\n     Static,\n     EarlyBound(/* index */ u32, /* lifetime decl */ DefId, LifetimeDefOrigin),\n@@ -47,7 +47,7 @@ pub enum Region {\n /// A set containing, at most, one known element.\n /// If two distinct values are inserted into a set, then it\n /// becomes `Many`, which can be used to detect ambiguities.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum Set1<T> {\n     Empty,\n     One(T),"}, {"sha": "bee8d13c762f976de14e357366fc8c8f8adec42c", "filename": "src/librustc_middle/mir/interpret/allocation.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -14,7 +14,7 @@ use super::{\n     UninitBytesAccess,\n };\n \n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct Allocation<Tag = (), Extra = ()> {\n     /// The actual bytes of the allocation.\n@@ -172,8 +172,6 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n     }\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx Allocation {}\n-\n /// Byte accessors.\n impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Just a small local helper function to avoid a bit of code repetition.\n@@ -666,7 +664,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n }\n \n /// Relocations.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n pub struct Relocations<Tag = (), Id = AllocId>(SortedMap<Size, (Tag, Id)>);\n \n impl<Tag, Id> Relocations<Tag, Id> {\n@@ -747,7 +745,7 @@ type Block = u64;\n \n /// A bitmask where each bit refers to the byte with the same index. If the bit is `true`, the byte\n /// is initialized. If it is `false` the byte is uninitialized.\n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct InitMask {\n     blocks: Vec<Block>,"}, {"sha": "059925088ce1d52d66266574111bfe509ba3dccb", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -11,7 +11,7 @@ use rustc_span::def_id::DefId;\n use rustc_target::abi::{Align, Size};\n use std::{any::Any, backtrace::Backtrace, fmt, mem};\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n pub enum ErrorHandled {\n     /// Already reported an error for this evaluation, and the compilation is\n     /// *guaranteed* to fail. Warnings/lints *must not* produce `Reported`.\n@@ -137,7 +137,7 @@ impl fmt::Display for InvalidProgramInfo<'_> {\n }\n \n /// Details of why a pointer had to be in-bounds.\n-#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Debug, Copy, Clone, TyEncodable, TyDecodable, HashStable)]\n pub enum CheckInAllocMsg {\n     MemoryAccessTest,\n     NullPointerTest,"}, {"sha": "e607da29ce453c76e8ad46ca70b514bcb2cfcdc3", "filename": "src/librustc_middle/mir/interpret/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -108,11 +108,11 @@ use rustc_data_structures::sync::{HashMapExt, Lock};\n use rustc_data_structures::tiny_list::TinyList;\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n-use rustc_serialize::{Decodable, Encodable, Encoder};\n+use rustc_serialize::{Decodable, Encodable};\n use rustc_target::abi::{Endian, Size};\n \n use crate::mir;\n-use crate::ty::codec::TyDecoder;\n+use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::subst::GenericArgKind;\n use crate::ty::{self, Instance, Ty, TyCtxt};\n \n@@ -132,7 +132,7 @@ pub use self::pointer::{Pointer, PointerArithmetic};\n /// - A constant\n /// - A static\n /// - A const fn where all arguments (if any) are zero-sized types\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, Lift)]\n pub struct GlobalId<'tcx> {\n     /// For a constant or static, the `Instance` of the item itself.\n@@ -182,17 +182,14 @@ impl fmt::Display for AllocId {\n     }\n }\n \n-impl rustc_serialize::UseSpecializedEncodable for AllocId {}\n-impl rustc_serialize::UseSpecializedDecodable for AllocId {}\n-\n-#[derive(RustcDecodable, RustcEncodable)]\n+#[derive(TyDecodable, TyEncodable)]\n enum AllocDiscriminant {\n     Alloc,\n     Fn,\n     Static,\n }\n \n-pub fn specialized_encode_alloc_id<'tcx, E: Encoder>(\n+pub fn specialized_encode_alloc_id<'tcx, E: TyEncoder<'tcx>>(\n     encoder: &mut E,\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n@@ -333,7 +330,7 @@ impl<'s> AllocDecodingSession<'s> {\n         let alloc_id = decoder.with_position(pos, |decoder| {\n             match alloc_kind {\n                 AllocDiscriminant::Alloc => {\n-                    let alloc = <&'tcx Allocation as Decodable>::decode(decoder)?;\n+                    let alloc = <&'tcx Allocation as Decodable<_>>::decode(decoder)?;\n                     // We already have a reserved `AllocId`.\n                     let alloc_id = alloc_id.unwrap();\n                     trace!(\"decoded alloc {:?}: {:#?}\", alloc_id, alloc);\n@@ -351,7 +348,7 @@ impl<'s> AllocDecodingSession<'s> {\n                 AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating extern static alloc ID\");\n-                    let did = DefId::decode(decoder)?;\n+                    let did = <DefId as Decodable<D>>::decode(decoder)?;\n                     trace!(\"decoded static def-ID: {:?}\", did);\n                     let alloc_id = decoder.tcx().create_static_alloc(did);\n                     Ok(alloc_id)\n@@ -369,7 +366,7 @@ impl<'s> AllocDecodingSession<'s> {\n \n /// An allocation in the global (tcx-managed) memory can be either a function pointer,\n /// a static, or a \"real\" allocation with some data in it.\n-#[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n+#[derive(Debug, Clone, Eq, PartialEq, Hash, TyDecodable, TyEncodable, HashStable)]\n pub enum GlobalAlloc<'tcx> {\n     /// The alloc ID is used as a function pointer.\n     Function(Instance<'tcx>),"}, {"sha": "e3d5a085613aaddfacf6fb61e2aca34521349648", "filename": "src/librustc_middle/mir/interpret/pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -87,7 +87,7 @@ impl<T: HasDataLayout> PointerArithmetic for T {}\n ///\n /// `Pointer` is generic over the `Tag` associated with each pointer,\n /// which is used to do provenance tracking during execution.\n-#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub struct Pointer<Tag = ()> {\n     pub alloc_id: AllocId,"}, {"sha": "4c47f25105d0f4eb5d049b5b5e32ab6692e5806e", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -23,7 +23,7 @@ pub struct RawConst<'tcx> {\n \n /// Represents a constant value in Rust. `Scalar` and `Slice` are optimizations for\n /// array length computations, enum discriminants and the pattern matching logic.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub enum ConstValue<'tcx> {\n     /// Used only for types with `layout::abi::Scalar` ABI and ZSTs.\n@@ -108,7 +108,7 @@ impl<'tcx> ConstValue<'tcx> {\n /// `memory::Allocation`. It is in many ways like a small chunk of a `Allocation`, up to 8 bytes in\n /// size. Like a range of bytes in an `Allocation`, a `Scalar` can either represent the raw bytes\n /// of a simple value or a pointer into another `Allocation`\n-#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub enum Scalar<Tag = ()> {\n     /// The raw bytes of a simple value.\n@@ -562,7 +562,7 @@ impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n     }\n }\n \n-#[derive(Clone, Copy, Eq, PartialEq, RustcEncodable, RustcDecodable, HashStable, Hash)]\n+#[derive(Clone, Copy, Eq, PartialEq, TyEncodable, TyDecodable, HashStable, Hash)]\n pub enum ScalarMaybeUninit<Tag = ()> {\n     Scalar(Scalar<Tag>),\n     Uninit,"}, {"sha": "c53d631568219b23e5cd4e9b31304ffd6587d91a", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -5,6 +5,7 @@\n use crate::mir::interpret::{Allocation, ConstValue, GlobalAlloc, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n+use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::subst::{Subst, SubstsRef};\n@@ -73,7 +74,7 @@ impl<'tcx> HasLocalDecls<'tcx> for Body<'tcx> {\n /// The various \"big phases\" that MIR goes through.\n ///\n /// Warning: ordering of variants is significant.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n #[derive(HashStable)]\n pub enum MirPhase {\n     Build = 0,\n@@ -91,7 +92,7 @@ impl MirPhase {\n }\n \n /// The lowered representation of a single function.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable, TypeFoldable)]\n+#[derive(Clone, TyEncodable, TyDecodable, Debug, HashStable, TypeFoldable)]\n pub struct Body<'tcx> {\n     /// A list of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n@@ -413,7 +414,7 @@ impl<'tcx> Body<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum Safety {\n     Safe,\n     /// Unsafe because of a PushUnsafeBlock\n@@ -465,9 +466,13 @@ impl<T> ClearCrossCrate<T> {\n const TAG_CLEAR_CROSS_CRATE_CLEAR: u8 = 0;\n const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n \n-impl<T: Encodable> rustc_serialize::UseSpecializedEncodable for ClearCrossCrate<T> {\n+impl<'tcx, E: TyEncoder<'tcx>, T: Encodable<E>> Encodable<E> for ClearCrossCrate<T> {\n     #[inline]\n-    fn default_encode<E: rustc_serialize::Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        if E::CLEAR_CROSS_CRATE {\n+            return Ok(());\n+        }\n+\n         match *self {\n             ClearCrossCrate::Clear => TAG_CLEAR_CROSS_CRATE_CLEAR.encode(e),\n             ClearCrossCrate::Set(ref val) => {\n@@ -477,12 +482,13 @@ impl<T: Encodable> rustc_serialize::UseSpecializedEncodable for ClearCrossCrate<\n         }\n     }\n }\n-impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<T> {\n+impl<'tcx, D: TyDecoder<'tcx>, T: Decodable<D>> Decodable<D> for ClearCrossCrate<T> {\n     #[inline]\n-    fn default_decode<D>(d: &mut D) -> Result<ClearCrossCrate<T>, D::Error>\n-    where\n-        D: rustc_serialize::Decoder,\n-    {\n+    fn decode(d: &mut D) -> Result<ClearCrossCrate<T>, D::Error> {\n+        if D::CLEAR_CROSS_CRATE {\n+            return Ok(ClearCrossCrate::Clear);\n+        }\n+\n         let discr = u8::decode(d)?;\n \n         match discr {\n@@ -491,7 +497,7 @@ impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<\n                 let val = T::decode(d)?;\n                 Ok(ClearCrossCrate::Set(val))\n             }\n-            _ => unreachable!(),\n+            tag => Err(d.error(&format!(\"Invalid tag for ClearCrossCrate: {:?}\", tag))),\n         }\n     }\n }\n@@ -501,7 +507,7 @@ impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<\n /// Most passes can work with it as a whole, within a single function.\n // The unofficial Cranelift backend, at least as of #65828, needs `SourceInfo` to implement `Eq` and\n // `Hash`. Please ping @bjorn3 if removing them.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub struct SourceInfo {\n     /// The source span for the AST pertaining to this MIR entity.\n     pub span: Span,\n@@ -521,7 +527,7 @@ impl SourceInfo {\n ///////////////////////////////////////////////////////////////////////////\n // Borrow kinds\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n@@ -632,7 +638,7 @@ pub enum LocalKind {\n     ReturnPointer,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct VarBindingForm<'tcx> {\n     /// Is variable bound via `x`, `mut x`, `ref x`, or `ref mut x`?\n     pub binding_mode: ty::BindingMode,\n@@ -654,7 +660,7 @@ pub struct VarBindingForm<'tcx> {\n     pub pat_span: Span,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable)]\n pub enum BindingForm<'tcx> {\n     /// This is a binding for a non-`self` binding, or a `self` that has an explicit type.\n     Var(VarBindingForm<'tcx>),\n@@ -665,7 +671,7 @@ pub enum BindingForm<'tcx> {\n }\n \n /// Represents what type of implicit self a function has, if any.\n-#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum ImplicitSelfKind {\n     /// Represents a `fn x(self);`.\n     Imm,\n@@ -708,7 +714,7 @@ mod binding_form_impl {\n /// involved in borrow_check errors, e.g., explanations of where the\n /// temporaries come from, when their destructors are run, and/or how\n /// one might revise the code to satisfy the borrow checker's rules.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct BlockTailInfo {\n     /// If `true`, then the value resulting from evaluating this tail\n     /// expression is ignored by the block's expression context.\n@@ -725,7 +731,7 @@ pub struct BlockTailInfo {\n ///\n /// This can be a binding declared by the user, a temporary inserted by the compiler, a function\n /// argument, or the return place.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct LocalDecl<'tcx> {\n     /// Whether this is a mutable minding (i.e., `let x` or `let mut x`).\n     ///\n@@ -863,7 +869,7 @@ static_assert_size!(LocalDecl<'_>, 56);\n ///\n /// Not used for non-StaticRef temporaries, the return place, or anonymous\n /// function parameters.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub enum LocalInfo<'tcx> {\n     /// A user-defined local variable or function parameter\n     ///\n@@ -1006,7 +1012,7 @@ impl<'tcx> LocalDecl<'tcx> {\n }\n \n /// Debug information pertaining to a user variable.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct VarDebugInfo<'tcx> {\n     pub name: Symbol,\n \n@@ -1041,7 +1047,7 @@ impl BasicBlock {\n ///////////////////////////////////////////////////////////////////////////\n // BasicBlockData and Terminator\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct BasicBlockData<'tcx> {\n     /// List of statements in this block.\n     pub statements: Vec<Statement<'tcx>>,\n@@ -1064,7 +1070,7 @@ pub struct BasicBlockData<'tcx> {\n }\n \n /// Information about an assertion failure.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, PartialEq)]\n pub enum AssertKind<O> {\n     BoundsCheck { len: O, index: O },\n     Overflow(BinOp, O, O),\n@@ -1075,7 +1081,7 @@ pub enum AssertKind<O> {\n     ResumedAfterPanic(GeneratorKind),\n }\n \n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub enum InlineAsmOperand<'tcx> {\n     In {\n         reg: InlineAsmRegOrRegClass,\n@@ -1320,7 +1326,7 @@ impl<O: fmt::Debug> fmt::Debug for AssertKind<O> {\n ///////////////////////////////////////////////////////////////////////////\n // Statements\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct Statement<'tcx> {\n     pub source_info: SourceInfo,\n     pub kind: StatementKind<'tcx>,\n@@ -1346,7 +1352,7 @@ impl Statement<'_> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub enum StatementKind<'tcx> {\n     /// Write the RHS Rvalue to the LHS Place.\n     Assign(Box<(Place<'tcx>, Rvalue<'tcx>)>),\n@@ -1399,7 +1405,7 @@ pub enum StatementKind<'tcx> {\n }\n \n /// Describes what kind of retag is to be performed.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, HashStable)]\n+#[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, PartialEq, Eq, HashStable)]\n pub enum RetagKind {\n     /// The initial retag when entering a function.\n     FnEntry,\n@@ -1412,7 +1418,7 @@ pub enum RetagKind {\n }\n \n /// The `FakeReadCause` describes the type of pattern why a FakeRead statement exists.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable, PartialEq)]\n+#[derive(Copy, Clone, TyEncodable, TyDecodable, Debug, HashStable, PartialEq)]\n pub enum FakeReadCause {\n     /// Inject a fake read of the borrowed input at the end of each guards\n     /// code.\n@@ -1454,7 +1460,7 @@ pub enum FakeReadCause {\n     ForIndex,\n }\n \n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct LlvmInlineAsm<'tcx> {\n     pub asm: hir::LlvmInlineAsmInner,\n     pub outputs: Box<[Place<'tcx>]>,\n@@ -1499,18 +1505,16 @@ impl Debug for Statement<'_> {\n \n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, HashStable)]\n pub struct Place<'tcx> {\n     pub local: Local,\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n     pub projection: &'tcx List<PlaceElem<'tcx>>,\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for Place<'tcx> {}\n-\n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable)]\n pub enum ProjectionElem<V, T> {\n     Deref,\n     Field(Field, T),\n@@ -1735,7 +1739,7 @@ rustc_index::newtype_index! {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct SourceScopeData {\n     pub span: Span,\n     pub parent_scope: Option<SourceScope>,\n@@ -1745,7 +1749,7 @@ pub struct SourceScopeData {\n     pub local_data: ClearCrossCrate<SourceScopeLocalData>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct SourceScopeLocalData {\n     /// An `HirId` with lint levels equivalent to this scope's lint levels.\n     pub lint_root: hir::HirId,\n@@ -1758,7 +1762,7 @@ pub struct SourceScopeLocalData {\n \n /// These are values that can appear inside an rvalue. They are intentionally\n /// limited to prevent rvalues from being nested in one another.\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, PartialEq, TyEncodable, TyDecodable, HashStable)]\n pub enum Operand<'tcx> {\n     /// Copy: The value must be available for use afterwards.\n     ///\n@@ -1892,7 +1896,7 @@ impl<'tcx> Operand<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n /// Rvalues\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, PartialEq)]\n pub enum Rvalue<'tcx> {\n     /// x (either a move or copy, depending on type of x)\n     Use(Operand<'tcx>),\n@@ -1938,13 +1942,13 @@ pub enum Rvalue<'tcx> {\n     Aggregate(Box<AggregateKind<'tcx>>, Vec<Operand<'tcx>>),\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum CastKind {\n     Misc,\n     Pointer(PointerCast),\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum AggregateKind<'tcx> {\n     /// The type is of the element\n     Array(Ty<'tcx>),\n@@ -1961,7 +1965,7 @@ pub enum AggregateKind<'tcx> {\n     Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum BinOp {\n     /// The `+` operator (addition)\n     Add,\n@@ -2009,15 +2013,15 @@ impl BinOp {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum NullOp {\n     /// Returns the size of a value of that type\n     SizeOf,\n     /// Creates a new uninitialized box for a value of that type\n     Box,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum UnOp {\n     /// The `!` operator for logical inversion\n     Not,\n@@ -2187,7 +2191,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// this does not necessarily mean that they are \"==\" in Rust -- in\n /// particular one must be wary of `NaN`!\n \n-#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, PartialEq, TyEncodable, TyDecodable, HashStable)]\n pub struct Constant<'tcx> {\n     pub span: Span,\n \n@@ -2248,7 +2252,7 @@ impl Constant<'tcx> {\n /// The first will lead to the constraint `w: &'1 str` (for some\n /// inferred region `'1`). The second will lead to the constraint `w:\n /// &'static str`.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct UserTypeProjections {\n     pub contents: Vec<(UserTypeProjection, Span)>,\n }\n@@ -2325,7 +2329,7 @@ impl<'tcx> UserTypeProjections {\n /// * `let (x, _): T = ...` -- here, the `projs` vector would contain\n ///   `field[0]` (aka `.0`), indicating that the type of `s` is\n ///   determined by finding the type of the `.0` field from `T`.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, PartialEq)]\n pub struct UserTypeProjection {\n     pub base: UserTypeAnnotationIndex,\n     pub projs: Vec<ProjectionKind>,"}, {"sha": "009240d0561603c070d694420d38f16dca43ade8", "filename": "src/librustc_middle/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmono.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -242,7 +242,7 @@ pub struct CodegenUnit<'tcx> {\n /// Specifies the linkage type for a `MonoItem`.\n ///\n /// See https://llvm.org/docs/LangRef.html#linkage-types for more details about these variants.\n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Debug, Encodable, Decodable, HashStable)]\n pub enum Linkage {\n     External,\n     AvailableExternally,"}, {"sha": "b16a1d53fff1cdb2ea5e4f29bcad58e1d9becc1f", "filename": "src/librustc_middle/mir/predecessors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -54,16 +54,16 @@ impl PredecessorCache {\n     }\n }\n \n-impl serialize::Encodable for PredecessorCache {\n+impl<S: serialize::Encoder> serialize::Encodable<S> for PredecessorCache {\n     #[inline]\n-    fn encode<S: serialize::Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         serialize::Encodable::encode(&(), s)\n     }\n }\n \n-impl serialize::Decodable for PredecessorCache {\n+impl<D: serialize::Decoder> serialize::Decodable<D> for PredecessorCache {\n     #[inline]\n-    fn decode<D: serialize::Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+    fn decode(d: &mut D) -> Result<Self, D::Error> {\n         serialize::Decodable::decode(d).map(|_v: ()| Self::new())\n     }\n }"}, {"sha": "0878e9313d8c5d6153a836330fc00fb85eb29de2", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -16,7 +16,7 @@ use std::fmt::{self, Debug};\n \n use super::{Field, SourceInfo};\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, TyEncodable, TyDecodable, HashStable)]\n pub enum UnsafetyViolationKind {\n     /// Only permitted in regular `fn`s, prohibited in `const fn`s.\n     General,\n@@ -35,7 +35,7 @@ pub enum UnsafetyViolationKind {\n     UnsafeFnBorrowPacked,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, TyEncodable, TyDecodable, HashStable)]\n pub enum UnsafetyViolationDetails {\n     CallToUnsafeFunction,\n     UseOfInlineAssembly,\n@@ -120,15 +120,15 @@ impl UnsafetyViolationDetails {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, TyEncodable, TyDecodable, HashStable)]\n pub struct UnsafetyViolation {\n     pub source_info: SourceInfo,\n     pub lint_root: hir::HirId,\n     pub kind: UnsafetyViolationKind,\n     pub details: UnsafetyViolationDetails,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable)]\n pub struct UnsafetyCheckResult {\n     /// Violations that are propagated *upwards* from this function.\n     pub violations: Lrc<[UnsafetyViolation]>,\n@@ -145,7 +145,7 @@ rustc_index::newtype_index! {\n }\n \n /// The layout of generator state.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct GeneratorLayout<'tcx> {\n     /// The type of every local stored inside the generator.\n     pub field_tys: IndexVec<GeneratorSavedLocal, Ty<'tcx>>,\n@@ -220,7 +220,7 @@ impl Debug for GeneratorLayout<'_> {\n     }\n }\n \n-#[derive(Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct BorrowCheckResult<'tcx> {\n     /// All the opaque types that are restricted to concrete types\n     /// by this function. Unlike the value in `TypeckResults`, this has\n@@ -235,7 +235,7 @@ pub struct BorrowCheckResult<'tcx> {\n /// Each field corresponds to an implementer of the `Qualif` trait in\n /// `librustc_mir/transform/check_consts/qualifs.rs`. See that file for more information on each\n /// `Qualif`.\n-#[derive(Clone, Copy, Debug, Default, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, Debug, Default, TyEncodable, TyDecodable, HashStable)]\n pub struct ConstQualifs {\n     pub has_mut_interior: bool,\n     pub needs_drop: bool,\n@@ -291,7 +291,7 @@ pub struct ConstQualifs {\n /// `ReEarlyBound`, `ReFree`). We use these because in a query response we\n /// cannot use `ReVar` (which is what we use internally within the rest of the\n /// NLL code).\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct ClosureRegionRequirements<'tcx> {\n     /// The number of external regions defined on the closure. In our\n     /// example above, it would be 3 -- one for `'static`, then `'1`\n@@ -307,7 +307,7 @@ pub struct ClosureRegionRequirements<'tcx> {\n \n /// Indicates an outlives-constraint between a type or between two\n /// free regions declared on the closure.\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct ClosureOutlivesRequirement<'tcx> {\n     // This region or type ...\n     pub subject: ClosureOutlivesSubject<'tcx>,\n@@ -328,7 +328,7 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n ///\n /// See also `rustc_mir::borrow_check::constraints`.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable)]\n pub enum ConstraintCategory {\n     Return(ReturnConstraint),\n     Yield,\n@@ -365,15 +365,15 @@ pub enum ConstraintCategory {\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable)]\n pub enum ReturnConstraint {\n     Normal,\n     ClosureUpvar(hir::HirId),\n }\n \n /// The subject of a `ClosureOutlivesRequirement` -- that is, the thing\n /// that must outlive some region.\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum ClosureOutlivesSubject<'tcx> {\n     /// Subject is a type, typically a type parameter, but could also\n     /// be a projection. Indicates a requirement like `T: 'a` being\n@@ -398,7 +398,7 @@ pub struct DestructuredConst<'tcx> {\n /// Coverage information summarized from a MIR if instrumented for source code coverage (see\n /// compiler option `-Zinstrument-coverage`). This information is generated by the\n /// `InstrumentCoverage` MIR pass and can be retrieved via the `coverageinfo` query.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Clone, TyEncodable, TyDecodable, Debug, HashStable)]\n pub struct CoverageInfo {\n     /// The total number of coverage region counters added to the MIR `Body`.\n     pub num_counters: u32,"}, {"sha": "0ab783812241e343afe204964f0f614cb131efb2", "filename": "src/librustc_middle/mir/terminator/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fterminator%2Fmod.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -16,7 +16,7 @@ use std::slice;\n \n pub use super::query::*;\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, PartialEq)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, PartialEq)]\n pub enum TerminatorKind<'tcx> {\n     /// Block should have one successor in the graph; we jump there.\n     Goto { target: BasicBlock },\n@@ -194,7 +194,7 @@ pub enum TerminatorKind<'tcx> {\n         destination: Option<BasicBlock>,\n     },\n }\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct Terminator<'tcx> {\n     pub source_info: SourceInfo,\n     pub kind: TerminatorKind<'tcx>,"}, {"sha": "ea9c8b7a415840b15e2adfedca48baea42093e5b", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -426,7 +426,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// ### The type parameter `N`\n ///\n /// See explanation on `ImplSourceUserDefinedData`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub enum ImplSource<'tcx, N> {\n     /// ImplSource identifying a particular impl.\n     ImplSourceUserDefined(ImplSourceUserDefinedData<'tcx, N>),\n@@ -557,14 +557,14 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n /// is `Obligation`, as one might expect. During codegen, however, this\n /// is `()`, because codegen only requires a shallow resolution of an\n /// impl, and nested obligations are satisfied later.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceUserDefinedData<'tcx, N> {\n     pub impl_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceGeneratorData<'tcx, N> {\n     pub generator_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -573,7 +573,7 @@ pub struct ImplSourceGeneratorData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceClosureData<'tcx, N> {\n     pub closure_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,\n@@ -582,18 +582,18 @@ pub struct ImplSourceClosureData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceAutoImplData<N> {\n     pub trait_def_id: DefId,\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceBuiltinData<N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(PartialEq, Eq, Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceObjectData<'tcx, N> {\n     /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n     pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -606,17 +606,17 @@ pub struct ImplSourceObjectData<'tcx, N> {\n     pub nested: Vec<N>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceFnPointerData<'tcx, N> {\n     pub fn_ty: Ty<'tcx>,\n     pub nested: Vec<N>,\n }\n \n // FIXME(@lcnr): This should be  refactored and merged with other builtin vtables.\n-#[derive(Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub struct ImplSourceDiscriminantKindData;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceTraitAliasData<'tcx, N> {\n     pub alias_def_id: DefId,\n     pub substs: SubstsRef<'tcx>,"}, {"sha": "969404c68cab7084513835d141ce4e4c9a5231ab", "filename": "src/librustc_middle/traits/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fspecialization_graph.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -23,7 +23,7 @@ use rustc_span::symbol::Ident;\n ///   parents of a given specializing impl, which is needed for extracting\n ///   default items amongst other things. In the simple \"chain\" rule, every impl\n ///   has at most one parent.\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(TyEncodable, TyDecodable, HashStable)]\n pub struct Graph {\n     /// All impls have a parent; the \"root\" impls have as their parent the `def_id`\n     /// of the trait.\n@@ -50,7 +50,7 @@ impl Graph {\n \n /// Children of a given impl, grouped into blanket/non-blanket varieties as is\n /// done in `TraitDef`.\n-#[derive(Default, RustcEncodable, RustcDecodable)]\n+#[derive(Default, TyEncodable, TyDecodable)]\n pub struct Children {\n     // Impls of a trait (or specializations of a given impl). To allow for\n     // quicker lookup, the impls are indexed by a simplified version of their"}, {"sha": "0ab07aea426c3c95d217133c567d291e0c0f8cc0", "filename": "src/librustc_middle/ty/adjustment.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fadjustment.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::{DerefMutTraitLangItem, DerefTraitLangItem};\n use rustc_macros::HashStable;\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub enum PointerCast {\n     /// Go from a fn-item type to a fn-pointer type.\n     ReifyFnPointer,\n@@ -76,7 +76,7 @@ pub enum PointerCast {\n ///    At some point, of course, `Box` should move out of the compiler, in which\n ///    case this is analogous to transforming a struct. E.g., Box<[i32; 4]> ->\n ///    Box<[i32]> is an `Adjust::Unsize` with the target `Box<[i32]>`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct Adjustment<'tcx> {\n     pub kind: Adjust<'tcx>,\n     pub target: Ty<'tcx>,\n@@ -91,7 +91,7 @@ impl Adjustment<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub enum Adjust<'tcx> {\n     /// Go from ! to any type.\n     NeverToAny,\n@@ -109,7 +109,7 @@ pub enum Adjust<'tcx> {\n /// call, with the signature `&'a T -> &'a U` or `&'a mut T -> &'a mut U`.\n /// The target type is `U` in both cases, with the region and mutability\n /// being those shared by both the receiver and the returned reference.\n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Copy, Clone, PartialEq, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub struct OverloadedDeref<'tcx> {\n     pub region: ty::Region<'tcx>,\n     pub mutbl: hir::Mutability,\n@@ -143,13 +143,13 @@ impl<'tcx> OverloadedDeref<'tcx> {\n /// new code via two-phase borrows, so we try to limit where we create two-phase\n /// capable mutable borrows.\n /// See #49434 for tracking.\n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum AllowTwoPhase {\n     Yes,\n     No,\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum AutoBorrowMutability {\n     Mut { allow_two_phase_borrow: AllowTwoPhase },\n     Not,\n@@ -164,7 +164,7 @@ impl From<AutoBorrowMutability> for hir::Mutability {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+#[derive(Copy, Clone, PartialEq, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable)]\n pub enum AutoBorrow<'tcx> {\n     /// Converts from T to &T.\n     Ref(ty::Region<'tcx>, AutoBorrowMutability),\n@@ -179,7 +179,7 @@ pub enum AutoBorrow<'tcx> {\n /// This struct can be obtained via the `coerce_impl_info` query.\n /// Demanding this struct also has the side-effect of reporting errors\n /// for inappropriate impls.\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Clone, Copy, TyEncodable, TyDecodable, Debug, HashStable)]\n pub struct CoerceUnsizedInfo {\n     /// If this is a \"custom coerce\" impl, then what kind of custom\n     /// coercion is it? This applies to impls of `CoerceUnsized` for\n@@ -188,7 +188,7 @@ pub struct CoerceUnsizedInfo {\n     pub custom_kind: Option<CustomCoerceUnsized>,\n }\n \n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(Clone, Copy, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum CustomCoerceUnsized {\n     /// Records the index of the field being coerced.\n     Struct(usize),"}, {"sha": "3237147c8ba2f589f8d4478875b88c03d2d975af", "filename": "src/librustc_middle/ty/binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fbinding.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -2,7 +2,7 @@ use rustc_hir::BindingAnnotation;\n use rustc_hir::BindingAnnotation::*;\n use rustc_hir::Mutability;\n \n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n+#[derive(Clone, PartialEq, TyEncodable, TyDecodable, Debug, Copy, HashStable)]\n pub enum BindingMode {\n     BindByReference(Mutability),\n     BindByValue(Mutability),"}, {"sha": "3a3caa55f60776f6a8a5b0bb52ac19cbc4960b0c", "filename": "src/librustc_middle/ty/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcast.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -31,7 +31,7 @@ pub enum CastTy<'tcx> {\n }\n \n /// Cast Kind. See RFC 401 (or librustc_typeck/check/cast.rs)\n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum CastKind {\n     CoercionCast,\n     PtrPtrCast,"}, {"sha": "42f55e9f5f9c7e3100b2c0306bdffaef9ae033bd", "filename": "src/librustc_middle/ty/codec.rs", "status": "modified", "additions": 206, "deletions": 318, "changes": 524, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcodec.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -8,12 +8,15 @@\n \n use crate::arena::ArenaAllocatable;\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n-use crate::mir::{self, interpret::Allocation};\n+use crate::mir::{\n+    self,\n+    interpret::{AllocId, Allocation},\n+};\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, List, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::{CrateNum, DefId};\n-use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::Span;\n use std::convert::{TryFrom, TryInto};\n use std::hash::Hash;\n@@ -25,46 +28,65 @@ use std::marker::DiscriminantKind;\n /// This offset is also chosen so that the first byte is never < 0x80.\n pub const SHORTHAND_OFFSET: usize = 0x80;\n \n-pub trait EncodableWithShorthand: Clone + Eq + Hash {\n-    type Variant: Encodable;\n+pub trait EncodableWithShorthand<'tcx, E: TyEncoder<'tcx>>: Copy + Eq + Hash {\n+    type Variant: Encodable<E>;\n     fn variant(&self) -> &Self::Variant;\n }\n \n #[allow(rustc::usage_of_ty_tykind)]\n-impl<'tcx> EncodableWithShorthand for Ty<'tcx> {\n+impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for Ty<'tcx> {\n     type Variant = ty::TyKind<'tcx>;\n     fn variant(&self) -> &Self::Variant {\n         &self.kind\n     }\n }\n \n-impl<'tcx> EncodableWithShorthand for ty::Predicate<'tcx> {\n+impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for ty::Predicate<'tcx> {\n     type Variant = ty::PredicateKind<'tcx>;\n     fn variant(&self) -> &Self::Variant {\n         self.kind()\n     }\n }\n \n-pub trait TyEncoder: Encoder {\n-    fn position(&self) -> usize;\n+pub trait OpaqueEncoder: Encoder {\n+    fn opaque(&mut self) -> &mut rustc_serialize::opaque::Encoder;\n+    fn encoder_position(&self) -> usize;\n }\n \n-impl TyEncoder for opaque::Encoder {\n+impl OpaqueEncoder for rustc_serialize::opaque::Encoder {\n+    #[inline]\n+    fn opaque(&mut self) -> &mut rustc_serialize::opaque::Encoder {\n+        self\n+    }\n     #[inline]\n-    fn position(&self) -> usize {\n+    fn encoder_position(&self) -> usize {\n         self.position()\n     }\n }\n \n+pub trait TyEncoder<'tcx>: Encoder {\n+    const CLEAR_CROSS_CRATE: bool;\n+\n+    fn tcx(&self) -> TyCtxt<'tcx>;\n+    fn position(&self) -> usize;\n+    fn type_shorthands(&mut self) -> &mut FxHashMap<Ty<'tcx>, usize>;\n+    fn predicate_shorthands(&mut self) -> &mut FxHashMap<ty::Predicate<'tcx>, usize>;\n+    fn encode_alloc_id(&mut self, alloc_id: &AllocId) -> Result<(), Self::Error>;\n+}\n+\n+pub trait RefDecodable<'tcx, D: TyDecoder<'tcx>> {\n+    fn decode(d: &mut D) -> Result<&'tcx Self, D::Error>;\n+}\n+\n /// Encode the given value or a previously cached shorthand.\n pub fn encode_with_shorthand<E, T, M>(encoder: &mut E, value: &T, cache: M) -> Result<(), E::Error>\n where\n-    E: TyEncoder,\n+    E: TyEncoder<'tcx>,\n     M: for<'b> Fn(&'b mut E) -> &'b mut FxHashMap<T, usize>,\n-    T: EncodableWithShorthand,\n+    T: EncodableWithShorthand<'tcx, E>,\n     <T::Variant as DiscriminantKind>::Discriminant: Ord + TryFrom<usize>,\n {\n-    let existing_shorthand = cache(encoder).get(value).cloned();\n+    let existing_shorthand = cache(encoder).get(value).copied();\n     if let Some(shorthand) = existing_shorthand {\n         return encoder.emit_usize(shorthand);\n     }\n@@ -89,13 +111,51 @@ where\n     // Check that the shorthand is a not longer than the\n     // full encoding itself, i.e., it's an obvious win.\n     if leb128_bits >= 64 || (shorthand as u64) < (1 << leb128_bits) {\n-        cache(encoder).insert(value.clone(), shorthand);\n+        cache(encoder).insert(*value, shorthand);\n     }\n \n     Ok(())\n }\n \n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for Ty<'tcx> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        encode_with_shorthand(e, self, TyEncoder::type_shorthands)\n+    }\n+}\n+\n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Predicate<'tcx> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        encode_with_shorthand(e, self, TyEncoder::predicate_shorthands)\n+    }\n+}\n+\n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for AllocId {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        e.encode_alloc_id(self)\n+    }\n+}\n+\n+macro_rules! encodable_via_deref {\n+    ($($t:ty),+) => {\n+        $(impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for $t {\n+            fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+                (**self).encode(e)\n+            }\n+        })*\n+    }\n+}\n+\n+encodable_via_deref! {\n+    &'tcx ty::TypeckResults<'tcx>,\n+    ty::Region<'tcx>,\n+    &'tcx mir::Body<'tcx>,\n+    &'tcx mir::UnsafetyCheckResult,\n+    &'tcx mir::BorrowCheckResult<'tcx>\n+}\n+\n pub trait TyDecoder<'tcx>: Decoder {\n+    const CLEAR_CROSS_CRATE: bool;\n+\n     fn tcx(&self) -> TyCtxt<'tcx>;\n \n     fn peek_byte(&self) -> u8;\n@@ -127,10 +187,12 @@ pub trait TyDecoder<'tcx>: Decoder {\n     fn positioned_at_shorthand(&self) -> bool {\n         (self.peek_byte() & (SHORTHAND_OFFSET as u8)) != 0\n     }\n+\n+    fn decode_alloc_id(&mut self) -> Result<AllocId, Self::Error>;\n }\n \n #[inline]\n-pub fn decode_arena_allocable<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable>(\n+pub fn decode_arena_allocable<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n     decoder: &mut D,\n ) -> Result<&'tcx T, D::Error>\n where\n@@ -140,172 +202,156 @@ where\n }\n \n #[inline]\n-pub fn decode_arena_allocable_slice<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable>(\n+pub fn decode_arena_allocable_slice<'tcx, D, T: ArenaAllocatable<'tcx> + Decodable<D>>(\n     decoder: &mut D,\n ) -> Result<&'tcx [T], D::Error>\n where\n     D: TyDecoder<'tcx>,\n {\n-    Ok(decoder.tcx().arena.alloc_from_iter(<Vec<T> as Decodable>::decode(decoder)?))\n+    Ok(decoder.tcx().arena.alloc_from_iter(<Vec<T> as Decodable<D>>::decode(decoder)?))\n }\n \n-#[inline]\n-pub fn decode_cnum<D>(decoder: &mut D) -> Result<CrateNum, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let cnum = CrateNum::from_u32(u32::decode(decoder)?);\n-    Ok(decoder.map_encoded_cnum_to_current(cnum))\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for Ty<'tcx> {\n+    #[allow(rustc::usage_of_ty_tykind)]\n+    fn decode(decoder: &mut D) -> Result<Ty<'tcx>, D::Error> {\n+        // Handle shorthands first, if we have an usize > 0x80.\n+        if decoder.positioned_at_shorthand() {\n+            let pos = decoder.read_usize()?;\n+            assert!(pos >= SHORTHAND_OFFSET);\n+            let shorthand = pos - SHORTHAND_OFFSET;\n+\n+            decoder.cached_ty_for_shorthand(shorthand, |decoder| {\n+                decoder.with_position(shorthand, Ty::decode)\n+            })\n+        } else {\n+            let tcx = decoder.tcx();\n+            Ok(tcx.mk_ty(ty::TyKind::decode(decoder)?))\n+        }\n+    }\n }\n \n-#[allow(rustc::usage_of_ty_tykind)]\n-#[inline]\n-pub fn decode_ty<D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    // Handle shorthands first, if we have an usize > 0x80.\n-    if decoder.positioned_at_shorthand() {\n-        let pos = decoder.read_usize()?;\n-        assert!(pos >= SHORTHAND_OFFSET);\n-        let shorthand = pos - SHORTHAND_OFFSET;\n-\n-        decoder.cached_ty_for_shorthand(shorthand, |decoder| {\n-            decoder.with_position(shorthand, Ty::decode)\n-        })\n-    } else {\n-        let tcx = decoder.tcx();\n-        Ok(tcx.mk_ty(ty::TyKind::decode(decoder)?))\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Predicate<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<ty::Predicate<'tcx>, D::Error> {\n+        // Handle shorthands first, if we have an usize > 0x80.\n+        let predicate_kind = if decoder.positioned_at_shorthand() {\n+            let pos = decoder.read_usize()?;\n+            assert!(pos >= SHORTHAND_OFFSET);\n+            let shorthand = pos - SHORTHAND_OFFSET;\n+\n+            decoder.with_position(shorthand, ty::PredicateKind::decode)\n+        } else {\n+            ty::PredicateKind::decode(decoder)\n+        }?;\n+        let predicate = decoder.tcx().mk_predicate(predicate_kind);\n+        Ok(predicate)\n     }\n }\n \n-#[inline]\n-pub fn decode_predicate<D>(decoder: &mut D) -> Result<ty::Predicate<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    // Handle shorthands first, if we have an usize > 0x80.\n-    if decoder.positioned_at_shorthand() {\n-        let pos = decoder.read_usize()?;\n-        assert!(pos >= SHORTHAND_OFFSET);\n-        let shorthand = pos - SHORTHAND_OFFSET;\n-\n-        decoder.cached_predicate_for_shorthand(shorthand, |decoder| {\n-            decoder.with_position(shorthand, ty::Predicate::decode)\n-        })\n-    } else {\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for SubstsRef<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+        let len = decoder.read_usize()?;\n         let tcx = decoder.tcx();\n-        Ok(tcx.mk_predicate(ty::PredicateKind::decode(decoder)?))\n+        Ok(tcx.mk_substs((0..len).map(|_| Decodable::decode(decoder)))?)\n     }\n }\n \n-#[inline]\n-pub fn decode_spanned_predicates<D>(\n-    decoder: &mut D,\n-) -> Result<&'tcx [(ty::Predicate<'tcx>, Span)], D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let tcx = decoder.tcx();\n-    Ok(tcx.arena.alloc_from_iter(\n-        (0..decoder.read_usize()?)\n-            .map(|_| Decodable::decode(decoder))\n-            .collect::<Result<Vec<_>, _>>()?,\n-    ))\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for mir::Place<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+        let local: mir::Local = Decodable::decode(decoder)?;\n+        let len = decoder.read_usize()?;\n+        let projection: &'tcx List<mir::PlaceElem<'tcx>> =\n+            decoder.tcx().mk_place_elems((0..len).map(|_| Decodable::decode(decoder)))?;\n+        Ok(mir::Place { local, projection })\n+    }\n }\n \n-#[inline]\n-pub fn decode_substs<D>(decoder: &mut D) -> Result<SubstsRef<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let len = decoder.read_usize()?;\n-    let tcx = decoder.tcx();\n-    Ok(tcx.mk_substs((0..len).map(|_| Decodable::decode(decoder)))?)\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Region<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+        Ok(decoder.tcx().mk_region(Decodable::decode(decoder)?))\n+    }\n }\n \n-#[inline]\n-pub fn decode_place<D>(decoder: &mut D) -> Result<mir::Place<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let local: mir::Local = Decodable::decode(decoder)?;\n-    let len = decoder.read_usize()?;\n-    let projection: &'tcx List<mir::PlaceElem<'tcx>> =\n-        decoder.tcx().mk_place_elems((0..len).map(|_| Decodable::decode(decoder)))?;\n-    Ok(mir::Place { local, projection })\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for CanonicalVarInfos<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+        let len = decoder.read_usize()?;\n+        let interned: Result<Vec<CanonicalVarInfo>, _> =\n+            (0..len).map(|_| Decodable::decode(decoder)).collect();\n+        Ok(decoder.tcx().intern_canonical_var_infos(interned?.as_slice()))\n+    }\n }\n \n-#[inline]\n-pub fn decode_region<D>(decoder: &mut D) -> Result<ty::Region<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    Ok(decoder.tcx().mk_region(Decodable::decode(decoder)?))\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for AllocId {\n+    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+        decoder.decode_alloc_id()\n+    }\n }\n \n-#[inline]\n-pub fn decode_ty_slice<D>(decoder: &mut D) -> Result<&'tcx ty::List<Ty<'tcx>>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let len = decoder.read_usize()?;\n-    Ok(decoder.tcx().mk_type_list((0..len).map(|_| Decodable::decode(decoder)))?)\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::SymbolName<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+        Ok(ty::SymbolName::new(decoder.tcx(), &decoder.read_str()?))\n+    }\n }\n \n-#[inline]\n-pub fn decode_adt_def<D>(decoder: &mut D) -> Result<&'tcx ty::AdtDef, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let def_id = DefId::decode(decoder)?;\n-    Ok(decoder.tcx().adt_def(def_id))\n+macro_rules! impl_decodable_via_ref {\n+    ($($t:ty),+) => {\n+        $(impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for $t {\n+            fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+                RefDecodable::decode(decoder)\n+            }\n+        })*\n+    }\n+}\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::AdtDef {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        let def_id = <DefId as Decodable<D>>::decode(decoder)?;\n+        Ok(decoder.tcx().adt_def(def_id))\n+    }\n }\n \n-#[inline]\n-pub fn decode_symbol_name<D>(decoder: &mut D) -> Result<ty::SymbolName<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    Ok(ty::SymbolName::new(decoder.tcx(), &decoder.read_str()?))\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<Ty<'tcx>> {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        let len = decoder.read_usize()?;\n+        Ok(decoder.tcx().mk_type_list((0..len).map(|_| Decodable::decode(decoder)))?)\n+    }\n }\n \n-#[inline]\n-pub fn decode_existential_predicate_slice<D>(\n-    decoder: &mut D,\n-) -> Result<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let len = decoder.read_usize()?;\n-    Ok(decoder.tcx().mk_existential_predicates((0..len).map(|_| Decodable::decode(decoder)))?)\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<ty::ExistentialPredicate<'tcx>> {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        let len = decoder.read_usize()?;\n+        Ok(decoder.tcx().mk_existential_predicates((0..len).map(|_| Decodable::decode(decoder)))?)\n+    }\n }\n \n-#[inline]\n-pub fn decode_canonical_var_infos<D>(decoder: &mut D) -> Result<CanonicalVarInfos<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    let len = decoder.read_usize()?;\n-    let interned: Result<Vec<CanonicalVarInfo>, _> =\n-        (0..len).map(|_| Decodable::decode(decoder)).collect();\n-    Ok(decoder.tcx().intern_canonical_var_infos(interned?.as_slice()))\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::Const<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        Ok(decoder.tcx().mk_const(Decodable::decode(decoder)?))\n+    }\n }\n \n-#[inline]\n-pub fn decode_const<D>(decoder: &mut D) -> Result<&'tcx ty::Const<'tcx>, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    Ok(decoder.tcx().mk_const(Decodable::decode(decoder)?))\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for Allocation {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        Ok(decoder.tcx().intern_const_alloc(Decodable::decode(decoder)?))\n+    }\n }\n \n-#[inline]\n-pub fn decode_allocation<D>(decoder: &mut D) -> Result<&'tcx Allocation, D::Error>\n-where\n-    D: TyDecoder<'tcx>,\n-{\n-    Ok(decoder.tcx().intern_const_alloc(Decodable::decode(decoder)?))\n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [(ty::Predicate<'tcx>, Span)] {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        Ok(decoder.tcx().arena.alloc_from_iter(\n+            (0..decoder.read_usize()?)\n+                .map(|_| Decodable::decode(decoder))\n+                .collect::<Result<Vec<_>, _>>()?,\n+        ))\n+    }\n+}\n+\n+impl_decodable_via_ref! {\n+    &'tcx ty::TypeckResults<'tcx>,\n+    &'tcx ty::List<Ty<'tcx>>,\n+    &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+    &'tcx Allocation,\n+    &'tcx mir::Body<'tcx>,\n+    &'tcx mir::UnsafetyCheckResult,\n+    &'tcx mir::BorrowCheckResult<'tcx>\n }\n \n #[macro_export]\n@@ -320,42 +366,21 @@ macro_rules! __impl_decoder_methods {\n     }\n }\n \n-#[macro_export]\n macro_rules! impl_arena_allocatable_decoder {\n     ([]$args:tt) => {};\n     ([decode $(, $attrs:ident)*]\n-     [[$DecoderName:ident [$($typaram:tt),*]], [$name:ident: $ty:ty, $gen_ty:ty], $tcx:lifetime]) => {\n-         // FIXME(#36588): These impls are horribly unsound as they allow\n-         // the caller to pick any lifetime for `'tcx`, including `'static`.\n-        #[allow(unused_lifetimes)]\n-        impl<'_x, '_y, '_z, '_w, '_a, $($typaram),*> SpecializedDecoder<&'_a $gen_ty>\n-        for $DecoderName<$($typaram),*>\n-        where &'_a $gen_ty: UseSpecializedDecodable\n-        {\n+     [[$name:ident: $ty:ty], $tcx:lifetime]) => {\n+        impl<$tcx, D: TyDecoder<$tcx>> RefDecodable<$tcx, D> for $ty {\n             #[inline]\n-            fn specialized_decode(&mut self) -> Result<&'_a $gen_ty, Self::Error> {\n-                unsafe {\n-                    std::mem::transmute::<\n-                        Result<&$tcx $ty, Self::Error>,\n-                        Result<&'_a $gen_ty, Self::Error>,\n-                    >(decode_arena_allocable(self))\n-                }\n+            fn decode(decoder: &mut D) -> Result<&$tcx Self, D::Error> {\n+                decode_arena_allocable(decoder)\n             }\n         }\n \n-        #[allow(unused_lifetimes)]\n-        impl<'_x, '_y, '_z, '_w, '_a, $($typaram),*> SpecializedDecoder<&'_a [$gen_ty]>\n-        for $DecoderName<$($typaram),*>\n-        where &'_a [$gen_ty]: UseSpecializedDecodable\n-        {\n+        impl<$tcx, D: TyDecoder<$tcx>> RefDecodable<$tcx, D> for [$ty] {\n             #[inline]\n-            fn specialized_decode(&mut self) -> Result<&'_a [$gen_ty], Self::Error> {\n-                unsafe {\n-                    std::mem::transmute::<\n-                        Result<&$tcx [$ty], Self::Error>,\n-                        Result<&'_a [$gen_ty], Self::Error>,\n-                    >(decode_arena_allocable_slice(self))\n-                }\n+            fn decode(decoder: &mut D) -> Result<&$tcx Self, D::Error> {\n+                decode_arena_allocable_slice(decoder)\n             }\n         }\n     };\n@@ -364,38 +389,30 @@ macro_rules! impl_arena_allocatable_decoder {\n     };\n }\n \n-#[macro_export]\n macro_rules! impl_arena_allocatable_decoders {\n-    ($args:tt, [$($a:tt $name:ident: $ty:ty, $gen_ty:ty;)*], $tcx:lifetime) => {\n+    ([], [$($a:tt $name:ident: $ty:ty, $_gen_ty:ty;)*], $tcx:lifetime) => {\n         $(\n-            impl_arena_allocatable_decoder!($a [$args, [$name: $ty, $gen_ty], $tcx]);\n+            impl_arena_allocatable_decoder!($a [[$name: $ty], $tcx]);\n         )*\n     }\n }\n \n+rustc_hir::arena_types!(impl_arena_allocatable_decoders, [], 'tcx);\n+arena_types!(impl_arena_allocatable_decoders, [], 'tcx);\n+\n #[macro_export]\n macro_rules! implement_ty_decoder {\n     ($DecoderName:ident <$($typaram:tt),*>) => {\n         mod __ty_decoder_impl {\n             use std::borrow::Cow;\n-            use std::mem::transmute;\n-\n-            use rustc_serialize::{Decoder, SpecializedDecoder, UseSpecializedDecodable};\n-\n-            use $crate::infer::canonical::CanonicalVarInfos;\n-            use $crate::ty;\n-            use $crate::ty::codec::*;\n-            use $crate::ty::subst::InternalSubsts;\n-            use rustc_hir::def_id::CrateNum;\n-\n-            use rustc_span::Span;\n+            use rustc_serialize::Decoder;\n \n             use super::$DecoderName;\n \n             impl<$($typaram ),*> Decoder for $DecoderName<$($typaram),*> {\n                 type Error = String;\n \n-                __impl_decoder_methods! {\n+                $crate::__impl_decoder_methods! {\n                     read_nil -> ();\n \n                     read_u128 -> u128;\n@@ -423,135 +440,6 @@ macro_rules! implement_ty_decoder {\n                     self.opaque.error(err)\n                 }\n             }\n-\n-            // FIXME(#36588): These impls are horribly unsound as they allow\n-            // the caller to pick any lifetime for `'tcx`, including `'static`.\n-\n-            arena_types!(impl_arena_allocatable_decoders, [$DecoderName [$($typaram),*]], 'tcx);\n-\n-            impl<$($typaram),*> SpecializedDecoder<CrateNum>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<CrateNum, Self::Error> {\n-                    decode_cnum(self)\n-                }\n-            }\n-\n-            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x ty::TyS<'_y>>\n-            for $DecoderName<$($typaram),*>\n-            where &'_x ty::TyS<'_y>: UseSpecializedDecodable\n-            {\n-                fn specialized_decode(&mut self) -> Result<&'_x ty::TyS<'_y>, Self::Error> {\n-                    unsafe {\n-                        transmute::<\n-                            Result<ty::Ty<'tcx>, Self::Error>,\n-                            Result<&'_x ty::TyS<'_y>, Self::Error>,\n-                        >(decode_ty(self))\n-                    }\n-                }\n-            }\n-\n-            impl<'_x, $($typaram),*> SpecializedDecoder<ty::Predicate<'_x>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<ty::Predicate<'_x>, Self::Error> {\n-                    unsafe {\n-                        transmute::<\n-                            Result<ty::Predicate<'tcx>, Self::Error>,\n-                            Result<ty::Predicate<'_x>, Self::Error>,\n-                        >(decode_predicate(self))\n-                    }\n-                }\n-            }\n-\n-            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x [(ty::Predicate<'_y>, Span)]>\n-            for $DecoderName<$($typaram),*>\n-            where &'_x [(ty::Predicate<'_y>, Span)]: UseSpecializedDecodable {\n-                fn specialized_decode(&mut self)\n-                                      -> Result<&'_x [(ty::Predicate<'_y>, Span)], Self::Error>\n-                {\n-                    unsafe { transmute(decode_spanned_predicates(self)) }\n-                }\n-            }\n-\n-            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x InternalSubsts<'_y>>\n-            for $DecoderName<$($typaram),*>\n-            where &'_x InternalSubsts<'_y>: UseSpecializedDecodable {\n-                fn specialized_decode(&mut self) -> Result<&'_x InternalSubsts<'_y>, Self::Error> {\n-                    unsafe { transmute(decode_substs(self)) }\n-                }\n-            }\n-\n-            impl<'_x, $($typaram),*> SpecializedDecoder<$crate::mir::Place<'_x>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(\n-                    &mut self\n-                ) -> Result<$crate::mir::Place<'_x>, Self::Error> {\n-                    unsafe { transmute(decode_place(self)) }\n-                }\n-            }\n-\n-            impl<'_x, $($typaram),*> SpecializedDecoder<ty::Region<'_x>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<ty::Region<'_x>, Self::Error> {\n-                    unsafe { transmute(decode_region(self)) }\n-                }\n-            }\n-\n-            impl<'_x, '_y, '_z, $($typaram),*> SpecializedDecoder<&'_x ty::List<&'_y ty::TyS<'_z>>>\n-            for $DecoderName<$($typaram),*>\n-            where &'_x ty::List<&'_y ty::TyS<'_z>>: UseSpecializedDecodable {\n-                fn specialized_decode(&mut self)\n-                                      -> Result<&'_x ty::List<&'_y ty::TyS<'_z>>, Self::Error> {\n-                    unsafe { transmute(decode_ty_slice(self)) }\n-                }\n-            }\n-\n-            impl<'_x, $($typaram),*> SpecializedDecoder<&'_x ty::AdtDef>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<&'_x ty::AdtDef, Self::Error> {\n-                    unsafe { transmute(decode_adt_def(self)) }\n-                }\n-            }\n-\n-            impl<'_x, $($typaram),*> SpecializedDecoder<ty::SymbolName<'_x>>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<ty::SymbolName<'_x>, Self::Error> {\n-                    unsafe { transmute(decode_symbol_name(self)) }\n-                }\n-            }\n-\n-            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x ty::List<ty::ExistentialPredicate<'_y>>>\n-            for $DecoderName<$($typaram),*>\n-            where &'_x ty::List<ty::ExistentialPredicate<'_y>>: UseSpecializedDecodable {\n-                fn specialized_decode(&mut self)\n-                    -> Result<&'_x ty::List<ty::ExistentialPredicate<'_y>>, Self::Error> {\n-                        unsafe { transmute(decode_existential_predicate_slice(self)) }\n-                }\n-            }\n-\n-            impl<'_x, $($typaram),*> SpecializedDecoder<CanonicalVarInfos<'_x>>\n-                for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self)\n-                    -> Result<CanonicalVarInfos<'_x>, Self::Error> {\n-                        unsafe { transmute(decode_canonical_var_infos(self)) }\n-                }\n-            }\n-\n-            impl<'_x, '_y, $($typaram),*> SpecializedDecoder<&'_x $crate::ty::Const<'_y>>\n-            for $DecoderName<$($typaram),*>\n-            where &'_x $crate::ty::Const<'_y>: UseSpecializedDecodable {\n-                fn specialized_decode(&mut self) -> Result<&'_x ty::Const<'_y>, Self::Error> {\n-                    unsafe { transmute(decode_const(self)) }\n-                }\n-            }\n-\n-            impl<'_x, $($typaram),*> SpecializedDecoder<&'_x $crate::mir::interpret::Allocation>\n-            for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(\n-                    &mut self\n-                ) -> Result<&'_x $crate::mir::interpret::Allocation, Self::Error> {\n-                    unsafe { transmute(decode_allocation(self)) }\n-                }\n-            }\n         }\n-    };\n+    }\n }"}, {"sha": "e883c7c6dcd2264de133ae179b31b93356fcb73a", "filename": "src/librustc_middle/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fconsts.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -15,7 +15,7 @@ pub use int::*;\n pub use kind::*;\n \n /// Typed constant value.\n-#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq, Ord, PartialOrd)]\n+#[derive(Copy, Clone, Debug, Hash, TyEncodable, TyDecodable, Eq, PartialEq, Ord, PartialOrd)]\n #[derive(HashStable)]\n pub struct Const<'tcx> {\n     pub ty: Ty<'tcx>,"}, {"sha": "a4c177160f5d039b6b6baefb380e6cf2878e998a", "filename": "src/librustc_middle/ty/consts/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -10,7 +10,7 @@ use rustc_macros::HashStable;\n use rustc_target::abi::Size;\n \n /// Represents a constant in Rust.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub enum ConstKind<'tcx> {\n     /// A const generic parameter.\n@@ -68,7 +68,7 @@ impl<'tcx> ConstKind<'tcx> {\n }\n \n /// An inference variable for a const, for use in const generics.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub enum InferConst<'tcx> {\n     /// Infer the value of the const."}, {"sha": "ba1f78e337a8311be74df8039b05996b6a3ba6f9", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -263,7 +263,7 @@ impl<'a, V> LocalTableInContextMut<'a, V> {\n }\n \n /// All information necessary to validate and reveal an `impl Trait`.\n-#[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n+#[derive(TyEncodable, TyDecodable, Debug, HashStable)]\n pub struct ResolvedOpaqueTy<'tcx> {\n     /// The revealed type as seen by this function.\n     pub concrete_type: Ty<'tcx>,\n@@ -291,7 +291,7 @@ pub struct ResolvedOpaqueTy<'tcx> {\n ///\n /// Here, we would store the type `T`, the span of the value `x`, the \"scope-span\" for\n /// the scope that contains `x`, the expr `T` evaluated from, and the span of `foo.await`.\n-#[derive(RustcEncodable, RustcDecodable, Clone, Debug, Eq, Hash, PartialEq, HashStable)]\n+#[derive(TyEncodable, TyDecodable, Clone, Debug, Eq, Hash, PartialEq, HashStable)]\n pub struct GeneratorInteriorTypeCause<'tcx> {\n     /// Type of the captured binding.\n     pub ty: Ty<'tcx>,\n@@ -305,7 +305,7 @@ pub struct GeneratorInteriorTypeCause<'tcx> {\n     pub expr: Option<hir::HirId>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Debug)]\n+#[derive(TyEncodable, TyDecodable, Debug)]\n pub struct TypeckResults<'tcx> {\n     /// The `HirId::owner` all `ItemLocalId`s in this table are relative to.\n     pub hir_owner: LocalDefId,\n@@ -728,7 +728,7 @@ rustc_index::newtype_index! {\n pub type CanonicalUserTypeAnnotations<'tcx> =\n     IndexVec<UserTypeAnnotationIndex, CanonicalUserTypeAnnotation<'tcx>>;\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable, Lift)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct CanonicalUserTypeAnnotation<'tcx> {\n     pub user_ty: CanonicalUserType<'tcx>,\n     pub span: Span,\n@@ -787,7 +787,7 @@ impl CanonicalUserType<'tcx> {\n /// A user-given type annotation attached to a constant. These arise\n /// from constants that are named via paths, like `Foo::<A>::new` and\n /// so forth.\n-#[derive(Copy, Clone, Debug, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n pub enum UserType<'tcx> {\n     Ty(Ty<'tcx>),\n@@ -1333,7 +1333,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn serialize_query_result_cache<E>(self, encoder: &mut E) -> Result<(), E::Error>\n     where\n-        E: ty::codec::TyEncoder,\n+        E: ty::codec::OpaqueEncoder,\n     {\n         self.queries.on_disk_cache.serialize(self, encoder)\n     }"}, {"sha": "7456020ee9b679ff414c7c93c830672e4efcea83", "filename": "src/librustc_middle/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffast_reject.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -17,7 +17,7 @@ pub type SimplifiedType = SimplifiedTypeGen<DefId>;\n /// because we sometimes need to use SimplifiedTypeGen values as stable sorting\n /// keys (in which case we use a DefPathHash as id-type) but in the general case\n /// the non-stable but fast to construct DefId-version is the better choice.\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, TyEncodable, TyDecodable)]\n pub enum SimplifiedTypeGen<D>\n where\n     D: Copy + Debug + Ord + Eq,"}, {"sha": "e6dafd4965bc9fb321568a1af6d9be3e738a7927", "filename": "src/librustc_middle/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Finstance.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -15,14 +15,14 @@ use std::fmt;\n /// Monomorphization happens on-the-fly and no monomorphized MIR is ever created. Instead, this type\n /// simply couples a potentially generic `InstanceDef` with some substs, and codegen and const eval\n /// will do all required substitution as they run.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, Lift)]\n pub struct Instance<'tcx> {\n     pub def: InstanceDef<'tcx>,\n     pub substs: SubstsRef<'tcx>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum InstanceDef<'tcx> {\n     /// A user-defined callable item.\n     ///"}, {"sha": "16e65d2cca4cbcfed06447c84d90c7dcc04053d0", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -165,7 +165,7 @@ pub const FAT_PTR_ADDR: usize = 0;\n /// - For a slice, this is the length.\n pub const FAT_PTR_EXTRA: usize = 1;\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, TyEncodable, TyDecodable)]\n pub enum LayoutError<'tcx> {\n     Unknown(Ty<'tcx>),\n     SizeOverflow(Ty<'tcx>),"}, {"sha": "fe390adf89f9fe70c32c94338f69807f3f7821e3", "filename": "src/librustc_middle/ty/list.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flist.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -76,9 +76,16 @@ impl<T: fmt::Debug> fmt::Debug for List<T> {\n     }\n }\n \n-impl<T: Encodable> Encodable for List<T> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for List<T> {\n     #[inline]\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for &List<T> {\n+    #[inline]\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }"}, {"sha": "ff6f0d346f7dc71491bad33d3f0a8ceed9001e2a", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 28, "deletions": 47, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -89,12 +89,11 @@ pub use self::query::queries;\n \n pub use self::consts::{Const, ConstInt, ConstKind, InferConst};\n \n+pub mod _match;\n pub mod adjustment;\n pub mod binding;\n pub mod cast;\n-#[macro_use]\n pub mod codec;\n-pub mod _match;\n mod erase_regions;\n pub mod error;\n pub mod fast_reject;\n@@ -171,7 +170,7 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, TyEncodable, TyDecodable, HashStable)]\n pub enum ImplPolarity {\n     /// `impl Trait for Type`\n     Positive,\n@@ -316,7 +315,7 @@ impl<'tcx> AssociatedItems<'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable, HashStable, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Copy, Hash, TyEncodable, TyDecodable, HashStable)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n     Public,\n@@ -403,7 +402,7 @@ impl Visibility {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, RustcDecodable, RustcEncodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, TyDecodable, TyEncodable, HashStable)]\n pub enum Variance {\n     Covariant,     // T<A> <: T<B> iff A <: B -- e.g., function return type\n     Invariant,     // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n@@ -652,27 +651,23 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TyS<'tcx> {\n #[rustc_diagnostic_item = \"Ty\"]\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n-impl<'tcx> rustc_serialize::UseSpecializedEncodable for Ty<'tcx> {}\n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for Ty<'tcx> {}\n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx List<Ty<'tcx>> {}\n-\n pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub struct UpvarPath {\n     pub hir_id: hir::HirId,\n }\n \n /// Upvars do not get their own `NodeId`. Instead, we use the pair of\n /// the original var ID (that is, the root variable that is referenced\n /// by the upvar) and the ID of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n pub struct UpvarId {\n     pub var_path: UpvarPath,\n     pub closure_expr_id: LocalDefId,\n }\n \n-#[derive(Clone, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy, HashStable)]\n+#[derive(Clone, PartialEq, Debug, TyEncodable, TyDecodable, Copy, HashStable)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -720,7 +715,7 @@ pub enum BorrowKind {\n \n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n-#[derive(PartialEq, Clone, Debug, Copy, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, HashStable)]\n pub enum UpvarCapture<'tcx> {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n@@ -731,7 +726,7 @@ pub enum UpvarCapture<'tcx> {\n     ByRef(UpvarBorrow<'tcx>),\n }\n \n-#[derive(PartialEq, Clone, Copy, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(PartialEq, Clone, Copy, TyEncodable, TyDecodable, HashStable)]\n pub struct UpvarBorrow<'tcx> {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n@@ -766,7 +761,7 @@ impl ty::EarlyBoundRegion {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub enum GenericParamDefKind {\n     Lifetime,\n     Type {\n@@ -787,7 +782,7 @@ impl GenericParamDefKind {\n     }\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct GenericParamDef {\n     pub name: Symbol,\n     pub def_id: DefId,\n@@ -831,7 +826,7 @@ pub struct GenericParamCount {\n ///\n /// The ordering of parameters is the same as in `Subst` (excluding child generics):\n /// `Self` (optionally), `Lifetime` params..., `Type` params...\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct Generics {\n     pub parent: Option<DefId>,\n     pub parent_count: usize,\n@@ -933,7 +928,7 @@ impl<'tcx> Generics {\n }\n \n /// Bounds on generics.\n-#[derive(Copy, Clone, Default, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Default, Debug, TyEncodable, TyDecodable, HashStable)]\n pub struct GenericPredicates<'tcx> {\n     pub parent: Option<DefId>,\n     pub predicates: &'tcx [(Predicate<'tcx>, Span)],\n@@ -1025,9 +1020,6 @@ pub struct Predicate<'tcx> {\n     inner: &'tcx PredicateInner<'tcx>,\n }\n \n-impl rustc_serialize::UseSpecializedEncodable for Predicate<'_> {}\n-impl rustc_serialize::UseSpecializedDecodable for Predicate<'_> {}\n-\n impl<'tcx> PartialEq for Predicate<'tcx> {\n     fn eq(&self, other: &Self) -> bool {\n         // `self.kind` is always interned.\n@@ -1103,15 +1095,15 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub enum PredicateKind<'tcx> {\n     /// `for<'a>: ...`\n     ForAll(Binder<PredicateAtom<'tcx>>),\n     Atom(PredicateAtom<'tcx>),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub enum PredicateAtom<'tcx> {\n     /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n@@ -1261,7 +1253,7 @@ impl<'tcx> Predicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>,\n@@ -1286,7 +1278,7 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct OutlivesPredicate<A, B>(pub A, pub B); // `A: B`\n pub type PolyOutlivesPredicate<A, B> = ty::Binder<OutlivesPredicate<A, B>>;\n@@ -1295,7 +1287,7 @@ pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'t\n pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<RegionOutlivesPredicate<'tcx>>;\n pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<TypeOutlivesPredicate<'tcx>>;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct SubtypePredicate<'tcx> {\n     pub a_is_expected: bool,\n@@ -1316,7 +1308,7 @@ pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n /// equality between arbitrary types. Processing an instance of\n /// Form #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n@@ -1585,7 +1577,7 @@ impl UniverseIndex {\n /// basically a name -- distinct bound regions within the same\n /// universe are just two regions with an unknown relationship to one\n /// another.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, PartialOrd, Ord)]\n pub struct Placeholder<T> {\n     pub universe: UniverseIndex,\n     pub name: T,\n@@ -1635,7 +1627,7 @@ pub type PlaceholderConst = Placeholder<BoundVar>;\n ///     a.foo::<7>();\n /// }\n /// ```\n-#[derive(Copy, Clone, Debug, TypeFoldable, Lift, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, TypeFoldable, Lift, TyEncodable, TyDecodable)]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n #[derive(Hash, HashStable)]\n pub struct WithOptConstParam<T> {\n@@ -2106,7 +2098,7 @@ impl<'tcx> VariantDef {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Encodable, Decodable, HashStable)]\n pub enum VariantDiscr {\n     /// Explicit value for this variant, i.e., `X = 123`.\n     /// The `DefId` corresponds to the embedded constant.\n@@ -2178,14 +2170,12 @@ impl Hash for AdtDef {\n     }\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedEncodable for &'tcx AdtDef {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for AdtDef {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         self.did.encode(s)\n     }\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         thread_local! {\n@@ -2229,7 +2219,7 @@ impl Into<DataTypeKind> for AdtKind {\n }\n \n bitflags! {\n-    #[derive(RustcEncodable, RustcDecodable, Default, HashStable)]\n+    #[derive(TyEncodable, TyDecodable, Default, HashStable)]\n     pub struct ReprFlags: u8 {\n         const IS_C               = 1 << 0;\n         const IS_SIMD            = 1 << 1;\n@@ -2246,7 +2236,7 @@ bitflags! {\n }\n \n /// Represents the repr options provided by the user,\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Default, HashStable)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, Default, HashStable)]\n pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n     pub align: Option<Align>,\n@@ -2690,7 +2680,7 @@ impl<'tcx> FieldDef {\n ///\n /// You can get the environment type of a closure using\n /// `tcx.closure_env_ty()`.\n-#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum ClosureKind {\n     // Warning: Ordering is significant here! The ordering is chosen\n@@ -3141,7 +3131,7 @@ pub struct CrateInherentImpls {\n     pub inherent_impls: DefIdMap<Vec<DefId>>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, HashStable)]\n pub struct SymbolName<'tcx> {\n     /// `&str` gives a consistent ordering, which ensures reproducible builds.\n     pub name: &'tcx str,\n@@ -3166,12 +3156,3 @@ impl<'tcx> fmt::Debug for SymbolName<'tcx> {\n         fmt::Display::fmt(&self.name, fmt)\n     }\n }\n-\n-impl<'tcx> rustc_serialize::UseSpecializedEncodable for SymbolName<'tcx> {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(self.name)\n-    }\n-}\n-\n-// The decoding takes place in `decode_symbol_name()`.\n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for SymbolName<'tcx> {}"}, {"sha": "007b46b11769413aeb924d68f9404ca52c2b7c9e", "filename": "src/librustc_middle/ty/query/on_disk_cache.rs", "status": "modified", "additions": 162, "deletions": 201, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -1,28 +1,24 @@\n use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n-use crate::mir::interpret;\n use crate::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use crate::ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n+use crate::mir::{self, interpret};\n+use crate::ty::codec::{OpaqueEncoder, RefDecodable, TyDecoder, TyEncoder};\n use crate::ty::context::TyCtxt;\n use crate::ty::{self, Ty};\n-use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n+use rustc_data_structures::fingerprint::{Fingerprint, FingerprintDecoder, FingerprintEncoder};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, OnceCell};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathHash;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_serialize::{\n-    opaque, Decodable, Decoder, Encodable, Encoder, SpecializedDecoder, SpecializedEncoder,\n-    UseSpecializedDecodable, UseSpecializedEncodable,\n-};\n+use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n use rustc_session::{CrateDisambiguator, Session};\n use rustc_span::hygiene::{\n     ExpnDataDecodeMode, ExpnDataEncodeMode, ExpnId, HygieneDecodeContext, HygieneEncodeContext,\n     SyntaxContext, SyntaxContextData,\n };\n use rustc_span::source_map::{SourceMap, StableSourceFileId};\n-use rustc_span::symbol::Ident;\n use rustc_span::CachingSourceMapView;\n use rustc_span::{BytePos, ExpnData, SourceFile, Span, DUMMY_SP};\n use std::mem;\n@@ -87,7 +83,7 @@ pub struct OnDiskCache<'sess> {\n }\n \n // This type is used only for serialization and deserialization.\n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Encodable, Decodable)]\n struct Footer {\n     file_index_to_stable_id: FxHashMap<SourceFileIndex, StableSourceFileId>,\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n@@ -105,10 +101,10 @@ type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n type EncodedDiagnosticsIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n type EncodedDiagnostics = Vec<Diagnostic>;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Encodable, Decodable)]\n struct SourceFileIndex(u32);\n \n-#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq, Encodable, Decodable)]\n struct AbsoluteBytePos(u32);\n \n impl AbsoluteBytePos {\n@@ -182,7 +178,7 @@ impl<'sess> OnDiskCache<'sess> {\n \n     pub fn serialize<'tcx, E>(&self, tcx: TyCtxt<'tcx>, encoder: &mut E) -> Result<(), E::Error>\n     where\n-        E: TyEncoder,\n+        E: OpaqueEncoder,\n     {\n         // Serializing the `DepGraph` should not modify it.\n         tcx.dep_graph.with_ignore(|| {\n@@ -333,7 +329,7 @@ impl<'sess> OnDiskCache<'sess> {\n \n             // Encode the position of the footer as the last 8 bytes of the\n             // file so we know where to look for it.\n-            IntEncodedWithFixedSize(footer_pos).encode(encoder.encoder)?;\n+            IntEncodedWithFixedSize(footer_pos).encode(encoder.encoder.opaque())?;\n \n             // DO NOT WRITE ANYTHING TO THE ENCODER AFTER THIS POINT! The address\n             // of the footer must be the last thing in the data stream.\n@@ -380,13 +376,13 @@ impl<'sess> OnDiskCache<'sess> {\n \n     /// Returns the cached query result if there is something in the cache for\n     /// the given `SerializedDepNodeIndex`; otherwise returns `None`.\n-    pub fn try_load_query_result<T>(\n+    crate fn try_load_query_result<'tcx, T>(\n         &self,\n-        tcx: TyCtxt<'_>,\n+        tcx: TyCtxt<'tcx>,\n         dep_node_index: SerializedDepNodeIndex,\n     ) -> Option<T>\n     where\n-        T: Decodable,\n+        T: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n         self.load_indexed(tcx, dep_node_index, &self.query_result_index, \"query result\")\n     }\n@@ -417,7 +413,7 @@ impl<'sess> OnDiskCache<'sess> {\n         debug_tag: &'static str,\n     ) -> Option<T>\n     where\n-        T: Decodable,\n+        T: for<'a> Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n         let pos = index.get(&dep_node_index).cloned()?;\n \n@@ -427,14 +423,14 @@ impl<'sess> OnDiskCache<'sess> {\n         })\n     }\n \n-    fn with_decoder<'tcx, T, F: FnOnce(&mut CacheDecoder<'sess, 'tcx>) -> T>(\n+    fn with_decoder<'a, 'tcx, T, F: FnOnce(&mut CacheDecoder<'sess, 'tcx>) -> T>(\n         &'sess self,\n         tcx: TyCtxt<'tcx>,\n         pos: AbsoluteBytePos,\n         f: F,\n     ) -> T\n     where\n-        T: Decodable,\n+        T: Decodable<CacheDecoder<'a, 'tcx>>,\n     {\n         let cnum_map =\n             self.cnum_map.get_or_init(|| Self::compute_cnum_map(tcx, &self.prev_cnums[..]));\n@@ -492,7 +488,7 @@ impl<'sess> OnDiskCache<'sess> {\n /// A decoder that can read from the incr. comp. cache. It is similar to the one\n /// we use for crate metadata decoding in that it can rebase spans and eventually\n /// will also handle things that contain `Ty` instances.\n-struct CacheDecoder<'a, 'tcx> {\n+crate struct CacheDecoder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     opaque: opaque::Decoder<'a>,\n     source_map: &'a SourceMap,\n@@ -547,8 +543,8 @@ impl<'a, 'tcx> DecoderWithPosition for CacheDecoder<'a, 'tcx> {\n // tag matches and the correct amount of bytes was read.\n fn decode_tagged<D, T, V>(decoder: &mut D, expected_tag: T) -> Result<V, D::Error>\n where\n-    T: Decodable + Eq + ::std::fmt::Debug,\n-    V: Decodable,\n+    T: Decodable<D> + Eq + ::std::fmt::Debug,\n+    V: Decodable<D>,\n     D: DecoderWithPosition,\n {\n     let start_pos = decoder.position();\n@@ -565,6 +561,8 @@ where\n }\n \n impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n+    const CLEAR_CROSS_CRATE: bool = false;\n+\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n@@ -642,14 +640,19 @@ impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n     fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {\n         self.cnum_map[cnum].unwrap_or_else(|| bug!(\"could not find new `CrateNum` for {:?}\", cnum))\n     }\n+\n+    fn decode_alloc_id(&mut self) -> Result<interpret::AllocId, Self::Error> {\n+        let alloc_decoding_session = self.alloc_decoding_session;\n+        alloc_decoding_session.decode_alloc_id(self)\n+    }\n }\n \n-implement_ty_decoder!(CacheDecoder<'a, 'tcx>);\n+crate::implement_ty_decoder!(CacheDecoder<'a, 'tcx>);\n \n-impl<'a, 'tcx> SpecializedDecoder<SyntaxContext> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<SyntaxContext, Self::Error> {\n-        let syntax_contexts = self.syntax_contexts;\n-        rustc_span::hygiene::decode_syntax_context(self, self.hygiene_context, |this, id| {\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for SyntaxContext {\n+    fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        let syntax_contexts = decoder.syntax_contexts;\n+        rustc_span::hygiene::decode_syntax_context(decoder, decoder.hygiene_context, |this, id| {\n             // This closure is invoked if we haven't already decoded the data for the `SyntaxContext` we are deserializing.\n             // We look up the position of the associated `SyntaxData` and decode it.\n             let pos = syntax_contexts.get(&id).unwrap();\n@@ -661,12 +664,12 @@ impl<'a, 'tcx> SpecializedDecoder<SyntaxContext> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<ExpnId> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<ExpnId, Self::Error> {\n-        let expn_data = self.expn_data;\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n+    fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        let expn_data = decoder.expn_data;\n         rustc_span::hygiene::decode_expn_id(\n-            self,\n-            ExpnDataDecodeMode::incr_comp(self.hygiene_context),\n+            decoder,\n+            ExpnDataDecodeMode::incr_comp(decoder.hygiene_context),\n             |this, index| {\n                 // This closure is invoked if we haven't already decoded the data for the `ExpnId` we are deserializing.\n                 // We look up the position of the associated `ExpnData` and decode it.\n@@ -683,85 +686,104 @@ impl<'a, 'tcx> SpecializedDecoder<ExpnId> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<interpret::AllocId> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<interpret::AllocId, Self::Error> {\n-        let alloc_decoding_session = self.alloc_decoding_session;\n-        alloc_decoding_session.decode_alloc_id(self)\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n-        let tag: u8 = Decodable::decode(self)?;\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for Span {\n+    fn decode(decoder: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        let tag: u8 = Decodable::decode(decoder)?;\n \n         if tag == TAG_INVALID_SPAN {\n             return Ok(DUMMY_SP);\n         } else {\n             debug_assert_eq!(tag, TAG_VALID_SPAN);\n         }\n \n-        let file_lo_index = SourceFileIndex::decode(self)?;\n-        let line_lo = usize::decode(self)?;\n-        let col_lo = BytePos::decode(self)?;\n-        let len = BytePos::decode(self)?;\n-        let ctxt = SyntaxContext::decode(self)?;\n+        let file_lo_index = SourceFileIndex::decode(decoder)?;\n+        let line_lo = usize::decode(decoder)?;\n+        let col_lo = BytePos::decode(decoder)?;\n+        let len = BytePos::decode(decoder)?;\n+        let ctxt = SyntaxContext::decode(decoder)?;\n \n-        let file_lo = self.file_index_to_file(file_lo_index);\n+        let file_lo = decoder.file_index_to_file(file_lo_index);\n         let lo = file_lo.lines[line_lo - 1] + col_lo;\n         let hi = lo + len;\n \n         Ok(Span::new(lo, hi, ctxt))\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<Ident> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Ident, Self::Error> {\n-        // FIXME: Handle hygiene in incremental\n-        bug!(\"Trying to decode Ident for incremental\");\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for CrateNum {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        let cnum = CrateNum::from_u32(u32::decode(d)?);\n+        Ok(d.map_encoded_cnum_to_current(cnum))\n     }\n }\n \n // This impl makes sure that we get a runtime error when we try decode a\n // `DefIndex` that is not contained in a `DefId`. Such a case would be problematic\n // because we would not know how to transform the `DefIndex` to the current\n // context.\n-impl<'a, 'tcx> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<DefIndex, Self::Error> {\n-        bug!(\"trying to decode `DefIndex` outside the context of a `DefId`\")\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefIndex {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<DefIndex, String> {\n+        Err(d.error(\"trying to decode `DefIndex` outside the context of a `DefId`\"))\n     }\n }\n \n // Both the `CrateNum` and the `DefIndex` of a `DefId` can change in between two\n // compilation sessions. We use the `DefPathHash`, which is stable across\n // sessions, to map the old `DefId` to the new one.\n-impl<'a, 'tcx> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for DefId {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n         // Load the `DefPathHash` which is was we encoded the `DefId` as.\n-        let def_path_hash = DefPathHash::decode(self)?;\n+        let def_path_hash = DefPathHash::decode(d)?;\n \n         // Using the `DefPathHash`, we can lookup the new `DefId`.\n-        Ok(self.tcx().def_path_hash_to_def_id.as_ref().unwrap()[&def_path_hash])\n+        Ok(d.tcx().def_path_hash_to_def_id.as_ref().unwrap()[&def_path_hash])\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for CacheDecoder<'a, 'tcx> {\n-    #[inline]\n-    fn specialized_decode(&mut self) -> Result<LocalDefId, Self::Error> {\n-        Ok(DefId::decode(self)?.expect_local())\n+impl<'a, 'tcx> FingerprintDecoder for CacheDecoder<'a, 'tcx> {\n+    fn decode_fingerprint(&mut self) -> Result<Fingerprint, Self::Error> {\n+        Fingerprint::decode_opaque(&mut self.opaque)\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Fingerprint, Self::Error> {\n-        Fingerprint::decode_opaque(&mut self.opaque)\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx FxHashSet<LocalDefId> {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        RefDecodable::decode(d)\n+    }\n+}\n+\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n+    for &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>>\n+{\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        RefDecodable::decode(d)\n+    }\n+}\n+\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        RefDecodable::decode(d)\n+    }\n+}\n+\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n+    for &'tcx [rustc_ast::ast::InlineAsmTemplatePiece]\n+{\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        RefDecodable::decode(d)\n+    }\n+}\n+\n+impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [Span] {\n+    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Result<Self, String> {\n+        RefDecodable::decode(d)\n     }\n }\n \n //- ENCODING -------------------------------------------------------------------\n \n /// An encoder that can write the incr. comp. cache.\n-struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n+struct CacheEncoder<'a, 'tcx, E: OpaqueEncoder> {\n     tcx: TyCtxt<'tcx>,\n     encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n@@ -774,7 +796,7 @@ struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n \n impl<'a, 'tcx, E> CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n     fn source_file_index(&mut self, source_file: Lrc<SourceFile>) -> SourceFileIndex {\n         self.file_to_file_index[&(&*source_file as *const SourceFile)]\n@@ -785,7 +807,7 @@ where\n     /// encode the specified tag, then the given value, then the number of\n     /// bytes taken up by tag and value. On decoding, we can then verify that\n     /// we get the expected tag and read the expected number of bytes.\n-    fn encode_tagged<T: Encodable, V: Encodable>(\n+    fn encode_tagged<T: Encodable<Self>, V: Encodable<Self>>(\n         &mut self,\n         tag: T,\n         value: &V,\n@@ -800,170 +822,111 @@ where\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-{\n-    fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n-        let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n-        index.encode(self)\n+impl<'a, 'tcx> FingerprintEncoder for CacheEncoder<'a, 'tcx, rustc_serialize::opaque::Encoder> {\n+    fn encode_fingerprint(&mut self, f: &Fingerprint) -> opaque::EncodeResult {\n+        f.encode_opaque(self.encoder)\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<SyntaxContext> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for SyntaxContext\n where\n-    E: 'a + TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n-    fn specialized_encode(&mut self, ctxt: &SyntaxContext) -> Result<(), Self::Error> {\n-        rustc_span::hygiene::raw_encode_syntax_context(*ctxt, self.hygiene_context, self)\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n+        rustc_span::hygiene::raw_encode_syntax_context(*self, s.hygiene_context, s)\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<ExpnId> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for ExpnId\n where\n-    E: 'a + TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n-    fn specialized_encode(&mut self, expn: &ExpnId) -> Result<(), Self::Error> {\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n         rustc_span::hygiene::raw_encode_expn_id(\n-            *expn,\n-            self.hygiene_context,\n+            *self,\n+            s.hygiene_context,\n             ExpnDataEncodeMode::IncrComp,\n-            self,\n+            s,\n         )\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for Span\n where\n-    E: 'a + TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n-    fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n-        if *span == DUMMY_SP {\n-            return TAG_INVALID_SPAN.encode(self);\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n+        if *self == DUMMY_SP {\n+            return TAG_INVALID_SPAN.encode(s);\n         }\n \n-        let span_data = span.data();\n-        let (file_lo, line_lo, col_lo) =\n-            match self.source_map.byte_pos_to_line_and_col(span_data.lo) {\n-                Some(pos) => pos,\n-                None => return TAG_INVALID_SPAN.encode(self),\n-            };\n+        let span_data = self.data();\n+        let (file_lo, line_lo, col_lo) = match s.source_map.byte_pos_to_line_and_col(span_data.lo) {\n+            Some(pos) => pos,\n+            None => return TAG_INVALID_SPAN.encode(s),\n+        };\n \n         if !file_lo.contains(span_data.hi) {\n-            return TAG_INVALID_SPAN.encode(self);\n+            return TAG_INVALID_SPAN.encode(s);\n         }\n \n         let len = span_data.hi - span_data.lo;\n \n-        let source_file_index = self.source_file_index(file_lo);\n+        let source_file_index = s.source_file_index(file_lo);\n \n-        TAG_VALID_SPAN.encode(self)?;\n-        source_file_index.encode(self)?;\n-        line_lo.encode(self)?;\n-        col_lo.encode(self)?;\n-        len.encode(self)?;\n-        span_data.ctxt.encode(self)?;\n-        Ok(())\n+        TAG_VALID_SPAN.encode(s)?;\n+        source_file_index.encode(s)?;\n+        line_lo.encode(s)?;\n+        col_lo.encode(s)?;\n+        len.encode(s)?;\n+        span_data.ctxt.encode(s)\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<Ident> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> TyEncoder<'tcx> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n-    fn specialized_encode(&mut self, _: &Ident) -> Result<(), Self::Error> {\n-        // We don't currently encode enough information to ensure hygiene works\n-        // with incremental, so panic rather than risk incremental bugs.\n+    const CLEAR_CROSS_CRATE: bool = false;\n \n-        // FIXME: handle hygiene in incremental.\n-        bug!(\"trying to encode `Ident` for incremental\");\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n     }\n-}\n-\n-impl<'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-{\n-    #[inline]\n     fn position(&self) -> usize {\n-        self.encoder.position()\n+        self.encoder.encoder_position()\n     }\n-}\n-\n-impl<'a, 'tcx, E> SpecializedEncoder<CrateNum> for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-{\n-    #[inline]\n-    fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n-        self.emit_u32(cnum.as_u32())\n+    fn type_shorthands(&mut self) -> &mut FxHashMap<Ty<'tcx>, usize> {\n+        &mut self.type_shorthands\n     }\n-}\n-\n-impl<'a, 'b, 'c, 'tcx, E> SpecializedEncoder<&'b ty::TyS<'c>> for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-    &'b ty::TyS<'c>: UseSpecializedEncodable,\n-{\n-    #[inline]\n-    fn specialized_encode(&mut self, ty: &&'b ty::TyS<'c>) -> Result<(), Self::Error> {\n-        debug_assert!(self.tcx.lift(ty).is_some());\n-        let ty = unsafe { std::mem::transmute::<&&'b ty::TyS<'c>, &&'tcx ty::TyS<'tcx>>(ty) };\n-        ty_codec::encode_with_shorthand(self, ty, |encoder| &mut encoder.type_shorthands)\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx, E> SpecializedEncoder<ty::Predicate<'b>> for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-{\n-    #[inline]\n-    fn specialized_encode(&mut self, predicate: &ty::Predicate<'b>) -> Result<(), Self::Error> {\n-        debug_assert!(self.tcx.lift(predicate).is_some());\n-        let predicate =\n-            unsafe { std::mem::transmute::<&ty::Predicate<'b>, &ty::Predicate<'tcx>>(predicate) };\n-        ty_codec::encode_with_shorthand(self, predicate, |encoder| {\n-            &mut encoder.predicate_shorthands\n-        })\n+    fn predicate_shorthands(&mut self) -> &mut FxHashMap<ty::Predicate<'tcx>, usize> {\n+        &mut self.predicate_shorthands\n     }\n-}\n+    fn encode_alloc_id(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n+        let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n \n-impl<'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-{\n-    #[inline]\n-    fn specialized_encode(&mut self, id: &DefId) -> Result<(), Self::Error> {\n-        let def_path_hash = self.tcx.def_path_hash(*id);\n-        def_path_hash.encode(self)\n+        index.encode(self)\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<LocalDefId> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for DefId\n where\n-    E: 'a + TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n-    #[inline]\n-    fn specialized_encode(&mut self, id: &LocalDefId) -> Result<(), Self::Error> {\n-        id.to_def_id().encode(self)\n+    fn encode(&self, s: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n+        let def_path_hash = s.tcx.def_path_hash(*self);\n+        def_path_hash.encode(s)\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> Encodable<CacheEncoder<'a, 'tcx, E>> for DefIndex\n where\n-    E: 'a + TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n-    fn specialized_encode(&mut self, _: &DefIndex) -> Result<(), Self::Error> {\n+    fn encode(&self, _: &mut CacheEncoder<'a, 'tcx, E>) -> Result<(), E::Error> {\n         bug!(\"encoding `DefIndex` without context\");\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for CacheEncoder<'a, 'tcx, opaque::Encoder> {\n-    fn specialized_encode(&mut self, f: &Fingerprint) -> Result<(), Self::Error> {\n-        f.encode_opaque(&mut self.encoder)\n-    }\n-}\n-\n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n         #[inline]\n@@ -975,7 +938,7 @@ macro_rules! encoder_methods {\n \n impl<'a, 'tcx, E> Encoder for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + TyEncoder,\n+    E: 'a + OpaqueEncoder,\n {\n     type Error = E::Error;\n \n@@ -1014,32 +977,29 @@ impl IntEncodedWithFixedSize {\n     pub const ENCODED_SIZE: usize = 8;\n }\n \n-impl UseSpecializedEncodable for IntEncodedWithFixedSize {}\n-impl UseSpecializedDecodable for IntEncodedWithFixedSize {}\n-\n-impl SpecializedEncoder<IntEncodedWithFixedSize> for opaque::Encoder {\n-    fn specialized_encode(&mut self, x: &IntEncodedWithFixedSize) -> Result<(), Self::Error> {\n-        let start_pos = self.position();\n+impl Encodable<opaque::Encoder> for IntEncodedWithFixedSize {\n+    fn encode(&self, e: &mut opaque::Encoder) -> Result<(), !> {\n+        let start_pos = e.position();\n         for i in 0..IntEncodedWithFixedSize::ENCODED_SIZE {\n-            ((x.0 >> (i * 8)) as u8).encode(self)?;\n+            ((self.0 >> (i * 8)) as u8).encode(e)?;\n         }\n-        let end_pos = self.position();\n+        let end_pos = e.position();\n         assert_eq!((end_pos - start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n         Ok(())\n     }\n }\n \n-impl<'a> SpecializedDecoder<IntEncodedWithFixedSize> for opaque::Decoder<'a> {\n-    fn specialized_decode(&mut self) -> Result<IntEncodedWithFixedSize, Self::Error> {\n+impl<'a> Decodable<opaque::Decoder<'a>> for IntEncodedWithFixedSize {\n+    fn decode(decoder: &mut opaque::Decoder<'a>) -> Result<IntEncodedWithFixedSize, String> {\n         let mut value: u64 = 0;\n-        let start_pos = self.position();\n+        let start_pos = decoder.position();\n \n         for i in 0..IntEncodedWithFixedSize::ENCODED_SIZE {\n-            let byte: u8 = Decodable::decode(self)?;\n+            let byte: u8 = Decodable::decode(decoder)?;\n             value |= (byte as u64) << (i * 8);\n         }\n \n-        let end_pos = self.position();\n+        let end_pos = decoder.position();\n         assert_eq!((end_pos - start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n \n         Ok(IntEncodedWithFixedSize(value))\n@@ -1053,8 +1013,8 @@ fn encode_query_results<'a, 'tcx, Q, E>(\n ) -> Result<(), E::Error>\n where\n     Q: super::QueryDescription<TyCtxt<'tcx>> + super::QueryAccessors<TyCtxt<'tcx>>,\n-    Q::Value: Encodable,\n-    E: 'a + TyEncoder,\n+    Q::Value: Encodable<CacheEncoder<'a, 'tcx, E>>,\n+    E: 'a + OpaqueEncoder,\n {\n     let _timer = tcx\n         .sess\n@@ -1066,15 +1026,16 @@ where\n \n     state.iter_results(|results| {\n         for (key, value, dep_node) in results {\n-            if Q::cache_on_disk(tcx, &key, Some(&value)) {\n+            if Q::cache_on_disk(tcx, &key, Some(value)) {\n                 let dep_node = SerializedDepNodeIndex::new(dep_node.index());\n \n                 // Record position of the cache entry.\n-                query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n+                query_result_index\n+                    .push((dep_node, AbsoluteBytePos::new(encoder.encoder.opaque().position())));\n \n                 // Encode the type check tables with the `SerializedDepNodeIndex`\n                 // as tag.\n-                encoder.encode_tagged(dep_node, &value)?;\n+                encoder.encode_tagged(dep_node, value)?;\n             }\n         }\n         Ok(())"}, {"sha": "dc979e52c5761fd1123a7b122544696dea6f2a7f", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -27,14 +27,14 @@ use std::marker::PhantomData;\n use std::ops::Range;\n use ty::util::IntTypeExt;\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n pub struct TypeAndMut<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub mutbl: hir::Mutability,\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, TyEncodable, TyDecodable, Copy)]\n #[derive(HashStable)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n@@ -43,7 +43,7 @@ pub struct FreeRegion {\n     pub bound_region: BoundRegion,\n }\n \n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, TyEncodable, TyDecodable, Copy)]\n #[derive(HashStable)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n@@ -82,7 +82,7 @@ impl BoundRegion {\n \n /// N.B., if you change this, you'll probably want to change the corresponding\n /// AST structure in `librustc_ast/ast.rs` as well.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable, Debug)]\n #[derive(HashStable)]\n #[rustc_diagnostic_item = \"TyKind\"]\n pub enum TyKind<'tcx> {\n@@ -215,7 +215,7 @@ impl TyKind<'tcx> {\n /// A type that is not publicly constructable. This prevents people from making `TyKind::Error`\n /// except through `tcx.err*()`.\n #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Encodable, Decodable, HashStable)]\n pub struct DelaySpanBugEmitted(pub(super) ());\n \n // `TyKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -622,7 +622,7 @@ impl<'tcx> UpvarSubsts<'tcx> {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Ord, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub enum ExistentialPredicate<'tcx> {\n     /// E.g., `Iterator`.\n@@ -673,8 +673,6 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx List<ExistentialPredicate<'tcx>> {}\n-\n impl<'tcx> List<ExistentialPredicate<'tcx>> {\n     /// Returns the \"principal `DefId`\" of this set of existential predicates.\n     ///\n@@ -770,7 +768,7 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n ///\n /// Trait references also appear in object types like `Foo<U>`, but in\n /// that case the `Self` parameter is absent from the substitutions.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n@@ -828,7 +826,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n ///\n /// The substitutions don't include the erased `Self`, only trait\n /// type and lifetime parameters (`[X, Y]` and `['a, 'b]` above).\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct ExistentialTraitRef<'tcx> {\n     pub def_id: DefId,\n@@ -884,7 +882,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n /// erase, or otherwise \"discharge\" these bound vars, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g., `liberate_late_bound_regions`).\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n pub struct Binder<T>(T);\n \n impl<T> Binder<T> {\n@@ -1016,7 +1014,7 @@ impl<T> Binder<Option<T>> {\n \n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct ProjectionTy<'tcx> {\n     /// The parameters of the associated item.\n@@ -1086,7 +1084,7 @@ impl<'tcx> PolyGenSig<'tcx> {\n /// - `inputs`: is the list of arguments and their modes.\n /// - `output`: is the return type.\n /// - `c_variadic`: indicates whether this is a C-variadic function.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct FnSig<'tcx> {\n     pub inputs_and_output: &'tcx List<Ty<'tcx>>,\n@@ -1147,7 +1145,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n \n pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<FnSig<'tcx>>>;\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct ParamTy {\n     pub index: u32,\n@@ -1172,7 +1170,7 @@ impl<'tcx> ParamTy {\n     }\n }\n \n-#[derive(Copy, Clone, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq, Ord, PartialOrd)]\n+#[derive(Copy, Clone, Hash, TyEncodable, TyDecodable, Eq, PartialEq, Ord, PartialOrd)]\n #[derive(HashStable)]\n pub struct ParamConst {\n     pub index: u32,\n@@ -1345,7 +1343,7 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// [1]: http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n /// [2]: http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n-#[derive(Clone, PartialEq, Eq, Hash, Copy, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n+#[derive(Clone, PartialEq, Eq, Hash, Copy, TyEncodable, TyDecodable, PartialOrd, Ord)]\n pub enum RegionKind {\n     /// Region bound in a type or fn declaration which will be\n     /// substituted 'early' -- that is, at the same time when type\n@@ -1383,32 +1381,30 @@ pub enum RegionKind {\n     ReErased,\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for Region<'tcx> {}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, PartialOrd, Ord)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, PartialOrd, Ord)]\n pub struct EarlyBoundRegion {\n     pub def_id: DefId,\n     pub index: u32,\n     pub name: Symbol,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct TyVid {\n     pub index: u32,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct ConstVid<'tcx> {\n     pub index: u32,\n     pub phantom: PhantomData<&'tcx ()>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct IntVid {\n     pub index: u32,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct FloatVid {\n     pub index: u32,\n }\n@@ -1425,7 +1421,7 @@ impl Atom for RegionVid {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum InferTy {\n     TyVar(TyVid),\n@@ -1444,14 +1440,14 @@ rustc_index::newtype_index! {\n     pub struct BoundVar { .. }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub struct BoundTy {\n     pub var: BoundVar,\n     pub kind: BoundTyKind,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum BoundTyKind {\n     Anon,\n@@ -1465,7 +1461,7 @@ impl From<BoundVar> for BoundTy {\n }\n \n /// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub struct ExistentialProjection<'tcx> {\n     pub item_def_id: DefId,"}, {"sha": "acd58ab7f967a6e60af7917aa41c272db3b4c55c", "filename": "src/librustc_middle/ty/subst.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsubst.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -1,13 +1,14 @@\n // Type substitutions.\n \n use crate::infer::canonical::Canonical;\n+use crate::ty::codec::{TyDecoder, TyEncoder};\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::sty::{ClosureSubsts, GeneratorSubsts};\n use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt};\n \n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n-use rustc_serialize::{self, Decodable, Decoder, Encodable, Encoder};\n+use rustc_serialize::{self, Decodable, Encodable};\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::SmallVec;\n \n@@ -34,7 +35,7 @@ const TYPE_TAG: usize = 0b00;\n const REGION_TAG: usize = 0b01;\n const CONST_TAG: usize = 0b10;\n \n-#[derive(Debug, RustcEncodable, RustcDecodable, PartialEq, Eq, PartialOrd, Ord, HashStable)]\n+#[derive(Debug, TyEncodable, TyDecodable, PartialEq, Eq, PartialOrd, Ord, HashStable)]\n pub enum GenericArgKind<'tcx> {\n     Lifetime(ty::Region<'tcx>),\n     Type(Ty<'tcx>),\n@@ -168,14 +169,14 @@ impl<'tcx> TypeFoldable<'tcx> for GenericArg<'tcx> {\n     }\n }\n \n-impl<'tcx> Encodable for GenericArg<'tcx> {\n-    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for GenericArg<'tcx> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         self.unpack().encode(e)\n     }\n }\n \n-impl<'tcx> Decodable for GenericArg<'tcx> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<GenericArg<'tcx>, D::Error> {\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for GenericArg<'tcx> {\n+    fn decode(d: &mut D) -> Result<GenericArg<'tcx>, D::Error> {\n         Ok(GenericArgKind::decode(d)?.pack())\n     }\n }\n@@ -396,8 +397,6 @@ impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n     }\n }\n \n-impl<'tcx> rustc_serialize::UseSpecializedDecodable for SubstsRef<'tcx> {}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n //\n@@ -653,7 +652,7 @@ pub type CanonicalUserSubsts<'tcx> = Canonical<'tcx, UserSubsts<'tcx>>;\n \n /// Stores the user-given substs to reach some fully qualified path\n /// (e.g., `<T>::Item` or `<T as Trait>::Item`).\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n pub struct UserSubsts<'tcx> {\n     /// The substitutions for the item as given by the user.\n@@ -680,7 +679,7 @@ pub struct UserSubsts<'tcx> {\n /// the impl (with the substs from `UserSubsts`) and apply those to\n /// the self type, giving `Foo<?A>`. Finally, we unify that with\n /// the self type here, which contains `?A` to be `&'static u32`\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n pub struct UserSelfTy<'tcx> {\n     pub impl_def_id: DefId,"}, {"sha": "86fe3ac3751aff2247a57155a3eb50bf8003d181", "filename": "src/librustc_middle/ty/trait_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ftrait_def.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -47,7 +47,7 @@ pub struct TraitDef {\n \n /// Whether this trait is treated specially by the standard library\n /// specialization lint.\n-#[derive(HashStable, PartialEq, Clone, Copy, RustcEncodable, RustcDecodable)]\n+#[derive(HashStable, PartialEq, Clone, Copy, TyEncodable, TyDecodable)]\n pub enum TraitSpecializationKind {\n     /// The default. Specializing on this trait is not allowed.\n     None,"}, {"sha": "23507ac830d553c48a31e34a54896968753b7059", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -1143,7 +1143,7 @@ pub fn needs_drop_components(\n     }\n }\n \n-#[derive(Copy, Clone, Debug, HashStable, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, HashStable, TyEncodable, TyDecodable)]\n pub struct AlwaysRequiresDrop;\n \n /// Normalizes all opaque types in the given value, replacing them"}, {"sha": "c1ec452e001bb3a84c0575ed3f4ae7177f0c2525", "filename": "src/librustc_query_system/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2FCargo.toml?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -15,6 +15,7 @@ log = { package = \"tracing\", version = \"0.1\" }\n rustc-rayon-core = \"0.3.0\"\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_span = { path = \"../librustc_span\" }"}, {"sha": "e302784cc3e5fb5f78820d90b70ca436b0e700a1", "filename": "src/librustc_query_system/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -50,7 +50,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use std::fmt;\n use std::hash::Hash;\n \n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n pub struct DepNode<K> {\n     pub kind: K,\n     pub hash: Fingerprint,\n@@ -152,7 +152,8 @@ impl<Ctxt: DepContext> DepNodeParams<Ctxt> for () {\n /// some independent path or string that persists between runs without\n /// the need to be mapped or unmapped. (This ensures we can serialize\n /// them even in the absence of a tcx.)\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Encodable, Decodable)]\n pub struct WorkProductId {\n     hash: Fingerprint,\n }"}, {"sha": "d70306b4869218d9ecce39f793ad8e3dbeecd5a4", "filename": "src/librustc_query_system/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -857,7 +857,7 @@ impl<K: DepKind> DepGraph<K> {\n /// may be added -- for example, new monomorphizations -- even if\n /// nothing in P changed!). We will compare that hash against the\n /// previous hash. If it matches up, we can reuse the object file.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Encodable, Decodable)]\n pub struct WorkProduct {\n     pub cgu_name: String,\n     /// Saved file associated with this CGU."}, {"sha": "29357ce9449ce26f48df11c3ac0c12c743efa0a2", "filename": "src/librustc_query_system/dep_graph/prev.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -3,7 +3,7 @@ use super::{DepKind, DepNode};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n \n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Encodable, Decodable)]\n pub struct PreviousDepGraph<K: DepKind> {\n     data: SerializedDepGraph<K>,\n     index: FxHashMap<DepNode<K>, SerializedDepNodeIndex>,"}, {"sha": "932c6d2a2f184260434bf38989fa5d9626f88dff", "filename": "src/librustc_query_system/dep_graph/serialized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -9,7 +9,7 @@ rustc_index::newtype_index! {\n }\n \n /// Data for use when recompiling the **current crate**.\n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Encodable, Decodable)]\n pub struct SerializedDepGraph<K: DepKind> {\n     /// The set of all DepNodes in the graph\n     pub nodes: IndexVec<SerializedDepNodeIndex, DepNode<K>>,"}, {"sha": "db104398f16efa6bf00deb39e0dc8d1b45782752", "filename": "src/librustc_query_system/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_query_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_query_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Flib.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -10,6 +10,8 @@\n extern crate log;\n #[macro_use]\n extern crate rustc_data_structures;\n+#[macro_use]\n+extern crate rustc_macros;\n \n pub mod cache;\n pub mod dep_graph;"}, {"sha": "3d274cb01507b004bcde7191709a66c6c6bb4ed4", "filename": "src/librustc_serialize/collection_impls.rs", "status": "modified", "additions": 72, "deletions": 62, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_serialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_serialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Fcollection_impls.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -9,8 +9,8 @@ use std::sync::Arc;\n \n use smallvec::{Array, SmallVec};\n \n-impl<A: Array<Item: Encodable>> Encodable for SmallVec<A> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, A: Array<Item: Encodable<S>>> Encodable<S> for SmallVec<A> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n@@ -20,8 +20,8 @@ impl<A: Array<Item: Encodable>> Encodable for SmallVec<A> {\n     }\n }\n \n-impl<A: Array<Item: Decodable>> Decodable for SmallVec<A> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<SmallVec<A>, D::Error> {\n+impl<D: Decoder, A: Array<Item: Decodable<D>>> Decodable<D> for SmallVec<A> {\n+    fn decode(d: &mut D) -> Result<SmallVec<A>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut vec = SmallVec::with_capacity(len);\n             // FIXME(#48994) - could just be collected into a Result<SmallVec, D::Error>\n@@ -33,8 +33,8 @@ impl<A: Array<Item: Decodable>> Decodable for SmallVec<A> {\n     }\n }\n \n-impl<T: Encodable> Encodable for LinkedList<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for LinkedList<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n@@ -44,8 +44,8 @@ impl<T: Encodable> Encodable for LinkedList<T> {\n     }\n }\n \n-impl<T: Decodable> Decodable for LinkedList<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<LinkedList<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for LinkedList<T> {\n+    fn decode(d: &mut D) -> Result<LinkedList<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut list = LinkedList::new();\n             for i in 0..len {\n@@ -56,8 +56,8 @@ impl<T: Decodable> Decodable for LinkedList<T> {\n     }\n }\n \n-impl<T: Encodable> Encodable for VecDeque<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for VecDeque<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n@@ -67,8 +67,8 @@ impl<T: Encodable> Encodable for VecDeque<T> {\n     }\n }\n \n-impl<T: Decodable> Decodable for VecDeque<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<VecDeque<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for VecDeque<T> {\n+    fn decode(d: &mut D) -> Result<VecDeque<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut deque: VecDeque<T> = VecDeque::with_capacity(len);\n             for i in 0..len {\n@@ -79,12 +79,12 @@ impl<T: Decodable> Decodable for VecDeque<T> {\n     }\n }\n \n-impl<K, V> Encodable for BTreeMap<K, V>\n+impl<S: Encoder, K, V> Encodable<S> for BTreeMap<K, V>\n where\n-    K: Encodable + PartialEq + Ord,\n-    V: Encodable,\n+    K: Encodable<S> + PartialEq + Ord,\n+    V: Encodable<S>,\n {\n-    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, e: &mut S) -> Result<(), S::Error> {\n         e.emit_map(self.len(), |e| {\n             for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n@@ -95,12 +95,12 @@ where\n     }\n }\n \n-impl<K, V> Decodable for BTreeMap<K, V>\n+impl<D: Decoder, K, V> Decodable<D> for BTreeMap<K, V>\n where\n-    K: Decodable + PartialEq + Ord,\n-    V: Decodable,\n+    K: Decodable<D> + PartialEq + Ord,\n+    V: Decodable<D>,\n {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<BTreeMap<K, V>, D::Error> {\n+    fn decode(d: &mut D) -> Result<BTreeMap<K, V>, D::Error> {\n         d.read_map(|d, len| {\n             let mut map = BTreeMap::new();\n             for i in 0..len {\n@@ -113,11 +113,11 @@ where\n     }\n }\n \n-impl<T> Encodable for BTreeSet<T>\n+impl<S: Encoder, T> Encodable<S> for BTreeSet<T>\n where\n-    T: Encodable + PartialEq + Ord,\n+    T: Encodable<S> + PartialEq + Ord,\n {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n@@ -127,11 +127,11 @@ where\n     }\n }\n \n-impl<T> Decodable for BTreeSet<T>\n+impl<D: Decoder, T> Decodable<D> for BTreeSet<T>\n where\n-    T: Decodable + PartialEq + Ord,\n+    T: Decodable<D> + PartialEq + Ord,\n {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<BTreeSet<T>, D::Error> {\n+    fn decode(d: &mut D) -> Result<BTreeSet<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut set = BTreeSet::new();\n             for i in 0..len {\n@@ -142,13 +142,13 @@ where\n     }\n }\n \n-impl<K, V, S> Encodable for HashMap<K, V, S>\n+impl<E: Encoder, K, V, S> Encodable<E> for HashMap<K, V, S>\n where\n-    K: Encodable + Eq,\n-    V: Encodable,\n+    K: Encodable<E> + Eq,\n+    V: Encodable<E>,\n     S: BuildHasher,\n {\n-    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_map(self.len(), |e| {\n             for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n@@ -159,13 +159,13 @@ where\n     }\n }\n \n-impl<K, V, S> Decodable for HashMap<K, V, S>\n+impl<D: Decoder, K, V, S> Decodable<D> for HashMap<K, V, S>\n where\n-    K: Decodable + Hash + Eq,\n-    V: Decodable,\n+    K: Decodable<D> + Hash + Eq,\n+    V: Decodable<D>,\n     S: BuildHasher + Default,\n {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> {\n+    fn decode(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> {\n         d.read_map(|d, len| {\n             let state = Default::default();\n             let mut map = HashMap::with_capacity_and_hasher(len, state);\n@@ -179,12 +179,12 @@ where\n     }\n }\n \n-impl<T, S> Encodable for HashSet<T, S>\n+impl<E: Encoder, T, S> Encodable<E> for HashSet<T, S>\n where\n-    T: Encodable + Eq,\n+    T: Encodable<E> + Eq,\n     S: BuildHasher,\n {\n-    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n@@ -194,12 +194,22 @@ where\n     }\n }\n \n-impl<T, S> Decodable for HashSet<T, S>\n+impl<E: Encoder, T, S> Encodable<E> for &HashSet<T, S>\n where\n-    T: Decodable + Hash + Eq,\n+    T: Encodable<E> + Eq,\n+    S: BuildHasher,\n+{\n+    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<D: Decoder, T, S> Decodable<D> for HashSet<T, S>\n+where\n+    T: Decodable<D> + Hash + Eq,\n     S: BuildHasher + Default,\n {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, S>, D::Error> {\n+    fn decode(d: &mut D) -> Result<HashSet<T, S>, D::Error> {\n         d.read_seq(|d, len| {\n             let state = Default::default();\n             let mut set = HashSet::with_capacity_and_hasher(len, state);\n@@ -211,13 +221,13 @@ where\n     }\n }\n \n-impl<K, V, S> Encodable for indexmap::IndexMap<K, V, S>\n+impl<E: Encoder, K, V, S> Encodable<E> for indexmap::IndexMap<K, V, S>\n where\n-    K: Encodable + Hash + Eq,\n-    V: Encodable,\n+    K: Encodable<E> + Hash + Eq,\n+    V: Encodable<E>,\n     S: BuildHasher,\n {\n-    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_map(self.len(), |e| {\n             for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n@@ -228,13 +238,13 @@ where\n     }\n }\n \n-impl<K, V, S> Decodable for indexmap::IndexMap<K, V, S>\n+impl<D: Decoder, K, V, S> Decodable<D> for indexmap::IndexMap<K, V, S>\n where\n-    K: Decodable + Hash + Eq,\n-    V: Decodable,\n+    K: Decodable<D> + Hash + Eq,\n+    V: Decodable<D>,\n     S: BuildHasher + Default,\n {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<indexmap::IndexMap<K, V, S>, D::Error> {\n+    fn decode(d: &mut D) -> Result<indexmap::IndexMap<K, V, S>, D::Error> {\n         d.read_map(|d, len| {\n             let state = Default::default();\n             let mut map = indexmap::IndexMap::with_capacity_and_hasher(len, state);\n@@ -248,12 +258,12 @@ where\n     }\n }\n \n-impl<T, S> Encodable for indexmap::IndexSet<T, S>\n+impl<E: Encoder, T, S> Encodable<E> for indexmap::IndexSet<T, S>\n where\n-    T: Encodable + Hash + Eq,\n+    T: Encodable<E> + Hash + Eq,\n     S: BuildHasher,\n {\n-    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n+    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?;\n@@ -263,12 +273,12 @@ where\n     }\n }\n \n-impl<T, S> Decodable for indexmap::IndexSet<T, S>\n+impl<D: Decoder, T, S> Decodable<D> for indexmap::IndexSet<T, S>\n where\n-    T: Decodable + Hash + Eq,\n+    T: Decodable<D> + Hash + Eq,\n     S: BuildHasher + Default,\n {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<indexmap::IndexSet<T, S>, D::Error> {\n+    fn decode(d: &mut D) -> Result<indexmap::IndexSet<T, S>, D::Error> {\n         d.read_seq(|d, len| {\n             let state = Default::default();\n             let mut set = indexmap::IndexSet::with_capacity_and_hasher(len, state);\n@@ -280,8 +290,8 @@ where\n     }\n }\n \n-impl<T: Encodable> Encodable for Rc<[T]> {\n-    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n+impl<E: Encoder, T: Encodable<E>> Encodable<E> for Rc<[T]> {\n+    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (index, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(index, |s| e.encode(s))?;\n@@ -291,8 +301,8 @@ impl<T: Encodable> Encodable for Rc<[T]> {\n     }\n }\n \n-impl<T: Decodable> Decodable for Rc<[T]> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Rc<[T]>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Rc<[T]> {\n+    fn decode(d: &mut D) -> Result<Rc<[T]>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut vec = Vec::with_capacity(len);\n             for index in 0..len {\n@@ -303,8 +313,8 @@ impl<T: Decodable> Decodable for Rc<[T]> {\n     }\n }\n \n-impl<T: Encodable> Encodable for Arc<[T]> {\n-    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n+impl<E: Encoder, T: Encodable<E>> Encodable<E> for Arc<[T]> {\n+    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (index, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(index, |s| e.encode(s))?;\n@@ -314,8 +324,8 @@ impl<T: Encodable> Encodable for Arc<[T]> {\n     }\n }\n \n-impl<T: Decodable> Decodable for Arc<[T]> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Arc<[T]>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Arc<[T]> {\n+    fn decode(d: &mut D) -> Result<Arc<[T]>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut vec = Vec::with_capacity(len);\n             for index in 0..len {"}, {"sha": "dafeb053d83d30a932825eb98d0b00cb459d4eba", "filename": "src/librustc_serialize/json.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_serialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_serialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Fjson.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -292,7 +292,7 @@ pub fn error_str(error: ErrorCode) -> &'static str {\n }\n \n /// Shortcut function to decode a JSON `&str` into an object\n-pub fn decode<T: crate::Decodable>(s: &str) -> DecodeResult<T> {\n+pub fn decode<T: crate::Decodable<Decoder>>(s: &str) -> DecodeResult<T> {\n     let json = match from_str(s) {\n         Ok(x) => x,\n         Err(e) => return Err(ParseError(e)),\n@@ -303,7 +303,9 @@ pub fn decode<T: crate::Decodable>(s: &str) -> DecodeResult<T> {\n }\n \n /// Shortcut function to encode a `T` into a JSON `String`\n-pub fn encode<T: crate::Encodable>(object: &T) -> Result<string::String, EncoderError> {\n+pub fn encode<T: for<'r> crate::Encodable<Encoder<'r>>>(\n+    object: &T,\n+) -> Result<string::String, EncoderError> {\n     let mut s = String::new();\n     {\n         let mut encoder = Encoder::new(&mut s);\n@@ -1144,8 +1146,8 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n     }\n }\n \n-impl Encodable for Json {\n-    fn encode<E: crate::Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+impl<E: crate::Encoder> Encodable<E> for Json {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n         match *self {\n             Json::I64(v) => v.encode(e),\n             Json::U64(v) => v.encode(e),\n@@ -2727,7 +2729,7 @@ impl<'a> fmt::Display for PrettyJson<'a> {\n     }\n }\n \n-impl<'a, T: Encodable> fmt::Display for AsJson<'a, T> {\n+impl<'a, T: for<'r> Encodable<Encoder<'r>>> fmt::Display for AsJson<'a, T> {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n@@ -2747,7 +2749,7 @@ impl<'a, T> AsPrettyJson<'a, T> {\n     }\n }\n \n-impl<'a, T: Encodable> fmt::Display for AsPrettyJson<'a, T> {\n+impl<'a, T: for<'x> Encodable<PrettyEncoder<'x>>> fmt::Display for AsPrettyJson<'a, T> {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };"}, {"sha": "265b3b95e956a9c0e9505cd3ab71be6cff89c26e", "filename": "src/librustc_serialize/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_serialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_serialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Flib.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -10,7 +10,6 @@ Core encoding and decoding interfaces.\n     test(attr(allow(unused_variables), deny(warnings)))\n )]\n #![feature(box_syntax)]\n-#![feature(min_specialization)]\n #![feature(never_type)]\n #![feature(nll)]\n #![feature(associated_type_bounds)]\n@@ -19,9 +18,6 @@ Core encoding and decoding interfaces.\n \n pub use self::serialize::{Decodable, Decoder, Encodable, Encoder};\n \n-pub use self::serialize::{SpecializationError, SpecializedDecoder, SpecializedEncoder};\n-pub use self::serialize::{UseSpecializedDecodable, UseSpecializedEncodable};\n-\n mod collection_impls;\n mod serialize;\n "}, {"sha": "d279954bf91bff5f18e0979239e2dc40ce672b23", "filename": "src/librustc_serialize/serialize.rs", "status": "modified", "additions": 146, "deletions": 240, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_serialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_serialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_serialize%2Fserialize.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -4,7 +4,6 @@\n Core encoding and decoding interfaces.\n */\n \n-use std::any;\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::marker::PhantomData;\n@@ -380,282 +379,288 @@ pub trait Decoder {\n     fn error(&mut self, err: &str) -> Self::Error;\n }\n \n-pub trait Encodable {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error>;\n+pub trait Encodable<S: Encoder> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error>;\n }\n \n-pub trait Decodable: Sized {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error>;\n+pub trait Decodable<D: Decoder>: Sized {\n+    fn decode(d: &mut D) -> Result<Self, D::Error>;\n }\n \n-impl Encodable for usize {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for usize {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_usize(*self)\n     }\n }\n \n-impl Decodable for usize {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<usize, D::Error> {\n+impl<D: Decoder> Decodable<D> for usize {\n+    fn decode(d: &mut D) -> Result<usize, D::Error> {\n         d.read_usize()\n     }\n }\n \n-impl Encodable for u8 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for u8 {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u8(*self)\n     }\n }\n \n-impl Decodable for u8 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<u8, D::Error> {\n+impl<D: Decoder> Decodable<D> for u8 {\n+    fn decode(d: &mut D) -> Result<u8, D::Error> {\n         d.read_u8()\n     }\n }\n \n-impl Encodable for u16 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for u16 {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u16(*self)\n     }\n }\n \n-impl Decodable for u16 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<u16, D::Error> {\n+impl<D: Decoder> Decodable<D> for u16 {\n+    fn decode(d: &mut D) -> Result<u16, D::Error> {\n         d.read_u16()\n     }\n }\n \n-impl Encodable for u32 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for u32 {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u32(*self)\n     }\n }\n \n-impl Decodable for u32 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<u32, D::Error> {\n+impl<D: Decoder> Decodable<D> for u32 {\n+    fn decode(d: &mut D) -> Result<u32, D::Error> {\n         d.read_u32()\n     }\n }\n \n-impl Encodable for ::std::num::NonZeroU32 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for ::std::num::NonZeroU32 {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u32(self.get())\n     }\n }\n \n-impl Decodable for ::std::num::NonZeroU32 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+impl<D: Decoder> Decodable<D> for ::std::num::NonZeroU32 {\n+    fn decode(d: &mut D) -> Result<Self, D::Error> {\n         d.read_u32().map(|d| ::std::num::NonZeroU32::new(d).unwrap())\n     }\n }\n \n-impl Encodable for u64 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for u64 {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u64(*self)\n     }\n }\n \n-impl Decodable for u64 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<u64, D::Error> {\n+impl<D: Decoder> Decodable<D> for u64 {\n+    fn decode(d: &mut D) -> Result<u64, D::Error> {\n         d.read_u64()\n     }\n }\n \n-impl Encodable for u128 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for u128 {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u128(*self)\n     }\n }\n \n-impl Decodable for u128 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<u128, D::Error> {\n+impl<D: Decoder> Decodable<D> for u128 {\n+    fn decode(d: &mut D) -> Result<u128, D::Error> {\n         d.read_u128()\n     }\n }\n \n-impl Encodable for isize {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for isize {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_isize(*self)\n     }\n }\n \n-impl Decodable for isize {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<isize, D::Error> {\n+impl<D: Decoder> Decodable<D> for isize {\n+    fn decode(d: &mut D) -> Result<isize, D::Error> {\n         d.read_isize()\n     }\n }\n \n-impl Encodable for i8 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for i8 {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i8(*self)\n     }\n }\n \n-impl Decodable for i8 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<i8, D::Error> {\n+impl<D: Decoder> Decodable<D> for i8 {\n+    fn decode(d: &mut D) -> Result<i8, D::Error> {\n         d.read_i8()\n     }\n }\n \n-impl Encodable for i16 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for i16 {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i16(*self)\n     }\n }\n \n-impl Decodable for i16 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<i16, D::Error> {\n+impl<D: Decoder> Decodable<D> for i16 {\n+    fn decode(d: &mut D) -> Result<i16, D::Error> {\n         d.read_i16()\n     }\n }\n \n-impl Encodable for i32 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for i32 {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i32(*self)\n     }\n }\n \n-impl Decodable for i32 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<i32, D::Error> {\n+impl<D: Decoder> Decodable<D> for i32 {\n+    fn decode(d: &mut D) -> Result<i32, D::Error> {\n         d.read_i32()\n     }\n }\n \n-impl Encodable for i64 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for i64 {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i64(*self)\n     }\n }\n \n-impl Decodable for i64 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<i64, D::Error> {\n+impl<D: Decoder> Decodable<D> for i64 {\n+    fn decode(d: &mut D) -> Result<i64, D::Error> {\n         d.read_i64()\n     }\n }\n \n-impl Encodable for i128 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for i128 {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i128(*self)\n     }\n }\n \n-impl Decodable for i128 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<i128, D::Error> {\n+impl<D: Decoder> Decodable<D> for i128 {\n+    fn decode(d: &mut D) -> Result<i128, D::Error> {\n         d.read_i128()\n     }\n }\n \n-impl Encodable for str {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for str {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(self)\n     }\n }\n \n-impl Encodable for String {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for &str {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_str(self)\n+    }\n+}\n+\n+impl<S: Encoder> Encodable<S> for String {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(&self[..])\n     }\n }\n \n-impl Decodable for String {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<String, D::Error> {\n+impl<D: Decoder> Decodable<D> for String {\n+    fn decode(d: &mut D) -> Result<String, D::Error> {\n         Ok(d.read_str()?.into_owned())\n     }\n }\n \n-impl Encodable for f32 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for f32 {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_f32(*self)\n     }\n }\n \n-impl Decodable for f32 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<f32, D::Error> {\n+impl<D: Decoder> Decodable<D> for f32 {\n+    fn decode(d: &mut D) -> Result<f32, D::Error> {\n         d.read_f32()\n     }\n }\n \n-impl Encodable for f64 {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for f64 {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_f64(*self)\n     }\n }\n \n-impl Decodable for f64 {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<f64, D::Error> {\n+impl<D: Decoder> Decodable<D> for f64 {\n+    fn decode(d: &mut D) -> Result<f64, D::Error> {\n         d.read_f64()\n     }\n }\n \n-impl Encodable for bool {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for bool {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_bool(*self)\n     }\n }\n \n-impl Decodable for bool {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<bool, D::Error> {\n+impl<D: Decoder> Decodable<D> for bool {\n+    fn decode(d: &mut D) -> Result<bool, D::Error> {\n         d.read_bool()\n     }\n }\n \n-impl Encodable for char {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for char {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_char(*self)\n     }\n }\n \n-impl Decodable for char {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<char, D::Error> {\n+impl<D: Decoder> Decodable<D> for char {\n+    fn decode(d: &mut D) -> Result<char, D::Error> {\n         d.read_char()\n     }\n }\n \n-impl Encodable for () {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for () {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_unit()\n     }\n }\n \n-impl Decodable for () {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<(), D::Error> {\n+impl<D: Decoder> Decodable<D> for () {\n+    fn decode(d: &mut D) -> Result<(), D::Error> {\n         d.read_nil()\n     }\n }\n \n-impl<T> Encodable for PhantomData<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T> Encodable<S> for PhantomData<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_unit()\n     }\n }\n \n-impl<T> Decodable for PhantomData<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<PhantomData<T>, D::Error> {\n+impl<D: Decoder, T> Decodable<D> for PhantomData<T> {\n+    fn decode(d: &mut D) -> Result<PhantomData<T>, D::Error> {\n         d.read_nil()?;\n         Ok(PhantomData)\n     }\n }\n \n-impl<T: Decodable> Decodable for Box<[T]> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Box<[T]>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Box<[T]> {\n+    fn decode(d: &mut D) -> Result<Box<[T]>, D::Error> {\n         let v: Vec<T> = Decodable::decode(d)?;\n         Ok(v.into_boxed_slice())\n     }\n }\n \n-impl<T: Encodable> Encodable for Rc<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for Rc<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n-impl<T: Decodable> Decodable for Rc<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Rc<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Rc<T> {\n+    fn decode(d: &mut D) -> Result<Rc<T>, D::Error> {\n         Ok(Rc::new(Decodable::decode(d)?))\n     }\n }\n \n-impl<T: Encodable> Encodable for [T] {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for [T] {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?\n@@ -665,8 +670,8 @@ impl<T: Encodable> Encodable for [T] {\n     }\n }\n \n-impl<T: Encodable> Encodable for Vec<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for Vec<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?\n@@ -676,8 +681,8 @@ impl<T: Encodable> Encodable for Vec<T> {\n     }\n }\n \n-impl<T: Decodable> Decodable for Vec<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Vec<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Vec<T> {\n+    fn decode(d: &mut D) -> Result<Vec<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n             for i in 0..len {\n@@ -688,8 +693,8 @@ impl<T: Decodable> Decodable for Vec<T> {\n     }\n }\n \n-impl Encodable for [u8; 20] {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for [u8; 20] {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?\n@@ -699,8 +704,8 @@ impl Encodable for [u8; 20] {\n     }\n }\n \n-impl Decodable for [u8; 20] {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<[u8; 20], D::Error> {\n+impl<D: Decoder> Decodable<D> for [u8; 20] {\n+    fn decode(d: &mut D) -> Result<[u8; 20], D::Error> {\n         d.read_seq(|d, len| {\n             assert!(len == 20);\n             let mut v = [0u8; 20];\n@@ -712,11 +717,11 @@ impl Decodable for [u8; 20] {\n     }\n }\n \n-impl<'a, T: Encodable> Encodable for Cow<'a, [T]>\n+impl<'a, S: Encoder, T: Encodable<S>> Encodable<S> for Cow<'a, [T]>\n where\n     [T]: ToOwned<Owned = Vec<T>>,\n {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 s.emit_seq_elt(i, |s| e.encode(s))?\n@@ -726,11 +731,11 @@ where\n     }\n }\n \n-impl<T: Decodable + ToOwned> Decodable for Cow<'static, [T]>\n+impl<D: Decoder, T: Decodable<D> + ToOwned> Decodable<D> for Cow<'static, [T]>\n where\n     [T]: ToOwned<Owned = Vec<T>>,\n {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Cow<'static, [T]>, D::Error> {\n+    fn decode(d: &mut D) -> Result<Cow<'static, [T]>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n             for i in 0..len {\n@@ -741,23 +746,23 @@ where\n     }\n }\n \n-impl<T: Encodable> Encodable for Option<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for Option<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_option(|s| match *self {\n             None => s.emit_option_none(),\n             Some(ref v) => s.emit_option_some(|s| v.encode(s)),\n         })\n     }\n }\n \n-impl<T: Decodable> Decodable for Option<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Option<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Option<T> {\n+    fn decode(d: &mut D) -> Result<Option<T>, D::Error> {\n         d.read_option(|d, b| if b { Ok(Some(Decodable::decode(d)?)) } else { Ok(None) })\n     }\n }\n \n-impl<T1: Encodable, T2: Encodable> Encodable for Result<T1, T2> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T1: Encodable<S>, T2: Encodable<S>> Encodable<S> for Result<T1, T2> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_enum(\"Result\", |s| match *self {\n             Ok(ref v) => {\n                 s.emit_enum_variant(\"Ok\", 0, 1, |s| s.emit_enum_variant_arg(0, |s| v.encode(s)))\n@@ -769,8 +774,8 @@ impl<T1: Encodable, T2: Encodable> Encodable for Result<T1, T2> {\n     }\n }\n \n-impl<T1: Decodable, T2: Decodable> Decodable for Result<T1, T2> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Result<T1, T2>, D::Error> {\n+impl<D: Decoder, T1: Decodable<D>, T2: Decodable<D>> Decodable<D> for Result<T1, T2> {\n+    fn decode(d: &mut D) -> Result<Result<T1, T2>, D::Error> {\n         d.read_enum(\"Result\", |d| {\n             d.read_enum_variant(&[\"Ok\", \"Err\"], |d, disr| match disr {\n                 0 => Ok(Ok(d.read_enum_variant_arg(0, |d| T1::decode(d))?)),\n@@ -806,9 +811,9 @@ macro_rules! count {\n macro_rules! tuple {\n     () => ();\n     ( $($name:ident,)+ ) => (\n-        impl<$($name:Decodable),+> Decodable for ($($name,)+) {\n+        impl<D: Decoder, $($name: Decodable<D>),+> Decodable<D> for ($($name,)+) {\n             #[allow(non_snake_case)]\n-            fn decode<D: Decoder>(d: &mut D) -> Result<($($name,)+), D::Error> {\n+            fn decode(d: &mut D) -> Result<($($name,)+), D::Error> {\n                 let len: usize = count!($($name)+);\n                 d.read_tuple(len, |d| {\n                     let mut i = 0;\n@@ -819,9 +824,9 @@ macro_rules! tuple {\n                 })\n             }\n         }\n-        impl<$($name:Encodable),+> Encodable for ($($name,)+) {\n+        impl<S: Encoder, $($name: Encodable<S>),+> Encodable<S> for ($($name,)+) {\n             #[allow(non_snake_case)]\n-            fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+            fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n                 let ($(ref $name,)+) = *self;\n                 let mut n = 0;\n                 $(let $name = $name; n += 1;)+\n@@ -838,33 +843,33 @@ macro_rules! tuple {\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-impl Encodable for path::Path {\n-    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for path::Path {\n+    fn encode(&self, e: &mut S) -> Result<(), S::Error> {\n         self.to_str().unwrap().encode(e)\n     }\n }\n \n-impl Encodable for path::PathBuf {\n-    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for path::PathBuf {\n+    fn encode(&self, e: &mut S) -> Result<(), S::Error> {\n         path::Path::encode(self, e)\n     }\n }\n \n-impl Decodable for path::PathBuf {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<path::PathBuf, D::Error> {\n+impl<D: Decoder> Decodable<D> for path::PathBuf {\n+    fn decode(d: &mut D) -> Result<path::PathBuf, D::Error> {\n         let bytes: String = Decodable::decode(d)?;\n         Ok(path::PathBuf::from(bytes))\n     }\n }\n \n-impl<T: Encodable + Copy> Encodable for Cell<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S> + Copy> Encodable<S> for Cell<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         self.get().encode(s)\n     }\n }\n \n-impl<T: Decodable + Copy> Decodable for Cell<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Cell<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D> + Copy> Decodable<D> for Cell<T> {\n+    fn decode(d: &mut D) -> Result<Cell<T>, D::Error> {\n         Ok(Cell::new(Decodable::decode(d)?))\n     }\n }\n@@ -874,136 +879,37 @@ impl<T: Decodable + Copy> Decodable for Cell<T> {\n // `encoder.error(\"attempting to Encode borrowed RefCell\")`\n // from `encode` when `try_borrow` returns `None`.\n \n-impl<T: Encodable> Encodable for RefCell<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for RefCell<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         self.borrow().encode(s)\n     }\n }\n \n-impl<T: Decodable> Decodable for RefCell<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<RefCell<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for RefCell<T> {\n+    fn decode(d: &mut D) -> Result<RefCell<T>, D::Error> {\n         Ok(RefCell::new(Decodable::decode(d)?))\n     }\n }\n \n-impl<T: Encodable> Encodable for Arc<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: Encodable<S>> Encodable<S> for Arc<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n-impl<T: Decodable> Decodable for Arc<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Arc<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Arc<T> {\n+    fn decode(d: &mut D) -> Result<Arc<T>, D::Error> {\n         Ok(Arc::new(Decodable::decode(d)?))\n     }\n }\n \n-// ___________________________________________________________________________\n-// Specialization-based interface for multi-dispatch Encodable/Decodable.\n-\n-/// Implement this trait on your `{Encodable,Decodable}::Error` types\n-/// to override the default panic behavior for missing specializations.\n-pub trait SpecializationError {\n-    /// Creates an error for a missing method specialization.\n-    /// Defaults to panicking with type, trait & method names.\n-    /// `S` is the encoder/decoder state type,\n-    /// `T` is the type being encoded/decoded, and\n-    /// the arguments are the names of the trait\n-    /// and method that should've been overridden.\n-    fn not_found<S, T: ?Sized>(trait_name: &'static str, method_name: &'static str) -> Self;\n-}\n-\n-impl<E> SpecializationError for E {\n-    default fn not_found<S, T: ?Sized>(trait_name: &'static str, method_name: &'static str) -> E {\n-        panic!(\n-            \"missing specialization: `<{} as {}<{}>>::{}` not overridden\",\n-            any::type_name::<S>(),\n-            trait_name,\n-            any::type_name::<T>(),\n-            method_name\n-        );\n-    }\n-}\n-\n-/// Implement this trait on encoders, with `T` being the type\n-/// you want to encode (employing `UseSpecializedEncodable`),\n-/// using a strategy specific to the encoder.\n-pub trait SpecializedEncoder<T: ?Sized + UseSpecializedEncodable>: Encoder {\n-    /// Encode the value in a manner specific to this encoder state.\n-    fn specialized_encode(&mut self, value: &T) -> Result<(), Self::Error>;\n-}\n-\n-impl<E: Encoder, T: ?Sized + UseSpecializedEncodable> SpecializedEncoder<T> for E {\n-    default fn specialized_encode(&mut self, value: &T) -> Result<(), E::Error> {\n-        value.default_encode(self)\n-    }\n-}\n-\n-/// Implement this trait on decoders, with `T` being the type\n-/// you want to decode (employing `UseSpecializedDecodable`),\n-/// using a strategy specific to the decoder.\n-pub trait SpecializedDecoder<T: UseSpecializedDecodable>: Decoder {\n-    /// Decode a value in a manner specific to this decoder state.\n-    fn specialized_decode(&mut self) -> Result<T, Self::Error>;\n-}\n-\n-impl<D: Decoder, T: UseSpecializedDecodable> SpecializedDecoder<T> for D {\n-    default fn specialized_decode(&mut self) -> Result<T, D::Error> {\n-        T::default_decode(self)\n-    }\n-}\n-\n-/// Implement this trait on your type to get an `Encodable`\n-/// implementation which goes through `SpecializedEncoder`.\n-pub trait UseSpecializedEncodable {\n-    /// Defaults to returning an error (see `SpecializationError`).\n-    fn default_encode<E: Encoder>(&self, _: &mut E) -> Result<(), E::Error> {\n-        Err(E::Error::not_found::<E, Self>(\"SpecializedEncoder\", \"specialized_encode\"))\n-    }\n-}\n-\n-impl<T: ?Sized + UseSpecializedEncodable> Encodable for T {\n-    default fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n-        E::specialized_encode(e, self)\n-    }\n-}\n-\n-/// Implement this trait on your type to get an `Decodable`\n-/// implementation which goes through `SpecializedDecoder`.\n-pub trait UseSpecializedDecodable: Sized {\n-    /// Defaults to returning an error (see `SpecializationError`).\n-    fn default_decode<D: Decoder>(_: &mut D) -> Result<Self, D::Error> {\n-        Err(D::Error::not_found::<D, Self>(\"SpecializedDecoder\", \"specialized_decode\"))\n-    }\n-}\n-\n-impl<T: UseSpecializedDecodable> Decodable for T {\n-    default fn decode<D: Decoder>(d: &mut D) -> Result<T, D::Error> {\n-        D::specialized_decode(d)\n-    }\n-}\n-\n-// Can't avoid specialization for &T and Box<T> impls,\n-// as proxy impls on them are blankets that conflict\n-// with the Encodable and Decodable impls above,\n-// which only have `default` on their methods\n-// for this exact reason.\n-// May be fixable in a simpler fashion via the\n-// more complex lattice model for specialization.\n-impl<'a, T: ?Sized + Encodable> UseSpecializedEncodable for &'a T {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n-    }\n-}\n-impl<T: ?Sized + Encodable> UseSpecializedEncodable for Box<T> {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder, T: ?Sized + Encodable<S>> Encodable<S> for Box<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n-impl<T: Decodable> UseSpecializedDecodable for Box<T> {\n-    fn default_decode<D: Decoder>(d: &mut D) -> Result<Box<T>, D::Error> {\n+impl<D: Decoder, T: Decodable<D>> Decodable<D> for Box<T> {\n+    fn decode(d: &mut D) -> Result<Box<T>, D::Error> {\n         Ok(box Decodable::decode(d)?)\n     }\n }\n-impl<'a, T: Decodable> UseSpecializedDecodable for &'a T {}\n-impl<'a, T: Decodable> UseSpecializedDecodable for &'a [T] {}"}, {"sha": "cb6626d0f4bd5cd88346058f5b4b1aff81d6a91e", "filename": "src/librustc_session/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_session%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_session%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2FCargo.toml?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -12,6 +12,7 @@ path = \"lib.rs\"\n bitflags = \"1.2.1\"\n getopts = \"0.2\"\n log = { package = \"tracing\", version = \"0.1\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "c26c9bde3ee85114472d8f7e18d189d9b398ba7a", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -39,7 +39,7 @@ pub struct Config {\n }\n \n bitflags! {\n-    #[derive(Default, RustcEncodable, RustcDecodable)]\n+    #[derive(Default, Encodable, Decodable)]\n     pub struct SanitizerSet: u8 {\n         const ADDRESS = 1 << 0;\n         const LEAK    = 1 << 1;\n@@ -194,7 +194,8 @@ impl SwitchWithOptPath {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Encodable, Decodable)]\n pub enum SymbolManglingVersion {\n     Legacy,\n     V0,\n@@ -209,7 +210,8 @@ pub enum DebugInfo {\n     Full,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n+#[derive(Encodable, Decodable)]\n pub enum OutputType {\n     Bitcode,\n     Assembly,\n@@ -672,7 +674,7 @@ pub enum EntryFnType {\n \n impl_stable_hash_via_hash!(EntryFnType);\n \n-#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Debug, Encodable, Decodable)]\n pub enum CrateType {\n     Executable,\n     Dylib,"}, {"sha": "c2ea141a06fe31b71f9419b9d6155646c3f8bc68", "filename": "src/librustc_session/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_session%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_session%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flib.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -3,6 +3,8 @@\n \n #[macro_use]\n extern crate bitflags;\n+#[macro_use]\n+extern crate rustc_macros;\n \n pub mod cgu_reuse_tracker;\n pub mod utils;"}, {"sha": "e12364b7dac7cb355917994aa0855998076e3dec", "filename": "src/librustc_session/search_paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_session%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_session%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsearch_paths.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -33,7 +33,7 @@ impl SearchPathFile {\n     }\n }\n \n-#[derive(PartialEq, Clone, Copy, Debug, Hash, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Clone, Copy, Debug, Hash, Eq, Encodable, Decodable)]\n pub enum PathKind {\n     Native,\n     Crate,"}, {"sha": "15447c01d1e55a5080e31c53fc84aacf6a3e8baa", "filename": "src/librustc_session/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_session%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_session%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Futils.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -10,7 +10,7 @@ impl Session {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n pub enum NativeLibKind {\n     /// Static library (e.g. `libfoo.a` on Linux or `foo.lib` on Windows/MSVC) included\n     /// when linking a final binary, but not when archiving an rlib."}, {"sha": "aae778217d3f1116a2b1e02ec4f65d341b9bffe2", "filename": "src/librustc_span/def_id.rs", "status": "modified", "additions": 49, "deletions": 24, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_span%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_span%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fdef_id.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -4,7 +4,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::AtomicRef;\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable_Generic;\n-use rustc_serialize::{Decoder, Encoder};\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::borrow::Borrow;\n use std::fmt;\n \n@@ -84,13 +84,14 @@ impl fmt::Display for CrateNum {\n \n /// As a local identifier, a `CrateNum` is only meaningful within its context, e.g. within a tcx.\n /// Therefore, make sure to include the context when encode a `CrateNum`.\n-impl rustc_serialize::UseSpecializedEncodable for CrateNum {\n-    fn default_encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n-        e.emit_u32(self.as_u32())\n+impl<E: Encoder> Encodable<E> for CrateNum {\n+    default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n+        s.emit_u32(self.as_u32())\n     }\n }\n-impl rustc_serialize::UseSpecializedDecodable for CrateNum {\n-    fn default_decode<D: Decoder>(d: &mut D) -> Result<CrateNum, D::Error> {\n+\n+impl<D: Decoder> Decodable<D> for CrateNum {\n+    default fn decode(d: &mut D) -> Result<CrateNum, D::Error> {\n         Ok(CrateNum::from_u32(d.read_u32()?))\n     }\n }\n@@ -104,8 +105,8 @@ impl ::std::fmt::Debug for CrateNum {\n     }\n }\n \n-#[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug, RustcEncodable, RustcDecodable)]\n-#[derive(HashStable_Generic)]\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub struct DefPathHash(pub Fingerprint);\n \n impl Borrow<Fingerprint> for DefPathHash {\n@@ -120,16 +121,26 @@ rustc_index::newtype_index! {\n     /// particular definition. It should really be considered an interned\n     /// shorthand for a particular DefPath.\n     pub struct DefIndex {\n-        DEBUG_FORMAT = \"DefIndex({})\",\n+        ENCODABLE = custom // (only encodable in metadata)\n \n+        DEBUG_FORMAT = \"DefIndex({})\",\n         /// The crate root is always assigned index 0 by the AST Map code,\n         /// thanks to `NodeCollector::new`.\n         const CRATE_DEF_INDEX = 0,\n     }\n }\n \n-impl rustc_serialize::UseSpecializedEncodable for DefIndex {}\n-impl rustc_serialize::UseSpecializedDecodable for DefIndex {}\n+impl<E: Encoder> Encodable<E> for DefIndex {\n+    default fn encode(&self, _: &mut E) -> Result<(), E::Error> {\n+        panic!(\"cannot encode `DefIndex` with `{}`\", std::any::type_name::<E>());\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for DefIndex {\n+    default fn decode(_: &mut D) -> Result<DefIndex, D::Error> {\n+        panic!(\"cannot decode `DefIndex` with `{}`\", std::any::type_name::<D>());\n+    }\n+}\n \n /// A `DefId` identifies a particular *definition*, by combining a crate\n /// index and a def index.\n@@ -168,19 +179,24 @@ impl DefId {\n     }\n }\n \n-impl rustc_serialize::UseSpecializedEncodable for DefId {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        let krate = u64::from(self.krate.as_u32());\n-        let index = u64::from(self.index.as_u32());\n-        s.emit_u64((krate << 32) | index)\n+impl<E: Encoder> Encodable<E> for DefId {\n+    default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n+        s.emit_struct(\"DefId\", 2, |s| {\n+            s.emit_struct_field(\"krate\", 0, |s| self.krate.encode(s))?;\n+\n+            s.emit_struct_field(\"index\", 1, |s| self.index.encode(s))\n+        })\n     }\n }\n-impl rustc_serialize::UseSpecializedDecodable for DefId {\n-    fn default_decode<D: Decoder>(d: &mut D) -> Result<DefId, D::Error> {\n-        let def_id = d.read_u64()?;\n-        let krate = CrateNum::from_u32((def_id >> 32) as u32);\n-        let index = DefIndex::from_u32((def_id & 0xffffffff) as u32);\n-        Ok(DefId { krate, index })\n+\n+impl<D: Decoder> Decodable<D> for DefId {\n+    default fn decode(d: &mut D) -> Result<DefId, D::Error> {\n+        d.read_struct(\"DefId\", 2, |d| {\n+            Ok(DefId {\n+                krate: d.read_struct_field(\"krate\", 0, Decodable::decode)?,\n+                index: d.read_struct_field(\"index\", 1, Decodable::decode)?,\n+            })\n+        })\n     }\n }\n \n@@ -239,8 +255,17 @@ impl fmt::Debug for LocalDefId {\n     }\n }\n \n-impl rustc_serialize::UseSpecializedEncodable for LocalDefId {}\n-impl rustc_serialize::UseSpecializedDecodable for LocalDefId {}\n+impl<E: Encoder> Encodable<E> for LocalDefId {\n+    fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n+        self.to_def_id().encode(s)\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for LocalDefId {\n+    fn decode(d: &mut D) -> Result<LocalDefId, D::Error> {\n+        DefId::decode(d).map(|d| d.expect_local())\n+    }\n+}\n \n impl<CTX: HashStableContext> HashStable<CTX> for DefId {\n     fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {"}, {"sha": "4d0c92f51d7ca7063c934486a78c7947e2b4b511", "filename": "src/librustc_span/edition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_span%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_span%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fedition.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -5,7 +5,7 @@ use std::str::FromStr;\n use rustc_macros::HashStable_Generic;\n \n /// The edition of the compiler (RFC 2052)\n-#[derive(Clone, Copy, Hash, PartialEq, PartialOrd, Debug, RustcEncodable, RustcDecodable, Eq)]\n+#[derive(Clone, Copy, Hash, PartialEq, PartialOrd, Debug, Encodable, Decodable, Eq)]\n #[derive(HashStable_Generic)]\n pub enum Edition {\n     // editions must be kept in order, oldest to newest"}, {"sha": "e8f4606b518cf3b1d3ed10fd2d28157aadee03d6", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -34,16 +34,14 @@ use log::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_macros::HashStable_Generic;\n-use rustc_serialize::{\n-    Decodable, Decoder, Encodable, Encoder, UseSpecializedDecodable, UseSpecializedEncodable,\n-};\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::fmt;\n \n /// A `SyntaxContext` represents a chain of pairs `(ExpnId, Transparency)` named \"marks\".\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct SyntaxContext(u32);\n \n-#[derive(Debug, RustcEncodable, RustcDecodable, Clone)]\n+#[derive(Debug, Encodable, Decodable, Clone)]\n pub struct SyntaxContextData {\n     outer_expn: ExpnId,\n     outer_transparency: Transparency,\n@@ -62,7 +60,7 @@ pub struct ExpnId(u32);\n \n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug, Encodable, Decodable)]\n #[derive(HashStable_Generic)]\n pub enum Transparency {\n     /// Identifier produced by a transparent expansion is always resolved at call-site.\n@@ -664,7 +662,7 @@ impl Span {\n \n /// A subset of properties from both macro definition and macro call available through global data.\n /// Avoid using this if you have access to the original definition or call structures.\n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Clone, Debug, Encodable, Decodable, HashStable_Generic)]\n pub struct ExpnData {\n     // --- The part unique to each expansion.\n     /// The kind of this expansion - macro or compiler desugaring.\n@@ -766,7 +764,7 @@ impl ExpnData {\n }\n \n /// Expansion kind.\n-#[derive(Clone, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Clone, Debug, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub enum ExpnKind {\n     /// No expansion, aka root expansion. Only `ExpnId::root()` has this kind.\n     Root,\n@@ -794,7 +792,7 @@ impl ExpnKind {\n }\n \n /// The kind of macro invocation or definition.\n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum MacroKind {\n     /// A bang macro `foo!()`.\n@@ -830,7 +828,7 @@ impl MacroKind {\n }\n \n /// The kind of AST transform.\n-#[derive(Clone, Copy, Debug, PartialEq, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Clone, Copy, Debug, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub enum AstPass {\n     StdImports,\n     TestHarness,\n@@ -848,7 +846,7 @@ impl AstPass {\n }\n \n /// The kind of compiler desugaring.\n-#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Debug, Encodable, Decodable, HashStable_Generic)]\n pub enum DesugaringKind {\n     /// We desugar `if c { i } else { e }` to `match $ExprKind::Use(c) { true => i, _ => e }`.\n     /// However, we do not want to blame `c` for unreachability but rather say that `i`\n@@ -867,7 +865,7 @@ pub enum DesugaringKind {\n }\n \n /// A location in the desugaring of a `for` loop\n-#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Clone, Copy, PartialEq, Debug, Encodable, Decodable, HashStable_Generic)]\n pub enum ForLoopLoc {\n     Head,\n     IntoIter,\n@@ -888,9 +886,6 @@ impl DesugaringKind {\n     }\n }\n \n-impl UseSpecializedEncodable for ExpnId {}\n-impl UseSpecializedDecodable for ExpnId {}\n-\n #[derive(Default)]\n pub struct HygieneEncodeContext {\n     /// All `SyntaxContexts` for which we have written `SyntaxContextData` into crate metadata.\n@@ -1137,6 +1132,7 @@ pub fn for_all_expns_in<E, F: FnMut(u32, ExpnId, &ExpnData) -> Result<(), E>>(\n     }\n     Ok(())\n }\n+\n pub fn for_all_data<E, F: FnMut((u32, SyntaxContext, &SyntaxContextData)) -> Result<(), E>>(\n     mut f: F,\n ) -> Result<(), E> {\n@@ -1147,6 +1143,18 @@ pub fn for_all_data<E, F: FnMut((u32, SyntaxContext, &SyntaxContextData)) -> Res\n     Ok(())\n }\n \n+impl<E: Encoder> Encodable<E> for ExpnId {\n+    default fn encode(&self, _: &mut E) -> Result<(), E::Error> {\n+        panic!(\"cannot encode `ExpnId` with `{}`\", std::any::type_name::<E>());\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for ExpnId {\n+    default fn decode(_: &mut D) -> Result<Self, D::Error> {\n+        panic!(\"cannot decode `ExpnId` with `{}`\", std::any::type_name::<D>());\n+    }\n+}\n+\n pub fn for_all_expn_data<E, F: FnMut(u32, &ExpnData) -> Result<(), E>>(mut f: F) -> Result<(), E> {\n     let all_data = HygieneData::with(|data| data.expn_data.clone());\n     for (i, data) in all_data.into_iter().enumerate() {\n@@ -1218,5 +1226,14 @@ impl<'a> ExpnDataDecodeMode<'a, Box<dyn FnOnce(CrateNum) -> &'a HygieneDecodeCon\n     }\n }\n \n-impl UseSpecializedEncodable for SyntaxContext {}\n-impl UseSpecializedDecodable for SyntaxContext {}\n+impl<E: Encoder> Encodable<E> for SyntaxContext {\n+    default fn encode(&self, _: &mut E) -> Result<(), E::Error> {\n+        panic!(\"cannot encode `SyntaxContext` with `{}`\", std::any::type_name::<E>());\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for SyntaxContext {\n+    default fn decode(_: &mut D) -> Result<Self, D::Error> {\n+        panic!(\"cannot decode `SyntaxContext` with `{}`\", std::any::type_name::<D>());\n+    }\n+}"}, {"sha": "c654dade2abd4ae60f9897e5eede270a153e9969", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -15,8 +15,7 @@\n #![feature(option_expect_none)]\n #![feature(refcell_take)]\n \n-// FIXME(#56935): Work around ICEs during cross-compilation.\n-#[allow(unused)]\n+#[macro_use]\n extern crate rustc_macros;\n \n use rustc_data_structures::AtomicRef;\n@@ -105,8 +104,8 @@ scoped_tls::scoped_thread_local!(pub static SESSION_GLOBALS: SessionGlobals);\n //\n // FIXME: We should use this enum or something like it to get rid of the\n // use of magic `/rust/1.x/...` paths across the board.\n-#[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash, RustcDecodable, RustcEncodable)]\n-#[derive(HashStable_Generic)]\n+#[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash)]\n+#[derive(HashStable_Generic, Decodable, Encodable)]\n pub enum RealFileName {\n     Named(PathBuf),\n     /// For de-virtualized paths (namely paths into libstd that have been mapped\n@@ -152,8 +151,8 @@ impl RealFileName {\n }\n \n /// Differentiates between real files and common virtual files.\n-#[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash, RustcDecodable, RustcEncodable)]\n-#[derive(HashStable_Generic)]\n+#[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash)]\n+#[derive(HashStable_Generic, Decodable, Encodable)]\n pub enum FileName {\n     Real(RealFileName),\n     /// Call to `quote!`.\n@@ -333,7 +332,7 @@ impl Ord for Span {\n ///   the error, and would be rendered with `^^^`.\n /// - They can have a *label*. In this case, the label is written next\n ///   to the mark in the snippet when we render.\n-#[derive(Clone, Debug, Hash, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Hash, PartialEq, Eq, Encodable, Decodable)]\n pub struct MultiSpan {\n     primary_spans: Vec<Span>,\n     span_labels: Vec<(Span, String)>,\n@@ -698,23 +697,22 @@ impl Default for Span {\n     }\n }\n \n-impl rustc_serialize::UseSpecializedEncodable for Span {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<E: Encoder> Encodable<E> for Span {\n+    default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         let span = self.data();\n         s.emit_struct(\"Span\", 2, |s| {\n             s.emit_struct_field(\"lo\", 0, |s| span.lo.encode(s))?;\n-\n             s.emit_struct_field(\"hi\", 1, |s| span.hi.encode(s))\n         })\n     }\n }\n-\n-impl rustc_serialize::UseSpecializedDecodable for Span {\n-    fn default_decode<D: Decoder>(d: &mut D) -> Result<Span, D::Error> {\n-        d.read_struct(\"Span\", 2, |d| {\n+impl<D: Decoder> Decodable<D> for Span {\n+    default fn decode(s: &mut D) -> Result<Span, D::Error> {\n+        s.read_struct(\"Span\", 2, |d| {\n             let lo = d.read_struct_field(\"lo\", 0, Decodable::decode)?;\n             let hi = d.read_struct_field(\"hi\", 1, Decodable::decode)?;\n-            Ok(Span::with_root_ctxt(lo, hi))\n+\n+            Ok(Span::new(lo, hi, SyntaxContext::root()))\n         })\n     }\n }\n@@ -889,7 +887,7 @@ impl From<Vec<Span>> for MultiSpan {\n }\n \n /// Identifies an offset of a multi-byte character in a `SourceFile`.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n+#[derive(Copy, Clone, Encodable, Decodable, Eq, PartialEq, Debug)]\n pub struct MultiByteChar {\n     /// The absolute offset of the character in the `SourceMap`.\n     pub pos: BytePos,\n@@ -898,7 +896,7 @@ pub struct MultiByteChar {\n }\n \n /// Identifies an offset of a non-narrow character in a `SourceFile`.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n+#[derive(Copy, Clone, Encodable, Decodable, Eq, PartialEq, Debug)]\n pub enum NonNarrowChar {\n     /// Represents a zero-width character.\n     ZeroWidth(BytePos),\n@@ -960,7 +958,7 @@ impl Sub<BytePos> for NonNarrowChar {\n }\n \n /// Identifies an offset of a character that was normalized away from `SourceFile`.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Eq, PartialEq, Debug)]\n+#[derive(Copy, Clone, Encodable, Decodable, Eq, PartialEq, Debug)]\n pub struct NormalizedPos {\n     /// The absolute offset of the character in the `SourceMap`.\n     pub pos: BytePos,\n@@ -1012,7 +1010,7 @@ impl ExternalSource {\n #[derive(Debug)]\n pub struct OffsetOverflowError;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n pub enum SourceFileHashAlgorithm {\n     Md5,\n     Sha1,\n@@ -1033,8 +1031,8 @@ impl FromStr for SourceFileHashAlgorithm {\n rustc_data_structures::impl_stable_hash_via_hash!(SourceFileHashAlgorithm);\n \n /// The hash of the on-disk source file used for debug info.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable)]\n-#[derive(HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub struct SourceFileHash {\n     pub kind: SourceFileHashAlgorithm,\n     value: [u8; 20],\n@@ -1113,8 +1111,8 @@ pub struct SourceFile {\n     pub cnum: CrateNum,\n }\n \n-impl Encodable for SourceFile {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for SourceFile {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_struct(\"SourceFile\", 8, |s| {\n             s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n             s.emit_struct_field(\"name_was_remapped\", 1, |s| self.name_was_remapped.encode(s))?;\n@@ -1183,8 +1181,8 @@ impl Encodable for SourceFile {\n     }\n }\n \n-impl Decodable for SourceFile {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<SourceFile, D::Error> {\n+impl<D: Decoder> Decodable<D> for SourceFile {\n+    fn decode(d: &mut D) -> Result<SourceFile, D::Error> {\n         d.read_struct(\"SourceFile\", 8, |d| {\n             let name: FileName = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n             let name_was_remapped: bool =\n@@ -1585,14 +1583,14 @@ impl Sub for BytePos {\n     }\n }\n \n-impl Encodable for BytePos {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: rustc_serialize::Encoder> Encodable<S> for BytePos {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u32(self.0)\n     }\n }\n \n-impl Decodable for BytePos {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<BytePos, D::Error> {\n+impl<D: rustc_serialize::Decoder> Decodable<D> for BytePos {\n+    fn decode(d: &mut D) -> Result<BytePos, D::Error> {\n         Ok(BytePos(d.read_u32()?))\n     }\n }"}, {"sha": "29e589057b5e2945ca1ec038c8fd4a14b3691011", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -75,7 +75,7 @@ pub mod monotonic {\n     impl<T> !DerefMut for MonotonicVec<T> {}\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable_Generic)]\n+#[derive(Clone, Encodable, Decodable, Debug, Copy, HashStable_Generic)]\n pub struct Spanned<T> {\n     pub node: T,\n     pub span: Span,\n@@ -118,7 +118,7 @@ impl FileLoader for RealFileLoader {\n // This is a `SourceFile` identifier that is used to correlate `SourceFile`s between\n // subsequent compilation sessions (which is something we need to do during\n // incremental compilation).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Encodable, Decodable, Debug)]\n pub struct StableSourceFileId(u128);\n \n // FIXME: we need a more globally consistent approach to the problem solved by"}, {"sha": "7843c04f25596e2f70d8cca544b9c918bf9a415d", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -5,9 +5,8 @@\n use rustc_arena::DroplessArena;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n-use rustc_macros::{symbols, HashStable_Generic};\n+use rustc_macros::HashStable_Generic;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-use rustc_serialize::{UseSpecializedDecodable, UseSpecializedEncodable};\n \n use std::cmp::{Ord, PartialEq, PartialOrd};\n use std::fmt;\n@@ -1192,7 +1191,7 @@ symbols! {\n     }\n }\n \n-#[derive(Copy, Clone, Eq, HashStable_Generic)]\n+#[derive(Copy, Clone, Eq, HashStable_Generic, Encodable, Decodable)]\n pub struct Ident {\n     pub name: Symbol,\n     pub span: Span,\n@@ -1289,26 +1288,6 @@ impl fmt::Display for Ident {\n     }\n }\n \n-impl UseSpecializedEncodable for Ident {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_struct(\"Ident\", 2, |s| {\n-            s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n-            s.emit_struct_field(\"span\", 1, |s| self.span.encode(s))\n-        })\n-    }\n-}\n-\n-impl UseSpecializedDecodable for Ident {\n-    fn default_decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n-        d.read_struct(\"Ident\", 2, |d| {\n-            Ok(Ident {\n-                name: d.read_struct_field(\"name\", 0, Decodable::decode)?,\n-                span: d.read_struct_field(\"span\", 1, Decodable::decode)?,\n-            })\n-        })\n-    }\n-}\n-\n /// This is the most general way to print identifiers.\n /// AST pretty-printer is used as a fallback for turning AST structures into token streams for\n /// proc macros. Additionally, proc macros may stringify their input and expect it survive the\n@@ -1452,15 +1431,15 @@ impl fmt::Display for Symbol {\n     }\n }\n \n-impl Encodable for Symbol {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<S: Encoder> Encodable<S> for Symbol {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         self.with(|string| s.emit_str(string))\n     }\n }\n \n-impl Decodable for Symbol {\n+impl<D: Decoder> Decodable<D> for Symbol {\n     #[inline]\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Symbol, D::Error> {\n+    fn decode(d: &mut D) -> Result<Symbol, D::Error> {\n         Ok(Symbol::intern(&d.read_str()?))\n     }\n }\n@@ -1549,7 +1528,7 @@ pub mod sym {\n     use super::Symbol;\n     use std::convert::TryInto;\n \n-    symbols!();\n+    define_symbols!();\n \n     // Used from a macro in `librustc_feature/accepted.rs`\n     pub use super::kw::MacroRules as macro_rules;"}, {"sha": "4b565dd246f6da06feea1d999f18fe13ba63f533", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -235,7 +235,7 @@ pub enum Endian {\n }\n \n /// Size of a type in bytes.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Encodable, Decodable)]\n #[derive(HashStable_Generic)]\n pub struct Size {\n     raw: u64,\n@@ -358,7 +358,7 @@ impl AddAssign for Size {\n }\n \n /// Alignment of a type in bytes (always a power of two).\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Encodable, Decodable)]\n #[derive(HashStable_Generic)]\n pub struct Align {\n     pow2: u8,\n@@ -415,7 +415,7 @@ impl Align {\n }\n \n /// A pair of alignments, ABI-mandated and preferred.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Encodable, Decodable)]\n #[derive(HashStable_Generic)]\n pub struct AbiAndPrefAlign {\n     pub abi: Align,"}, {"sha": "c22644bf813a4a0e0ddb6bf6e2b623e1b104e4b3", "filename": "src/librustc_target/asm/mod.rs", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_target%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_target%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fmod.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -13,7 +13,7 @@ macro_rules! def_reg_class {\n             $class:ident,\n         )*\n     }) => {\n-        #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n+        #[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n         #[allow(non_camel_case_types)]\n         pub enum $arch_regclass {\n             $($class,)*\n@@ -62,7 +62,7 @@ macro_rules! def_regs {\n         )*\n     }) => {\n         #[allow(unreachable_code)]\n-        #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n+        #[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n         #[allow(non_camel_case_types)]\n         pub enum $arch_reg {\n             $($reg,)*\n@@ -163,7 +163,7 @@ pub use nvptx::{NvptxInlineAsmReg, NvptxInlineAsmRegClass};\n pub use riscv::{RiscVInlineAsmReg, RiscVInlineAsmRegClass};\n pub use x86::{X86InlineAsmReg, X86InlineAsmRegClass};\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash)]\n pub enum InlineAsmArch {\n     X86,\n     X86_64,\n@@ -193,17 +193,7 @@ impl FromStr for InlineAsmArch {\n     }\n }\n \n-#[derive(\n-    Copy,\n-    Clone,\n-    RustcEncodable,\n-    RustcDecodable,\n-    Debug,\n-    Eq,\n-    PartialEq,\n-    Hash,\n-    HashStable_Generic\n-)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n pub enum InlineAsmReg {\n     X86(X86InlineAsmReg),\n     Arm(ArmInlineAsmReg),\n@@ -293,17 +283,7 @@ impl InlineAsmReg {\n     }\n }\n \n-#[derive(\n-    Copy,\n-    Clone,\n-    RustcEncodable,\n-    RustcDecodable,\n-    Debug,\n-    Eq,\n-    PartialEq,\n-    Hash,\n-    HashStable_Generic\n-)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n pub enum InlineAsmRegClass {\n     X86(X86InlineAsmRegClass),\n     Arm(ArmInlineAsmRegClass),\n@@ -429,17 +409,7 @@ impl InlineAsmRegClass {\n     }\n }\n \n-#[derive(\n-    Copy,\n-    Clone,\n-    RustcEncodable,\n-    RustcDecodable,\n-    Debug,\n-    Eq,\n-    PartialEq,\n-    Hash,\n-    HashStable_Generic\n-)]\n+#[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n pub enum InlineAsmRegOrRegClass {\n     Reg(InlineAsmReg),\n     RegClass(InlineAsmRegClass),"}, {"sha": "62df63ceb1efd8cf5d890b1dc2266040ac371eeb", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -16,8 +16,7 @@\n #![feature(associated_type_bounds)]\n #![feature(exhaustive_patterns)]\n \n-// FIXME(#56935): Work around ICEs during cross-compilation.\n-#[allow(unused)]\n+#[macro_use]\n extern crate rustc_macros;\n \n #[macro_use]"}, {"sha": "1e45739ca22b4a76f61c33be87661d35d4f19f5e", "filename": "src/librustc_target/spec/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_target%2Fspec%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_target%2Fspec%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fabi.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -5,8 +5,8 @@ use rustc_macros::HashStable_Generic;\n #[cfg(test)]\n mod tests;\n \n-#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Clone, Copy, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy, Debug)]\n+#[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum Abi {\n     // N.B., this ordering MUST match the AbiDatas array below.\n     // (This is ensured by the test indices_are_correct().)"}, {"sha": "fa29ff3f8d80f6df5fd1d97ca1602ff97e37a62d", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=cbcef3effcf64bd0d89ea2dc8973e18d7fcf94c3", "patch": "@@ -161,7 +161,7 @@ flavor_mappings! {\n     ((LinkerFlavor::Lld(LldFlavor::Link)), \"lld-link\"),\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Clone, Copy, Debug, PartialEq, Hash, Encodable, Decodable, HashStable_Generic)]\n pub enum PanicStrategy {\n     Unwind,\n     Abort,\n@@ -185,7 +185,7 @@ impl ToJson for PanicStrategy {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub enum RelroLevel {\n     Full,\n     Partial,\n@@ -229,7 +229,7 @@ impl ToJson for RelroLevel {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, Debug, PartialEq, Hash, Encodable, Decodable)]\n pub enum MergeFunctions {\n     Disabled,\n     Trampolines,\n@@ -1734,7 +1734,7 @@ impl ToJson for Target {\n }\n \n /// Either a target triple string or a path to a JSON file.\n-#[derive(PartialEq, Clone, Debug, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(PartialEq, Clone, Debug, Hash, Encodable, Decodable)]\n pub enum TargetTriple {\n     TargetTriple(String),\n     TargetPath(PathBuf),"}]}