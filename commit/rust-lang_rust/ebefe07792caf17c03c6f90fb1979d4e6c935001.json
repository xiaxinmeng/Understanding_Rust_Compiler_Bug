{"sha": "ebefe07792caf17c03c6f90fb1979d4e6c935001", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZWZlMDc3OTJjYWYxN2MwM2M2ZjkwZmIxOTc5ZDRlNmM5MzUwMDE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-15T23:00:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-15T23:00:15Z"}, "message": "core::rt: Make Scheduler::unsafe_local return a fabricated region pointer\n\nInstead of taking a closure. It's unsafe either way. Rename it to unsafe_local_borrow.", "tree": {"sha": "c0849200ec0237e39999e09a9d0eb2fbcbf84a43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0849200ec0237e39999e09a9d0eb2fbcbf84a43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebefe07792caf17c03c6f90fb1979d4e6c935001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebefe07792caf17c03c6f90fb1979d4e6c935001", "html_url": "https://github.com/rust-lang/rust/commit/ebefe07792caf17c03c6f90fb1979d4e6c935001", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebefe07792caf17c03c6f90fb1979d4e6c935001/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "473b4d19ad51529afb8f1391cf471a20053c781c", "url": "https://api.github.com/repos/rust-lang/rust/commits/473b4d19ad51529afb8f1391cf471a20053c781c", "html_url": "https://github.com/rust-lang/rust/commit/473b4d19ad51529afb8f1391cf471a20053c781c"}], "stats": {"total": 475, "additions": 228, "deletions": 247}, "files": [{"sha": "d800101111464782067a6b56200d94ad100ea297", "filename": "src/libcore/rt/sched/local.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ebefe07792caf17c03c6f90fb1979d4e6c935001/src%2Flibcore%2Frt%2Fsched%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebefe07792caf17c03c6f90fb1979d4e6c935001/src%2Flibcore%2Frt%2Fsched%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Flocal.rs?ref=ebefe07792caf17c03c6f90fb1979d4e6c935001", "patch": "@@ -43,7 +43,7 @@ pub fn take() -> ~Scheduler {\n /// # Safety Note\n /// Because this leaves the Scheduler in thread-local storage it is possible\n /// For the Scheduler pointer to be aliased\n-pub unsafe fn borrow(f: &fn(&mut Scheduler)) {\n+pub unsafe fn borrow() -> &mut Scheduler {\n     unsafe {\n         let key = tls_key();\n         let mut void_sched: *mut c_void = tls::get(key);\n@@ -54,7 +54,7 @@ pub unsafe fn borrow(f: &fn(&mut Scheduler)) {\n                 transmute::<&mut *mut c_void, &mut ~Scheduler>(void_sched_ptr)\n             };\n             let sched: &mut Scheduler = &mut **sched;\n-            f(sched);\n+            return sched;\n         }\n     }\n }\n@@ -93,8 +93,7 @@ fn borrow_smoke_test() {\n     let scheduler = ~UvEventLoop::new_scheduler();\n     put(scheduler);\n     unsafe {\n-        do borrow |_sched| {\n-        }\n+        let _scheduler = borrow();\n     }\n     let _scheduler = take();\n }"}, {"sha": "a2a440ba76eae2e0b365d27872eedd751493060d", "filename": "src/libcore/rt/sched/mod.rs", "status": "modified", "additions": 47, "deletions": 50, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/ebefe07792caf17c03c6f90fb1979d4e6c935001/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebefe07792caf17c03c6f90fb1979d4e6c935001/src%2Flibcore%2Frt%2Fsched%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched%2Fmod.rs?ref=ebefe07792caf17c03c6f90fb1979d4e6c935001", "patch": "@@ -95,29 +95,33 @@ pub impl Scheduler {\n         // Give ownership of the scheduler (self) to the thread\n         local::put(self);\n \n-        do Scheduler::unsafe_local |scheduler| {\n-            fn run_scheduler_once() {\n-                do Scheduler::unsafe_local |scheduler| {\n-                    if scheduler.resume_task_from_queue() {\n-                        // Ok, a task ran. Nice! We'll do it again later\n-                        scheduler.event_loop.callback(run_scheduler_once);\n-                    }\n-                }\n+        let scheduler = Scheduler::unsafe_local_borrow();\n+        fn run_scheduler_once() {\n+            let scheduler = Scheduler::unsafe_local_borrow();\n+            if scheduler.resume_task_from_queue() {\n+                // Ok, a task ran. Nice! We'll do it again later\n+                scheduler.event_loop.callback(run_scheduler_once);\n             }\n-\n-            scheduler.event_loop.callback(run_scheduler_once);\n-            scheduler.event_loop.run();\n         }\n \n+        scheduler.event_loop.callback(run_scheduler_once);\n+        scheduler.event_loop.run();\n+\n         return local::take();\n     }\n \n     /// Get a mutable pointer to the thread-local scheduler.\n     /// # Safety Note\n     /// This allows other mutable aliases to the scheduler, both in the current\n     /// execution context and other execution contexts.\n-    fn unsafe_local(f: &fn(&mut Scheduler)) {\n-        unsafe { local::borrow(f) }\n+    fn unsafe_local_borrow() -> &mut Scheduler {\n+        unsafe { local::borrow() }\n+    }\n+\n+    fn local_borrow(f: &fn(&mut Scheduler)) {\n+        let mut sched = local::take();\n+        f(sched);\n+        local::put(sched);\n     }\n \n     // * Scheduler-context operations\n@@ -208,9 +212,8 @@ pub impl Scheduler {\n         }\n \n         // We could be executing in a different thread now\n-        do Scheduler::unsafe_local |sched| {\n-            sched.run_cleanup_job();\n-        }\n+        let sched = Scheduler::unsafe_local_borrow();\n+        sched.run_cleanup_job();\n     }\n \n     /// Switch directly to another task, without going through the scheduler.\n@@ -232,9 +235,8 @@ pub impl Scheduler {\n         }\n \n         // We could be executing in a different thread now\n-        do Scheduler::unsafe_local |sched| {\n-            sched.run_cleanup_job();\n-        }\n+        let sched = Scheduler::unsafe_local_borrow();\n+        sched.run_cleanup_job();\n     }\n \n     // * Other stuff\n@@ -331,15 +333,13 @@ pub impl Task {\n             // This is the first code to execute after the initial\n             // context switch to the task. The previous context may\n             // have asked us to do some cleanup.\n-            do Scheduler::unsafe_local |sched| {\n-                sched.run_cleanup_job();\n-            }\n+            let sched = Scheduler::unsafe_local_borrow();\n+            sched.run_cleanup_job();\n \n             start();\n \n-            do Scheduler::unsafe_local |sched| {\n-                sched.terminate_current_task();\n-            }\n+            let sched = Scheduler::unsafe_local_borrow();\n+            sched.terminate_current_task();\n         };\n         return wrapper;\n     }\n@@ -398,13 +398,12 @@ fn test_swap_tasks() {\n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task1 = ~do Task::new(&mut sched.stack_pool) {\n             unsafe { *count_ptr = *count_ptr + 1; }\n-            do Scheduler::unsafe_local |sched| {\n-                let task2 = ~do Task::new(&mut sched.stack_pool) {\n-                    unsafe { *count_ptr = *count_ptr + 1; }\n-                };\n-                // Context switch directly to the new task\n-                sched.resume_task_from_running_task_direct(task2);\n-            }\n+            let sched = Scheduler::unsafe_local_borrow();\n+            let task2 = ~do Task::new(&mut sched.stack_pool) {\n+                unsafe { *count_ptr = *count_ptr + 1; }\n+            };\n+            // Context switch directly to the new task\n+            sched.resume_task_from_running_task_direct(task2);\n             unsafe { *count_ptr = *count_ptr + 1; }\n         };\n         sched.task_queue.push_back(task1);\n@@ -431,7 +430,7 @@ fn test_run_a_lot_of_tasks_queued() {\n         assert!(count == MAX);\n \n         fn run_task(count_ptr: *mut int) {\n-            do Scheduler::unsafe_local |sched| {\n+            do Scheduler::local_borrow |sched| {\n                 let task = ~do Task::new(&mut sched.stack_pool) {\n                     unsafe {\n                         *count_ptr = *count_ptr + 1;\n@@ -464,18 +463,17 @@ fn test_run_a_lot_of_tasks_direct() {\n         assert!(count == MAX);\n \n         fn run_task(count_ptr: *mut int) {\n-            do Scheduler::unsafe_local |sched| {\n-                let task = ~do Task::new(&mut sched.stack_pool) {\n-                    unsafe {\n-                        *count_ptr = *count_ptr + 1;\n-                        if *count_ptr != MAX {\n-                            run_task(count_ptr);\n-                        }\n+            let sched = Scheduler::unsafe_local_borrow();\n+            let task = ~do Task::new(&mut sched.stack_pool) {\n+                unsafe {\n+                    *count_ptr = *count_ptr + 1;\n+                    if *count_ptr != MAX {\n+                        run_task(count_ptr);\n                     }\n-                };\n-                // Context switch directly to the new task\n-                sched.resume_task_from_running_task_direct(task);\n-            }\n+                }\n+            };\n+            // Context switch directly to the new task\n+            sched.resume_task_from_running_task_direct(task);\n         };\n     }\n }\n@@ -485,12 +483,11 @@ fn test_block_task() {\n     do run_in_bare_thread {\n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task = ~do Task::new(&mut sched.stack_pool) {\n-            do Scheduler::unsafe_local |sched| {\n-                assert!(sched.in_task_context());\n-                do sched.deschedule_running_task_and_then() |sched, task| {\n-                    assert!(!sched.in_task_context());\n-                    sched.task_queue.push_back(task);\n-                }\n+            let sched = Scheduler::unsafe_local_borrow();\n+            assert!(sched.in_task_context());\n+            do sched.deschedule_running_task_and_then() |sched, task| {\n+                assert!(!sched.in_task_context());\n+                sched.task_queue.push_back(task);\n             }\n         };\n         sched.task_queue.push_back(task);"}, {"sha": "a43ec07c2de118725c733f6c2b93c35fa7aa8472", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 178, "deletions": 193, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/ebefe07792caf17c03c6f90fb1979d4e6c935001/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebefe07792caf17c03c6f90fb1979d4e6c935001/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=ebefe07792caf17c03c6f90fb1979d4e6c935001", "patch": "@@ -104,37 +104,35 @@ impl IoFactory for UvIoFactory {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Option<~StreamObject>> = &result_cell;\n \n-        do Scheduler::unsafe_local |scheduler| {\n-            assert!(scheduler.in_task_context());\n-\n-            // Block this task and take ownership, switch to scheduler context\n-            do scheduler.deschedule_running_task_and_then |scheduler, task| {\n-\n-                rtdebug!(\"connect: entered scheduler context\");\n-                assert!(!scheduler.in_task_context());\n-                let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n-                let task_cell = Cell(task);\n-\n-                // Wait for a connection\n-                do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                    rtdebug!(\"connect: in connect callback\");\n-                    let maybe_stream = if status.is_none() {\n-                        rtdebug!(\"status is none\");\n-                        Some(~UvStream(stream_watcher))\n-                    } else {\n-                        rtdebug!(\"status is some\");\n-                        stream_watcher.close(||());\n-                        None\n-                    };\n-\n-                    // Store the stream in the task's stack\n-                    unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n-\n-                    // Context switch\n-                    do Scheduler::unsafe_local |scheduler| {\n-                        scheduler.resume_task_immediately(task_cell.take());\n-                    }\n-                }\n+        let scheduler = Scheduler::unsafe_local_borrow();\n+        assert!(scheduler.in_task_context());\n+\n+        // Block this task and take ownership, switch to scheduler context\n+        do scheduler.deschedule_running_task_and_then |scheduler, task| {\n+\n+            rtdebug!(\"connect: entered scheduler context\");\n+            assert!(!scheduler.in_task_context());\n+            let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n+            let task_cell = Cell(task);\n+\n+            // Wait for a connection\n+            do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                rtdebug!(\"connect: in connect callback\");\n+                let maybe_stream = if status.is_none() {\n+                    rtdebug!(\"status is none\");\n+                    Some(~UvStream(stream_watcher))\n+                } else {\n+                    rtdebug!(\"status is some\");\n+                    stream_watcher.close(||());\n+                    None\n+                };\n+\n+                // Store the stream in the task's stack\n+                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n+\n+                // Context switch\n+                let scheduler = Scheduler::unsafe_local_borrow();\n+                scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n \n@@ -178,33 +176,31 @@ impl TcpListener for UvTcpListener {\n \n         let server_tcp_watcher = self.watcher();\n \n-        do Scheduler::unsafe_local |scheduler| {\n-            assert!(scheduler.in_task_context());\n-\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell(task);\n-                let mut server_tcp_watcher = server_tcp_watcher;\n-                do server_tcp_watcher.listen |server_stream_watcher, status| {\n-                    let maybe_stream = if status.is_none() {\n-                        let mut server_stream_watcher = server_stream_watcher;\n-                        let mut loop_ = loop_from_watcher(&server_stream_watcher);\n-                        let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-                        let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n-                        // XXX: Need's to be surfaced in interface\n-                        server_stream_watcher.accept(client_tcp_watcher);\n-                        Some(~UvStream::new(client_tcp_watcher))\n-                    } else {\n-                        None\n-                    };\n-\n-                    unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n-\n-                    rtdebug!(\"resuming task from listen\");\n-                    // Context switch\n-                    do Scheduler::unsafe_local |scheduler| {\n-                        scheduler.resume_task_immediately(task_cell.take());\n-                    }\n-                }\n+        let scheduler = Scheduler::unsafe_local_borrow();\n+        assert!(scheduler.in_task_context());\n+\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let task_cell = Cell(task);\n+            let mut server_tcp_watcher = server_tcp_watcher;\n+            do server_tcp_watcher.listen |server_stream_watcher, status| {\n+                let maybe_stream = if status.is_none() {\n+                    let mut server_stream_watcher = server_stream_watcher;\n+                    let mut loop_ = loop_from_watcher(&server_stream_watcher);\n+                    let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                    let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n+                    // XXX: Need's to be surfaced in interface\n+                    server_stream_watcher.accept(client_tcp_watcher);\n+                    Some(~UvStream::new(client_tcp_watcher))\n+                } else {\n+                    None\n+                };\n+\n+                unsafe { (*result_cell_ptr).put_back(maybe_stream); }\n+\n+                rtdebug!(\"resuming task from listen\");\n+                // Context switch\n+                let scheduler = Scheduler::unsafe_local_borrow();\n+                scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n \n@@ -243,42 +239,40 @@ impl Stream for UvStream {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<uint, ()>> = &result_cell;\n \n-        do Scheduler::unsafe_local |scheduler| {\n-            assert!(scheduler.in_task_context());\n-            let watcher = self.watcher();\n-            let buf_ptr: *&mut [u8] = &buf;\n-            do scheduler.deschedule_running_task_and_then |scheduler, task| {\n-                rtdebug!(\"read: entered scheduler context\");\n-                assert!(!scheduler.in_task_context());\n+        let scheduler = Scheduler::unsafe_local_borrow();\n+        assert!(scheduler.in_task_context());\n+        let watcher = self.watcher();\n+        let buf_ptr: *&mut [u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |scheduler, task| {\n+            rtdebug!(\"read: entered scheduler context\");\n+            assert!(!scheduler.in_task_context());\n+            let mut watcher = watcher;\n+            let task_cell = Cell(task);\n+            // XXX: We shouldn't reallocate these callbacks every\n+            // call to read\n+            let alloc: AllocCallback = |_| unsafe {\n+                slice_to_uv_buf(*buf_ptr)\n+            };\n+            do watcher.read_start(alloc) |watcher, nread, _buf, status| {\n+\n+                // Stop reading so that no read callbacks are\n+                // triggered before the user calls `read` again.\n+                // XXX: Is there a performance impact to calling\n+                // stop here?\n                 let mut watcher = watcher;\n-                let task_cell = Cell(task);\n-                // XXX: We shouldn't reallocate these callbacks every\n-                // call to read\n-                let alloc: AllocCallback = |_| unsafe {\n-                    slice_to_uv_buf(*buf_ptr)\n+                watcher.read_stop();\n+\n+                let result = if status.is_none() {\n+                    assert!(nread >= 0);\n+                    Ok(nread as uint)\n+                } else {\n+                    Err(())\n                 };\n-                do watcher.read_start(alloc) |watcher, nread, _buf, status| {\n-\n-                    // Stop reading so that no read callbacks are\n-                    // triggered before the user calls `read` again.\n-                    // XXX: Is there a performance impact to calling\n-                    // stop here?\n-                    let mut watcher = watcher;\n-                    watcher.read_stop();\n-\n-                    let result = if status.is_none() {\n-                        assert!(nread >= 0);\n-                        Ok(nread as uint)\n-                    } else {\n-                        Err(())\n-                    };\n-\n-                    unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                    do Scheduler::unsafe_local |scheduler| {\n-                        scheduler.resume_task_immediately(task_cell.take());\n-                    }\n-                }\n+\n+                unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                let scheduler = Scheduler::unsafe_local_borrow();\n+                scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n \n@@ -289,29 +283,27 @@ impl Stream for UvStream {\n     fn write(&mut self, buf: &[u8]) -> Result<(), ()> {\n         let result_cell = empty_cell();\n         let result_cell_ptr: *Cell<Result<(), ()>> = &result_cell;\n-        do Scheduler::unsafe_local |scheduler| {\n-            assert!(scheduler.in_task_context());\n-            let watcher = self.watcher();\n-            let buf_ptr: *&[u8] = &buf;\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let mut watcher = watcher;\n-                let task_cell = Cell(task);\n-                let buf = unsafe { &*buf_ptr };\n-                // XXX: OMGCOPIES\n-                let buf = buf.to_vec();\n-                do watcher.write(buf) |_watcher, status| {\n-                    let result = if status.is_none() {\n-                        Ok(())\n-                    } else {\n-                        Err(())\n-                    };\n-\n-                    unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                    do Scheduler::unsafe_local |scheduler| {\n-                        scheduler.resume_task_immediately(task_cell.take());\n-                    }\n-                }\n+        let scheduler = Scheduler::unsafe_local_borrow();\n+        assert!(scheduler.in_task_context());\n+        let watcher = self.watcher();\n+        let buf_ptr: *&[u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let mut watcher = watcher;\n+            let task_cell = Cell(task);\n+            let buf = unsafe { &*buf_ptr };\n+            // XXX: OMGCOPIES\n+            let buf = buf.to_vec();\n+            do watcher.write(buf) |_watcher, status| {\n+                let result = if status.is_none() {\n+                    Ok(())\n+                } else {\n+                    Err(())\n+                };\n+\n+                unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                let scheduler = Scheduler::unsafe_local_borrow();\n+                scheduler.resume_task_immediately(task_cell.take());\n             }\n         }\n \n@@ -326,12 +318,11 @@ fn test_simple_io_no_connect() {\n     do run_in_bare_thread {\n         let mut sched = ~UvEventLoop::new_scheduler();\n         let task = ~do Task::new(&mut sched.stack_pool) {\n-            do Scheduler::unsafe_local |sched| {\n-                let io = sched.event_loop.io().unwrap();\n-                let addr = Ipv4(127, 0, 0, 1, 2926);\n-                let maybe_chan = io.connect(addr);\n-                assert!(maybe_chan.is_none());\n-            }\n+            let sched = Scheduler::unsafe_local_borrow();\n+            let io = sched.event_loop.io().unwrap();\n+            let addr = Ipv4(127, 0, 0, 1, 2926);\n+            let maybe_chan = io.connect(addr);\n+            assert!(maybe_chan.is_none());\n         };\n         sched.task_queue.push_back(task);\n         sched.run();\n@@ -346,29 +337,27 @@ fn test_simple_tcp_server_and_client() {\n         let addr = Ipv4(127, 0, 0, 1, 2929);\n \n         let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            do Scheduler::unsafe_local |sched| {\n-                let io = sched.event_loop.io().unwrap();\n-                let mut stream = io.connect(addr).unwrap();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.close();\n-            }\n+            let sched = Scheduler::unsafe_local_borrow();\n+            let io = sched.event_loop.io().unwrap();\n+            let mut stream = io.connect(addr).unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.close();\n         };\n \n         let server_task = ~do Task::new(&mut sched.stack_pool) {\n-            do Scheduler::unsafe_local |sched| {\n-                let io = sched.event_loop.io().unwrap();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n-                let mut buf = [0, .. 2048];\n-                let nread = stream.read(buf).unwrap();\n-                assert!(nread == 8);\n-                for uint::range(0, nread) |i| {\n-                    rtdebug!(\"%u\", buf[i] as uint);\n-                    assert!(buf[i] == i as u8);\n-                }\n-                stream.close();\n-                listener.close();\n+            let sched = Scheduler::unsafe_local_borrow();\n+            let io = sched.event_loop.io().unwrap();\n+            let mut listener = io.bind(addr).unwrap();\n+            let mut stream = listener.listen().unwrap();\n+            let mut buf = [0, .. 2048];\n+            let nread = stream.read(buf).unwrap();\n+            assert!(nread == 8);\n+            for uint::range(0, nread) |i| {\n+                rtdebug!(\"%u\", buf[i] as uint);\n+                assert!(buf[i] == i as u8);\n             }\n+            stream.close();\n+            listener.close();\n         };\n \n         // Start the server first so it listens before the client connects\n@@ -385,53 +374,50 @@ fn test_read_and_block() {\n         let addr = Ipv4(127, 0, 0, 1, 2930);\n \n         let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            do Scheduler::unsafe_local |sched| {\n-                let io = sched.event_loop.io().unwrap();\n-                let mut stream = io.connect(addr).unwrap();\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-                stream.close();\n-            }\n+            let sched = Scheduler::unsafe_local_borrow();\n+            let io = sched.event_loop.io().unwrap();\n+            let mut stream = io.connect(addr).unwrap();\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+            stream.close();\n         };\n \n         let server_task = ~do Task::new(&mut sched.stack_pool) {\n-            do Scheduler::unsafe_local |sched| {\n-                let io = sched.event_loop.io().unwrap();\n-                let mut listener = io.bind(addr).unwrap();\n-                let mut stream = listener.listen().unwrap();\n-                let mut buf = [0, .. 2048];\n-\n-                let expected = 32;\n-                let mut current = 0;\n-                let mut reads = 0;\n-\n-                while current < expected {\n-                    let nread = stream.read(buf).unwrap();\n-                    for uint::range(0, nread) |i| {\n-                        let val = buf[i] as uint;\n-                        assert!(val == current % 8);\n-                        current += 1;\n-                    }\n-                    reads += 1;\n-\n-                    do Scheduler::unsafe_local |scheduler| {\n-                        // Yield to the other task in hopes that it\n-                        // will trigger a read callback while we are\n-                        // not ready for it\n-                        do scheduler.deschedule_running_task_and_then |scheduler, task| {\n-                            scheduler.task_queue.push_back(task);\n-                        }\n-                    }\n-                }\n+            let sched = Scheduler::unsafe_local_borrow();\n+            let io = sched.event_loop.io().unwrap();\n+            let mut listener = io.bind(addr).unwrap();\n+            let mut stream = listener.listen().unwrap();\n+            let mut buf = [0, .. 2048];\n \n-                // Make sure we had multiple reads\n-                assert!(reads > 1);\n+            let expected = 32;\n+            let mut current = 0;\n+            let mut reads = 0;\n \n-                stream.close();\n-                listener.close();\n+            while current < expected {\n+                let nread = stream.read(buf).unwrap();\n+                for uint::range(0, nread) |i| {\n+                    let val = buf[i] as uint;\n+                    assert!(val == current % 8);\n+                    current += 1;\n+                }\n+                reads += 1;\n+\n+                let scheduler = Scheduler::unsafe_local_borrow();\n+                // Yield to the other task in hopes that it\n+                // will trigger a read callback while we are\n+                // not ready for it\n+                do scheduler.deschedule_running_task_and_then |scheduler, task| {\n+                    scheduler.task_queue.push_back(task);\n+                }\n             }\n+\n+            // Make sure we had multiple reads\n+            assert!(reads > 1);\n+\n+            stream.close();\n+            listener.close();\n         };\n \n         // Start the server first so it listens before the client connects\n@@ -448,19 +434,18 @@ fn test_read_read_read() {\n         let addr = Ipv4(127, 0, 0, 1, 2931);\n \n         let client_task = ~do Task::new(&mut sched.stack_pool) {\n-            do Scheduler::unsafe_local |sched| {\n-                let io = sched.event_loop.io().unwrap();\n-                let mut stream = io.connect(addr).unwrap();\n-                let mut buf = [0, .. 2048];\n-                let mut total_bytes_read = 0;\n-                while total_bytes_read < 500000000 {\n-                    let nread = stream.read(buf).unwrap();\n-                    rtdebug!(\"read %u bytes\", nread as uint);\n-                    total_bytes_read += nread;\n-                }\n-                rtdebug_!(\"read %u bytes total\", total_bytes_read as uint);\n-                stream.close();\n+            let sched = Scheduler::unsafe_local_borrow();\n+            let io = sched.event_loop.io().unwrap();\n+            let mut stream = io.connect(addr).unwrap();\n+            let mut buf = [0, .. 2048];\n+            let mut total_bytes_read = 0;\n+            while total_bytes_read < 500000000 {\n+                let nread = stream.read(buf).unwrap();\n+                rtdebug!(\"read %u bytes\", nread as uint);\n+                total_bytes_read += nread;\n             }\n+            rtdebug_!(\"read %u bytes total\", total_bytes_read as uint);\n+            stream.close();\n         };\n \n         sched.task_queue.push_back(client_task);"}]}