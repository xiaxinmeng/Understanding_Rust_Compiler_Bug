{"sha": "bdcd19d294a0b0eeaa4691bf111dbf25960c0558", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkY2QxOWQyOTRhMGIwZWVhYTQ2OTFiZjExMWRiZjI1OTYwYzA1NTg=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-10-27T16:38:04Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-10-27T16:38:04Z"}, "message": "Read local dependencies from cargo metadata", "tree": {"sha": "ae19dfc76c37bbe04dff8934b37f2d1671df8266", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae19dfc76c37bbe04dff8934b37f2d1671df8266"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdcd19d294a0b0eeaa4691bf111dbf25960c0558", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdcd19d294a0b0eeaa4691bf111dbf25960c0558", "html_url": "https://github.com/rust-lang/rust/commit/bdcd19d294a0b0eeaa4691bf111dbf25960c0558", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdcd19d294a0b0eeaa4691bf111dbf25960c0558/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d86b0eaf83e619c2d54b7ac55ff1a91b831ca0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d86b0eaf83e619c2d54b7ac55ff1a91b831ca0b", "html_url": "https://github.com/rust-lang/rust/commit/8d86b0eaf83e619c2d54b7ac55ff1a91b831ca0b"}], "stats": {"total": 202, "additions": 142, "deletions": 60}, "files": [{"sha": "14d1715286a00ac8ce936c3c28b42c6af5ae5738", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 142, "deletions": 60, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/bdcd19d294a0b0eeaa4691bf111dbf25960c0558/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdcd19d294a0b0eeaa4691bf111dbf25960c0558/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=bdcd19d294a0b0eeaa4691bf111dbf25960c0558", "patch": "@@ -180,6 +180,29 @@ pub struct Target {\n     kind: TargetKind,\n }\n \n+impl Target {\n+    pub fn from_json(json_val: &Value) -> Option<Self> {\n+        let jtarget = json_val.as_object()?;\n+        let path = PathBuf::from(jtarget.get(\"src_path\")?.as_str()?);\n+        let kinds = jtarget.get(\"kind\")?.as_array()?;\n+        let kind = match kinds[0].as_str()? {\n+            \"bin\" => TargetKind::Bin,\n+            \"lib\" | \"dylib\" | \"staticlib\" | \"cdylib\" | \"rlib\" => TargetKind::Lib,\n+            \"test\" => TargetKind::Test,\n+            \"example\" => TargetKind::Example,\n+            \"bench\" => TargetKind::Bench,\n+            \"custom-build\" => TargetKind::CustomBuild,\n+            \"proc-macro\" => TargetKind::ProcMacro,\n+            _ => TargetKind::Other,\n+        };\n+\n+        Some(Target {\n+            path: path,\n+            kind: kind,\n+        })\n+    }\n+}\n+\n #[derive(Debug, PartialEq, Eq)]\n pub enum WorkspaceHitlist {\n     All,\n@@ -205,76 +228,135 @@ impl WorkspaceHitlist {\n     }\n }\n \n-// Returns a vector of all compile targets of a crate\n-fn get_targets(workspace_hitlist: &WorkspaceHitlist) -> Result<Vec<Target>, std::io::Error> {\n+fn get_cargo_metadata_from_utf8(v: &[u8]) -> Option<Value> {\n+    json::from_str(str::from_utf8(v).ok()?).ok()\n+}\n+\n+fn get_json_array_with<'a>(v: &'a Value, key: &str) -> Option<&'a Vec<Value>> {\n+    v.as_object()?.get(key)?.as_array()\n+}\n+\n+// `cargo metadata --no-deps | jq '.[\"packages\"]'`\n+fn get_packages(v: &[u8]) -> Result<Vec<Value>, io::Error> {\n+    let e = io::Error::new(\n+        io::ErrorKind::NotFound,\n+        String::from(\"`cargo metadata` returned json without a 'packages' key\"),\n+    );\n+    match get_cargo_metadata_from_utf8(v) {\n+        Some(ref json_obj) => get_json_array_with(json_obj, \"packages\").cloned().ok_or(e),\n+        None => Err(e),\n+    }\n+}\n+\n+fn extract_target_from_package(package: &Value) -> Option<Vec<Target>> {\n+    let jtargets = get_json_array_with(package, \"targets\")?;\n     let mut targets: Vec<Target> = vec![];\n+    for jtarget in jtargets {\n+        targets.push(Target::from_json(&jtarget)?);\n+    }\n+    Some(targets)\n+}\n \n+fn filter_packages_with_hitlist<'a>(\n+    packages: Vec<Value>,\n+    workspace_hitlist: &'a WorkspaceHitlist,\n+) -> Result<Vec<Value>, &'a String> {\n+    if *workspace_hitlist == WorkspaceHitlist::All {\n+        return Ok(packages);\n+    }\n+    let mut hitlist: HashSet<&String> = workspace_hitlist\n+        .get_some()\n+        .map_or(HashSet::new(), HashSet::from_iter);\n+    let members: Vec<Value> = packages\n+        .into_iter()\n+        .filter(|member| {\n+            member\n+                .as_object()\n+                .and_then(|member_obj| {\n+                    member_obj\n+                        .get(\"name\")\n+                        .and_then(Value::as_str)\n+                        .map(|member_name| {\n+                            hitlist.take(&member_name.to_string()).is_some()\n+                        })\n+                })\n+                .unwrap_or(false)\n+        })\n+        .collect();\n+    if hitlist.is_empty() {\n+        Ok(members)\n+    } else {\n+        Err(hitlist.into_iter().next().unwrap())\n+    }\n+}\n+\n+fn get_dependencies_from_package(package: &Value) -> Option<Vec<PathBuf>> {\n+    let jdependencies = get_json_array_with(package, \"dependencies\")?;\n+    let root_path = env::current_dir().ok()?;\n+    let mut dependencies: Vec<PathBuf> = vec![];\n+    for jdep in jdependencies {\n+        let jdependency = jdep.as_object()?;\n+        if !jdependency.get(\"source\")?.is_null() {\n+            continue;\n+        }\n+        let name = jdependency.get(\"name\")?.as_str()?;\n+        let mut path = root_path.clone();\n+        path.push(&name);\n+        dependencies.push(path);\n+    }\n+    Some(dependencies)\n+}\n+\n+// Returns a vector of local dependencies under this crate\n+fn get_path_to_local_dependencies(packages: &[Value]) -> Vec<PathBuf> {\n+    let mut local_dependencies: Vec<PathBuf> = vec![];\n+    for package in packages {\n+        if let Some(mut d) = get_dependencies_from_package(package) {\n+            local_dependencies.append(&mut d);\n         }\n     }\n+    local_dependencies\n+}\n+\n+// Returns a vector of all compile targets of a crate\n+fn get_targets(workspace_hitlist: &WorkspaceHitlist) -> Result<Vec<Target>, io::Error> {\n     let output = Command::new(\"cargo\")\n-        .arg(\"metadata\")\n-        .arg(\"--no-deps\")\n+        .args(&[\"metadata\", \"--no-deps\", \"--format-version=1\"])\n         .output()?;\n     if output.status.success() {\n-        let data = &String::from_utf8(output.stdout).unwrap();\n-        let json: Value = json::from_str(data).unwrap();\n-        let json_obj = json.as_object().unwrap();\n-        let mut hitlist: HashSet<&String> = if *workspace_hitlist != WorkspaceHitlist::All {\n-            HashSet::from_iter(workspace_hitlist.get_some().unwrap())\n-        } else {\n-            HashSet::new() // Unused\n-        };\n-        let members: Vec<&Value> = json_obj\n-            .get(\"packages\")\n-            .unwrap()\n-            .as_array()\n-            .unwrap()\n-            .into_iter()\n-            .filter(|member| if *workspace_hitlist == WorkspaceHitlist::All {\n-                true\n-            } else {\n-                let member_obj = member.as_object().unwrap();\n-                let member_name = member_obj.get(\"name\").unwrap().as_str().unwrap();\n-                hitlist.take(&member_name.to_string()).is_some()\n-            })\n-            .collect();\n-        if !hitlist.is_empty() {\n-            // Mimick cargo of only outputting one <package> spec.\n-            return Err(std::io::Error::new(\n-                std::io::ErrorKind::InvalidInput,\n-                format!(\n-                    \"package `{}` is not a member of the workspace\",\n-                    hitlist.iter().next().unwrap()\n-                ),\n-            ));\n+        let cur_dir = env::current_dir()?;\n+        let mut targets: Vec<Target> = vec![];\n+        let packages = get_packages(&output.stdout)?;\n+\n+        // If we can find any local dependencies, we will try to get targets from those as well.\n+        for path in get_path_to_local_dependencies(&packages) {\n+            env::set_current_dir(path)?;\n+            targets.append(&mut get_targets(workspace_hitlist)?);\n         }\n-        for member in members {\n-            let member_obj = member.as_object().unwrap();\n-            let jtargets = member_obj.get(\"targets\").unwrap().as_array().unwrap();\n-            for jtarget in jtargets {\n-                targets.push(target_from_json(jtarget));\n+\n+        env::set_current_dir(cur_dir)?;\n+        match filter_packages_with_hitlist(packages, workspace_hitlist) {\n+            Ok(packages) => {\n+                for package in packages {\n+                    if let Some(mut target) = extract_target_from_package(&package) {\n+                        targets.append(&mut target);\n+                    }\n+                }\n+                Ok(targets)\n+            }\n+            Err(package) => {\n+                // Mimick cargo of only outputting one <package> spec.\n+                Err(io::Error::new(\n+                    io::ErrorKind::InvalidInput,\n+                    format!(\"package `{}` is not a member of the workspace\", package),\n+                ))\n             }\n         }\n-}\n-\n-fn target_from_json(jtarget: &Value) -> Target {\n-    let jtarget = jtarget.as_object().unwrap();\n-    let path = PathBuf::from(jtarget.get(\"src_path\").unwrap().as_str().unwrap());\n-    let kinds = jtarget.get(\"kind\").unwrap().as_array().unwrap();\n-    let kind = match kinds[0].as_str().unwrap() {\n-        \"bin\" => TargetKind::Bin,\n-        \"lib\" | \"dylib\" | \"staticlib\" | \"cdylib\" | \"rlib\" => TargetKind::Lib,\n-        \"test\" => TargetKind::Test,\n-        \"example\" => TargetKind::Example,\n-        \"bench\" => TargetKind::Bench,\n-        \"custom-build\" => TargetKind::CustomBuild,\n-        \"proc-macro\" => TargetKind::ProcMacro,\n-        _ => TargetKind::Other,\n-    };\n-\n-    Target {\n-        path: path,\n-        kind: kind,\n+    } else {\n+        Err(io::Error::new(\n+            io::ErrorKind::NotFound,\n+            str::from_utf8(&output.stderr).unwrap(),\n+        ))\n     }\n }\n "}]}