{"sha": "a25bbcc27fcbddb005b3025086f87940937b7619", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNWJiY2MyN2ZjYmRkYjAwNWIzMDI1MDg2Zjg3OTQwOTM3Yjc2MTk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-21T17:37:36Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-21T17:37:36Z"}, "message": "Propagate reachability through reexported impls\n\nWhen re-exporting a trait/structure/enum, then we need to propagate the\nreachability of the type through the methods that are defined on it.\n\nCloses #9906\nCloses #9968", "tree": {"sha": "60d1008663a7c2b9d133b378b5b49a53da108c6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60d1008663a7c2b9d133b378b5b49a53da108c6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a25bbcc27fcbddb005b3025086f87940937b7619", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a25bbcc27fcbddb005b3025086f87940937b7619", "html_url": "https://github.com/rust-lang/rust/commit/a25bbcc27fcbddb005b3025086f87940937b7619", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a25bbcc27fcbddb005b3025086f87940937b7619/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebb9b461914347950592f9a2d4e53e324f2f1238", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebb9b461914347950592f9a2d4e53e324f2f1238", "html_url": "https://github.com/rust-lang/rust/commit/ebb9b461914347950592f9a2d4e53e324f2f1238"}], "stats": {"total": 207, "additions": 172, "deletions": 35}, "files": [{"sha": "f65eeee49d510bf9a3c360f0c46d9ec2fefb82c4", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 72, "deletions": 35, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/a25bbcc27fcbddb005b3025086f87940937b7619/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25bbcc27fcbddb005b3025086f87940937b7619/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=a25bbcc27fcbddb005b3025086f87940937b7619", "patch": "@@ -21,36 +21,36 @@ use middle::privacy;\n use middle::resolve;\n \n use std::hashmap::HashSet;\n-use syntax::ast::*;\n+use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{def_id_of_def, is_local};\n+use syntax::ast_util::{def_id_of_def, is_local, local_def};\n use syntax::attr;\n use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n // Returns true if the given set of attributes contains the `#[inline]`\n // attribute.\n-fn attributes_specify_inlining(attrs: &[Attribute]) -> bool {\n+fn attributes_specify_inlining(attrs: &[ast::Attribute]) -> bool {\n     attr::contains_name(attrs, \"inline\")\n }\n \n // Returns true if the given set of generics implies that the item it's\n // associated with must be inlined.\n-fn generics_require_inlining(generics: &Generics) -> bool {\n+fn generics_require_inlining(generics: &ast::Generics) -> bool {\n     !generics.ty_params.is_empty()\n }\n \n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(item: @item) -> bool {\n+fn item_might_be_inlined(item: @ast::item) -> bool {\n     if attributes_specify_inlining(item.attrs) {\n         return true\n     }\n \n     match item.node {\n-        item_fn(_, _, _, ref generics, _) => {\n+        ast::item_fn(_, _, _, ref generics, _) => {\n             generics_require_inlining(generics)\n         }\n         _ => false,\n@@ -59,17 +59,17 @@ fn item_might_be_inlined(item: @item) -> bool {\n \n // Returns true if the given type method must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`.\n-fn ty_method_might_be_inlined(ty_method: &TypeMethod) -> bool {\n+fn ty_method_might_be_inlined(ty_method: &ast::TypeMethod) -> bool {\n     attributes_specify_inlining(ty_method.attrs) ||\n         generics_require_inlining(&ty_method.generics)\n }\n \n // Returns true if the given trait method must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`.\n-fn trait_method_might_be_inlined(trait_method: &trait_method) -> bool {\n+fn trait_method_might_be_inlined(trait_method: &ast::trait_method) -> bool {\n     match *trait_method {\n-        required(ref ty_method) => ty_method_might_be_inlined(ty_method),\n-        provided(_) => true\n+        ast::required(ref ty_method) => ty_method_might_be_inlined(ty_method),\n+        ast::provided(_) => true\n     }\n }\n \n@@ -81,27 +81,27 @@ struct ReachableContext {\n     // methods they've been resolved to.\n     method_map: typeck::method_map,\n     // The set of items which must be exported in the linkage sense.\n-    reachable_symbols: @mut HashSet<NodeId>,\n+    reachable_symbols: @mut HashSet<ast::NodeId>,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n-    worklist: @mut ~[NodeId],\n+    worklist: @mut ~[ast::NodeId],\n     // Known reexports of modules\n     exp_map2: resolve::ExportMap2,\n }\n \n struct MarkSymbolVisitor {\n-    worklist: @mut ~[NodeId],\n+    worklist: @mut ~[ast::NodeId],\n     method_map: typeck::method_map,\n     tcx: ty::ctxt,\n-    reachable_symbols: @mut HashSet<NodeId>,\n+    reachable_symbols: @mut HashSet<ast::NodeId>,\n }\n \n impl Visitor<()> for MarkSymbolVisitor {\n \n-    fn visit_expr(&mut self, expr:@Expr, _:()) {\n+    fn visit_expr(&mut self, expr:@ast::Expr, _:()) {\n \n                 match expr.node {\n-                    ExprPath(_) => {\n+                    ast::ExprPath(_) => {\n                         let def = match self.tcx.def_map.find(&expr.id) {\n                             Some(&def) => def,\n                             None => {\n@@ -118,7 +118,7 @@ impl Visitor<()> for MarkSymbolVisitor {\n                         }\n                         self.reachable_symbols.insert(def_id.node);\n                     }\n-                    ExprMethodCall(*) => {\n+                    ast::ExprMethodCall(*) => {\n                         match self.method_map.find(&expr.id) {\n                             Some(&typeck::method_map_entry {\n                                 origin: typeck::method_static(def_id),\n@@ -162,24 +162,24 @@ impl ReachableContext {\n \n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n-    fn def_id_represents_local_inlined_item(tcx: ty::ctxt, def_id: DefId)\n+    fn def_id_represents_local_inlined_item(tcx: ty::ctxt, def_id: ast::DefId)\n                                             -> bool {\n-        if def_id.crate != LOCAL_CRATE {\n+        if def_id.crate != ast::LOCAL_CRATE {\n             return false\n         }\n \n         let node_id = def_id.node;\n         match tcx.items.find(&node_id) {\n             Some(&ast_map::node_item(item, _)) => {\n                 match item.node {\n-                    item_fn(*) => item_might_be_inlined(item),\n+                    ast::item_fn(*) => item_might_be_inlined(item),\n                     _ => false,\n                 }\n             }\n             Some(&ast_map::node_trait_method(trait_method, _, _)) => {\n                 match *trait_method {\n-                    required(_) => false,\n-                    provided(_) => true,\n+                    ast::required(_) => false,\n+                    ast::provided(_) => true,\n                 }\n             }\n             Some(&ast_map::node_method(method, impl_did, _)) => {\n@@ -189,11 +189,11 @@ impl ReachableContext {\n                 } else {\n                     // Check the impl. If the generics on the self type of the\n                     // impl require inlining, this method does too.\n-                    assert!(impl_did.crate == LOCAL_CRATE);\n+                    assert!(impl_did.crate == ast::LOCAL_CRATE);\n                     match tcx.items.find(&impl_did.node) {\n                         Some(&ast_map::node_item(item, _)) => {\n                             match item.node {\n-                                item_impl(ref generics, _, _, _) => {\n+                                ast::item_impl(ref generics, _, _, _) => {\n                                     generics_require_inlining(generics)\n                                 }\n                                 _ => false\n@@ -231,7 +231,7 @@ impl ReachableContext {\n         }\n     }\n \n-    fn propagate_mod(&self, id: NodeId) {\n+    fn propagate_mod(&self, id: ast::NodeId) {\n         match self.exp_map2.find(&id) {\n             Some(l) => {\n                 for reexport in l.iter() {\n@@ -262,21 +262,58 @@ impl ReachableContext {\n             match self.tcx.items.find(&search_item) {\n                 Some(&ast_map::node_item(item, _)) => {\n                     match item.node {\n-                        item_fn(_, _, _, _, ref search_block) => {\n+                        ast::item_fn(_, _, _, _, ref search_block) => {\n                             visit::walk_block(&mut visitor, search_block, ())\n                         }\n                         // Our recursion into modules involves looking up their\n                         // public reexports and the destinations of those\n                         // exports. Privacy will put them in the worklist, but\n                         // we won't find them in the ast_map, so this is where\n                         // we deal with publicly re-exported items instead.\n-                        item_mod(*) => { self.propagate_mod(item.id); }\n+                        ast::item_mod(*) => self.propagate_mod(item.id),\n+\n+                        // Implementations of exported structs/enums need to get\n+                        // added to the worklist (as all their methods should be\n+                        // accessible)\n+                        ast::item_struct(*) | ast::item_enum(*) => {\n+                            let def = local_def(item.id);\n+                            let impls = match self.tcx.inherent_impls.find(&def) {\n+                                Some(&impls) => impls,\n+                                None => continue\n+                            };\n+                            for imp in impls.iter() {\n+                                if is_local(imp.did) {\n+                                    self.worklist.push(imp.did.node);\n+                                }\n+                            }\n+                        }\n+\n+                        // Propagate through this impl\n+                        ast::item_impl(_, _, _, ref methods) => {\n+                            for method in methods.iter() {\n+                                self.worklist.push(method.id);\n+                            }\n+                        }\n+\n+                        // Default methods of exported traits need to all be\n+                        // accessible.\n+                        ast::item_trait(_, _, ref methods) => {\n+                            for method in methods.iter() {\n+                                match *method {\n+                                    ast::required(*) => {}\n+                                    ast::provided(ref method) => {\n+                                        self.worklist.push(method.id);\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n                         // These are normal, nothing reachable about these\n                         // inherently and their children are already in the\n                         // worklist\n-                        item_struct(*) | item_impl(*) | item_static(*) |\n-                        item_enum(*) | item_ty(*) | item_trait(*) |\n-                        item_foreign_mod(*) => {}\n+                        ast::item_static(*) | ast::item_ty(*) |\n+                            ast::item_foreign_mod(*) => {}\n+\n                         _ => {\n                             self.tcx.sess.span_bug(item.span,\n                                                    \"found non-function item \\\n@@ -286,10 +323,10 @@ impl ReachableContext {\n                 }\n                 Some(&ast_map::node_trait_method(trait_method, _, _)) => {\n                     match *trait_method {\n-                        required(*) => {\n+                        ast::required(*) => {\n                             // Keep going, nothing to get exported\n                         }\n-                        provided(ref method) => {\n+                        ast::provided(ref method) => {\n                             visit::walk_block(&mut visitor, &method.body, ())\n                         }\n                     }\n@@ -310,7 +347,7 @@ impl ReachableContext {\n                                                worklist: {}\",\n                                                desc))\n                 }\n-                None if search_item == CRATE_NODE_ID => {\n+                None if search_item == ast::CRATE_NODE_ID => {\n                     self.propagate_mod(search_item);\n                 }\n                 None => {\n@@ -329,7 +366,7 @@ impl ReachableContext {\n     // reachability, which might result in a compile time loss.\n     fn mark_destructors_reachable(&self) {\n         for (_, destructor_def_id) in self.tcx.destructor_for_type.iter() {\n-            if destructor_def_id.crate == LOCAL_CRATE {\n+            if destructor_def_id.crate == ast::LOCAL_CRATE {\n                 self.reachable_symbols.insert(destructor_def_id.node);\n             }\n         }\n@@ -340,7 +377,7 @@ pub fn find_reachable(tcx: ty::ctxt,\n                       method_map: typeck::method_map,\n                       exp_map2: resolve::ExportMap2,\n                       exported_items: &privacy::ExportedItems)\n-                      -> @mut HashSet<NodeId> {\n+                      -> @mut HashSet<ast::NodeId> {\n     // XXX(pcwalton): We only need to mark symbols that are exported. But this\n     // is more complicated than just looking at whether the symbol is `pub`,\n     // because it might be the target of a `pub use` somewhere. For now, I"}, {"sha": "09ce8f0097ea663003f26715f80b6d30b5c70f05", "filename": "src/test/auxiliary/issue-9906.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a25bbcc27fcbddb005b3025086f87940937b7619/src%2Ftest%2Fauxiliary%2Fissue-9906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25bbcc27fcbddb005b3025086f87940937b7619/src%2Ftest%2Fauxiliary%2Fissue-9906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-9906.rs?ref=a25bbcc27fcbddb005b3025086f87940937b7619", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast windows doesn't like extern mod\n+// aux-build:issue-9906.rs\n+\n+pub use other::FooBar;\n+pub use other::foo;\n+\n+mod other {\n+    pub struct FooBar{value: int}\n+    impl FooBar{\n+        pub fn new(val: int) -> FooBar {\n+            FooBar{value: val}\n+        }\n+    }\n+\n+    pub fn foo(){\n+        1+1;\n+    }\n+}"}, {"sha": "d04d761e112560250daea6293025e02eb8863201", "filename": "src/test/auxiliary/issue-9968.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a25bbcc27fcbddb005b3025086f87940937b7619/src%2Ftest%2Fauxiliary%2Fissue-9968.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25bbcc27fcbddb005b3025086f87940937b7619/src%2Ftest%2Fauxiliary%2Fissue-9968.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-9968.rs?ref=a25bbcc27fcbddb005b3025086f87940937b7619", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use internal::core::{Trait, Struct};\n+\n+mod internal {\n+    pub mod core {\n+        pub struct Struct;\n+        impl Struct {\n+            pub fn init() -> Struct {\n+                Struct\n+            }\n+        }\n+\n+        pub trait Trait {\n+            fn test(&self) {\n+                private();\n+            }\n+        }\n+\n+        impl Trait for Struct {}\n+\n+        fn private() { }\n+    }\n+}"}, {"sha": "287000d2fb1d42d1f42a215281a6eb1db1dd063c", "filename": "src/test/run-pass/issue-9906.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a25bbcc27fcbddb005b3025086f87940937b7619/src%2Ftest%2Frun-pass%2Fissue-9906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25bbcc27fcbddb005b3025086f87940937b7619/src%2Ftest%2Frun-pass%2Fissue-9906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9906.rs?ref=a25bbcc27fcbddb005b3025086f87940937b7619", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast windows doesn't like extern mod\n+// aux-build:issue-9906.rs\n+\n+extern mod testmod(name = \"issue-9906\");\n+\n+fn main() {\n+    testmod::foo();\n+    testmod::FooBar::new(1);\n+}"}, {"sha": "70338bd0f32b4d80e760b70291fc7e16f5c0504c", "filename": "src/test/run-pass/issue-9968.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a25bbcc27fcbddb005b3025086f87940937b7619/src%2Ftest%2Frun-pass%2Fissue-9968.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25bbcc27fcbddb005b3025086f87940937b7619/src%2Ftest%2Frun-pass%2Fissue-9968.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9968.rs?ref=a25bbcc27fcbddb005b3025086f87940937b7619", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast windows doesn't like extern mod\n+// aux-build:issue-9968.rs\n+\n+extern mod lib(name = \"issue-9968\");\n+\n+use lib::{Trait, Struct};\n+\n+fn main()\n+{\n+    Struct::init().test();\n+}"}]}