{"sha": "c865b56744940c8755f4fee6f605d8e7eafc7d3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NjViNTY3NDQ5NDBjODc1NWY0ZmVlNmY2MDVkOGU3ZWFmYzdkM2Q=", "commit": {"author": {"name": "Alexander Gonzalez", "email": "alexfertel97@gmail.com", "date": "2021-07-26T22:15:40Z"}, "committer": {"name": "Alexander Gonzalez", "email": "alexfertel97@gmail.com", "date": "2021-07-26T22:15:40Z"}, "message": "docs: Fix several typos and grammar mistakes", "tree": {"sha": "d11a45b3723ae66c06b9189cbf6d76763f793206", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d11a45b3723ae66c06b9189cbf6d76763f793206"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c865b56744940c8755f4fee6f605d8e7eafc7d3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c865b56744940c8755f4fee6f605d8e7eafc7d3d", "html_url": "https://github.com/rust-lang/rust/commit/c865b56744940c8755f4fee6f605d8e7eafc7d3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c865b56744940c8755f4fee6f605d8e7eafc7d3d/comments", "author": {"login": "alexfertel", "id": 22298999, "node_id": "MDQ6VXNlcjIyMjk4OTk5", "avatar_url": "https://avatars.githubusercontent.com/u/22298999?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexfertel", "html_url": "https://github.com/alexfertel", "followers_url": "https://api.github.com/users/alexfertel/followers", "following_url": "https://api.github.com/users/alexfertel/following{/other_user}", "gists_url": "https://api.github.com/users/alexfertel/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexfertel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexfertel/subscriptions", "organizations_url": "https://api.github.com/users/alexfertel/orgs", "repos_url": "https://api.github.com/users/alexfertel/repos", "events_url": "https://api.github.com/users/alexfertel/events{/privacy}", "received_events_url": "https://api.github.com/users/alexfertel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexfertel", "id": 22298999, "node_id": "MDQ6VXNlcjIyMjk4OTk5", "avatar_url": "https://avatars.githubusercontent.com/u/22298999?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexfertel", "html_url": "https://github.com/alexfertel", "followers_url": "https://api.github.com/users/alexfertel/followers", "following_url": "https://api.github.com/users/alexfertel/following{/other_user}", "gists_url": "https://api.github.com/users/alexfertel/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexfertel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexfertel/subscriptions", "organizations_url": "https://api.github.com/users/alexfertel/orgs", "repos_url": "https://api.github.com/users/alexfertel/repos", "events_url": "https://api.github.com/users/alexfertel/events{/privacy}", "received_events_url": "https://api.github.com/users/alexfertel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a59b56324db99475ea2027cb94f82785b16ad14", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a59b56324db99475ea2027cb94f82785b16ad14", "html_url": "https://github.com/rust-lang/rust/commit/3a59b56324db99475ea2027cb94f82785b16ad14"}], "stats": {"total": 58, "additions": 28, "deletions": 30}, "files": [{"sha": "650fbfc89f36c534e13ebccbf1131c08607ac168", "filename": "docs/dev/guide.md", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c865b56744940c8755f4fee6f605d8e7eafc7d3d/docs%2Fdev%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/c865b56744940c8755f4fee6f605d8e7eafc7d3d/docs%2Fdev%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fguide.md?ref=c865b56744940c8755f4fee6f605d8e7eafc7d3d", "patch": "@@ -79,7 +79,7 @@ group of files which are assumed to rarely change. It's mostly an optimization\n and does not change the fundamental picture.\n \n The `set_crate_graph` method allows us to control how the input files are partitioned\n-into compilation unites -- crates. It also controls (in theory, not implemented\n+into compilation units -- crates. It also controls (in theory, not implemented\n yet) `cfg` flags. `CrateGraph` is a directed acyclic graph of crates. Each crate\n has a root `FileId`, a set of active `cfg` flags and a set of dependencies. Each\n dependency is a pair of a crate and a name. It is possible to have two crates\n@@ -95,7 +95,6 @@ function, and will be inserted into the crate graph just like dependencies.\n Soon we'll talk how we build an LSP server on top of `Analysis`, but first,\n let's deal with that paths issue.\n \n-\n ## Source roots (a.k.a. \"Filesystems are horrible\")\n \n This is a non-essential section, feel free to skip.\n@@ -104,18 +103,18 @@ The previous section said that the filesystem path is an attribute of a file,\n but this is not the whole truth. Making it an absolute `PathBuf` will be bad for\n several reasons. First, filesystems are full of (platform-dependent) edge cases:\n \n-* it's hard (requires a syscall) to decide if two paths are equivalent\n-* some filesystems are case-sensitive (e.g. on macOS)\n-* paths are not necessary UTF-8\n-* symlinks can form cycles\n+* It's hard (requires a syscall) to decide if two paths are equivalent.\n+* Some filesystems are case-sensitive (e.g. macOS).\n+* Paths are not necessarily UTF-8.\n+* Symlinks can form cycles.\n \n-Second, this might hurt reproducibility and hermeticity of builds. In theory,\n+Second, this might hurt the reproducibility and hermeticity of builds. In theory,\n moving a project from `/foo/bar/my-project` to `/spam/eggs/my-project` should\n not change a bit in the output. However, if the absolute path is a part of the\n input, it is at least in theory observable, and *could* affect the output.\n \n Yet another problem is that we really *really* want to avoid doing I/O, but with\n-Rust the set of \"input\" files is not necessary known up-front. In theory, you\n+Rust the set of \"input\" files is not necessarily known up-front. In theory, you\n can have `#[path=\"/dev/random\"] mod foo;`.\n \n To solve (or explicitly refuse to solve) these problems rust-analyzer uses the\n@@ -205,7 +204,7 @@ fact that most of the changes are small, and that analysis results are unlikely\n to change significantly between invocations.\n \n To do this we use [salsa]: a framework for incremental on-demand computation.\n-You can skip the rest of the section if you are familiar with rustc's red-green\n+You can skip the rest of the section if you are familiar with `rustc`'s red-green\n algorithm (which is used for incremental compilation).\n \n [salsa]: https://github.com/salsa-rs/salsa\n@@ -220,12 +219,11 @@ of type `V`. Queries come in two basic varieties:\n   like.\n \n * **Functions**: pure functions (no side effects) that transform your inputs\n-  into other values. The results of queries is memoized to avoid recomputing\n+  into other values. The results of queries are memoized to avoid recomputing\n   them a lot. When you make changes to the inputs, we'll figure out (fairly\n   intelligently) when we can re-use these memoized values and when we have to\n   recompute them.\n \n-\n For further discussion, its important to understand one bit of \"fairly\n intelligently\". Suppose we have two functions, `f1` and `f2`, and one input,\n `z`. We call `f1(X)` which in turn calls `f2(Y)` which inspects `i(Z)`. `i(Z)`\n@@ -267,13 +265,13 @@ The bulk of the rust-analyzer is transforming input text into a semantic model o\n Rust code: a web of entities like modules, structs, functions and traits.\n \n An important fact to realize is that (unlike most other languages like C# or\n-Java) there isn't a one-to-one mapping between source code and the semantic model. A\n+Java) there is not a one-to-one mapping between the source code and the semantic model. A\n single function definition in the source code might result in several semantic\n-functions: for example, the same source file might be included as a module into\n-several crate, or a single \"crate\" might be present in the compilation DAG\n+functions: for example, the same source file might get included as a module in\n+several crates or a single crate might be present in the compilation DAG\n several times, with different sets of `cfg`s enabled. The IDE-specific task of\n-mapping source code position into a semantic model is inherently imprecise for\n-this reason, and is handled by the [`source_binder`].\n+mapping source code into a semantic model is inherently imprecise for\n+this reason and gets handled by the [`source_binder`].\n \n [`source_binder`]: https://github.com/rust-analyzer/rust-analyzer/blob/guide-2019-01/crates/hir/src/source_binder.rs\n \n@@ -533,18 +531,18 @@ To conclude the overview of the rust-analyzer, let's trace the request for\n \n We start by [receiving a message] from the language client. We decode the\n message as a request for completion and [schedule it on the threadpool]. This is\n-the also place where we [catch] canceled errors if, immediately after completion, the\n+the place where we [catch] canceled errors if, immediately after completion, the\n client sends some modification.\n \n-In [the handler] we a deserialize LSP request into the rust-analyzer specific data\n+In [the handler], we deserialize LSP requests into rust-analyzer specific data\n types (by converting a file url into a numeric `FileId`), [ask analysis for\n-completion] and serializer results to LSP.\n+completion] and serialize results into the LSP.\n \n The [completion implementation] is finally the place where we start doing the actual\n work. The first step is to collect the `CompletionContext` -- a struct which\n describes the cursor position in terms of Rust syntax and semantics. For\n example, `function_syntax: Option<&'a ast::FnDef>` stores a reference to\n-enclosing function *syntax*, while `function: Option<hir::Function>` is the\n+the enclosing function *syntax*, while `function: Option<hir::Function>` is the\n `Def` for this function.\n \n To construct the context, we first do an [\"IntelliJ Trick\"]: we insert a dummy"}, {"sha": "b73a74876376a4eca277d56071dc79b2b8066d68", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c865b56744940c8755f4fee6f605d8e7eafc7d3d/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/c865b56744940c8755f4fee6f605d8e7eafc7d3d/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=c865b56744940c8755f4fee6f605d8e7eafc7d3d", "patch": "@@ -656,7 +656,7 @@ interface TestInfo {\n }\n ```\n \n-## Hover Actions\n+## Move Item\n \n **Issue:** https://github.com/rust-analyzer/rust-analyzer/issues/6823\n "}, {"sha": "6309fd02ce4163b7b46b2ad4b607fd31c7b78392", "filename": "docs/dev/style.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c865b56744940c8755f4fee6f605d8e7eafc7d3d/docs%2Fdev%2Fstyle.md", "raw_url": "https://github.com/rust-lang/rust/raw/c865b56744940c8755f4fee6f605d8e7eafc7d3d/docs%2Fdev%2Fstyle.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fstyle.md?ref=c865b56744940c8755f4fee6f605d8e7eafc7d3d", "patch": "@@ -170,7 +170,7 @@ More than one mark per test / code branch doesn't add significantly to understan\n Do not use `#[should_panic]` tests.\n Instead, explicitly check for `None`, `Err`, etc.\n \n-**Rationale:** `#[should_panic]` is a tool for library authors, to makes sure that API does not fail silently, when misused.\n+**Rationale:** `#[should_panic]` is a tool for library authors to make sure that the API does not fail silently when misused.\n `rust-analyzer` is not a library, we don't need to test for API misuse, and we have to handle any user input without panics.\n Panic messages in the logs from the `#[should_panic]` tests are confusing.\n \n@@ -333,7 +333,7 @@ impl Foo {\n }\n ```\n \n-Prefer `Default` even it has to be implemented manually.\n+Prefer `Default` even if it has to be implemented manually.\n \n **Rationale:** less typing in the common case, uniformity.\n \n@@ -343,7 +343,7 @@ Use `Vec::new` rather than `vec![]`.\n \n Avoid using \"dummy\" states to implement a `Default`.\n If a type doesn't have a sensible default, empty value, don't hide it.\n-Let the caller explicitly decide what's the right initial state is.\n+Let the caller explicitly decide what the right initial state is.\n \n ## Functions Over Objects\n \n@@ -526,7 +526,7 @@ if words.len() != 2 {\n }\n ```\n \n-**Rationale:** not allocating is almost often faster.\n+**Rationale:** not allocating is almost always faster.\n \n ## Push Allocations to the Call Site\n \n@@ -998,9 +998,9 @@ match output.status.code() {\n };\n ```\n \n-**Rationale:** like blocks, single-use variables are a cognitively cheap abstraction, as they have access to all the context.\n+**Rationale:** Like blocks, single-use variables are a cognitively cheap abstraction, as they have access to all the context.\n Extra variables help during debugging, they make it easy to print/view important intermediate results.\n-Giving a name to a condition in `if` expression often improves clarity and leads to a nicer formatted code.\n+Giving a name to a condition inside an `if` expression often improves clarity and leads to nicely formatted code.\n \n ## Token names\n "}, {"sha": "5a065e00ef6b692c431e7ec8a03d1c877c52666d", "filename": "docs/dev/syntax.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c865b56744940c8755f4fee6f605d8e7eafc7d3d/docs%2Fdev%2Fsyntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/c865b56744940c8755f4fee6f605d8e7eafc7d3d/docs%2Fdev%2Fsyntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fsyntax.md?ref=c865b56744940c8755f4fee6f605d8e7eafc7d3d", "patch": "@@ -6,7 +6,7 @@ This guide describes the current state of syntax trees and parsing in rust-analy\n \n ## Source Code\n \n-The things described are implemented in two places\n+The things described are implemented in three places\n \n * [rowan](https://github.com/rust-analyzer/rowan/tree/v0.9.0) -- a generic library for rowan syntax trees.\n * [ra_syntax](https://github.com/rust-analyzer/rust-analyzer/tree/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_syntax) crate inside rust-analyzer which wraps `rowan` into rust-analyzer specific API.\n@@ -15,9 +15,9 @@ The things described are implemented in two places\n \n ## Design Goals\n \n-* Syntax trees are lossless, or full fidelity. All comments and whitespace are preserved.\n+* Syntax trees are lossless, or full fidelity. All comments and whitespace get preserved.\n * Syntax trees are semantic-less. They describe *strictly* the structure of a sequence of characters, they don't have hygiene, name resolution or type information attached.\n-* Syntax trees are simple value type. It is possible to create trees for a syntax without any external context.\n+* Syntax trees are simple value types. It is possible to create trees for a syntax without any external context.\n * Syntax trees have intuitive traversal API (parent, children, siblings, etc).\n * Parsing is lossless (even if the input is invalid, the tree produced by the parser represents it exactly).\n * Parsing is resilient (even if the input is invalid, parser tries to see as much syntax tree fragments in the input as it can)."}]}