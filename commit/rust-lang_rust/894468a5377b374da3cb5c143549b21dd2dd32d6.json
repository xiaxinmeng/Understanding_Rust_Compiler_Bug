{"sha": "894468a5377b374da3cb5c143549b21dd2dd32d6", "node_id": "C_kwDOAAsO6NoAKDg5NDQ2OGE1Mzc3YjM3NGRhM2NiNWMxNDM1NDliMjFkZDJkZDMyZDY", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-11-22T02:05:56Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-11-22T03:15:12Z"}, "message": "Move stack slot allocation to a new fn", "tree": {"sha": "79f24b50f1de1b27e834e5192378104699141850", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79f24b50f1de1b27e834e5192378104699141850"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/894468a5377b374da3cb5c143549b21dd2dd32d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/894468a5377b374da3cb5c143549b21dd2dd32d6", "html_url": "https://github.com/rust-lang/rust/commit/894468a5377b374da3cb5c143549b21dd2dd32d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/894468a5377b374da3cb5c143549b21dd2dd32d6/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f16d27aca48454fc3a05a477b20ba5264a740b14", "url": "https://api.github.com/repos/rust-lang/rust/commits/f16d27aca48454fc3a05a477b20ba5264a740b14", "html_url": "https://github.com/rust-lang/rust/commit/f16d27aca48454fc3a05a477b20ba5264a740b14"}], "stats": {"total": 93, "additions": 70, "deletions": 23}, "files": [{"sha": "dde776d8e51d0bb396faf83455b4760775384ec8", "filename": "src/inline_asm.rs", "status": "modified", "additions": 70, "deletions": 23, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/894468a5377b374da3cb5c143549b21dd2dd32d6/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/894468a5377b374da3cb5c143549b21dd2dd32d6/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=894468a5377b374da3cb5c143549b21dd2dd32d6", "patch": "@@ -103,70 +103,60 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         crate::trap::trap_unimplemented(fx, \"Alloca is not supported\");\n     }\n \n-    let mut slot_size = Size::from_bytes(0);\n     let mut clobbered_regs = Vec::new();\n     let mut inputs = Vec::new();\n     let mut outputs = Vec::new();\n \n-    let mut new_slot = |reg_class: InlineAsmRegClass| {\n-        let reg_size = reg_class\n-            .supported_types(InlineAsmArch::X86_64)\n-            .iter()\n-            .map(|(ty, _)| ty.size())\n-            .max()\n-            .unwrap();\n-        let align = rustc_target::abi::Align::from_bytes(reg_size.bytes()).unwrap();\n-        slot_size = slot_size.align_to(align);\n-        let offset = slot_size;\n-        slot_size += reg_size;\n-        offset\n-    };\n-\n     let mut asm_gen = InlineAssemblyGenerator {\n         tcx: fx.tcx,\n         arch: InlineAsmArch::X86_64,\n         template,\n         operands,\n         options,\n         registers: Vec::new(),\n+        stack_slots_clobber: Vec::new(),\n+        stack_slots_input: Vec::new(),\n+        stack_slots_output: Vec::new(),\n+        stack_slot_size: Size::from_bytes(0),\n     };\n     asm_gen.allocate_registers();\n+    asm_gen.allocate_stack_slots();\n \n     // FIXME overlap input and output slots to save stack space\n     for (i, operand) in operands.iter().enumerate() {\n         match *operand {\n             InlineAsmOperand::In { reg, ref value } => {\n                 let reg = asm_gen.registers[i].unwrap();\n-                clobbered_regs.push((reg, new_slot(reg.reg_class())));\n+                clobbered_regs.push((reg, asm_gen.stack_slots_clobber[i].unwrap()));\n                 inputs.push((\n                     reg,\n-                    new_slot(reg.reg_class()),\n+                    asm_gen.stack_slots_input[i].unwrap(),\n                     crate::base::codegen_operand(fx, value).load_scalar(fx),\n                 ));\n             }\n             InlineAsmOperand::Out { reg, late: _, place } => {\n                 let reg = asm_gen.registers[i].unwrap();\n-                clobbered_regs.push((reg, new_slot(reg.reg_class())));\n+                clobbered_regs.push((reg, asm_gen.stack_slots_clobber[i].unwrap()));\n                 if let Some(place) = place {\n                     outputs.push((\n                         reg,\n-                        new_slot(reg.reg_class()),\n+                        asm_gen.stack_slots_output[i].unwrap(),\n                         crate::base::codegen_place(fx, place),\n                     ));\n                 }\n             }\n             InlineAsmOperand::InOut { reg, late: _, ref in_value, out_place } => {\n                 let reg = asm_gen.registers[i].unwrap();\n-                clobbered_regs.push((reg, new_slot(reg.reg_class())));\n+                clobbered_regs.push((reg, asm_gen.stack_slots_clobber[i].unwrap()));\n                 inputs.push((\n                     reg,\n-                    new_slot(reg.reg_class()),\n+                    asm_gen.stack_slots_input[i].unwrap(),\n                     crate::base::codegen_operand(fx, in_value).load_scalar(fx),\n                 ));\n                 if let Some(out_place) = out_place {\n                     outputs.push((\n                         reg,\n-                        new_slot(reg.reg_class()),\n+                        asm_gen.stack_slots_output[i].unwrap(),\n                         crate::base::codegen_place(fx, out_place),\n                     ));\n                 }\n@@ -184,7 +174,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n     let generated_asm = asm_gen.generate_asm_wrapper(&asm_name, clobbered_regs, &inputs, &outputs);\n     fx.cx.global_asm.push_str(&generated_asm);\n \n-    call_inline_asm(fx, &asm_name, slot_size, inputs, outputs);\n+    call_inline_asm(fx, &asm_name, asm_gen.stack_slot_size, inputs, outputs);\n }\n \n struct InlineAssemblyGenerator<'a, 'tcx> {\n@@ -194,6 +184,10 @@ struct InlineAssemblyGenerator<'a, 'tcx> {\n     operands: &'a [InlineAsmOperand<'tcx>],\n     options: InlineAsmOptions,\n     registers: Vec<Option<InlineAsmReg>>,\n+    stack_slots_clobber: Vec<Option<Size>>,\n+    stack_slots_input: Vec<Option<Size>>,\n+    stack_slots_output: Vec<Option<Size>>,\n+    stack_slot_size: Size,\n }\n \n impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n@@ -317,6 +311,59 @@ impl<'tcx> InlineAssemblyGenerator<'_, 'tcx> {\n         self.registers = regs;\n     }\n \n+    fn allocate_stack_slots(&mut self) {\n+        let mut slot_size = Size::from_bytes(0);\n+        let mut slots_clobber = vec![None; self.operands.len()];\n+        let mut slots_input = vec![None; self.operands.len()];\n+        let mut slots_output = vec![None; self.operands.len()];\n+\n+        let mut new_slot = |reg_class: InlineAsmRegClass| {\n+            let reg_size = reg_class\n+                .supported_types(InlineAsmArch::X86_64)\n+                .iter()\n+                .map(|(ty, _)| ty.size())\n+                .max()\n+                .unwrap();\n+            let align = rustc_target::abi::Align::from_bytes(reg_size.bytes()).unwrap();\n+            slot_size = slot_size.align_to(align);\n+            let offset = slot_size;\n+            slot_size += reg_size;\n+            offset\n+        };\n+\n+        // FIXME overlap input and output slots to save stack space\n+        for (i, operand) in self.operands.iter().enumerate() {\n+            match *operand {\n+                InlineAsmOperand::In { reg, .. } => {\n+                    slots_clobber[i] = Some(new_slot(reg.reg_class()));\n+                    slots_input[i] = Some(new_slot(reg.reg_class()));\n+                }\n+                InlineAsmOperand::Out { reg, place, .. } => {\n+                    slots_clobber[i] = Some(new_slot(reg.reg_class()));\n+                    if place.is_some() {\n+                        slots_output[i] = Some(new_slot(reg.reg_class()));\n+                    }\n+                }\n+                InlineAsmOperand::InOut { reg, out_place, .. } => {\n+                    slots_clobber[i] = Some(new_slot(reg.reg_class()));\n+                    let slot = new_slot(reg.reg_class());\n+                    slots_input[i] = Some(slot);\n+                    if out_place.is_some() {\n+                        slots_output[i] = Some(slot);\n+                    }\n+                }\n+                InlineAsmOperand::Const { value: _ } => (),\n+                InlineAsmOperand::SymFn { value: _ } => (),\n+                InlineAsmOperand::SymStatic { def_id: _ } => (),\n+            }\n+        }\n+\n+        self.stack_slots_clobber = slots_clobber;\n+        self.stack_slots_input = slots_input;\n+        self.stack_slots_output = slots_output;\n+        self.stack_slot_size = slot_size;\n+    }\n+\n     fn generate_asm_wrapper(\n         &self,\n         asm_name: &str,"}]}