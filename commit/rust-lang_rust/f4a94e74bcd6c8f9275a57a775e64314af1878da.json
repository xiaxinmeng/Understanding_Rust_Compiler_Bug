{"sha": "f4a94e74bcd6c8f9275a57a775e64314af1878da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YTk0ZTc0YmNkNmM4ZjkyNzVhNTdhNzc1ZTY0MzE0YWYxODc4ZGE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-13T07:49:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-04-13T07:49:01Z"}, "message": "fold ScopeWithSyntax into SourceAnalyzer", "tree": {"sha": "d10b8da727d6b581a78d79e660fe05218e5b80d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d10b8da727d6b581a78d79e660fe05218e5b80d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4a94e74bcd6c8f9275a57a775e64314af1878da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4a94e74bcd6c8f9275a57a775e64314af1878da", "html_url": "https://github.com/rust-lang/rust/commit/f4a94e74bcd6c8f9275a57a775e64314af1878da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4a94e74bcd6c8f9275a57a775e64314af1878da/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30481808fbfea109f324dfaf93daaaebacc75333", "url": "https://api.github.com/repos/rust-lang/rust/commits/30481808fbfea109f324dfaf93daaaebacc75333", "html_url": "https://github.com/rust-lang/rust/commit/30481808fbfea109f324dfaf93daaaebacc75333"}], "stats": {"total": 352, "additions": 159, "deletions": 193}, "files": [{"sha": "e0479ef1307fce7a8d8cedc057d79fbacb579674", "filename": "crates/ra_assists/src/inline_local_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a94e74bcd6c8f9275a57a775e64314af1878da/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a94e74bcd6c8f9275a57a775e64314af1878da/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Finline_local_variable.rs?ref=f4a94e74bcd6c8f9275a57a775e64314af1878da", "patch": "@@ -27,7 +27,7 @@ pub(crate) fn inline_local_varialbe(mut ctx: AssistCtx<impl HirDatabase>) -> Opt\n         let_stmt.syntax().range()\n     };\n     let analyzer = hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, bind_pat.syntax(), None);\n-    let refs = analyzer.find_all_refs(bind_pat)?;\n+    let refs = analyzer.find_all_refs(bind_pat);\n \n     let mut wrap_in_parens = vec![true; refs.len()];\n "}, {"sha": "882208ec1f036b871f47694aa9ecbad26713750a", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f4a94e74bcd6c8f9275a57a775e64314af1878da/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a94e74bcd6c8f9275a57a775e64314af1878da/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=f4a94e74bcd6c8f9275a57a775e64314af1878da", "patch": "@@ -4,7 +4,7 @@ use ra_db::{CrateId, SourceRootId, Edition};\n use ra_syntax::{ast::self, TreeArc};\n \n use crate::{\n-    Name, ScopesWithSourceMap, Ty, HirFileId, Either,\n+    Name, Ty, HirFileId, Either,\n     HirDatabase, DefDatabase,\n     type_ref::TypeRef,\n     nameres::{ModuleScope, Namespace, ImportId, CrateModuleId},\n@@ -466,12 +466,6 @@ impl DefWithBody {\n             DefWithBody::Static(ref s) => s.resolver(db),\n         }\n     }\n-\n-    pub fn scopes(&self, db: &impl HirDatabase) -> ScopesWithSourceMap {\n-        let scopes = db.expr_scopes(*self);\n-        let source_map = db.body_with_source_map(*self).1;\n-        ScopesWithSourceMap { scopes, source_map }\n-    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -535,12 +529,6 @@ impl Function {\n         db.type_for_def((*self).into(), Namespace::Values)\n     }\n \n-    pub fn scopes(&self, db: &impl HirDatabase) -> ScopesWithSourceMap {\n-        let scopes = db.expr_scopes((*self).into());\n-        let source_map = db.body_with_source_map((*self).into()).1;\n-        ScopesWithSourceMap { scopes, source_map }\n-    }\n-\n     pub fn signature(&self, db: &impl HirDatabase) -> Arc<FnSignature> {\n         db.fn_signature(*self)\n     }"}, {"sha": "038a25a9717cad90534c8e480995891bb8d59d64", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4a94e74bcd6c8f9275a57a775e64314af1878da/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a94e74bcd6c8f9275a57a775e64314af1878da/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=f4a94e74bcd6c8f9275a57a775e64314af1878da", "patch": "@@ -16,7 +16,7 @@ use crate::{\n };\n use crate::{ path::GenericArgs, ty::primitive::{IntTy, UncertainIntTy, FloatTy, UncertainFloatTy}};\n \n-pub use self::scope::{ExprScopes, ScopesWithSourceMap, ScopeEntryWithSyntax};\n+pub use self::scope::{ExprScopes, ScopeEntryWithSyntax};\n \n pub(crate) mod scope;\n \n@@ -93,7 +93,7 @@ pub fn resolver_for_scope(\n ) -> Resolver {\n     let mut r = body.owner.resolver(db);\n     let scopes = db.expr_scopes(body.owner);\n-    let scope_chain = scopes.scope_chain_for(scope_id).collect::<Vec<_>>();\n+    let scope_chain = scopes.scope_chain(scope_id).collect::<Vec<_>>();\n     for scope in scope_chain.into_iter().rev() {\n         r = r.push_expr_scope(Arc::clone(&scopes), scope);\n     }"}, {"sha": "476385a2fc78a4d381fccb2b1169214004a75f28", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 28, "deletions": 138, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/f4a94e74bcd6c8f9275a57a775e64314af1878da/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a94e74bcd6c8f9275a57a775e64314af1878da/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=f4a94e74bcd6c8f9275a57a775e64314af1878da", "patch": "@@ -1,17 +1,16 @@\n use std::sync::Arc;\n \n-use rustc_hash::{FxHashMap, FxHashSet};\n-\n+use rustc_hash::{FxHashMap};\n use ra_syntax::{\n-    AstNode, SyntaxNode, TextUnit, TextRange, SyntaxNodePtr, AstPtr,\n+    TextRange, AstPtr,\n     algo::generate,\n     ast,\n };\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n use crate::{\n-    Name, AsName,DefWithBody, Either,\n-    expr::{PatId, ExprId, Pat, Expr, Body, Statement, BodySourceMap},\n+    Name, DefWithBody, Either,\n+    expr::{PatId, ExprId, Pat, Expr, Body, Statement},\n     HirDatabase,\n };\n \n@@ -23,7 +22,7 @@ impl_arena_id!(ScopeId);\n pub struct ExprScopes {\n     body: Arc<Body>,\n     scopes: Arena<ScopeId, ScopeData>,\n-    scope_for: FxHashMap<ExprId, ScopeId>,\n+    pub(crate) scope_for: FxHashMap<ExprId, ScopeId>,\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -66,10 +65,7 @@ impl ExprScopes {\n         &self.scopes[scope].entries\n     }\n \n-    pub fn scope_chain_for<'a>(\n-        &'a self,\n-        scope: Option<ScopeId>,\n-    ) -> impl Iterator<Item = ScopeId> + 'a {\n+    pub fn scope_chain<'a>(&'a self, scope: Option<ScopeId>) -> impl Iterator<Item = ScopeId> + 'a {\n         generate(scope, move |&scope| self.scopes[scope].parent)\n     }\n \n@@ -107,16 +103,10 @@ impl ExprScopes {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ScopesWithSourceMap {\n-    pub(crate) source_map: Arc<BodySourceMap>,\n-    pub(crate) scopes: Arc<ExprScopes>,\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ScopeEntryWithSyntax {\n-    name: Name,\n-    ptr: Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>,\n+    pub(crate) name: Name,\n+    pub(crate) ptr: Either<AstPtr<ast::Pat>, AstPtr<ast::SelfParam>>,\n }\n \n impl ScopeEntryWithSyntax {\n@@ -129,96 +119,6 @@ impl ScopeEntryWithSyntax {\n     }\n }\n \n-impl ScopesWithSourceMap {\n-    fn scope_chain<'a>(&'a self, node: &SyntaxNode) -> impl Iterator<Item = ScopeId> + 'a {\n-        generate(self.scope_for(node), move |&scope| self.scopes.scopes[scope].parent)\n-    }\n-\n-    pub(crate) fn scope_for_offset(&self, offset: TextUnit) -> Option<ScopeId> {\n-        self.scopes\n-            .scope_for\n-            .iter()\n-            .filter_map(|(id, scope)| Some((self.source_map.expr_syntax(*id)?, scope)))\n-            // find containing scope\n-            .min_by_key(|(ptr, _scope)| {\n-                (!(ptr.range().start() <= offset && offset <= ptr.range().end()), ptr.range().len())\n-            })\n-            .map(|(ptr, scope)| self.adjust(ptr, *scope, offset))\n-    }\n-\n-    // XXX: during completion, cursor might be outside of any particular\n-    // expression. Try to figure out the correct scope...\n-    // FIXME: move this to source binder?\n-    fn adjust(&self, ptr: SyntaxNodePtr, original_scope: ScopeId, offset: TextUnit) -> ScopeId {\n-        let r = ptr.range();\n-        let child_scopes = self\n-            .scopes\n-            .scope_for\n-            .iter()\n-            .filter_map(|(id, scope)| Some((self.source_map.expr_syntax(*id)?, scope)))\n-            .map(|(ptr, scope)| (ptr.range(), scope))\n-            .filter(|(range, _)| range.start() <= offset && range.is_subrange(&r) && *range != r);\n-\n-        child_scopes\n-            .max_by(|(r1, _), (r2, _)| {\n-                if r2.is_subrange(&r1) {\n-                    std::cmp::Ordering::Greater\n-                } else if r1.is_subrange(&r2) {\n-                    std::cmp::Ordering::Less\n-                } else {\n-                    r1.start().cmp(&r2.start())\n-                }\n-            })\n-            .map(|(_ptr, scope)| *scope)\n-            .unwrap_or(original_scope)\n-    }\n-\n-    pub(crate) fn resolve_local_name(\n-        &self,\n-        name_ref: &ast::NameRef,\n-    ) -> Option<ScopeEntryWithSyntax> {\n-        let mut shadowed = FxHashSet::default();\n-        let name = name_ref.as_name();\n-        let ret = self\n-            .scope_chain(name_ref.syntax())\n-            .flat_map(|scope| self.scopes.entries(scope).iter())\n-            .filter(|entry| shadowed.insert(entry.name()))\n-            .filter(|entry| entry.name() == &name)\n-            .nth(0);\n-        ret.and_then(|entry| {\n-            Some(ScopeEntryWithSyntax {\n-                name: entry.name().clone(),\n-                ptr: self.source_map.pat_syntax(entry.pat())?,\n-            })\n-        })\n-    }\n-\n-    pub(crate) fn find_all_refs(&self, pat: &ast::BindPat) -> Vec<ReferenceDescriptor> {\n-        let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n-        let ptr = Either::A(AstPtr::new(pat.into()));\n-        fn_def\n-            .syntax()\n-            .descendants()\n-            .filter_map(ast::NameRef::cast)\n-            .filter(|name_ref| match self.resolve_local_name(*name_ref) {\n-                None => false,\n-                Some(entry) => entry.ptr() == ptr,\n-            })\n-            .map(|name_ref| ReferenceDescriptor {\n-                name: name_ref.syntax().text().to_string(),\n-                range: name_ref.syntax().range(),\n-            })\n-            .collect()\n-    }\n-\n-    pub(crate) fn scope_for(&self, node: &SyntaxNode) -> Option<ScopeId> {\n-        node.ancestors()\n-            .map(SyntaxNodePtr::new)\n-            .filter_map(|ptr| self.source_map.syntax_expr(ptr))\n-            .find_map(|it| self.scopes.scope_for(it))\n-    }\n-}\n-\n impl ScopeEntry {\n     pub fn name(&self) -> &Name {\n         &self.name\n@@ -297,12 +197,11 @@ pub struct ReferenceDescriptor {\n \n #[cfg(test)]\n mod tests {\n-    use ra_db::salsa::InternKey;\n-    use ra_syntax::{SourceFile, algo::find_node_at_offset};\n+    use ra_db::SourceDatabase;\n+    use ra_syntax::{algo::find_node_at_offset, AstNode, SyntaxNodePtr};\n     use test_utils::{extract_offset, assert_eq_text};\n-    use crate::Function;\n \n-    use crate::expr::{ExprCollector};\n+    use crate::{source_binder::SourceAnalyzer, mock::MockDatabase};\n \n     use super::*;\n \n@@ -316,18 +215,20 @@ mod tests {\n             buf.push_str(&code[off..]);\n             buf\n         };\n-        let file = SourceFile::parse(&code);\n+\n+        let (db, _source_root, file_id) = MockDatabase::with_single_file(&code);\n+        let file = db.parse(file_id);\n         let marker: &ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n-        let fn_def: &ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let irrelevant_function =\n-            Function { id: crate::ids::FunctionId::from_intern_id(0u32.into()) };\n-        let (body, source_map) = collect_fn_body_syntax(irrelevant_function, fn_def);\n-        let scopes = ExprScopes::new(Arc::new(body));\n-        let scopes =\n-            ScopesWithSourceMap { scopes: Arc::new(scopes), source_map: Arc::new(source_map) };\n+        let analyzer = SourceAnalyzer::new(&db, file_id, marker.syntax(), None);\n+\n+        let scopes = analyzer.scopes();\n+        let expr_id =\n+            analyzer.body_source_map().syntax_expr(SyntaxNodePtr::new(marker.syntax())).unwrap();\n+        let scope = scopes.scope_for(expr_id);\n+\n         let actual = scopes\n-            .scope_chain(marker.syntax())\n-            .flat_map(|scope| scopes.scopes.entries(scope))\n+            .scope_chain(scope)\n+            .flat_map(|scope| scopes.entries(scope))\n             .map(|it| it.name().to_string())\n             .collect::<Vec<_>>()\n             .join(\"\\n\");\n@@ -410,28 +311,17 @@ mod tests {\n         );\n     }\n \n-    fn collect_fn_body_syntax(function: Function, node: &ast::FnDef) -> (Body, BodySourceMap) {\n-        let mut collector = ExprCollector::new(DefWithBody::Function(function));\n-        collector.collect_fn_body(node);\n-        collector.finish()\n-    }\n-\n     fn do_check_local_name(code: &str, expected_offset: u32) {\n         let (off, code) = extract_offset(code);\n-        let file = SourceFile::parse(&code);\n+\n+        let (db, _source_root, file_id) = MockDatabase::with_single_file(&code);\n+        let file = db.parse(file_id);\n         let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into())\n             .expect(\"failed to find a name at the target offset\");\n-\n-        let fn_def: &ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n         let name_ref: &ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n+        let analyzer = SourceAnalyzer::new(&db, file_id, name_ref.syntax(), None);\n \n-        let irrelevant_function =\n-            Function { id: crate::ids::FunctionId::from_intern_id(0u32.into()) };\n-        let (body, source_map) = collect_fn_body_syntax(irrelevant_function, fn_def);\n-        let scopes = ExprScopes::new(Arc::new(body));\n-        let scopes =\n-            ScopesWithSourceMap { scopes: Arc::new(scopes), source_map: Arc::new(source_map) };\n-        let local_name_entry = scopes.resolve_local_name(name_ref).unwrap();\n+        let local_name_entry = analyzer.resolve_local_name(name_ref).unwrap();\n         let local_name =\n             local_name_entry.ptr().either(|it| it.syntax_node_ptr(), |it| it.syntax_node_ptr());\n         assert_eq!(local_name.range(), expected_name.syntax().range());"}, {"sha": "eb2aa0e6c1433dd772e85af96184998b40a116b4", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a94e74bcd6c8f9275a57a775e64314af1878da/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a94e74bcd6c8f9275a57a775e64314af1878da/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=f4a94e74bcd6c8f9275a57a775e64314af1878da", "patch": "@@ -64,7 +64,7 @@ pub use self::{\n     impl_block::{ImplBlock, ImplItem},\n     docs::{Docs, Documentation},\n     adt::AdtDef,\n-    expr::{ExprScopes, ScopesWithSourceMap, ScopeEntryWithSyntax},\n+    expr::{ExprScopes, ScopeEntryWithSyntax},\n     resolve::{Resolver, Resolution},\n     source_binder::{SourceAnalyzer, PathResolution},\n };"}, {"sha": "d87f8ff34a942c026fc6d5b0bd75d39d631185f8", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 125, "deletions": 37, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/f4a94e74bcd6c8f9275a57a775e64314af1878da/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a94e74bcd6c8f9275a57a775e64314af1878da/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=f4a94e74bcd6c8f9275a57a775e64314af1878da", "patch": "@@ -7,9 +7,10 @@\n /// purely for \"IDE needs\".\n use std::sync::Arc;\n \n+use rustc_hash::FxHashSet;\n use ra_db::{FileId, FilePosition};\n use ra_syntax::{\n-    SyntaxNode, AstPtr, TextUnit,\n+    SyntaxNode, AstPtr, TextUnit, SyntaxNodePtr,\n     ast::{self, AstNode, NameOwner},\n     algo::find_node_at_offset,\n     SyntaxKind::*,\n@@ -18,7 +19,7 @@ use ra_syntax::{\n use crate::{\n     HirDatabase, Function, Struct, Enum, Const, Static, Either, DefWithBody,\n     AsName, Module, HirFileId, Crate, Trait, Resolver,\n-    expr::scope::{ReferenceDescriptor, ScopeEntryWithSyntax},\n+    expr::{BodySourceMap, scope::{ReferenceDescriptor, ScopeEntryWithSyntax, ScopeId, ExprScopes}},\n     ids::LocationCtx,\n     expr, AstId\n };\n@@ -120,29 +121,6 @@ pub fn trait_from_module(\n     Trait { id: ctx.to_def(trait_def) }\n }\n \n-fn resolver_for_node(\n-    db: &impl HirDatabase,\n-    file_id: FileId,\n-    node: &SyntaxNode,\n-    offset: Option<TextUnit>,\n-) -> Resolver {\n-    node.ancestors()\n-        .find_map(|node| {\n-            if ast::Expr::cast(node).is_some() || ast::Block::cast(node).is_some() {\n-                let def = def_with_body_from_child_node(db, file_id, node)?;\n-                let scopes = def.scopes(db);\n-                let scope = match offset {\n-                    None => scopes.scope_for(&node),\n-                    Some(offset) => scopes.scope_for_offset(offset),\n-                };\n-                Some(expr::resolver_for_scope(def.body(db), db, scope))\n-            } else {\n-                try_get_resolver_for_node(db, file_id, node)\n-            }\n-        })\n-        .unwrap_or_default()\n-}\n-\n fn try_get_resolver_for_node(\n     db: &impl HirDatabase,\n     file_id: FileId,\n@@ -192,9 +170,9 @@ fn def_with_body_from_child_node(\n #[derive(Debug)]\n pub struct SourceAnalyzer {\n     resolver: Resolver,\n-    body_source_map: Option<Arc<crate::expr::BodySourceMap>>,\n+    body_source_map: Option<Arc<BodySourceMap>>,\n     infer: Option<Arc<crate::ty::InferenceResult>>,\n-    scopes: Option<crate::expr::ScopesWithSourceMap>,\n+    scopes: Option<Arc<crate::expr::ExprScopes>>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -217,11 +195,30 @@ impl SourceAnalyzer {\n         offset: Option<TextUnit>,\n     ) -> SourceAnalyzer {\n         let def_with_body = def_with_body_from_child_node(db, file_id, node);\n-        SourceAnalyzer {\n-            resolver: resolver_for_node(db, file_id, node, offset),\n-            body_source_map: def_with_body.map(|it| it.body_source_map(db)),\n-            infer: def_with_body.map(|it| it.infer(db)),\n-            scopes: def_with_body.map(|it| it.scopes(db)),\n+        if let Some(def) = def_with_body {\n+            let source_map = def.body_source_map(db);\n+            let scopes = db.expr_scopes(def);\n+            let scope = match offset {\n+                None => scope_for(&scopes, &source_map, &node),\n+                Some(offset) => scope_for_offset(&scopes, &source_map, offset),\n+            };\n+            let resolver = expr::resolver_for_scope(def.body(db), db, scope);\n+            SourceAnalyzer {\n+                resolver,\n+                body_source_map: Some(source_map),\n+                infer: Some(def.infer(db)),\n+                scopes: Some(scopes),\n+            }\n+        } else {\n+            SourceAnalyzer {\n+                resolver: node\n+                    .ancestors()\n+                    .find_map(|node| try_get_resolver_for_node(db, file_id, node))\n+                    .unwrap_or_default(),\n+                body_source_map: None,\n+                infer: None,\n+                scopes: None,\n+            }\n         }\n     }\n \n@@ -276,21 +273,112 @@ impl SourceAnalyzer {\n         Some(res)\n     }\n \n-    pub fn find_all_refs(&self, pat: &ast::BindPat) -> Option<Vec<ReferenceDescriptor>> {\n-        self.scopes.as_ref().map(|it| it.find_all_refs(pat))\n+    pub fn resolve_local_name(&self, name_ref: &ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n+        let mut shadowed = FxHashSet::default();\n+        let name = name_ref.as_name();\n+        let source_map = self.body_source_map.as_ref()?;\n+        let scopes = self.scopes.as_ref()?;\n+        let scope = scope_for(scopes, source_map, name_ref.syntax());\n+        let ret = scopes\n+            .scope_chain(scope)\n+            .flat_map(|scope| scopes.entries(scope).iter())\n+            .filter(|entry| shadowed.insert(entry.name()))\n+            .filter(|entry| entry.name() == &name)\n+            .nth(0);\n+        ret.and_then(|entry| {\n+            Some(ScopeEntryWithSyntax {\n+                name: entry.name().clone(),\n+                ptr: source_map.pat_syntax(entry.pat())?,\n+            })\n+        })\n     }\n \n-    pub fn resolve_local_name(&self, name_ref: &ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n-        self.scopes.as_ref()?.resolve_local_name(name_ref)\n+    pub fn find_all_refs(&self, pat: &ast::BindPat) -> Vec<ReferenceDescriptor> {\n+        let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n+        let ptr = Either::A(AstPtr::new(pat.into()));\n+        fn_def\n+            .syntax()\n+            .descendants()\n+            .filter_map(ast::NameRef::cast)\n+            .filter(|name_ref| match self.resolve_local_name(*name_ref) {\n+                None => false,\n+                Some(entry) => entry.ptr() == ptr,\n+            })\n+            .map(|name_ref| ReferenceDescriptor {\n+                name: name_ref.syntax().text().to_string(),\n+                range: name_ref.syntax().range(),\n+            })\n+            .collect()\n     }\n \n     #[cfg(test)]\n-    pub(crate) fn body_source_map(&self) -> Arc<crate::expr::BodySourceMap> {\n+    pub(crate) fn body_source_map(&self) -> Arc<BodySourceMap> {\n         self.body_source_map.clone().unwrap()\n     }\n \n     #[cfg(test)]\n     pub(crate) fn inference_result(&self) -> Arc<crate::ty::InferenceResult> {\n         self.infer.clone().unwrap()\n     }\n+\n+    #[cfg(test)]\n+    pub(crate) fn scopes(&self) -> Arc<ExprScopes> {\n+        self.scopes.clone().unwrap()\n+    }\n+}\n+\n+fn scope_for(\n+    scopes: &ExprScopes,\n+    source_map: &BodySourceMap,\n+    node: &SyntaxNode,\n+) -> Option<ScopeId> {\n+    node.ancestors()\n+        .map(SyntaxNodePtr::new)\n+        .filter_map(|ptr| source_map.syntax_expr(ptr))\n+        .find_map(|it| scopes.scope_for(it))\n+}\n+\n+fn scope_for_offset(\n+    scopes: &ExprScopes,\n+    source_map: &BodySourceMap,\n+    offset: TextUnit,\n+) -> Option<ScopeId> {\n+    scopes\n+        .scope_for\n+        .iter()\n+        .filter_map(|(id, scope)| Some((source_map.expr_syntax(*id)?, scope)))\n+        // find containing scope\n+        .min_by_key(|(ptr, _scope)| {\n+            (!(ptr.range().start() <= offset && offset <= ptr.range().end()), ptr.range().len())\n+        })\n+        .map(|(ptr, scope)| adjust(scopes, source_map, ptr, offset).unwrap_or(*scope))\n+}\n+\n+// XXX: during completion, cursor might be outside of any particular\n+// expression. Try to figure out the correct scope...\n+fn adjust(\n+    scopes: &ExprScopes,\n+    source_map: &BodySourceMap,\n+    ptr: SyntaxNodePtr,\n+    offset: TextUnit,\n+) -> Option<ScopeId> {\n+    let r = ptr.range();\n+    let child_scopes = scopes\n+        .scope_for\n+        .iter()\n+        .filter_map(|(id, scope)| Some((source_map.expr_syntax(*id)?, scope)))\n+        .map(|(ptr, scope)| (ptr.range(), scope))\n+        .filter(|(range, _)| range.start() <= offset && range.is_subrange(&r) && *range != r);\n+\n+    child_scopes\n+        .max_by(|(r1, _), (r2, _)| {\n+            if r2.is_subrange(&r1) {\n+                std::cmp::Ordering::Greater\n+            } else if r1.is_subrange(&r2) {\n+                std::cmp::Ordering::Less\n+            } else {\n+                r1.start().cmp(&r2.start())\n+            }\n+        })\n+        .map(|(_ptr, scope)| *scope)\n }"}, {"sha": "9f655d83ce03066c52414578d0c77bad7034d304", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4a94e74bcd6c8f9275a57a775e64314af1878da/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4a94e74bcd6c8f9275a57a775e64314af1878da/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=f4a94e74bcd6c8f9275a57a775e64314af1878da", "patch": "@@ -65,7 +65,7 @@ pub(crate) fn find_all_refs(\n     let declaration = NavigationTarget::from_bind_pat(position.file_id, binding);\n \n     let references = analyzer\n-        .find_all_refs(binding)?\n+        .find_all_refs(binding)\n         .into_iter()\n         .map(move |ref_desc| FileRange { file_id: position.file_id, range: ref_desc.range })\n         .collect::<Vec<_>>();"}]}