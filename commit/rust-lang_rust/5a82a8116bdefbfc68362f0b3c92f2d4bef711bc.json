{"sha": "5a82a8116bdefbfc68362f0b3c92f2d4bef711bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhODJhODExNmJkZWZiZmM2ODM2MmYwYjNjOTJmMmQ0YmVmNzExYmM=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2015-03-11T12:41:31Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2015-03-11T12:41:31Z"}, "message": "Remove unnecessary Arc usage in introduction", "tree": {"sha": "d50df383ecf61d1e4db8c29672f293a52ff931d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d50df383ecf61d1e4db8c29672f293a52ff931d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a82a8116bdefbfc68362f0b3c92f2d4bef711bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a82a8116bdefbfc68362f0b3c92f2d4bef711bc", "html_url": "https://github.com/rust-lang/rust/commit/5a82a8116bdefbfc68362f0b3c92f2d4bef711bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a82a8116bdefbfc68362f0b3c92f2d4bef711bc/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f899513a30165946a75ff7f515ab37a226e72172", "url": "https://api.github.com/repos/rust-lang/rust/commits/f899513a30165946a75ff7f515ab37a226e72172", "html_url": "https://github.com/rust-lang/rust/commit/f899513a30165946a75ff7f515ab37a226e72172"}], "stats": {"total": 36, "additions": 14, "deletions": 22}, "files": [{"sha": "79f285dccc04b89f0a751b8b7035408aab3454b1", "filename": "src/doc/intro.md", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5a82a8116bdefbfc68362f0b3c92f2d4bef711bc/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a82a8116bdefbfc68362f0b3c92f2d4bef711bc/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=5a82a8116bdefbfc68362f0b3c92f2d4bef711bc", "patch": "@@ -457,30 +457,25 @@ owner. Rust detects this and gives us the error: we claim that\n `numbers` has ownership, but our code tries to make three owners. This\n may cause a safety problem, so Rust disallows it.\n \n-What to do here? Rust has two types that helps us: `Arc<T>` and `Mutex<T>`.\n-*Arc* stands for \"atomically reference counted\". In other words, an Arc will\n-keep track of the number of references to something, and not free the\n-associated resource until the count is zero. The *atomic* portion refers to an\n-Arc's usage of concurrency primitives to atomically update the count, making it\n-safe across threads. If we use an Arc, we can have our three references. But,\n-an Arc does not allow mutable borrows of the data it holds, and we want to\n-modify what we're sharing. In this case, we can use a `Mutex<T>` inside of our\n-Arc. A Mutex will synchronize our accesses, so that we can ensure that our\n-mutation doesn't cause a data race.\n-\n-Here's what using an Arc with a Mutex looks like:\n+What to do here? Rust has a type that helps us: `Mutex<T>`. Because the threads\n+are scoped, it is possible to use an _immutable_ reference to `numbers` inside\n+of the closure. However, Rust prevents us from having multiple _mutable_\n+references to the same object, so we need a `Mutex` to be able to modify what\n+we're sharing. A Mutex will synchronize our accesses, so that we can ensure\n+that our mutation doesn't cause a data race.\n+\n+Here's what using a Mutex looks like:\n \n ```{rust}\n use std::thread;\n-use std::sync::{Arc,Mutex};\n+use std::sync::Mutex;\n \n fn main() {\n-    let numbers = Arc::new(Mutex::new(vec![1, 2, 3]));\n+    let numbers = &Mutex::new(vec![1, 2, 3]);\n \n     let guards: Vec<_> = (0..3).map(|i| {\n-        let number = numbers.clone();\n         thread::scoped(move || {\n-            let mut array = number.lock().unwrap();\n+            let mut array = numbers.lock().unwrap();\n             array[i] += 1;\n             println!(\"numbers[{}] is {}\", i, array[i]);\n         })\n@@ -489,12 +484,9 @@ fn main() {\n ```\n \n We first have to `use` the appropriate library, and then we wrap our vector in\n-an Arc with the call to `Arc::new()`. Inside of the loop, we make a new\n-reference to the Arc with the `clone()` method. This will increment the\n-reference count. When each new `numbers` variable binding goes out of scope, it\n-will decrement the count. The `lock()` call will return us a reference to the\n-value inside the Mutex, and block any other calls to `lock()` until said\n-reference goes out of scope.\n+a `Mutex` with the call to `Mutex::new()`. Inside of the loop, the `lock()`\n+call will return us a reference to the value inside the Mutex, and block any\n+other calls to `lock()` until said reference goes out of scope.\n \n We can compile and run this program without error, and in fact, see the\n non-deterministic aspect:"}]}