{"sha": "30793c1e819550288a9a17ddeccac06be85b61a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwNzkzYzFlODE5NTUwMjg4YTlhMTdkZGVjY2FjMDZiZTg1YjYxYTI=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-06-14T15:39:25Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-06-22T15:58:30Z"}, "message": "Add documentation for various THIR structs", "tree": {"sha": "f9222f5624a42caf78563cfced9ed3be0e90e1ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9222f5624a42caf78563cfced9ed3be0e90e1ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30793c1e819550288a9a17ddeccac06be85b61a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30793c1e819550288a9a17ddeccac06be85b61a2", "html_url": "https://github.com/rust-lang/rust/commit/30793c1e819550288a9a17ddeccac06be85b61a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30793c1e819550288a9a17ddeccac06be85b61a2/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3487be11d5f3c9afc4d8e44438cdd2af1e98c859", "url": "https://api.github.com/repos/rust-lang/rust/commits/3487be11d5f3c9afc4d8e44438cdd2af1e98c859", "html_url": "https://github.com/rust-lang/rust/commit/3487be11d5f3c9afc4d8e44438cdd2af1e98c859"}], "stats": {"total": 144, "additions": 109, "deletions": 35}, "files": [{"sha": "cdefc9effa1e9ac0ce840991ec1687486de2b35e", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 109, "deletions": 35, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/30793c1e819550288a9a17ddeccac06be85b61a2/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30793c1e819550288a9a17ddeccac06be85b61a2/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=30793c1e819550288a9a17ddeccac06be85b61a2", "patch": "@@ -1,3 +1,13 @@\n+//! THIR datatypes and definitions. See the [rustc dev guide] for more info.\n+//!\n+//! If you compare the THIR [`ExprKind`] to [`hir::ExprKind`], you will see it is\n+//! a good bit simpler. In fact, a number of the more straight-forward\n+//! MIR simplifications are already done in the lowering to THIR. For\n+//! example, method calls and overloaded operators are absent: they are\n+//! expected to be converted into [`ExprKind::Call`] instances.\n+//!\n+//! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/thir.html\n+\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n@@ -24,13 +34,15 @@ use std::fmt;\n use std::ops::Index;\n \n newtype_index! {\n+    /// An index to an [`Arm`] stored in [`Thir::arms`]\n     #[derive(HashStable)]\n     pub struct ArmId {\n         DEBUG_FORMAT = \"a{}\"\n     }\n }\n \n newtype_index! {\n+    /// An index to an [`Expr`] stored in [`Thir::exprs`]\n     #[derive(HashStable)]\n     pub struct ExprId {\n         DEBUG_FORMAT = \"e{}\"\n@@ -39,13 +51,17 @@ newtype_index! {\n \n newtype_index! {\n     #[derive(HashStable)]\n+    /// An index to a [`Stmt`] stored in [`Thir::stmts`]\n     pub struct StmtId {\n         DEBUG_FORMAT = \"s{}\"\n     }\n }\n \n macro_rules! thir_with_elements {\n     ($($name:ident: $id:ty => $value:ty,)*) => {\n+        /// A container for a THIR body.\n+        ///\n+        /// This can be indexed directly by any THIR index (e.g. [`ExprId`]).\n         #[derive(Debug, HashStable)]\n         pub struct Thir<'tcx> {\n             $(\n@@ -88,18 +104,28 @@ pub enum LintLevel {\n \n #[derive(Debug, HashStable)]\n pub struct Block {\n+    /// Whether the block itself has a label. Used by `label: {}`\n+    /// and `try` blocks.\n+    ///\n+    /// This does *not* include labels on loops, e.g. `'label: loop {}`.\n     pub targeted_by_break: bool,\n     pub region_scope: region::Scope,\n     pub opt_destruction_scope: Option<region::Scope>,\n+    /// The span of the block, including the opening braces,\n+    /// the label, and the `unsafe` keyword, if present.\n     pub span: Span,\n+    /// The statements in the blocK.\n     pub stmts: Box<[StmtId]>,\n+    /// The trailing expression of the block, if any.\n     pub expr: Option<ExprId>,\n     pub safety_mode: BlockSafety,\n }\n \n #[derive(Debug, HashStable)]\n pub struct Adt<'tcx> {\n+    /// The ADT we're constructing.\n     pub adt_def: &'tcx AdtDef,\n+    /// The variant of the ADT.\n     pub variant_index: VariantIdx,\n     pub substs: SubstsRef<'tcx>,\n \n@@ -108,13 +134,16 @@ pub struct Adt<'tcx> {\n     pub user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n \n     pub fields: Box<[FieldExpr]>,\n+    /// The base, e.g. `Foo {x: 1, .. base}`.\n     pub base: Option<FruInfo<'tcx>>,\n }\n \n #[derive(Copy, Clone, Debug, HashStable)]\n pub enum BlockSafety {\n     Safe,\n+    /// A compiler-generated unsafe block\n     BuiltinUnsafe,\n+    /// An `unsafe` block. The `HirId` is the ID of the block.\n     ExplicitUnsafe(hir::HirId),\n }\n \n@@ -126,32 +155,34 @@ pub struct Stmt<'tcx> {\n \n #[derive(Debug, HashStable)]\n pub enum StmtKind<'tcx> {\n+    /// An expression with a trailing semicolon.\n     Expr {\n-        /// scope for this statement; may be used as lifetime of temporaries\n+        /// The scope for this statement; may be used as lifetime of temporaries.\n         scope: region::Scope,\n \n-        /// expression being evaluated in this statement\n+        /// The expression being evaluated in this statement.\n         expr: ExprId,\n     },\n \n+    /// A `let` binding.\n     Let {\n-        /// scope for variables bound in this let; covers this and\n-        /// remaining statements in block\n+        /// The scope for variables bound in this `let`; it covers this and\n+        /// all the remaining statements in the block.\n         remainder_scope: region::Scope,\n \n-        /// scope for the initialization itself; might be used as\n-        /// lifetime of temporaries\n+        /// The scope for the initialization itself; might be used as\n+        /// lifetime of temporaries.\n         init_scope: region::Scope,\n \n         /// `let <PAT> = ...`\n         ///\n-        /// if a type is included, it is added as an ascription pattern\n+        /// If a type annotation is included, it is added as an ascription pattern.\n         pattern: Pat<'tcx>,\n \n-        /// let pat: ty = <INIT> ...\n+        /// `let pat: ty = <INIT>`\n         initializer: Option<ExprId>,\n \n-        /// the lint level for this let-statement\n+        /// The lint level for this `let` statement.\n         lint_level: LintLevel,\n     },\n }\n@@ -160,27 +191,14 @@ pub enum StmtKind<'tcx> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Expr<'_>, 104);\n \n-/// The Thir trait implementor lowers their expressions (`&'tcx H::Expr`)\n-/// into instances of this `Expr` enum. This lowering can be done\n-/// basically as lazily or as eagerly as desired: every recursive\n-/// reference to an expression in this enum is an `ExprId`, which\n-/// may in turn be another instance of this enum (boxed), or else an\n-/// unlowered `&'tcx H::Expr`. Note that instances of `Expr` are very\n-/// short-lived. They are created by `Thir::to_expr`, analyzed and\n-/// converted into MIR, and then discarded.\n-///\n-/// If you compare `Expr` to the full compiler AST, you will see it is\n-/// a good bit simpler. In fact, a number of the more straight-forward\n-/// MIR simplifications are already done in the impl of `Thir`. For\n-/// example, method calls and overloaded operators are absent: they are\n-/// expected to be converted into `Expr::Call` instances.\n+/// A THIR expression.\n #[derive(Debug, HashStable)]\n pub struct Expr<'tcx> {\n-    /// type of this expression\n+    /// The type of this expression\n     pub ty: Ty<'tcx>,\n \n-    /// lifetime of this expression if it should be spilled into a\n-    /// temporary; should be None only if in a constant context\n+    /// The lifetime of this expression if it should be spilled into a\n+    /// temporary; should be `None` only if in a constant context\n     pub temp_lifetime: Option<region::Scope>,\n \n     /// span of the expression in the source\n@@ -192,88 +210,120 @@ pub struct Expr<'tcx> {\n \n #[derive(Debug, HashStable)]\n pub enum ExprKind<'tcx> {\n+    /// `Scope`s are used to explicitely mark destruction scopes,\n+    /// and to track the `HirId` of the expressions within the scope.\n     Scope {\n         region_scope: region::Scope,\n         lint_level: LintLevel,\n         value: ExprId,\n     },\n+    /// A `box <value>` expression.\n     Box {\n         value: ExprId,\n     },\n+    /// An `if` expression.\n     If {\n         cond: ExprId,\n         then: ExprId,\n         else_opt: Option<ExprId>,\n     },\n+    /// A function call. Method calls and overloaded operators are converted to plain function calls.\n     Call {\n+        /// The type of the function. This is often a [`FnDef`] or a [`FnPtr`].\n+        ///\n+        /// [`FnDef`]: ty::TyKind::FnDef\n+        /// [`FnPtr`]: ty::TyKind::FnPtr\n         ty: Ty<'tcx>,\n+        /// The function itself.\n         fun: ExprId,\n+        /// The arguments passed to the function.\n+        ///\n+        /// Note: in some cases (like calling a closure), the function call `f(...args)` gets\n+        /// rewritten as a call to a function trait method (e.g. `FnOnce::call_once(f, (...args))`).\n         args: Box<[ExprId]>,\n-        /// Whether this is from a call in HIR, rather than from an overloaded\n-        /// operator. `true` for overloaded function call.\n+        /// Whether this is from an overloaded operator rather than a\n+        /// function call from HIR. `true` for overloaded function call.\n         from_hir_call: bool,\n-        /// This `Span` is the span of the function, without the dot and receiver\n-        /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n+        /// The span of the function, without the dot and receiver\n+        /// (e.g. `foo(a, b)` in `x.foo(a, b)`).\n         fn_span: Span,\n     },\n+    /// A *non-overloaded* dereference.\n     Deref {\n         arg: ExprId,\n-    }, // NOT overloaded!\n+    },\n+    /// A *non-overloaded* binary operation.\n     Binary {\n         op: BinOp,\n         lhs: ExprId,\n         rhs: ExprId,\n-    }, // NOT overloaded!\n+    },\n+    /// A logical operation. This is distinct from `BinaryOp` because\n+    /// the operands need to be lazily evaluated.\n     LogicalOp {\n         op: LogicalOp,\n         lhs: ExprId,\n         rhs: ExprId,\n-    }, // NOT overloaded!\n-    // LogicalOp is distinct from BinaryOp because of lazy evaluation of the operands.\n+    },\n+    /// A *non-overloaded* unary operation. Note that here the deref (`*`)\n+    /// operator is represented by `ExprKind::Deref`.\n     Unary {\n         op: UnOp,\n         arg: ExprId,\n-    }, // NOT overloaded!\n+    },\n+    /// A cast: `<source> as <type>`. The type we cast to is the type of\n+    /// the parent expression.\n     Cast {\n         source: ExprId,\n     },\n     Use {\n         source: ExprId,\n     }, // Use a lexpr to get a vexpr.\n+    /// A coercion from `!` to any type.\n     NeverToAny {\n         source: ExprId,\n     },\n+    /// A pointer cast. More information can be found in [`PointerCast`].\n     Pointer {\n         cast: PointerCast,\n         source: ExprId,\n     },\n+    /// A `loop` expression.\n     Loop {\n         body: ExprId,\n     },\n+    /// A `match` expression.\n     Match {\n         scrutinee: ExprId,\n         arms: Box<[ArmId]>,\n     },\n+    /// A block.\n     Block {\n         body: Block,\n     },\n+    /// An assignment: `lhs = rhs`.\n     Assign {\n         lhs: ExprId,\n         rhs: ExprId,\n     },\n+    /// A *non-overloaded* operation assignment, e.g. `lhs += rhs`.\n     AssignOp {\n         op: BinOp,\n         lhs: ExprId,\n         rhs: ExprId,\n     },\n+    /// Access to a struct or tuple field.\n     Field {\n         lhs: ExprId,\n+        /// This can be a named (`.foo`) or unnamed (`.0`) field.\n         name: Field,\n     },\n+    /// A *non-overloaded* indexing operation.\n     Index {\n         lhs: ExprId,\n         index: ExprId,\n     },\n+    /// A local variable.\n     VarRef {\n         id: hir::HirId,\n     },\n@@ -285,6 +335,7 @@ pub enum ExprKind<'tcx> {\n         /// HirId of the root variable\n         var_hir_id: hir::HirId,\n     },\n+    /// A borrow, e.g. `&arg`.\n     Borrow {\n         borrow_kind: BorrowKind,\n         arg: ExprId,\n@@ -294,47 +345,59 @@ pub enum ExprKind<'tcx> {\n         mutability: hir::Mutability,\n         arg: ExprId,\n     },\n+    /// A `break` expression.\n     Break {\n         label: region::Scope,\n         value: Option<ExprId>,\n     },\n+    /// A `continue` expression.\n     Continue {\n         label: region::Scope,\n     },\n+    /// A `return` expression.\n     Return {\n         value: Option<ExprId>,\n     },\n+    /// An inline `const` block, e.g. `const {}`.\n     ConstBlock {\n         value: &'tcx Const<'tcx>,\n     },\n+    /// An array literal constructed from one repeated element, e.g. `[1; 5]`.\n     Repeat {\n         value: ExprId,\n         count: &'tcx Const<'tcx>,\n     },\n+    /// An array, e.g. `[a, b, c, d]`.\n     Array {\n         fields: Box<[ExprId]>,\n     },\n+    /// A tuple, e.g. `(a, b, c, d)`.\n     Tuple {\n         fields: Box<[ExprId]>,\n     },\n+    /// An ADT constructor, e.g. `Foo {x: 1, y: 2}`.\n     Adt(Box<Adt<'tcx>>),\n+    /// A type ascription on a place.\n     PlaceTypeAscription {\n         source: ExprId,\n         /// Type that the user gave to this expression\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n+    /// A type ascription on a value, e.g. `42: i32`.\n     ValueTypeAscription {\n         source: ExprId,\n         /// Type that the user gave to this expression\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n     },\n+    /// A closure definition.\n     Closure {\n         closure_id: DefId,\n         substs: UpvarSubsts<'tcx>,\n         upvars: Box<[ExprId]>,\n         movability: Option<hir::Movability>,\n         fake_reads: Vec<(ExprId, FakeReadCause, hir::HirId)>,\n     },\n+    /// A literal.\n     Literal {\n         literal: &'tcx Const<'tcx>,\n         user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n@@ -351,6 +414,7 @@ pub enum ExprKind<'tcx> {\n         literal: &'tcx Const<'tcx>,\n         def_id: DefId,\n     },\n+    /// Inline assembly, i.e. `asm!()`.\n     InlineAsm {\n         template: &'tcx [InlineAsmTemplatePiece],\n         operands: Box<[InlineAsmOperand<'tcx>]>,\n@@ -359,16 +423,21 @@ pub enum ExprKind<'tcx> {\n     },\n     /// An expression taking a reference to a thread local.\n     ThreadLocalRef(DefId),\n+    /// Inline LLVM assembly, i.e. `llvm_asm!()`.\n     LlvmInlineAsm {\n         asm: &'tcx hir::LlvmInlineAsmInner,\n         outputs: Box<[ExprId]>,\n         inputs: Box<[ExprId]>,\n     },\n+    /// A `yield` expression.\n     Yield {\n         value: ExprId,\n     },\n }\n \n+/// Represents the association of a field identifier and an expression.\n+///\n+/// This is used in struct constructors.\n #[derive(Debug, HashStable)]\n pub struct FieldExpr {\n     pub name: Field,\n@@ -381,6 +450,7 @@ pub struct FruInfo<'tcx> {\n     pub field_types: Box<[Ty<'tcx>]>,\n }\n \n+/// A `match` arm.\n #[derive(Debug, HashStable)]\n pub struct Arm<'tcx> {\n     pub pattern: Pat<'tcx>,\n@@ -391,6 +461,7 @@ pub struct Arm<'tcx> {\n     pub span: Span,\n }\n \n+/// A `match` guard.\n #[derive(Debug, HashStable)]\n pub enum Guard<'tcx> {\n     If(ExprId),\n@@ -399,7 +470,9 @@ pub enum Guard<'tcx> {\n \n #[derive(Copy, Clone, Debug, HashStable)]\n pub enum LogicalOp {\n+    /// The `&&` operator.\n     And,\n+    /// The `||` operator.\n     Or,\n }\n \n@@ -516,6 +589,7 @@ pub struct Ascription<'tcx> {\n \n #[derive(Clone, Debug, PartialEq, HashStable)]\n pub enum PatKind<'tcx> {\n+    /// A wildward pattern: `_`.\n     Wild,\n \n     AscribeUserType {"}]}