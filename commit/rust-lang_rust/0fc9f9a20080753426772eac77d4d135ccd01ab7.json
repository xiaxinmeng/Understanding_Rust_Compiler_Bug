{"sha": "0fc9f9a20080753426772eac77d4d135ccd01ab7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmYzlmOWEyMDA4MDc1MzQyNjc3MmVhYzc3ZDRkMTM1Y2NkMDFhYjc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-04-22T18:07:23Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-04-28T20:53:00Z"}, "message": "Make the codegen unit partitioner also emit item declarations.", "tree": {"sha": "8a8608422fde56ab13be64ed3e7adf9a8abff549", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a8608422fde56ab13be64ed3e7adf9a8abff549"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fc9f9a20080753426772eac77d4d135ccd01ab7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fc9f9a20080753426772eac77d4d135ccd01ab7", "html_url": "https://github.com/rust-lang/rust/commit/0fc9f9a20080753426772eac77d4d135ccd01ab7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fc9f9a20080753426772eac77d4d135ccd01ab7/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f04d35cc6ca34e94a0635bde76a401f7f4a65da", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f04d35cc6ca34e94a0635bde76a401f7f4a65da", "html_url": "https://github.com/rust-lang/rust/commit/7f04d35cc6ca34e94a0635bde76a401f7f4a65da"}], "stats": {"total": 338, "additions": 225, "deletions": 113}, "files": [{"sha": "cb648038c343643737ed3b7d327837edf4cb4dfe", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -52,9 +52,8 @@ impl BitVector {\n \n     pub fn grow(&mut self, num_bits: usize) {\n         let num_words = u64s(num_bits);\n-        let extra_words = self.data.len() - num_words;\n-        if extra_words > 0 {\n-            self.data.extend((0..extra_words).map(|_| 0));\n+        if self.data.len() < num_words {\n+            self.data.resize(num_words, 0)\n         }\n     }\n \n@@ -284,15 +283,27 @@ fn union_two_vecs() {\n #[test]\n fn grow() {\n     let mut vec1 = BitVector::new(65);\n-    assert!(vec1.insert(3));\n-    assert!(!vec1.insert(3));\n-    assert!(vec1.insert(5));\n-    assert!(vec1.insert(64));\n+    for index in 0 .. 65 {\n+        assert!(vec1.insert(index));\n+        assert!(!vec1.insert(index));\n+    }\n     vec1.grow(128);\n-    assert!(vec1.contains(3));\n-    assert!(vec1.contains(5));\n-    assert!(vec1.contains(64));\n-    assert!(!vec1.contains(126));\n+\n+    // Check if the bits set before growing are still set\n+    for index in 0 .. 65 {\n+        assert!(vec1.contains(index));\n+    }\n+\n+    // Check if the new bits are all un-set\n+    for index in 65 .. 128 {\n+        assert!(!vec1.contains(index));\n+    }\n+\n+    // Check that we can set all new bits without running out of bounds\n+    for index in 65 .. 128 {\n+        assert!(vec1.insert(index));\n+        assert!(!vec1.insert(index));\n+    }\n }\n \n #[test]"}, {"sha": "526b6bf68be249e36b8e37dad1061ac4e38e54ed", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -97,7 +97,7 @@ pub enum Visibility {\n // DLLExportLinkage, GhostLinkage and LinkOnceODRAutoHideLinkage.\n // LinkerPrivateLinkage and LinkerPrivateWeakLinkage are not included either;\n // they've been removed in upstream LLVM commit r203866.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Linkage {\n     ExternalLinkage = 0,\n     AvailableExternallyLinkage = 1,"}, {"sha": "b100282781ece2d3700b19c6c820673e0821f09b", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -58,7 +58,6 @@ use attributes;\n use build::*;\n use builder::{Builder, noname};\n use callee::{Callee, CallArgs, ArgExprs, ArgVals};\n-use partitioning::{self, PartitioningStrategy};\n use cleanup::{self, CleanupMethods, DropHint};\n use closure;\n use common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_uint, C_integral};\n@@ -83,6 +82,7 @@ use machine::{llalign_of_min, llsize_of, llsize_of_real};\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n+use partitioning::{self, PartitioningStrategy, InstantiationMode};\n use symbol_names_test;\n use tvec;\n use type_::Type;\n@@ -2934,7 +2934,7 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n         None => TransItemCollectionMode::Lazy\n     };\n \n-    let (items, inlining_map) = time(time_passes, \"translation item collection\", || {\n+    let (items, reference_map) = time(time_passes, \"translation item collection\", || {\n         collector::collect_crate_translation_items(&ccx, collection_mode)\n     });\n \n@@ -2948,7 +2948,7 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n         partitioning::partition(ccx.tcx(),\n                                 items.iter().cloned(),\n                                 strategy,\n-                                &inlining_map)\n+                                &reference_map)\n     });\n \n     if ccx.sess().opts.debugging_opts.print_trans_items.is_some() {\n@@ -2976,17 +2976,18 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n                     output.push_str(&cgu_name[..]);\n \n                     let linkage_abbrev = match linkage {\n-                        llvm::ExternalLinkage => \"External\",\n-                        llvm::AvailableExternallyLinkage => \"Available\",\n-                        llvm::LinkOnceAnyLinkage => \"OnceAny\",\n-                        llvm::LinkOnceODRLinkage => \"OnceODR\",\n-                        llvm::WeakAnyLinkage => \"WeakAny\",\n-                        llvm::WeakODRLinkage => \"WeakODR\",\n-                        llvm::AppendingLinkage => \"Appending\",\n-                        llvm::InternalLinkage => \"Internal\",\n-                        llvm::PrivateLinkage => \"Private\",\n-                        llvm::ExternalWeakLinkage => \"ExternalWeak\",\n-                        llvm::CommonLinkage => \"Common\",\n+                        InstantiationMode::Def(llvm::ExternalLinkage) => \"External\",\n+                        InstantiationMode::Def(llvm::AvailableExternallyLinkage) => \"Available\",\n+                        InstantiationMode::Def(llvm::LinkOnceAnyLinkage) => \"OnceAny\",\n+                        InstantiationMode::Def(llvm::LinkOnceODRLinkage) => \"OnceODR\",\n+                        InstantiationMode::Def(llvm::WeakAnyLinkage) => \"WeakAny\",\n+                        InstantiationMode::Def(llvm::WeakODRLinkage) => \"WeakODR\",\n+                        InstantiationMode::Def(llvm::AppendingLinkage) => \"Appending\",\n+                        InstantiationMode::Def(llvm::InternalLinkage) => \"Internal\",\n+                        InstantiationMode::Def(llvm::PrivateLinkage) => \"Private\",\n+                        InstantiationMode::Def(llvm::ExternalWeakLinkage) => \"ExternalWeak\",\n+                        InstantiationMode::Def(llvm::CommonLinkage) => \"Common\",\n+                        InstantiationMode::Decl => \"Declaration\",\n                     };\n \n                     output.push_str(\"[\");"}, {"sha": "e8181579911d2c085e6b28d28e63a4912229d2dd", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 86, "deletions": 18, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -188,6 +188,8 @@\n //! this is not implemented however: a translation item will be produced\n //! regardless of whether it is actually needed or not.\n \n+use rustc_data_structures::bitvec::BitVector;\n+\n use rustc::hir;\n use rustc::hir::intravisit as hir_visit;\n \n@@ -252,12 +254,76 @@ impl<'tcx> Hash for TransItem<'tcx> {\n     }\n }\n \n-pub type InliningMap<'tcx> = FnvHashMap<TransItem<'tcx>, FnvHashSet<TransItem<'tcx>>>;\n+/// Maps every translation item to all translation items it references in its\n+/// body.\n+pub struct ReferenceMap<'tcx> {\n+    // Maps a source translation item to a range of target translation items.\n+    // The two numbers in the tuple are the start (inclusive) and\n+    // end index (exclusive) within the `targets` and the `inlined` vecs.\n+    index: FnvHashMap<TransItem<'tcx>, (usize, usize)>,\n+    targets: Vec<TransItem<'tcx>>,\n+    inlined: BitVector\n+}\n+\n+impl<'tcx> ReferenceMap<'tcx> {\n+\n+    fn new() -> ReferenceMap<'tcx> {\n+        ReferenceMap {\n+            index: FnvHashMap(),\n+            targets: Vec::new(),\n+            inlined: BitVector::new(64 * 256),\n+        }\n+    }\n+\n+    fn record_references<I>(&mut self, source: TransItem<'tcx>, targets: I)\n+        where I: Iterator<Item=(TransItem<'tcx>, bool)>\n+    {\n+        assert!(!self.index.contains_key(&source));\n+\n+        let start_index = self.targets.len();\n+\n+        for (target, inlined) in targets {\n+            let index = self.targets.len();\n+            self.targets.push(target);\n+            self.inlined.grow(index + 1);\n+\n+            if inlined {\n+                self.inlined.insert(index);\n+            }\n+        }\n+\n+        let end_index = self.targets.len();\n+        self.index.insert(source, (start_index, end_index));\n+    }\n+\n+    // Internally iterate over all items referenced by `source` which will be\n+    // made available for inlining.\n+    pub fn with_inlining_candidates<F>(&self, source: TransItem<'tcx>, mut f: F)\n+        where F: FnMut(TransItem<'tcx>) {\n+        if let Some(&(start_index, end_index)) = self.index.get(&source)\n+        {\n+            for index in start_index .. end_index {\n+                if self.inlined.contains(index) {\n+                    f(self.targets[index])\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn get_direct_references_from(&self, source: TransItem<'tcx>) -> &[TransItem<'tcx>]\n+    {\n+        if let Some(&(start_index, end_index)) = self.index.get(&source) {\n+            &self.targets[start_index .. end_index]\n+        } else {\n+            &self.targets[0 .. 0]\n+        }\n+    }\n+}\n \n pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n                                                  -> (FnvHashSet<TransItem<'tcx>>,\n-                                                     InliningMap<'tcx>) {\n+                                                     ReferenceMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n     ccx.tcx().dep_graph.with_ignore(|| {\n@@ -266,17 +332,17 @@ pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"Building translation item graph, beginning at roots\");\n         let mut visited = FnvHashSet();\n         let mut recursion_depths = DefIdMap();\n-        let mut inlining_map = FnvHashMap();\n+        let mut reference_map = ReferenceMap::new();\n \n         for root in roots {\n             collect_items_rec(ccx,\n                               root,\n                               &mut visited,\n                               &mut recursion_depths,\n-                              &mut inlining_map);\n+                              &mut reference_map);\n         }\n \n-        (visited, inlining_map)\n+        (visited, reference_map)\n     })\n }\n \n@@ -307,7 +373,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n                                    visited: &mut FnvHashSet<TransItem<'tcx>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n-                                   inlining_map: &mut InliningMap<'tcx>) {\n+                                   reference_map: &mut ReferenceMap<'tcx>) {\n     if !visited.insert(starting_point.clone()) {\n         // We've been here already, no need to search again.\n         return;\n@@ -351,9 +417,10 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n+    record_references(ccx, starting_point, &neighbors[..], reference_map);\n+\n     for neighbour in neighbors {\n-        record_inlined_use(ccx, starting_point, neighbour, inlining_map);\n-        collect_items_rec(ccx, neighbour, visited, recursion_depths, inlining_map);\n+        collect_items_rec(ccx, neighbour, visited, recursion_depths, reference_map);\n     }\n \n     if let Some((def_id, depth)) = recursion_depth_reset {\n@@ -363,16 +430,17 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(ccx));\n }\n \n-fn record_inlined_use<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                caller: TransItem<'tcx>,\n-                                callee: TransItem<'tcx>,\n-                                inlining_map: &mut InliningMap<'tcx>) {\n-    if callee.is_from_extern_crate() ||\n-       callee.requests_inline(ccx.tcx()) {\n-        inlining_map.entry(caller)\n-                    .or_insert_with(|| FnvHashSet())\n-                    .insert(callee);\n-    }\n+fn record_references<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               caller: TransItem<'tcx>,\n+                               callees: &[TransItem<'tcx>],\n+                               reference_map: &mut ReferenceMap<'tcx>) {\n+    let iter = callees.into_iter()\n+                      .map(|callee| {\n+                        let is_inlining_candidate = callee.is_from_extern_crate() ||\n+                                                    callee.requests_inline(ccx.tcx());\n+                        (*callee, is_inlining_candidate)\n+                      });\n+    reference_map.record_references(caller, iter);\n }\n \n fn check_recursion_limit<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "250292ee684de52e465acd61782a2f35da2f2c9f", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 80, "deletions": 48, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -116,8 +116,7 @@\n //! source-level module, functions from the same module will be available for\n //! inlining, even when they are not marked #[inline].\n \n-use collector::{InliningMap, TransItem};\n-use context::CrateContext;\n+use collector::{TransItem, ReferenceMap};\n use monomorphize;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n@@ -127,13 +126,27 @@ use llvm;\n use syntax::parse::token::{self, InternedString};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n+#[derive(Clone, Copy, Eq, PartialEq, Debug)]\n+pub enum InstantiationMode {\n+    /// This variant indicates that a translation item should be placed in some\n+    /// codegen unit as a definition and with the given linkage.\n+    Def(llvm::Linkage),\n+\n+    /// This variant indicates that only a declaration of some translation item\n+    /// should be placed in a given codegen unit.\n+    Decl\n+}\n+\n pub struct CodegenUnit<'tcx> {\n     pub name: InternedString,\n-    pub items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n+    pub items: FnvHashMap<TransItem<'tcx>, InstantiationMode>,\n }\n \n pub enum PartitioningStrategy {\n+    /// Generate one codegen unit per source-level module.\n     PerModule,\n+\n+    /// Partition the whole crate into a fixed number of codegen units.\n     FixedUnitCount(usize)\n }\n \n@@ -143,7 +156,7 @@ const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n pub fn partition<'tcx, I>(tcx: &TyCtxt<'tcx>,\n                           trans_items: I,\n                           strategy: PartitioningStrategy,\n-                          inlining_map: &InliningMap<'tcx>)\n+                          reference_map: &ReferenceMap<'tcx>)\n                           -> Vec<CodegenUnit<'tcx>>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n@@ -152,6 +165,8 @@ pub fn partition<'tcx, I>(tcx: &TyCtxt<'tcx>,\n     // functions and statics defined in the local crate.\n     let mut initial_partitioning = place_root_translation_items(tcx, trans_items);\n \n+    // If the partitioning should produce a fixed count of codegen units, merge\n+    // until that count is reached.\n     if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n         merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name[..]);\n     }\n@@ -160,17 +175,27 @@ pub fn partition<'tcx, I>(tcx: &TyCtxt<'tcx>,\n     // translation items have to go into each codegen unit. These additional\n     // translation items can be drop-glue, functions from external crates, and\n     // local functions the definition of which is marked with #[inline].\n-    place_inlined_translation_items(initial_partitioning, inlining_map)\n+    let post_inlining = place_inlined_translation_items(initial_partitioning,\n+                                                        reference_map);\n+\n+    // Now we know all *definitions* within all codegen units, thus we can\n+    // easily determine which declarations need to be placed within each one.\n+    let post_declarations = place_declarations(post_inlining, reference_map);\n+\n+    post_declarations.0\n }\n \n-struct InitialPartitioning<'tcx> {\n+struct PreInliningPartitioning<'tcx> {\n     codegen_units: Vec<CodegenUnit<'tcx>>,\n     roots: FnvHashSet<TransItem<'tcx>>,\n }\n \n+struct PostInliningPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n+struct PostDeclarationsPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n+\n fn place_root_translation_items<'tcx, I>(tcx: &TyCtxt<'tcx>,\n                                          trans_items: I)\n-                                         -> InitialPartitioning<'tcx>\n+                                         -> PreInliningPartitioning<'tcx>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n     let mut roots = FnvHashSet();\n@@ -214,20 +239,21 @@ fn place_root_translation_items<'tcx, I>(tcx: &TyCtxt<'tcx>,\n                 }\n             };\n \n-            codegen_unit.items.insert(trans_item, linkage);\n+            codegen_unit.items.insert(trans_item,\n+                                      InstantiationMode::Def(linkage));\n             roots.insert(trans_item);\n         }\n     }\n \n-    InitialPartitioning {\n+    PreInliningPartitioning {\n         codegen_units: codegen_units.into_iter()\n                                     .map(|(_, codegen_unit)| codegen_unit)\n                                     .collect(),\n         roots: roots,\n     }\n }\n \n-fn merge_codegen_units<'tcx>(initial_partitioning: &mut InitialPartitioning<'tcx>,\n+fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n                              target_cgu_count: usize,\n                              crate_name: &str) {\n     if target_cgu_count >= initial_partitioning.codegen_units.len() {\n@@ -237,7 +263,9 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut InitialPartitioning<'tcx\n     assert!(target_cgu_count >= 1);\n     let codegen_units = &mut initial_partitioning.codegen_units;\n \n-    // Merge the two smallest codegen units until the target size is reached\n+    // Merge the two smallest codegen units until the target size is reached.\n+    // Note that \"size\" is estimated here rather inaccurately as the number of\n+    // translation items in a given unit. This could be improved on.\n     while codegen_units.len() > target_cgu_count {\n         // Sort small cgus to the back\n         codegen_units.as_mut_slice().sort_by_key(|cgu| -(cgu.items.len() as i64));\n@@ -254,61 +282,86 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut InitialPartitioning<'tcx\n     }\n }\n \n-fn place_inlined_translation_items<'tcx>(initial_partitioning: InitialPartitioning<'tcx>,\n-                                         inlining_map: &InliningMap<'tcx>)\n-                                         -> Vec<CodegenUnit<'tcx>> {\n-    let mut final_partitioning = Vec::new();\n+fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartitioning<'tcx>,\n+                                         reference_map: &ReferenceMap<'tcx>)\n+                                         -> PostInliningPartitioning<'tcx> {\n+    let mut new_partitioning = Vec::new();\n \n     for codegen_unit in &initial_partitioning.codegen_units[..] {\n         // Collect all items that need to be available in this codegen unit\n         let mut reachable = FnvHashSet();\n         for root in codegen_unit.items.keys() {\n-            follow_inlining(*root, inlining_map, &mut reachable);\n+            follow_inlining(*root, reference_map, &mut reachable);\n         }\n \n-        let mut final_codegen_unit = CodegenUnit {\n+        let mut new_codegen_unit = CodegenUnit {\n             name: codegen_unit.name.clone(),\n             items: FnvHashMap(),\n         };\n \n         // Add all translation items that are not already there\n         for trans_item in reachable {\n-            if let Some(linkage) = codegen_unit.items.get(&trans_item) {\n+            if let Some(instantiation_mode) = codegen_unit.items.get(&trans_item) {\n                 // This is a root, just copy it over\n-                final_codegen_unit.items.insert(trans_item, *linkage);\n+                new_codegen_unit.items.insert(trans_item, *instantiation_mode);\n             } else {\n                 if initial_partitioning.roots.contains(&trans_item) {\n                     // This item will be instantiated in some other codegen unit,\n                     // so we just add it here with AvailableExternallyLinkage\n-                    final_codegen_unit.items.insert(trans_item, llvm::AvailableExternallyLinkage);\n+                    new_codegen_unit.items.insert(trans_item,\n+                        InstantiationMode::Def(llvm::AvailableExternallyLinkage));\n                 } else {\n                     // We can't be sure if this will also be instantiated\n                     // somewhere else, so we add an instance here with\n                     // LinkOnceODRLinkage. That way the item can be discarded if\n                     // it's not needed (inlined) after all.\n-                    final_codegen_unit.items.insert(trans_item, llvm::LinkOnceODRLinkage);\n+                    new_codegen_unit.items.insert(trans_item,\n+                        InstantiationMode::Def(llvm::LinkOnceODRLinkage));\n                 }\n             }\n         }\n \n-        final_partitioning.push(final_codegen_unit);\n+        new_partitioning.push(new_codegen_unit);\n     }\n \n-    return final_partitioning;\n+    return PostInliningPartitioning(new_partitioning);\n \n     fn follow_inlining<'tcx>(trans_item: TransItem<'tcx>,\n-                             inlining_map: &InliningMap<'tcx>,\n+                             reference_map: &ReferenceMap<'tcx>,\n                              visited: &mut FnvHashSet<TransItem<'tcx>>) {\n         if !visited.insert(trans_item) {\n             return;\n         }\n \n-        if let Some(inlined_items) = inlining_map.get(&trans_item) {\n-            for &inlined_item in inlined_items {\n-                follow_inlining(inlined_item, inlining_map, visited);\n+        reference_map.with_inlining_candidates(trans_item, |target| {\n+            follow_inlining(target, reference_map, visited);\n+        });\n+    }\n+}\n+\n+fn place_declarations<'tcx>(codegen_units: PostInliningPartitioning<'tcx>,\n+                            reference_map: &ReferenceMap<'tcx>)\n+                            -> PostDeclarationsPartitioning<'tcx> {\n+    let PostInliningPartitioning(mut codegen_units) = codegen_units;\n+\n+    for codegen_unit in codegen_units.iter_mut() {\n+        let mut declarations = FnvHashSet();\n+\n+        for (trans_item, _) in &codegen_unit.items {\n+            for referenced_item in reference_map.get_direct_references_from(*trans_item) {\n+                if !codegen_unit.items.contains_key(referenced_item) {\n+                    declarations.insert(*referenced_item);\n+                }\n             }\n         }\n+\n+        codegen_unit.items\n+                    .extend(declarations.iter()\n+                                        .map(|trans_item| (*trans_item,\n+                                                           InstantiationMode::Decl)));\n     }\n+\n+    PostDeclarationsPartitioning(codegen_units)\n }\n \n fn characteristic_def_id_of_trans_item<'tcx>(tcx: &TyCtxt<'tcx>,\n@@ -377,24 +430,3 @@ fn compute_codegen_unit_name<'tcx>(tcx: &TyCtxt<'tcx>,\n \n     return token::intern_and_get_ident(&mod_path[..]);\n }\n-\n-impl<'tcx> CodegenUnit<'tcx> {\n-    pub fn _dump<'a>(&self, ccx: &CrateContext<'a, 'tcx>) {\n-        println!(\"CodegenUnit {} (\", self.name);\n-\n-        let mut items: Vec<_> = self.items\n-                                    .iter()\n-                                    .map(|(trans_item, inst)| {\n-                                        format!(\"{} -- ({:?})\", trans_item.to_string(ccx), inst)\n-                                    })\n-                                    .collect();\n-\n-        items.as_mut_slice().sort();\n-\n-        for s in items {\n-            println!(\"  {}\", s);\n-        }\n-\n-        println!(\")\");\n-    }\n-}"}, {"sha": "be41232ffbab00cd78579f0bc150bb8aad7a9960", "filename": "src/test/codegen-units/partitioning/extern-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=\"\"\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]"}, {"sha": "cd6f4619f9c8038c130212aac80b6b66c0b31c0d", "filename": "src/test/codegen-units/partitioning/extern-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager -Zincremental=\"\"\n+// compile-flags:-Zprint-trans-items=eager -Zincremental=tmp\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]"}, {"sha": "7b92cf3f7cd52407b6677dbc52b9be1001b8fcfd", "filename": "src/test/codegen-units/partitioning/inlining-from-extern-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=\"\"\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp\n \n #![crate_type=\"lib\"]\n "}, {"sha": "f3a973fc47851800a15c09df29f82b654d4448e0", "filename": "src/test/codegen-units/partitioning/local-drop-glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=\"\"\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n@@ -21,7 +21,7 @@ struct Struct {\n }\n \n impl Drop for Struct {\n-    //~ TRANS_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[WeakODR]\n+    //~ TRANS_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[WeakODR] local_drop_glue-mod1[Declaration]\n     fn drop(&mut self) {}\n }\n "}, {"sha": "dd18874baa32b05fa5905d176b7036ee4d287a14", "filename": "src/test/codegen-units/partitioning/local-generic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -9,18 +9,18 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager -Zincremental=\"\"\n+// compile-flags:-Zprint-trans-items=eager -Zincremental=tmp\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n // Used in different modules/codegen units but always instantiated in the same\n // codegen unit.\n \n-//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[WeakODR]\n-//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[WeakODR]\n-//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[WeakODR]\n-//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[WeakODR] local_generic[Declaration]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[WeakODR] local_generic-mod1[Declaration]\n+//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[WeakODR] local_generic-mod1-mod1[Declaration]\n+//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[WeakODR] local_generic-mod2[Declaration]\n pub fn generic<T>(x: T) -> T { x }\n \n //~ TRANS_ITEM fn local_generic::user[0] @@ local_generic[WeakODR]"}, {"sha": "f493c8ed63f743b8088df4efcf6c572da4be3b90", "filename": "src/test/codegen-units/partitioning/local-inlining.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=\"\"\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]"}, {"sha": "31d99e08b653081925dda511e6255179d69f468b", "filename": "src/test/codegen-units/partitioning/local-transitive-inlining.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=\"\"\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]"}, {"sha": "6d04545f93d6e9d2c5ea36264a67d4c882114452", "filename": "src/test/codegen-units/partitioning/methods-are-with-self-type.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=\"\"\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp\n \n #![allow(dead_code)]\n \n@@ -59,19 +59,19 @@ mod type2 {\n //~ TRANS_ITEM fn methods_are_with_self_type::main[0]\n fn main()\n {\n-    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::method[0]<u32, u64> @@ methods_are_with_self_type.volatile[WeakODR]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::method[0]<u32, u64> @@ methods_are_with_self_type.volatile[WeakODR] methods_are_with_self_type[Declaration]\n     SomeGenericType(0u32, 0u64).method();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::associated_fn[0]<char, &str> @@ methods_are_with_self_type.volatile[WeakODR]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::associated_fn[0]<char, &str> @@ methods_are_with_self_type.volatile[WeakODR] methods_are_with_self_type[Declaration]\n     SomeGenericType::associated_fn('c', \"&str\");\n \n-    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR] methods_are_with_self_type[Declaration]\n     type1::Struct.foo();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR] methods_are_with_self_type[Declaration]\n     type2::Struct.foo();\n \n-    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR] methods_are_with_self_type[Declaration]\n     type1::Struct.default();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR] methods_are_with_self_type[Declaration]\n     type2::Struct.default();\n }\n "}, {"sha": "69c9bd0a12ae4e495413160dd8dbb2f3f269730c", "filename": "src/test/codegen-units/partitioning/regular-modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=eager -Z incremental=\"\"\n+// compile-flags:-Zprint-trans-items=eager -Z incremental=tmp\n \n #![allow(dead_code)]\n #![crate_type=\"lib\"]"}, {"sha": "e853ccaff0dd5ceb0e58da892c66b358cb7c73e7", "filename": "src/test/codegen-units/partitioning/statics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fc9f9a20080753426772eac77d4d135ccd01ab7/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs?ref=0fc9f9a20080753426772eac77d4d135ccd01ab7", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // ignore-tidy-linelength\n-// compile-flags:-Zprint-trans-items=lazy -Zincremental=\"\"\n+// compile-flags:-Zprint-trans-items=lazy -Zincremental=tmp\n \n #![crate_type=\"lib\"]\n "}]}