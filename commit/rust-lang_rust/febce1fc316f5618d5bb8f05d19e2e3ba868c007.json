{"sha": "febce1fc316f5618d5bb8f05d19e2e3ba868c007", "node_id": "C_kwDOAAsO6NoAKGZlYmNlMWZjMzE2ZjU2MThkNWJiOGYwNWQxOWUyZTNiYTg2OGMwMDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-16T11:43:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-16T11:43:28Z"}, "message": "Auto merge of #95689 - lqd:self-profiler, r=wesleywiser\n\nAllow self-profiler to only record potentially costly arguments when argument recording is turned on\n\nAs discussed [on zulip](https://rust-lang.zulipchat.com/#narrow/stream/247081-t-compiler.2Fperformance/topic/Identifying.20proc-macro.20slowdowns/near/277304909) with `@wesleywiser,` I'd like to record proc-macro expansions in the self-profiler, with some detailed data (per-expansion spans for example, to follow #95473).\n\nAt the same time, I'd also like to avoid doing expensive things when tracking a generic activity's arguments, if they were not specifically opted into the event filter mask, to allow the self-profiler to be used in hotter contexts.\n\nThis PR tries to offer:\n- a way to ensure a closure to record arguments will only be called in that situation, so that potentially costly arguments can still be recorded when needed. With the additional requirement that, if possible, it would offer a way to record non-owned data without adding many `generic_activity_with_arg_{...}`-style methods. This lead to the `generic_activity_with_arg_recorder` single entry-point, and the closure parameter would offer the new methods, able to be executed in a context where costly argument could be created without disturbing the profiled piece of code.\n- some facilities/patterns allowing to record more rustc specific data in this situation, without making `rustc_data_structures`  where the self-profiler is defined, depend on other rustc crates (causing circular dependencies): in particular, spans. They are quite tricky to turn into strings (if the default `Debug` impl output does not match the context one needs them for), and since I'd also like to avoid the allocation there when arg recording is turned off today, that has turned into another flexibility requirement for the API in this PR (separating the span-specific recording into an extension trait). **edit**: I've removed this from the PR so that it's easier to review, and opened https://github.com/rust-lang/rust/pull/95739.\n- allow for extensibility in the future: other ways to record arguments, or additional data attached to them could be added in the future (e.g. recording the argument's name as well as its data).\n\nSome areas where I'd love feedback:\n- the API and names: the `EventArgRecorder` and its method for example. As well as the verbosity that comes from the increased flexibility.\n- if I should convert the existing `generic_activity_with_arg{s}` to just forward to `generic_activity_with_arg_recorder` + `recorder.record_arg` (or remove them altogether ? Probably not): I've used the new API in the simple case I could find of allocating for an arg that may not be recorded, and the rest don't seem costly.\n- [x] whether this API should panic if no arguments were recorded by the user-provided closure (like this PR currently does: it seems like an error to use an API dedicated to record arguments but not call the methods to then do so) or if this should just record a generic activity without arguments ?\n- whether the `record_arg` function should be `#[inline(always)]`, like the `generic_activity_*` functions ?\n\nAs mentioned, r? `@wesleywiser` following our recent discussion.", "tree": {"sha": "00082556cf5a4fbd135ff1ec3466fa9d6b36cfd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00082556cf5a4fbd135ff1ec3466fa9d6b36cfd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/febce1fc316f5618d5bb8f05d19e2e3ba868c007", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/febce1fc316f5618d5bb8f05d19e2e3ba868c007", "html_url": "https://github.com/rust-lang/rust/commit/febce1fc316f5618d5bb8f05d19e2e3ba868c007", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/febce1fc316f5618d5bb8f05d19e2e3ba868c007/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8422403f775126c40d558838d321c063554c822", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8422403f775126c40d558838d321c063554c822", "html_url": "https://github.com/rust-lang/rust/commit/c8422403f775126c40d558838d321c063554c822"}, {"sha": "1906b7e967f98e8c735054af61906e86cfc80ac7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1906b7e967f98e8c735054af61906e86cfc80ac7", "html_url": "https://github.com/rust-lang/rust/commit/1906b7e967f98e8c735054af61906e86cfc80ac7"}], "stats": {"total": 116, "additions": 103, "deletions": 13}, "files": [{"sha": "efcf18d31eb09a69d345f94f5081b16b3612a20c", "filename": "compiler/rustc_codegen_gcc/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/febce1fc316f5618d5bb8f05d19e2e3ba868c007/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febce1fc316f5618d5bb8f05d19e2e3ba868c007/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs?ref=febce1fc316f5618d5bb8f05d19e2e3ba868c007", "patch": "@@ -11,7 +11,7 @@ use rustc_target::spec::SplitDebuginfo;\n use crate::{GccCodegenBackend, GccContext};\n \n pub(crate) unsafe fn codegen(cgcx: &CodegenContext<GccCodegenBackend>, _diag_handler: &Handler, module: ModuleCodegen<GccContext>, config: &ModuleConfig) -> Result<CompiledModule, FatalError> {\n-    let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_codegen\", &module.name[..]);\n+    let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_codegen\", &*module.name);\n     {\n         let context = &module.module_llvm.context;\n "}, {"sha": "7a747a9cdee4ead49b6894f5dc730a0ac94e729e", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/febce1fc316f5618d5bb8f05d19e2e3ba868c007/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febce1fc316f5618d5bb8f05d19e2e3ba868c007/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=febce1fc316f5618d5bb8f05d19e2e3ba868c007", "patch": "@@ -313,7 +313,9 @@ fn fat_lto(\n         for (bc_decoded, name) in serialized_modules {\n             let _timer = cgcx\n                 .prof\n-                .generic_activity_with_arg(\"LLVM_fat_lto_link_module\", format!(\"{:?}\", name));\n+                .generic_activity_with_arg_recorder(\"LLVM_fat_lto_link_module\", |recorder| {\n+                    recorder.record_arg(format!(\"{:?}\", name))\n+                });\n             info!(\"linking {:?}\", name);\n             let data = bc_decoded.data();\n             linker.add(data).map_err(|()| {"}, {"sha": "7ef3b12cd08dab5c5a2b7f71ca1ceb70668c388d", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/febce1fc316f5618d5bb8f05d19e2e3ba868c007/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febce1fc316f5618d5bb8f05d19e2e3ba868c007/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=febce1fc316f5618d5bb8f05d19e2e3ba868c007", "patch": "@@ -721,8 +721,7 @@ pub(crate) fn link(\n \n     let mut linker = Linker::new(first.module_llvm.llmod());\n     for module in elements {\n-        let _timer =\n-            cgcx.prof.generic_activity_with_arg(\"LLVM_link_module\", format!(\"{:?}\", module.name));\n+        let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_link_module\", &*module.name);\n         let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n         linker.add(buffer.data()).map_err(|()| {\n             let msg = format!(\"failed to serialize module {:?}\", module.name);"}, {"sha": "86f92dc02399f95e3bb34b83d311030919afaf98", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/febce1fc316f5618d5bb8f05d19e2e3ba868c007/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febce1fc316f5618d5bb8f05d19e2e3ba868c007/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=febce1fc316f5618d5bb8f05d19e2e3ba868c007", "patch": "@@ -74,10 +74,11 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol) -> (ModuleCodegen\n \n     fn module_codegen(tcx: TyCtxt<'_>, cgu_name: Symbol) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);\n-        let _prof_timer = tcx.prof.generic_activity_with_args(\n-            \"codegen_module\",\n-            &[cgu_name.to_string(), cgu.size_estimate().to_string()],\n-        );\n+        let _prof_timer =\n+            tcx.prof.generic_activity_with_arg_recorder(\"codegen_module\", |recorder| {\n+                recorder.record_arg(cgu_name.to_string());\n+                recorder.record_arg(cgu.size_estimate().to_string());\n+            });\n         // Instantiate monomorphizations without filling out definitions yet...\n         let llvm_module = ModuleLlvm::new(tcx, cgu_name.as_str());\n         {"}, {"sha": "3f7a90a8467b85b3ac91983e9e51a729d2f6b358", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 93, "deletions": 5, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/febce1fc316f5618d5bb8f05d19e2e3ba868c007/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/febce1fc316f5618d5bb8f05d19e2e3ba868c007/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=febce1fc316f5618d5bb8f05d19e2e3ba868c007", "patch": "@@ -97,6 +97,7 @@ use std::time::{Duration, Instant};\n pub use measureme::EventId;\n use measureme::{EventIdBuilder, Profiler, SerializableString, StringId};\n use parking_lot::RwLock;\n+use smallvec::SmallVec;\n \n bitflags::bitflags! {\n     struct EventFilter: u32 {\n@@ -183,11 +184,11 @@ impl SelfProfilerRef {\n         }\n     }\n \n-    // This shim makes sure that calls only get executed if the filter mask\n-    // lets them pass. It also contains some trickery to make sure that\n-    // code is optimized for non-profiling compilation sessions, i.e. anything\n-    // past the filter check is never inlined so it doesn't clutter the fast\n-    // path.\n+    /// This shim makes sure that calls only get executed if the filter mask\n+    /// lets them pass. It also contains some trickery to make sure that\n+    /// code is optimized for non-profiling compilation sessions, i.e. anything\n+    /// past the filter check is never inlined so it doesn't clutter the fast\n+    /// path.\n     #[inline(always)]\n     fn exec<F>(&self, event_filter: EventFilter, f: F) -> TimingGuard<'_>\n     where\n@@ -288,6 +289,66 @@ impl SelfProfilerRef {\n         })\n     }\n \n+    /// Start profiling a generic activity, allowing costly arguments to be recorded. Profiling\n+    /// continues until the `TimingGuard` returned from this call is dropped.\n+    ///\n+    /// If the arguments to a generic activity are cheap to create, use `generic_activity_with_arg`\n+    /// or `generic_activity_with_args` for their simpler API. However, if they are costly or\n+    /// require allocation in sufficiently hot contexts, then this allows for a closure to be called\n+    /// only when arguments were asked to be recorded via `-Z self-profile-events=args`.\n+    ///\n+    /// In this case, the closure will be passed a `&mut EventArgRecorder`, to help with recording\n+    /// one or many arguments within the generic activity being profiled, by calling its\n+    /// `record_arg` method for example.\n+    ///\n+    /// This `EventArgRecorder` may implement more specific traits from other rustc crates, e.g. for\n+    /// richer handling of rustc-specific argument types, while keeping this single entry-point API\n+    /// for recording arguments.\n+    ///\n+    /// Note: recording at least one argument is *required* for the self-profiler to create the\n+    /// `TimingGuard`. A panic will be triggered if that doesn't happen. This function exists\n+    /// explicitly to record arguments, so it fails loudly when there are none to record.\n+    ///\n+    #[inline(always)]\n+    pub fn generic_activity_with_arg_recorder<F>(\n+        &self,\n+        event_label: &'static str,\n+        mut f: F,\n+    ) -> TimingGuard<'_>\n+    where\n+        F: FnMut(&mut EventArgRecorder<'_>),\n+    {\n+        // Ensure this event will only be recorded when self-profiling is turned on.\n+        self.exec(EventFilter::GENERIC_ACTIVITIES, |profiler| {\n+            let builder = EventIdBuilder::new(&profiler.profiler);\n+            let event_label = profiler.get_or_alloc_cached_string(event_label);\n+\n+            // Ensure the closure to create event arguments will only be called when argument\n+            // recording is turned on.\n+            let event_id = if profiler.event_filter_mask.contains(EventFilter::FUNCTION_ARGS) {\n+                // Set up the builder and call the user-provided closure to record potentially\n+                // costly event arguments.\n+                let mut recorder = EventArgRecorder { profiler, args: SmallVec::new() };\n+                f(&mut recorder);\n+\n+                // It is expected that the closure will record at least one argument. If that\n+                // doesn't happen, it's a bug: we've been explicitly called in order to record\n+                // arguments, so we fail loudly when there are none to record.\n+                if recorder.args.is_empty() {\n+                    panic!(\n+                        \"The closure passed to `generic_activity_with_arg_recorder` needs to \\\n+                         record at least one argument\"\n+                    );\n+                }\n+\n+                builder.from_label_and_args(event_label, &recorder.args)\n+            } else {\n+                builder.from_label(event_label)\n+            };\n+            TimingGuard::start(profiler, profiler.generic_activity_event_kind, event_id)\n+        })\n+    }\n+\n     /// Record the size of an artifact that the compiler produces\n     ///\n     /// `artifact_kind` is the class of artifact (e.g., query_cache, object_file, etc.)\n@@ -443,6 +504,33 @@ impl SelfProfilerRef {\n     }\n }\n \n+/// A helper for recording costly arguments to self-profiling events. Used with\n+/// `SelfProfilerRef::generic_activity_with_arg_recorder`.\n+pub struct EventArgRecorder<'p> {\n+    /// The `SelfProfiler` used to intern the event arguments that users will ask to record.\n+    profiler: &'p SelfProfiler,\n+\n+    /// The interned event arguments to be recorded in the generic activity event.\n+    ///\n+    /// The most common case, when actually recording event arguments, is to have one argument. Then\n+    /// followed by recording two, in a couple places.\n+    args: SmallVec<[StringId; 2]>,\n+}\n+\n+impl EventArgRecorder<'_> {\n+    /// Records a single argument within the current generic activity being profiled.\n+    ///\n+    /// Note: when self-profiling with costly event arguments, at least one argument\n+    /// needs to be recorded. A panic will be triggered if that doesn't happen.\n+    pub fn record_arg<A>(&mut self, event_arg: A)\n+    where\n+        A: Borrow<str> + Into<String>,\n+    {\n+        let event_arg = self.profiler.get_or_alloc_cached_string(event_arg);\n+        self.args.push(event_arg);\n+    }\n+}\n+\n pub struct SelfProfiler {\n     profiler: Profiler,\n     event_filter_mask: EventFilter,"}]}