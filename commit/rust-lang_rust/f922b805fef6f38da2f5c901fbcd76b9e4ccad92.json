{"sha": "f922b805fef6f38da2f5c901fbcd76b9e4ccad92", "node_id": "C_kwDOAAsO6NoAKGY5MjJiODA1ZmVmNmYzOGRhMmY1YzkwMWZiY2Q3NmI5ZTRjY2FkOTI", "commit": {"author": {"name": "Morgan Thomas", "email": "corp@m0rg.dev", "date": "2022-03-12T15:35:13Z"}, "committer": {"name": "Morgan Thomas", "email": "corp@m0rg.dev", "date": "2022-03-12T15:35:13Z"}, "message": "- clean up match in ide_completion::completions::record::complete_record_literal\n- use original instead of adjusted type in ide_completion::completions::record::complete_record\n- don't even bother checking if we can complete union literals to Default or to struct update syntax", "tree": {"sha": "66b4bacf39e63a4cca62ded042cd573a566c8c70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66b4bacf39e63a4cca62ded042cd573a566c8c70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f922b805fef6f38da2f5c901fbcd76b9e4ccad92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f922b805fef6f38da2f5c901fbcd76b9e4ccad92", "html_url": "https://github.com/rust-lang/rust/commit/f922b805fef6f38da2f5c901fbcd76b9e4ccad92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f922b805fef6f38da2f5c901fbcd76b9e4ccad92/comments", "author": {"login": "m0rg-dev", "id": 38578268, "node_id": "MDQ6VXNlcjM4NTc4MjY4", "avatar_url": "https://avatars.githubusercontent.com/u/38578268?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m0rg-dev", "html_url": "https://github.com/m0rg-dev", "followers_url": "https://api.github.com/users/m0rg-dev/followers", "following_url": "https://api.github.com/users/m0rg-dev/following{/other_user}", "gists_url": "https://api.github.com/users/m0rg-dev/gists{/gist_id}", "starred_url": "https://api.github.com/users/m0rg-dev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m0rg-dev/subscriptions", "organizations_url": "https://api.github.com/users/m0rg-dev/orgs", "repos_url": "https://api.github.com/users/m0rg-dev/repos", "events_url": "https://api.github.com/users/m0rg-dev/events{/privacy}", "received_events_url": "https://api.github.com/users/m0rg-dev/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m0rg-dev", "id": 38578268, "node_id": "MDQ6VXNlcjM4NTc4MjY4", "avatar_url": "https://avatars.githubusercontent.com/u/38578268?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m0rg-dev", "html_url": "https://github.com/m0rg-dev", "followers_url": "https://api.github.com/users/m0rg-dev/followers", "following_url": "https://api.github.com/users/m0rg-dev/following{/other_user}", "gists_url": "https://api.github.com/users/m0rg-dev/gists{/gist_id}", "starred_url": "https://api.github.com/users/m0rg-dev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m0rg-dev/subscriptions", "organizations_url": "https://api.github.com/users/m0rg-dev/orgs", "repos_url": "https://api.github.com/users/m0rg-dev/repos", "events_url": "https://api.github.com/users/m0rg-dev/events{/privacy}", "received_events_url": "https://api.github.com/users/m0rg-dev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6519b0a0097594fe00673cc42fc2d0ec83d738aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/6519b0a0097594fe00673cc42fc2d0ec83d738aa", "html_url": "https://github.com/rust-lang/rust/commit/6519b0a0097594fe00673cc42fc2d0ec83d738aa"}], "stats": {"total": 105, "additions": 50, "deletions": 55}, "files": [{"sha": "264b3784bf1dc8aff528aaaffe2a261942338e35", "filename": "crates/ide_completion/src/completions/record.rs", "status": "modified", "additions": 50, "deletions": 55, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f922b805fef6f38da2f5c901fbcd76b9e4ccad92/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f922b805fef6f38da2f5c901fbcd76b9e4ccad92/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=f922b805fef6f38da2f5c901fbcd76b9e4ccad92", "patch": "@@ -15,50 +15,50 @@ pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n         ) => {\n             let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));\n \n-            let default_trait = ctx.famous_defs().core_default_Default();\n-            let impl_default_trait =\n-                default_trait.zip(ty.as_ref()).map_or(false, |(default_trait, ty)| {\n-                    ty.original.impls_trait(ctx.db, default_trait, &[])\n-                });\n-\n-            let missing_fields = match ty.and_then(|t| t.adjusted().as_adt()) {\n-                Some(hir::Adt::Union(un)) => {\n-                    // ctx.sema.record_literal_missing_fields will always return\n-                    // an empty Vec on a union literal. This is normally\n-                    // reasonable, but here we'd like to present the full list\n-                    // of fields if the literal is empty.\n-                    let were_fields_specified = record_expr\n-                        .record_expr_field_list()\n-                        .and_then(|fl| fl.fields().next())\n-                        .is_some();\n-\n-                    match were_fields_specified {\n-                        false => un.fields(ctx.db).into_iter().map(|f| (f, f.ty(ctx.db))).collect(),\n-                        true => vec![],\n-                    }\n+            if let Some(hir::Adt::Union(un)) = ty.as_ref().and_then(|t| t.original.as_adt()) {\n+                // ctx.sema.record_literal_missing_fields will always return\n+                // an empty Vec on a union literal. This is normally\n+                // reasonable, but here we'd like to present the full list\n+                // of fields if the literal is empty.\n+                let were_fields_specified = record_expr\n+                    .record_expr_field_list()\n+                    .and_then(|fl| fl.fields().next())\n+                    .is_some();\n+\n+                match were_fields_specified {\n+                    false => un.fields(ctx.db).into_iter().map(|f| (f, f.ty(ctx.db))).collect(),\n+                    true => vec![],\n                 }\n-                _ => ctx.sema.record_literal_missing_fields(record_expr),\n-            };\n-            if impl_default_trait && !missing_fields.is_empty() && ctx.path_qual().is_none() {\n-                let completion_text = \"..Default::default()\";\n-                let mut item =\n-                    CompletionItem::new(SymbolKind::Field, ctx.source_range(), completion_text);\n-                let completion_text =\n-                    completion_text.strip_prefix(ctx.token.text()).unwrap_or(completion_text);\n-                item.insert_text(completion_text).set_relevance(CompletionRelevance {\n-                    exact_postfix_snippet_match: true,\n-                    ..Default::default()\n-                });\n-                item.add_to(acc);\n-            }\n-            if ctx.previous_token_is(T![.]) {\n-                let mut item =\n-                    CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), \"..\");\n-                item.insert_text(\".\");\n-                item.add_to(acc);\n-                return None;\n+            } else {\n+                let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n+\n+                let default_trait = ctx.famous_defs().core_default_Default();\n+                let impl_default_trait =\n+                    default_trait.zip(ty.as_ref()).map_or(false, |(default_trait, ty)| {\n+                        ty.original.impls_trait(ctx.db, default_trait, &[])\n+                    });\n+\n+                if impl_default_trait && !missing_fields.is_empty() && ctx.path_qual().is_none() {\n+                    let completion_text = \"..Default::default()\";\n+                    let mut item =\n+                        CompletionItem::new(SymbolKind::Field, ctx.source_range(), completion_text);\n+                    let completion_text =\n+                        completion_text.strip_prefix(ctx.token.text()).unwrap_or(completion_text);\n+                    item.insert_text(completion_text).set_relevance(CompletionRelevance {\n+                        exact_postfix_snippet_match: true,\n+                        ..Default::default()\n+                    });\n+                    item.add_to(acc);\n+                }\n+                if ctx.previous_token_is(T![.]) {\n+                    let mut item =\n+                        CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), \"..\");\n+                    item.insert_text(\".\");\n+                    item.add_to(acc);\n+                    return None;\n+                }\n+                missing_fields\n             }\n-            missing_fields\n         }\n         Some(ImmediateLocation::RecordPat(record_pat)) => {\n             ctx.sema.record_pattern_missing_fields(record_pat)\n@@ -82,22 +82,17 @@ pub(crate) fn complete_record_literal(\n     }\n \n     match ctx.expected_type.as_ref()?.as_adt()? {\n-        hir::Adt::Struct(strukt) => {\n-            if ctx.path_qual().is_none() {\n-                let module =\n-                    if let Some(module) = ctx.module { module } else { strukt.module(ctx.db) };\n-                let path = module.find_use_path(ctx.db, hir::ModuleDef::from(strukt));\n+        hir::Adt::Struct(strukt) if ctx.path_qual().is_none() => {\n+            let module = if let Some(module) = ctx.module { module } else { strukt.module(ctx.db) };\n+            let path = module.find_use_path(ctx.db, hir::ModuleDef::from(strukt));\n \n-                acc.add_struct_literal(ctx, strukt, path, None);\n-            }\n+            acc.add_struct_literal(ctx, strukt, path, None);\n         }\n-        hir::Adt::Union(un) => {\n-            if ctx.path_qual().is_none() {\n-                let module = if let Some(module) = ctx.module { module } else { un.module(ctx.db) };\n-                let path = module.find_use_path(ctx.db, hir::ModuleDef::from(un));\n+        hir::Adt::Union(un) if ctx.path_qual().is_none() => {\n+            let module = if let Some(module) = ctx.module { module } else { un.module(ctx.db) };\n+            let path = module.find_use_path(ctx.db, hir::ModuleDef::from(un));\n \n-                acc.add_union_literal(ctx, un, path, None);\n-            }\n+            acc.add_union_literal(ctx, un, path, None);\n         }\n         _ => {}\n     };"}]}