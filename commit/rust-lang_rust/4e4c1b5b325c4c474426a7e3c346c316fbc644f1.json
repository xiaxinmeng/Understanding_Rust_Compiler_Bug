{"sha": "4e4c1b5b325c4c474426a7e3c346c316fbc644f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNGMxYjViMzI1YzRjNDc0NDI2YTdlM2MzNDZjMzE2ZmJjNjQ0ZjE=", "commit": {"author": {"name": "1011X", "email": "1011XXXXX@gmail.com", "date": "2018-03-04T18:33:34Z"}, "committer": {"name": "1011X", "email": "1011XXXXX@gmail.com", "date": "2018-03-04T18:33:34Z"}, "message": "Added `ascii` module to core", "tree": {"sha": "99b1de26df5d39e3396fa38efee8582d2f9577d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99b1de26df5d39e3396fa38efee8582d2f9577d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e4c1b5b325c4c474426a7e3c346c316fbc644f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e4c1b5b325c4c474426a7e3c346c316fbc644f1", "html_url": "https://github.com/rust-lang/rust/commit/4e4c1b5b325c4c474426a7e3c346c316fbc644f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e4c1b5b325c4c474426a7e3c346c316fbc644f1/comments", "author": {"login": "1011X", "id": 1851619, "node_id": "MDQ6VXNlcjE4NTE2MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1851619?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1011X", "html_url": "https://github.com/1011X", "followers_url": "https://api.github.com/users/1011X/followers", "following_url": "https://api.github.com/users/1011X/following{/other_user}", "gists_url": "https://api.github.com/users/1011X/gists{/gist_id}", "starred_url": "https://api.github.com/users/1011X/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1011X/subscriptions", "organizations_url": "https://api.github.com/users/1011X/orgs", "repos_url": "https://api.github.com/users/1011X/repos", "events_url": "https://api.github.com/users/1011X/events{/privacy}", "received_events_url": "https://api.github.com/users/1011X/received_events", "type": "User", "site_admin": false}, "committer": {"login": "1011X", "id": 1851619, "node_id": "MDQ6VXNlcjE4NTE2MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1851619?v=4", "gravatar_id": "", "url": "https://api.github.com/users/1011X", "html_url": "https://github.com/1011X", "followers_url": "https://api.github.com/users/1011X/followers", "following_url": "https://api.github.com/users/1011X/following{/other_user}", "gists_url": "https://api.github.com/users/1011X/gists{/gist_id}", "starred_url": "https://api.github.com/users/1011X/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/1011X/subscriptions", "organizations_url": "https://api.github.com/users/1011X/orgs", "repos_url": "https://api.github.com/users/1011X/repos", "events_url": "https://api.github.com/users/1011X/events{/privacy}", "received_events_url": "https://api.github.com/users/1011X/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b8bd530b0ec0dc7538c12799468867662f818cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b8bd530b0ec0dc7538c12799468867662f818cc", "html_url": "https://github.com/rust-lang/rust/commit/3b8bd530b0ec0dc7538c12799468867662f818cc"}], "stats": {"total": 499, "additions": 499, "deletions": 0}, "files": [{"sha": "e7bee41ac34834025771c197bef02cccc0c262ea", "filename": "src/libcore/ascii.rs", "status": "added", "additions": 499, "deletions": 0, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/4e4c1b5b325c4c474426a7e3c346c316fbc644f1/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4c1b5b325c4c474426a7e3c346c316fbc644f1/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=4e4c1b5b325c4c474426a7e3c346c316fbc644f1", "patch": "@@ -0,0 +1,499 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations on ASCII strings and characters.\n+//!\n+//! Most string operations in Rust act on UTF-8 strings. However, at times it\n+//! makes more sense to only consider the ASCII character set for a specific\n+//! operation.\n+//!\n+//! The [`escape_default`] function provides an iterator over the bytes of an\n+//! escaped version of the character given.\n+//!\n+//! [`escape_default`]: fn.escape_default.html\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use fmt;\n+use ops::Range;\n+use iter::FusedIterator;\n+\n+/// An iterator over the escaped version of a byte.\n+///\n+/// This `struct` is created by the [`escape_default`] function. See its\n+/// documentation for more.\n+///\n+/// [`escape_default`]: fn.escape_default.html\n+#[unstable(feature = \"core_ascii\", issue = \"46409\")]\n+pub struct EscapeDefault {\n+    range: Range<usize>,\n+    data: [u8; 4],\n+}\n+\n+/// Returns an iterator that produces an escaped version of a `u8`.\n+///\n+/// The default is chosen with a bias toward producing literals that are\n+/// legal in a variety of languages, including C++11 and similar C-family\n+/// languages. The exact rules are:\n+///\n+/// * Tab is escaped as `\\t`.\n+/// * Carriage return is escaped as `\\r`.\n+/// * Line feed is escaped as `\\n`.\n+/// * Single quote is escaped as `\\'`.\n+/// * Double quote is escaped as `\\\"`.\n+/// * Backslash is escaped as `\\\\`.\n+/// * Any character in the 'printable ASCII' range `0x20` .. `0x7e`\n+///   inclusive is not escaped.\n+/// * Any other chars are given hex escapes of the form '\\xNN'.\n+/// * Unicode escapes are never generated by this function.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// let escaped = ascii::escape_default(b'0').next().unwrap();\n+/// assert_eq!(b'0', escaped);\n+///\n+/// let mut escaped = ascii::escape_default(b'\\t');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b't', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\r');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'r', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\n');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'n', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\'');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\\'', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\"');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\"', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\\\');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+///\n+/// let mut escaped = ascii::escape_default(b'\\x9d');\n+///\n+/// assert_eq!(b'\\\\', escaped.next().unwrap());\n+/// assert_eq!(b'x', escaped.next().unwrap());\n+/// assert_eq!(b'9', escaped.next().unwrap());\n+/// assert_eq!(b'd', escaped.next().unwrap());\n+/// ```\n+#[unstable(feature = \"core_ascii\", issue = \"46409\")]\n+pub fn escape_ascii(c: u8) -> EscapeDefault {\n+    let (data, len) = match c {\n+        b'\\t' => ([b'\\\\', b't', 0, 0], 2),\n+        b'\\r' => ([b'\\\\', b'r', 0, 0], 2),\n+        b'\\n' => ([b'\\\\', b'n', 0, 0], 2),\n+        b'\\\\' => ([b'\\\\', b'\\\\', 0, 0], 2),\n+        b'\\'' => ([b'\\\\', b'\\'', 0, 0], 2),\n+        b'\"' => ([b'\\\\', b'\"', 0, 0], 2),\n+        b'\\x20' ... b'\\x7e' => ([c, 0, 0, 0], 1),\n+        _ => ([b'\\\\', b'x', hexify(c >> 4), hexify(c & 0xf)], 4),\n+    };\n+\n+    return EscapeDefault { range: 0..len, data };\n+\n+    fn hexify(b: u8) -> u8 {\n+        match b {\n+            0 ... 9 => b'0' + b,\n+            _ => b'a' + b - 10,\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for EscapeDefault {\n+    type Item = u8;\n+    fn next(&mut self) -> Option<u8> { self.range.next().map(|i| self.data[i]) }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl DoubleEndedIterator for EscapeDefault {\n+    fn next_back(&mut self) -> Option<u8> {\n+        self.range.next_back().map(|i| self.data[i])\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ExactSizeIterator for EscapeDefault {}\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl FusedIterator for EscapeDefault {}\n+\n+#[stable(feature = \"std_debug\", since = \"1.16.0\")]\n+impl fmt::Debug for EscapeDefault {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"EscapeDefault { .. }\")\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use char::from_u32;\n+\n+    #[test]\n+    fn test_is_ascii() {\n+        assert!(b\"\".is_ascii());\n+        assert!(b\"banana\\0\\x7F\".is_ascii());\n+        assert!(b\"banana\\0\\x7F\".iter().all(|b| b.is_ascii()));\n+        assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".is_ascii());\n+        assert!(!b\"Vi\\xe1\\xbb\\x87t Nam\".iter().all(|b| b.is_ascii()));\n+        assert!(!b\"\\xe1\\xbb\\x87\".iter().any(|b| b.is_ascii()));\n+\n+        assert!(\"\".is_ascii());\n+        assert!(\"banana\\0\\u{7F}\".is_ascii());\n+        assert!(\"banana\\0\\u{7F}\".chars().all(|c| c.is_ascii()));\n+        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().all(|c| c.is_ascii()));\n+        assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\u1ec7\u00a0\".chars().any(|c| c.is_ascii()));\n+    }\n+\n+    #[test]\n+    fn test_to_ascii_uppercase() {\n+        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_uppercase(), \"URL()URL()URL()\u00fcRL\");\n+        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_uppercase(), \"H\u0131\u212a\u00df\");\n+\n+        for i in 0..501 {\n+            let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n+                        else { i };\n+            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_uppercase(),\n+                       (from_u32(upper).unwrap()).to_string());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_to_ascii_lowercase() {\n+        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lowercase(), \"url()url()url()\u00dcrl\");\n+        // Dotted capital I, Kelvin sign, Sharp S.\n+        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lowercase(), \"h\u0130\u212a\u00df\");\n+\n+        for i in 0..501 {\n+            let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n+                        else { i };\n+            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lowercase(),\n+                       (from_u32(lower).unwrap()).to_string());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_make_ascii_lower_case() {\n+        macro_rules! test {\n+            ($from: expr, $to: expr) => {\n+                {\n+                    let mut x = $from;\n+                    x.make_ascii_lowercase();\n+                    assert_eq!(x, $to);\n+                }\n+            }\n+        }\n+        test!(b'A', b'a');\n+        test!(b'a', b'a');\n+        test!(b'!', b'!');\n+        test!('A', 'a');\n+        test!('\u00c0', '\u00c0');\n+        test!('a', 'a');\n+        test!('!', '!');\n+        test!(b\"H\\xc3\\x89\".to_vec(), b\"h\\xc3\\x89\");\n+        test!(\"H\u0130\u212a\u00df\".to_string(), \"h\u0130\u212a\u00df\");\n+    }\n+\n+\n+    #[test]\n+    fn test_make_ascii_upper_case() {\n+        macro_rules! test {\n+            ($from: expr, $to: expr) => {\n+                {\n+                    let mut x = $from;\n+                    x.make_ascii_uppercase();\n+                    assert_eq!(x, $to);\n+                }\n+            }\n+        }\n+        test!(b'a', b'A');\n+        test!(b'A', b'A');\n+        test!(b'!', b'!');\n+        test!('a', 'A');\n+        test!('\u00e0', '\u00e0');\n+        test!('A', 'A');\n+        test!('!', '!');\n+        test!(b\"h\\xc3\\xa9\".to_vec(), b\"H\\xc3\\xa9\");\n+        test!(\"h\u0131\u212a\u00df\".to_string(), \"H\u0131\u212a\u00df\");\n+\n+        let mut x = \"Hello\".to_string();\n+        x[..3].make_ascii_uppercase();  // Test IndexMut on String.\n+        assert_eq!(x, \"HELlo\")\n+    }\n+\n+    #[test]\n+    fn test_eq_ignore_ascii_case() {\n+        assert!(\"url()URL()uRl()\u00dcrl\".eq_ignore_ascii_case(\"url()url()url()\u00dcrl\"));\n+        assert!(!\"\u00dcrl\".eq_ignore_ascii_case(\"\u00fcrl\"));\n+        // Dotted capital I, Kelvin sign, Sharp S.\n+        assert!(\"H\u0130\u212a\u00df\".eq_ignore_ascii_case(\"h\u0130\u212a\u00df\"));\n+        assert!(!\"\u0130\".eq_ignore_ascii_case(\"i\"));\n+        assert!(!\"\u212a\".eq_ignore_ascii_case(\"k\"));\n+        assert!(!\"\u00df\".eq_ignore_ascii_case(\"s\"));\n+\n+        for i in 0..501 {\n+            let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n+                        else { i };\n+            assert!((from_u32(i).unwrap()).to_string().eq_ignore_ascii_case(\n+                    &from_u32(lower).unwrap().to_string()));\n+        }\n+    }\n+\n+    #[test]\n+    fn inference_works() {\n+        let x = \"a\".to_string();\n+        x.eq_ignore_ascii_case(\"A\");\n+    }\n+\n+    // Shorthands used by the is_ascii_* tests.\n+    macro_rules! assert_all {\n+        ($what:ident, $($str:tt),+) => {{\n+            $(\n+                for b in $str.chars() {\n+                    if !b.$what() {\n+                        panic!(\"expected {}({}) but it isn't\",\n+                               stringify!($what), b);\n+                    }\n+                }\n+                for b in $str.as_bytes().iter() {\n+                    if !b.$what() {\n+                        panic!(\"expected {}(0x{:02x})) but it isn't\",\n+                               stringify!($what), b);\n+                    }\n+                }\n+                assert!($str.$what());\n+                assert!($str.as_bytes().$what());\n+            )+\n+        }};\n+        ($what:ident, $($str:tt),+,) => (assert_all!($what,$($str),+))\n+    }\n+    macro_rules! assert_none {\n+        ($what:ident, $($str:tt),+) => {{\n+            $(\n+                for b in $str.chars() {\n+                    if b.$what() {\n+                        panic!(\"expected not-{}({}) but it is\",\n+                               stringify!($what), b);\n+                    }\n+                }\n+                for b in $str.as_bytes().iter() {\n+                    if b.$what() {\n+                        panic!(\"expected not-{}(0x{:02x})) but it is\",\n+                               stringify!($what), b);\n+                    }\n+                }\n+            )*\n+        }};\n+        ($what:ident, $($str:tt),+,) => (assert_none!($what,$($str),+))\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_alphabetic() {\n+        assert_all!(is_ascii_alphabetic,\n+            \"\",\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        );\n+        assert_none!(is_ascii_alphabetic,\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_uppercase() {\n+        assert_all!(is_ascii_uppercase,\n+            \"\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+        );\n+        assert_none!(is_ascii_uppercase,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_lowercase() {\n+        assert_all!(is_ascii_lowercase,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+        );\n+        assert_none!(is_ascii_lowercase,\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_alphanumeric() {\n+        assert_all!(is_ascii_alphanumeric,\n+            \"\",\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+        );\n+        assert_none!(is_ascii_alphanumeric,\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_digit() {\n+        assert_all!(is_ascii_digit,\n+            \"\",\n+            \"0123456789\",\n+        );\n+        assert_none!(is_ascii_digit,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_hexdigit() {\n+        assert_all!(is_ascii_hexdigit,\n+            \"\",\n+            \"0123456789\",\n+            \"abcdefABCDEF\",\n+        );\n+        assert_none!(is_ascii_hexdigit,\n+            \"ghijklmnopqrstuvwxyz\",\n+            \"GHIJKLMNOQPRSTUVWXYZ\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_punctuation() {\n+        assert_all!(is_ascii_punctuation,\n+            \"\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        );\n+        assert_none!(is_ascii_punctuation,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_graphic() {\n+        assert_all!(is_ascii_graphic,\n+            \"\",\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+        );\n+        assert_none!(is_ascii_graphic,\n+            \" \\t\\n\\x0c\\r\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_whitespace() {\n+        assert_all!(is_ascii_whitespace,\n+            \"\",\n+            \" \\t\\n\\x0c\\r\",\n+        );\n+        assert_none!(is_ascii_whitespace,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x0b\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_is_ascii_control() {\n+        assert_all!(is_ascii_control,\n+            \"\",\n+            \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\",\n+            \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\",\n+            \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\",\n+            \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\",\n+            \"\\x7f\",\n+        );\n+        assert_none!(is_ascii_control,\n+            \"abcdefghijklmnopqrstuvwxyz\",\n+            \"ABCDEFGHIJKLMNOQPRSTUVWXYZ\",\n+            \"0123456789\",\n+            \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n+            \" \",\n+        );\n+    }\n+}"}]}