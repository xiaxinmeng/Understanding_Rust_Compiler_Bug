{"sha": "9f3f69efab08afc14674647667f7561d669e76c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmM2Y2OWVmYWIwOGFmYzE0Njc0NjQ3NjY3Zjc1NjFkNjY5ZTc2YzM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-12T21:55:50Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-12T21:58:58Z"}, "message": "regionck.rs: experimentally adopt a more conservative strategy for\nprojection outlives relations that prefers not to add extract edges to\nregion graph", "tree": {"sha": "f47188b56760c3b85546908029acfe660e903eca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f47188b56760c3b85546908029acfe660e903eca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f3f69efab08afc14674647667f7561d669e76c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3f69efab08afc14674647667f7561d669e76c3", "html_url": "https://github.com/rust-lang/rust/commit/9f3f69efab08afc14674647667f7561d669e76c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f3f69efab08afc14674647667f7561d669e76c3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad700abea4c6718628a4ceccccdad6a633f1dd9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad700abea4c6718628a4ceccccdad6a633f1dd9c", "html_url": "https://github.com/rust-lang/rust/commit/ad700abea4c6718628a4ceccccdad6a633f1dd9c"}], "stats": {"total": 179, "additions": 73, "deletions": 106}, "files": [{"sha": "cc2ac42428b5f3d1cd31b7ca62442960df2b5f15", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 73, "deletions": 106, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/9f3f69efab08afc14674647667f7561d669e76c3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3f69efab08afc14674647667f7561d669e76c3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=9f3f69efab08afc14674647667f7561d669e76c3", "patch": "@@ -1580,116 +1580,60 @@ fn param_ty_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                      origin: infer::SubregionOrigin<'tcx>,\n                                      region: ty::Region,\n-                                     projection_ty: ty::ProjectionTy<'tcx>) {\n+                                     projection_ty: ty::ProjectionTy<'tcx>)\n+{\n     debug!(\"projection_must_outlive(region={:?}, projection_ty={:?}, origin={:?})\",\n            region, projection_ty, origin);\n \n-    // This is a particularly thorny situation for inference, and for\n-    // now we don't have a complete solution, we just do the best we\n-    // can. The problem is that there are multiple ways for `<P0 as\n-    // TraitRef<P1..Pn>>::Foo: 'r` to be satisfied:\n-    //\n-    // 1. If `Pi: 'r` forall i, it is satisfied.\n-    // 2. If there is a suitable where-clause, it can be satisfied.\n-    // 3. The trait declaration may declare `'static` bounds on `Foo` as well.\n-    //\n-    // The fact that there are so many options here makes this thorny.\n-    // In the case of parameter relations like `T: 'r`, it's somewhat\n-    // simpler, because checking such a relation does not affect\n-    // inference.  This is true because the region bounds we can\n-    // derive for `T` never involve region variables -- they are\n-    // always free regions.  The only place a region variable can come\n-    // is on the RHS, and in that case, the smaller the region, the\n-    // better. This means that our current inference, which always\n-    // infers the smallest region it can, can just be used, and we'll\n-    // know what the smallest value for `'r` is when it's done. We can\n-    // then compare that to the regions in the LHS, which are already\n-    // as big as possible, and we're all done.\n-    //\n-    // Projections can in fact be this simple as well. In particular,\n-    // if the parameters `P0..Pn` do not involve any region variables,\n-    // that's the same situation.\n-    //\n-    // Where things get thorny is when region variables are involved,\n-    // because in that case relating `Pi: 'r` may influence the\n-    // inference process, since it could cause `'r` to be inferred to\n-    // a larger value. But the problem is that if we add that as a\n-    // constraint into our dataflow graph, we've essentially committed\n-    // to using option 1 (above) to show that `<P0 as\n-    // Trait<P1..Pn>>::Foo: 'r` is satisfied, and it may be that\n-    // Option 1 does not apply, but Option 2 or 3 does. But we can't\n-    // know that now.\n-    //\n-    // For now we choose to accept this. It's a conservative choice,\n-    // so we can move to a more sophisticated inference model later.\n-    // And it's sometimes possible to workaround by introducing\n-    // explicit type parameters or type annotations. But it ain't\n-    // great!\n-\n-    let declared_bounds = projection_declared_bounds(rcx, origin.span(), projection_ty);\n-\n-    debug!(\"projection_must_outlive: declared_bounds={:?}\",\n-           declared_bounds);\n-\n-    // If we know that the projection outlives 'static, then we're done here.\n-    if declared_bounds.contains(&ty::ReStatic) {\n+    // This case is thorny for inference. The fundamental problem is\n+    // that there are many cases where we have choice, and inference\n+    // doesn't like choice (the current region inference in\n+    // particular). :) First off, we have to choose between using the\n+    // OutlivesProjectionEnv, OutlivesProjectionTraitDef, and\n+    // OutlivesProjectionComponent rules, any one of which is\n+    // sufficient.  If there are no inference variables involved, it's\n+    // not hard to pick the right rule, but if there are, we're in a\n+    // bit of a catch 22: if we picked which rule we were going to\n+    // use, we could add constraints to the region inference graph\n+    // that make it apply, but if we don't add those constraints, the\n+    // rule might not apply (but another rule might). For now, we err\n+    // on the side of adding too few edges into the graph.\n+\n+    // Compute the bounds we can derive from the environment or trait\n+    // definition.  We know that the projection outlives all the\n+    // regions in this list.\n+    let env_bounds = projection_declared_bounds(rcx, origin.span(), projection_ty);\n+\n+    debug!(\"projection_must_outlive: env_bounds={:?}\",\n+           env_bounds);\n+\n+    // If we know that the projection outlives 'static, then we're\n+    // done here.\n+    if env_bounds.contains(&ty::ReStatic) {\n+        debug!(\"projection_must_outlive: 'static as declared bound\");\n         return;\n     }\n \n-    // Determine whether any of regions that appear in the projection\n-    // were declared as bounds by the user. This is typically a situation\n-    // like this:\n-    //\n-    //     trait Foo<'a> {\n-    //         type Bar: 'a;\n-    //     }\n-    //\n-    // where we are checking `<T as Foo<'_#0r>>: '_#1r`. In such a\n-    // case, if we use the conservative rule, we will check that\n-    // BOTH of the following hold:\n-    //\n-    //     T: _#1r\n-    //     _#0r: _#1r\n+    // If declared bounds list is empty, the only applicable rule is\n+    // OutlivesProjectionComponent. If there are inference variables,\n+    // then, we can break down the outlives into more primitive\n+    // components without adding unnecessary edges.\n     //\n-    // This is overkill, since the declared bounds tell us that the\n-    // the latter is sufficient.\n-    let intersection_bounds: Vec<_> =\n-        projection_ty.trait_ref.substs.regions()\n-                                      .iter()\n-                                      .filter(|r| declared_bounds.contains(r))\n-                                      .collect();\n-    let intersection_bounds_needs_infer =\n-        intersection_bounds.iter()\n-                           .any(|r| r.needs_infer());\n-    if intersection_bounds_needs_infer {\n-        // If the upper bound(s) (`_#0r` in the above example) are\n-        // region variables, then introduce edges into the inference\n-        // graph, because we need to ensure that `_#0r` is inferred to\n-        // something big enough. But if the upper bound has no\n-        // inference, then fallback (below) to the verify path, where\n-        // we just check after the fact that it was big enough. This\n-        // is more flexible, because it only requires that there\n-        // exists SOME intersection bound that is big enough, whereas\n-        // this path requires that ALL intersection bounds be big\n-        // enough.\n-        debug!(\"projection_must_outlive: intersection_bounds={:?}\",\n-               intersection_bounds);\n-        for &r in intersection_bounds {\n-            rcx.fcx.mk_subr(origin.clone(), region, r);\n-        }\n-        return;\n-    }\n-\n-    // If there are no intersection bounds, but there are still\n-    // inference variables involves, then fallback to the most\n-    // conservative rule, where we require all components of the\n-    // projection outlive the bound.\n-    if\n-        intersection_bounds.is_empty() && (\n-            projection_ty.trait_ref.substs.types.iter().any(|t| t.needs_infer()) ||\n-                projection_ty.trait_ref.substs.regions().iter().any(|r| r.needs_infer()))\n-    {\n-        debug!(\"projection_must_outlive: fallback to rule #1\");\n+    // If there are *no* inference variables, however, we COULD do\n+    // this, but we choose not to, because the error messages are less\n+    // good. For example, a requirement like `T::Item: 'r` would be\n+    // translated to a requirement that `T: 'r`; when this is reported\n+    // to the user, it will thus say \"T: 'r must hold so that T::Item:\n+    // 'r holds\". But that makes it sound like the only way to fix\n+    // the problem is to add `T: 'r`, which isn't true. So, if there are no\n+    // inference variables, we use a verify constraint instead of adding\n+    // edges, which winds up enforcing the same condition.\n+    let needs_infer = {\n+        projection_ty.trait_ref.substs.types.iter().any(|t| t.needs_infer()) ||\n+            projection_ty.trait_ref.substs.regions().iter().any(|r| r.needs_infer())\n+    };\n+    if env_bounds.is_empty() && needs_infer {\n+        debug!(\"projection_must_outlive: no declared bounds\");\n \n         for &component_ty in &projection_ty.trait_ref.substs.types {\n             type_must_outlive(rcx, origin.clone(), component_ty, region);\n@@ -1702,9 +1646,32 @@ fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n         return;\n     }\n \n-    // Inform region inference that this generic must be properly\n-    // bounded.\n-    let verify_bound = projection_bound(rcx, origin.span(), declared_bounds, projection_ty);\n+    // If we find that there is a unique declared bound `'b`, and this bound\n+    // appears in the trait reference, then the best action is to require that `'b:'r`,\n+    // so do that. This is best no matter what rule we use:\n+    //\n+    // - OutlivesProjectionEnv or OutlivesProjectionTraitDef: these would translate to\n+    // the requirement that `'b:'r`\n+    // - OutlivesProjectionComponent: this would require `'b:'r` in addition to other conditions\n+    if !env_bounds.is_empty() && env_bounds[1..].iter().all(|b| *b == env_bounds[0]) {\n+        let unique_bound = env_bounds[0];\n+        debug!(\"projection_must_outlive: unique declared bound = {:?}\", unique_bound);\n+        if projection_ty.trait_ref.substs.regions()\n+                                         .iter()\n+                                         .any(|r| env_bounds.contains(r))\n+        {\n+            debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n+            rcx.fcx.mk_subr(origin.clone(), region, unique_bound);\n+            return;\n+        }\n+    }\n+\n+    // Fallback to verifying after the fact that there exists a\n+    // declared bound, or that all the components appearing in the\n+    // projection outlive; in some cases, this may add insufficient\n+    // edges into the inference graph, leading to inference failures\n+    // even though a satisfactory solution exists.\n+    let verify_bound = projection_bound(rcx, origin.span(), env_bounds, projection_ty);\n     let generic = GenericKind::Projection(projection_ty);\n     rcx.fcx.infcx().verify_generic_bound(origin, generic.clone(), region, verify_bound);\n }"}]}