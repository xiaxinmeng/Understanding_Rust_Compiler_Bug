{"sha": "7ac48d793bc06d2646244e070c25cc129e539d17", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhYzQ4ZDc5M2JjMDZkMjY0NjI0NGUwNzBjMjVjYzEyOWU1MzlkMTc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-06T08:31:54Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-22T09:54:29Z"}, "message": "Resolve foreign macros", "tree": {"sha": "c82ad70796424a2d79bd203ea2fe7e4764174ffb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c82ad70796424a2d79bd203ea2fe7e4764174ffb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ac48d793bc06d2646244e070c25cc129e539d17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ac48d793bc06d2646244e070c25cc129e539d17", "html_url": "https://github.com/rust-lang/rust/commit/7ac48d793bc06d2646244e070c25cc129e539d17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ac48d793bc06d2646244e070c25cc129e539d17/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6dd902616448e9b86285f5056b32ac4d49e98ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6dd902616448e9b86285f5056b32ac4d49e98ac", "html_url": "https://github.com/rust-lang/rust/commit/d6dd902616448e9b86285f5056b32ac4d49e98ac"}], "stats": {"total": 118, "additions": 84, "deletions": 34}, "files": [{"sha": "e06d7dce4dbef7b05783e3a989063cf303664776", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac48d793bc06d2646244e070c25cc129e539d17/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac48d793bc06d2646244e070c25cc129e539d17/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=7ac48d793bc06d2646244e070c25cc129e539d17", "patch": "@@ -409,7 +409,7 @@ impl<'a> Resolver<'a> {\n         def\n     }\n \n-    fn resolve_macro_to_def_inner(&mut self, scope: Mark, path: &ast::Path,\n+    pub fn resolve_macro_to_def_inner(&mut self, scope: Mark, path: &ast::Path,\n                                   kind: MacroKind, force: bool)\n                                   -> Result<Def, Determinacy> {\n         let ast::Path { ref segments, span } = *path;"}, {"sha": "e4e3cc2acd5efc7e84832ba9a0c7c0ac8d3af11a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ac48d793bc06d2646244e070c25cc129e539d17/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac48d793bc06d2646244e070c25cc129e539d17/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7ac48d793bc06d2646244e070c25cc129e539d17", "patch": "@@ -135,7 +135,11 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n             None\n         }\n     });\n-    let fqn = once(crate_name).chain(relative).collect();\n+    let fqn = if let clean::TypeKind::Macro = kind {\n+        vec![crate_name, relative.last().unwrap()]\n+    } else {\n+        once(crate_name).chain(relative).collect()\n+    };\n     cx.renderinfo.borrow_mut().external_paths.insert(did, (fqn, kind));\n }\n "}, {"sha": "74d1fd0d14e1478efa885d65f6813edc710c330a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 76, "deletions": 31, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/7ac48d793bc06d2646244e070c25cc129e539d17/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac48d793bc06d2646244e070c25cc129e539d17/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7ac48d793bc06d2646244e070c25cc129e539d17", "patch": "@@ -824,34 +824,43 @@ impl AttributesExt for Attributes {\n     }\n }\n \n+enum PathKind {\n+    /// can be either value or type, not a macro\n+    Unknown,\n+    /// macro\n+    Macro,\n+    /// values, functions, consts, statics, everything in the value namespace\n+    Value,\n+    /// types, traits, everything in the type namespace\n+    Type\n+}\n impl Clean<Attributes> for [ast::Attribute] {\n     fn clean(&self, cx: &DocContext) -> Attributes {\n         let mut attrs = Attributes::from_ast(cx.sess().diagnostic(), self);\n \n         if UnstableFeatures::from_environment().is_nightly_build() {\n             let dox = attrs.collapsed_doc_value().unwrap_or_else(String::new);\n             for link in markdown_links(&dox, cx.render_type) {\n-                let path = {\n-                    let is_value;\n+                let def = {\n+                    let mut kind = PathKind::Unknown;\n                     let path_str = if let Some(prefix) =\n                         [\"struct\", \"enum\", \"type\",\n                          \"trait\", \"union\"].iter()\n                                           .find(|p| link.starts_with(**p)) {\n-                        is_value = Some(false);\n+                        kind = PathKind::Type;\n                         link.trim_left_matches(prefix).trim()\n                     } else if let Some(prefix) =\n                         [\"const\", \"static\"].iter()\n                                            .find(|p| link.starts_with(**p)) {\n-                        is_value = Some(true);\n+                        kind = PathKind::Value;\n                         link.trim_left_matches(prefix).trim()\n                     } else if link.ends_with(\"()\") {\n-                        is_value = Some(true);\n+                        kind = PathKind::Value;\n                         link.trim_right_matches(\"()\").trim()\n-                    } else if link.ends_with(\"!\") {\n-                        // FIXME (misdreavus): macros are resolved with different machinery\n-                        continue;\n+                    } else if link.ends_with('!') {\n+                        kind = PathKind::Macro;\n+                        link.trim_right_matches('!').trim()\n                     } else {\n-                        is_value = None;\n                         link.trim()\n                     };\n \n@@ -879,34 +888,68 @@ impl Clean<Attributes> for [ast::Attribute] {\n                         }\n                     };\n \n-                    if let Some(is_value) = is_value {\n-                        if let Ok(path) = resolve(is_value) {\n-                            path\n-                        } else {\n-                            // this could just be a normal link or a broken link\n-                            // we could potentially check if something is\n-                            // \"intra-doc-link-like\" and warn in that case\n-                            continue;\n+                    match kind {\n+                        PathKind::Value => {\n+                            if let Ok(path) = resolve(true) {\n+                                path.def\n+                            } else {\n+                                // this could just be a normal link or a broken link\n+                                // we could potentially check if something is\n+                                // \"intra-doc-link-like\" and warn in that case\n+                                continue;\n+                            }\n                         }\n-                    } else {\n-                        // try both!\n-                        // It is imperative we search for not-a-value first\n-                        // Otherwise we will find struct ctors for when we are looking\n-                        // for structs, etc, and the link won't work.\n-                        if let Ok(path) = resolve(false) {\n-                            path\n-                        } else if let Ok(path) = resolve(true) {\n-                            path\n-                        } else {\n-                            // this could just be a normal link\n-                            continue;\n+                        PathKind::Type => {\n+                            if let Ok(path) = resolve(false) {\n+                                path.def\n+                            } else {\n+                                // this could just be a normal link\n+                                continue;\n+                            }\n+                        }\n+                        PathKind::Unknown => {\n+                            // try both!\n+                            // It is imperative we search for not-a-value first\n+                            // Otherwise we will find struct ctors for when we are looking\n+                            // for structs, etc, and the link won't work.\n+                            if let Ok(path) = resolve(false) {\n+                                path.def\n+                            } else if let Ok(path) = resolve(true) {\n+                                path.def\n+                            } else {\n+                                // this could just be a normal link\n+                                continue;\n+                            }\n+                        }\n+                        PathKind::Macro => {\n+                            use syntax::ext::base::MacroKind;\n+                            use syntax::ext::hygiene::Mark;\n+                            let segment = ast::PathSegment {\n+                                identifier: ast::Ident::from_str(path_str),\n+                                span: DUMMY_SP,\n+                                parameters: None,\n+                            };\n+                            let path = ast::Path {\n+                                span: DUMMY_SP,\n+                                segments: vec![segment],\n+                            };\n+\n+                            let mut resolver = cx.resolver.borrow_mut();\n+                            let mark = Mark::root();\n+                            let res = resolver\n+                                .resolve_macro_to_def_inner(mark, &path, MacroKind::Bang, false);\n+                            if let Ok(def) = res {\n+                                def\n+                            } else {\n+                                continue;\n+                            }\n                         }\n                     }\n                 };\n \n-                register_def(cx, def);\n \n-                attrs.links.push((link, path.def.def_id()));\n+                register_def(cx, def);\n+                attrs.links.push((link, def.def_id()));\n             }\n \n             cx.sess().abort_if_errors();\n@@ -1970,6 +2013,7 @@ pub enum TypeKind {\n     Variant,\n     Typedef,\n     Foreign,\n+    Macro,\n }\n \n pub trait GetDefId {\n@@ -3271,6 +3315,7 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::TyForeign(i) => (i, TypeKind::Foreign),\n         Def::Static(i, _) => (i, TypeKind::Static),\n         Def::Variant(i) => (cx.tcx.parent_def_id(i).unwrap(), TypeKind::Enum),\n+        Def::Macro(i, _) => (i, TypeKind::Macro),\n         Def::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n         Def::SelfTy(_, Some(impl_def_id)) => {\n             return impl_def_id"}, {"sha": "e9c6488c49c6cb0f9c90ea74b268fc95b136f28e", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ac48d793bc06d2646244e070c25cc129e539d17/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac48d793bc06d2646244e070c25cc129e539d17/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=7ac48d793bc06d2646244e070c25cc129e539d17", "patch": "@@ -102,6 +102,7 @@ impl From<clean::TypeKind> for ItemType {\n             clean::TypeKind::Variant  => ItemType::Variant,\n             clean::TypeKind::Typedef  => ItemType::Typedef,\n             clean::TypeKind::Foreign  => ItemType::ForeignType,\n+            clean::TypeKind::Macro  => ItemType::Macro,\n         }\n     }\n }"}, {"sha": "b58a59f12173c5850145de360b6433d6229eede9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ac48d793bc06d2646244e070c25cc129e539d17/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ac48d793bc06d2646244e070c25cc129e539d17/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=7ac48d793bc06d2646244e070c25cc129e539d17", "patch": "@@ -1284,7 +1284,7 @@ impl DocFolder for Cache {\n             clean::FunctionItem(..) | clean::ModuleItem(..) |\n             clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n             clean::ConstantItem(..) | clean::StaticItem(..) |\n-            clean::UnionItem(..) | clean::ForeignTypeItem\n+            clean::UnionItem(..) | clean::ForeignTypeItem | clean::MacroItem(..)\n             if !self.stripped_mod => {\n                 // Re-exported items mean that the same id can show up twice\n                 // in the rustdoc ast that we're looking at. We know,"}]}