{"sha": "a421482e7515414ae4e5e9f76bf997c7f1e7398b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MjE0ODJlNzUxNTQxNGFlNGU1ZTlmNzZiZjk5N2M3ZjFlNzM5OGI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-02T16:18:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-02T16:18:42Z"}, "message": "Merge #9112\n\n9112: Fix some bugs in `extract_struct_from_enum_variant` assist r=Veykril a=Veykril\n\nbors r+\r\nFixes #9100\r\nFixes #9099\r\nKind of fixes  #9109, it now copies all the generics might be incorrect if the variant doesn't use all of them)\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "b7c860ee33b7d03f447e7a641abcc73d8fd92212", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7c860ee33b7d03f447e7a641abcc73d8fd92212"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a421482e7515414ae4e5e9f76bf997c7f1e7398b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgt69iCRBK7hj4Ov3rIwAAIvEIAJhsJy9kS+oz5BeQhW+CdmKH\nkEOjINqm7JpFjvu6RGQUFpAvHuIu/QwYmkWvBmnxCjL2kJsuizjrqX68fiFnBega\nCSi3sabKn5roo+dpaH5rA3jKTUm37CWci0jpny23tDHwY0i73Q9z8iyCDFojGuUM\nzvR8tuvoGuQXGoEcdLXUBI0yvx4oTuRKIyxh0o4Ribw3Rpwb/21zJ6MdyjZS96dh\n7uEt7fp/EFO2Os7Z62AAWMS20DU04Fg68ionULQq+3E4fOU7Yo6thmgXRHiherZt\n0oqSBGwfvQD8r9YiQYkb4fBIMTj2ZxkLjZhLAyFx4bCjO/4R80iSsvqsJbgIweo=\n=XbU2\n-----END PGP SIGNATURE-----\n", "payload": "tree b7c860ee33b7d03f447e7a641abcc73d8fd92212\nparent 2022cfce44f7c3d82dd354abeb2d40b570fa3ef4\nparent 6ffe1d99d4edd907ffa37493e1758ab1cbaf0617\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1622650722 +0000\ncommitter GitHub <noreply@github.com> 1622650722 +0000\n\nMerge #9112\n\n9112: Fix some bugs in `extract_struct_from_enum_variant` assist r=Veykril a=Veykril\n\nbors r+\r\nFixes #9100\r\nFixes #9099\r\nKind of fixes  #9109, it now copies all the generics might be incorrect if the variant doesn't use all of them)\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a421482e7515414ae4e5e9f76bf997c7f1e7398b", "html_url": "https://github.com/rust-lang/rust/commit/a421482e7515414ae4e5e9f76bf997c7f1e7398b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a421482e7515414ae4e5e9f76bf997c7f1e7398b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2022cfce44f7c3d82dd354abeb2d40b570fa3ef4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2022cfce44f7c3d82dd354abeb2d40b570fa3ef4", "html_url": "https://github.com/rust-lang/rust/commit/2022cfce44f7c3d82dd354abeb2d40b570fa3ef4"}, {"sha": "6ffe1d99d4edd907ffa37493e1758ab1cbaf0617", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ffe1d99d4edd907ffa37493e1758ab1cbaf0617", "html_url": "https://github.com/rust-lang/rust/commit/6ffe1d99d4edd907ffa37493e1758ab1cbaf0617"}], "stats": {"total": 174, "additions": 127, "deletions": 47}, "files": [{"sha": "d3ff7b65cd00989b1f6a25e7d161bb149eee0b1d", "filename": "crates/ide_assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 125, "deletions": 44, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/a421482e7515414ae4e5e9f76bf997c7f1e7398b/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a421482e7515414ae4e5e9f76bf997c7f1e7398b/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=a421482e7515414ae4e5e9f76bf997c7f1e7398b", "patch": "@@ -11,14 +11,19 @@ use ide_db::{\n     search::FileReference,\n     RootDatabase,\n };\n+use itertools::Itertools;\n use rustc_hash::FxHashSet;\n use syntax::{\n-    algo::find_node_at_offset,\n-    ast::{self, make, AstNode, NameOwner, VisibilityOwner},\n-    ted, SyntaxNode, T,\n+    ast::{\n+        self, make, AstNode, AttrsOwner, GenericParamsOwner, NameOwner, TypeBoundsOwner,\n+        VisibilityOwner,\n+    },\n+    match_ast,\n+    ted::{self, Position},\n+    SyntaxNode, T,\n };\n \n-use crate::{AssistContext, AssistId, AssistKind, Assists};\n+use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: extract_struct_from_enum_variant\n //\n@@ -70,11 +75,10 @@ pub(crate) fn extract_struct_from_enum_variant(\n                     continue;\n                 }\n                 builder.edit_file(file_id);\n-                let source_file = builder.make_mut(ctx.sema.parse(file_id));\n                 let processed = process_references(\n                     ctx,\n+                    builder,\n                     &mut visited_modules_set,\n-                    source_file.syntax(),\n                     &enum_module_def,\n                     &variant_hir_name,\n                     references,\n@@ -84,13 +88,12 @@ pub(crate) fn extract_struct_from_enum_variant(\n                 });\n             }\n             builder.edit_file(ctx.frange.file_id);\n-            let source_file = builder.make_mut(ctx.sema.parse(ctx.frange.file_id));\n             let variant = builder.make_mut(variant.clone());\n             if let Some(references) = def_file_references {\n                 let processed = process_references(\n                     ctx,\n+                    builder,\n                     &mut visited_modules_set,\n-                    source_file.syntax(),\n                     &enum_module_def,\n                     &variant_hir_name,\n                     references,\n@@ -100,12 +103,12 @@ pub(crate) fn extract_struct_from_enum_variant(\n                 });\n             }\n \n-            let def = create_struct_def(variant_name.clone(), &field_list, enum_ast.visibility());\n+            let def = create_struct_def(variant_name.clone(), &field_list, &enum_ast);\n             let start_offset = &variant.parent_enum().syntax().clone();\n             ted::insert_raw(ted::Position::before(start_offset), def.syntax());\n             ted::insert_raw(ted::Position::before(start_offset), &make::tokens::blank_line());\n \n-            update_variant(&variant);\n+            update_variant(&variant, enum_ast.generic_param_list());\n         },\n     )\n }\n@@ -149,7 +152,7 @@ fn existing_definition(db: &RootDatabase, variant_name: &ast::Name, variant: &Va\n fn create_struct_def(\n     variant_name: ast::Name,\n     field_list: &Either<ast::RecordFieldList, ast::TupleFieldList>,\n-    visibility: Option<ast::Visibility>,\n+    enum_: &ast::Enum,\n ) -> ast::Struct {\n     let pub_vis = make::visibility_pub();\n \n@@ -184,12 +187,38 @@ fn create_struct_def(\n         }\n     };\n \n-    make::struct_(visibility, variant_name, None, field_list).clone_for_update()\n+    // FIXME: This uses all the generic params of the enum, but the variant might not use all of them.\n+    let strukt =\n+        make::struct_(enum_.visibility(), variant_name, enum_.generic_param_list(), field_list)\n+            .clone_for_update();\n+\n+    // copy attributes\n+    ted::insert_all(\n+        Position::first_child_of(strukt.syntax()),\n+        enum_.attrs().map(|it| it.syntax().clone_for_update().into()).collect(),\n+    );\n+    strukt\n }\n \n-fn update_variant(variant: &ast::Variant) -> Option<()> {\n+fn update_variant(variant: &ast::Variant, generic: Option<ast::GenericParamList>) -> Option<()> {\n     let name = variant.name()?;\n-    let tuple_field = make::tuple_field(None, make::ty(&name.text()));\n+    let ty = match generic {\n+        // FIXME: This uses all the generic params of the enum, but the variant might not use all of them.\n+        Some(gpl) => {\n+            let gpl = gpl.clone_for_update();\n+            gpl.generic_params().for_each(|gp| {\n+                match gp {\n+                    ast::GenericParam::LifetimeParam(it) => it.type_bound_list(),\n+                    ast::GenericParam::TypeParam(it) => it.type_bound_list(),\n+                    ast::GenericParam::ConstParam(_) => return,\n+                }\n+                .map(|it| it.remove());\n+            });\n+            make::ty(&format!(\"{}<{}>\", name.text(), gpl.generic_params().join(\", \")))\n+        }\n+        None => make::ty(&name.text()),\n+    };\n+    let tuple_field = make::tuple_field(None, ty);\n     let replacement = make::variant(\n         name,\n         Some(ast::FieldList::TupleFieldList(make::tuple_field_list(iter::once(tuple_field)))),\n@@ -208,18 +237,17 @@ fn apply_references(\n     if let Some((scope, path)) = import {\n         insert_use(&scope, mod_path_to_ast(&path), insert_use_cfg);\n     }\n-    ted::insert_raw(\n-        ted::Position::before(segment.syntax()),\n-        make::path_from_text(&format!(\"{}\", segment)).clone_for_update().syntax(),\n-    );\n+    // deep clone to prevent cycle\n+    let path = make::path_from_segments(iter::once(segment.clone_subtree()), false);\n+    ted::insert_raw(ted::Position::before(segment.syntax()), path.clone_for_update().syntax());\n     ted::insert_raw(ted::Position::before(segment.syntax()), make::token(T!['(']));\n     ted::insert_raw(ted::Position::after(&node), make::token(T![')']));\n }\n \n fn process_references(\n     ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n     visited_modules: &mut FxHashSet<Module>,\n-    source_file: &SyntaxNode,\n     enum_module_def: &ModuleDef,\n     variant_hir_name: &Name,\n     refs: Vec<FileReference>,\n@@ -228,8 +256,9 @@ fn process_references(\n     // and corresponding nodes up front\n     refs.into_iter()\n         .flat_map(|reference| {\n-            let (segment, scope_node, module) =\n-                reference_to_node(&ctx.sema, source_file, reference)?;\n+            let (segment, scope_node, module) = reference_to_node(&ctx.sema, reference)?;\n+            let segment = builder.make_mut(segment);\n+            let scope_node = builder.make_syntax_mut(scope_node);\n             if !visited_modules.contains(&module) {\n                 let mod_path = module.find_use_path_prefixed(\n                     ctx.sema.db,\n@@ -251,23 +280,22 @@ fn process_references(\n \n fn reference_to_node(\n     sema: &hir::Semantics<RootDatabase>,\n-    source_file: &SyntaxNode,\n     reference: FileReference,\n ) -> Option<(ast::PathSegment, SyntaxNode, hir::Module)> {\n-    let offset = reference.range.start();\n-    if let Some(path_expr) = find_node_at_offset::<ast::PathExpr>(source_file, offset) {\n-        // tuple variant\n-        Some((path_expr.path()?.segment()?, path_expr.syntax().parent()?))\n-    } else if let Some(record_expr) = find_node_at_offset::<ast::RecordExpr>(source_file, offset) {\n-        // record variant\n-        Some((record_expr.path()?.segment()?, record_expr.syntax().clone()))\n-    } else {\n-        None\n-    }\n-    .and_then(|(segment, expr)| {\n-        let module = sema.scope(&expr).module()?;\n-        Some((segment, expr, module))\n-    })\n+    let segment =\n+        reference.name.as_name_ref()?.syntax().parent().and_then(ast::PathSegment::cast)?;\n+    let parent = segment.parent_path().syntax().parent()?;\n+    let expr_or_pat = match_ast! {\n+        match parent {\n+            ast::PathExpr(_it) => parent.parent()?,\n+            ast::RecordExpr(_it) => parent,\n+            ast::TupleStructPat(_it) => parent,\n+            ast::RecordPat(_it) => parent,\n+            _ => return None,\n+        }\n+    };\n+    let module = sema.scope(&expr_or_pat).module()?;\n+    Some((segment, expr_or_pat, module))\n }\n \n #[cfg(test)]\n@@ -278,6 +306,12 @@ mod tests {\n \n     use super::*;\n \n+    fn check_not_applicable(ra_fixture: &str) {\n+        let fixture =\n+            format!(\"//- /main.rs crate:main deps:core\\n{}\\n{}\", ra_fixture, FamousDefs::FIXTURE);\n+        check_assist_not_applicable(extract_struct_from_enum_variant, &fixture)\n+    }\n+\n     #[test]\n     fn test_extract_struct_several_fields_tuple() {\n         check_assist(\n@@ -311,6 +345,32 @@ enum A { One(One) }\"#,\n         );\n     }\n \n+    #[test]\n+    fn test_extract_struct_carries_over_generics() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            r\"enum En<T> { Var { a: T$0 } }\",\n+            r#\"struct Var<T>{ pub a: T }\n+\n+enum En<T> { Var(Var<T>) }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_carries_over_attributes() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            r#\"#[derive(Debug)]\n+#[derive(Clone)]\n+enum Enum { Variant{ field: u32$0 } }\"#,\n+            r#\"#[derive(Debug)]#[derive(Clone)] struct Variant{ pub field: u32 }\n+\n+#[derive(Debug)]\n+#[derive(Clone)]\n+enum Enum { Variant(Variant) }\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_extract_struct_keep_comments_and_attrs_one_field_named() {\n         check_assist(\n@@ -496,7 +556,7 @@ enum E {\n }\n \n fn f() {\n-    let e = E::V { i: 9, j: 2 };\n+    let E::V { i, j } = E::V { i: 9, j: 2 };\n }\n \"#,\n             r#\"\n@@ -507,7 +567,34 @@ enum E {\n }\n \n fn f() {\n-    let e = E::V(V { i: 9, j: 2 });\n+    let E::V(V { i, j }) = E::V(V { i: 9, j: 2 });\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn extract_record_fix_references2() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            r#\"\n+enum E {\n+    $0V(i32, i32)\n+}\n+\n+fn f() {\n+    let E::V(i, j) = E::V(9, 2);\n+}\n+\"#,\n+            r#\"\n+struct V(pub i32, pub i32);\n+\n+enum E {\n+    V(V)\n+}\n+\n+fn f() {\n+    let E::V(V(i, j)) = E::V(V(9, 2));\n }\n \"#,\n         )\n@@ -610,12 +697,6 @@ fn foo() {\n         );\n     }\n \n-    fn check_not_applicable(ra_fixture: &str) {\n-        let fixture =\n-            format!(\"//- /main.rs crate:main deps:core\\n{}\\n{}\", ra_fixture, FamousDefs::FIXTURE);\n-        check_assist_not_applicable(extract_struct_from_enum_variant, &fixture)\n-    }\n-\n     #[test]\n     fn test_extract_enum_not_applicable_for_element_with_no_fields() {\n         check_not_applicable(\"enum A { $0One }\");"}, {"sha": "4c3c9661d44d2ac3d3a31b89fbbdca11ee1f9913", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a421482e7515414ae4e5e9f76bf997c7f1e7398b/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a421482e7515414ae4e5e9f76bf997c7f1e7398b/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=a421482e7515414ae4e5e9f76bf997c7f1e7398b", "patch": "@@ -580,12 +580,11 @@ pub fn fn_(\n pub fn struct_(\n     visibility: Option<ast::Visibility>,\n     strukt_name: ast::Name,\n-    type_params: Option<ast::GenericParamList>,\n+    generic_param_list: Option<ast::GenericParamList>,\n     field_list: ast::FieldList,\n ) -> ast::Struct {\n     let semicolon = if matches!(field_list, ast::FieldList::TupleFieldList(_)) { \";\" } else { \"\" };\n-    let type_params =\n-        if let Some(type_params) = type_params { format!(\"<{}>\", type_params) } else { \"\".into() };\n+    let type_params = generic_param_list.map_or_else(String::new, |it| it.to_string());\n     let visibility = match visibility {\n         None => String::new(),\n         Some(it) => format!(\"{} \", it),"}]}