{"sha": "697d13084476d8058423b226578a58a8c7d5c86a", "node_id": "C_kwDOAAsO6NoAKDY5N2QxMzA4NDQ3NmQ4MDU4NDIzYjIyNjU3OGE1OGE4YzdkNWM4NmE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-04-30T20:35:29Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-04-30T20:35:29Z"}, "message": "Merge from rustc", "tree": {"sha": "5e9698aacd7b6e8cbba75b99192af034868e7d78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e9698aacd7b6e8cbba75b99192af034868e7d78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/697d13084476d8058423b226578a58a8c7d5c86a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/697d13084476d8058423b226578a58a8c7d5c86a", "html_url": "https://github.com/rust-lang/rust/commit/697d13084476d8058423b226578a58a8c7d5c86a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/697d13084476d8058423b226578a58a8c7d5c86a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e52cc12df16eab3637d256987d7e6d0b81836b5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e52cc12df16eab3637d256987d7e6d0b81836b5d", "html_url": "https://github.com/rust-lang/rust/commit/e52cc12df16eab3637d256987d7e6d0b81836b5d"}, {"sha": "eb62877597000ccf8bb99ab131b5977344afdfa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb62877597000ccf8bb99ab131b5977344afdfa3", "html_url": "https://github.com/rust-lang/rust/commit/eb62877597000ccf8bb99ab131b5977344afdfa3"}], "stats": {"total": 48889, "additions": 30017, "deletions": 18872}, "files": [{"sha": "d065fa46469fcf8e619b2de07d522694c7d3b413", "filename": ".editorconfig", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/.editorconfig", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/.editorconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.editorconfig?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -20,3 +20,6 @@ trim_trailing_whitespace = false\n \n [*.yml]\n indent_size = 2\n+\n+[Makefile]\n+indent_style = tab"}, {"sha": "4c445f635d7d25be6ce7c3311cfe34c98076dd62", "filename": ".git-blame-ignore-revs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/.git-blame-ignore-revs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/.git-blame-ignore-revs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.git-blame-ignore-revs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -12,3 +12,5 @@ a06baa56b95674fc626b3c3fd680d6a65357fe60\n c34fbfaad38cf5829ef5cfe780dc9d58480adeaa\n # move tests\n cf2dff2b1e3fa55fa5415d524200070d0d7aacfe\n+# Run rustfmt on bootstrap\n+b39a1d6f1a30ba29f25d7141038b9a5bf0126e36"}, {"sha": "934312662beb66fe5f3f9e07a5d59f1600b0238e", "filename": ".github/ISSUE_TEMPLATE/library_tracking_issue.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/.github%2FISSUE_TEMPLATE%2Flibrary_tracking_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/.github%2FISSUE_TEMPLATE%2Flibrary_tracking_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Flibrary_tracking_issue.md?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -12,7 +12,7 @@ Tracking issues are for tracking a feature from implementation to stabilization.\n Make sure to include the relevant RFC for the feature if it has one.\n \n If the new feature is small, it may be fine to skip the RFC process. In that\n-case, you can use use `issue = \"none\"` in your initial implementation PR. The\n+case, you can use `issue = \"none\"` in your initial implementation PR. The\n reviewer will ask you to open a tracking issue if they agree your feature can be\n added without an RFC.\n -->\n@@ -65,7 +65,7 @@ the rfcbot will ask all the team members to verify they agree with\n stabilization. Once enough members agree and there are no concerns, the final\n comment period begins: this issue will be marked as such and will be listed\n in the next This Week in Rust newsletter. If no blocking concerns are raised in\n-that period of 10 days, a stabilzation PR can be opened by anyone.\n+that period of 10 days, a stabilization PR can be opened by anyone.\n -->\n \n ### Unresolved Questions"}, {"sha": "32c18cab09902245029b78addd4649b80bec2dc1", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 46, "deletions": 42, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -181,70 +181,70 @@ jobs:\n               - ARM64\n               - linux\n           - name: arm-android\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: armhf-gnu\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-aarch64-linux\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-android\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-arm-linux\n             os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-armhf-linux\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-armv7-linux\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-i586-gnu-i586-i686-musl\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-i686-linux\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-mips-linux\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-mips64-linux\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-mips64el-linux\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-mipsel-linux\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-powerpc-linux\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-powerpc64-linux\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-powerpc64le-linux\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-riscv64-linux\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-s390x-linux\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-various-1\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-various-2\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-x86_64-freebsd\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-x86_64-illumos\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-x86_64-linux\n             os: ubuntu-20.04-16core-64gb\n@@ -254,10 +254,10 @@ jobs:\n               IMAGE: dist-x86_64-linux\n             os: ubuntu-20.04-16core-64gb\n           - name: dist-x86_64-musl\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: dist-x86_64-netbsd\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: i686-gnu\n             os: ubuntu-20.04-16core-64gb\n@@ -266,51 +266,55 @@ jobs:\n             os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: mingw-check\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: test-various\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: wasm32\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: x86_64-gnu\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: x86_64-gnu-stable\n             env:\n               IMAGE: x86_64-gnu\n               RUST_CI_OVERRIDE_RELEASE_CHANNEL: stable\n               CI_ONLY_WHEN_CHANNEL: nightly\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n           - name: x86_64-gnu-aux\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: x86_64-gnu-debug\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: x86_64-gnu-distcheck\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n+          - name: x86_64-gnu-llvm-16\n+            env:\n+              RUST_BACKTRACE: 1\n+            os: ubuntu-20.04-8core-32gb\n           - name: x86_64-gnu-llvm-15\n             env:\n               RUST_BACKTRACE: 1\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n           - name: x86_64-gnu-llvm-14\n             env:\n               RUST_BACKTRACE: 1\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n           - name: x86_64-gnu-llvm-14-stage1\n             env:\n               RUST_BACKTRACE: 1\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n           - name: x86_64-gnu-nopt\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n             env: {}\n           - name: x86_64-gnu-tools\n             env:\n               DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n-            os: ubuntu-20.04-16core-64gb\n+            os: ubuntu-20.04-8core-32gb\n           - name: dist-x86_64-apple\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --host=x86_64-apple-darwin --target=x86_64-apple-darwin\"\n@@ -322,7 +326,7 @@ jobs:\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: macos-12-xl\n+            os: macos-latest\n           - name: dist-apple-various\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --host='' --target=aarch64-apple-ios,x86_64-apple-ios,aarch64-apple-ios-sim\"\n@@ -333,7 +337,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-12-xl\n+            os: macos-latest\n           - name: dist-x86_64-apple-alt\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths\"\n@@ -344,7 +348,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-12-xl\n+            os: macos-latest\n           - name: x86_64-apple-1\n             env:\n               SCRIPT: \"./x.py --stage 2 test --exclude tests/ui --exclude tests/rustdoc --exclude tests/run-make-fulldeps\"\n@@ -355,7 +359,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-12-xl\n+            os: macos-latest\n           - name: x86_64-apple-2\n             env:\n               SCRIPT: \"./x.py --stage 2 test tests/ui tests/rustdoc tests/run-make-fulldeps\"\n@@ -366,7 +370,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-12-xl\n+            os: macos-latest\n           - name: dist-aarch64-apple\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --stage 2\"\n@@ -381,7 +385,7 @@ jobs:\n               NO_OVERFLOW_CHECKS: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n               JEMALLOC_SYS_WITH_LG_PAGE: 14\n-            os: macos-12-xl\n+            os: macos-latest\n           - name: x86_64-msvc-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\""}, {"sha": "dc12737851e410ceefcad93e6a23453c3081b0db", "filename": "Cargo.lock", "status": "modified", "additions": 346, "deletions": 1812, "changes": 2158, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=697d13084476d8058423b226578a58a8c7d5c86a"}, {"sha": "a497d7321e02cb212d3df83261f4d025786e1446", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -22,12 +22,6 @@ members = [\n   \"src/tools/remote-test-server\",\n   \"src/tools/rust-installer\",\n   \"src/tools/rust-demangler\",\n-  \"src/tools/cargo\",\n-  \"src/tools/cargo/crates/credential/cargo-credential-1password\",\n-  \"src/tools/cargo/crates/credential/cargo-credential-macos-keychain\",\n-  \"src/tools/cargo/crates/credential/cargo-credential-wincred\",\n-  \"src/tools/cargo/crates/mdman\",\n-  # \"src/tools/cargo/crates/resolver-tests\",\n   \"src/tools/rustdoc\",\n   \"src/tools/rls\",\n   \"src/tools/rustfmt\",\n@@ -44,6 +38,7 @@ members = [\n   \"src/tools/lld-wrapper\",\n   \"src/tools/collect-license-metadata\",\n   \"src/tools/generate-copyright\",\n+  \"src/tools/suggest-tests\",\n ]\n \n exclude = [\n@@ -105,10 +100,6 @@ miniz_oxide.debug = 0\n object.debug = 0\n \n [patch.crates-io]\n-# See comments in `src/tools/rustc-workspace-hack/README.md` for what's going on\n-# here\n-rustc-workspace-hack = { path = 'src/tools/rustc-workspace-hack' }\n-\n # See comments in `library/rustc-std-workspace-core/README.md` for what's going on\n # here\n rustc-std-workspace-core = { path = 'library/rustc-std-workspace-core' }"}, {"sha": "41b135972af11458ebc394377610af743f8731ae", "filename": "README.md", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -22,6 +22,8 @@ Read [\"Installation\"] from [The Book].\n \n The Rust build system uses a Python script called `x.py` to build the compiler,\n which manages the bootstrapping process. It lives at the root of the project.\n+It also uses a file named `config.toml` to determine various configuration settings for the build.\n+You can see a full list of options in `config.example.toml`.\n \n The `x.py` command can be run directly on most Unix systems in the following\n format:\n@@ -85,6 +87,8 @@ See [the rustc-dev-guide for more info][sysllvm].\n \n ### Building on a Unix-like system\n \n+#### Build steps\n+\n 1. Clone the [source] with `git`:\n \n    ```sh\n@@ -96,18 +100,13 @@ See [the rustc-dev-guide for more info][sysllvm].\n \n 2. Configure the build settings:\n \n-   The Rust build system uses a file named `config.toml` in the root of the\n-   source tree to determine various configuration settings for the build.\n-   Set up the defaults intended for distros to get started. You can see a full\n-   list of options in `config.example.toml`.\n-\n    ```sh\n-   printf 'profile = \"user\" \\nchangelog-seen = 2 \\n' > config.toml\n+   ./configure\n    ```\n \n    If you plan to use `x.py install` to create an installation, it is\n    recommended that you set the `prefix` value in the `[install]` section to a\n-   directory.\n+   directory: `./configure --set install.prefix=<path>`\n \n 3. Build and install:\n \n@@ -117,12 +116,25 @@ See [the rustc-dev-guide for more info][sysllvm].\n \n    When complete, `./x.py install` will place several programs into\n    `$PREFIX/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n-   API-documentation tool. If you've set `profile = \"user\"` or\n-   `build.extended = true`, it will also include [Cargo], Rust's package\n-   manager.\n+   API-documentation tool. By default, it will also include [Cargo], Rust's package manager.\n+   You can disable this behavior by passing `--set build.extended=false` to `./configure`.\n \n [Cargo]: https://github.com/rust-lang/cargo\n \n+#### Configure and Make\n+\n+This project provides a configure script and makefile (the latter of which just invokes `x.py`).\n+`./configure` is the recommended way to programatically generate a `config.toml`. `make` is not\n+recommended (we suggest using `x.py` directly), but it is supported and we try not to break it\n+unnecessarily.\n+\n+```sh\n+./configure\n+make && sudo make install\n+```\n+\n+`configure` generates a `config.toml` which can also be used with normal `x.py` invocations.\n+\n ### Building on Windows\n \n On Windows, we suggest using [winget] to install dependencies by running the\n@@ -186,7 +198,7 @@ toolchain.\n 4. Navigate to Rust's source code (or clone it), then build it:\n \n    ```sh\n-   ./x.py build && ./x.py install\n+   python x.py setup user && python x.py build && python x.py install\n    ```\n \n #### MSVC\n@@ -204,6 +216,7 @@ With these dependencies installed, you can build the compiler in a `cmd.exe`\n shell with:\n \n ```sh\n+python x.py setup user\n python x.py build\n ```\n \n@@ -232,21 +245,7 @@ Windows build triples are:\n \n The build triple can be specified by either specifying `--build=<triple>` when\n invoking `x.py` commands, or by creating a `config.toml` file (as described in\n-[Installing from Source](#installing-from-source)), and modifying the `build`\n-option under the `[build]` section.\n-\n-### Configure and Make\n-\n-While it's not the recommended build system, this project also provides a\n-configure script and makefile (the latter of which just invokes `x.py`).\n-\n-```sh\n-./configure\n-make && sudo make install\n-```\n-\n-`configure` generates a `config.toml` which can also be used with normal `x.py`\n-invocations.\n+[Building on a Unix-like system](#building-on-a-unix-like-system)), and passing `--set build.build=<triple>` to `./configure`.\n \n ## Building Documentation\n "}, {"sha": "e72905c15bd256864b7ad67419a0c66295baf4c5", "filename": "RELEASES.md", "status": "modified", "additions": 111, "deletions": 5, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,3 +1,109 @@\n+Version 1.69.0 (2023-04-20)\n+==========================\n+\n+<a id=\"1.69.0-Language\"></a>\n+\n+Language\n+--------\n+\n+- [Deriving built-in traits on packed structs works with `Copy` fields.](https://github.com/rust-lang/rust/pull/104429/)\n+- [Stabilize the `cmpxchg16b` target feature on x86 and x86_64.](https://github.com/rust-lang/rust/pull/106774/)\n+- [Improve analysis of trait bounds for associated types.](https://github.com/rust-lang/rust/pull/103695/)\n+- [Allow associated types to be used as union fields.](https://github.com/rust-lang/rust/pull/106938/)\n+- [Allow `Self: Autotrait` bounds on dyn-safe trait methods.](https://github.com/rust-lang/rust/pull/107082/)\n+- [Treat `str` as containing `[u8]` for auto trait purposes.](https://github.com/rust-lang/rust/pull/107941/)\n+\n+<a id=\"1.69.0-Compiler\"></a>\n+\n+Compiler\n+--------\n+\n+- [Upgrade `*-pc-windows-gnu` on CI to mingw-w64 v10 and GCC 12.2.](https://github.com/rust-lang/rust/pull/100178/)\n+- [Rework min_choice algorithm of member constraints.](https://github.com/rust-lang/rust/pull/105300/)\n+- [Support `true` and `false` as boolean flags in compiler arguments.](https://github.com/rust-lang/rust/pull/107043/)\n+- [Default `repr(C)` enums to `c_int` size.](https://github.com/rust-lang/rust/pull/107592/)\n+\n+<a id=\"1.69.0-Libraries\"></a>\n+\n+Libraries\n+---------\n+\n+- [Implement the unstable `DispatchFromDyn` for cell types, allowing downstream experimentation with custom method receivers.](https://github.com/rust-lang/rust/pull/97373/)\n+- [Document that `fmt::Arguments::as_str()` may return `Some(_)` in more cases after optimization, subject to change.](https://github.com/rust-lang/rust/pull/106823/)\n+- [Implement `AsFd` and `AsRawFd` for `Rc`.](https://github.com/rust-lang/rust/pull/107317/)\n+\n+<a id=\"1.69.0-Stabilized-APIs\"></a>\n+\n+Stabilized APIs\n+---------------\n+\n+- [`CStr::from_bytes_until_nul`](https://doc.rust-lang.org/stable/core/ffi/struct.CStr.html#method.from_bytes_until_nul)\n+- [`core::ffi::FromBytesUntilNulError`](https://doc.rust-lang.org/stable/core/ffi/struct.FromBytesUntilNulError.html)\n+\n+These APIs are now stable in const contexts:\n+\n+- [`SocketAddr::new`](https://doc.rust-lang.org/stable/std/net/enum.SocketAddr.html#method.new)\n+- [`SocketAddr::ip`](https://doc.rust-lang.org/stable/std/net/enum.SocketAddr.html#method.ip)\n+- [`SocketAddr::port`](https://doc.rust-lang.org/stable/std/net/enum.SocketAddr.html#method.port)\n+- [`SocketAddr::is_ipv4`](https://doc.rust-lang.org/stable/std/net/enum.SocketAddr.html#method.is_ipv4)\n+- [`SocketAddr::is_ipv6`](https://doc.rust-lang.org/stable/std/net/enum.SocketAddr.html#method.is_ipv6)\n+- [`SocketAddrV4::new`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV4.html#method.new)\n+- [`SocketAddrV4::ip`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV4.html#method.ip)\n+- [`SocketAddrV4::port`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV4.html#method.port)\n+- [`SocketAddrV6::new`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV6.html#method.new)\n+- [`SocketAddrV6::ip`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV6.html#method.ip)\n+- [`SocketAddrV6::port`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV6.html#method.port)\n+- [`SocketAddrV6::flowinfo`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV6.html#method.flowinfo)\n+- [`SocketAddrV6::scope_id`](https://doc.rust-lang.org/stable/std/net/struct.SocketAddrV6.html#method.scope_id)\n+\n+<a id=\"1.69.0-Cargo\"></a>\n+\n+Cargo\n+-----\n+\n+- [Cargo now suggests `cargo fix` or `cargo clippy --fix` when compilation warnings are auto-fixable.](https://github.com/rust-lang/cargo/pull/11558/)\n+- [Cargo now suggests `cargo add` if you try to install a library crate.](https://github.com/rust-lang/cargo/pull/11410/)\n+- [Cargo now sets the `CARGO_BIN_NAME` environment variable also for binary examples.](https://github.com/rust-lang/cargo/pull/11705/)\n+\n+<a id=\"1.69.0-Rustdoc\"></a>\n+\n+Rustdoc\n+-----\n+\n+- [Vertically compact trait bound formatting.](https://github.com/rust-lang/rust/pull/102842/)\n+- [Only include stable lints in `rustdoc::all` group.](https://github.com/rust-lang/rust/pull/106316/)\n+- [Compute maximum Levenshtein distance based on the query.](https://github.com/rust-lang/rust/pull/107141/)\n+- [Remove inconsistently-present sidebar tooltips.](https://github.com/rust-lang/rust/pull/107490/)\n+- [Search by macro when query ends with `!`.](https://github.com/rust-lang/rust/pull/108143/)\n+\n+<a id=\"1.69.0-Compatibility-Notes\"></a>\n+\n+Compatibility Notes\n+-------------------\n+\n+- [The `rust-analysis` component from `rustup` now only contains a warning placeholder.](https://github.com/rust-lang/rust/pull/101841/) This was primarily intended for RLS, and the corresponding `-Zsave-analysis` flag has been removed from the compiler as well.\n+- [Unaligned references to packed fields are now a hard error.](https://github.com/rust-lang/rust/pull/102513/) This has been a warning since 1.53, and denied by default with a future-compatibility warning since 1.62.\n+- [Update the minimum external LLVM to 14.](https://github.com/rust-lang/rust/pull/107573/)\n+- [Cargo now emits errors on invalid characters in a registry token.](https://github.com/rust-lang/cargo/pull/11600/)\n+- [When `default-features` is set to false of a workspace dependency, and an inherited dependency of a member has `default-features = true`, Cargo will enable default features of that dependency.](https://github.com/rust-lang/cargo/pull/11409/)\n+- [Cargo denies `CARGO_HOME` in the `[env]` configuration table. Cargo itself doesn't pick up this value, but recursive calls to cargo would, which was not intended.](https://github.com/rust-lang/cargo/pull/11644/)\n+- [Debuginfo for build dependencies is now off if not explicitly set. This is expected to improve the overall build time.](https://github.com/rust-lang/cargo/pull/11252/)\n+- [The Rust distribution no longer always includes rustdoc](https://github.com/rust-lang/rust/pull/106886)\n+  If `tools = [...]` is set in config.toml, we will respect a missing rustdoc in that list. By\n+  default rustdoc remains included. To retain the prior behavior explicitly add `\"rustdoc\"` to the\n+  list.\n+  \n+<a id=\"1.69.0-Internal-Changes\"></a>\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- [Move `format_args!()` into AST (and expand it during AST lowering)](https://github.com/rust-lang/rust/pull/106745/)\n+\n Version 1.68.2 (2023-03-28)\n ===========================\n \n@@ -861,7 +967,7 @@ Compatibility Notes\n - [rustdoc: doctests are now run on unexported `macro_rules!` macros, matching other private items][96630]\n - [rustdoc: Remove .woff font files][96279]\n - [Enforce Copy bounds for repeat elements while considering lifetimes][95819]\n-- [Windows: Fix potentinal unsoundness by aborting if `File` reads or writes cannot\n+- [Windows: Fix potential unsoundness by aborting if `File` reads or writes cannot\n   complete synchronously][95469].\n \n Internal Changes\n@@ -1692,10 +1798,10 @@ Libraries\n - [impl Default, Copy, Clone for std::io::Sink and std::io::Empty][rust#86744]\n - [`impl From<[(K, V); N]>` for all collections.][rust#84111]\n - [Remove `P: Unpin` bound on impl Future for Pin.][rust#81363]\n-- [Treat invalid environment variable names as non-existent.][rust#86183]\n+- [Treat invalid environment variable names as nonexistent.][rust#86183]\n   Previously, the environment functions would panic if given a variable name\n   with an internal null character or equal sign (`=`). Now, these functions will\n-  just treat such names as non-existent variables, since the OS cannot represent\n+  just treat such names as nonexistent variables, since the OS cannot represent\n   the existence of a variable with such a name.\n \n Stabilised APIs\n@@ -1888,7 +1994,7 @@ Compatibility Notes\n   kinds of errors could be categorised [into newer more specific `ErrorKind`\n   variants][79965], and that they do not represent a user error.\n - [Using environment variable names with `process::Command` on Windows now\n-  behaves as expected.][85270] Previously using envionment variables with\n+  behaves as expected.][85270] Previously using environment variables with\n   `Command` would cause them to be ASCII-uppercased.\n - [Rustdoc will now warn on using rustdoc lints that aren't prefixed\n   with `rustdoc::`][86849]\n@@ -6265,7 +6371,7 @@ eg. `static MINUTE: Duration = Duration::from_secs(60);`\n \n Cargo\n -----\n-- [`cargo new` no longer removes `rust` or `rs` prefixs/suffixs.][cargo/5013]\n+- [`cargo new` no longer removes `rust` or `rs` prefixes/suffixes.][cargo/5013]\n - [`cargo new` now defaults to creating a binary crate, instead of a\n   library crate.][cargo/5029]\n "}, {"sha": "b4597d5bc78450eee640215a88d51c042ed74d23", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 374, "deletions": 213, "changes": 587, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,4 +1,5 @@\n use super::*;\n+use std::fmt::Write;\n use std::{borrow::Borrow, cmp, iter, ops::Bound};\n \n #[cfg(feature = \"randomize\")]\n@@ -49,219 +50,60 @@ pub trait LayoutCalculator {\n         repr: &ReprOptions,\n         kind: StructKind,\n     ) -> Option<LayoutS> {\n-        let pack = repr.pack;\n-        let mut align = if pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n-        let mut inverse_memory_index: IndexVec<u32, FieldIdx> = fields.indices().collect();\n-        let optimize = !repr.inhibit_struct_field_reordering_opt();\n-        if optimize {\n-            let end =\n-                if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n-            let optimizing = &mut inverse_memory_index.raw[..end];\n-            let effective_field_align = |layout: Layout<'_>| {\n-                if let Some(pack) = pack {\n-                    // return the packed alignment in bytes\n-                    layout.align().abi.min(pack).bytes()\n-                } else {\n-                    // returns log2(effective-align).\n-                    // This is ok since `pack` applies to all fields equally.\n-                    // The calculation assumes that size is an integer multiple of align, except for ZSTs.\n-                    //\n-                    // group [u8; 4] with align-4 or [u8; 6] with align-2 fields\n-                    layout.align().abi.bytes().max(layout.size().bytes()).trailing_zeros() as u64\n-                }\n-            };\n-\n-            // If `-Z randomize-layout` was enabled for the type definition we can shuffle\n-            // the field ordering to try and catch some code making assumptions about layouts\n-            // we don't guarantee\n-            if repr.can_randomize_type_layout() && cfg!(feature = \"randomize\") {\n-                #[cfg(feature = \"randomize\")]\n-                {\n-                    // `ReprOptions.layout_seed` is a deterministic seed that we can use to\n-                    // randomize field ordering with\n-                    let mut rng = Xoshiro128StarStar::seed_from_u64(repr.field_shuffle_seed);\n-\n-                    // Shuffle the ordering of the fields\n-                    optimizing.shuffle(&mut rng);\n-                }\n-                // Otherwise we just leave things alone and actually optimize the type's fields\n-            } else {\n-                match kind {\n-                    StructKind::AlwaysSized | StructKind::MaybeUnsized => {\n-                        optimizing.sort_by_key(|&x| {\n-                            // Place ZSTs first to avoid \"interesting offsets\",\n-                            // especially with only one or two non-ZST fields.\n-                            // Then place largest alignments first, largest niches within an alignment group last\n-                            let f = fields[x];\n-                            let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n-                            (!f.0.is_zst(), cmp::Reverse(effective_field_align(f)), niche_size)\n-                        });\n-                    }\n-\n-                    StructKind::Prefixed(..) => {\n-                        // Sort in ascending alignment so that the layout stays optimal\n-                        // regardless of the prefix.\n-                        // And put the largest niche in an alignment group at the end\n-                        // so it can be used as discriminant in jagged enums\n-                        optimizing.sort_by_key(|&x| {\n-                            let f = fields[x];\n-                            let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n-                            (effective_field_align(f), niche_size)\n-                        });\n+        let layout = univariant(self, dl, fields, repr, kind, NicheBias::Start);\n+        // Enums prefer niches close to the beginning or the end of the variants so that other (smaller)\n+        // data-carrying variants can be packed into the space after/before the niche.\n+        // If the default field ordering does not give us a niche at the front then we do a second\n+        // run and bias niches to the right and then check which one is closer to one of the struct's\n+        // edges.\n+        if let Some(layout) = &layout {\n+            if let Some(niche) = layout.largest_niche {\n+                let head_space = niche.offset.bytes();\n+                let niche_length = niche.value.size(dl).bytes();\n+                let tail_space = layout.size.bytes() - head_space - niche_length;\n+\n+                // This may end up doing redundant work if the niche is already in the last field\n+                // (e.g. a trailing bool) and there is tail padding. But it's non-trivial to get\n+                // the unpadded size so we try anyway.\n+                if fields.len() > 1 && head_space != 0 && tail_space > 0 {\n+                    let alt_layout = univariant(self, dl, fields, repr, kind, NicheBias::End)\n+                        .expect(\"alt layout should always work\");\n+                    let niche = alt_layout\n+                        .largest_niche\n+                        .expect(\"alt layout should have a niche like the regular one\");\n+                    let alt_head_space = niche.offset.bytes();\n+                    let alt_niche_len = niche.value.size(dl).bytes();\n+                    let alt_tail_space = alt_layout.size.bytes() - alt_head_space - alt_niche_len;\n+\n+                    debug_assert_eq!(layout.size.bytes(), alt_layout.size.bytes());\n+\n+                    let prefer_alt_layout =\n+                        alt_head_space > head_space && alt_head_space > tail_space;\n+\n+                    debug!(\n+                        \"sz: {}, default_niche_at: {}+{}, default_tail_space: {}, alt_niche_at/head_space: {}+{}, alt_tail: {}, num_fields: {}, better: {}\\n\\\n+                        layout: {}\\n\\\n+                        alt_layout: {}\\n\",\n+                        layout.size.bytes(),\n+                        head_space,\n+                        niche_length,\n+                        tail_space,\n+                        alt_head_space,\n+                        alt_niche_len,\n+                        alt_tail_space,\n+                        layout.fields.count(),\n+                        prefer_alt_layout,\n+                        format_field_niches(&layout, &fields, &dl),\n+                        format_field_niches(&alt_layout, &fields, &dl),\n+                    );\n+\n+                    if prefer_alt_layout {\n+                        return Some(alt_layout);\n                     }\n                 }\n-\n-                // FIXME(Kixiron): We can always shuffle fields within a given alignment class\n-                //                 regardless of the status of `-Z randomize-layout`\n             }\n         }\n-        // inverse_memory_index holds field indices by increasing memory offset.\n-        // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n-        // We now write field offsets to the corresponding offset slot;\n-        // field 5 with offset 0 puts 0 in offsets[5].\n-        // At the bottom of this function, we invert `inverse_memory_index` to\n-        // produce `memory_index` (see `invert_mapping`).\n-        let mut sized = true;\n-        let mut offsets = IndexVec::from_elem(Size::ZERO, &fields);\n-        let mut offset = Size::ZERO;\n-        let mut largest_niche = None;\n-        let mut largest_niche_available = 0;\n-        if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n-            let prefix_align =\n-                if let Some(pack) = pack { prefix_align.min(pack) } else { prefix_align };\n-            align = align.max(AbiAndPrefAlign::new(prefix_align));\n-            offset = prefix_size.align_to(prefix_align);\n-        }\n-        for &i in &inverse_memory_index {\n-            let field = &fields[i];\n-            if !sized {\n-                self.delay_bug(&format!(\n-                    \"univariant: field #{} comes after unsized field\",\n-                    offsets.len(),\n-                ));\n-            }\n-\n-            if field.0.is_unsized() {\n-                sized = false;\n-            }\n-\n-            // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-            let field_align = if let Some(pack) = pack {\n-                field.align().min(AbiAndPrefAlign::new(pack))\n-            } else {\n-                field.align()\n-            };\n-            offset = offset.align_to(field_align.abi);\n-            align = align.max(field_align);\n-\n-            debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n-            offsets[i] = offset;\n-\n-            if let Some(mut niche) = field.largest_niche() {\n-                let available = niche.available(dl);\n-                if available > largest_niche_available {\n-                    largest_niche_available = available;\n-                    niche.offset += offset;\n-                    largest_niche = Some(niche);\n-                }\n-            }\n-\n-            offset = offset.checked_add(field.size(), dl)?;\n-        }\n-        if let Some(repr_align) = repr.align {\n-            align = align.max(AbiAndPrefAlign::new(repr_align));\n-        }\n-        debug!(\"univariant min_size: {:?}\", offset);\n-        let min_size = offset;\n-        // As stated above, inverse_memory_index holds field indices by increasing offset.\n-        // This makes it an already-sorted view of the offsets vec.\n-        // To invert it, consider:\n-        // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n-        // Field 5 would be the first element, so memory_index is i:\n-        // Note: if we didn't optimize, it's already right.\n-        let memory_index = if optimize {\n-            inverse_memory_index.invert_bijective_mapping()\n-        } else {\n-            debug_assert!(inverse_memory_index.iter().copied().eq(fields.indices()));\n-            inverse_memory_index.into_iter().map(FieldIdx::as_u32).collect()\n-        };\n-        let size = min_size.align_to(align.abi);\n-        let mut abi = Abi::Aggregate { sized };\n-        // Unpack newtype ABIs and find scalar pairs.\n-        if sized && size.bytes() > 0 {\n-            // All other fields must be ZSTs.\n-            let mut non_zst_fields = fields.iter_enumerated().filter(|&(_, f)| !f.0.is_zst());\n-\n-            match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n-                // We have exactly one non-ZST field.\n-                (Some((i, field)), None, None) => {\n-                    // Field fills the struct and it has a scalar or scalar pair ABI.\n-                    if offsets[i].bytes() == 0\n-                        && align.abi == field.align().abi\n-                        && size == field.size()\n-                    {\n-                        match field.abi() {\n-                            // For plain scalars, or vectors of them, we can't unpack\n-                            // newtypes for `#[repr(C)]`, as that affects C ABIs.\n-                            Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n-                                abi = field.abi();\n-                            }\n-                            // But scalar pairs are Rust-specific and get\n-                            // treated as aggregates by C ABIs anyway.\n-                            Abi::ScalarPair(..) => {\n-                                abi = field.abi();\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n-                }\n-\n-                // Two non-ZST fields, and they're both scalars.\n-                (Some((i, a)), Some((j, b)), None) => {\n-                    match (a.abi(), b.abi()) {\n-                        (Abi::Scalar(a), Abi::Scalar(b)) => {\n-                            // Order by the memory placement, not source order.\n-                            let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n-                                ((i, a), (j, b))\n-                            } else {\n-                                ((j, b), (i, a))\n-                            };\n-                            let pair = self.scalar_pair(a, b);\n-                            let pair_offsets = match pair.fields {\n-                                FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n-                                    assert_eq!(memory_index.raw, [0, 1]);\n-                                    offsets\n-                                }\n-                                _ => panic!(),\n-                            };\n-                            if offsets[i] == pair_offsets[FieldIdx::from_usize(0)]\n-                                && offsets[j] == pair_offsets[FieldIdx::from_usize(1)]\n-                                && align == pair.align\n-                                && size == pair.size\n-                            {\n-                                // We can use `ScalarPair` only when it matches our\n-                                // already computed layout (including `#[repr(C)]`).\n-                                abi = pair.abi;\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-\n-                _ => {}\n-            }\n-        }\n-        if fields.iter().any(|f| f.abi().is_uninhabited()) {\n-            abi = Abi::Uninhabited;\n-        }\n-        Some(LayoutS {\n-            variants: Variants::Single { index: FIRST_VARIANT },\n-            fields: FieldsShape::Arbitrary { offsets, memory_index },\n-            abi,\n-            largest_niche,\n-            align,\n-            size,\n-        })\n+        layout\n     }\n \n     fn layout_of_never_type(&self) -> LayoutS {\n@@ -461,8 +303,8 @@ pub trait LayoutCalculator {\n             let all_indices = variants.indices();\n             let needs_disc =\n                 |index: VariantIdx| index != largest_variant_index && !absent(&variants[index]);\n-            let niche_variants = all_indices.clone().find(|v| needs_disc(*v)).unwrap().index()\n-                ..=all_indices.rev().find(|v| needs_disc(*v)).unwrap().index();\n+            let niche_variants = all_indices.clone().find(|v| needs_disc(*v)).unwrap()\n+                ..=all_indices.rev().find(|v| needs_disc(*v)).unwrap();\n \n             let count = niche_variants.size_hint().1.unwrap() as u128;\n \n@@ -560,8 +402,7 @@ pub trait LayoutCalculator {\n                     tag: niche_scalar,\n                     tag_encoding: TagEncoding::Niche {\n                         untagged_variant: largest_variant_index,\n-                        niche_variants: (VariantIdx::new(*niche_variants.start())\n-                            ..=VariantIdx::new(*niche_variants.end())),\n+                        niche_variants,\n                         niche_start,\n                     },\n                     tag_field: 0,\n@@ -934,3 +775,323 @@ pub trait LayoutCalculator {\n         })\n     }\n }\n+\n+/// Determines towards which end of a struct layout optimizations will try to place the best niches.\n+enum NicheBias {\n+    Start,\n+    End,\n+}\n+\n+fn univariant(\n+    this: &(impl LayoutCalculator + ?Sized),\n+    dl: &TargetDataLayout,\n+    fields: &IndexSlice<FieldIdx, Layout<'_>>,\n+    repr: &ReprOptions,\n+    kind: StructKind,\n+    niche_bias: NicheBias,\n+) -> Option<LayoutS> {\n+    let pack = repr.pack;\n+    let mut align = if pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n+    let mut inverse_memory_index: IndexVec<u32, FieldIdx> = fields.indices().collect();\n+    let optimize = !repr.inhibit_struct_field_reordering_opt();\n+    if optimize && fields.len() > 1 {\n+        let end = if let StructKind::MaybeUnsized = kind { fields.len() - 1 } else { fields.len() };\n+        let optimizing = &mut inverse_memory_index.raw[..end];\n+\n+        // If `-Z randomize-layout` was enabled for the type definition we can shuffle\n+        // the field ordering to try and catch some code making assumptions about layouts\n+        // we don't guarantee\n+        if repr.can_randomize_type_layout() && cfg!(feature = \"randomize\") {\n+            #[cfg(feature = \"randomize\")]\n+            {\n+                // `ReprOptions.layout_seed` is a deterministic seed that we can use to\n+                // randomize field ordering with\n+                let mut rng = Xoshiro128StarStar::seed_from_u64(repr.field_shuffle_seed.as_u64());\n+\n+                // Shuffle the ordering of the fields\n+                optimizing.shuffle(&mut rng);\n+            }\n+            // Otherwise we just leave things alone and actually optimize the type's fields\n+        } else {\n+            let max_field_align = fields.iter().map(|f| f.align().abi.bytes()).max().unwrap_or(1);\n+            let largest_niche_size = fields\n+                .iter()\n+                .filter_map(|f| f.largest_niche())\n+                .map(|n| n.available(dl))\n+                .max()\n+                .unwrap_or(0);\n+\n+            // Calculates a sort key to group fields by their alignment or possibly some size-derived\n+            // pseudo-alignment.\n+            let alignment_group_key = |layout: Layout<'_>| {\n+                if let Some(pack) = pack {\n+                    // return the packed alignment in bytes\n+                    layout.align().abi.min(pack).bytes()\n+                } else {\n+                    // returns log2(effective-align).\n+                    // This is ok since `pack` applies to all fields equally.\n+                    // The calculation assumes that size is an integer multiple of align, except for ZSTs.\n+                    //\n+                    let align = layout.align().abi.bytes();\n+                    let size = layout.size().bytes();\n+                    let niche_size = layout.largest_niche().map(|n| n.available(dl)).unwrap_or(0);\n+                    // group [u8; 4] with align-4 or [u8; 6] with align-2 fields\n+                    let size_as_align = align.max(size).trailing_zeros();\n+                    let size_as_align = if largest_niche_size > 0 {\n+                        match niche_bias {\n+                            // Given `A(u8, [u8; 16])` and `B(bool, [u8; 16])` we want to bump the array\n+                            // to the front in the first case (for aligned loads) but keep the bool in front\n+                            // in the second case for its niches.\n+                            NicheBias::Start => max_field_align.trailing_zeros().min(size_as_align),\n+                            // When moving niches towards the end of the struct then for\n+                            // A((u8, u8, u8, bool), (u8, bool, u8)) we want to keep the first tuple\n+                            // in the align-1 group because its bool can be moved closer to the end.\n+                            NicheBias::End if niche_size == largest_niche_size => {\n+                                align.trailing_zeros()\n+                            }\n+                            NicheBias::End => size_as_align,\n+                        }\n+                    } else {\n+                        size_as_align\n+                    };\n+                    size_as_align as u64\n+                }\n+            };\n+\n+            match kind {\n+                StructKind::AlwaysSized | StructKind::MaybeUnsized => {\n+                    // Currently `LayoutS` only exposes a single niche so sorting is usually sufficient\n+                    // to get one niche into the preferred position. If it ever supported multiple niches\n+                    // then a more advanced pick-and-pack approach could provide better results.\n+                    // But even for the single-niche cache it's not optimal. E.g. for\n+                    // A(u32, (bool, u8), u16) it would be possible to move the bool to the front\n+                    // but it would require packing the tuple together with the u16 to build a 4-byte\n+                    // group so that the u32 can be placed after it without padding. This kind\n+                    // of packing can't be achieved by sorting.\n+                    optimizing.sort_by_key(|&x| {\n+                        let f = fields[x];\n+                        let field_size = f.size().bytes();\n+                        let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n+                        let niche_size_key = match niche_bias {\n+                            // large niche first\n+                            NicheBias::Start => !niche_size,\n+                            // large niche last\n+                            NicheBias::End => niche_size,\n+                        };\n+                        let inner_niche_offset_key = match niche_bias {\n+                            NicheBias::Start => f.largest_niche().map_or(0, |n| n.offset.bytes()),\n+                            NicheBias::End => f.largest_niche().map_or(0, |n| {\n+                                !(field_size - n.value.size(dl).bytes() - n.offset.bytes())\n+                            }),\n+                        };\n+\n+                        (\n+                            // Place ZSTs first to avoid \"interesting offsets\", especially with only one\n+                            // or two non-ZST fields. This helps Scalar/ScalarPair layouts.\n+                            !f.0.is_zst(),\n+                            // Then place largest alignments first.\n+                            cmp::Reverse(alignment_group_key(f)),\n+                            // Then prioritize niche placement within alignment group according to\n+                            // `niche_bias_start`.\n+                            niche_size_key,\n+                            // Then among fields with equally-sized niches prefer the ones\n+                            // closer to the start/end of the field.\n+                            inner_niche_offset_key,\n+                        )\n+                    });\n+                }\n+\n+                StructKind::Prefixed(..) => {\n+                    // Sort in ascending alignment so that the layout stays optimal\n+                    // regardless of the prefix.\n+                    // And put the largest niche in an alignment group at the end\n+                    // so it can be used as discriminant in jagged enums\n+                    optimizing.sort_by_key(|&x| {\n+                        let f = fields[x];\n+                        let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n+                        (alignment_group_key(f), niche_size)\n+                    });\n+                }\n+            }\n+\n+            // FIXME(Kixiron): We can always shuffle fields within a given alignment class\n+            //                 regardless of the status of `-Z randomize-layout`\n+        }\n+    }\n+    // inverse_memory_index holds field indices by increasing memory offset.\n+    // That is, if field 5 has offset 0, the first element of inverse_memory_index is 5.\n+    // We now write field offsets to the corresponding offset slot;\n+    // field 5 with offset 0 puts 0 in offsets[5].\n+    // At the bottom of this function, we invert `inverse_memory_index` to\n+    // produce `memory_index` (see `invert_mapping`).\n+    let mut sized = true;\n+    let mut offsets = IndexVec::from_elem(Size::ZERO, &fields);\n+    let mut offset = Size::ZERO;\n+    let mut largest_niche = None;\n+    let mut largest_niche_available = 0;\n+    if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n+        let prefix_align =\n+            if let Some(pack) = pack { prefix_align.min(pack) } else { prefix_align };\n+        align = align.max(AbiAndPrefAlign::new(prefix_align));\n+        offset = prefix_size.align_to(prefix_align);\n+    }\n+    for &i in &inverse_memory_index {\n+        let field = &fields[i];\n+        if !sized {\n+            this.delay_bug(&format!(\n+                \"univariant: field #{} comes after unsized field\",\n+                offsets.len(),\n+            ));\n+        }\n+\n+        if field.0.is_unsized() {\n+            sized = false;\n+        }\n+\n+        // Invariant: offset < dl.obj_size_bound() <= 1<<61\n+        let field_align = if let Some(pack) = pack {\n+            field.align().min(AbiAndPrefAlign::new(pack))\n+        } else {\n+            field.align()\n+        };\n+        offset = offset.align_to(field_align.abi);\n+        align = align.max(field_align);\n+\n+        debug!(\"univariant offset: {:?} field: {:#?}\", offset, field);\n+        offsets[i] = offset;\n+\n+        if let Some(mut niche) = field.largest_niche() {\n+            let available = niche.available(dl);\n+            // Pick up larger niches.\n+            let prefer_new_niche = match niche_bias {\n+                NicheBias::Start => available > largest_niche_available,\n+                // if there are several niches of the same size then pick the last one\n+                NicheBias::End => available >= largest_niche_available,\n+            };\n+            if prefer_new_niche {\n+                largest_niche_available = available;\n+                niche.offset += offset;\n+                largest_niche = Some(niche);\n+            }\n+        }\n+\n+        offset = offset.checked_add(field.size(), dl)?;\n+    }\n+    if let Some(repr_align) = repr.align {\n+        align = align.max(AbiAndPrefAlign::new(repr_align));\n+    }\n+    debug!(\"univariant min_size: {:?}\", offset);\n+    let min_size = offset;\n+    // As stated above, inverse_memory_index holds field indices by increasing offset.\n+    // This makes it an already-sorted view of the offsets vec.\n+    // To invert it, consider:\n+    // If field 5 has offset 0, offsets[0] is 5, and memory_index[5] should be 0.\n+    // Field 5 would be the first element, so memory_index is i:\n+    // Note: if we didn't optimize, it's already right.\n+    let memory_index = if optimize {\n+        inverse_memory_index.invert_bijective_mapping()\n+    } else {\n+        debug_assert!(inverse_memory_index.iter().copied().eq(fields.indices()));\n+        inverse_memory_index.into_iter().map(FieldIdx::as_u32).collect()\n+    };\n+    let size = min_size.align_to(align.abi);\n+    let mut abi = Abi::Aggregate { sized };\n+    // Unpack newtype ABIs and find scalar pairs.\n+    if sized && size.bytes() > 0 {\n+        // All other fields must be ZSTs.\n+        let mut non_zst_fields = fields.iter_enumerated().filter(|&(_, f)| !f.0.is_zst());\n+\n+        match (non_zst_fields.next(), non_zst_fields.next(), non_zst_fields.next()) {\n+            // We have exactly one non-ZST field.\n+            (Some((i, field)), None, None) => {\n+                // Field fills the struct and it has a scalar or scalar pair ABI.\n+                if offsets[i].bytes() == 0 && align.abi == field.align().abi && size == field.size()\n+                {\n+                    match field.abi() {\n+                        // For plain scalars, or vectors of them, we can't unpack\n+                        // newtypes for `#[repr(C)]`, as that affects C ABIs.\n+                        Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n+                            abi = field.abi();\n+                        }\n+                        // But scalar pairs are Rust-specific and get\n+                        // treated as aggregates by C ABIs anyway.\n+                        Abi::ScalarPair(..) => {\n+                            abi = field.abi();\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+\n+            // Two non-ZST fields, and they're both scalars.\n+            (Some((i, a)), Some((j, b)), None) => {\n+                match (a.abi(), b.abi()) {\n+                    (Abi::Scalar(a), Abi::Scalar(b)) => {\n+                        // Order by the memory placement, not source order.\n+                        let ((i, a), (j, b)) = if offsets[i] < offsets[j] {\n+                            ((i, a), (j, b))\n+                        } else {\n+                            ((j, b), (i, a))\n+                        };\n+                        let pair = this.scalar_pair(a, b);\n+                        let pair_offsets = match pair.fields {\n+                            FieldsShape::Arbitrary { ref offsets, ref memory_index } => {\n+                                assert_eq!(memory_index.raw, [0, 1]);\n+                                offsets\n+                            }\n+                            _ => panic!(),\n+                        };\n+                        if offsets[i] == pair_offsets[FieldIdx::from_usize(0)]\n+                            && offsets[j] == pair_offsets[FieldIdx::from_usize(1)]\n+                            && align == pair.align\n+                            && size == pair.size\n+                        {\n+                            // We can use `ScalarPair` only when it matches our\n+                            // already computed layout (including `#[repr(C)]`).\n+                            abi = pair.abi;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+    if fields.iter().any(|f| f.abi().is_uninhabited()) {\n+        abi = Abi::Uninhabited;\n+    }\n+    Some(LayoutS {\n+        variants: Variants::Single { index: FIRST_VARIANT },\n+        fields: FieldsShape::Arbitrary { offsets, memory_index },\n+        abi,\n+        largest_niche,\n+        align,\n+        size,\n+    })\n+}\n+\n+fn format_field_niches(\n+    layout: &LayoutS,\n+    fields: &IndexSlice<FieldIdx, Layout<'_>>,\n+    dl: &TargetDataLayout,\n+) -> String {\n+    let mut s = String::new();\n+    for i in layout.fields.index_by_increasing_offset() {\n+        let offset = layout.fields.offset(i);\n+        let f = fields[i.into()];\n+        write!(s, \"[o{}a{}s{}\", offset.bytes(), f.align().abi.bytes(), f.size().bytes()).unwrap();\n+        if let Some(n) = f.largest_niche() {\n+            write!(\n+                s,\n+                \" n{}b{}s{}\",\n+                n.offset.bytes(),\n+                n.available(dl).ilog2(),\n+                n.value.size(dl).bytes()\n+            )\n+            .unwrap();\n+        }\n+        write!(s, \"] \").unwrap();\n+    }\n+    s\n+}"}, {"sha": "d01a9b003042b6127ad2d47d0eb5d0bb97fa3a14", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -9,9 +9,10 @@ use std::str::FromStr;\n \n use bitflags::bitflags;\n use rustc_data_structures::intern::Interned;\n+use rustc_data_structures::stable_hasher::Hash64;\n #[cfg(feature = \"nightly\")]\n use rustc_data_structures::stable_hasher::StableOrd;\n-use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n+use rustc_index::{IndexSlice, IndexVec};\n #[cfg(feature = \"nightly\")]\n use rustc_macros::HashStable_Generic;\n #[cfg(feature = \"nightly\")]\n@@ -77,12 +78,12 @@ pub struct ReprOptions {\n     pub flags: ReprFlags,\n     /// The seed to be used for randomizing a type's layout\n     ///\n-    /// Note: This could technically be a `[u8; 16]` (a `u128`) which would\n+    /// Note: This could technically be a `Hash128` which would\n     /// be the \"most accurate\" hash as it'd encompass the item and crate\n     /// hash without loss, but it does pay the price of being larger.\n-    /// Everything's a tradeoff, a `u64` seed should be sufficient for our\n+    /// Everything's a tradeoff, a 64-bit seed should be sufficient for our\n     /// purposes (primarily `-Z randomize-layout`)\n-    pub field_shuffle_seed: u64,\n+    pub field_shuffle_seed: Hash64,\n }\n \n impl ReprOptions {\n@@ -665,15 +666,12 @@ impl Align {\n             format!(\"`{}` is too large\", align)\n         }\n \n-        let mut bytes = align;\n-        let mut pow2: u8 = 0;\n-        while (bytes & 1) == 0 {\n-            pow2 += 1;\n-            bytes >>= 1;\n-        }\n-        if bytes != 1 {\n+        let tz = align.trailing_zeros();\n+        if align != (1 << tz) {\n             return Err(not_power_of_2(align));\n         }\n+\n+        let pow2 = tz as u8;\n         if pow2 > Self::MAX.pow2 {\n             return Err(too_large(align));\n         }"}, {"sha": "6e15f06a76de015dc8c62ac25d5fdf1fd0901654", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -20,6 +20,7 @@\n #![feature(rustc_attrs)]\n #![cfg_attr(test, feature(test))]\n #![feature(strict_provenance)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n #![allow(clippy::mut_from_ref)] // Arena allocators are one of the places where this pattern is fine.\n@@ -74,19 +75,27 @@ impl<T> ArenaChunk<T> {\n     #[inline]\n     unsafe fn new(capacity: usize) -> ArenaChunk<T> {\n         ArenaChunk {\n-            storage: NonNull::new(Box::into_raw(Box::new_uninit_slice(capacity))).unwrap(),\n+            storage: NonNull::from(Box::leak(Box::new_uninit_slice(capacity))),\n             entries: 0,\n         }\n     }\n \n     /// Destroys this arena chunk.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that `len` elements of this chunk have been initialized.\n     #[inline]\n     unsafe fn destroy(&mut self, len: usize) {\n         // The branch on needs_drop() is an -O1 performance optimization.\n-        // Without the branch, dropping TypedArena<u8> takes linear time.\n+        // Without the branch, dropping TypedArena<T> takes linear time.\n         if mem::needs_drop::<T>() {\n-            let slice = &mut *(self.storage.as_mut());\n-            ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(&mut slice[..len]));\n+            // SAFETY: The caller must ensure that `len` elements of this chunk have\n+            // been initialized.\n+            unsafe {\n+                let slice = self.storage.as_mut();\n+                ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(&mut slice[..len]));\n+            }\n         }\n     }\n \n@@ -104,7 +113,7 @@ impl<T> ArenaChunk<T> {\n                 // A pointer as large as possible for zero-sized elements.\n                 ptr::invalid_mut(!0)\n             } else {\n-                self.start().add((*self.storage.as_ptr()).len())\n+                self.start().add(self.storage.len())\n             }\n         }\n     }\n@@ -255,7 +264,9 @@ impl<T> TypedArena<T> {\n         self.ensure_capacity(len);\n \n         let start_ptr = self.ptr.get();\n-        self.ptr.set(start_ptr.add(len));\n+        // SAFETY: `self.ensure_capacity` makes sure that there is enough space\n+        // for `len` elements.\n+        unsafe { self.ptr.set(start_ptr.add(len)) };\n         start_ptr\n     }\n \n@@ -288,7 +299,7 @@ impl<T> TypedArena<T> {\n                 // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = (*last_chunk.storage.as_ptr()).len().min(HUGE_PAGE / elem_size / 2);\n+                new_cap = last_chunk.storage.len().min(HUGE_PAGE / elem_size / 2);\n                 new_cap *= 2;\n             } else {\n                 new_cap = PAGE / elem_size;\n@@ -396,7 +407,7 @@ impl DroplessArena {\n                 // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = (*last_chunk.storage.as_ptr()).len().min(HUGE_PAGE / 2);\n+                new_cap = last_chunk.storage.len().min(HUGE_PAGE / 2);\n                 new_cap *= 2;\n             } else {\n                 new_cap = PAGE;\n@@ -483,6 +494,10 @@ impl DroplessArena {\n         }\n     }\n \n+    /// # Safety\n+    ///\n+    /// The caller must ensure that `mem` is valid for writes up to\n+    /// `size_of::<T>() * len`.\n     #[inline]\n     unsafe fn write_from_iter<T, I: Iterator<Item = T>>(\n         &self,\n@@ -494,13 +509,18 @@ impl DroplessArena {\n         // Use a manual loop since LLVM manages to optimize it better for\n         // slice iterators\n         loop {\n-            let value = iter.next();\n-            if i >= len || value.is_none() {\n-                // We only return as many items as the iterator gave us, even\n-                // though it was supposed to give us `len`\n-                return slice::from_raw_parts_mut(mem, i);\n+            // SAFETY: The caller must ensure that `mem` is valid for writes up to\n+            // `size_of::<T>() * len`.\n+            unsafe {\n+                match iter.next() {\n+                    Some(value) if i < len => mem.add(i).write(value),\n+                    Some(_) | None => {\n+                        // We only return as many items as the iterator gave us, even\n+                        // though it was supposed to give us `len`\n+                        return slice::from_raw_parts_mut(mem, i);\n+                    }\n+                }\n             }\n-            ptr::write(mem.add(i), value.unwrap());\n             i += 1;\n         }\n     }"}, {"sha": "3ed342ce48b43194ab30a70997f5c2b5d34536df", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1271,6 +1271,7 @@ impl Expr {\n             ExprKind::Continue(..) => ExprPrecedence::Continue,\n             ExprKind::Ret(..) => ExprPrecedence::Ret,\n             ExprKind::InlineAsm(..) => ExprPrecedence::InlineAsm,\n+            ExprKind::OffsetOf(..) => ExprPrecedence::OffsetOf,\n             ExprKind::MacCall(..) => ExprPrecedence::Mac,\n             ExprKind::Struct(..) => ExprPrecedence::Struct,\n             ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n@@ -1298,17 +1299,17 @@ impl Expr {\n \n     /// To a first-order approximation, is this a pattern?\n     pub fn is_approximately_pattern(&self) -> bool {\n-        match &self.peel_parens().kind {\n+        matches!(\n+            &self.peel_parens().kind,\n             ExprKind::Array(_)\n-            | ExprKind::Call(_, _)\n-            | ExprKind::Tup(_)\n-            | ExprKind::Lit(_)\n-            | ExprKind::Range(_, _, _)\n-            | ExprKind::Underscore\n-            | ExprKind::Path(_, _)\n-            | ExprKind::Struct(_) => true,\n-            _ => false,\n-        }\n+                | ExprKind::Call(_, _)\n+                | ExprKind::Tup(_)\n+                | ExprKind::Lit(_)\n+                | ExprKind::Range(_, _, _)\n+                | ExprKind::Underscore\n+                | ExprKind::Path(_, _)\n+                | ExprKind::Struct(_)\n+        )\n     }\n }\n \n@@ -1469,6 +1470,9 @@ pub enum ExprKind {\n     /// Output of the `asm!()` macro.\n     InlineAsm(P<InlineAsm>),\n \n+    /// Output of the `offset_of!()` macro.\n+    OffsetOf(P<Ty>, P<[Ident]>),\n+\n     /// A macro invocation; pre-expansion.\n     MacCall(P<MacCall>),\n \n@@ -2972,7 +2976,7 @@ pub enum ItemKind {\n }\n \n impl ItemKind {\n-    pub fn article(&self) -> &str {\n+    pub fn article(&self) -> &'static str {\n         use ItemKind::*;\n         match self {\n             Use(..) | Static(..) | Const(..) | Fn(..) | Mod(..) | GlobalAsm(..) | TyAlias(..)\n@@ -2981,7 +2985,7 @@ impl ItemKind {\n         }\n     }\n \n-    pub fn descr(&self) -> &str {\n+    pub fn descr(&self) -> &'static str {\n         match self {\n             ItemKind::ExternCrate(..) => \"extern crate\",\n             ItemKind::Use(..) => \"`use` import\","}, {"sha": "e6c4db9e2ae5c1bb0623d0bc4a57e0c0eaeae9f9", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -10,15 +10,10 @@ use crate::tokenstream::{DelimSpan, Spacing, TokenTree};\n use crate::tokenstream::{LazyAttrTokenStream, TokenStream};\n use crate::util::comments;\n use crate::util::literal::escape_string_symbol;\n-use rustc_data_structures::sync::WorkerLocal;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n-use std::cell::Cell;\n use std::iter;\n-#[cfg(debug_assertions)]\n-use std::ops::BitXor;\n-#[cfg(debug_assertions)]\n use std::sync::atomic::{AtomicU32, Ordering};\n use thin_vec::{thin_vec, ThinVec};\n \n@@ -40,39 +35,16 @@ impl MarkedAttrs {\n     }\n }\n \n-pub struct AttrIdGenerator(WorkerLocal<Cell<u32>>);\n-\n-#[cfg(debug_assertions)]\n-static MAX_ATTR_ID: AtomicU32 = AtomicU32::new(u32::MAX);\n+pub struct AttrIdGenerator(AtomicU32);\n \n impl AttrIdGenerator {\n     pub fn new() -> Self {\n-        // We use `(index as u32).reverse_bits()` to initialize the\n-        // starting value of AttrId in each worker thread.\n-        // The `index` is the index of the worker thread.\n-        // This ensures that the AttrId generated in each thread is unique.\n-        AttrIdGenerator(WorkerLocal::new(|index| {\n-            let index: u32 = index.try_into().unwrap();\n-\n-            #[cfg(debug_assertions)]\n-            {\n-                let max_id = ((index + 1).next_power_of_two() - 1).bitxor(u32::MAX).reverse_bits();\n-                MAX_ATTR_ID.fetch_min(max_id, Ordering::Release);\n-            }\n-\n-            Cell::new(index.reverse_bits())\n-        }))\n+        AttrIdGenerator(AtomicU32::new(0))\n     }\n \n     pub fn mk_attr_id(&self) -> AttrId {\n-        let id = self.0.get();\n-\n-        // Ensure the assigned attr_id does not overlap the bits\n-        // representing the number of threads.\n-        #[cfg(debug_assertions)]\n-        assert!(id <= MAX_ATTR_ID.load(Ordering::Acquire));\n-\n-        self.0.set(id + 1);\n+        let id = self.0.fetch_add(1, Ordering::Relaxed);\n+        assert!(id != u32::MAX);\n         AttrId::from_u32(id)\n     }\n }"}, {"sha": "b07ed1d1c741eeb372d57c0f80a9e6d935bbb3f8", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -10,7 +10,6 @@\n )]\n #![feature(associated_type_bounds)]\n #![feature(box_patterns)]\n-#![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]"}, {"sha": "99f1f4bd9685f491606136039b1de37ae88438f0", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1456,6 +1456,12 @@ pub fn noop_visit_expr<T: MutVisitor>(\n         }\n         ExprKind::InlineAsm(asm) => vis.visit_inline_asm(asm),\n         ExprKind::FormatArgs(fmt) => vis.visit_format_args(fmt),\n+        ExprKind::OffsetOf(container, fields) => {\n+            vis.visit_ty(container);\n+            for field in fields.iter_mut() {\n+                vis.visit_ident(field);\n+            }\n+        }\n         ExprKind::MacCall(mac) => vis.visit_mac_call(mac),\n         ExprKind::Struct(se) => {\n             let StructExpr { qself, path, fields, rest } = se.deref_mut();"}, {"sha": "d16741757d1f1e03f8882021f36c4aef39ba2ece", "filename": "compiler/rustc_ast/src/node_id.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fnode_id.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -9,14 +9,14 @@ rustc_index::newtype_index! {\n     ///\n     /// [`DefId`]: rustc_span::def_id::DefId\n     #[debug_format = \"NodeId({})\"]\n-    pub struct NodeId {}\n+    pub struct NodeId {\n+        /// The [`NodeId`] used to represent the root of the crate.\n+        const CRATE_NODE_ID = 0;\n+    }\n }\n \n rustc_data_structures::define_id_collections!(NodeMap, NodeSet, NodeMapEntry, NodeId);\n \n-/// The [`NodeId`] used to represent the root of the crate.\n-pub const CRATE_NODE_ID: NodeId = NodeId::from_u32(0);\n-\n /// When parsing and at the beginning of doing expansions, we initially give all AST nodes\n /// this dummy AST [`NodeId`]. Then, during a later phase of expansion, we renumber them\n /// to have small, positive IDs."}, {"sha": "0140fb752bf92f8c9f11c265f5ae99e527abdaa8", "filename": "compiler/rustc_ast/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fptr.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -126,7 +126,8 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for P<T> {\n }\n \n impl<T> P<[T]> {\n-    pub const fn new() -> P<[T]> {\n+    // FIXME(const-hack) make this const again\n+    pub fn new() -> P<[T]> {\n         P { ptr: Box::default() }\n     }\n "}, {"sha": "24b4bd8623f047952ba1c43577b67a51a91f8cee", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -269,6 +269,7 @@ pub enum ExprPrecedence {\n     Index,\n     Try,\n     InlineAsm,\n+    OffsetOf,\n     Mac,\n     FormatArgs,\n \n@@ -335,7 +336,8 @@ impl ExprPrecedence {\n             | ExprPrecedence::Try\n             | ExprPrecedence::InlineAsm\n             | ExprPrecedence::Mac\n-            | ExprPrecedence::FormatArgs => PREC_POSTFIX,\n+            | ExprPrecedence::FormatArgs\n+            | ExprPrecedence::OffsetOf => PREC_POSTFIX,\n \n             // Never need parens\n             ExprPrecedence::Array"}, {"sha": "8a6b5d5c9052deffc6fcee5e4dd0bccb8c2547d5", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -909,6 +909,12 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::Paren(subexpression) => visitor.visit_expr(subexpression),\n         ExprKind::InlineAsm(asm) => visitor.visit_inline_asm(asm),\n         ExprKind::FormatArgs(f) => visitor.visit_format_args(f),\n+        ExprKind::OffsetOf(container, fields) => {\n+            visitor.visit_ty(container);\n+            for &field in fields {\n+                visitor.visit_ident(field);\n+            }\n+        }\n         ExprKind::Yield(optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n         }"}, {"sha": "6b0da256505063a55be90c16f9e7a4738326bcf7", "filename": "compiler/rustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -12,6 +12,7 @@ rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "7a0a7da969572565c54e6b48241d30f5fa8508da", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -121,12 +121,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             LitKind::Err\n                         }\n                     };\n-                    hir::ExprKind::Lit(respan(self.lower_span(e.span), lit_kind))\n+                    let lit = self.arena.alloc(respan(self.lower_span(e.span), lit_kind));\n+                    hir::ExprKind::Lit(lit)\n+                }\n+                ExprKind::IncludedBytes(bytes) => {\n+                    let lit = self.arena.alloc(respan(\n+                        self.lower_span(e.span),\n+                        LitKind::ByteStr(bytes.clone(), StrStyle::Cooked),\n+                    ));\n+                    hir::ExprKind::Lit(lit)\n                 }\n-                ExprKind::IncludedBytes(bytes) => hir::ExprKind::Lit(respan(\n-                    self.lower_span(e.span),\n-                    LitKind::ByteStr(bytes.clone(), StrStyle::Cooked),\n-                )),\n                 ExprKind::Cast(expr, ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n@@ -285,6 +289,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::ExprKind::InlineAsm(self.lower_inline_asm(e.span, asm))\n                 }\n                 ExprKind::FormatArgs(fmt) => self.lower_format_args(e.span, fmt),\n+                ExprKind::OffsetOf(container, fields) => hir::ExprKind::OffsetOf(\n+                    self.lower_ty(\n+                        container,\n+                        &mut ImplTraitContext::Disallowed(ImplTraitPosition::OffsetOf),\n+                    ),\n+                    self.arena.alloc_from_iter(fields.iter().map(|&ident| self.lower_ident(ident))),\n+                ),\n                 ExprKind::Struct(se) => {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n@@ -847,13 +858,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let awaitee_arm = self.arm(awaitee_pat, loop_expr);\n \n         // `match ::std::future::IntoFuture::into_future(<expr>) { ... }`\n-        let into_future_span = self.mark_span_with_reason(\n-            DesugaringKind::Await,\n-            dot_await_span,\n-            self.allow_into_future.clone(),\n-        );\n         let into_future_expr = self.expr_call_lang_item_fn(\n-            into_future_span,\n+            span,\n             hir::LangItem::IntoFutureIntoFuture,\n             arena_vec![self; expr],\n             Some(expr_hir_id),\n@@ -1746,40 +1752,31 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     pub(super) fn expr_usize(&mut self, sp: Span, value: usize) -> hir::Expr<'hir> {\n-        self.expr(\n-            sp,\n-            hir::ExprKind::Lit(hir::Lit {\n-                span: sp,\n-                node: ast::LitKind::Int(\n-                    value as u128,\n-                    ast::LitIntType::Unsigned(ast::UintTy::Usize),\n-                ),\n-            }),\n-        )\n+        let lit = self.arena.alloc(hir::Lit {\n+            span: sp,\n+            node: ast::LitKind::Int(value as u128, ast::LitIntType::Unsigned(ast::UintTy::Usize)),\n+        });\n+        self.expr(sp, hir::ExprKind::Lit(lit))\n     }\n \n     pub(super) fn expr_u32(&mut self, sp: Span, value: u32) -> hir::Expr<'hir> {\n-        self.expr(\n-            sp,\n-            hir::ExprKind::Lit(hir::Lit {\n-                span: sp,\n-                node: ast::LitKind::Int(value.into(), ast::LitIntType::Unsigned(ast::UintTy::U32)),\n-            }),\n-        )\n+        let lit = self.arena.alloc(hir::Lit {\n+            span: sp,\n+            node: ast::LitKind::Int(value.into(), ast::LitIntType::Unsigned(ast::UintTy::U32)),\n+        });\n+        self.expr(sp, hir::ExprKind::Lit(lit))\n     }\n \n     pub(super) fn expr_char(&mut self, sp: Span, value: char) -> hir::Expr<'hir> {\n-        self.expr(sp, hir::ExprKind::Lit(hir::Lit { span: sp, node: ast::LitKind::Char(value) }))\n+        let lit = self.arena.alloc(hir::Lit { span: sp, node: ast::LitKind::Char(value) });\n+        self.expr(sp, hir::ExprKind::Lit(lit))\n     }\n \n     pub(super) fn expr_str(&mut self, sp: Span, value: Symbol) -> hir::Expr<'hir> {\n-        self.expr(\n-            sp,\n-            hir::ExprKind::Lit(hir::Lit {\n-                span: sp,\n-                node: ast::LitKind::Str(value, ast::StrStyle::Cooked),\n-            }),\n-        )\n+        let lit = self\n+            .arena\n+            .alloc(hir::Lit { span: sp, node: ast::LitKind::Str(value, ast::StrStyle::Cooked) });\n+        self.expr(sp, hir::ExprKind::Lit(lit))\n     }\n \n     pub(super) fn expr_call_mut("}, {"sha": "c081162ea1467eb5b46425ffc1433e354c57aba2", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -186,7 +186,7 @@ enum ArgumentType {\n /// Generates:\n ///\n /// ```text\n-///     <core::fmt::ArgumentV1>::new_\u2026(arg)\n+///     <core::fmt::Argument>::new_\u2026(arg)\n /// ```\n fn make_argument<'hir>(\n     ctx: &mut LoweringContext<'_, 'hir>,\n@@ -220,19 +220,19 @@ fn make_argument<'hir>(\n /// Generates:\n ///\n /// ```text\n-///     <core::fmt::rt::v1::Count>::Is(\u2026)\n+///     <core::fmt::rt::Count>::Is(\u2026)\n /// ```\n ///\n /// or\n ///\n /// ```text\n-///     <core::fmt::rt::v1::Count>::Param(\u2026)\n+///     <core::fmt::rt::Count>::Param(\u2026)\n /// ```\n ///\n /// or\n ///\n /// ```text\n-///     <core::fmt::rt::v1::Count>::Implied\n+///     <core::fmt::rt::Count>::Implied\n /// ```\n fn make_count<'hir>(\n     ctx: &mut LoweringContext<'_, 'hir>,\n@@ -278,13 +278,13 @@ fn make_count<'hir>(\n /// Generates\n ///\n /// ```text\n-///     <core::fmt::rt::v1::Argument::new(\n+///     <core::fmt::rt::Placeholder::new(\n ///         \u2026usize, // position\n ///         '\u2026', // fill\n-///         <core::fmt::rt::v1::Alignment>::\u2026, // alignment\n+///         <core::fmt::rt::Alignment>::\u2026, // alignment\n ///         \u2026u32, // flags\n-///         <core::fmt::rt::v1::Count::\u2026>, // width\n-///         <core::fmt::rt::v1::Count::\u2026>, // precision\n+///         <core::fmt::rt::Count::\u2026>, // width\n+///         <core::fmt::rt::Count::\u2026>, // precision\n ///     )\n /// ```\n fn make_format_spec<'hir>(\n@@ -327,7 +327,7 @@ fn make_format_spec<'hir>(\n             None => sym::Unknown,\n         },\n     );\n-    // This needs to match `FlagV1` in library/core/src/fmt/mod.rs.\n+    // This needs to match `Flag` in library/core/src/fmt/rt.rs.\n     let flags: u32 = ((sign == Some(FormatSign::Plus)) as u32)\n         | ((sign == Some(FormatSign::Minus)) as u32) << 1\n         | (alternate as u32) << 2\n@@ -438,7 +438,7 @@ fn expand_format_args<'hir>(\n     // If the args array contains exactly all the original arguments once,\n     // in order, we can use a simple array instead of a `match` construction.\n     // However, if there's a yield point in any argument except the first one,\n-    // we don't do this, because an ArgumentV1 cannot be kept across yield points.\n+    // we don't do this, because an Argument cannot be kept across yield points.\n     //\n     // This is an optimization, speeding up compilation about 1-2% in some cases.\n     // See https://github.com/rust-lang/rust/pull/106770#issuecomment-1380790609\n@@ -449,9 +449,9 @@ fn expand_format_args<'hir>(\n     let args = if use_simple_array {\n         // Generate:\n         //     &[\n-        //         <core::fmt::ArgumentV1>::new_display(&arg0),\n-        //         <core::fmt::ArgumentV1>::new_lower_hex(&arg1),\n-        //         <core::fmt::ArgumentV1>::new_debug(&arg2),\n+        //         <core::fmt::Argument>::new_display(&arg0),\n+        //         <core::fmt::Argument>::new_lower_hex(&arg1),\n+        //         <core::fmt::Argument>::new_debug(&arg2),\n         //         \u2026\n         //     ]\n         let elements: Vec<_> = arguments\n@@ -477,9 +477,9 @@ fn expand_format_args<'hir>(\n         // Generate:\n         //     &match (&arg0, &arg1, &\u2026) {\n         //         args => [\n-        //             <core::fmt::ArgumentV1>::new_display(args.0),\n-        //             <core::fmt::ArgumentV1>::new_lower_hex(args.1),\n-        //             <core::fmt::ArgumentV1>::new_debug(args.0),\n+        //             <core::fmt::Argument>::new_display(args.0),\n+        //             <core::fmt::Argument>::new_lower_hex(args.1),\n+        //             <core::fmt::Argument>::new_debug(args.0),\n         //             \u2026\n         //         ]\n         //     }"}, {"sha": "2e66c81eb0d058f105bc182112ffd9bbc27c082b", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::definitions;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::*;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::{Idx, IndexVec};\n use rustc_middle::span_bug;\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;"}, {"sha": "3d154a93fb2dafc99291af802ce53ead521e8ed7", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -12,7 +12,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::PredicateOrigin;\n-use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n+use rustc_index::{Idx, IndexSlice, IndexVec};\n use rustc_middle::ty::{ResolverAstLowering, TyCtxt};\n use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::source_map::DesugaringKind;\n@@ -83,24 +83,23 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             impl_trait_bounds: Vec::new(),\n             allow_try_trait: Some([sym::try_trait_v2, sym::yeet_desugar_details][..].into()),\n             allow_gen_future: Some([sym::gen_future, sym::closure_track_caller][..].into()),\n-            allow_into_future: Some([sym::into_future][..].into()),\n             generics_def_id_map: Default::default(),\n         };\n         lctx.with_hir_id_owner(owner, |lctx| f(lctx));\n \n         for (def_id, info) in lctx.children {\n-            self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n-            debug_assert!(matches!(self.owners[def_id], hir::MaybeOwner::Phantom));\n-            self.owners[def_id] = info;\n+            let owner = self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n+            debug_assert!(matches!(owner, hir::MaybeOwner::Phantom));\n+            *owner = info;\n         }\n     }\n \n     pub(super) fn lower_node(\n         &mut self,\n         def_id: LocalDefId,\n     ) -> hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>> {\n-        self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n-        if let hir::MaybeOwner::Phantom = self.owners[def_id] {\n+        let owner = self.owners.ensure_contains_elem(def_id, || hir::MaybeOwner::Phantom);\n+        if let hir::MaybeOwner::Phantom = owner {\n             let node = self.ast_index[def_id];\n             match node {\n                 AstOwner::NonOwner => {}\n@@ -138,12 +137,10 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             // Evaluate with the lifetimes in `params` in-scope.\n             // This is used to track which lifetimes have already been defined,\n             // and which need to be replicated when lowering an async fn.\n-            match parent_hir.node().expect_item().kind {\n-                hir::ItemKind::Impl(hir::Impl { of_trait, .. }) => {\n-                    lctx.is_in_trait_impl = of_trait.is_some();\n-                }\n-                _ => {}\n-            };\n+\n+            if let hir::ItemKind::Impl(impl_) = parent_hir.node().expect_item().kind {\n+                lctx.is_in_trait_impl = impl_.of_trait.is_some();\n+            }\n \n             match ctxt {\n                 AssocCtxt::Trait => hir::OwnerNode::TraitItem(lctx.lower_trait_item(item)),\n@@ -445,7 +442,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ItemKind::MacroDef(MacroDef { body, macro_rules }) => {\n                 let body = P(self.lower_delim_args(body));\n                 let macro_kind = self.resolver.decl_macro_kind(self.local_def_id(id));\n-                hir::ItemKind::Macro(ast::MacroDef { body, macro_rules: *macro_rules }, macro_kind)\n+                let macro_def = self.arena.alloc(ast::MacroDef { body, macro_rules: *macro_rules });\n+                hir::ItemKind::Macro(macro_def, macro_kind)\n             }\n             ItemKind::MacCall(..) => {\n                 panic!(\"`TyMac` should have been expanded by now\")"}, {"sha": "b5b28bf8e31e5416b651dc06779a2e54b60eb59f", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -55,13 +55,13 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::{\n     DiagnosticArgFromDisplay, DiagnosticMessage, Handler, StashKey, SubdiagnosticMessage,\n };\n+use rustc_fluent_macro::fluent_messages;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, LifetimeRes, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n-use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n-use rustc_macros::fluent_messages;\n+use rustc_index::{Idx, IndexSlice, IndexVec};\n use rustc_middle::{\n     span_bug,\n     ty::{ResolverAstLowering, TyCtxt},\n@@ -136,7 +136,6 @@ struct LoweringContext<'a, 'hir> {\n \n     allow_try_trait: Option<Lrc<[Symbol]>>,\n     allow_gen_future: Option<Lrc<[Symbol]>>,\n-    allow_into_future: Option<Lrc<[Symbol]>>,\n \n     /// Mapping from generics `def_id`s to TAIT generics `def_id`s.\n     /// For each captured lifetime (e.g., 'a), we create a new lifetime parameter that is a generic\n@@ -283,6 +282,7 @@ enum ImplTraitPosition {\n     FieldTy,\n     Cast,\n     ImplSelf,\n+    OffsetOf,\n }\n \n impl std::fmt::Display for ImplTraitPosition {\n@@ -313,6 +313,7 @@ impl std::fmt::Display for ImplTraitPosition {\n             ImplTraitPosition::FieldTy => \"field types\",\n             ImplTraitPosition::Cast => \"cast types\",\n             ImplTraitPosition::ImplSelf => \"impl headers\",\n+            ImplTraitPosition::OffsetOf => \"`offset_of!` params\",\n         };\n \n         write!(f, \"{name}\")\n@@ -332,10 +333,7 @@ enum FnDeclKind {\n \n impl FnDeclKind {\n     fn param_impl_trait_allowed(&self) -> bool {\n-        match self {\n-            FnDeclKind::Fn | FnDeclKind::Inherent | FnDeclKind::Impl | FnDeclKind::Trait => true,\n-            _ => false,\n-        }\n+        matches!(self, FnDeclKind::Fn | FnDeclKind::Inherent | FnDeclKind::Impl | FnDeclKind::Trait)\n     }\n \n     fn return_impl_trait_allowed(&self, tcx: TyCtxt<'_>) -> bool {\n@@ -371,8 +369,8 @@ fn index_crate<'a>(\n     krate: &'a Crate,\n ) -> IndexVec<LocalDefId, AstOwner<'a>> {\n     let mut indexer = Indexer { node_id_to_def_id, index: IndexVec::new() };\n-    indexer.index.ensure_contains_elem(CRATE_DEF_ID, || AstOwner::NonOwner);\n-    indexer.index[CRATE_DEF_ID] = AstOwner::Crate(krate);\n+    *indexer.index.ensure_contains_elem(CRATE_DEF_ID, || AstOwner::NonOwner) =\n+        AstOwner::Crate(krate);\n     visit::walk_crate(&mut indexer, krate);\n     return indexer.index;\n \n@@ -389,22 +387,21 @@ fn index_crate<'a>(\n \n         fn visit_item(&mut self, item: &'a ast::Item) {\n             let def_id = self.node_id_to_def_id[&item.id];\n-            self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n-            self.index[def_id] = AstOwner::Item(item);\n+            *self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner) = AstOwner::Item(item);\n             visit::walk_item(self, item)\n         }\n \n         fn visit_assoc_item(&mut self, item: &'a ast::AssocItem, ctxt: visit::AssocCtxt) {\n             let def_id = self.node_id_to_def_id[&item.id];\n-            self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n-            self.index[def_id] = AstOwner::AssocItem(item, ctxt);\n+            *self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner) =\n+                AstOwner::AssocItem(item, ctxt);\n             visit::walk_assoc_item(self, item, ctxt);\n         }\n \n         fn visit_foreign_item(&mut self, item: &'a ast::ForeignItem) {\n             let def_id = self.node_id_to_def_id[&item.id];\n-            self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner);\n-            self.index[def_id] = AstOwner::ForeignItem(item);\n+            *self.index.ensure_contains_elem(def_id, || AstOwner::NonOwner) =\n+                AstOwner::ForeignItem(item);\n             visit::walk_foreign_item(self, item);\n         }\n     }"}, {"sha": "eb73612352072607f0acbb5e83bcd05b61d6a602", "filename": "compiler/rustc_ast_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -12,6 +12,7 @@ rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_feature = { path = \"../rustc_feature\" }\n rustc_macros = { path = \"../rustc_macros\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "ffca37ae9d5f673f9470c39ee5bd7f7a29ef09c8", "filename": "compiler/rustc_ast_passes/messages.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fmessages.ftl?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -231,7 +231,7 @@ ast_passes_feature_on_non_nightly = `#![feature]` may not be used on the {$chann\n     .suggestion = remove the attribute\n     .stable_since = the feature `{$name}` has been stable since `{$since}` and no longer requires an attribute to enable\n \n-ast_passes_incompatbile_features = `{$f1}` and `{$f2}` are incompatible, using them at the same time is not allowed\n+ast_passes_incompatible_features = `{$f1}` and `{$f2}` are incompatible, using them at the same time is not allowed\n     .help = remove one of these features\n \n ast_passes_show_span = {$msg}"}, {"sha": "1732865f0bb6489657735f10cc654f3aac9f2863", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -677,7 +677,7 @@ impl AddToDiagnostic for StableFeature {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes_incompatbile_features)]\n+#[diag(ast_passes_incompatible_features)]\n #[help]\n pub struct IncompatibleFeatures {\n     #[primary_span]"}, {"sha": "7db413c5bbd420ca927d2dbb50b967877c601244", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -13,7 +13,7 @@\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n-use rustc_macros::fluent_messages;\n+use rustc_fluent_macro::fluent_messages;\n \n pub mod ast_validation;\n mod errors;"}, {"sha": "7ab8c3eaba2273d96a6a4693dc53653f314eba36", "filename": "compiler/rustc_ast_pretty/src/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -360,7 +360,7 @@ impl Printer {\n \n     fn check_stack(&mut self, mut depth: usize) {\n         while let Some(&index) = self.scan_stack.back() {\n-            let mut entry = &mut self.buf[index];\n+            let entry = &mut self.buf[index];\n             match entry.token {\n                 Token::Begin(_) => {\n                     if depth == 0 {"}, {"sha": "aeb0c762020418617622331155469ee1c8dc9109", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -549,6 +549,26 @@ impl<'a> State<'a> {\n                 self.end();\n                 self.pclose();\n             }\n+            ast::ExprKind::OffsetOf(container, fields) => {\n+                // FIXME: This should have its own syntax, distinct from a macro invocation.\n+                self.word(\"offset_of!\");\n+                self.popen();\n+                self.rbox(0, Inconsistent);\n+                self.print_type(container);\n+                self.word(\",\");\n+                self.space();\n+\n+                if let Some((&first, rest)) = fields.split_first() {\n+                    self.print_ident(first);\n+\n+                    for &field in rest {\n+                        self.word(\".\");\n+                        self.print_ident(field);\n+                    }\n+                }\n+\n+                self.end();\n+            }\n             ast::ExprKind::MacCall(m) => self.print_mac(m),\n             ast::ExprKind::Paren(e) => {\n                 self.popen();"}, {"sha": "2c4c3a0c2635b5ff1888e32fc60fc22ac3646139", "filename": "compiler/rustc_attr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_attr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_attr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -9,6 +9,7 @@ edition = \"2021\"\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_errors = { path = \"../rustc_errors\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_feature = { path = \"../rustc_feature\" }"}, {"sha": "cfed2acfb3a41dec0806f114a8b3d67a5e19706a", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -12,7 +12,7 @@\n extern crate rustc_macros;\n \n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n-use rustc_macros::fluent_messages;\n+use rustc_fluent_macro::fluent_messages;\n \n mod builtin;\n mod session_diagnostics;"}, {"sha": "56a9deb6aab1443d4b52da4f8f6d08cb4d9d2a0b", "filename": "compiler/rustc_borrowck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -15,12 +15,12 @@ rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_graphviz = { path = \"../rustc_graphviz\" }\n rustc_hir = { path = \"../rustc_hir\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n-rustc_const_eval = { path = \"../rustc_const_eval\" }\n rustc_mir_dataflow = { path = \"../rustc_mir_dataflow\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "0b8123c970360abd9b10b51c6cec907d23e46f15", "filename": "compiler/rustc_borrowck/messages.ftl", "status": "modified", "additions": 138, "deletions": 12, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fmessages.ftl?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -56,18 +56,6 @@ borrowck_returned_lifetime_short =\n borrowck_used_impl_require_static =\n     the used `impl` has a `'static` requirement\n \n-borrowck_capture_kind_label =\n-    capture is {$kind_desc} because of use here\n-\n-borrowck_var_borrow_by_use_place_in_generator =\n-    borrow occurs due to use of {$place} in closure in generator\n-\n-borrowck_var_borrow_by_use_place_in_closure =\n-    borrow occurs due to use of {$place} in closure\n-\n-borrowck_var_borrow_by_use_place =\n-    borrow occurs due to use of {$place}\n-\n borrowck_borrow_due_to_use_generator =\n     borrow occurs due to use in generator\n \n@@ -101,12 +89,63 @@ borrowck_capture_mut =\n borrowck_capture_move =\n     capture is moved because of use here\n \n+borrowck_var_borrow_by_use_place_in_generator =\n+    {$is_single_var ->\n+        *[true] borrow occurs\n+        [false] borrows occur\n+    } due to use of {$place} in generator\n+\n+borrowck_var_borrow_by_use_place_in_closure =\n+    {$is_single_var ->\n+        *[true] borrow occurs\n+        [false] borrows occur\n+    } due to use of {$place} in closure\n+\n+borrowck_var_borrow_by_use_in_generator =\n+    borrow occurs due to use in generator\n+\n+borrowck_var_borrow_by_use_in_closure =\n+    borrow occurs due to use in closure\n+\n borrowck_var_move_by_use_place_in_generator =\n     move occurs due to use of {$place} in generator\n \n borrowck_var_move_by_use_place_in_closure =\n     move occurs due to use of {$place} in closure\n \n+borrowck_var_move_by_use_in_generator =\n+    move occurs due to use in generator\n+\n+borrowck_var_move_by_use_in_closure =\n+    move occurs due to use in closure\n+\n+borrowck_partial_var_move_by_use_in_generator =\n+    variable {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to use in generator\n+\n+borrowck_partial_var_move_by_use_in_closure =\n+    variable {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to use in closure\n+\n+borrowck_var_first_borrow_by_use_place_in_generator =\n+    first borrow occurs due to use of {$place} in generator\n+\n+borrowck_var_first_borrow_by_use_place_in_closure =\n+    first borrow occurs due to use of {$place} in closure\n+\n+borrowck_var_second_borrow_by_use_place_in_generator =\n+    second borrow occurs due to use of {$place} in generator\n+\n+borrowck_var_second_borrow_by_use_place_in_closure =\n+    second borrow occurs due to use of {$place} in closure\n+\n+borrowck_var_mutable_borrow_by_use_place_in_closure =\n+    mutable borrow occurs due to use of {$place} in closure\n+\n borrowck_cannot_move_when_borrowed =\n     cannot move out of {$place ->\n         [value] value\n@@ -127,3 +166,90 @@ borrowck_opaque_type_non_generic_param =\n         [true] cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n         *[other] this generic parameter must be used with a generic {$kind} parameter\n     }\n+\n+borrowck_moved_due_to_call =\n+    {$place_name} {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to this {$is_loop_message ->\n+        [true] call, in previous iteration of loop\n+        *[false] call\n+    }\n+\n+borrowck_moved_due_to_usage_in_operator =\n+    {$place_name} {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to usage in {$is_loop_message ->\n+        [true] operator, in previous iteration of loop\n+        *[false] operator\n+    }\n+\n+borrowck_moved_due_to_implicit_into_iter_call =\n+    {$place_name} {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to this implicit call to {$is_loop_message ->\n+        [true] `.into_iter()`, in previous iteration of loop\n+        *[false] `.into_iter()`\n+    }\n+\n+borrowck_moved_due_to_method_call =\n+    {$place_name} {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to this method {$is_loop_message ->\n+        [true] call, in previous iteration of loop\n+        *[false] call\n+    }\n+\n+borrowck_value_moved_here =\n+    value {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } {$is_move_msg ->\n+        [true] into closure here\n+        *[false] here\n+    }{$is_loop_message ->\n+        [true] , in previous iteration of loop\n+        *[false] {\"\"}\n+    }\n+\n+borrowck_consider_borrow_type_contents =\n+    help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents\n+\n+borrowck_moved_a_fn_once_in_call =\n+    this value implements `FnOnce`, which causes it to be moved when called\n+\n+borrowck_calling_operator_moves_lhs =\n+    calling this operator moves the left-hand side\n+\n+borrowck_func_take_self_moved_place =\n+    `{$func}` takes ownership of the receiver `self`, which moves {$place_name}\n+\n+borrowck_suggest_iterate_over_slice =\n+    consider iterating over a slice of the `{$ty}`'s content to avoid moving into the `for` loop\n+\n+borrowck_suggest_create_freash_reborrow =\n+    consider reborrowing the `Pin` instead of moving it\n+\n+borrowck_value_capture_here =\n+    value captured {$is_within ->\n+        [true] here by generator\n+        *[false] here\n+    }\n+\n+borrowck_move_out_place_here =\n+    {$place} is moved here\n+\n+borrowck_closure_invoked_twice =\n+    closure cannot be invoked more than once because it moves the variable `{$place_name}` out of its environment\n+\n+borrowck_closure_moved_twice =\n+    closure cannot be moved more than once as it is not `Copy` due to moving the variable `{$place_name}` out of its environment\n+\n+borrowck_ty_no_impl_copy =\n+    {$is_partial_move ->\n+        [true] partial move\n+        *[false] move\n+    } occurs because {$place} has type `{$ty}`, which does not implement the `Copy` trait"}, {"sha": "acca1a1477f2540d21165f7748d1ee84d482a4e2", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -469,6 +469,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     #[rustc_lint_diagnostics]\n+    #[track_caller]\n     pub(crate) fn struct_span_err_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,"}, {"sha": "8b7d9ec2cd671cf659ddfddf303802c26d68ceb0", "filename": "compiler/rustc_borrowck/src/constraints/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,5 +1,5 @@\n use rustc_data_structures::graph;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::{RegionVid, VarianceDiagInfo};\n use rustc_span::DUMMY_SP;"}, {"sha": "315886bbe29ba53f302159f7f1c3268c660d916f", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -2,7 +2,7 @@\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n use rustc_data_structures::graph::scc::Sccs;\n-use rustc_index::vec::{IndexSlice, IndexVec};\n+use rustc_index::{IndexSlice, IndexVec};\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::{RegionVid, VarianceDiagInfo};\n use rustc_span::Span;"}, {"sha": "3451b7db8caaea5010b3194d6f010cbad620a9ef", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -3,10 +3,10 @@\n //! This file provides API for compiler consumers.\n \n use rustc_hir::def_id::LocalDefId;\n-use rustc_index::vec::IndexSlice;\n+use rustc_index::IndexSlice;\n use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n use rustc_middle::mir::Body;\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n \n pub use super::{\n     facts::{AllFacts as PoloniusInput, RustcFacts},\n@@ -28,12 +28,9 @@ pub use super::{\n ///     that shows how to do this at `tests/run-make/obtain-borrowck/`.\n ///\n /// *   Polonius is highly unstable, so expect regular changes in its signature or other details.\n-pub fn get_body_with_borrowck_facts(\n-    tcx: TyCtxt<'_>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n-) -> BodyWithBorrowckFacts<'_> {\n+pub fn get_body_with_borrowck_facts(tcx: TyCtxt<'_>, def: LocalDefId) -> BodyWithBorrowckFacts<'_> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n-    let infcx = tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def.did)).build();\n+    let infcx = tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def)).build();\n     let input_body: &Body<'_> = &input_body.borrow();\n     let promoted: &IndexSlice<_, _> = &promoted.borrow();\n     *super::do_mir_borrowck(&infcx, input_body, promoted, true).1.unwrap()"}, {"sha": "6259722b6940f1d3f2de5a2f34989e087e856a2a", "filename": "compiler/rustc_borrowck/src/def_use.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -52,12 +52,16 @@ pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::ShallowBorrow) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::UniqueBorrow) |\n \n+        // `PlaceMention` and `AscribeUserType` both evaluate the place, which must not\n+        // contain dangling references.\n+        PlaceContext::NonUse(NonUseContext::PlaceMention) |\n+        PlaceContext::NonUse(NonUseContext::AscribeUserTy) |\n+\n         PlaceContext::MutatingUse(MutatingUseContext::AddressOf) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::Inspect) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) |\n-        PlaceContext::NonUse(NonUseContext::AscribeUserTy) |\n         PlaceContext::MutatingUse(MutatingUseContext::Retag) =>\n             Some(DefUse::Use),\n \n@@ -72,8 +76,6 @@ pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n         PlaceContext::MutatingUse(MutatingUseContext::Drop) =>\n             Some(DefUse::Drop),\n \n-        // This statement exists to help unsafeck. It does not require the place to be live.\n-        PlaceContext::NonUse(NonUseContext::PlaceMention) => None,\n         // Debug info is neither def nor use.\n         PlaceContext::NonUse(NonUseContext::VarDebugInfo) => None,\n "}, {"sha": "ac84188a35fb1e3d43b34b68f8ad0178874fff96", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 286, "deletions": 99, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,5 +1,6 @@\n+use std::iter;\n+\n use either::Either;\n-use rustc_const_eval::util::CallKind;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{\n@@ -9,29 +10,28 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, LangItem};\n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::ObligationCause;\n+use rustc_middle::hir::nested_filter::OnlyBodies;\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n     FakeReadCause, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty};\n+use rustc_middle::util::CallKind;\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{BytePos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::ObligationCtxt;\n \n use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n-\n use crate::diagnostics::conflict_errors::StorageDeadOrDrop::LocalStorageDead;\n-use crate::diagnostics::find_all_local_uses;\n-use crate::diagnostics::mutability_errors::mut_borrow_of_mutable_ref;\n+use crate::diagnostics::{find_all_local_uses, CapturedMessageOpt};\n use crate::{\n     borrow_set::BorrowData, diagnostics::Instance, prefixes::IsPrefixOf,\n     InitializationRequiringAction, MirBorrowckCtxt, PrefixSet, WriteKind,\n@@ -183,13 +183,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let move_spans = self.move_spans(moved_place.as_ref(), move_out.source);\n                 let move_span = move_spans.args_or_use();\n \n-                let move_msg = if move_spans.for_closure() { \" into closure\" } else { \"\" };\n+                let is_move_msg = move_spans.for_closure();\n \n-                let loop_message = if location == move_out.source || move_site.traversed_back_edge {\n-                    \", in previous iteration of loop\"\n-                } else {\n-                    \"\"\n-                };\n+                let is_loop_message = location == move_out.source || move_site.traversed_back_edge;\n \n                 if location == move_out.source {\n                     is_loop_move = true;\n@@ -206,17 +202,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         );\n                     }\n \n+                    let msg_opt = CapturedMessageOpt {\n+                        is_partial_move,\n+                        is_loop_message,\n+                        is_move_msg,\n+                        is_loop_move,\n+                        maybe_reinitialized_locations_is_empty: maybe_reinitialized_locations\n+                            .is_empty(),\n+                    };\n                     self.explain_captures(\n                         &mut err,\n                         span,\n                         move_span,\n                         move_spans,\n                         *moved_place,\n-                        partially_str,\n-                        loop_message,\n-                        move_msg,\n-                        is_loop_move,\n-                        maybe_reinitialized_locations.is_empty(),\n+                        msg_opt,\n                     );\n                 }\n                 seen_spans.insert(move_span);\n@@ -282,12 +282,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             if needs_note {\n-                let span = if let Some(local) = place.as_local() {\n-                    Some(self.body.local_decls[local].source_info.span)\n+                if let Some(local) = place.as_local() {\n+                    let span = self.body.local_decls[local].source_info.span;\n+                    err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Label {\n+                        is_partial_move,\n+                        ty,\n+                        place: &note_msg,\n+                        span,\n+                    });\n                 } else {\n-                    None\n+                    err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Note {\n+                        is_partial_move,\n+                        ty,\n+                        place: &note_msg,\n+                    });\n                 };\n-                self.note_type_does_not_implement_copy(&mut err, &note_msg, ty, span, partial_str);\n             }\n \n             if let UseSpans::FnSelfUse {\n@@ -633,11 +642,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let Some(default_trait) = tcx.get_diagnostic_item(sym::Default) else {\n                 return false;\n             };\n-            // Regions are already solved, so we must use a fresh InferCtxt,\n-            // but the type has region variables, so erase those.\n-            tcx.infer_ctxt()\n-                .build()\n-                .type_implements_trait(default_trait, [tcx.erase_regions(ty)], param_env)\n+            self.infcx\n+                .type_implements_trait(default_trait, [ty], param_env)\n                 .must_apply_modulo_regions()\n         };\n \n@@ -696,7 +702,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 .copied()\n                 .find_map(find_fn_kind_from_did),\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => tcx\n-                .bound_explicit_item_bounds(def_id)\n+                .explicit_item_bounds(def_id)\n                 .subst_iter_copied(tcx, substs)\n                 .find_map(find_fn_kind_from_did),\n             ty::Closure(_, substs) => match substs.as_closure().kind() {\n@@ -730,13 +736,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn suggest_cloning(&self, err: &mut Diagnostic, ty: Ty<'tcx>, span: Span) {\n         let tcx = self.infcx.tcx;\n         // Try to find predicates on *generic params* that would allow copying `ty`\n-        let infcx = tcx.infer_ctxt().build();\n-\n         if let Some(clone_trait_def) = tcx.lang_items().clone_trait()\n-            && infcx\n+            && self.infcx\n                 .type_implements_trait(\n                     clone_trait_def,\n-                    [tcx.erase_regions(ty)],\n+                    [ty],\n                     self.param_env,\n                 )\n                 .must_apply_modulo_regions()\n@@ -760,12 +764,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .and_then(|def_id| tcx.hir().get_generics(def_id))\n         else { return; };\n         // Try to find predicates on *generic params* that would allow copying `ty`\n-        let infcx = tcx.infer_ctxt().build();\n-        let ocx = ObligationCtxt::new(&infcx);\n+        let ocx = ObligationCtxt::new(&self.infcx);\n         let copy_did = tcx.require_lang_item(LangItem::Copy, Some(span));\n         let cause = ObligationCause::misc(span, self.mir_def_id());\n \n-        ocx.register_bound(cause, self.param_env, infcx.tcx.erase_regions(ty), copy_did);\n+        ocx.register_bound(cause, self.param_env, ty, copy_did);\n         let errors = ocx.select_all_or_error();\n \n         // Only emit suggestion if all required predicates are on generic\n@@ -827,11 +830,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         borrow_spans.var_path_only_subdiag(&mut err, crate::InitializationRequiringAction::Borrow);\n \n-        move_spans.var_span_label(\n-            &mut err,\n-            format!(\"move occurs due to use{}\", move_spans.describe()),\n-            \"moved\",\n-        );\n+        move_spans.var_subdiag(None, &mut err, None, |kind, var_span| {\n+            use crate::session_diagnostics::CaptureVarCause::*;\n+            match kind {\n+                Some(_) => MoveUseInGenerator { var_span },\n+                None => MoveUseInClosure { var_span },\n+            }\n+        });\n \n         self.explain_why_borrow_contains_point(location, borrow, None)\n             .add_explanation_to_diagnostic(\n@@ -868,13 +873,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             borrow_span,\n             &self.describe_any_place(borrow.borrowed_place.as_ref()),\n         );\n-        borrow_spans.var_subdiag(&mut err, Some(borrow.kind), |kind, var_span| {\n+        borrow_spans.var_subdiag(None, &mut err, Some(borrow.kind), |kind, var_span| {\n             use crate::session_diagnostics::CaptureVarCause::*;\n             let place = &borrow.borrowed_place;\n             let desc_place = self.describe_any_place(place.as_ref());\n             match kind {\n-                Some(_) => BorrowUsePlaceGenerator { place: desc_place, var_span },\n-                None => BorrowUsePlaceClosure { place: desc_place, var_span },\n+                Some(_) => {\n+                    BorrowUsePlaceGenerator { place: desc_place, var_span, is_single_var: true }\n+                }\n+                None => BorrowUsePlaceClosure { place: desc_place, var_span, is_single_var: true },\n             }\n         });\n \n@@ -946,7 +953,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     &msg_borrow,\n                     None,\n                 );\n-                self.suggest_binding_for_closure_capture_self(\n+                self.suggest_binding_for_closure_capture_self(&mut err, &issued_spans);\n+                self.suggest_using_closure_argument_instead_of_capture(\n                     &mut err,\n                     issued_borrow.borrowed_place,\n                     &issued_spans,\n@@ -969,6 +977,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     place,\n                     issued_borrow.borrowed_place,\n                 );\n+                self.suggest_using_closure_argument_instead_of_capture(\n+                    &mut err,\n+                    issued_borrow.borrowed_place,\n+                    &issued_spans,\n+                );\n                 err\n             }\n \n@@ -988,16 +1001,26 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         immutable_section_description,\n                         \"mutably borrow\",\n                     );\n-                    borrow_spans.var_span_label(\n+                    borrow_spans.var_subdiag(\n+                        None,\n                         &mut err,\n-                        format!(\n-                            \"borrow occurs due to use of {}{}\",\n-                            desc_place,\n-                            borrow_spans.describe(),\n-                        ),\n-                        \"immutable\",\n+                        Some(BorrowKind::Unique),\n+                        |kind, var_span| {\n+                            use crate::session_diagnostics::CaptureVarCause::*;\n+                            match kind {\n+                                Some(_) => BorrowUsePlaceGenerator {\n+                                    place: desc_place,\n+                                    var_span,\n+                                    is_single_var: true,\n+                                },\n+                                None => BorrowUsePlaceClosure {\n+                                    place: desc_place,\n+                                    var_span,\n+                                    is_single_var: true,\n+                                },\n+                            }\n+                        },\n                     );\n-\n                     return err;\n                 } else {\n                     first_borrow_desc = \"immutable \";\n@@ -1070,32 +1093,48 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         if issued_spans == borrow_spans {\n-            borrow_spans.var_span_label(\n-                &mut err,\n-                format!(\"borrows occur due to use of {}{}\", desc_place, borrow_spans.describe(),),\n-                gen_borrow_kind.describe_mutability(),\n-            );\n+            borrow_spans.var_subdiag(None, &mut err, Some(gen_borrow_kind), |kind, var_span| {\n+                use crate::session_diagnostics::CaptureVarCause::*;\n+                match kind {\n+                    Some(_) => BorrowUsePlaceGenerator {\n+                        place: desc_place,\n+                        var_span,\n+                        is_single_var: false,\n+                    },\n+                    None => {\n+                        BorrowUsePlaceClosure { place: desc_place, var_span, is_single_var: false }\n+                    }\n+                }\n+            });\n         } else {\n-            let borrow_place = &issued_borrow.borrowed_place;\n-            let borrow_place_desc = self.describe_any_place(borrow_place.as_ref());\n-            issued_spans.var_span_label(\n+            issued_spans.var_subdiag(\n+                Some(&self.infcx.tcx.sess.parse_sess.span_diagnostic),\n                 &mut err,\n-                format!(\n-                    \"first borrow occurs due to use of {}{}\",\n-                    borrow_place_desc,\n-                    issued_spans.describe(),\n-                ),\n-                issued_borrow.kind.describe_mutability(),\n+                Some(issued_borrow.kind),\n+                |kind, var_span| {\n+                    use crate::session_diagnostics::CaptureVarCause::*;\n+                    let borrow_place = &issued_borrow.borrowed_place;\n+                    let borrow_place_desc = self.describe_any_place(borrow_place.as_ref());\n+                    match kind {\n+                        Some(_) => {\n+                            FirstBorrowUsePlaceGenerator { place: borrow_place_desc, var_span }\n+                        }\n+                        None => FirstBorrowUsePlaceClosure { place: borrow_place_desc, var_span },\n+                    }\n+                },\n             );\n \n-            borrow_spans.var_span_label(\n+            borrow_spans.var_subdiag(\n+                Some(&self.infcx.tcx.sess.parse_sess.span_diagnostic),\n                 &mut err,\n-                format!(\n-                    \"second borrow occurs due to use of {}{}\",\n-                    desc_place,\n-                    borrow_spans.describe(),\n-                ),\n-                gen_borrow_kind.describe_mutability(),\n+                Some(gen_borrow_kind),\n+                |kind, var_span| {\n+                    use crate::session_diagnostics::CaptureVarCause::*;\n+                    match kind {\n+                        Some(_) => SecondBorrowUsePlaceGenerator { place: desc_place, var_span },\n+                        None => SecondBorrowUsePlaceClosure { place: desc_place, var_span },\n+                    }\n+                },\n             );\n         }\n \n@@ -1229,22 +1268,160 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    fn suggest_binding_for_closure_capture_self(\n+    /// Suggest using closure argument instead of capture.\n+    ///\n+    /// For example:\n+    /// ```ignore (illustrative)\n+    /// struct S;\n+    ///\n+    /// impl S {\n+    ///     fn call(&mut self, f: impl Fn(&mut Self)) { /* ... */ }\n+    ///     fn x(&self) {}\n+    /// }\n+    ///\n+    ///     let mut v = S;\n+    ///     v.call(|this: &mut S| v.x());\n+    /// //  ^\\                    ^-- help: try using the closure argument: `this`\n+    /// //    *-- error: cannot borrow `v` as mutable because it is also borrowed as immutable\n+    /// ```\n+    fn suggest_using_closure_argument_instead_of_capture(\n         &self,\n         err: &mut Diagnostic,\n         borrowed_place: Place<'tcx>,\n         issued_spans: &UseSpans<'tcx>,\n     ) {\n-        let UseSpans::ClosureUse { capture_kind_span, .. } = issued_spans else { return };\n-        let hir = self.infcx.tcx.hir();\n+        let &UseSpans::ClosureUse { capture_kind_span, .. } = issued_spans else { return };\n+        let tcx = self.infcx.tcx;\n+        let hir = tcx.hir();\n \n-        // check whether the borrowed place is capturing `self` by mut reference\n+        // Get the type of the local that we are trying to borrow\n         let local = borrowed_place.local;\n-        let Some(_) = self\n-            .body\n-            .local_decls\n-            .get(local)\n-            .map(|l| mut_borrow_of_mutable_ref(l, self.local_names[local])) else { return };\n+        let local_ty = self.body.local_decls[local].ty;\n+\n+        // Get the body the error happens in\n+        let Some(body_id) = hir.get(self.mir_hir_id()).body_id() else { return };\n+\n+        let body_expr = hir.body(body_id).value;\n+\n+        struct ClosureFinder<'hir> {\n+            hir: rustc_middle::hir::map::Map<'hir>,\n+            borrow_span: Span,\n+            res: Option<(&'hir hir::Expr<'hir>, &'hir hir::Closure<'hir>)>,\n+            /// The path expression with the `borrow_span` span\n+            error_path: Option<(&'hir hir::Expr<'hir>, &'hir hir::QPath<'hir>)>,\n+        }\n+        impl<'hir> Visitor<'hir> for ClosureFinder<'hir> {\n+            type NestedFilter = OnlyBodies;\n+\n+            fn nested_visit_map(&mut self) -> Self::Map {\n+                self.hir\n+            }\n+\n+            fn visit_expr(&mut self, ex: &'hir hir::Expr<'hir>) {\n+                if let hir::ExprKind::Path(qpath) = &ex.kind\n+                    && ex.span == self.borrow_span\n+                {\n+                    self.error_path = Some((ex, qpath));\n+                }\n+\n+                if let hir::ExprKind::Closure(closure) = ex.kind\n+                    && ex.span.contains(self.borrow_span)\n+                    // To support cases like `|| { v.call(|this| v.get()) }`\n+                    // FIXME: actually support such cases (need to figure out how to move from the capture place to original local)\n+                    && self.res.as_ref().map_or(true, |(prev_res, _)| prev_res.span.contains(ex.span))\n+                {\n+                    self.res = Some((ex, closure));\n+                }\n+\n+                hir::intravisit::walk_expr(self, ex);\n+            }\n+        }\n+\n+        // Find the closure that most tightly wraps `capture_kind_span`\n+        let mut finder =\n+            ClosureFinder { hir, borrow_span: capture_kind_span, res: None, error_path: None };\n+        finder.visit_expr(body_expr);\n+        let Some((closure_expr, closure)) = finder.res else { return };\n+\n+        let typeck_results = tcx.typeck(self.mir_def_id());\n+\n+        // Check that the parent of the closure is a method call,\n+        // with receiver matching with local's type (modulo refs)\n+        let parent = hir.parent_id(closure_expr.hir_id);\n+        if let hir::Node::Expr(parent) = hir.get(parent) {\n+            if let hir::ExprKind::MethodCall(_, recv, ..) = parent.kind {\n+                let recv_ty = typeck_results.expr_ty(recv);\n+\n+                if recv_ty.peel_refs() != local_ty {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        // Get closure's arguments\n+        let ty::Closure(_, substs) = typeck_results.expr_ty(closure_expr).kind() else { /* hir::Closure can be a generator too */ return };\n+        let sig = substs.as_closure().sig();\n+        let tupled_params =\n+            tcx.erase_late_bound_regions(sig.inputs().iter().next().unwrap().map_bound(|&b| b));\n+        let ty::Tuple(params) = tupled_params.kind() else { return };\n+\n+        // Find the first argument with a matching type, get its name\n+        let Some((_, this_name)) = params\n+            .iter()\n+            .zip(hir.body_param_names(closure.body))\n+            .find(|(param_ty, name)|{\n+                // FIXME: also support deref for stuff like `Rc` arguments\n+                param_ty.peel_refs() == local_ty && name != &Ident::empty()\n+            })\n+            else { return };\n+\n+        let spans;\n+        if let Some((_path_expr, qpath)) = finder.error_path\n+            && let hir::QPath::Resolved(_, path) = qpath\n+            && let hir::def::Res::Local(local_id) = path.res\n+        {\n+            // Find all references to the problematic variable in this closure body\n+\n+            struct VariableUseFinder {\n+                local_id: hir::HirId,\n+                spans: Vec<Span>,\n+            }\n+            impl<'hir> Visitor<'hir> for VariableUseFinder {\n+                fn visit_expr(&mut self, ex: &'hir hir::Expr<'hir>) {\n+                    if let hir::ExprKind::Path(qpath) = &ex.kind\n+                        && let hir::QPath::Resolved(_, path) = qpath\n+                        && let hir::def::Res::Local(local_id) = path.res\n+                        && local_id == self.local_id\n+                    {\n+                        self.spans.push(ex.span);\n+                    }\n+\n+                    hir::intravisit::walk_expr(self, ex);\n+                }\n+            }\n+\n+            let mut finder = VariableUseFinder { local_id, spans: Vec::new() };\n+            finder.visit_expr(hir.body(closure.body).value);\n+\n+            spans = finder.spans;\n+        } else {\n+            spans = vec![capture_kind_span];\n+        }\n+\n+        err.multipart_suggestion(\n+            \"try using the closure argument\",\n+            iter::zip(spans, iter::repeat(this_name.to_string())).collect(),\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n+    fn suggest_binding_for_closure_capture_self(\n+        &self,\n+        err: &mut Diagnostic,\n+        issued_spans: &UseSpans<'tcx>,\n+    ) {\n+        let UseSpans::ClosureUse { capture_kind_span, .. } = issued_spans else { return };\n+        let hir = self.infcx.tcx.hir();\n \n         struct ExpressionFinder<'hir> {\n             capture_span: Span,\n@@ -1731,9 +1908,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             err.span_label(borrow_span, \"borrowed value does not live long enough\");\n             err.span_label(drop_span, format!(\"`{}` dropped here while still borrowed\", name));\n \n-            let within = if borrow_spans.for_generator() { \" by generator\" } else { \"\" };\n-\n-            borrow_spans.args_span_label(&mut err, format!(\"value captured here{}\", within));\n+            borrow_spans.args_subdiag(&mut err, |args_span| {\n+                crate::session_diagnostics::CaptureArgLabel::Capture {\n+                    is_within: borrow_spans.for_generator(),\n+                    args_span,\n+                }\n+            });\n \n             explanation.add_explanation_to_diagnostic(\n                 self.infcx.tcx,\n@@ -1947,9 +2127,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             None,\n         );\n \n-        let within = if borrow_spans.for_generator() { \" by generator\" } else { \"\" };\n-\n-        borrow_spans.args_span_label(&mut err, format!(\"value captured here{}\", within));\n+        borrow_spans.args_subdiag(&mut err, |args_span| {\n+            crate::session_diagnostics::CaptureArgLabel::Capture {\n+                is_within: borrow_spans.for_generator(),\n+                args_span,\n+            }\n+        });\n \n         err\n     }\n@@ -2029,7 +2212,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let tcx = self.infcx.tcx;\n \n             let return_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n-            let return_ty = tcx.erase_regions(return_ty);\n \n             // to avoid panics\n             if let Some(iter_trait) = tcx.get_diagnostic_item(sym::Iterator)\n@@ -2382,11 +2564,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     section,\n                     \"assign\",\n                 );\n-                loan_spans.var_span_label(\n-                    &mut err,\n-                    format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n-                    loan.kind.describe_mutability(),\n-                );\n+\n+                loan_spans.var_subdiag(None, &mut err, Some(loan.kind), |kind, var_span| {\n+                    use crate::session_diagnostics::CaptureVarCause::*;\n+                    match kind {\n+                        Some(_) => BorrowUseInGenerator { var_span },\n+                        None => BorrowUseInClosure { var_span },\n+                    }\n+                });\n \n                 self.buffer_error(err);\n \n@@ -2396,11 +2581,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         let mut err = self.cannot_assign_to_borrowed(span, loan_span, &descr_place);\n \n-        loan_spans.var_span_label(\n-            &mut err,\n-            format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n-            loan.kind.describe_mutability(),\n-        );\n+        loan_spans.var_subdiag(None, &mut err, Some(loan.kind), |kind, var_span| {\n+            use crate::session_diagnostics::CaptureVarCause::*;\n+            match kind {\n+                Some(_) => BorrowUseInGenerator { var_span },\n+                None => BorrowUseInClosure { var_span },\n+            }\n+        });\n \n         self.explain_why_borrow_contains_point(location, loan, None).add_explanation_to_diagnostic(\n             self.infcx.tcx,\n@@ -2424,7 +2611,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             Some((method_did, method_substs)),\n         ) = (\n             &self.body[loan.reserve_location.block].terminator,\n-            rustc_const_eval::util::find_self_call(\n+            rustc_middle::util::find_self_call(\n                 tcx,\n                 self.body,\n                 loan.assigned_place.local,"}, {"sha": "f995c3165a91e2da189f674d53055e1b047f3e42", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -3,7 +3,7 @@\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n-use rustc_index::vec::IndexSlice;\n+use rustc_index::IndexSlice;\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::mir::{\n     Body, CastKind, ConstraintCategory, FakeReadCause, Local, LocalInfo, Location, Operand, Place,"}, {"sha": "4243ec214b098fcd11fc196ac10525688f747c2c", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 118, "deletions": 163, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,20 +1,24 @@\n //! Borrow checker diagnostics.\n \n+use crate::session_diagnostics::{\n+    CaptureArgLabel, CaptureReasonLabel, CaptureReasonNote, CaptureReasonSuggest, CaptureVarCause,\n+    CaptureVarKind, CaptureVarPathUseCause, OnClosureNote,\n+};\n use itertools::Itertools;\n-use rustc_const_eval::util::{call_kind, CallDesugaringKind};\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, Namespace};\n use rustc_hir::GeneratorKind;\n-use rustc_index::vec::IndexSlice;\n-use rustc_infer::infer::{LateBoundRegionConversionTime, TyCtxtInferExt};\n+use rustc_index::IndexSlice;\n+use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::{\n     AggregateKind, Constant, FakeReadCause, Local, LocalInfo, LocalKind, Location, Operand, Place,\n     PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n+use rustc_middle::util::{call_kind, CallDesugaringKind};\n use rustc_mir_dataflow::move_paths::{InitLocation, LookupResult};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n@@ -45,7 +49,7 @@ pub(crate) use mutability_errors::AccessKind;\n pub(crate) use outlives_suggestion::OutlivesSuggestionBuilder;\n pub(crate) use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n pub(crate) use region_name::{RegionName, RegionNameSource};\n-pub(crate) use rustc_const_eval::util::CallKind;\n+pub(crate) use rustc_middle::util::CallKind;\n \n pub(super) struct DescribePlaceOpt {\n     pub including_downcast: bool,\n@@ -117,13 +121,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind() {\n                         let did = did.expect_local();\n                         if let Some((span, hir_place)) = self.infcx.tcx.closure_kind_origin(did) {\n-                            diag.span_note(\n-                                *span,\n-                                &format!(\n-                                    \"closure cannot be invoked more than once because it moves the \\\n-                                    variable `{}` out of its environment\",\n-                                    ty::place_to_string_for_capture(self.infcx.tcx, hir_place)\n-                                ),\n+                            diag.eager_subdiagnostic(\n+                                &self.infcx.tcx.sess.parse_sess.span_diagnostic,\n+                                OnClosureNote::InvokedTwice {\n+                                    place_name: &ty::place_to_string_for_capture(\n+                                        self.infcx.tcx,\n+                                        hir_place,\n+                                    ),\n+                                    span: *span,\n+                                },\n                             );\n                             return true;\n                         }\n@@ -137,13 +143,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind() {\n                 let did = did.expect_local();\n                 if let Some((span, hir_place)) = self.infcx.tcx.closure_kind_origin(did) {\n-                    diag.span_note(\n-                        *span,\n-                        &format!(\n-                            \"closure cannot be moved more than once as it is not `Copy` due to \\\n-                             moving the variable `{}` out of its environment\",\n-                            ty::place_to_string_for_capture(self.infcx.tcx, hir_place)\n-                        ),\n+                    diag.eager_subdiagnostic(\n+                        &self.infcx.tcx.sess.parse_sess.span_diagnostic,\n+                        OnClosureNote::MovedTwice {\n+                            place_name: &ty::place_to_string_for_capture(self.infcx.tcx, hir_place),\n+                            span: *span,\n+                        },\n                     );\n                     return true;\n                 }\n@@ -380,25 +385,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    /// Add a note that a type does not implement `Copy`\n-    pub(super) fn note_type_does_not_implement_copy(\n-        &self,\n-        err: &mut Diagnostic,\n-        place_desc: &str,\n-        ty: Ty<'tcx>,\n-        span: Option<Span>,\n-        move_prefix: &str,\n-    ) {\n-        let message = format!(\n-            \"{move_prefix}move occurs because {place_desc} has type `{ty}`, which does not implement the `Copy` trait\",\n-        );\n-        if let Some(span) = span {\n-            err.span_label(span, message);\n-        } else {\n-            err.note(&message);\n-        }\n-    }\n-\n     pub(super) fn borrowed_content_source(\n         &self,\n         deref_base: PlaceRef<'tcx>,\n@@ -582,9 +568,13 @@ impl UseSpans<'_> {\n     }\n \n     /// Add a span label to the arguments of the closure, if it exists.\n-    pub(super) fn args_span_label(self, err: &mut Diagnostic, message: impl Into<String>) {\n+    pub(super) fn args_subdiag(\n+        self,\n+        err: &mut Diagnostic,\n+        f: impl FnOnce(Span) -> CaptureArgLabel,\n+    ) {\n         if let UseSpans::ClosureUse { args_span, .. } = self {\n-            err.span_label(args_span, message);\n+            err.subdiagnostic(f(args_span));\n         }\n     }\n \n@@ -595,8 +585,8 @@ impl UseSpans<'_> {\n         err: &mut Diagnostic,\n         action: crate::InitializationRequiringAction,\n     ) {\n-        use crate::session_diagnostics::CaptureVarPathUseCause::*;\n         use crate::InitializationRequiringAction::*;\n+        use CaptureVarPathUseCause::*;\n         if let UseSpans::ClosureUse { generator_kind, path_span, .. } = self {\n             match generator_kind {\n                 Some(_) => {\n@@ -619,52 +609,36 @@ impl UseSpans<'_> {\n         }\n     }\n \n-    /// Add a span label to the use of the captured variable, if it exists.\n-    pub(super) fn var_span_label(\n-        self,\n-        err: &mut Diagnostic,\n-        message: impl Into<String>,\n-        kind_desc: impl Into<String>,\n-    ) {\n-        if let UseSpans::ClosureUse { capture_kind_span, path_span, .. } = self {\n-            if capture_kind_span == path_span {\n-                err.span_label(capture_kind_span, message);\n-            } else {\n-                let capture_kind_label =\n-                    format!(\"capture is {} because of use here\", kind_desc.into());\n-                let path_label = message;\n-                err.span_label(capture_kind_span, capture_kind_label);\n-                err.span_label(path_span, path_label);\n-            }\n-        }\n-    }\n-\n     /// Add a subdiagnostic to the use of the captured variable, if it exists.\n     pub(super) fn var_subdiag(\n         self,\n+        handler: Option<&rustc_errors::Handler>,\n         err: &mut Diagnostic,\n         kind: Option<rustc_middle::mir::BorrowKind>,\n-        f: impl Fn(Option<GeneratorKind>, Span) -> crate::session_diagnostics::CaptureVarCause,\n+        f: impl FnOnce(Option<GeneratorKind>, Span) -> CaptureVarCause,\n     ) {\n-        use crate::session_diagnostics::CaptureVarKind::*;\n         if let UseSpans::ClosureUse { generator_kind, capture_kind_span, path_span, .. } = self {\n             if capture_kind_span != path_span {\n                 err.subdiagnostic(match kind {\n                     Some(kd) => match kd {\n                         rustc_middle::mir::BorrowKind::Shared\n                         | rustc_middle::mir::BorrowKind::Shallow\n                         | rustc_middle::mir::BorrowKind::Unique => {\n-                            Immute { kind_span: capture_kind_span }\n+                            CaptureVarKind::Immut { kind_span: capture_kind_span }\n                         }\n \n                         rustc_middle::mir::BorrowKind::Mut { .. } => {\n-                            Mut { kind_span: capture_kind_span }\n+                            CaptureVarKind::Mut { kind_span: capture_kind_span }\n                         }\n                     },\n-                    None => Move { kind_span: capture_kind_span },\n+                    None => CaptureVarKind::Move { kind_span: capture_kind_span },\n                 });\n             };\n-            err.subdiagnostic(f(generator_kind, path_span));\n+            let diag = f(generator_kind, path_span);\n+            match handler {\n+                Some(hd) => err.eager_subdiagnostic(hd, diag),\n+                None => err.subdiagnostic(diag),\n+            };\n         }\n     }\n \n@@ -684,20 +658,6 @@ impl UseSpans<'_> {\n         }\n     }\n \n-    /// Describe the span associated with a use of a place.\n-    pub(super) fn describe(&self) -> &str {\n-        match *self {\n-            UseSpans::ClosureUse { generator_kind, .. } => {\n-                if generator_kind.is_some() {\n-                    \" in generator\"\n-                } else {\n-                    \" in closure\"\n-                }\n-            }\n-            _ => \"\",\n-        }\n-    }\n-\n     pub(super) fn or_else<F>(self, if_other: F) -> Self\n     where\n         F: FnOnce() -> Self,\n@@ -788,6 +748,15 @@ impl<'tcx> BorrowedContentSource<'tcx> {\n     }\n }\n \n+///helper struct for explain_captures()\n+struct CapturedMessageOpt {\n+    is_partial_move: bool,\n+    is_loop_message: bool,\n+    is_move_msg: bool,\n+    is_loop_move: bool,\n+    maybe_reinitialized_locations_is_empty: bool,\n+}\n+\n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// Finds the spans associated to a move or copy of move_place at location.\n     pub(super) fn move_spans(\n@@ -874,7 +843,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }) = &self.body[location.block].terminator\n         {\n             let Some((method_did, method_substs)) =\n-                rustc_const_eval::util::find_self_call(\n+            rustc_middle::util::find_self_call(\n                     self.infcx.tcx,\n                     &self.body,\n                     target_temp,\n@@ -1027,12 +996,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         move_span: Span,\n         move_spans: UseSpans<'tcx>,\n         moved_place: Place<'tcx>,\n-        partially_str: &str,\n-        loop_message: &str,\n-        move_msg: &str,\n-        is_loop_move: bool,\n-        maybe_reinitialized_locations_is_empty: bool,\n+        msg_opt: CapturedMessageOpt,\n     ) {\n+        let CapturedMessageOpt {\n+            is_partial_move: is_partial,\n+            is_loop_message,\n+            is_move_msg,\n+            is_loop_move,\n+            maybe_reinitialized_locations_is_empty,\n+        } = msg_opt;\n         if let UseSpans::FnSelfUse { var_span, fn_call_span, fn_span, kind } = move_spans {\n             let place_name = self\n                 .describe_place(moved_place.as_ref())\n@@ -1042,30 +1014,26 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 CallKind::FnCall { fn_trait_id, .. }\n                     if Some(fn_trait_id) == self.infcx.tcx.lang_items().fn_once_trait() =>\n                 {\n-                    err.span_label(\n+                    err.subdiagnostic(CaptureReasonLabel::Call {\n                         fn_call_span,\n-                        &format!(\n-                            \"{place_name} {partially_str}moved due to this call{loop_message}\",\n-                        ),\n-                    );\n-                    err.span_note(\n-                        var_span,\n-                        \"this value implements `FnOnce`, which causes it to be moved when called\",\n-                    );\n+                        place_name: &place_name,\n+                        is_partial,\n+                        is_loop_message,\n+                    });\n+                    err.subdiagnostic(CaptureReasonNote::FnOnceMoveInCall { var_span });\n                 }\n                 CallKind::Operator { self_arg, .. } => {\n                     let self_arg = self_arg.unwrap();\n-                    err.span_label(\n+                    err.subdiagnostic(CaptureReasonLabel::OperatorUse {\n                         fn_call_span,\n-                        &format!(\n-                            \"{place_name} {partially_str}moved due to usage in operator{loop_message}\",\n-                        ),\n-                    );\n+                        place_name: &place_name,\n+                        is_partial,\n+                        is_loop_message,\n+                    });\n                     if self.fn_self_span_reported.insert(fn_span) {\n-                        err.span_note(\n-                            self_arg.span,\n-                            \"calling this operator moves the left-hand side\",\n-                        );\n+                        err.subdiagnostic(CaptureReasonNote::LhsMoveByOperator {\n+                            span: self_arg.span,\n+                        });\n                     }\n                 }\n                 CallKind::Normal { self_arg, desugaring, method_did, method_substs } => {\n@@ -1074,35 +1042,27 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if let Some((CallDesugaringKind::ForLoopIntoIter, _)) = desugaring {\n                         let ty = moved_place.ty(self.body, tcx).ty;\n                         let suggest = match tcx.get_diagnostic_item(sym::IntoIterator) {\n-                            Some(def_id) => {\n-                                let infcx = self.infcx.tcx.infer_ctxt().build();\n-                                type_known_to_meet_bound_modulo_regions(\n-                                    &infcx,\n-                                    self.param_env,\n-                                    tcx.mk_imm_ref(tcx.lifetimes.re_erased, tcx.erase_regions(ty)),\n-                                    def_id,\n-                                )\n-                            }\n+                            Some(def_id) => type_known_to_meet_bound_modulo_regions(\n+                                &self.infcx,\n+                                self.param_env,\n+                                tcx.mk_imm_ref(tcx.lifetimes.re_erased, ty),\n+                                def_id,\n+                            ),\n                             _ => false,\n                         };\n                         if suggest {\n-                            err.span_suggestion_verbose(\n-                                move_span.shrink_to_lo(),\n-                                &format!(\n-                                    \"consider iterating over a slice of the `{ty}`'s content to \\\n-                                     avoid moving into the `for` loop\",\n-                                ),\n-                                \"&\",\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                            err.subdiagnostic(CaptureReasonSuggest::IterateSlice {\n+                                ty,\n+                                span: move_span.shrink_to_lo(),\n+                            });\n                         }\n \n-                        err.span_label(\n+                        err.subdiagnostic(CaptureReasonLabel::ImplicitCall {\n                             fn_call_span,\n-                            &format!(\n-                                \"{place_name} {partially_str}moved due to this implicit call to `.into_iter()`{loop_message}\",\n-                            ),\n-                        );\n+                            place_name: &place_name,\n+                            is_partial,\n+                            is_loop_message,\n+                        });\n                         // If the moved place was a `&mut` ref, then we can\n                         // suggest to reborrow it where it was moved, so it\n                         // will still be valid by the time we get to the usage.\n@@ -1125,34 +1085,30 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             }\n                         }\n                     } else {\n-                        err.span_label(\n+                        err.subdiagnostic(CaptureReasonLabel::MethodCall {\n                             fn_call_span,\n-                            &format!(\n-                                \"{place_name} {partially_str}moved due to this method call{loop_message}\",\n-                            ),\n-                        );\n-\n-                        let infcx = tcx.infer_ctxt().build();\n+                            place_name: &place_name,\n+                            is_partial,\n+                            is_loop_message,\n+                        });\n                         // Erase and shadow everything that could be passed to the new infcx.\n-                        let ty = tcx.erase_regions(moved_place.ty(self.body, tcx).ty);\n-                        let method_substs = tcx.erase_regions(method_substs);\n+                        let ty = moved_place.ty(self.body, tcx).ty;\n \n                         if let ty::Adt(def, substs) = ty.kind()\n                             && Some(def.did()) == tcx.lang_items().pin_type()\n                             && let ty::Ref(_, _, hir::Mutability::Mut) = substs.type_at(0).kind()\n-                            && let self_ty = infcx.instantiate_binder_with_fresh_vars(\n+                            && let self_ty = self.infcx.instantiate_binder_with_fresh_vars(\n                                 fn_call_span,\n                                 LateBoundRegionConversionTime::FnCall,\n                                 tcx.fn_sig(method_did).subst(tcx, method_substs).input(0),\n                             )\n-                            && infcx.can_eq(self.param_env, ty, self_ty)\n+                            && self.infcx.can_eq(self.param_env, ty, self_ty)\n                         {\n-                            err.span_suggestion_verbose(\n-                                fn_call_span.shrink_to_lo(),\n-                                \"consider reborrowing the `Pin` instead of moving it\",\n-                                \"as_mut().\".to_string(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                            err.eager_subdiagnostic(\n+                                &self.infcx.tcx.sess.parse_sess.span_diagnostic,\n+                                CaptureReasonSuggest::FreshReborrow {\n+                                    span: fn_call_span.shrink_to_lo(),\n+                                });\n                         }\n                         if let Some(clone_trait) = tcx.lang_items().clone_trait()\n                             && let trait_ref = tcx.mk_trait_ref(clone_trait, [ty])\n@@ -1162,7 +1118,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 self.param_env,\n                                 ty::Binder::dummy(trait_ref),\n                             )\n-                            && infcx.predicate_must_hold_modulo_regions(&o)\n+                            && self.infcx.predicate_must_hold_modulo_regions(&o)\n                         {\n                             err.span_suggestion_verbose(\n                                 fn_call_span.shrink_to_lo(),\n@@ -1177,10 +1133,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     // error messages.\n                     if span != DUMMY_SP && self.fn_self_span_reported.insert(self_arg.span) {\n                         let func = tcx.def_path_str(method_did);\n-                        err.span_note(\n-                            self_arg.span,\n-                            &format!(\"`{func}` takes ownership of the receiver `self`, which moves {place_name}\")\n-                        );\n+                        err.subdiagnostic(CaptureReasonNote::FuncTakeSelf {\n+                            func,\n+                            place_name,\n+                            span: self_arg.span,\n+                        });\n                     }\n                     let parent_did = tcx.parent(method_did);\n                     let parent_self_ty =\n@@ -1194,30 +1151,28 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n                     });\n                     if is_option_or_result && maybe_reinitialized_locations_is_empty {\n-                        err.span_label(\n-                            var_span,\n-                            \"help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents\",\n-                        );\n+                        err.subdiagnostic(CaptureReasonLabel::BorrowContent { var_span });\n                     }\n                 }\n                 // Other desugarings takes &self, which cannot cause a move\n                 _ => {}\n             }\n         } else {\n-            if move_span != span || !loop_message.is_empty() {\n-                err.span_label(\n+            if move_span != span || is_loop_message {\n+                err.subdiagnostic(CaptureReasonLabel::MovedHere {\n                     move_span,\n-                    format!(\"value {partially_str}moved{move_msg} here{loop_message}\"),\n-                );\n+                    is_partial,\n+                    is_move_msg,\n+                    is_loop_message,\n+                });\n             }\n             // If the move error occurs due to a loop, don't show\n             // another message for the same span\n-            if loop_message.is_empty() {\n-                move_spans.var_span_label(\n-                    err,\n-                    format!(\"variable {partially_str}moved due to use{}\", move_spans.describe()),\n-                    \"moved\",\n-                );\n+            if !is_loop_message {\n+                move_spans.var_subdiag(None, err, None, |kind, var_span| match kind {\n+                    Some(_) => CaptureVarCause::PartialMoveUseInGenerator { var_span, is_partial },\n+                    None => CaptureVarCause::PartialMoveUseInClosure { var_span, is_partial },\n+                })\n             }\n         }\n     }"}, {"sha": "67af96a71e30d715a83115a26155241d4cf5d0ab", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -6,6 +6,7 @@ use rustc_mir_dataflow::move_paths::{\n };\n use rustc_span::{BytePos, Span};\n \n+use crate::diagnostics::CapturedMessageOpt;\n use crate::diagnostics::{DescribePlaceOpt, UseSpans};\n use crate::prefixes::PrefixSet;\n use crate::MirBorrowckCtxt;\n@@ -397,10 +398,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n         };\n+        let msg_opt = CapturedMessageOpt {\n+            is_partial_move: false,\n+            is_loop_message: false,\n+            is_move_msg: false,\n+            is_loop_move: false,\n+            maybe_reinitialized_locations_is_empty: true,\n+        };\n         if let Some(use_spans) = use_spans {\n-            self.explain_captures(\n-                &mut err, span, span, use_spans, move_place, \"\", \"\", \"\", false, true,\n-            );\n+            self.explain_captures(&mut err, span, span, use_spans, move_place, msg_opt);\n         }\n         err\n     }\n@@ -416,13 +422,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         None => \"value\".to_string(),\n                     };\n \n-                    self.note_type_does_not_implement_copy(\n-                        err,\n-                        &place_desc,\n-                        place_ty,\n-                        Some(span),\n-                        \"\",\n-                    );\n+                    err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Label {\n+                        is_partial_move: false,\n+                        ty: place_ty,\n+                        place: &place_desc,\n+                        span,\n+                    });\n                 } else {\n                     binds_to.sort();\n                     binds_to.dedup();\n@@ -444,9 +449,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Some(desc) => format!(\"`{desc}`\"),\n                     None => \"value\".to_string(),\n                 };\n-                self.note_type_does_not_implement_copy(err, &place_desc, place_ty, Some(span), \"\");\n+                err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Label {\n+                    is_partial_move: false,\n+                    ty: place_ty,\n+                    place: &place_desc,\n+                    span,\n+                });\n \n-                use_spans.args_span_label(err, format!(\"{place_desc} is moved here\"));\n+                use_spans.args_subdiag(err, |args_span| {\n+                    crate::session_diagnostics::CaptureArgLabel::MoveOutPlace {\n+                        place: place_desc,\n+                        args_span,\n+                    }\n+                });\n             }\n         }\n     }\n@@ -534,13 +549,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n \n             if binds_to.len() == 1 {\n-                self.note_type_does_not_implement_copy(\n-                    err,\n-                    &format!(\"`{}`\", self.local_names[*local].unwrap()),\n-                    bind_to.ty,\n-                    Some(binding_span),\n-                    \"\",\n-                );\n+                let place_desc = &format!(\"`{}`\", self.local_names[*local].unwrap());\n+                err.subdiagnostic(crate::session_diagnostics::TypeNoCopy::Label {\n+                    is_partial_move: false,\n+                    ty: bind_to.ty,\n+                    place: &place_desc,\n+                    span: binding_span,\n+                });\n             }\n         }\n "}, {"sha": "e3d81194ac817de2595eb5d37fea21498e122a14", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -15,8 +15,8 @@ use rustc_span::{sym, BytePos, Span};\n use rustc_target::abi::FieldIdx;\n \n use crate::diagnostics::BorrowedContentSource;\n+use crate::util::FindAssignments;\n use crate::MirBorrowckCtxt;\n-use rustc_const_eval::util::collect_writes::FindAssignments;\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub(crate) enum AccessKind {\n@@ -231,14 +231,18 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n                 if suggest {\n-                    borrow_spans.var_span_label(\n-                        &mut err,\n-                        format!(\n-                            \"mutable borrow occurs due to use of {} in closure\",\n-                            self.describe_any_place(access_place.as_ref()),\n-                        ),\n-                        \"mutable\",\n-                    );\n+                    borrow_spans.var_subdiag(\n+                    None,\n+                    &mut err,\n+                    Some(mir::BorrowKind::Mut { allow_two_phase_borrow: false }),\n+                    |_kind, var_span| {\n+                        let place = self.describe_any_place(access_place.as_ref());\n+                        crate::session_diagnostics::CaptureVarCause::MutableBorrowUsePlaceClosure {\n+                            place,\n+                            var_span,\n+                        }\n+                    },\n+                );\n                 }\n                 borrow_span\n             }\n@@ -1143,7 +1147,7 @@ pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<\n             // suggest removing the `&mut`.\n             //\n             // Deliberately fall into this case for all implicit self types,\n-            // so that we don't fall in to the next case with them.\n+            // so that we don't fall into the next case with them.\n             kind == hir::ImplicitSelfKind::MutRef\n         }\n         _ if Some(kw::SelfLower) == local_name => {\n@@ -1231,7 +1235,7 @@ fn suggest_ampmut<'tcx>(\n         }\n     }\n \n-    let (suggestability, highlight_span) = match opt_ty_info {\n+    let (suggestibility, highlight_span) = match opt_ty_info {\n         // if this is a variable binding with an explicit type,\n         // try to highlight that for the suggestion.\n         Some(ty_span) => (true, ty_span),\n@@ -1252,7 +1256,7 @@ fn suggest_ampmut<'tcx>(\n     let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n     assert_eq!(ty_mut.mutbl, hir::Mutability::Not);\n     (\n-        suggestability,\n+        suggestibility,\n         highlight_span,\n         if local_decl.ty.is_ref() {\n             format!(\"&mut {}\", ty_mut.ty)"}, {"sha": "98418e2372f0e612b6675a7cf199396355b10ce0", "filename": "compiler/rustc_borrowck/src/diagnostics/var_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -3,7 +3,7 @@\n \n use crate::region_infer::RegionInferenceContext;\n use crate::Upvar;\n-use rustc_index::vec::{Idx, IndexSlice};\n+use rustc_index::IndexSlice;\n use rustc_middle::mir::{Body, Local};\n use rustc_middle::ty::{RegionVid, TyCtxt};\n use rustc_span::source_map::Span;\n@@ -117,7 +117,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_index: usize,\n     ) -> (Option<Symbol>, Span) {\n         let implicit_inputs = self.universal_regions().defining_ty.implicit_inputs();\n-        let argument_local = Local::new(implicit_inputs + argument_index + 1);\n+        let argument_local = Local::from_usize(implicit_inputs + argument_index + 1);\n         debug!(\"get_argument_name_and_span_for_region: argument_local={argument_local:?}\");\n \n         let argument_name = local_names[argument_local];"}, {"sha": "87fad9a355d3d69dc0d69ca770fcfdbdc3fa899d", "filename": "compiler/rustc_borrowck/src/facts.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -4,7 +4,6 @@ use crate::location::{LocationIndex, LocationTable};\n use crate::BorrowIndex;\n use polonius_engine::AllFacts as PoloniusFacts;\n use polonius_engine::Atom;\n-use rustc_index::vec::Idx;\n use rustc_middle::mir::Local;\n use rustc_middle::ty::{RegionVid, TyCtxt};\n use rustc_mir_dataflow::move_paths::MovePathIndex;\n@@ -93,13 +92,13 @@ impl AllFactsExt for AllFacts {\n \n impl Atom for BorrowIndex {\n     fn index(self) -> usize {\n-        Idx::index(self)\n+        self.as_usize()\n     }\n }\n \n impl Atom for LocationIndex {\n     fn index(self) -> usize {\n-        Idx::index(self)\n+        self.as_usize()\n     }\n }\n "}, {"sha": "06986f848bfeb75331abea476e244364dd2deb32", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -79,7 +79,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n             // Only relevant for mir typeck\n             StatementKind::AscribeUserType(..)\n-            // Only relevant for unsafeck\n+            // Only relevant for liveness and unsafeck\n             | StatementKind::PlaceMention(..)\n             // Doesn't have any language semantics\n             | StatementKind::Coverage(..)"}, {"sha": "6900729d671a07e04041a77b5133f7dab38e21b4", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -20,14 +20,14 @@ extern crate tracing;\n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_fluent_macro::fluent_messages;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::ChunkedBitSet;\n-use rustc_index::vec::{IndexSlice, IndexVec};\n+use rustc_index::{IndexSlice, IndexVec};\n use rustc_infer::infer::{\n     DefiningAnchor, InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin, TyCtxtInferExt,\n };\n-use rustc_macros::fluent_messages;\n use rustc_middle::mir::{\n     traversal, Body, ClearCrossCrate, Local, Location, Mutability, NonDivergingIntrinsic, Operand,\n     Place, PlaceElem, PlaceRef, VarDebugInfoContents,\n@@ -88,6 +88,7 @@ mod session_diagnostics;\n mod type_check;\n mod universal_regions;\n mod used_muts;\n+mod util;\n \n /// A public API provided for the Rust compiler consumers.\n pub mod consumers;\n@@ -118,24 +119,12 @@ impl<'tcx> TyCtxtConsts<'tcx> {\n }\n \n pub fn provide(providers: &mut Providers) {\n-    *providers = Providers {\n-        mir_borrowck: |tcx, did| {\n-            if let Some(def) = ty::WithOptConstParam::try_lookup(did, tcx) {\n-                tcx.mir_borrowck_const_arg(def)\n-            } else {\n-                mir_borrowck(tcx, ty::WithOptConstParam::unknown(did))\n-            }\n-        },\n-        mir_borrowck_const_arg: |tcx, (did, param_did)| {\n-            mir_borrowck(tcx, ty::WithOptConstParam { did, const_param_did: Some(param_did) })\n-        },\n-        ..*providers\n-    };\n+    *providers = Providers { mir_borrowck, ..*providers };\n }\n \n-fn mir_borrowck(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &BorrowCheckResult<'_> {\n+fn mir_borrowck(tcx: TyCtxt<'_>, def: LocalDefId) -> &BorrowCheckResult<'_> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n-    debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n+    debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def));\n \n     if input_body.borrow().should_skip() {\n         debug!(\"Skipping borrowck because of injected body\");\n@@ -149,7 +138,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &Bor\n         return tcx.arena.alloc(result);\n     }\n \n-    let hir_owner = tcx.hir().local_def_id_to_hir_id(def.did).owner;\n+    let hir_owner = tcx.hir().local_def_id_to_hir_id(def).owner;\n \n     let infcx =\n         tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id)).build();\n@@ -166,19 +155,19 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &Bor\n /// If `return_body_with_facts` is true, then return the body with non-erased\n /// region ids on which the borrow checking was performed together with Polonius\n /// facts.\n-#[instrument(skip(infcx, input_body, input_promoted), fields(id=?input_body.source.with_opt_param().as_local().unwrap()), level = \"debug\")]\n+#[instrument(skip(infcx, input_body, input_promoted), fields(id=?input_body.source.def_id()), level = \"debug\")]\n fn do_mir_borrowck<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     input_body: &Body<'tcx>,\n     input_promoted: &IndexSlice<Promoted, Body<'tcx>>,\n     return_body_with_facts: bool,\n ) -> (BorrowCheckResult<'tcx>, Option<Box<BodyWithBorrowckFacts<'tcx>>>) {\n-    let def = input_body.source.with_opt_param().as_local().unwrap();\n+    let def = input_body.source.def_id().expect_local();\n     debug!(?def);\n \n     let tcx = infcx.tcx;\n     let infcx = BorrowckInferCtxt::new(infcx);\n-    let param_env = tcx.param_env(def.did);\n+    let param_env = tcx.param_env(def);\n \n     let mut local_names = IndexVec::from_elem(None, &input_body.local_decls);\n     for var_debug_info in &input_body.var_debug_info {\n@@ -206,7 +195,7 @@ fn do_mir_borrowck<'tcx>(\n         errors.set_tainted_by_errors(e);\n     }\n     let upvars: Vec<_> = tcx\n-        .closure_captures(def.did)\n+        .closure_captures(def)\n         .iter()\n         .map(|&captured_place| {\n             let capture = captured_place.info.capture_kind;\n@@ -248,7 +237,7 @@ fn do_mir_borrowck<'tcx>(\n         .iterate_to_fixpoint()\n         .into_results_cursor(&body);\n \n-    let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(def.did).is_fn_or_closure();\n+    let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(def).is_fn_or_closure();\n     let borrow_set =\n         Rc::new(BorrowSet::build(tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n@@ -528,7 +517,7 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n     where\n         F: Fn() -> RegionCtxt,\n     {\n-        let next_region = self.infcx.next_nll_region_var(origin.clone());\n+        let next_region = self.infcx.next_nll_region_var(origin);\n         let vid = next_region.as_var();\n \n         if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n@@ -676,7 +665,7 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n             }\n             // Only relevant for mir typeck\n             StatementKind::AscribeUserType(..)\n-            // Only relevant for unsafeck\n+            // Only relevant for liveness and unsafeck\n             | StatementKind::PlaceMention(..)\n             // Doesn't have any language semantics\n             | StatementKind::Coverage(..)\n@@ -946,6 +935,7 @@ enum InitializationRequiringAction {\n     PartialAssignment,\n }\n \n+#[derive(Debug)]\n struct RootPlace<'tcx> {\n     place_local: Local,\n     place_projection: &'tcx [PlaceElem<'tcx>],\n@@ -1859,11 +1849,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // is allowed, remove this match arm.\n                         ty::Adt(..) | ty::Tuple(..) => {\n                             check_parent_of_field(self, location, place_base, span, flow_state);\n-\n-                            // rust-lang/rust#21232, #54499, #54986: during period where we reject\n-                            // partial initialization, do not complain about unnecessary `mut` on\n-                            // an attempt to do a partial initialization.\n-                            self.used_mut.insert(place.local);\n                         }\n \n                         _ => {}\n@@ -1951,6 +1936,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     (prefix, base, span),\n                     mpi,\n                 );\n+\n+                // rust-lang/rust#21232, #54499, #54986: during period where we reject\n+                // partial initialization, do not complain about unnecessary `mut` on\n+                // an attempt to do a partial initialization.\n+                this.used_mut.insert(base.local);\n             }\n         }\n     }"}, {"sha": "0e669abfd14aa5b9da32ff8fbe5ac01ce631a894", "filename": "compiler/rustc_borrowck/src/location.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,6 +1,6 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::IndexVec;\n use rustc_middle::mir::{BasicBlock, Body, Location};\n \n /// Maps between a MIR Location, which identifies a particular\n@@ -50,19 +50,19 @@ impl LocationTable {\n     }\n \n     pub fn all_points(&self) -> impl Iterator<Item = LocationIndex> {\n-        (0..self.num_points).map(LocationIndex::new)\n+        (0..self.num_points).map(LocationIndex::from_usize)\n     }\n \n     pub fn start_index(&self, location: Location) -> LocationIndex {\n         let Location { block, statement_index } = location;\n         let start_index = self.statements_before_block[block];\n-        LocationIndex::new(start_index + statement_index * 2)\n+        LocationIndex::from_usize(start_index + statement_index * 2)\n     }\n \n     pub fn mid_index(&self, location: Location) -> LocationIndex {\n         let Location { block, statement_index } = location;\n         let start_index = self.statements_before_block[block];\n-        LocationIndex::new(start_index + statement_index * 2 + 1)\n+        LocationIndex::from_usize(start_index + statement_index * 2 + 1)\n     }\n \n     pub fn to_location(&self, index: LocationIndex) -> RichLocation {"}, {"sha": "842e90080582f5b7f40bf4059e0c5634a12c2a7e", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -2,7 +2,7 @@\n #![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxIndexMap;\n-use rustc_index::vec::{IndexSlice, IndexVec};\n+use rustc_index::{IndexSlice, IndexVec};\n use rustc_middle::infer::MemberConstraint;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n@@ -221,7 +221,7 @@ fn append_list(\n ) {\n     let mut p = target_list;\n     loop {\n-        let mut r = &mut constraints[p];\n+        let r = &mut constraints[p];\n         match r.next_constraint {\n             Some(q) => p = q,\n             None => {"}, {"sha": "5f1bcb27ea7939cd25a634fee8a1a66bd2a2892d", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -4,11 +4,11 @@\n \n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_index::vec::IndexSlice;\n+use rustc_index::IndexSlice;\n use rustc_middle::mir::{create_dump_file, dump_enabled, dump_mir, PassWhere};\n use rustc_middle::mir::{\n-    BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n-    Promoted,\n+    Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location, Promoted,\n+    START_BLOCK,\n };\n use rustc_middle::ty::{self, OpaqueHiddenType, TyCtxt};\n use rustc_span::symbol::sym;\n@@ -61,7 +61,7 @@ pub(crate) fn replace_regions_in_mir<'tcx>(\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexSlice<Promoted, Body<'tcx>>,\n ) -> UniversalRegions<'tcx> {\n-    let def = body.source.with_opt_param().as_local().unwrap();\n+    let def = body.source.def_id().expect_local();\n \n     debug!(?def);\n \n@@ -94,8 +94,8 @@ fn populate_polonius_move_facts(\n         }\n     }\n \n-    let fn_entry_start = location_table\n-        .start_index(Location { block: BasicBlock::from_u32(0u32), statement_index: 0 });\n+    let fn_entry_start =\n+        location_table.start_index(Location { block: START_BLOCK, statement_index: 0 });\n \n     // initialized_at\n     for init in move_data.inits.iter() {\n@@ -235,7 +235,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n     // Create the region inference context, taking ownership of the\n     // region inference data that was contained in `infcx`, and the\n     // base constraints generated by the type-check.\n-    let var_origins = infcx.take_region_var_origins();\n+    let var_origins = infcx.get_region_var_origins();\n     let MirTypeckRegionConstraints {\n         placeholder_indices,\n         placeholder_index_to_region: _,"}, {"sha": "65573c71f14a0ea584cca4c15154badc99b07e76", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::CRATE_DEF_ID;\n-use rustc_index::vec::{IndexSlice, IndexVec};\n+use rustc_index::{IndexSlice, IndexVec};\n use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};"}, {"sha": "193e20601152b36eb61c18b2e810f9a8c2f3c2f2", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -4,8 +4,8 @@ use rustc_data_structures::fx::FxIndexSet;\n use rustc_index::bit_set::SparseBitMatrix;\n use rustc_index::interval::IntervalSet;\n use rustc_index::interval::SparseIntervalMatrix;\n-use rustc_index::vec::Idx;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::Idx;\n+use rustc_index::IndexVec;\n use rustc_middle::mir::{BasicBlock, Body, Location};\n use rustc_middle::ty::{self, RegionVid};\n use std::fmt::Debug;"}, {"sha": "22de7549e9409cf8300fe25b46d2998d9293e903", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,7 +1,7 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n use crate::BorrowckInferCtxt;\n-use rustc_index::vec::IndexSlice;\n+use rustc_index::IndexSlice;\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::mir::visit::{MutVisitor, TyContext};\n use rustc_middle::mir::Constant;"}, {"sha": "bb95101845f3e0eead5e28c24224b18ba3b4e3d6", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 206, "deletions": 1, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -184,7 +184,7 @@ pub(crate) enum CaptureVarPathUseCause {\n #[derive(Subdiagnostic)]\n pub(crate) enum CaptureVarKind {\n     #[label(borrowck_capture_immute)]\n-    Immute {\n+    Immut {\n         #[primary_span]\n         kind_span: Span,\n     },\n@@ -204,16 +204,80 @@ pub(crate) enum CaptureVarKind {\n pub(crate) enum CaptureVarCause {\n     #[label(borrowck_var_borrow_by_use_place_in_generator)]\n     BorrowUsePlaceGenerator {\n+        is_single_var: bool,\n         place: String,\n         #[primary_span]\n         var_span: Span,\n     },\n     #[label(borrowck_var_borrow_by_use_place_in_closure)]\n     BorrowUsePlaceClosure {\n+        is_single_var: bool,\n         place: String,\n         #[primary_span]\n         var_span: Span,\n     },\n+    #[label(borrowck_var_borrow_by_use_in_generator)]\n+    BorrowUseInGenerator {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_borrow_by_use_in_closure)]\n+    BorrowUseInClosure {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_move_by_use_in_generator)]\n+    MoveUseInGenerator {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_move_by_use_in_closure)]\n+    MoveUseInClosure {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_first_borrow_by_use_place_in_generator)]\n+    FirstBorrowUsePlaceGenerator {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_first_borrow_by_use_place_in_closure)]\n+    FirstBorrowUsePlaceClosure {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_second_borrow_by_use_place_in_generator)]\n+    SecondBorrowUsePlaceGenerator {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_second_borrow_by_use_place_in_closure)]\n+    SecondBorrowUsePlaceClosure {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_var_mutable_borrow_by_use_place_in_closure)]\n+    MutableBorrowUsePlaceClosure {\n+        place: String,\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[label(borrowck_partial_var_move_by_use_in_generator)]\n+    PartialMoveUseInGenerator {\n+        #[primary_span]\n+        var_span: Span,\n+        is_partial: bool,\n+    },\n+    #[label(borrowck_partial_var_move_by_use_in_closure)]\n+    PartialMoveUseInClosure {\n+        #[primary_span]\n+        var_span: Span,\n+        is_partial: bool,\n+    },\n }\n \n #[derive(Diagnostic)]\n@@ -239,3 +303,144 @@ pub(crate) struct NonGenericOpaqueTypeParam<'a, 'tcx> {\n     #[label]\n     pub param_span: Span,\n }\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureReasonLabel<'a> {\n+    #[label(borrowck_moved_due_to_call)]\n+    Call {\n+        #[primary_span]\n+        fn_call_span: Span,\n+        place_name: &'a str,\n+        is_partial: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_moved_due_to_usage_in_operator)]\n+    OperatorUse {\n+        #[primary_span]\n+        fn_call_span: Span,\n+        place_name: &'a str,\n+        is_partial: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_moved_due_to_implicit_into_iter_call)]\n+    ImplicitCall {\n+        #[primary_span]\n+        fn_call_span: Span,\n+        place_name: &'a str,\n+        is_partial: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_moved_due_to_method_call)]\n+    MethodCall {\n+        #[primary_span]\n+        fn_call_span: Span,\n+        place_name: &'a str,\n+        is_partial: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_value_moved_here)]\n+    MovedHere {\n+        #[primary_span]\n+        move_span: Span,\n+        is_partial: bool,\n+        is_move_msg: bool,\n+        is_loop_message: bool,\n+    },\n+    #[label(borrowck_consider_borrow_type_contents)]\n+    BorrowContent {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureReasonNote {\n+    #[note(borrowck_moved_a_fn_once_in_call)]\n+    FnOnceMoveInCall {\n+        #[primary_span]\n+        var_span: Span,\n+    },\n+    #[note(borrowck_calling_operator_moves_lhs)]\n+    LhsMoveByOperator {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(borrowck_func_take_self_moved_place)]\n+    FuncTakeSelf {\n+        func: String,\n+        place_name: String,\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureReasonSuggest<'tcx> {\n+    #[suggestion(\n+        borrowck_suggest_iterate_over_slice,\n+        applicability = \"maybe-incorrect\",\n+        code = \"&\",\n+        style = \"verbose\"\n+    )]\n+    IterateSlice {\n+        ty: Ty<'tcx>,\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(\n+        borrowck_suggest_create_freash_reborrow,\n+        applicability = \"maybe-incorrect\",\n+        code = \"as_mut().\",\n+        style = \"verbose\"\n+    )]\n+    FreshReborrow {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum CaptureArgLabel {\n+    #[label(borrowck_value_capture_here)]\n+    Capture {\n+        is_within: bool,\n+        #[primary_span]\n+        args_span: Span,\n+    },\n+    #[label(borrowck_move_out_place_here)]\n+    MoveOutPlace {\n+        place: String,\n+        #[primary_span]\n+        args_span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum OnClosureNote<'a> {\n+    #[note(borrowck_closure_invoked_twice)]\n+    InvokedTwice {\n+        place_name: &'a str,\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(borrowck_closure_moved_twice)]\n+    MovedTwice {\n+        place_name: &'a str,\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum TypeNoCopy<'a, 'tcx> {\n+    #[label(borrowck_ty_no_impl_copy)]\n+    Label {\n+        is_partial_move: bool,\n+        ty: Ty<'tcx>,\n+        place: &'a str,\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(borrowck_ty_no_impl_copy)]\n+    Note { is_partial_move: bool, ty: Ty<'tcx>, place: &'a str },\n+}"}, {"sha": "9250b8d3eaf2a31ec3bc9dafbd97aef678c1ccf7", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -7,7 +7,6 @@\n //! `RETURN_PLACE` the MIR arguments) are always fully normalized (and\n //! contain revealed `impl Trait` values).\n \n-use rustc_index::vec::Idx;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty};\n@@ -83,7 +82,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n \n             // In MIR, argument N is stored in local N+1.\n-            let local = Local::new(argument_index + 1);\n+            let local = Local::from_usize(argument_index + 1);\n \n             let mir_input_ty = body.local_decls[local].ty;\n "}, {"sha": "a9ca94567878a598e79bbb481aaa2dafef2494b0", "filename": "compiler/rustc_borrowck/src/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,5 +1,5 @@\n use rustc_data_structures::vec_linked_list as vll;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location};\n "}, {"sha": "d5e50a61b032c5543398920e6d02229db7dd91f9", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -14,7 +14,7 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n-use rustc_index::vec::{IndexSlice, IndexVec};\n+use rustc_index::{IndexSlice, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n@@ -394,7 +394,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     self.cx.ascribe_user_type(\n                         constant.literal.ty(),\n                         UserType::TypeOf(\n-                            uv.def.did,\n+                            uv.def,\n                             UserSubsts { substs: uv.substs, user_self_ty: None },\n                         ),\n                         locations.span(&self.cx.body),\n@@ -1766,7 +1766,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             if let Some(uv) = maybe_uneval {\n                 if uv.promoted.is_none() {\n                     let tcx = self.tcx();\n-                    let def_id = uv.def.def_id_for_type_of();\n+                    let def_id = uv.def;\n                     if tcx.def_kind(def_id) == DefKind::InlineConst {\n                         let def_id = def_id.expect_local();\n                         let predicates =\n@@ -2306,7 +2306,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Rvalue::AddressOf(..)\n             | Rvalue::ThreadLocalRef(..)\n             | Rvalue::Len(..)\n-            | Rvalue::Discriminant(..) => {}\n+            | Rvalue::Discriminant(..)\n+            | Rvalue::NullaryOp(NullOp::OffsetOf(..), _) => {}\n         }\n     }\n "}, {"sha": "3f7f23df8d92d96981fc7a13ea8a2072d8cf7f69", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -19,7 +19,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::BodyOwnerKind;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::IndexVec;\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt};\n@@ -226,7 +226,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// known between those regions.\n     pub fn new(\n         infcx: &BorrowckInferCtxt<'_, 'tcx>,\n-        mir_def: ty::WithOptConstParam<LocalDefId>,\n+        mir_def: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         UniversalRegionsBuilder { infcx, mir_def, param_env }.build()\n@@ -289,7 +289,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// Returns an iterator over all the RegionVids corresponding to\n     /// universally quantified free regions.\n     pub fn universal_regions(&self) -> impl Iterator<Item = RegionVid> {\n-        (FIRST_GLOBAL_INDEX..self.num_universals).map(RegionVid::new)\n+        (FIRST_GLOBAL_INDEX..self.num_universals).map(RegionVid::from_usize)\n     }\n \n     /// Returns `true` if `r` is classified as an local region.\n@@ -388,7 +388,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n \n struct UniversalRegionsBuilder<'cx, 'tcx> {\n     infcx: &'cx BorrowckInferCtxt<'cx, 'tcx>,\n-    mir_def: ty::WithOptConstParam<LocalDefId>,\n+    mir_def: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n@@ -417,12 +417,12 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let mut indices = self.compute_indices(fr_static, defining_ty);\n         debug!(\"build: indices={:?}\", indices);\n \n-        let typeck_root_def_id = self.infcx.tcx.typeck_root_def_id(self.mir_def.did.to_def_id());\n+        let typeck_root_def_id = self.infcx.tcx.typeck_root_def_id(self.mir_def.to_def_id());\n \n         // If this is a 'root' body (not a closure/generator/inline const), then\n         // there are no extern regions, so the local regions start at the same\n         // position as the (empty) sub-list of extern regions\n-        let first_local_index = if self.mir_def.did.to_def_id() == typeck_root_def_id {\n+        let first_local_index = if self.mir_def.to_def_id() == typeck_root_def_id {\n             first_extern_index\n         } else {\n             // If this is a closure, generator, or inline-const, then the late-bound regions from the enclosing\n@@ -433,7 +433,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             // }\n             for_each_late_bound_region_in_recursive_scope(\n                 self.infcx.tcx,\n-                self.infcx.tcx.local_parent(self.mir_def.did),\n+                self.infcx.tcx.local_parent(self.mir_def),\n                 |r| {\n                     debug!(?r);\n                     if !indices.indices.contains_key(&r) {\n@@ -462,13 +462,13 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         let inputs_and_output = self.infcx.replace_bound_regions_with_nll_infer_vars(\n             FR,\n-            self.mir_def.did,\n+            self.mir_def,\n             bound_inputs_and_output,\n             &mut indices,\n         );\n         // Converse of above, if this is a function/closure then the late-bound regions declared on its\n         // signature are local.\n-        for_each_late_bound_region_in_item(self.infcx.tcx, self.mir_def.did, |r| {\n+        for_each_late_bound_region_in_item(self.infcx.tcx, self.mir_def, |r| {\n             debug!(?r);\n             if !indices.indices.contains_key(&r) {\n                 let region_vid = {\n@@ -492,7 +492,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             if self.infcx.tcx.fn_sig(def_id).skip_binder().c_variadic() {\n                 let va_list_did = self.infcx.tcx.require_lang_item(\n                     LangItem::VaList,\n-                    Some(self.infcx.tcx.def_span(self.mir_def.did)),\n+                    Some(self.infcx.tcx.def_span(self.mir_def)),\n                 );\n \n                 let reg_vid = self\n@@ -544,11 +544,11 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n     /// see `DefiningTy` for details.\n     fn defining_ty(&self) -> DefiningTy<'tcx> {\n         let tcx = self.infcx.tcx;\n-        let typeck_root_def_id = tcx.typeck_root_def_id(self.mir_def.did.to_def_id());\n+        let typeck_root_def_id = tcx.typeck_root_def_id(self.mir_def.to_def_id());\n \n-        match tcx.hir().body_owner_kind(self.mir_def.did) {\n+        match tcx.hir().body_owner_kind(self.mir_def) {\n             BodyOwnerKind::Closure | BodyOwnerKind::Fn => {\n-                let defining_ty = tcx.type_of(self.mir_def.def_id_for_type_of()).subst_identity();\n+                let defining_ty = tcx.type_of(self.mir_def).subst_identity();\n \n                 debug!(\"defining_ty (pre-replacement): {:?}\", defining_ty);\n \n@@ -562,20 +562,20 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                     }\n                     ty::FnDef(def_id, substs) => DefiningTy::FnDef(def_id, substs),\n                     _ => span_bug!(\n-                        tcx.def_span(self.mir_def.did),\n+                        tcx.def_span(self.mir_def),\n                         \"expected defining type for `{:?}`: `{:?}`\",\n-                        self.mir_def.did,\n+                        self.mir_def,\n                         defining_ty\n                     ),\n                 }\n             }\n \n             BodyOwnerKind::Const | BodyOwnerKind::Static(..) => {\n                 let identity_substs = InternalSubsts::identity_for_item(tcx, typeck_root_def_id);\n-                if self.mir_def.did.to_def_id() == typeck_root_def_id {\n+                if self.mir_def.to_def_id() == typeck_root_def_id {\n                     let substs =\n                         self.infcx.replace_free_regions_with_nll_infer_vars(FR, identity_substs);\n-                    DefiningTy::Const(self.mir_def.did.to_def_id(), substs)\n+                    DefiningTy::Const(self.mir_def.to_def_id(), substs)\n                 } else {\n                     // FIXME this line creates a dependency between borrowck and typeck.\n                     //\n@@ -587,15 +587,15 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                     // below), so that `type_of(inline_const_def_id).substs(substs)` uses the\n                     // proper type with NLL infer vars.\n                     let ty = tcx\n-                        .typeck(self.mir_def.did)\n-                        .node_type(tcx.local_def_id_to_hir_id(self.mir_def.did));\n+                        .typeck(self.mir_def)\n+                        .node_type(tcx.local_def_id_to_hir_id(self.mir_def));\n                     let substs = InlineConstSubsts::new(\n                         tcx,\n                         InlineConstSubstsParts { parent_substs: identity_substs, ty },\n                     )\n                     .substs;\n                     let substs = self.infcx.replace_free_regions_with_nll_infer_vars(FR, substs);\n-                    DefiningTy::InlineConst(self.mir_def.did.to_def_id(), substs)\n+                    DefiningTy::InlineConst(self.mir_def.to_def_id(), substs)\n                 }\n             }\n         }\n@@ -611,7 +611,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         defining_ty: DefiningTy<'tcx>,\n     ) -> UniversalRegionIndices<'tcx> {\n         let tcx = self.infcx.tcx;\n-        let typeck_root_def_id = tcx.typeck_root_def_id(self.mir_def.did.to_def_id());\n+        let typeck_root_def_id = tcx.typeck_root_def_id(self.mir_def.to_def_id());\n         let identity_substs = InternalSubsts::identity_for_item(tcx, typeck_root_def_id);\n         let fr_substs = match defining_ty {\n             DefiningTy::Closure(_, substs)\n@@ -647,7 +647,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         match defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n-                assert_eq!(self.mir_def.did.to_def_id(), def_id);\n+                assert_eq!(self.mir_def.to_def_id(), def_id);\n                 let closure_sig = substs.as_closure().sig();\n                 let inputs_and_output = closure_sig.inputs_and_output();\n                 let bound_vars = tcx.mk_bound_variable_kinds_from_iter(\n@@ -682,7 +682,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             }\n \n             DefiningTy::Generator(def_id, substs, movability) => {\n-                assert_eq!(self.mir_def.did.to_def_id(), def_id);\n+                assert_eq!(self.mir_def.to_def_id(), def_id);\n                 let resume_ty = substs.as_generator().resume_ty();\n                 let output = substs.as_generator().return_ty();\n                 let generator_ty = tcx.mk_generator(def_id, substs, movability);\n@@ -700,14 +700,14 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             DefiningTy::Const(def_id, _) => {\n                 // For a constant body, there are no inputs, and one\n                 // \"output\" (the type of the constant).\n-                assert_eq!(self.mir_def.did.to_def_id(), def_id);\n-                let ty = tcx.type_of(self.mir_def.def_id_for_type_of()).subst_identity();\n+                assert_eq!(self.mir_def.to_def_id(), def_id);\n+                let ty = tcx.type_of(self.mir_def).subst_identity();\n                 let ty = indices.fold_to_region_vids(tcx, ty);\n                 ty::Binder::dummy(tcx.mk_type_list(&[ty]))\n             }\n \n             DefiningTy::InlineConst(def_id, substs) => {\n-                assert_eq!(self.mir_def.did.to_def_id(), def_id);\n+                assert_eq!(self.mir_def.to_def_id(), def_id);\n                 let ty = substs.as_inline_const().ty();\n                 ty::Binder::dummy(tcx.mk_type_list(&[ty]))\n             }"}, {"sha": "8d92bb359385780cdccebde4885f6c141640dc9b", "filename": "compiler/rustc_borrowck/src/util/collect_writes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Futil%2Fcollect_writes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Futil%2Fcollect_writes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Futil%2Fcollect_writes.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "previous_filename": "compiler/rustc_const_eval/src/util/collect_writes.rs"}, {"sha": "7377d4de7274f93d180207ee6301feb519f6f12e", "filename": "compiler/rustc_borrowck/src/util/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_borrowck%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Futil%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,3 @@\n+mod collect_writes;\n+\n+pub use collect_writes::FindAssignments;"}, {"sha": "5f6441660e3bc5f1e129f741f7455292e8b2bb63", "filename": "compiler/rustc_builtin_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -17,6 +17,7 @@ rustc_feature = { path = \"../rustc_feature\" }\n rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n rustc_macros = { path = \"../rustc_macros\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_parse_format = { path = \"../rustc_parse_format\" }\n rustc_parse = { path = \"../rustc_parse\" }\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "74049406426ed0bf97318d58249df61f4bdd4907", "filename": "compiler/rustc_builtin_macros/messages.ftl", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fmessages.ftl?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -149,3 +149,25 @@ builtin_macros_format_pos_mismatch = {$n} positional {$n ->\n     [one] argument\n     *[more] arguments\n     } in format string, but {$desc}\n+\n+builtin_macros_offset_of_expected_field = expected field\n+\n+builtin_macros_offset_of_expected_two_args = expected 2 arguments\n+\n+builtin_macros_test_case_non_item = `#[test_case]` attribute is only allowed on items\n+\n+builtin_macros_test_bad_fn = {$kind} functions cannot be used for tests\n+    .label = `{$kind}` because of this\n+\n+builtin_macros_asm_explicit_register_name = explicit register arguments cannot have names\n+\n+builtin_macros_asm_mutually_exclusive = the `{$opt1}` and `{$opt2}` options are mutually exclusive\n+\n+builtin_macros_asm_pure_combine = the `pure` option must be combined with either `nomem` or `readonly`\n+\n+builtin_macros_asm_pure_no_output = asm with the `pure` option must have at least one output\n+\n+builtin_macros_asm_modifier_invalid = asm template modifier must be a single character\n+\n+builtin_macros_test_runner_invalid = `test_runner` argument must be a path\n+builtin_macros_test_runner_nargs = `#![test_runner(..)]` accepts exactly 1 argument"}, {"sha": "bcdd58a090162f6cf5909637cd8d647a4ab93534", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -15,6 +15,8 @@ use rustc_span::{InnerSpan, Span};\n use rustc_target::asm::InlineAsmArch;\n use smallvec::smallvec;\n \n+use crate::errors;\n+\n pub struct AsmArgs {\n     pub templates: Vec<P<ast::Expr>>,\n     pub operands: Vec<(ast::InlineAsmOperand, Span)>,\n@@ -205,7 +207,7 @@ pub fn parse_asm_args<'a>(\n         // of the argument available.\n         if explicit_reg {\n             if name.is_some() {\n-                diag.struct_span_err(span, \"explicit register arguments cannot have names\").emit();\n+                diag.emit_err(errors::AsmExplicitRegisterName { span });\n             }\n             args.reg_args.insert(slot);\n         } else if let Some(name) = name {\n@@ -240,25 +242,19 @@ pub fn parse_asm_args<'a>(\n         && args.options.contains(ast::InlineAsmOptions::READONLY)\n     {\n         let spans = args.options_spans.clone();\n-        diag.struct_span_err(spans, \"the `nomem` and `readonly` options are mutually exclusive\")\n-            .emit();\n+        diag.emit_err(errors::AsmMutuallyExclusive { spans, opt1: \"nomem\", opt2: \"readonly\" });\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE)\n         && args.options.contains(ast::InlineAsmOptions::NORETURN)\n     {\n         let spans = args.options_spans.clone();\n-        diag.struct_span_err(spans, \"the `pure` and `noreturn` options are mutually exclusive\")\n-            .emit();\n+        diag.emit_err(errors::AsmMutuallyExclusive { spans, opt1: \"pure\", opt2: \"noreturn\" });\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE)\n         && !args.options.intersects(ast::InlineAsmOptions::NOMEM | ast::InlineAsmOptions::READONLY)\n     {\n         let spans = args.options_spans.clone();\n-        diag.struct_span_err(\n-            spans,\n-            \"the `pure` option must be combined with either `nomem` or `readonly`\",\n-        )\n-        .emit();\n+        diag.emit_err(errors::AsmPureCombine { spans });\n     }\n \n     let mut have_real_output = false;\n@@ -285,11 +281,7 @@ pub fn parse_asm_args<'a>(\n         }\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE) && !have_real_output {\n-        diag.struct_span_err(\n-            args.options_spans.clone(),\n-            \"asm with the `pure` option must have at least one output\",\n-        )\n-        .emit();\n+        diag.emit_err(errors::AsmPureNoOutput { spans: args.options_spans.clone() });\n     }\n     if args.options.contains(ast::InlineAsmOptions::NORETURN) && !outputs_sp.is_empty() {\n         let err = diag\n@@ -705,11 +697,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                             .ty_span\n                             .map(|sp| template_sp.from_inner(InnerSpan::new(sp.start, sp.end)))\n                             .unwrap_or(template_sp);\n-                        ecx.struct_span_err(\n-                            span,\n-                            \"asm template modifier must be a single character\",\n-                        )\n-                        .emit();\n+                        ecx.emit_err(errors::AsmModifierInvalid { span });\n                         modifier = None;\n                     }\n "}, {"sha": "090e00616fb4806f7ad956413a13d2125ddb25b4", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -301,6 +301,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             | ExprKind::If(_, _, _)\n             | ExprKind::IncludedBytes(..)\n             | ExprKind::InlineAsm(_)\n+            | ExprKind::OffsetOf(_, _)\n             | ExprKind::Let(_, _, _)\n             | ExprKind::Lit(_)\n             | ExprKind::Loop(_, _, _)"}, {"sha": "b146988a3c2357a33e8914d51239ec1caae479e5", "filename": "compiler/rustc_builtin_macros/src/errors.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -551,3 +551,71 @@ pub(crate) struct FormatPositionalMismatch {\n     #[subdiagnostic]\n     pub(crate) highlight: SingleLabelManySpans,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_test_case_non_item)]\n+pub(crate) struct TestCaseNonItem {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_test_bad_fn)]\n+pub(crate) struct TestBadFn {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[label]\n+    pub(crate) cause: Span,\n+    pub(crate) kind: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_explicit_register_name)]\n+pub(crate) struct AsmExplicitRegisterName {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_mutually_exclusive)]\n+pub(crate) struct AsmMutuallyExclusive {\n+    #[primary_span]\n+    pub(crate) spans: Vec<Span>,\n+    pub(crate) opt1: &'static str,\n+    pub(crate) opt2: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_pure_combine)]\n+pub(crate) struct AsmPureCombine {\n+    #[primary_span]\n+    pub(crate) spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_pure_no_output)]\n+pub(crate) struct AsmPureNoOutput {\n+    #[primary_span]\n+    pub(crate) spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_modifier_invalid)]\n+pub(crate) struct AsmModifierInvalid {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_test_runner_invalid)]\n+pub(crate) struct TestRunnerInvalid {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_test_runner_nargs)]\n+pub(crate) struct TestRunnerNargs {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}"}, {"sha": "f17df5b0a83c72eeea38e41cdb6faec20def193b", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -141,13 +141,7 @@ fn parse_args<'a>(ecx: &mut ExtCtxt<'a>, sp: Span, tts: TokenStream) -> PResult<\n                         args: args\n                             .named_args()\n                             .iter()\n-                            .filter_map(|a| {\n-                                if let Some(ident) = a.kind.ident() {\n-                                    Some((a, ident))\n-                                } else {\n-                                    None\n-                                }\n-                            })\n+                            .filter_map(|a| a.kind.ident().map(|ident| (a, ident)))\n                             .map(|(arg, n)| n.span.to(arg.expr.span))\n                             .collect(),\n                     });"}, {"sha": "8f86ef44aa3ab8f6d07d8a1f19680e27b9d17ebc", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -24,7 +24,7 @@ use crate::deriving::*;\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_expand::base::{MacroExpanderFn, ResolverExpand, SyntaxExtensionKind};\n use rustc_expand::proc_macro::BangProcMacro;\n-use rustc_macros::fluent_messages;\n+use rustc_fluent_macro::fluent_messages;\n use rustc_span::symbol::sym;\n \n mod alloc_error_handler;\n@@ -45,6 +45,7 @@ mod format;\n mod format_foreign;\n mod global_allocator;\n mod log_syntax;\n+mod offset_of;\n mod source_util;\n mod test;\n mod trace_macros;\n@@ -92,6 +93,7 @@ pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n         line: source_util::expand_line,\n         log_syntax: log_syntax::expand_log_syntax,\n         module_path: source_util::expand_mod,\n+        offset_of: offset_of::expand_offset_of,\n         option_env: env::expand_option_env,\n         core_panic: edition_panic::expand_panic,\n         std_panic: edition_panic::expand_panic,"}, {"sha": "0ef3e000e414c40c69fb87601320f8f07098957f", "filename": "compiler/rustc_builtin_macros/src/offset_of.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Foffset_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Foffset_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Foffset_of.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,99 @@\n+use rustc_ast as ast;\n+use rustc_ast::ptr::P;\n+use rustc_ast::token;\n+use rustc_ast::tokenstream::TokenStream;\n+use rustc_errors::PResult;\n+use rustc_expand::base::{self, *};\n+use rustc_macros::Diagnostic;\n+use rustc_parse::parser::Parser;\n+use rustc_span::{symbol::Ident, Span};\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_offset_of_expected_field)]\n+struct ExpectedField {\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_offset_of_expected_two_args)]\n+struct ExpectedTwoArgs {\n+    #[primary_span]\n+    span: Span,\n+}\n+\n+fn parse_field<'a>(cx: &ExtCtxt<'a>, p: &mut Parser<'a>) -> PResult<'a, Ident> {\n+    let token = p.token.uninterpolate();\n+    let field = match token.kind {\n+        token::Ident(name, _) => Ident::new(name, token.span),\n+        token::Literal(token::Lit { kind: token::Integer, symbol, suffix: None }) => {\n+            Ident::new(symbol, token.span)\n+        }\n+        _ => return Err(cx.create_err(ExpectedField { span: p.token.span })),\n+    };\n+\n+    p.bump();\n+\n+    Ok(field)\n+}\n+\n+fn parse_args<'a>(\n+    cx: &mut ExtCtxt<'a>,\n+    sp: Span,\n+    tts: TokenStream,\n+) -> PResult<'a, (P<ast::Ty>, P<[Ident]>)> {\n+    let mut p = cx.new_parser_from_tts(tts);\n+\n+    let container = p.parse_ty()?;\n+\n+    p.expect(&token::Comma)?;\n+\n+    if p.eat(&token::Eof) {\n+        return Err(cx.create_err(ExpectedTwoArgs { span: sp }));\n+    }\n+\n+    let mut fields = Vec::new();\n+\n+    loop {\n+        let field = parse_field(cx, &mut p)?;\n+        fields.push(field);\n+\n+        if p.eat(&token::Dot) {\n+            continue;\n+        }\n+\n+        p.eat(&token::Comma);\n+\n+        if !p.eat(&token::Eof) {\n+            return Err(cx.create_err(ExpectedTwoArgs { span: sp }));\n+        }\n+\n+        break;\n+    }\n+\n+    Ok((container, fields.into()))\n+}\n+\n+pub fn expand_offset_of<'cx>(\n+    cx: &'cx mut ExtCtxt<'_>,\n+    sp: Span,\n+    tts: TokenStream,\n+) -> Box<dyn base::MacResult + 'cx> {\n+    match parse_args(cx, sp, tts) {\n+        Ok((container, fields)) => {\n+            let expr = P(ast::Expr {\n+                id: ast::DUMMY_NODE_ID,\n+                kind: ast::ExprKind::OffsetOf(container, fields),\n+                span: sp,\n+                attrs: ast::AttrVec::new(),\n+                tokens: None,\n+            });\n+\n+            MacEager::expr(expr)\n+        }\n+        Err(mut err) => {\n+            err.emit();\n+            DummyResult::any(sp)\n+        }\n+    }\n+}"}, {"sha": "49ee276af4e6f2b13af83b7664d5370d4d185784", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n /// The expansion from a test function to the appropriate test struct for libtest\n /// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n use crate::util::{check_builtin_macro_attribute, warn_on_duplicate_attribute};\n@@ -40,12 +41,7 @@ pub fn expand_test_case(\n             unreachable!()\n         },\n         _ => {\n-            ecx.struct_span_err(\n-                anno_item.span(),\n-                \"`#[test_case]` attribute is only allowed on items\",\n-            )\n-            .emit();\n-\n+            ecx.emit_err(errors::TestCaseNonItem { span: anno_item.span() });\n             return vec![];\n         }\n     };\n@@ -533,15 +529,11 @@ fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n     match &i.kind {\n         ast::ItemKind::Fn(box ast::Fn { sig, generics, .. }) => {\n             if let ast::Unsafe::Yes(span) = sig.header.unsafety {\n-                sd.struct_span_err(i.span, \"unsafe functions cannot be used for tests\")\n-                    .span_label(span, \"`unsafe` because of this\")\n-                    .emit();\n+                sd.emit_err(errors::TestBadFn { span: i.span, cause: span, kind: \"unsafe\" });\n                 return false;\n             }\n             if let ast::Async::Yes { span, .. } = sig.header.asyncness {\n-                sd.struct_span_err(i.span, \"async functions cannot be used for tests\")\n-                    .span_label(span, \"`async` because of this\")\n-                    .emit();\n+                sd.emit_err(errors::TestBadFn { span: i.span, cause: span, kind: \"async\" });\n                 return false;\n             }\n "}, {"sha": "be4ba66c082aa9df702a450d58aac6452af43fc2", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -19,6 +19,8 @@ use tracing::debug;\n \n use std::{iter, mem};\n \n+use crate::errors;\n+\n #[derive(Clone)]\n struct Test {\n     span: Span,\n@@ -385,11 +387,11 @@ fn get_test_runner(sd: &rustc_errors::Handler, krate: &ast::Crate) -> Option<ast\n         [single] => match single.meta_item() {\n             Some(meta_item) if meta_item.is_word() => return Some(meta_item.path.clone()),\n             _ => {\n-                sd.struct_span_err(span, \"`test_runner` argument must be a path\").emit();\n+                sd.emit_err(errors::TestRunnerInvalid { span });\n             }\n         },\n         _ => {\n-            sd.struct_span_err(span, \"`#![test_runner(..)]` accepts exactly 1 argument\").emit();\n+            sd.emit_err(errors::TestRunnerNargs { span });\n         }\n     }\n     None"}, {"sha": "c70ba8f495387012782acf740be67aa5d14eadf8", "filename": "compiler/rustc_codegen_cranelift/.github/actions/github-release/README.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2FREADME.md?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,18 @@\n+# github-release\n+\n+An action used to publish GitHub releases for `wasmtime`.\n+\n+As of the time of this writing there's a few actions floating around which\n+perform github releases but they all tend to have their set of drawbacks.\n+Additionally nothing handles deleting releases which we need for our rolling\n+`dev` release.\n+\n+To handle all this this action rolls-its-own implementation using the\n+actions/toolkit repository and packages published there. These run in a Docker\n+container and take various inputs to orchestrate the release from the build.\n+\n+More comments can be found in `main.js`.\n+\n+Testing this is really hard. If you want to try though run `npm install` and\n+then `node main.js`. You'll have to configure a bunch of env vars though to get\n+anything reasonably working."}, {"sha": "36e5209f50c3b8aa0cb441bfd159673f5c32e4f1", "filename": "compiler/rustc_codegen_cranelift/.github/actions/github-release/action.yml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Faction.yml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Faction.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Faction.yml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,13 @@\n+# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+name: 'rustc_codegen_cranelift github releases'\n+description: 'rustc_codegen_cranelift github releases'\n+inputs:\n+  token:\n+    description: ''\n+    required: true\n+  files:\n+    description: ''\n+    required: true\n+runs:\n+  using: 'node16'\n+  main: 'main.js'"}, {"sha": "6fcfca34ea7766ab8096465f89010bb4fec8584f", "filename": "compiler/rustc_codegen_cranelift/.github/actions/github-release/main.js", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fmain.js?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,162 @@\n+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n+\n+const core = require('@actions/core');\n+const path = require(\"path\");\n+const fs = require(\"fs\");\n+const github = require('@actions/github');\n+const glob = require('glob');\n+\n+function sleep(milliseconds) {\n+  return new Promise(resolve => setTimeout(resolve, milliseconds))\n+}\n+\n+async function runOnce() {\n+  // Load all our inputs and env vars. Note that `getInput` reads from `INPUT_*`\n+  const files = core.getInput('files');\n+  const token = core.getInput('token');\n+  const slug = process.env.GITHUB_REPOSITORY;\n+  const owner = slug.split('/')[0];\n+  const repo = slug.split('/')[1];\n+  const sha = process.env.GITHUB_SHA;\n+  let name = 'dev';\n+  if (process.env.GITHUB_REF.startsWith('refs/tags/v')) {\n+    name = process.env.GITHUB_REF.substring(10);\n+  }\n+\n+  core.info(`files: ${files}`);\n+  core.info(`name: ${name}`);\n+  core.info(`token: ${token}`);\n+\n+  const octokit = github.getOctokit(token);\n+\n+  // For the `dev` release we may need to update the tag to point to the new\n+  // commit on this branch. All other names should already have tags associated\n+  // with them.\n+  if (name == 'dev') {\n+    let tag = null;\n+    try {\n+      tag = await octokit.request(\"GET /repos/:owner/:repo/git/refs/tags/:name\", { owner, repo, name });\n+      core.info(`found existing tag`);\n+      console.log(\"tag: \", JSON.stringify(tag.data, null, 2));\n+    } catch (e) {\n+      // ignore if this tag doesn't exist\n+      core.info(`no existing tag found`);\n+    }\n+\n+    if (tag === null || tag.data.object.sha !== sha) {\n+      core.info(`updating existing tag or creating new one`);\n+\n+      try {\n+        core.info(`updating dev tag`);\n+        await octokit.rest.git.updateRef({\n+          owner,\n+          repo,\n+          ref: 'tags/dev',\n+          sha,\n+          force: true,\n+        });\n+      } catch (e) {\n+        console.log(\"ERROR: \", JSON.stringify(e.data, null, 2));\n+        core.info(`creating dev tag`);\n+        try {\n+          await octokit.rest.git.createRef({\n+            owner,\n+            repo,\n+            ref: 'refs/tags/dev',\n+            sha,\n+          });\n+        } catch (e) {\n+          // we might race with others, so assume someone else has created the\n+          // tag by this point.\n+          console.log(\"failed to create tag: \", JSON.stringify(e.data, null, 2));\n+        }\n+      }\n+\n+      console.log(\"double-checking tag is correct\");\n+      tag = await octokit.request(\"GET /repos/:owner/:repo/git/refs/tags/:name\", { owner, repo, name });\n+      if (tag.data.object.sha !== sha) {\n+        console.log(\"tag: \", JSON.stringify(tag.data, null, 2));\n+        throw new Error(\"tag didn't work\");\n+      }\n+    } else {\n+      core.info(`existing tag works`);\n+    }\n+  }\n+\n+  // Delete a previous release\n+  try {\n+    core.info(`fetching release`);\n+    let release = await octokit.rest.repos.getReleaseByTag({ owner, repo, tag: name });\n+    console.log(\"found release: \", JSON.stringify(release.data, null, 2));\n+    await octokit.rest.repos.deleteRelease({\n+      owner,\n+      repo,\n+      release_id: release.data.id,\n+    });\n+    console.log(\"deleted release\");\n+  } catch (e) {\n+    console.log(\"ERROR: \", JSON.stringify(e, null, 2));\n+  }\n+\n+  console.log(\"creating a release\");\n+  let release = await octokit.rest.repos.createRelease({\n+    owner,\n+    repo,\n+    tag_name: name,\n+    prerelease: name === 'dev',\n+  });\n+\n+  // Delete all assets from a previous run\n+  for (const asset of release.data.assets) {\n+    console.log(`deleting prior asset ${asset.id}`);\n+    await octokit.rest.repos.deleteReleaseAsset({\n+      owner,\n+      repo,\n+      asset_id: asset.id,\n+    });\n+  }\n+\n+  // Upload all the relevant assets for this release as just general blobs.\n+  for (const file of glob.sync(files)) {\n+    const size = fs.statSync(file).size;\n+    const name = path.basename(file);\n+    core.info(`upload ${file}`);\n+    await octokit.rest.repos.uploadReleaseAsset({\n+      data: fs.createReadStream(file),\n+      headers: { 'content-length': size, 'content-type': 'application/octet-stream' },\n+      name,\n+      url: release.data.upload_url,\n+    });\n+  }\n+}\n+\n+async function run() {\n+  const retries = 10;\n+  for (let i = 0; i < retries; i++) {\n+    try {\n+      await runOnce();\n+      break;\n+    } catch (e) {\n+      if (i === retries - 1)\n+        throw e;\n+      logError(e);\n+      console.log(\"RETRYING after 10s\");\n+      await sleep(10000)\n+    }\n+  }\n+}\n+\n+function logError(e) {\n+  console.log(\"ERROR: \", e.message);\n+  try {\n+    console.log(JSON.stringify(e, null, 2));\n+  } catch (e) {\n+    // ignore json errors for now\n+  }\n+  console.log(e.stack);\n+}\n+\n+run().catch(err => {\n+  logError(err);\n+  core.setFailed(err.message);\n+});"}, {"sha": "dd3b2a048f09455080245ec1d29240830f378edb", "filename": "compiler/rustc_codegen_cranelift/.github/actions/github-release/package-lock.json", "status": "added", "additions": 571, "deletions": 0, "changes": 571, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fpackage-lock.json", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fpackage-lock.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fpackage-lock.json?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,571 @@\n+{\n+  \"name\": \"rustc_codegen_cranelift-github-release\",\n+  \"version\": \"0.0.0\",\n+  \"lockfileVersion\": 2,\n+  \"requires\": true,\n+  \"packages\": {\n+    \"\": {\n+      \"name\": \"rustc_codegen_cranelift-github-release\",\n+      \"version\": \"0.0.0\",\n+      \"dependencies\": {\n+        \"@actions/core\": \"^1.9.1\",\n+        \"@actions/github\": \"^5.1.0\",\n+        \"glob\": \"^7.1.5\"\n+      }\n+    },\n+    \"node_modules/@actions/core\": {\n+      \"version\": \"1.9.1\",\n+      \"resolved\": \"https://registry.npmjs.org/@actions/core/-/core-1.9.1.tgz\",\n+      \"integrity\": \"sha512-5ad+U2YGrmmiw6du20AQW5XuWo7UKN2052FjSV7MX+Wfjf8sCqcsZe62NfgHys4QI4/Y+vQvLKYL8jWtA1ZBTA==\",\n+      \"dependencies\": {\n+        \"@actions/http-client\": \"^2.0.1\",\n+        \"uuid\": \"^8.3.2\"\n+      }\n+    },\n+    \"node_modules/@actions/github\": {\n+      \"version\": \"5.1.0\",\n+      \"resolved\": \"https://registry.npmjs.org/@actions/github/-/github-5.1.0.tgz\",\n+      \"integrity\": \"sha512-tuI80F7JQIhg77ZTTgUAPpVD7ZnP9oHSPN8xw7LOwtA4vEMbAjWJNbmLBfV7xua7r016GyjzWLuec5cs8f/a8A==\",\n+      \"dependencies\": {\n+        \"@actions/http-client\": \"^2.0.1\",\n+        \"@octokit/core\": \"^3.6.0\",\n+        \"@octokit/plugin-paginate-rest\": \"^2.17.0\",\n+        \"@octokit/plugin-rest-endpoint-methods\": \"^5.13.0\"\n+      }\n+    },\n+    \"node_modules/@actions/http-client\": {\n+      \"version\": \"2.0.1\",\n+      \"resolved\": \"https://registry.npmjs.org/@actions/http-client/-/http-client-2.0.1.tgz\",\n+      \"integrity\": \"sha512-PIXiMVtz6VvyaRsGY268qvj57hXQEpsYogYOu2nrQhlf+XCGmZstmuZBbAybUl1nQGnvS1k1eEsQ69ZoD7xlSw==\",\n+      \"dependencies\": {\n+        \"tunnel\": \"^0.0.6\"\n+      }\n+    },\n+    \"node_modules/@octokit/auth-token\": {\n+      \"version\": \"2.5.0\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/auth-token/-/auth-token-2.5.0.tgz\",\n+      \"integrity\": \"sha512-r5FVUJCOLl19AxiuZD2VRZ/ORjp/4IN98Of6YJoJOkY75CIBuYfmiNHGrDwXr+aLGG55igl9QrxX3hbiXlLb+g==\",\n+      \"dependencies\": {\n+        \"@octokit/types\": \"^6.0.3\"\n+      }\n+    },\n+    \"node_modules/@octokit/core\": {\n+      \"version\": \"3.6.0\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/core/-/core-3.6.0.tgz\",\n+      \"integrity\": \"sha512-7RKRKuA4xTjMhY+eG3jthb3hlZCsOwg3rztWh75Xc+ShDWOfDDATWbeZpAHBNRpm4Tv9WgBMOy1zEJYXG6NJ7Q==\",\n+      \"dependencies\": {\n+        \"@octokit/auth-token\": \"^2.4.4\",\n+        \"@octokit/graphql\": \"^4.5.8\",\n+        \"@octokit/request\": \"^5.6.3\",\n+        \"@octokit/request-error\": \"^2.0.5\",\n+        \"@octokit/types\": \"^6.0.3\",\n+        \"before-after-hook\": \"^2.2.0\",\n+        \"universal-user-agent\": \"^6.0.0\"\n+      }\n+    },\n+    \"node_modules/@octokit/endpoint\": {\n+      \"version\": \"6.0.12\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/endpoint/-/endpoint-6.0.12.tgz\",\n+      \"integrity\": \"sha512-lF3puPwkQWGfkMClXb4k/eUT/nZKQfxinRWJrdZaJO85Dqwo/G0yOC434Jr2ojwafWJMYqFGFa5ms4jJUgujdA==\",\n+      \"dependencies\": {\n+        \"@octokit/types\": \"^6.0.3\",\n+        \"is-plain-object\": \"^5.0.0\",\n+        \"universal-user-agent\": \"^6.0.0\"\n+      }\n+    },\n+    \"node_modules/@octokit/graphql\": {\n+      \"version\": \"4.8.0\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/graphql/-/graphql-4.8.0.tgz\",\n+      \"integrity\": \"sha512-0gv+qLSBLKF0z8TKaSKTsS39scVKF9dbMxJpj3U0vC7wjNWFuIpL/z76Qe2fiuCbDRcJSavkXsVtMS6/dtQQsg==\",\n+      \"dependencies\": {\n+        \"@octokit/request\": \"^5.6.0\",\n+        \"@octokit/types\": \"^6.0.3\",\n+        \"universal-user-agent\": \"^6.0.0\"\n+      }\n+    },\n+    \"node_modules/@octokit/openapi-types\": {\n+      \"version\": \"12.11.0\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/openapi-types/-/openapi-types-12.11.0.tgz\",\n+      \"integrity\": \"sha512-VsXyi8peyRq9PqIz/tpqiL2w3w80OgVMwBHltTml3LmVvXiphgeqmY9mvBw9Wu7e0QWk/fqD37ux8yP5uVekyQ==\"\n+    },\n+    \"node_modules/@octokit/plugin-paginate-rest\": {\n+      \"version\": \"2.21.3\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/plugin-paginate-rest/-/plugin-paginate-rest-2.21.3.tgz\",\n+      \"integrity\": \"sha512-aCZTEf0y2h3OLbrgKkrfFdjRL6eSOo8komneVQJnYecAxIej7Bafor2xhuDJOIFau4pk0i/P28/XgtbyPF0ZHw==\",\n+      \"dependencies\": {\n+        \"@octokit/types\": \"^6.40.0\"\n+      },\n+      \"peerDependencies\": {\n+        \"@octokit/core\": \">=2\"\n+      }\n+    },\n+    \"node_modules/@octokit/plugin-rest-endpoint-methods\": {\n+      \"version\": \"5.16.2\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/plugin-rest-endpoint-methods/-/plugin-rest-endpoint-methods-5.16.2.tgz\",\n+      \"integrity\": \"sha512-8QFz29Fg5jDuTPXVtey05BLm7OB+M8fnvE64RNegzX7U+5NUXcOcnpTIK0YfSHBg8gYd0oxIq3IZTe9SfPZiRw==\",\n+      \"dependencies\": {\n+        \"@octokit/types\": \"^6.39.0\",\n+        \"deprecation\": \"^2.3.1\"\n+      },\n+      \"peerDependencies\": {\n+        \"@octokit/core\": \">=3\"\n+      }\n+    },\n+    \"node_modules/@octokit/request\": {\n+      \"version\": \"5.6.3\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/request/-/request-5.6.3.tgz\",\n+      \"integrity\": \"sha512-bFJl0I1KVc9jYTe9tdGGpAMPy32dLBXXo1dS/YwSCTL/2nd9XeHsY616RE3HPXDVk+a+dBuzyz5YdlXwcDTr2A==\",\n+      \"dependencies\": {\n+        \"@octokit/endpoint\": \"^6.0.1\",\n+        \"@octokit/request-error\": \"^2.1.0\",\n+        \"@octokit/types\": \"^6.16.1\",\n+        \"is-plain-object\": \"^5.0.0\",\n+        \"node-fetch\": \"^2.6.7\",\n+        \"universal-user-agent\": \"^6.0.0\"\n+      }\n+    },\n+    \"node_modules/@octokit/request-error\": {\n+      \"version\": \"2.1.0\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/request-error/-/request-error-2.1.0.tgz\",\n+      \"integrity\": \"sha512-1VIvgXxs9WHSjicsRwq8PlR2LR2x6DwsJAaFgzdi0JfJoGSO8mYI/cHJQ+9FbN21aa+DrgNLnwObmyeSC8Rmpg==\",\n+      \"dependencies\": {\n+        \"@octokit/types\": \"^6.0.3\",\n+        \"deprecation\": \"^2.0.0\",\n+        \"once\": \"^1.4.0\"\n+      }\n+    },\n+    \"node_modules/@octokit/types\": {\n+      \"version\": \"6.41.0\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/types/-/types-6.41.0.tgz\",\n+      \"integrity\": \"sha512-eJ2jbzjdijiL3B4PrSQaSjuF2sPEQPVCPzBvTHJD9Nz+9dw2SGH4K4xeQJ77YfTq5bRQ+bD8wT11JbeDPmxmGg==\",\n+      \"dependencies\": {\n+        \"@octokit/openapi-types\": \"^12.11.0\"\n+      }\n+    },\n+    \"node_modules/balanced-match\": {\n+      \"version\": \"1.0.2\",\n+      \"resolved\": \"https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz\",\n+      \"integrity\": \"sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==\"\n+    },\n+    \"node_modules/before-after-hook\": {\n+      \"version\": \"2.2.3\",\n+      \"resolved\": \"https://registry.npmjs.org/before-after-hook/-/before-after-hook-2.2.3.tgz\",\n+      \"integrity\": \"sha512-NzUnlZexiaH/46WDhANlyR2bXRopNg4F/zuSA3OpZnllCUgRaOF2znDioDWrmbNVsuZk6l9pMquQB38cfBZwkQ==\"\n+    },\n+    \"node_modules/brace-expansion\": {\n+      \"version\": \"1.1.11\",\n+      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n+      \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n+      \"dependencies\": {\n+        \"balanced-match\": \"^1.0.0\",\n+        \"concat-map\": \"0.0.1\"\n+      }\n+    },\n+    \"node_modules/concat-map\": {\n+      \"version\": \"0.0.1\",\n+      \"resolved\": \"https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz\",\n+      \"integrity\": \"sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==\"\n+    },\n+    \"node_modules/deprecation\": {\n+      \"version\": \"2.3.1\",\n+      \"resolved\": \"https://registry.npmjs.org/deprecation/-/deprecation-2.3.1.tgz\",\n+      \"integrity\": \"sha512-xmHIy4F3scKVwMsQ4WnVaS8bHOx0DmVwRywosKhaILI0ywMDWPtBSku2HNxRvF7jtwDRsoEwYQSfbxj8b7RlJQ==\"\n+    },\n+    \"node_modules/fs.realpath\": {\n+      \"version\": \"1.0.0\",\n+      \"resolved\": \"https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz\",\n+      \"integrity\": \"sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==\"\n+    },\n+    \"node_modules/glob\": {\n+      \"version\": \"7.2.3\",\n+      \"resolved\": \"https://registry.npmjs.org/glob/-/glob-7.2.3.tgz\",\n+      \"integrity\": \"sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==\",\n+      \"dependencies\": {\n+        \"fs.realpath\": \"^1.0.0\",\n+        \"inflight\": \"^1.0.4\",\n+        \"inherits\": \"2\",\n+        \"minimatch\": \"^3.1.1\",\n+        \"once\": \"^1.3.0\",\n+        \"path-is-absolute\": \"^1.0.0\"\n+      },\n+      \"engines\": {\n+        \"node\": \"*\"\n+      },\n+      \"funding\": {\n+        \"url\": \"https://github.com/sponsors/isaacs\"\n+      }\n+    },\n+    \"node_modules/inflight\": {\n+      \"version\": \"1.0.6\",\n+      \"resolved\": \"https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz\",\n+      \"integrity\": \"sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==\",\n+      \"dependencies\": {\n+        \"once\": \"^1.3.0\",\n+        \"wrappy\": \"1\"\n+      }\n+    },\n+    \"node_modules/inherits\": {\n+      \"version\": \"2.0.4\",\n+      \"resolved\": \"https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz\",\n+      \"integrity\": \"sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==\"\n+    },\n+    \"node_modules/is-plain-object\": {\n+      \"version\": \"5.0.0\",\n+      \"resolved\": \"https://registry.npmjs.org/is-plain-object/-/is-plain-object-5.0.0.tgz\",\n+      \"integrity\": \"sha512-VRSzKkbMm5jMDoKLbltAkFQ5Qr7VDiTFGXxYFXXowVj387GeGNOCsOH6Msy00SGZ3Fp84b1Naa1psqgcCIEP5Q==\",\n+      \"engines\": {\n+        \"node\": \">=0.10.0\"\n+      }\n+    },\n+    \"node_modules/minimatch\": {\n+      \"version\": \"3.1.2\",\n+      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n+      \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n+      \"dependencies\": {\n+        \"brace-expansion\": \"^1.1.7\"\n+      },\n+      \"engines\": {\n+        \"node\": \"*\"\n+      }\n+    },\n+    \"node_modules/node-fetch\": {\n+      \"version\": \"2.6.7\",\n+      \"resolved\": \"https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.7.tgz\",\n+      \"integrity\": \"sha512-ZjMPFEfVx5j+y2yF35Kzx5sF7kDzxuDj6ziH4FFbOp87zKDZNx8yExJIb05OGF4Nlt9IHFIMBkRl41VdvcNdbQ==\",\n+      \"dependencies\": {\n+        \"whatwg-url\": \"^5.0.0\"\n+      },\n+      \"engines\": {\n+        \"node\": \"4.x || >=6.0.0\"\n+      },\n+      \"peerDependencies\": {\n+        \"encoding\": \"^0.1.0\"\n+      },\n+      \"peerDependenciesMeta\": {\n+        \"encoding\": {\n+          \"optional\": true\n+        }\n+      }\n+    },\n+    \"node_modules/once\": {\n+      \"version\": \"1.4.0\",\n+      \"resolved\": \"https://registry.npmjs.org/once/-/once-1.4.0.tgz\",\n+      \"integrity\": \"sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==\",\n+      \"dependencies\": {\n+        \"wrappy\": \"1\"\n+      }\n+    },\n+    \"node_modules/path-is-absolute\": {\n+      \"version\": \"1.0.1\",\n+      \"resolved\": \"https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz\",\n+      \"integrity\": \"sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==\",\n+      \"engines\": {\n+        \"node\": \">=0.10.0\"\n+      }\n+    },\n+    \"node_modules/tr46\": {\n+      \"version\": \"0.0.3\",\n+      \"resolved\": \"https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz\",\n+      \"integrity\": \"sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==\"\n+    },\n+    \"node_modules/tunnel\": {\n+      \"version\": \"0.0.6\",\n+      \"resolved\": \"https://registry.npmjs.org/tunnel/-/tunnel-0.0.6.tgz\",\n+      \"integrity\": \"sha512-1h/Lnq9yajKY2PEbBadPXj3VxsDDu844OnaAo52UVmIzIvwwtBPIuNvkjuzBlTWpfJyUbG3ez0KSBibQkj4ojg==\",\n+      \"engines\": {\n+        \"node\": \">=0.6.11 <=0.7.0 || >=0.7.3\"\n+      }\n+    },\n+    \"node_modules/universal-user-agent\": {\n+      \"version\": \"6.0.0\",\n+      \"resolved\": \"https://registry.npmjs.org/universal-user-agent/-/universal-user-agent-6.0.0.tgz\",\n+      \"integrity\": \"sha512-isyNax3wXoKaulPDZWHQqbmIx1k2tb9fb3GGDBRxCscfYV2Ch7WxPArBsFEG8s/safwXTT7H4QGhaIkTp9447w==\"\n+    },\n+    \"node_modules/uuid\": {\n+      \"version\": \"8.3.2\",\n+      \"resolved\": \"https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz\",\n+      \"integrity\": \"sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==\",\n+      \"bin\": {\n+        \"uuid\": \"dist/bin/uuid\"\n+      }\n+    },\n+    \"node_modules/webidl-conversions\": {\n+      \"version\": \"3.0.1\",\n+      \"resolved\": \"https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz\",\n+      \"integrity\": \"sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ==\"\n+    },\n+    \"node_modules/whatwg-url\": {\n+      \"version\": \"5.0.0\",\n+      \"resolved\": \"https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz\",\n+      \"integrity\": \"sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==\",\n+      \"dependencies\": {\n+        \"tr46\": \"~0.0.3\",\n+        \"webidl-conversions\": \"^3.0.0\"\n+      }\n+    },\n+    \"node_modules/wrappy\": {\n+      \"version\": \"1.0.2\",\n+      \"resolved\": \"https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz\",\n+      \"integrity\": \"sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==\"\n+    }\n+  },\n+  \"dependencies\": {\n+    \"@actions/core\": {\n+      \"version\": \"1.9.1\",\n+      \"resolved\": \"https://registry.npmjs.org/@actions/core/-/core-1.9.1.tgz\",\n+      \"integrity\": \"sha512-5ad+U2YGrmmiw6du20AQW5XuWo7UKN2052FjSV7MX+Wfjf8sCqcsZe62NfgHys4QI4/Y+vQvLKYL8jWtA1ZBTA==\",\n+      \"requires\": {\n+        \"@actions/http-client\": \"^2.0.1\",\n+        \"uuid\": \"^8.3.2\"\n+      }\n+    },\n+    \"@actions/github\": {\n+      \"version\": \"5.1.0\",\n+      \"resolved\": \"https://registry.npmjs.org/@actions/github/-/github-5.1.0.tgz\",\n+      \"integrity\": \"sha512-tuI80F7JQIhg77ZTTgUAPpVD7ZnP9oHSPN8xw7LOwtA4vEMbAjWJNbmLBfV7xua7r016GyjzWLuec5cs8f/a8A==\",\n+      \"requires\": {\n+        \"@actions/http-client\": \"^2.0.1\",\n+        \"@octokit/core\": \"^3.6.0\",\n+        \"@octokit/plugin-paginate-rest\": \"^2.17.0\",\n+        \"@octokit/plugin-rest-endpoint-methods\": \"^5.13.0\"\n+      }\n+    },\n+    \"@actions/http-client\": {\n+      \"version\": \"2.0.1\",\n+      \"resolved\": \"https://registry.npmjs.org/@actions/http-client/-/http-client-2.0.1.tgz\",\n+      \"integrity\": \"sha512-PIXiMVtz6VvyaRsGY268qvj57hXQEpsYogYOu2nrQhlf+XCGmZstmuZBbAybUl1nQGnvS1k1eEsQ69ZoD7xlSw==\",\n+      \"requires\": {\n+        \"tunnel\": \"^0.0.6\"\n+      }\n+    },\n+    \"@octokit/auth-token\": {\n+      \"version\": \"2.5.0\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/auth-token/-/auth-token-2.5.0.tgz\",\n+      \"integrity\": \"sha512-r5FVUJCOLl19AxiuZD2VRZ/ORjp/4IN98Of6YJoJOkY75CIBuYfmiNHGrDwXr+aLGG55igl9QrxX3hbiXlLb+g==\",\n+      \"requires\": {\n+        \"@octokit/types\": \"^6.0.3\"\n+      }\n+    },\n+    \"@octokit/core\": {\n+      \"version\": \"3.6.0\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/core/-/core-3.6.0.tgz\",\n+      \"integrity\": \"sha512-7RKRKuA4xTjMhY+eG3jthb3hlZCsOwg3rztWh75Xc+ShDWOfDDATWbeZpAHBNRpm4Tv9WgBMOy1zEJYXG6NJ7Q==\",\n+      \"requires\": {\n+        \"@octokit/auth-token\": \"^2.4.4\",\n+        \"@octokit/graphql\": \"^4.5.8\",\n+        \"@octokit/request\": \"^5.6.3\",\n+        \"@octokit/request-error\": \"^2.0.5\",\n+        \"@octokit/types\": \"^6.0.3\",\n+        \"before-after-hook\": \"^2.2.0\",\n+        \"universal-user-agent\": \"^6.0.0\"\n+      }\n+    },\n+    \"@octokit/endpoint\": {\n+      \"version\": \"6.0.12\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/endpoint/-/endpoint-6.0.12.tgz\",\n+      \"integrity\": \"sha512-lF3puPwkQWGfkMClXb4k/eUT/nZKQfxinRWJrdZaJO85Dqwo/G0yOC434Jr2ojwafWJMYqFGFa5ms4jJUgujdA==\",\n+      \"requires\": {\n+        \"@octokit/types\": \"^6.0.3\",\n+        \"is-plain-object\": \"^5.0.0\",\n+        \"universal-user-agent\": \"^6.0.0\"\n+      }\n+    },\n+    \"@octokit/graphql\": {\n+      \"version\": \"4.8.0\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/graphql/-/graphql-4.8.0.tgz\",\n+      \"integrity\": \"sha512-0gv+qLSBLKF0z8TKaSKTsS39scVKF9dbMxJpj3U0vC7wjNWFuIpL/z76Qe2fiuCbDRcJSavkXsVtMS6/dtQQsg==\",\n+      \"requires\": {\n+        \"@octokit/request\": \"^5.6.0\",\n+        \"@octokit/types\": \"^6.0.3\",\n+        \"universal-user-agent\": \"^6.0.0\"\n+      }\n+    },\n+    \"@octokit/openapi-types\": {\n+      \"version\": \"12.11.0\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/openapi-types/-/openapi-types-12.11.0.tgz\",\n+      \"integrity\": \"sha512-VsXyi8peyRq9PqIz/tpqiL2w3w80OgVMwBHltTml3LmVvXiphgeqmY9mvBw9Wu7e0QWk/fqD37ux8yP5uVekyQ==\"\n+    },\n+    \"@octokit/plugin-paginate-rest\": {\n+      \"version\": \"2.21.3\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/plugin-paginate-rest/-/plugin-paginate-rest-2.21.3.tgz\",\n+      \"integrity\": \"sha512-aCZTEf0y2h3OLbrgKkrfFdjRL6eSOo8komneVQJnYecAxIej7Bafor2xhuDJOIFau4pk0i/P28/XgtbyPF0ZHw==\",\n+      \"requires\": {\n+        \"@octokit/types\": \"^6.40.0\"\n+      }\n+    },\n+    \"@octokit/plugin-rest-endpoint-methods\": {\n+      \"version\": \"5.16.2\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/plugin-rest-endpoint-methods/-/plugin-rest-endpoint-methods-5.16.2.tgz\",\n+      \"integrity\": \"sha512-8QFz29Fg5jDuTPXVtey05BLm7OB+M8fnvE64RNegzX7U+5NUXcOcnpTIK0YfSHBg8gYd0oxIq3IZTe9SfPZiRw==\",\n+      \"requires\": {\n+        \"@octokit/types\": \"^6.39.0\",\n+        \"deprecation\": \"^2.3.1\"\n+      }\n+    },\n+    \"@octokit/request\": {\n+      \"version\": \"5.6.3\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/request/-/request-5.6.3.tgz\",\n+      \"integrity\": \"sha512-bFJl0I1KVc9jYTe9tdGGpAMPy32dLBXXo1dS/YwSCTL/2nd9XeHsY616RE3HPXDVk+a+dBuzyz5YdlXwcDTr2A==\",\n+      \"requires\": {\n+        \"@octokit/endpoint\": \"^6.0.1\",\n+        \"@octokit/request-error\": \"^2.1.0\",\n+        \"@octokit/types\": \"^6.16.1\",\n+        \"is-plain-object\": \"^5.0.0\",\n+        \"node-fetch\": \"^2.6.7\",\n+        \"universal-user-agent\": \"^6.0.0\"\n+      }\n+    },\n+    \"@octokit/request-error\": {\n+      \"version\": \"2.1.0\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/request-error/-/request-error-2.1.0.tgz\",\n+      \"integrity\": \"sha512-1VIvgXxs9WHSjicsRwq8PlR2LR2x6DwsJAaFgzdi0JfJoGSO8mYI/cHJQ+9FbN21aa+DrgNLnwObmyeSC8Rmpg==\",\n+      \"requires\": {\n+        \"@octokit/types\": \"^6.0.3\",\n+        \"deprecation\": \"^2.0.0\",\n+        \"once\": \"^1.4.0\"\n+      }\n+    },\n+    \"@octokit/types\": {\n+      \"version\": \"6.41.0\",\n+      \"resolved\": \"https://registry.npmjs.org/@octokit/types/-/types-6.41.0.tgz\",\n+      \"integrity\": \"sha512-eJ2jbzjdijiL3B4PrSQaSjuF2sPEQPVCPzBvTHJD9Nz+9dw2SGH4K4xeQJ77YfTq5bRQ+bD8wT11JbeDPmxmGg==\",\n+      \"requires\": {\n+        \"@octokit/openapi-types\": \"^12.11.0\"\n+      }\n+    },\n+    \"balanced-match\": {\n+      \"version\": \"1.0.2\",\n+      \"resolved\": \"https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz\",\n+      \"integrity\": \"sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==\"\n+    },\n+    \"before-after-hook\": {\n+      \"version\": \"2.2.3\",\n+      \"resolved\": \"https://registry.npmjs.org/before-after-hook/-/before-after-hook-2.2.3.tgz\",\n+      \"integrity\": \"sha512-NzUnlZexiaH/46WDhANlyR2bXRopNg4F/zuSA3OpZnllCUgRaOF2znDioDWrmbNVsuZk6l9pMquQB38cfBZwkQ==\"\n+    },\n+    \"brace-expansion\": {\n+      \"version\": \"1.1.11\",\n+      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n+      \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n+      \"requires\": {\n+        \"balanced-match\": \"^1.0.0\",\n+        \"concat-map\": \"0.0.1\"\n+      }\n+    },\n+    \"concat-map\": {\n+      \"version\": \"0.0.1\",\n+      \"resolved\": \"https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz\",\n+      \"integrity\": \"sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==\"\n+    },\n+    \"deprecation\": {\n+      \"version\": \"2.3.1\",\n+      \"resolved\": \"https://registry.npmjs.org/deprecation/-/deprecation-2.3.1.tgz\",\n+      \"integrity\": \"sha512-xmHIy4F3scKVwMsQ4WnVaS8bHOx0DmVwRywosKhaILI0ywMDWPtBSku2HNxRvF7jtwDRsoEwYQSfbxj8b7RlJQ==\"\n+    },\n+    \"fs.realpath\": {\n+      \"version\": \"1.0.0\",\n+      \"resolved\": \"https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz\",\n+      \"integrity\": \"sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==\"\n+    },\n+    \"glob\": {\n+      \"version\": \"7.2.3\",\n+      \"resolved\": \"https://registry.npmjs.org/glob/-/glob-7.2.3.tgz\",\n+      \"integrity\": \"sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==\",\n+      \"requires\": {\n+        \"fs.realpath\": \"^1.0.0\",\n+        \"inflight\": \"^1.0.4\",\n+        \"inherits\": \"2\",\n+        \"minimatch\": \"^3.1.1\",\n+        \"once\": \"^1.3.0\",\n+        \"path-is-absolute\": \"^1.0.0\"\n+      }\n+    },\n+    \"inflight\": {\n+      \"version\": \"1.0.6\",\n+      \"resolved\": \"https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz\",\n+      \"integrity\": \"sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==\",\n+      \"requires\": {\n+        \"once\": \"^1.3.0\",\n+        \"wrappy\": \"1\"\n+      }\n+    },\n+    \"inherits\": {\n+      \"version\": \"2.0.4\",\n+      \"resolved\": \"https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz\",\n+      \"integrity\": \"sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==\"\n+    },\n+    \"is-plain-object\": {\n+      \"version\": \"5.0.0\",\n+      \"resolved\": \"https://registry.npmjs.org/is-plain-object/-/is-plain-object-5.0.0.tgz\",\n+      \"integrity\": \"sha512-VRSzKkbMm5jMDoKLbltAkFQ5Qr7VDiTFGXxYFXXowVj387GeGNOCsOH6Msy00SGZ3Fp84b1Naa1psqgcCIEP5Q==\"\n+    },\n+    \"minimatch\": {\n+      \"version\": \"3.1.2\",\n+      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz\",\n+      \"integrity\": \"sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==\",\n+      \"requires\": {\n+        \"brace-expansion\": \"^1.1.7\"\n+      }\n+    },\n+    \"node-fetch\": {\n+      \"version\": \"2.6.7\",\n+      \"resolved\": \"https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.7.tgz\",\n+      \"integrity\": \"sha512-ZjMPFEfVx5j+y2yF35Kzx5sF7kDzxuDj6ziH4FFbOp87zKDZNx8yExJIb05OGF4Nlt9IHFIMBkRl41VdvcNdbQ==\",\n+      \"requires\": {\n+        \"whatwg-url\": \"^5.0.0\"\n+      }\n+    },\n+    \"once\": {\n+      \"version\": \"1.4.0\",\n+      \"resolved\": \"https://registry.npmjs.org/once/-/once-1.4.0.tgz\",\n+      \"integrity\": \"sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==\",\n+      \"requires\": {\n+        \"wrappy\": \"1\"\n+      }\n+    },\n+    \"path-is-absolute\": {\n+      \"version\": \"1.0.1\",\n+      \"resolved\": \"https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz\",\n+      \"integrity\": \"sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==\"\n+    },\n+    \"tr46\": {\n+      \"version\": \"0.0.3\",\n+      \"resolved\": \"https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz\",\n+      \"integrity\": \"sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw==\"\n+    },\n+    \"tunnel\": {\n+      \"version\": \"0.0.6\",\n+      \"resolved\": \"https://registry.npmjs.org/tunnel/-/tunnel-0.0.6.tgz\",\n+      \"integrity\": \"sha512-1h/Lnq9yajKY2PEbBadPXj3VxsDDu844OnaAo52UVmIzIvwwtBPIuNvkjuzBlTWpfJyUbG3ez0KSBibQkj4ojg==\"\n+    },\n+    \"universal-user-agent\": {\n+      \"version\": \"6.0.0\",\n+      \"resolved\": \"https://registry.npmjs.org/universal-user-agent/-/universal-user-agent-6.0.0.tgz\",\n+      \"integrity\": \"sha512-isyNax3wXoKaulPDZWHQqbmIx1k2tb9fb3GGDBRxCscfYV2Ch7WxPArBsFEG8s/safwXTT7H4QGhaIkTp9447w==\"\n+    },\n+    \"uuid\": {\n+      \"version\": \"8.3.2\",\n+      \"resolved\": \"https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz\",\n+      \"integrity\": \"sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==\"\n+    },\n+    \"webidl-conversions\": {\n+      \"version\": \"3.0.1\",\n+      \"resolved\": \"https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz\",\n+      \"integrity\": \"sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ==\"\n+    },\n+    \"whatwg-url\": {\n+      \"version\": \"5.0.0\",\n+      \"resolved\": \"https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz\",\n+      \"integrity\": \"sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==\",\n+      \"requires\": {\n+        \"tr46\": \"~0.0.3\",\n+        \"webidl-conversions\": \"^3.0.0\"\n+      }\n+    },\n+    \"wrappy\": {\n+      \"version\": \"1.0.2\",\n+      \"resolved\": \"https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz\",\n+      \"integrity\": \"sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==\"\n+    }\n+  }\n+}"}, {"sha": "d9c23f8873ece8afe2ef7a7703e1fa13306f16b2", "filename": "compiler/rustc_codegen_cranelift/.github/actions/github-release/package.json", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Factions%2Fgithub-release%2Fpackage.json?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,11 @@\n+{\n+  \"name\": \"rustc_codegen_cranelift-github-release\",\n+  \"version\": \"0.0.0\",\n+  \"license\": \"Apache-2.0 WITH LLVM-exception\",\n+  \"main\": \"main.js\",\n+  \"dependencies\": {\n+    \"@actions/core\": \"^1.9.1\",\n+    \"@actions/github\": \"^5.1.0\",\n+    \"glob\": \"^7.1.5\"\n+  }\n+}"}, {"sha": "3c40555669cb38e8d19984fdbce0344ea9dc060c", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/abi-cafe.yml", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fabi-cafe.yml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fabi-cafe.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fabi-cafe.yml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -45,13 +45,6 @@ jobs:\n       if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n       run: rustup set default-host x86_64-pc-windows-gnu\n \n-    - name: Use sparse cargo registry\n-      run: |\n-        cat >> ~/.cargo/config.toml <<EOF\n-        [unstable]\n-        sparse-registry = true\n-        EOF\n-\n     - name: Prepare dependencies\n       run: ./y.rs prepare\n "}, {"sha": "e4af73ea6442e5bcd3a6c9439d6a3565a09d5178", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -20,6 +20,7 @@ jobs:\n       run: |\n         cargo fmt --check\n         rustfmt --check build_system/mod.rs\n+        rustfmt --check example/*\n \n \n   test:\n@@ -89,13 +90,6 @@ jobs:\n         sudo apt-get update\n         sudo apt-get install -y gcc-s390x-linux-gnu qemu-user\n \n-    - name: Use sparse cargo registry\n-      run: |\n-        cat >> ~/.cargo/config.toml <<EOF\n-        [unstable]\n-        sparse-registry = true\n-        EOF\n-\n     - name: Prepare dependencies\n       run: ./y.rs prepare\n \n@@ -137,13 +131,6 @@ jobs:\n         path: ~/.cargo/bin\n         key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-bin-dir-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n-    - name: Use sparse cargo registry\n-      run: |\n-        cat >> ~/.cargo/config.toml <<EOF\n-        [unstable]\n-        sparse-registry = true\n-        EOF\n-\n     - name: Install hyperfine\n       run: cargo install hyperfine || true\n \n@@ -206,13 +193,6 @@ jobs:\n         sudo apt-get update\n         sudo apt-get install -y gcc-mingw-w64-x86-64 wine-stable\n \n-    - name: Use sparse cargo registry\n-      run: |\n-        cat >> ~/.cargo/config.toml <<EOF\n-        [unstable]\n-        sparse-registry = true\n-        EOF\n-\n     - name: Prepare dependencies\n       run: ./y.rs prepare\n \n@@ -238,3 +218,43 @@ jobs:\n       with:\n         name: cg_clif-${{ runner.os }}-cross-x86_64-mingw\n         path: cg_clif.tar.xz\n+\n+  release:\n+    runs-on: ubuntu-latest\n+    timeout-minutes: 10\n+    if: ${{ github.ref == 'refs/heads/master' }}\n+    needs: [rustfmt, test, bench, dist]\n+\n+    concurrency:\n+      group: release-dev\n+      cancel-in-progress: true\n+\n+    steps:\n+      - uses: actions/checkout@v3\n+\n+      - name: Download all built artifacts\n+        uses: actions/download-artifact@v3\n+        with:\n+          path: artifacts/\n+\n+      - run: |\n+          ls -R artifacts/\n+          mkdir release/\n+          pushd artifacts/\n+          for dir in *; do\n+            mv $dir/cg_clif.tar.xz ../release/$dir.tar.xz\n+            rmdir $dir/ # verify $dir is empty\n+          done\n+          popd\n+          rmdir artifacts/ # verify all artifacts are represented in release/\n+          ls -R release/\n+\n+      - run: npm install --production\n+        working-directory: .github/actions/github-release\n+\n+      - name: Publish Release\n+        uses: ./.github/actions/github-release\n+        with:\n+          files: \"release/*\"\n+          token: ${{ github.token }}\n+        continue-on-error: true"}, {"sha": "b2f772c4fc4441f4c96606db8840c01271897b1c", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/rustc.yml", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Frustc.yml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -6,6 +6,7 @@ on:\n jobs:\n   bootstrap_rustc:\n     runs-on: ubuntu-latest\n+    timeout-minutes: 60\n \n     steps:\n     - uses: actions/checkout@v3\n@@ -16,20 +17,16 @@ jobs:\n         path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n-    - name: Use sparse cargo registry\n-      run: |\n-        cat >> ~/.cargo/config.toml <<EOF\n-        [unstable]\n-        sparse-registry = true\n-        EOF\n-\n     - name: Prepare dependencies\n       run: ./y.rs prepare\n \n     - name: Test\n       run: ./scripts/test_bootstrap.sh\n+\n+\n   rustc_test_suite:\n     runs-on: ubuntu-latest\n+    timeout-minutes: 60\n \n     steps:\n     - uses: actions/checkout@v3\n@@ -40,13 +37,6 @@ jobs:\n         path: build/cg_clif\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n \n-    - name: Use sparse cargo registry\n-      run: |\n-        cat >> ~/.cargo/config.toml <<EOF\n-        [unstable]\n-        sparse-registry = true\n-        EOF\n-\n     - name: Prepare dependencies\n       run: ./y.rs prepare\n "}, {"sha": "07a8e431a0e31ab93966eb700f0fb64c81b17d64", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 67, "deletions": 76, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -4,11 +4,11 @@ version = 3\n \n [[package]]\n name = \"ahash\"\n-version = \"0.7.6\"\n+version = \"0.8.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fcb51a0695d8f838b1ee009b3fbf66bda078cd64590202a864a8f3e8c4315c47\"\n+checksum = \"2c99f64d1e06488f620f932677e24bc6e2897582980441ae90a671415bd7ec2f\"\n dependencies = [\n- \"getrandom\",\n+ \"cfg-if\",\n  \"once_cell\",\n  \"version_check\",\n ]\n@@ -19,12 +19,6 @@ version = \"1.0.66\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"216261ddc8289130e551ddcd5ce8a064710c0d064a4d2895c67151c92b5443f6\"\n \n-[[package]]\n-name = \"arrayvec\"\n-version = \"0.7.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8da52d66c7071e2e3fa2a1e5c6d088fec47b593032b254f5e980de8ea54454d6\"\n-\n [[package]]\n name = \"autocfg\"\n version = \"1.1.0\"\n@@ -57,28 +51,27 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.93.1\"\n+version = \"0.95.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a7379abaacee0f14abf3204a7606118f0465785252169d186337bcb75030815a\"\n+checksum = \"1277fbfa94bc82c8ec4af2ded3e639d49ca5f7f3c7eeab2c66accd135ece4e70\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.93.1\"\n+version = \"0.95.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9489fa336927df749631f1008007ced2871068544f40a202ce6d93fbf2366a7b\"\n+checksum = \"c6e8c31ad3b2270e9aeec38723888fe1b0ace3bea2b06b3f749ccf46661d3220\"\n dependencies = [\n- \"arrayvec\",\n  \"bumpalo\",\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n  \"cranelift-codegen-shared\",\n  \"cranelift-entity\",\n  \"cranelift-isle\",\n  \"gimli\",\n- \"hashbrown\",\n+ \"hashbrown 0.13.2\",\n  \"log\",\n  \"regalloc2\",\n  \"smallvec\",\n@@ -87,30 +80,30 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.93.1\"\n+version = \"0.95.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"05bbb67da91ec721ed57cef2f7c5ef7728e1cd9bde9ffd3ef8601022e73e3239\"\n+checksum = \"c8ac5ac30d62b2d66f12651f6b606dbdfd9c2cfd0908de6b387560a277c5c9da\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.93.1\"\n+version = \"0.95.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"418ecb2f36032f6665dc1a5e2060a143dbab41d83b784882e97710e890a7a16d\"\n+checksum = \"dd82b8b376247834b59ed9bdc0ddeb50f517452827d4a11bccf5937b213748b8\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.93.1\"\n+version = \"0.95.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7cf583f7b093f291005f9fb1323e2c37f6ee4c7909e39ce016b2e8360d461705\"\n+checksum = \"40099d38061b37e505e63f89bab52199037a72b931ad4868d9089ff7268660b0\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.93.0\"\n+version = \"0.95.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7d361ed0373cf5f086b49c499aa72227b646a64f899f32e34312f97c0fadff75\"\n+checksum = \"64a25d9d0a0ae3079c463c34115ec59507b4707175454f0eee0891e83e30e82d\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -120,15 +113,15 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-isle\"\n-version = \"0.93.1\"\n+version = \"0.95.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"649782a39ce99798dd6b4029e2bb318a2fbeaade1b4fa25330763c10c65bc358\"\n+checksum = \"80de6a7d0486e4acbd5f9f87ec49912bf4c8fb6aea00087b989685460d4469ba\"\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.93.0\"\n+version = \"0.95.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9c9909222db472fcc98d9e4e7192fa9d064dac63a3fa657df8c6daae86fb2604\"\n+checksum = \"3ca96b05988aa057eda09a817a6e31915fabd7f476b513123aff08053cd193dd\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -145,19 +138,19 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.93.0\"\n+version = \"0.95.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"68689b83e52e605ba48652882d3fccc2e2e136abf139eb64ae667888ba0d52f8\"\n+checksum = \"e5112c0be9cc5da064e0620570d67852f11ce44f2e572a58ecf7f11df73978b8\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.93.0\"\n+version = \"0.95.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f98e4e99a353703475d5acb402b9c13482d41d8a4008b352559bd560afb90363\"\n+checksum = \"bb6b03e0e03801c4b3fd8ce0758a94750c07a44e7944cc0ffbf0d3f2e7c79b00\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -166,9 +159,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.93.0\"\n+version = \"0.95.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b7a006ce1d8dd11df67567d8673e5920f3a56441812aed52a007ffce8f1b20e9\"\n+checksum = \"48ed1b37d0972abe804cb5bf2b35f3a76a276ebbe148e3a726d8e31042790978\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -202,22 +195,11 @@ dependencies = [\n  \"byteorder\",\n ]\n \n-[[package]]\n-name = \"getrandom\"\n-version = \"0.2.8\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c05aeb6a22b8f62540c194aac980f2115af067bfe15a0734d7277a768d396b31\"\n-dependencies = [\n- \"cfg-if\",\n- \"libc\",\n- \"wasi\",\n-]\n-\n [[package]]\n name = \"gimli\"\n-version = \"0.26.2\"\n+version = \"0.27.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d\"\n+checksum = \"ad0a93d233ebf96623465aad4046a8d3aa4da22d4f4beba5388838c8a434bbb4\"\n dependencies = [\n  \"fallible-iterator\",\n  \"indexmap\",\n@@ -229,6 +211,12 @@ name = \"hashbrown\"\n version = \"0.12.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8a9ee70c43aaf417c914396645a0fa852624801b24ebb7ae78fe8272889ac888\"\n+\n+[[package]]\n+name = \"hashbrown\"\n+version = \"0.13.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"43a3c133739dddd0d2990f9a4bdf8eb4b21ef50e4851ca85ab661199821d510e\"\n dependencies = [\n  \"ahash\",\n ]\n@@ -240,7 +228,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99\"\n dependencies = [\n  \"autocfg\",\n- \"hashbrown\",\n+ \"hashbrown 0.12.3\",\n ]\n \n [[package]]\n@@ -285,12 +273,12 @@ checksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n \n [[package]]\n name = \"object\"\n-version = \"0.29.0\"\n+version = \"0.30.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n+checksum = \"ea86265d3d3dcb6a27fc51bd29a4bf387fae9d2986b823079d4986af253eb439\"\n dependencies = [\n  \"crc32fast\",\n- \"hashbrown\",\n+ \"hashbrown 0.13.2\",\n  \"indexmap\",\n  \"memchr\",\n ]\n@@ -303,9 +291,9 @@ checksum = \"86f0b0d4bf799edbc74508c1e8bf170ff5f41238e5f8225603ca7caaae2b7860\"\n \n [[package]]\n name = \"regalloc2\"\n-version = \"0.5.1\"\n+version = \"0.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"300d4fbfb40c1c66a78ba3ddd41c1110247cf52f97b87d0f2fc9209bd49b030c\"\n+checksum = \"80535183cae11b149d618fbd3c37e38d7cda589d82d7769e196ca9a9042d7621\"\n dependencies = [\n  \"fxhash\",\n  \"log\",\n@@ -374,17 +362,11 @@ version = \"0.9.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"49874b5167b65d7193b8aba1567f5c7d93d001cafc34600cee003eda787e483f\"\n \n-[[package]]\n-name = \"wasi\"\n-version = \"0.11.0+wasi-snapshot-preview1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n-\n [[package]]\n name = \"wasmtime-jit-icache-coherence\"\n-version = \"6.0.0\"\n+version = \"8.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ec1fd0f0dd79e7cc0f55b102e320d7c77ab76cd272008a8fd98e25b5777e2636\"\n+checksum = \"aecae978b13f7f67efb23bd827373ace4578f2137ec110bbf6a4a7cde4121bbd\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -415,9 +397,18 @@ checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n [[package]]\n name = \"windows-sys\"\n-version = \"0.42.0\"\n+version = \"0.45.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"75283be5efb2831d37ea142365f009c02ec203cd29a3ebecbc093d52315b66d0\"\n+dependencies = [\n+ \"windows-targets\",\n+]\n+\n+[[package]]\n+name = \"windows-targets\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5a3e1820f08b8513f676f7ab6c1f99ff312fb97b553d30ff4dd86f9f15728aa7\"\n+checksum = \"8e2522491fbfcd58cc84d47aeb2958948c4b8982e9a2d8a2a35bbaed431390e7\"\n dependencies = [\n  \"windows_aarch64_gnullvm\",\n  \"windows_aarch64_msvc\",\n@@ -430,42 +421,42 @@ dependencies = [\n \n [[package]]\n name = \"windows_aarch64_gnullvm\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"41d2aa71f6f0cbe00ae5167d90ef3cfe66527d6f613ca78ac8024c3ccab9a19e\"\n+checksum = \"8c9864e83243fdec7fc9c5444389dcbbfd258f745e7853198f365e3c4968a608\"\n \n [[package]]\n name = \"windows_aarch64_msvc\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dd0f252f5a35cac83d6311b2e795981f5ee6e67eb1f9a7f64eb4500fbc4dcdb4\"\n+checksum = \"4c8b1b673ffc16c47a9ff48570a9d85e25d265735c503681332589af6253c6c7\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fbeae19f6716841636c28d695375df17562ca208b2b7d0dc47635a50ae6c5de7\"\n+checksum = \"de3887528ad530ba7bdbb1faa8275ec7a1155a45ffa57c37993960277145d640\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"84c12f65daa39dd2babe6e442988fc329d6243fdce47d7d2d155b8d874862246\"\n+checksum = \"bf4d1122317eddd6ff351aa852118a2418ad4214e6613a50e0191f7004372605\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bf7b1b21b5362cbc318f686150e5bcea75ecedc74dd157d874d754a2ca44b0ed\"\n+checksum = \"c1040f221285e17ebccbc2591ffdc2d44ee1f9186324dd3e84e99ac68d699c45\"\n \n [[package]]\n name = \"windows_x86_64_gnullvm\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09d525d2ba30eeb3297665bd434a54297e4170c7f1a44cad4ef58095b4cd2028\"\n+checksum = \"628bfdf232daa22b0d64fdb62b09fcc36bb01f05a3939e20ab73aaf9470d0463\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n-version = \"0.42.0\"\n+version = \"0.42.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f40009d85759725a34da6d89a94e63d7bdc50a862acf0dbc7c8e488f1edcb6f5\"\n+checksum = \"447660ad36a13288b1db4d4248e857b510e8c3a225c822ba4fb748c0aafecffd\""}, {"sha": "a2890f6ddf9d462375f8236559918868f02d18f4", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -15,15 +15,15 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.93\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = { version = \"0.93\" }\n-cranelift-module = { version = \"0.93\" }\n-cranelift-native = { version = \"0.93\" }\n-cranelift-jit = { version = \"0.93\", optional = true }\n-cranelift-object = { version = \"0.93\" }\n+cranelift-codegen = { version = \"0.95.1\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = { version = \"0.95.1\" }\n+cranelift-module = { version = \"0.95.1\" }\n+cranelift-native = { version = \"0.95.1\" }\n+cranelift-jit = { version = \"0.95.1\", optional = true }\n+cranelift-object = { version = \"0.95.1\" }\n target-lexicon = \"0.12.0\"\n-gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n-object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n+gimli = { version = \"0.27.2\", default-features = false, features = [\"write\"]}\n+object = { version = \"0.30.3\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n indexmap = \"1.9.3\"\n libloading = { version = \"0.7.3\", optional = true }"}, {"sha": "c5222982aa739a6a7dcc67915cc19d9ba840c520", "filename": "compiler/rustc_codegen_cranelift/Readme.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FReadme.md?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -22,10 +22,9 @@ $ ./test.sh\n \n For more docs on how to build and test see [build_system/usage.txt](build_system/usage.txt) or the help message of `./y.rs`.\n \n-Alternatively you can download a pre built version from [Github Actions]. It is listed in the artifacts section\n-of workflow runs. Unfortunately due to GHA restrictions you need to be logged in to access it.\n+Alternatively you can download a pre built version from the [releases] page.\n \n-[Github Actions]: https://github.com/bjorn3/rustc_codegen_cranelift/actions?query=branch%3Amaster+event%3Apush+is%3Asuccess\n+[releases]: https://github.com/bjorn3/rustc_codegen_cranelift/releases/tag/dev\n \n ## Usage\n "}, {"sha": "7ddf91ad01faa83ea1902f1cd88122b010b1748c", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -4,9 +4,9 @@ version = 3\n \n [[package]]\n name = \"addr2line\"\n-version = \"0.17.0\"\n+version = \"0.19.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b9ecd88a8c8378ca913a680cd98f0f13ac67383d35993f86c90a70e3f137816b\"\n+checksum = \"a76fd60b23679b7d19bd066031410fb7e458ccc5e958eb5c325888ce4baedc97\"\n dependencies = [\n  \"compiler_builtins\",\n  \"gimli\",\n@@ -50,9 +50,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.89\"\n+version = \"0.1.91\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9fc9c2080d347a2c316518840ac9194644a9993dfa1e9778ef38979a339f5d8b\"\n+checksum = \"571298a3cce7e2afbd3d61abb91a18667d5ab25993ec577a88ee8ac45f00cc3a\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -95,9 +95,9 @@ dependencies = [\n \n [[package]]\n name = \"gimli\"\n-version = \"0.26.2\"\n+version = \"0.27.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d\"\n+checksum = \"ad0a93d233ebf96623465aad4046a8d3aa4da22d4f4beba5388838c8a434bbb4\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n@@ -128,9 +128,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.140\"\n+version = \"0.2.142\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"99227334921fae1a979cf0bfdfcc6b3e5ce376ef57e16fb6fb3ea2ed6095f80c\"\n+checksum = \"6a987beff54b60ffa6d51982e1aa1146bc42f19bd26be28b0586f252fccf5317\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -147,9 +147,9 @@ dependencies = [\n \n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.5.4\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"96590ba8f175222643a85693f33d26e9c8a015f599c216509b1a6894af675d34\"\n+checksum = \"b275950c28b37e794e8c55d88aeb5e139d0ce23fdbbeda68f8d7174abdf9e8fa\"\n dependencies = [\n  \"adler\",\n  \"compiler_builtins\",\n@@ -159,9 +159,9 @@ dependencies = [\n \n [[package]]\n name = \"object\"\n-version = \"0.29.0\"\n+version = \"0.30.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"21158b2c33aa6d4561f1c0a6ea283ca92bc54802a93b263e910746d679a7eb53\"\n+checksum = \"ea86265d3d3dcb6a27fc51bd29a4bf387fae9d2986b823079d4986af253eb439\"\n dependencies = [\n  \"compiler_builtins\",\n  \"memchr\",\n@@ -202,9 +202,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-demangle\"\n-version = \"0.1.21\"\n+version = \"0.1.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7ef03e0a2b150c7a90d01faf6254c9c48a41e95fb2a8c2ac1c6f0d2b9aefc342\"\n+checksum = \"d626bb9dae77e28219937af045c257c28bfd3f69333c512553507f5f9798cb76\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\","}, {"sha": "e4ed9be23b70528ee83174f4ad5059fa83fe88bd", "filename": "compiler/rustc_codegen_cranelift/build_system/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -43,7 +43,7 @@ pub(crate) enum SysrootKind {\n     Llvm,\n }\n \n-pub fn main() {\n+pub(crate) fn main() {\n     if env::var(\"RUST_BACKTRACE\").is_err() {\n         env::set_var(\"RUST_BACKTRACE\", \"1\");\n     }"}, {"sha": "0c25b4aadfa087bd4f826e3d3ba60f5ed9b8f936", "filename": "compiler/rustc_codegen_cranelift/build_system/tests.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -2,7 +2,6 @@ use super::build_sysroot;\n use super::config;\n use super::path::{Dirs, RelPath};\n use super::prepare::GitRepo;\n-use super::rustc_info::get_host_triple;\n use super::utils::{spawn_and_wait, spawn_and_wait_with_input, CargoProject, Compiler};\n use super::SysrootKind;\n use std::env;\n@@ -102,14 +101,14 @@ pub(crate) static RAND_REPO: GitRepo =\n pub(crate) static RAND: CargoProject = CargoProject::new(&RAND_REPO.source_dir(), \"rand\");\n \n pub(crate) static REGEX_REPO: GitRepo =\n-    GitRepo::github(\"rust-lang\", \"regex\", \"a9b2e02352db92ce1f6e5b7ecd41b8bbffbe161a\", \"regex\");\n+    GitRepo::github(\"rust-lang\", \"regex\", \"32fed9429eafba0ae92a64b01796a0c5a75b88c8\", \"regex\");\n \n pub(crate) static REGEX: CargoProject = CargoProject::new(&REGEX_REPO.source_dir(), \"regex\");\n \n pub(crate) static PORTABLE_SIMD_REPO: GitRepo = GitRepo::github(\n     \"rust-lang\",\n     \"portable-simd\",\n-    \"9bd30e77b3a3c699af102ebb3df0f6110f8aa02e\",\n+    \"ad8afa8c81273b3b49acbea38cd3bcf17a34cf2b\",\n     \"portable-simd\",\n );\n \n@@ -186,7 +185,9 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n \n         if runner.is_native {\n             let mut run_cmd = REGEX.test(&runner.target_compiler, &runner.dirs);\n-            run_cmd.args([\"--workspace\", \"--\", \"-q\"]);\n+            // regex-capi and regex-debug don't have any tests. Nor do they contain any code\n+            // that is useful to test with cg_clif. Skip building them to reduce test time.\n+            run_cmd.args([\"-p\", \"regex\", \"-p\", \"regex-syntax\", \"--\", \"-q\"]);\n             spawn_and_wait(run_cmd);\n         } else {\n             eprintln!(\"Cross-Compiling: Not running tests\");\n@@ -228,8 +229,11 @@ pub(crate) fn run_tests(\n             target_triple.clone(),\n         );\n \n-        let runner =\n-            TestRunner::new(dirs.clone(), target_compiler, get_host_triple() == target_triple);\n+        let runner = TestRunner::new(\n+            dirs.clone(),\n+            target_compiler,\n+            bootstrap_host_compiler.triple == target_triple,\n+        );\n \n         BUILD_EXAMPLE_OUT_DIR.ensure_fresh(dirs);\n         runner.run_testsuite(NO_SYSROOT_SUITE);\n@@ -250,8 +254,11 @@ pub(crate) fn run_tests(\n             target_triple.clone(),\n         );\n \n-        let runner =\n-            TestRunner::new(dirs.clone(), target_compiler, get_host_triple() == target_triple);\n+        let runner = TestRunner::new(\n+            dirs.clone(),\n+            target_compiler,\n+            bootstrap_host_compiler.triple == target_triple,\n+        );\n \n         if run_base_sysroot {\n             runner.run_testsuite(BASE_SYSROOT_SUITE);\n@@ -275,7 +282,7 @@ struct TestRunner {\n }\n \n impl TestRunner {\n-    pub fn new(dirs: Dirs, mut target_compiler: Compiler, is_native: bool) -> Self {\n+    fn new(dirs: Dirs, mut target_compiler: Compiler, is_native: bool) -> Self {\n         if let Ok(rustflags) = env::var(\"RUSTFLAGS\") {\n             target_compiler.rustflags.push(' ');\n             target_compiler.rustflags.push_str(&rustflags);\n@@ -297,7 +304,7 @@ impl TestRunner {\n         Self { is_native, jit_supported, dirs, target_compiler }\n     }\n \n-    pub fn run_testsuite(&self, tests: &[TestCase]) {\n+    fn run_testsuite(&self, tests: &[TestCase]) {\n         for TestCase { config, cmd } in tests {\n             let (tag, testname) = config.split_once('.').unwrap();\n             let tag = tag.to_uppercase();\n@@ -382,7 +389,7 @@ impl TestRunner {\n         spawn_and_wait(self.rustc_command(args));\n     }\n \n-    fn run_out_command<'a>(&self, name: &str, args: &[&str]) {\n+    fn run_out_command(&self, name: &str, args: &[&str]) {\n         let mut full_cmd = vec![];\n \n         // Prepend the RUN_WRAPPER's"}, {"sha": "d994e2fbc0ae0be69e0c06676cf630506030d69c", "filename": "compiler/rustc_codegen_cranelift/example/alloc_example.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -18,7 +18,7 @@ extern \"C\" {\n }\n \n #[panic_handler]\n-fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n+fn panic_handler(_: &core::panic::PanicInfo<'_>) -> ! {\n     core::intrinsics::abort();\n }\n "}, {"sha": "f7edfa960a229407174223b8aa70ad84c7282b13", "filename": "compiler/rustc_codegen_cranelift/example/arbitrary_self_types_pointers_and_wrappers.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Farbitrary_self_types_pointers_and_wrappers.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -3,8 +3,8 @@\n #![feature(arbitrary_self_types, unsize, coerce_unsized, dispatch_from_dyn)]\n \n use std::{\n-    ops::{Deref, CoerceUnsized, DispatchFromDyn},\n     marker::Unsize,\n+    ops::{CoerceUnsized, Deref, DispatchFromDyn},\n };\n \n struct Ptr<T: ?Sized>(Box<T>);\n@@ -33,7 +33,6 @@ impl<T: ?Sized> Deref for Wrapper<T> {\n impl<T: CoerceUnsized<U>, U> CoerceUnsized<Wrapper<U>> for Wrapper<T> {}\n impl<T: DispatchFromDyn<U>, U> DispatchFromDyn<Wrapper<U>> for Wrapper<T> {}\n \n-\n trait Trait {\n     // This method isn't object-safe yet. Unsized by-value `self` is object-safe (but not callable\n     // without unsized_locals), but wrappers around `Self` currently are not."}, {"sha": "22fc6ff33e33f0ffb2069c8e21b15769fb284815", "filename": "compiler/rustc_codegen_cranelift/example/dst-field-align.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fdst-field-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fdst-field-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fdst-field-align.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -2,66 +2,65 @@\n #![allow(dead_code)]\n struct Foo<T: ?Sized> {\n     a: u16,\n-    b: T\n+    b: T,\n }\n \n trait Bar {\n     fn get(&self) -> usize;\n }\n \n impl Bar for usize {\n-    fn get(&self) -> usize { *self }\n+    fn get(&self) -> usize {\n+        *self\n+    }\n }\n \n struct Baz<T: ?Sized> {\n-    a: T\n+    a: T,\n }\n \n struct HasDrop<T: ?Sized> {\n     ptr: Box<usize>,\n-    data: T\n+    data: T,\n }\n \n fn main() {\n     // Test that zero-offset works properly\n-    let b : Baz<usize> = Baz { a: 7 };\n+    let b: Baz<usize> = Baz { a: 7 };\n     assert_eq!(b.a.get(), 7);\n-    let b : &Baz<dyn Bar> = &b;\n+    let b: &Baz<dyn Bar> = &b;\n     assert_eq!(b.a.get(), 7);\n \n     // Test that the field is aligned properly\n-    let f : Foo<usize> = Foo { a: 0, b: 11 };\n+    let f: Foo<usize> = Foo { a: 0, b: 11 };\n     assert_eq!(f.b.get(), 11);\n-    let ptr1 : *const u8 = &f.b as *const _ as *const u8;\n+    let ptr1: *const u8 = &f.b as *const _ as *const u8;\n \n-    let f : &Foo<dyn Bar> = &f;\n-    let ptr2 : *const u8 = &f.b as *const _ as *const u8;\n+    let f: &Foo<dyn Bar> = &f;\n+    let ptr2: *const u8 = &f.b as *const _ as *const u8;\n     assert_eq!(f.b.get(), 11);\n \n     // The pointers should be the same\n     assert_eq!(ptr1, ptr2);\n \n     // Test that nested DSTs work properly\n-    let f : Foo<Foo<usize>> = Foo { a: 0, b: Foo { a: 1, b: 17 }};\n+    let f: Foo<Foo<usize>> = Foo { a: 0, b: Foo { a: 1, b: 17 } };\n     assert_eq!(f.b.b.get(), 17);\n-    let f : &Foo<Foo<dyn Bar>> = &f;\n+    let f: &Foo<Foo<dyn Bar>> = &f;\n     assert_eq!(f.b.b.get(), 17);\n \n     // Test that get the pointer via destructuring works\n \n-    let f : Foo<usize> = Foo { a: 0, b: 11 };\n-    let f : &Foo<dyn Bar> = &f;\n+    let f: Foo<usize> = Foo { a: 0, b: 11 };\n+    let f: &Foo<dyn Bar> = &f;\n     let &Foo { a: _, b: ref bar } = f;\n     assert_eq!(bar.get(), 11);\n \n     // Make sure that drop flags don't screw things up\n \n-    let d : HasDrop<Baz<[i32; 4]>> = HasDrop {\n-        ptr: Box::new(0),\n-        data: Baz { a: [1,2,3,4] }\n-    };\n-    assert_eq!([1,2,3,4], d.data.a);\n+    let d: HasDrop<Baz<[i32; 4]>> = HasDrop { ptr: Box::new(0), data: Baz { a: [1, 2, 3, 4] } };\n+    assert_eq!([1, 2, 3, 4], d.data.a);\n \n-    let d : &HasDrop<Baz<[i32]>> = &d;\n-    assert_eq!(&[1,2,3,4], &d.data.a);\n+    let d: &HasDrop<Baz<[i32]>> = &d;\n+    assert_eq!(&[1, 2, 3, 4], &d.data.a);\n }"}, {"sha": "885e55bc764232e17087b5864de9d18d8563562b", "filename": "compiler/rustc_codegen_cranelift/example/example.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fexample.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fexample.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fexample.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -11,11 +11,7 @@ pub fn abc(a: u8) -> u8 {\n }\n \n pub fn bcd(b: bool, a: u8) -> u8 {\n-    if b {\n-        a * 2\n-    } else {\n-        a * 3\n-    }\n+    if b { a * 2 } else { a * 3 }\n }\n \n pub fn call() {"}, {"sha": "166b006004385b225d8488fb08affc72299d2c55", "filename": "compiler/rustc_codegen_cranelift/example/issue-72793.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-72793.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-72793.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-72793.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -2,7 +2,9 @@\n \n #![feature(type_alias_impl_trait)]\n \n-trait T { type Item; }\n+trait T {\n+    type Item;\n+}\n \n type Alias<'a> = impl T<Item = &'a ()>;\n "}, {"sha": "6f39c5edcad209057161c09c5b606f4b395ff1e8", "filename": "compiler/rustc_codegen_cranelift/example/issue-91827-extern-types.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -40,10 +40,7 @@ impl<T, const N: usize> ListImpl<T, N> {\n     }\n }\n \n-pub static A: ListImpl<u128, 3> = ListImpl {\n-    len: 3,\n-    data: [5, 6, 7],\n-};\n+pub static A: ListImpl<u128, 3> = ListImpl { len: 3, data: [5, 6, 7] };\n pub static A_REF: &'static List<u128> = A.as_list();\n pub static A_TAIL_OFFSET: isize = tail_offset(A.as_list());\n "}, {"sha": "ea97e9f060e04a903e6c843f4b38df3f6e71a59d", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -37,13 +37,13 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n pub trait DispatchFromDyn<T> {}\n \n // &T -> &U\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n // &mut T -> &mut U\n-impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut T {}\n // *const T -> *const U\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n // *mut T -> *mut U\n-impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U>> for Box<T> {}\n \n #[lang = \"receiver\"]\n@@ -288,7 +288,6 @@ impl PartialEq for u32 {\n     }\n }\n \n-\n impl PartialEq for u64 {\n     fn eq(&self, other: &u64) -> bool {\n         (*self) == (*other)\n@@ -361,7 +360,7 @@ impl<T: ?Sized> PartialEq for *const T {\n     }\n }\n \n-impl <T: PartialEq> PartialEq for Option<T> {\n+impl<T: PartialEq> PartialEq for Option<T> {\n     fn eq(&self, other: &Self) -> bool {\n         match (self, other) {\n             (Some(lhs), Some(rhs)) => *lhs == *rhs,\n@@ -472,7 +471,20 @@ pub fn panic(_msg: &'static str) -> ! {\n #[track_caller]\n fn panic_bounds_check(index: usize, len: usize) -> ! {\n     unsafe {\n-        libc::printf(\"index out of bounds: the len is %d but the index is %d\\n\\0\" as *const str as *const i8, len, index);\n+        libc::printf(\n+            \"index out of bounds: the len is %d but the index is %d\\n\\0\" as *const str as *const i8,\n+            len,\n+            index,\n+        );\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"panic_cannot_unwind\"]\n+#[track_caller]\n+fn panic_cannot_unwind() -> ! {\n+    unsafe {\n+        libc::puts(\"panic in a function that cannot unwind\\n\\0\" as *const str as *const i8);\n         intrinsics::abort();\n     }\n }\n@@ -599,7 +611,7 @@ pub mod libc {\n     // functions. legacy_stdio_definitions.lib which provides the printf wrapper functions as normal\n     // symbols to link against.\n     #[cfg_attr(unix, link(name = \"c\"))]\n-    #[cfg_attr(target_env=\"msvc\", link(name=\"legacy_stdio_definitions\"))]\n+    #[cfg_attr(target_env = \"msvc\", link(name = \"legacy_stdio_definitions\"))]\n     extern \"C\" {\n         pub fn printf(format: *const i8, ...) -> i32;\n     }\n@@ -638,7 +650,7 @@ impl<T> Index<usize> for [T] {\n     }\n }\n \n-extern {\n+extern \"C\" {\n     type VaListImpl;\n }\n \n@@ -648,23 +660,33 @@ pub struct VaList<'a>(&'a mut VaListImpl);\n \n #[rustc_builtin_macro]\n #[rustc_macro_transparency = \"semitransparent\"]\n-pub macro stringify($($t:tt)*) { /* compiler built-in */ }\n+pub macro stringify($($t:tt)*) {\n+    /* compiler built-in */\n+}\n \n #[rustc_builtin_macro]\n #[rustc_macro_transparency = \"semitransparent\"]\n-pub macro file() { /* compiler built-in */ }\n+pub macro file() {\n+    /* compiler built-in */\n+}\n \n #[rustc_builtin_macro]\n #[rustc_macro_transparency = \"semitransparent\"]\n-pub macro line() { /* compiler built-in */ }\n+pub macro line() {\n+    /* compiler built-in */\n+}\n \n #[rustc_builtin_macro]\n #[rustc_macro_transparency = \"semitransparent\"]\n-pub macro cfg() { /* compiler built-in */ }\n+pub macro cfg() {\n+    /* compiler built-in */\n+}\n \n #[rustc_builtin_macro]\n #[rustc_macro_transparency = \"semitransparent\"]\n-pub macro global_asm() { /* compiler built-in */ }\n+pub macro global_asm() {\n+    /* compiler built-in */\n+}\n \n pub static A_STATIC: u8 = 42;\n \n@@ -676,7 +698,7 @@ struct PanicLocation {\n }\n \n #[no_mangle]\n-#[cfg(not(windows))]\n+#[cfg(not(all(windows, target_env = \"gnu\")))]\n pub fn get_tls() -> u8 {\n     #[thread_local]\n     static A: u8 = 42;"}, {"sha": "5a55aa215bfd7316fa3710487f87dbb8c19687a6", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -319,7 +319,7 @@ fn main() {\n \n     from_decimal_string();\n \n-    #[cfg(not(any(jit, windows)))]\n+    #[cfg(all(not(jit), not(all(windows, target_env = \"gnu\"))))]\n     test_tls();\n \n     #[cfg(all(not(jit), target_arch = \"x86_64\", any(target_os = \"linux\", target_os = \"darwin\")))]\n@@ -524,6 +524,7 @@ pub enum E1 {\n // Computing the discriminant used to be done using the niche type (here `u8`,\n // from the `bool` field of `V1`), overflowing for variants with large enough\n // indices (`V3` and `V4`), causing them to be interpreted as other variants.\n+#[rustfmt::skip]\n pub enum E2<X> {\n     V1 { f: bool },\n "}, {"sha": "f15e48acc41e52cd5809dd25b9f28f22e5158755", "filename": "compiler/rustc_codegen_cranelift/example/mod_bench.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmod_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmod_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmod_bench.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -3,15 +3,15 @@\n \n #[cfg_attr(unix, link(name = \"c\"))]\n #[cfg_attr(target_env = \"msvc\", link(name = \"msvcrt\"))]\n-extern {}\n+extern \"C\" {}\n \n #[panic_handler]\n-fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n+fn panic_handler(_: &core::panic::PanicInfo<'_>) -> ! {\n     core::intrinsics::abort();\n }\n \n-#[lang=\"eh_personality\"]\n-fn eh_personality(){}\n+#[lang = \"eh_personality\"]\n+fn eh_personality() {}\n \n // Required for rustc_codegen_llvm\n #[no_mangle]"}, {"sha": "ab4045d11a6636d007bbfaf7469bd7bedeaf96df", "filename": "compiler/rustc_codegen_cranelift/example/std_example.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,4 +1,4 @@\n-#![feature(core_intrinsics, generators, generator_trait, is_sorted)]\n+#![feature(core_intrinsics, generators, generator_trait, is_sorted, repr_simd)]\n \n #[cfg(target_arch = \"x86_64\")]\n use std::arch::x86_64::*;\n@@ -56,7 +56,10 @@ fn main() {\n \n     assert_eq!(0b0000000000000000000000000010000010000000000000000000000000000000_0000000000100000000000000000000000001000000000000100000000000000u128.leading_zeros(), 26);\n     assert_eq!(0b0000000000000000000000000010000000000000000000000000000000000000_0000000000000000000000000000000000001000000000000000000010000000u128.trailing_zeros(), 7);\n-    assert_eq!(core::intrinsics::saturating_sub(0, -170141183460469231731687303715884105728i128), 170141183460469231731687303715884105727i128);\n+    assert_eq!(\n+        core::intrinsics::saturating_sub(0, -170141183460469231731687303715884105728i128),\n+        170141183460469231731687303715884105727i128\n+    );\n \n     std::hint::black_box(std::hint::black_box(7571400400375753350092698930310845914i128) * 10);\n     assert!(0i128.checked_div(2i128).is_some());\n@@ -113,7 +116,9 @@ fn main() {\n \n     Box::pin(move |mut _task_context| {\n         yield ();\n-    }).as_mut().resume(0);\n+    })\n+    .as_mut()\n+    .resume(0);\n \n     #[derive(Copy, Clone)]\n     enum Nums {\n@@ -148,12 +153,20 @@ fn main() {\n \n         enum Never {}\n     }\n+\n+    foo(I64X2(0, 0));\n }\n \n fn panic(_: u128) {\n     panic!();\n }\n \n+#[repr(simd)]\n+struct I64X2(i64, i64);\n+\n+#[allow(improper_ctypes_definitions)]\n+extern \"C\" fn foo(_a: I64X2) {}\n+\n #[cfg(target_arch = \"x86_64\")]\n #[target_feature(enable = \"sse2\")]\n unsafe fn test_simd() {\n@@ -168,7 +181,10 @@ unsafe fn test_simd() {\n     let (zero0, zero1) = std::mem::transmute::<_, (u64, u64)>(x);\n     assert_eq!((zero0, zero1), (0, 0));\n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(or), [7, 7, 7, 7, 7, 7, 7, 7]);\n-    assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_eq), [0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff]);\n+    assert_eq!(\n+        std::mem::transmute::<_, [u16; 8]>(cmp_eq),\n+        [0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff]\n+    );\n     assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_lt), [0, 0, 0, 0, 0, 0, 0, 0]);\n \n     test_mm_slli_si128();\n@@ -182,6 +198,7 @@ unsafe fn test_simd() {\n     test_mm_extract_epi8();\n     test_mm_insert_epi16();\n \n+    #[rustfmt::skip]\n     let mask1 = _mm_movemask_epi8(dbg!(_mm_setr_epi8(255u8 as i8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)));\n     assert_eq!(mask1, 1);\n }\n@@ -343,7 +360,7 @@ fn test_checked_mul() {\n #[derive(PartialEq)]\n enum LoopState {\n     Continue(()),\n-    Break(())\n+    Break(()),\n }\n \n pub enum Instruction {"}, {"sha": "3c87891666399297f2c16719b5c9f68aa58d4b10", "filename": "compiler/rustc_codegen_cranelift/example/subslice-patterns-const-eval.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fsubslice-patterns-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fexample%2Fsubslice-patterns-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fsubslice-patterns-const-eval.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -19,7 +19,9 @@ macro_rules! n {\n // This macro has an unused variable so that it can be repeated base on the\n // number of times a repeated variable (`$e` in `z`) occurs.\n macro_rules! zed {\n-    ($e:expr) => { Z }\n+    ($e:expr) => {\n+        Z\n+    };\n }\n \n macro_rules! z {\n@@ -32,12 +34,14 @@ macro_rules! z {\n macro_rules! compare_evaluation {\n     ($e:expr, $t:ty $(,)?) => {{\n         const CONST_EVAL: $t = $e;\n-        const fn const_eval() -> $t { $e }\n+        const fn const_eval() -> $t {\n+            $e\n+        }\n         static CONST_EVAL2: $t = const_eval();\n         let runtime_eval = $e;\n         assert_eq!(CONST_EVAL, runtime_eval);\n         assert_eq!(CONST_EVAL2, runtime_eval);\n-    }}\n+    }};\n }\n \n // Repeat `$test`, substituting the given macro variables with the given\n@@ -65,6 +69,7 @@ macro_rules! repeat {\n     }\n }\n \n+#[rustfmt::skip]\n fn main() {\n     repeat! {\n         ($arr $Ty); n, N; z, Z:"}, {"sha": "59ad80c3207dca8924e694191208423c1eee2c49", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2023-03-15\"\n+channel = \"nightly-2023-04-29\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "e2db7d03a9d386c80f16dfbc9e5b3a3b765678d8", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo-clif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -64,7 +64,7 @@ fn main() {\n     };\n \n     #[cfg(unix)]\n-    Command::new(\"cargo\").args(args).exec();\n+    panic!(\"Failed to spawn cargo: {}\", Command::new(\"cargo\").args(args).exec());\n \n     #[cfg(not(unix))]\n     std::process::exit("}, {"sha": "ab496a4a6844eb5ef703443acc450ccf41515999", "filename": "compiler/rustc_codegen_cranelift/scripts/rustc-clif.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -15,22 +15,24 @@ fn main() {\n         env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,\n     );\n \n-    let mut args = std::env::args_os().skip(1).collect::<Vec<_>>();\n+    let passed_args = std::env::args_os().skip(1).collect::<Vec<_>>();\n+    let mut args = vec![];\n     args.push(OsString::from(\"-Cpanic=abort\"));\n     args.push(OsString::from(\"-Zpanic-abort-tests\"));\n     let mut codegen_backend_arg = OsString::from(\"-Zcodegen-backend=\");\n     codegen_backend_arg.push(cg_clif_dylib_path);\n     args.push(codegen_backend_arg);\n-    if !args.contains(&OsString::from(\"--sysroot\")) {\n+    if !passed_args.contains(&OsString::from(\"--sysroot\")) {\n         args.push(OsString::from(\"--sysroot\"));\n         args.push(OsString::from(sysroot.to_str().unwrap()));\n     }\n+    args.extend(passed_args);\n \n     // Ensure that the right toolchain is used\n     env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"TOOLCHAIN_NAME\"));\n \n     #[cfg(unix)]\n-    Command::new(\"rustc\").args(args).exec();\n+    panic!(\"Failed to spawn rustc: {}\", Command::new(\"rustc\").args(args).exec());\n \n     #[cfg(not(unix))]\n     std::process::exit("}, {"sha": "545844446c508cd32216f435e2cda732767a3e80", "filename": "compiler/rustc_codegen_cranelift/scripts/rustdoc-clif.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -15,22 +15,24 @@ fn main() {\n         env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,\n     );\n \n-    let mut args = std::env::args_os().skip(1).collect::<Vec<_>>();\n+    let passed_args = std::env::args_os().skip(1).collect::<Vec<_>>();\n+    let mut args = vec![];\n     args.push(OsString::from(\"-Cpanic=abort\"));\n     args.push(OsString::from(\"-Zpanic-abort-tests\"));\n     let mut codegen_backend_arg = OsString::from(\"-Zcodegen-backend=\");\n     codegen_backend_arg.push(cg_clif_dylib_path);\n     args.push(codegen_backend_arg);\n-    if !args.contains(&OsString::from(\"--sysroot\")) {\n+    if !passed_args.contains(&OsString::from(\"--sysroot\")) {\n         args.push(OsString::from(\"--sysroot\"));\n         args.push(OsString::from(sysroot.to_str().unwrap()));\n     }\n+    args.extend(passed_args);\n \n     // Ensure that the right toolchain is used\n     env::set_var(\"RUSTUP_TOOLCHAIN\", env!(\"TOOLCHAIN_NAME\"));\n \n     #[cfg(unix)]\n-    Command::new(\"rustdoc\").args(args).exec();\n+    panic!(\"Failed to spawn rustdoc: {}\", Command::new(\"rustdoc\").args(args).exec());\n \n     #[cfg(not(unix))]\n     std::process::exit("}, {"sha": "1329d3ea076b480d8d0c45f892c4f1f116aff553", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -10,7 +10,8 @@ pushd rust\n \n command -v rg >/dev/null 2>&1 || cargo install ripgrep\n \n-rm -r tests/ui/{extern/,unsized-locals/,lto/,linkage*} || true\n+# FIXME add needs-asm-support to all tests in tests/ui/asm\n+rm -r tests/ui/{unsized-locals/,lto/,linkage*} || true\n for test in $(rg --files-with-matches \"lto|// needs-asm-support|// needs-unwind\" tests/{codegen-units,ui,incremental}); do\n   rm $test\n done\n@@ -27,13 +28,24 @@ rm tests/ui/parser/unclosed-delimiter-in-dep.rs # submodule contains //~ERROR\n # ================\n \n # requires stack unwinding\n+# FIXME add needs-unwind to these tests\n rm tests/incremental/change_crate_dep_kind.rs\n rm tests/incremental/issue-80691-bad-eval-cache.rs # -Cpanic=abort causes abort instead of exit(101)\n+rm -r tests/run-make/c-unwind-abi-catch-lib-panic\n+rm -r tests/run-make/c-unwind-abi-catch-panic\n+rm -r tests/run-make/debug-assertions\n+rm -r tests/run-make/foreign-double-unwind\n+rm -r tests/run-make/foreign-exceptions\n+rm -r tests/run-make/foreign-rust-exceptions\n+rm -r tests/run-make/libtest-json\n+rm -r tests/run-make/static-unwinding\n \n # requires compiling with -Cpanic=unwind\n rm -r tests/ui/macros/rfc-2011-nicer-assert-messages/\n rm -r tests/run-make/test-benches\n rm tests/ui/test-attrs/test-type.rs\n+rm -r tests/run-make/const_fn_mir\n+rm -r tests/run-make/intrinsic-unreachable\n \n # vendor intrinsics\n rm tests/ui/sse2.rs # cpuid not supported, so sse2 not detected\n@@ -49,6 +61,7 @@ rm tests/incremental/hashes/statics.rs # same\n # variadic arguments\n rm tests/ui/abi/mir/mir_codegen_calls_variadic.rs # requires float varargs\n rm tests/ui/abi/variadic-ffi.rs # requires callee side vararg support\n+rm -r tests/run-make/c-link-to-rust-va-list-fn # requires callee side vararg support\n \n # unsized locals\n rm -r tests/run-pass-valgrind/unsized-locals\n@@ -59,6 +72,19 @@ rm tests/ui/target-feature/missing-plusminus.rs # error not implemented\n rm tests/ui/fn/dyn-fn-alignment.rs # wants a 256 byte alignment\n rm -r tests/run-make/emit-named-files # requires full --emit support\n rm -r tests/run-make/repr128-dwarf # debuginfo test\n+rm -r tests/run-make/split-debuginfo # same\n+rm -r tests/run-make/symbols-include-type-name # --emit=asm not supported\n+rm -r tests/run-make/target-specs # i686 not supported by Cranelift\n+rm -r tests/run-make/mismatching-target-triples # same\n+rm -r tests/run-make/use-extern-for-plugins # same\n+\n+# requires LTO\n+rm -r tests/run-make/cdylib\n+rm -r tests/run-make/issue-14500\n+rm -r tests/run-make/issue-64153\n+rm -r tests/run-make/codegen-options-parsing\n+rm -r tests/run-make/lto-*\n+rm -r tests/run-make/reproducible-build-2\n \n # optimization tests\n # ==================\n@@ -70,7 +96,14 @@ rm -r tests/run-make/fmt-write-bloat/ # tests an optimization\n # backend specific tests\n # ======================\n rm tests/incremental/thinlto/cgu_invalidated_when_import_{added,removed}.rs # requires LLVM\n+rm -r tests/run-make/cross-lang-lto # same\n+rm -r tests/run-make/issue-7349 # same\n+rm -r tests/run-make/sepcomp-inlining # same\n+rm -r tests/run-make/sepcomp-separate # same\n+rm -r tests/run-make/sepcomp-cci-copies # same\n+rm -r tests/run-make/volatile-intrinsics # same\n rm tests/ui/abi/stack-protector.rs # requires stack protector support\n+rm -r tests/run-make/emit-stack-sizes # requires support for -Z emit-stack-sizes\n \n # giving different but possibly correct results\n # =============================================\n@@ -95,13 +128,12 @@ rm tests/ui/proc-macro/no-missing-docs.rs # same\n rm tests/ui/rust-2018/proc-macro-crate-in-paths.rs # same\n rm tests/ui/proc-macro/allowed-signatures.rs # same\n \n+# rustdoc-clif passes extra args, suppressing the help message when no args are passed\n+rm -r tests/run-make/issue-88756-default-output\n+\n # doesn't work due to the way the rustc test suite is invoked.\n # should work when using ./x.py test the way it is intended\n # ============================================================\n-rm -r tests/run-make/emit-shared-files # requires the rustdoc executable in dist/bin/\n-rm -r tests/run-make/unstable-flag-required # same\n-rm -r tests/run-make/rustdoc-* # same\n-rm -r tests/run-make/issue-88756-default-output # same\n rm -r tests/run-make/remap-path-prefix-dwarf # requires llvm-dwarfdump\n rm -r tests/ui/consts/missing_span_in_backtrace.rs # expects sysroot source to be elsewhere\n \n@@ -112,17 +144,41 @@ rm tests/incremental/spike-neg2.rs # same\n \n rm tests/ui/simd/intrinsic/generic-reduction-pass.rs # simd_reduce_add_unordered doesn't accept an accumulator for integer vectors\n \n-rm tests/ui/simd/intrinsic/generic-as.rs # crash when accessing vector type field (#1318)\n rm tests/ui/simd/simd-bitmask.rs # crash\n \n+rm -r tests/run-make/issue-51671 # wrong filename given in case of --emit=obj\n+rm -r tests/run-make/issue-30063 # same\n+rm -r tests/run-make/multiple-emits # same\n+rm -r tests/run-make/output-type-permutations # same\n+rm -r tests/run-make/used # same\n+\n # bugs in the test suite\n # ======================\n rm tests/ui/backtrace.rs # TODO warning\n-rm tests/ui/simple_global_asm.rs # TODO add needs-asm-support\n rm tests/ui/process/nofile-limit.rs # TODO some AArch64 linking issue\n \n rm tests/ui/stdio-is-blocking.rs # really slow with unoptimized libstd\n \n+cp ../dist/bin/rustdoc-clif ../dist/bin/rustdoc # some tests expect bin/rustdoc to exist\n+\n+# prevent $(RUSTDOC) from picking up the sysroot built by x.py. It conflicts with the one used by\n+# rustdoc-clif\n+cat <<EOF | git apply -\n+diff --git a/tests/run-make/tools.mk b/tests/run-make/tools.mk\n+index ea06b620c4c..b969d0009c6 100644\n+--- a/tests/run-make/tools.mk\n++++ b/tests/run-make/tools.mk\n+@@ -9,7 +9,7 @@ RUSTC_ORIGINAL := \\$(RUSTC)\n+ BARE_RUSTC := \\$(HOST_RPATH_ENV) '\\$(RUSTC)'\n+ BARE_RUSTDOC := \\$(HOST_RPATH_ENV) '\\$(RUSTDOC)'\n+ RUSTC := \\$(BARE_RUSTC) --out-dir \\$(TMPDIR) -L \\$(TMPDIR) \\$(RUSTFLAGS)\n+-RUSTDOC := \\$(BARE_RUSTDOC) -L \\$(TARGET_RPATH_DIR)\n++RUSTDOC := \\$(BARE_RUSTDOC)\n+ ifdef RUSTC_LINKER\n+ RUSTC := \\$(RUSTC) -Clinker='\\$(RUSTC_LINKER)'\n+ RUSTDOC := \\$(RUSTDOC) -Clinker='\\$(RUSTC_LINKER)'\n+EOF\n+\n echo \"[TEST] rustc test suite\"\n-RUST_TEST_NOCAPTURE=1 COMPILETEST_FORCE_STAGE0=1 ./x.py test --stage 0 tests/{codegen-units,run-make,run-pass-valgrind,ui,incremental}\n+COMPILETEST_FORCE_STAGE0=1 ./x.py test --stage 0 --test-args=--nocapture tests/{codegen-units,run-make,run-pass-valgrind,ui,incremental}\n popd"}, {"sha": "364503fd3639a159b5e18d918594fc4b10fda3af", "filename": "compiler/rustc_codegen_cranelift/src/abi/comments.rs", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fcomments.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -6,8 +6,6 @@ use std::borrow::Cow;\n use rustc_middle::mir;\n use rustc_target::abi::call::PassMode;\n \n-use cranelift_codegen::entity::EntityRef;\n-\n use crate::prelude::*;\n \n pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n@@ -91,35 +89,7 @@ pub(super) fn add_local_place_comments<'tcx>(\n         largest_niche: _,\n     } = layout.0.0;\n \n-    let (kind, extra) = match *place.inner() {\n-        CPlaceInner::Var(place_local, var) => {\n-            assert_eq!(local, place_local);\n-            (\"ssa\", Cow::Owned(format!(\",var={}\", var.index())))\n-        }\n-        CPlaceInner::VarPair(place_local, var1, var2) => {\n-            assert_eq!(local, place_local);\n-            (\"ssa\", Cow::Owned(format!(\"var=({}, {})\", var1.index(), var2.index())))\n-        }\n-        CPlaceInner::VarLane(_local, _var, _lane) => unreachable!(),\n-        CPlaceInner::Addr(ptr, meta) => {\n-            let meta = if let Some(meta) = meta {\n-                Cow::Owned(format!(\"meta={}\", meta))\n-            } else {\n-                Cow::Borrowed(\"\")\n-            };\n-            match ptr.debug_base_and_offset() {\n-                (crate::pointer::PointerBase::Addr(addr), offset) => {\n-                    (\"reuse\", format!(\"storage={}{}{}\", addr, offset, meta).into())\n-                }\n-                (crate::pointer::PointerBase::Stack(stack_slot), offset) => {\n-                    (\"stack\", format!(\"storage={}{}{}\", stack_slot, offset, meta).into())\n-                }\n-                (crate::pointer::PointerBase::Dangling(align), offset) => {\n-                    (\"zst\", format!(\"align={},offset={}\", align.bytes(), offset).into())\n-                }\n-            }\n-        }\n-    };\n+    let (kind, extra) = place.debug_comment();\n \n     fx.add_global_comment(format!(\n         \"{:<5} {:5} {:30} {:4}b {}, {}{}{}\","}, {"sha": "e533afcfaa946729b8278f788697293b603c685f", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -70,7 +70,7 @@ pub(crate) fn get_function_sig<'tcx>(\n     default_call_conv: CallConv,\n     inst: Instance<'tcx>,\n ) -> Signature {\n-    assert!(!inst.substs.needs_infer());\n+    assert!(!inst.substs.has_infer());\n     clif_sig_from_fn_abi(\n         tcx,\n         default_call_conv,\n@@ -605,9 +605,9 @@ pub(crate) fn codegen_drop<'tcx>(\n                 //                | ...   |\n                 //                \\-------/\n                 //\n-                let (ptr, vtable) = drop_place.to_ptr_maybe_unsized();\n+                let (ptr, vtable) = drop_place.to_ptr_unsized();\n                 let ptr = ptr.get_addr(fx);\n-                let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable.unwrap());\n+                let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable);\n \n                 // FIXME(eddyb) perhaps move some of this logic into\n                 // `Instance::resolve_drop_in_place`?"}, {"sha": "d847e524f8cfa7740488cf3b847ccfadf1309da8", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -84,7 +84,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                     attrs\n                 )],\n                 Abi::Vector { .. } => {\n-                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n+                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout);\n                     smallvec![AbiParam::new(vector_ty)]\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),\n@@ -135,7 +135,7 @@ impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                     (None, vec![AbiParam::new(scalar_to_clif_type(tcx, scalar))])\n                 }\n                 Abi::Vector { .. } => {\n-                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n+                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout);\n                     (None, vec![AbiParam::new(vector_ty)])\n                 }\n                 _ => unreachable!(\"{:?}\", self.layout.abi),"}, {"sha": "14e54d5ee3814f97acb5ed7391d7992b4a70af55", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -9,7 +9,7 @@ use smallvec::{smallvec, SmallVec};\n /// this adds an extra parameter pointing to where the return value needs to be stored.\n pub(super) fn codegen_return_param<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    ssa_analyzed: &rustc_index::vec::IndexVec<Local, crate::analyze::SsaKind>,\n+    ssa_analyzed: &rustc_index::IndexSlice<Local, crate::analyze::SsaKind>,\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n@@ -63,11 +63,11 @@ pub(super) fn codegen_with_call_return_arg<'tcx>(\n     let (ret_temp_place, return_ptr) = match ret_arg_abi.mode {\n         PassMode::Ignore => (None, None),\n         PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n-            if matches!(ret_place.inner(), CPlaceInner::Addr(_, None)) {\n+            if let Some(ret_ptr) = ret_place.try_to_ptr() {\n                 // This is an optimization to prevent unnecessary copies of the return value when\n                 // the return place is already a memory place as opposed to a register.\n                 // This match arm can be safely removed.\n-                (None, Some(ret_place.to_ptr().get_addr(fx)))\n+                (None, Some(ret_ptr.get_addr(fx)))\n             } else {\n                 let place = CPlace::new_stack_slot(fx, ret_arg_abi.layout);\n                 (Some(place), Some(place.to_ptr().get_addr(fx)))"}, {"sha": "359d581c1535ab07bc3024050a1151153c33af68", "filename": "compiler/rustc_codegen_cranelift/src/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -2,7 +2,7 @@\n \n use crate::prelude::*;\n \n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_middle::mir::StatementKind::*;\n use rustc_middle::ty::Ty;\n "}, {"sha": "a259a4f30b27cca87f816fe92f717a2d37648e98", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 18, "deletions": 45, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,7 +1,7 @@\n //! Codegen of a single function\n \n use rustc_ast::InlineAsmOptions;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -28,7 +28,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     module: &mut dyn Module,\n     instance: Instance<'tcx>,\n ) -> CodegenedFunction {\n-    debug_assert!(!instance.substs.needs_infer());\n+    debug_assert!(!instance.substs.has_infer());\n \n     let symbol_name = tcx.symbol_name(instance).name.to_string();\n     let _timer = tcx.prof.generic_activity_with_arg(\"codegen fn\", &*symbol_name);\n@@ -141,16 +141,6 @@ pub(crate) fn compile_fn(\n     context.clear();\n     context.func = codegened_func.func;\n \n-    // If the return block is not reachable, then the SSA builder may have inserted an `iconst.i128`\n-    // instruction, which doesn't have an encoding.\n-    context.compute_cfg();\n-    context.compute_domtree();\n-    context.eliminate_unreachable_code(module.isa()).unwrap();\n-    context.dce(module.isa()).unwrap();\n-    // Some Cranelift optimizations expect the domtree to not yet be computed and as such don't\n-    // invalidate it when it would change.\n-    context.domtree.clear();\n-\n     #[cfg(any())] // This is never true\n     let _clif_guard = {\n         use std::fmt::Write;\n@@ -182,27 +172,6 @@ pub(crate) fn compile_fn(\n     cx.profiler.generic_activity(\"define function\").run(|| {\n         context.want_disasm = cx.should_write_ir;\n         module.define_function(codegened_func.func_id, context).unwrap();\n-\n-        if cx.profiler.enabled() {\n-            let mut recording_args = false;\n-            cx.profiler\n-                .generic_activity_with_arg_recorder(\n-                    \"define function (clif pass timings)\",\n-                    |recorder| {\n-                        let pass_times = cranelift_codegen::timing::take_current();\n-                        // Replace newlines with | as measureme doesn't allow control characters like\n-                        // newlines inside strings.\n-                        recorder.record_arg(format!(\"{}\", pass_times).replace('\\n', \" | \"));\n-                        recording_args = true;\n-                    },\n-                )\n-                .run(|| {\n-                    if recording_args {\n-                        // Wait a tiny bit to ensure chrome's profiler doesn't hide the event\n-                        std::thread::sleep(std::time::Duration::from_nanos(2))\n-                    }\n-                });\n-        }\n     });\n \n     if cx.should_write_ir {\n@@ -216,7 +185,7 @@ pub(crate) fn compile_fn(\n             &clif_comments,\n         );\n \n-        if let Some(disasm) = &context.compiled_code().unwrap().disasm {\n+        if let Some(disasm) = &context.compiled_code().unwrap().vcode {\n             crate::pretty_clif::write_ir_file(\n                 &cx.output_filenames,\n                 &format!(\"{}.vcode\", codegened_func.symbol_name),\n@@ -524,13 +493,14 @@ fn codegen_stmt<'tcx>(\n \n     fx.set_debug_loc(stmt.source_info);\n \n-    #[cfg(any())] // This is never true\n     match &stmt.kind {\n         StatementKind::StorageLive(..) | StatementKind::StorageDead(..) => {} // Those are not very useful\n         _ => {\n             if fx.clif_comments.enabled() {\n                 let inst = fx.bcx.func.layout.last_inst(cur_block).unwrap();\n-                fx.add_comment(inst, format!(\"{:?}\", stmt));\n+                with_no_trimmed_paths!({\n+                    fx.add_comment(inst, format!(\"{:?}\", stmt));\n+                });\n             }\n         }\n     }\n@@ -715,11 +685,11 @@ fn codegen_stmt<'tcx>(\n                 }\n                 Rvalue::Cast(CastKind::Pointer(PointerCast::Unsize), ref operand, _to_ty) => {\n                     let operand = codegen_operand(fx, operand);\n-                    operand.unsize_value(fx, lval);\n+                    crate::unsize::coerce_unsized_into(fx, operand, lval);\n                 }\n                 Rvalue::Cast(CastKind::DynStar, ref operand, _) => {\n                     let operand = codegen_operand(fx, operand);\n-                    operand.coerce_dyn_star(fx, lval);\n+                    crate::unsize::coerce_dyn_star(fx, operand, lval);\n                 }\n                 Rvalue::Cast(CastKind::Transmute, ref operand, _to_ty) => {\n                     let operand = codegen_operand(fx, operand);\n@@ -781,14 +751,20 @@ fn codegen_stmt<'tcx>(\n                     let operand = operand.load_scalar(fx);\n                     lval.write_cvalue(fx, CValue::by_val(operand, box_layout));\n                 }\n-                Rvalue::NullaryOp(null_op, ty) => {\n+                Rvalue::NullaryOp(ref null_op, ty) => {\n                     assert!(lval.layout().ty.is_sized(fx.tcx, ParamEnv::reveal_all()));\n                     let layout = fx.layout_of(fx.monomorphize(ty));\n                     let val = match null_op {\n                         NullOp::SizeOf => layout.size.bytes(),\n                         NullOp::AlignOf => layout.align.abi.bytes(),\n+                        NullOp::OffsetOf(fields) => {\n+                            layout.offset_of_subfield(fx, fields.iter().map(|f| f.index())).bytes()\n+                        }\n                     };\n-                    let val = CValue::const_val(fx, fx.layout_of(fx.tcx.types.usize), val.into());\n+                    let val = CValue::by_val(\n+                        fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(val).unwrap()),\n+                        fx.layout_of(fx.tcx.types.usize),\n+                    );\n                     lval.write_cvalue(fx, val);\n                 }\n                 Rvalue::Aggregate(ref kind, ref operands) => {\n@@ -863,9 +839,7 @@ fn codegen_array_len<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, place: CPlace<'tcx\n             let len = fx.monomorphize(len).eval_target_usize(fx.tcx, ParamEnv::reveal_all()) as i64;\n             fx.bcx.ins().iconst(fx.pointer_type, len)\n         }\n-        ty::Slice(_elem_ty) => {\n-            place.to_ptr_maybe_unsized().1.expect(\"Length metadata for slice place\")\n-        }\n+        ty::Slice(_elem_ty) => place.to_ptr_unsized().1,\n         _ => bug!(\"Rvalue::Len({:?})\", place),\n     }\n }\n@@ -919,8 +893,7 @@ pub(crate) fn codegen_place<'tcx>(\n                     ty::Slice(elem_ty) => {\n                         assert!(from_end, \"slice subslices should be `from_end`\");\n                         let elem_layout = fx.layout_of(*elem_ty);\n-                        let (ptr, len) = cplace.to_ptr_maybe_unsized();\n-                        let len = len.unwrap();\n+                        let (ptr, len) = cplace.to_ptr_unsized();\n                         cplace = CPlace::for_ptr_with_extra(\n                             ptr.offset_i64(fx, elem_layout.size.bytes() as i64 * (from as i64)),\n                             fx.bcx.ins().iadd_imm(len, -(from as i64 + to as i64)),"}, {"sha": "6bf3a866ba46ac37e33a57ae5d42d3b2bd4124ee", "filename": "compiler/rustc_codegen_cranelift/src/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -103,7 +103,7 @@ pub(crate) fn clif_int_or_float_cast(\n                     vec![AbiParam::new(types::I64X2)],\n                     &[from],\n                 )[0];\n-                // FIXME use bitcast instead of store to get from i64x2 to i128\n+                // FIXME(bytecodealliance/wasmtime#6104) use bitcast instead of store to get from i64x2 to i128\n                 let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n                     kind: StackSlotKind::ExplicitSlot,\n                     size: 16,"}, {"sha": "f751d8c179db59c3e60e84a053bc05dc584ad659", "filename": "compiler/rustc_codegen_cranelift/src/codegen_i128.rs", "status": "modified", "additions": 81, "deletions": 66, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -7,7 +7,6 @@ use crate::prelude::*;\n pub(crate) fn maybe_codegen<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n-    checked: bool,\n     lhs: CValue<'tcx>,\n     rhs: CValue<'tcx>,\n ) -> Option<CValue<'tcx>> {\n@@ -22,69 +21,23 @@ pub(crate) fn maybe_codegen<'tcx>(\n     let is_signed = type_sign(lhs.layout().ty);\n \n     match bin_op {\n-        BinOp::BitAnd | BinOp::BitOr | BinOp::BitXor => {\n-            assert!(!checked);\n-            None\n-        }\n-        BinOp::Add | BinOp::Sub if !checked => None,\n-        BinOp::Mul if !checked || is_signed => {\n-            if !checked {\n-                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n-                let ret_val = fx.lib_call(\n-                    \"__multi3\",\n-                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n-                    vec![AbiParam::new(types::I128)],\n-                    &args,\n-                )[0];\n-                Some(CValue::by_val(\n-                    ret_val,\n-                    fx.layout_of(if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 }),\n-                ))\n-            } else {\n-                let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n-                let oflow = CPlace::new_stack_slot(fx, fx.layout_of(fx.tcx.types.i32));\n-                let lhs = lhs.load_scalar(fx);\n-                let rhs = rhs.load_scalar(fx);\n-                let oflow_ptr = oflow.to_ptr().get_addr(fx);\n-                let res = fx.lib_call_unadjusted(\n-                    \"__muloti4\",\n-                    vec![\n-                        AbiParam::new(types::I128),\n-                        AbiParam::new(types::I128),\n-                        AbiParam::new(fx.pointer_type),\n-                    ],\n-                    vec![AbiParam::new(types::I128)],\n-                    &[lhs, rhs, oflow_ptr],\n-                )[0];\n-                let oflow = oflow.to_cvalue(fx).load_scalar(fx);\n-                let oflow = fx.bcx.ins().ireduce(types::I8, oflow);\n-                Some(CValue::by_val_pair(res, oflow, fx.layout_of(out_ty)))\n-            }\n-        }\n-        BinOp::Add | BinOp::Sub | BinOp::Mul => {\n-            assert!(checked);\n-            let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n-            let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n-            let param_types = vec![\n-                AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                AbiParam::new(types::I128),\n-                AbiParam::new(types::I128),\n-            ];\n-            let args = [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)];\n-            let name = match (bin_op, is_signed) {\n-                (BinOp::Add, false) => \"__rust_u128_addo\",\n-                (BinOp::Add, true) => \"__rust_i128_addo\",\n-                (BinOp::Sub, false) => \"__rust_u128_subo\",\n-                (BinOp::Sub, true) => \"__rust_i128_subo\",\n-                (BinOp::Mul, false) => \"__rust_u128_mulo\",\n-                _ => unreachable!(),\n-            };\n-            fx.lib_call(name, param_types, vec![], &args);\n-            Some(out_place.to_cvalue(fx))\n+        BinOp::BitAnd | BinOp::BitOr | BinOp::BitXor => None,\n+        BinOp::Add | BinOp::Sub => None,\n+        BinOp::Mul => {\n+            let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+            let ret_val = fx.lib_call(\n+                \"__multi3\",\n+                vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n+                vec![AbiParam::new(types::I128)],\n+                &args,\n+            )[0];\n+            Some(CValue::by_val(\n+                ret_val,\n+                fx.layout_of(if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 }),\n+            ))\n         }\n         BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n         BinOp::Div | BinOp::Rem => {\n-            assert!(!checked);\n             let name = match (bin_op, is_signed) {\n                 (BinOp::Div, false) => \"__udivti3\",\n                 (BinOp::Div, true) => \"__divti3\",\n@@ -100,7 +53,7 @@ pub(crate) fn maybe_codegen<'tcx>(\n                     vec![AbiParam::new(types::I64X2)],\n                     &args,\n                 )[0];\n-                // FIXME use bitcast instead of store to get from i64x2 to i128\n+                // FIXME(bytecodealliance/wasmtime#6104) use bitcast instead of store to get from i64x2 to i128\n                 let ret_place = CPlace::new_stack_slot(fx, lhs.layout());\n                 ret_place.to_ptr().store(fx, ret, MemFlags::trusted());\n                 Some(ret_place.to_cvalue(fx))\n@@ -115,10 +68,72 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 Some(CValue::by_val(ret_val, lhs.layout()))\n             }\n         }\n-        BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {\n-            assert!(!checked);\n-            None\n-        }\n+        BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => None,\n         BinOp::Shl | BinOp::Shr => None,\n     }\n }\n+\n+pub(crate) fn maybe_codegen_checked<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+) -> Option<CValue<'tcx>> {\n+    if lhs.layout().ty != fx.tcx.types.u128\n+        && lhs.layout().ty != fx.tcx.types.i128\n+        && rhs.layout().ty != fx.tcx.types.u128\n+        && rhs.layout().ty != fx.tcx.types.i128\n+    {\n+        return None;\n+    }\n+\n+    let is_signed = type_sign(lhs.layout().ty);\n+\n+    match bin_op {\n+        BinOp::BitAnd | BinOp::BitOr | BinOp::BitXor => unreachable!(),\n+        BinOp::Mul if is_signed => {\n+            let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n+            let oflow = CPlace::new_stack_slot(fx, fx.layout_of(fx.tcx.types.i32));\n+            let lhs = lhs.load_scalar(fx);\n+            let rhs = rhs.load_scalar(fx);\n+            let oflow_ptr = oflow.to_ptr().get_addr(fx);\n+            let res = fx.lib_call_unadjusted(\n+                \"__muloti4\",\n+                vec![\n+                    AbiParam::new(types::I128),\n+                    AbiParam::new(types::I128),\n+                    AbiParam::new(fx.pointer_type),\n+                ],\n+                vec![AbiParam::new(types::I128)],\n+                &[lhs, rhs, oflow_ptr],\n+            )[0];\n+            let oflow = oflow.to_cvalue(fx).load_scalar(fx);\n+            let oflow = fx.bcx.ins().ireduce(types::I8, oflow);\n+            Some(CValue::by_val_pair(res, oflow, fx.layout_of(out_ty)))\n+        }\n+        BinOp::Add | BinOp::Sub | BinOp::Mul => {\n+            let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n+            let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n+            let param_types = vec![\n+                AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n+                AbiParam::new(types::I128),\n+                AbiParam::new(types::I128),\n+            ];\n+            let args = [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+            let name = match (bin_op, is_signed) {\n+                (BinOp::Add, false) => \"__rust_u128_addo\",\n+                (BinOp::Add, true) => \"__rust_i128_addo\",\n+                (BinOp::Sub, false) => \"__rust_u128_subo\",\n+                (BinOp::Sub, true) => \"__rust_i128_subo\",\n+                (BinOp::Mul, false) => \"__rust_u128_mulo\",\n+                _ => unreachable!(),\n+            };\n+            fx.lib_call(name, param_types, vec![], &args);\n+            Some(out_place.to_cvalue(fx))\n+        }\n+        BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n+        BinOp::Div | BinOp::Rem => unreachable!(),\n+        BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => unreachable!(),\n+        BinOp::Shl | BinOp::Shr => unreachable!(),\n+    }\n+}"}, {"sha": "30f4cf4473c6bd283841228237d68c47f957e81a", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -2,7 +2,7 @@ use cranelift_codegen::isa::TargetFrontendConfig;\n use gimli::write::FileId;\n \n use rustc_data_structures::sync::Lrc;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_middle::ty::layout::{\n     FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOfHelpers,\n };\n@@ -72,19 +72,6 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n                 pointer_ty(tcx)\n             }\n         }\n-        ty::Adt(adt_def, _) if adt_def.repr().simd() => {\n-            let (element, count) = match &tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().abi\n-            {\n-                Abi::Vector { element, count } => (*element, *count),\n-                _ => unreachable!(),\n-            };\n-\n-            match scalar_to_clif_type(tcx, element).by(u32::try_from(count).unwrap()) {\n-                // Cranelift currently only implements icmp for 128bit vectors.\n-                Some(vector_ty) if vector_ty.bits() == 128 => vector_ty,\n-                _ => return None,\n-            }\n-        }\n         ty::Param(_) => bug!(\"ty param {:?}\", ty),\n         _ => return None,\n     })\n@@ -96,12 +83,7 @@ fn clif_pair_type_from_ty<'tcx>(\n ) -> Option<(types::Type, types::Type)> {\n     Some(match ty.kind() {\n         ty::Tuple(types) if types.len() == 2 => {\n-            let a = clif_type_from_ty(tcx, types[0])?;\n-            let b = clif_type_from_ty(tcx, types[1])?;\n-            if a.is_vector() || b.is_vector() {\n-                return None;\n-            }\n-            (a, b)\n+            (clif_type_from_ty(tcx, types[0])?, clif_type_from_ty(tcx, types[1])?)\n         }\n         ty::RawPtr(TypeAndMut { ty: pointee_ty, mutbl: _ }) | ty::Ref(_, pointee_ty, _) => {\n             if has_ptr_meta(tcx, *pointee_ty) {\n@@ -431,7 +413,11 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n \n     // Note: must be kept in sync with get_caller_location from cg_ssa\n     pub(crate) fn get_caller_location(&mut self, mut source_info: mir::SourceInfo) -> CValue<'tcx> {\n-        let span_to_caller_location = |fx: &mut FunctionCx<'_, '_, 'tcx>, span: Span| {\n+        let span_to_caller_location = |fx: &mut FunctionCx<'_, '_, 'tcx>, mut span: Span| {\n+            // Remove `Inlined` marks as they pollute `expansion_cause`.\n+            while span.is_inlined() {\n+                span.remove_mark();\n+            }\n             let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n             let caller = fx.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n             let const_loc = fx.tcx.const_caller_location(("}, {"sha": "54df04f8c2c4a7462da0b0761f6bf2640e440f07", "filename": "compiler/rustc_codegen_cranelift/src/concurrency_limiter.rs", "status": "modified", "additions": 55, "deletions": 12, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -25,8 +25,18 @@ impl ConcurrencyLimiter {\n             .clone()\n             .into_helper_thread(move |token| {\n                 let mut state = state_helper.lock().unwrap();\n-                state.add_new_token(token.unwrap());\n-                available_token_condvar_helper.notify_one();\n+                match token {\n+                    Ok(token) => {\n+                        state.add_new_token(token);\n+                        available_token_condvar_helper.notify_one();\n+                    }\n+                    Err(err) => {\n+                        state.poison(format!(\"failed to acquire jobserver token: {}\", err));\n+                        // Notify all threads waiting for a token to give them a chance to\n+                        // gracefully exit.\n+                        available_token_condvar_helper.notify_all();\n+                    }\n+                }\n             })\n             .unwrap();\n         ConcurrencyLimiter {\n@@ -37,16 +47,31 @@ impl ConcurrencyLimiter {\n         }\n     }\n \n-    pub(super) fn acquire(&mut self) -> ConcurrencyLimiterToken {\n+    pub(super) fn acquire(&mut self, handler: &rustc_errors::Handler) -> ConcurrencyLimiterToken {\n         let mut state = self.state.lock().unwrap();\n         loop {\n             state.assert_invariants();\n \n-            if state.try_start_job() {\n-                return ConcurrencyLimiterToken {\n-                    state: self.state.clone(),\n-                    available_token_condvar: self.available_token_condvar.clone(),\n-                };\n+            match state.try_start_job() {\n+                Ok(true) => {\n+                    return ConcurrencyLimiterToken {\n+                        state: self.state.clone(),\n+                        available_token_condvar: self.available_token_condvar.clone(),\n+                    };\n+                }\n+                Ok(false) => {}\n+                Err(err) => {\n+                    // An error happened when acquiring the token. Raise it as fatal error.\n+                    // Make sure to drop the mutex guard first to prevent poisoning the mutex.\n+                    drop(state);\n+                    if let Some(err) = err {\n+                        handler.fatal(&err).raise();\n+                    } else {\n+                        // The error was already emitted, but compilation continued. Raise a silent\n+                        // fatal error.\n+                        rustc_errors::FatalError.raise();\n+                    }\n+                }\n             }\n \n             self.helper_thread.as_mut().unwrap().request_token();\n@@ -100,13 +125,22 @@ mod state {\n         pending_jobs: usize,\n         active_jobs: usize,\n \n+        poisoned: bool,\n+        stored_error: Option<String>,\n+\n         // None is used to represent the implicit token, Some to represent explicit tokens\n         tokens: Vec<Option<Acquired>>,\n     }\n \n     impl ConcurrencyLimiterState {\n         pub(super) fn new(pending_jobs: usize) -> Self {\n-            ConcurrencyLimiterState { pending_jobs, active_jobs: 0, tokens: vec![None] }\n+            ConcurrencyLimiterState {\n+                pending_jobs,\n+                active_jobs: 0,\n+                poisoned: false,\n+                stored_error: None,\n+                tokens: vec![None],\n+            }\n         }\n \n         pub(super) fn assert_invariants(&self) {\n@@ -127,14 +161,18 @@ mod state {\n             self.drop_excess_capacity();\n         }\n \n-        pub(super) fn try_start_job(&mut self) -> bool {\n+        pub(super) fn try_start_job(&mut self) -> Result<bool, Option<String>> {\n+            if self.poisoned {\n+                return Err(self.stored_error.take());\n+            }\n+\n             if self.active_jobs < self.tokens.len() {\n                 // Using existing token\n                 self.job_started();\n-                return true;\n+                return Ok(true);\n             }\n \n-            false\n+            Ok(false)\n         }\n \n         pub(super) fn job_started(&mut self) {\n@@ -161,6 +199,11 @@ mod state {\n             self.assert_invariants();\n         }\n \n+        pub(super) fn poison(&mut self, error: String) {\n+            self.poisoned = true;\n+            self.stored_error = Some(error);\n+        }\n+\n         fn drop_excess_capacity(&mut self) {\n             self.assert_invariants();\n "}, {"sha": "bf5d29c16f664ad5ec48ca58354c0f83ab361e00", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -91,7 +91,7 @@ pub(crate) fn eval_mir_constant<'tcx>(\n             ),\n         },\n         ConstantKind::Unevaluated(mir::UnevaluatedConst { def, .. }, _)\n-            if fx.tcx.is_static(def.did) =>\n+            if fx.tcx.is_static(def) =>\n         {\n             span_bug!(constant.span, \"MIR constant refers to static\");\n         }\n@@ -159,6 +159,8 @@ pub(crate) fn codegen_const_value<'tcx>(\n                         _ => unreachable!(),\n                     };\n \n+                    // FIXME avoid this extra copy to the stack and directly write to the final\n+                    // destination\n                     let place = CPlace::new_stack_slot(fx, layout);\n                     place.to_ptr().store(fx, val, MemFlags::trusted());\n                     place.to_cvalue(fx)"}, {"sha": "670384663e83faba8801495a6bf76d49fe8af9d1", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -103,7 +103,6 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n         }\n     };\n \n-    let cast_to_size = dest_layout.layout.size();\n     let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n \n     // Read the tag/niche-encoded discriminant from memory.\n@@ -122,21 +121,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             dest.write_cvalue(fx, res);\n         }\n         TagEncoding::Niche { untagged_variant, ref niche_variants, niche_start } => {\n-            let tag_size = tag_scalar.size(fx);\n-            let max_unsigned = tag_size.unsigned_int_max();\n-            let max_signed = tag_size.signed_int_max() as u128;\n-            let min_signed = max_signed + 1;\n             let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n-            let niche_end = niche_start.wrapping_add(relative_max as u128) & max_unsigned;\n-            let range = tag_scalar.valid_range(fx);\n-\n-            let sle = |lhs: u128, rhs: u128| -> bool {\n-                // Signed and unsigned comparisons give the same results,\n-                // except that in signed comparisons an integer with the\n-                // sign bit set is less than one with the sign bit clear.\n-                // Toggle the sign bit to do a signed comparison.\n-                (lhs ^ min_signed) <= (rhs ^ min_signed)\n-            };\n \n             // We have a subrange `niche_start..=niche_end` inside `range`.\n             // If the value of the tag is inside this subrange, it's a\n@@ -153,45 +138,6 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n             // }\n             // However, we will likely be able to emit simpler code.\n \n-            // Find the least and greatest values in `range`, considered\n-            // both as signed and unsigned.\n-            let (low_unsigned, high_unsigned) =\n-                if range.start <= range.end { (range.start, range.end) } else { (0, max_unsigned) };\n-            let (low_signed, high_signed) = if sle(range.start, range.end) {\n-                (range.start, range.end)\n-            } else {\n-                (min_signed, max_signed)\n-            };\n-\n-            let niches_ule = niche_start <= niche_end;\n-            let niches_sle = sle(niche_start, niche_end);\n-            let cast_smaller = cast_to_size <= tag_size;\n-\n-            // In the algorithm above, we can change\n-            // cast(relative_tag) + niche_variants.start()\n-            // into\n-            // cast(tag + (niche_variants.start() - niche_start))\n-            // if either the casted type is no larger than the original\n-            // type, or if the niche values are contiguous (in either the\n-            // signed or unsigned sense).\n-            let can_incr = cast_smaller || niches_ule || niches_sle;\n-\n-            let data_for_boundary_niche = || -> Option<(IntCC, u128)> {\n-                if !can_incr {\n-                    None\n-                } else if niche_start == low_unsigned {\n-                    Some((IntCC::UnsignedLessThanOrEqual, niche_end))\n-                } else if niche_end == high_unsigned {\n-                    Some((IntCC::UnsignedGreaterThanOrEqual, niche_start))\n-                } else if niche_start == low_signed {\n-                    Some((IntCC::SignedLessThanOrEqual, niche_end))\n-                } else if niche_end == high_signed {\n-                    Some((IntCC::SignedGreaterThanOrEqual, niche_start))\n-                } else {\n-                    None\n-                }\n-            };\n-\n             let (is_niche, tagged_discr, delta) = if relative_max == 0 {\n                 // Best case scenario: only one tagged variant. This will\n                 // likely become just a comparison and a jump.\n@@ -206,41 +152,6 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n                 let tagged_discr =\n                     fx.bcx.ins().iconst(cast_to, niche_variants.start().as_u32() as i64);\n                 (is_niche, tagged_discr, 0)\n-            } else if let Some((predicate, constant)) = data_for_boundary_niche() {\n-                // The niche values are either the lowest or the highest in\n-                // `range`. We can avoid the first subtraction in the\n-                // algorithm.\n-                // The algorithm is now this:\n-                // is_niche = tag <= niche_end\n-                // discr = if is_niche {\n-                //     cast(tag + (niche_variants.start() - niche_start))\n-                // } else {\n-                //     untagged_variant\n-                // }\n-                // (the first line may instead be tag >= niche_start,\n-                // and may be a signed or unsigned comparison)\n-                // The arithmetic must be done before the cast, so we can\n-                // have the correct wrapping behavior. See issue #104519 for\n-                // the consequences of getting this wrong.\n-                let is_niche = codegen_icmp_imm(fx, predicate, tag, constant as i128);\n-                let delta = (niche_variants.start().as_u32() as u128).wrapping_sub(niche_start);\n-                let incr_tag = if delta == 0 {\n-                    tag\n-                } else {\n-                    let delta = match fx.bcx.func.dfg.value_type(tag) {\n-                        types::I128 => {\n-                            let lsb = fx.bcx.ins().iconst(types::I64, delta as u64 as i64);\n-                            let msb = fx.bcx.ins().iconst(types::I64, (delta >> 64) as u64 as i64);\n-                            fx.bcx.ins().iconcat(lsb, msb)\n-                        }\n-                        ty => fx.bcx.ins().iconst(ty, delta as i64),\n-                    };\n-                    fx.bcx.ins().iadd(tag, delta)\n-                };\n-\n-                let cast_tag = clif_intcast(fx, incr_tag, cast_to, !niches_ule);\n-\n-                (is_niche, cast_tag, 0)\n             } else {\n                 // The special cases don't apply, so we'll have to go with\n                 // the general algorithm."}, {"sha": "0e6c6ad95aa1ada40c59f4dc5df66c8e6a71b1bb", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -324,6 +324,10 @@ fn module_codegen(\n     OngoingModuleCodegen::Async(std::thread::spawn(move || {\n         cx.profiler.clone().verbose_generic_activity_with_arg(\"compile functions\", &*cgu_name).run(\n             || {\n+                cranelift_codegen::timing::set_thread_profiler(Box::new(super::MeasuremeProfiler(\n+                    cx.profiler.clone(),\n+                )));\n+\n                 let mut cached_context = Context::new();\n                 for codegened_func in codegened_functions {\n                     crate::base::compile_fn(\n@@ -407,7 +411,7 @@ pub(crate) fn run_aot(\n                                     backend_config.clone(),\n                                     global_asm_config.clone(),\n                                     cgu.name(),\n-                                    concurrency_limiter.acquire(),\n+                                    concurrency_limiter.acquire(tcx.sess.diagnostic()),\n                                 ),\n                                 module_codegen,\n                                 Some(rustc_middle::dep_graph::hash_result),"}, {"sha": "3118105a4e2d7a26b7abff8ff25b2b2529d4e134", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -224,6 +224,10 @@ pub(crate) fn codegen_and_compile_fn<'tcx>(\n     module: &mut dyn Module,\n     instance: Instance<'tcx>,\n ) {\n+    cranelift_codegen::timing::set_thread_profiler(Box::new(super::MeasuremeProfiler(\n+        cx.profiler.clone(),\n+    )));\n+\n     tcx.prof.generic_activity(\"codegen and compile fn\").run(|| {\n         let _inst_guard =\n             crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, tcx.symbol_name(instance).name));"}, {"sha": "5c52c9c18adfde49e1c60b56f909146bbce98732", "filename": "compiler/rustc_codegen_cranelift/src/driver/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -4,6 +4,7 @@\n //! [`codegen_fn`]: crate::base::codegen_fn\n //! [`codegen_static`]: crate::constant::codegen_static\n \n+use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_middle::mir::mono::{Linkage as RLinkage, MonoItem, Visibility};\n \n use crate::prelude::*;\n@@ -39,3 +40,31 @@ fn predefine_mono_items<'tcx>(\n         }\n     });\n }\n+\n+struct MeasuremeProfiler(SelfProfilerRef);\n+\n+struct TimingGuard {\n+    profiler: std::mem::ManuallyDrop<SelfProfilerRef>,\n+    inner: Option<rustc_data_structures::profiling::TimingGuard<'static>>,\n+}\n+\n+impl Drop for TimingGuard {\n+    fn drop(&mut self) {\n+        self.inner.take();\n+        unsafe {\n+            std::mem::ManuallyDrop::drop(&mut self.profiler);\n+        }\n+    }\n+}\n+\n+impl cranelift_codegen::timing::Profiler for MeasuremeProfiler {\n+    fn start_pass(&self, pass: cranelift_codegen::timing::Pass) -> Box<dyn std::any::Any> {\n+        let mut timing_guard =\n+            TimingGuard { profiler: std::mem::ManuallyDrop::new(self.0.clone()), inner: None };\n+        timing_guard.inner = Some(\n+            unsafe { &*(&*timing_guard.profiler as &SelfProfilerRef as *const SelfProfilerRef) }\n+                .generic_activity(pass.description()),\n+        );\n+        Box::new(timing_guard)\n+    }\n+}"}, {"sha": "63a1f6959ddae05f5096330ee071680b61bc94b5", "filename": "compiler/rustc_codegen_cranelift/src/global_asm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -104,7 +104,6 @@ pub(crate) fn compile_global_asm(\n             return Ok(None);\n         }\n \n-        // FIXME fix linker error on macOS\n         if cfg!(not(feature = \"inline_asm\")) {\n             return Err(\n                 \"asm! and global_asm! support is disabled while compiling rustc_codegen_cranelift\""}, {"sha": "539f8c103dbd7b59f09932315692ecebfa32d6f7", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -51,17 +51,13 @@ fn report_atomic_type_validation_error<'tcx>(\n     fx.bcx.ins().trap(TrapCode::UnreachableCodeReached);\n }\n \n-pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> Option<Type> {\n+pub(crate) fn clif_vector_type<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> Type {\n     let (element, count) = match layout.abi {\n         Abi::Vector { element, count } => (element, count),\n         _ => unreachable!(),\n     };\n \n-    match scalar_to_clif_type(tcx, element).by(u32::try_from(count).unwrap()) {\n-        // Cranelift currently only implements icmp for 128bit vectors.\n-        Some(vector_ty) if vector_ty.bits() == 128 => Some(vector_ty),\n-        _ => None,\n-    }\n+    scalar_to_clif_type(tcx, element).by(u32::try_from(count).unwrap()).unwrap()\n }\n \n fn simd_for_each_lane<'tcx>(\n@@ -534,7 +530,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n \n         // The only difference between offset and arith_offset is regarding UB. Because Cranelift\n         // doesn't have UB both are codegen'ed the same way\n-        sym::offset | sym::arith_offset => {\n+        sym::arith_offset => {\n             intrinsic_args!(fx, args => (base, offset); intrinsic);\n             let offset = offset.load_scalar(fx);\n \n@@ -1107,8 +1103,8 @@ fn codegen_regular_intrinsic_call<'tcx>(\n \n             fx.bcx.ins().call_indirect(f_sig, f, &[data]);\n \n-            let layout = ret.layout();\n-            let ret_val = CValue::const_val(fx, layout, ty::ScalarInt::null(layout.size));\n+            let layout = fx.layout_of(fx.tcx.types.i32);\n+            let ret_val = CValue::by_val(fx.bcx.ins().iconst(types::I32, 0), layout);\n             ret.write_cvalue(fx, ret_val);\n         }\n "}, {"sha": "264b578c168b2fb3148fd69b1cd95da59236037f", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -253,7 +253,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             }\n \n             ret.write_cvalue(fx, base);\n-            let ret_lane = ret.place_field(fx, FieldIdx::new(idx.try_into().unwrap()));\n+            let ret_lane = ret.place_lane(fx, idx.try_into().unwrap());\n             ret_lane.write_cvalue(fx, val);\n         }\n "}, {"sha": "f0b399ae2808d2792d173f29673b753ac0d60009", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -90,7 +90,7 @@ mod prelude {\n \n     pub(crate) use rustc_data_structures::fx::FxHashMap;\n \n-    pub(crate) use rustc_index::vec::Idx;\n+    pub(crate) use rustc_index::Idx;\n \n     pub(crate) use cranelift_codegen::ir::condcodes::{FloatCC, IntCC};\n     pub(crate) use cranelift_codegen::ir::function::Function;\n@@ -110,7 +110,7 @@ mod prelude {\n     pub(crate) use crate::common::*;\n     pub(crate) use crate::debuginfo::{DebugContext, UnwindContext};\n     pub(crate) use crate::pointer::Pointer;\n-    pub(crate) use crate::value_and_place::{CPlace, CPlaceInner, CValue};\n+    pub(crate) use crate::value_and_place::{CPlace, CValue};\n }\n \n struct PrintOnPanic<F: Fn() -> String>(F);"}, {"sha": "ba53e01c7a2123919dc3d30a4c14f81d220c3486", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -118,7 +118,7 @@ pub(crate) fn codegen_int_binop<'tcx>(\n         );\n     }\n \n-    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, false, in_lhs, in_rhs) {\n+    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, in_lhs, in_rhs) {\n         return res;\n     }\n \n@@ -173,7 +173,7 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n     let lhs = in_lhs.load_scalar(fx);\n     let rhs = in_rhs.load_scalar(fx);\n \n-    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, true, in_lhs, in_rhs) {\n+    if let Some(res) = crate::codegen_i128::maybe_codegen_checked(fx, bin_op, in_lhs, in_rhs) {\n         return res;\n     }\n "}, {"sha": "27e21183c55679f29f5380a601dcb5a0a96eade6", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -7,48 +7,51 @@\n //! test compile\n //! target x86_64\n //!\n-//! function u0:0(i64, i64, i64) system_v {\n-//! ; symbol _ZN119_$LT$example..IsNotEmpty$u20$as$u20$mini_core..FnOnce$LT$$LP$$RF$$u27$a$u20$$RF$$u27$b$u20$$u5b$u16$u5d$$C$$RP$$GT$$GT$9call_once17he85059d5e6a760a0E\n-//! ; instance Instance { def: Item(DefId(0/0:29 ~ example[8787]::{{impl}}[0]::call_once[0])), substs: [ReErased, ReErased] }\n-//! ; sig ([IsNotEmpty, (&&[u16],)]; c_variadic: false)->(u8, u8)\n+//! function u0:22(i64) -> i8, i8 system_v {\n+//! ; symbol _ZN97_$LT$example..IsNotEmpty$u20$as$u20$mini_core..FnOnce$LT$$LP$$RF$$RF$$u5b$u16$u5d$$C$$RP$$GT$$GT$9call_once17hd517c453d67c0915E\n+//! ; instance Instance { def: Item(WithOptConstParam { did: DefId(0:42 ~ example[4e51]::{impl#0}::call_once), const_param_did: None }), substs: [ReErased, ReErased] }\n+//! ; abi FnAbi { args: [ArgAbi { layout: TyAndLayout { ty: IsNotEmpty, layout: Layout { size: Size(0 bytes), align: AbiAndPrefAlign { abi: Align(1 bytes), pref: Align(8 bytes) }, abi: Aggregate { sized: true }, fields: Arbitrary { offsets: [], memory_index: [] }, largest_niche: None, variants: Single { index: 0 } } }, mode: Ignore }, ArgAbi { layout: TyAndLayout { ty: &&[u16], layout: Layout { size: Size(8 bytes), align: AbiAndPrefAlign { abi: Align(8 bytes), pref: Align(8 bytes) }, abi: Scalar(Initialized { value: Pointer(AddressSpace(0)), valid_range: 1..=18446744073709551615 }), fields: Primitive, largest_niche: Some(Niche { offset: Size(0 bytes), value: Pointer(AddressSpace(0)), valid_range: 1..=18446744073709551615 }), variants: Single { index: 0 } } }, mode: Direct(ArgAttributes { regular: NonNull | NoUndef, arg_ext: None, pointee_size: Size(0 bytes), pointee_align: Some(Align(8 bytes)) }) }], ret: ArgAbi { layout: TyAndLayout { ty: (u8, u8), layout: Layout { size: Size(2 bytes), align: AbiAndPrefAlign { abi: Align(1 bytes), pref: Align(8 bytes) }, abi: ScalarPair(Initialized { value: Int(I8, false), valid_range: 0..=255 }, Initialized { value: Int(I8, false), valid_range: 0..=255 }), fields: Arbitrary { offsets: [Size(0 bytes), Size(1 bytes)], memory_index: [0, 1] }, largest_niche: None, variants: Single { index: 0 } } }, mode: Pair(ArgAttributes { regular: NoUndef, arg_ext: None, pointee_size: Size(0 bytes), pointee_align: None }, ArgAttributes { regular: NoUndef, arg_ext: None, pointee_size: Size(0 bytes), pointee_align: None }) }, c_variadic: false, fixed_count: 1, conv: Rust, can_unwind: false }\n //!\n-//! ; ssa {_2: NOT_SSA, _4: NOT_SSA, _0: NOT_SSA, _3: (empty), _1: NOT_SSA}\n-//! ; msg   loc.idx    param    pass mode            ssa flags  ty\n-//! ; ret    _0      = v0       ByRef                NOT_SSA    (u8, u8)\n-//! ; arg    _1      = v1       ByRef                NOT_SSA    IsNotEmpty\n-//! ; arg    _2.0    = v2       ByVal(types::I64)    NOT_SSA    &&[u16]\n+//! ; kind  loc.idx   param    pass mode                            ty\n+//! ; ssa   _0    (u8, u8)                          2b 1, 8              var=(0, 1)\n+//! ; ret   _0      -          Pair(ArgAttributes { regular: NoUndef, arg_ext: None, pointee_size: Size(0 bytes), pointee_align: None }, ArgAttributes { regular: NoUndef, arg_ext: None, pointee_size: Size(0 bytes), pointee_align: None }) (u8, u8)\n+//! ; arg   _1      -          Ignore                               IsNotEmpty\n+//! ; arg   _2.0    = v0       Direct(ArgAttributes { regular: NonNull | NoUndef, arg_ext: None, pointee_size: Size(0 bytes), pointee_align: Some(Align(8 bytes)) }) &&[u16]\n //!\n-//!     ss0 = explicit_slot 0 ; _1: IsNotEmpty size=0 align=1,8\n-//!     ss1 = explicit_slot 8 ; _2: (&&[u16],) size=8 align=8,8\n-//!     ss2 = explicit_slot 8 ; _4: (&&[u16],) size=8 align=8,8\n-//!     sig0 = (i64, i64, i64) system_v\n-//!     sig1 = (i64, i64, i64) system_v\n-//!     fn0 = colocated u0:6 sig1 ; Instance { def: Item(DefId(0/0:31 ~ example[8787]::{{impl}}[1]::call_mut[0])), substs: [ReErased, ReErased] }\n+//! ; kind  local ty                              size align (abi,pref)\n+//! ; zst   _1    IsNotEmpty                        0b 1, 8              align=8,offset=\n+//! ; stack _2    (&&[u16],)                        8b 8, 8              storage=ss0\n+//! ; ssa   _3    &mut IsNotEmpty                   8b 8, 8              var=2\n //!\n-//! block0(v0: i64, v1: i64, v2: i64):\n-//!     v3 = stack_addr.i64 ss0\n-//!     v4 = stack_addr.i64 ss1\n-//!     store v2, v4\n-//!     v5 = stack_addr.i64 ss2\n+//!     ss0 = explicit_slot 16\n+//!     sig0 = (i64, i64) -> i8, i8 system_v\n+//!     fn0 = colocated u0:23 sig0 ; Instance { def: Item(WithOptConstParam { did: DefId(0:46 ~ example[4e51]::{impl#1}::call_mut), const_param_did: None }), substs: [ReErased, ReErased] }\n+//!\n+//! block0(v0: i64):\n+//!     nop\n+//! ; write_cvalue: Addr(Pointer { base: Stack(ss0), offset: Offset32(0) }, None): &&[u16] <- ByVal(v0): &&[u16]\n+//!     stack_store v0, ss0\n //!     jump block1\n //!\n //! block1:\n //!     nop\n //! ; _3 = &mut _1\n-//! ; _4 = _2\n-//!     v6 = load.i64 v4\n-//!     store v6, v5\n+//!     v1 = iconst.i64 8\n+//! ; write_cvalue: Var(_3, var2): &mut IsNotEmpty <- ByVal(v1): &mut IsNotEmpty\n //! ;\n-//! ; _0 = const mini_core::FnMut::call_mut(move _3, move _4)\n-//!     v7 = load.i64 v5\n-//!     call fn0(v0, v3, v7)\n+//! ; _0 = <IsNotEmpty as mini_core::FnMut<(&&[u16],)>>::call_mut(move _3, _2)\n+//!     v2 = stack_load.i64 ss0\n+//!     v3, v4 = call fn0(v1, v2)  ; v1 = 8\n+//!     v5 -> v3\n+//!     v6 -> v4\n+//! ; write_cvalue: VarPair(_0, var0, var1): (u8, u8) <- ByValPair(v3, v4): (u8, u8)\n //!     jump block2\n //!\n //! block2:\n //!     nop\n //! ;\n //! ; return\n-//!     return\n+//!     return v5, v6\n //! }\n //! ```\n "}, {"sha": "c964d1ac5e0dd4608de6fcd852b09fa8be73d38f", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 113, "deletions": 217, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -2,8 +2,8 @@\n \n use crate::prelude::*;\n \n+use cranelift_codegen::entity::EntityRef;\n use cranelift_codegen::ir::immediates::Offset32;\n-use cranelift_codegen::ir::{InstructionData, Opcode};\n \n fn codegen_field<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n@@ -214,17 +214,7 @@ impl<'tcx> CValue<'tcx> {\n     ) -> CValue<'tcx> {\n         let layout = self.1;\n         match self.0 {\n-            CValueInner::ByVal(val) => match layout.abi {\n-                Abi::Vector { element: _, count } => {\n-                    let count = u8::try_from(count).expect(\"SIMD type with more than 255 lanes???\");\n-                    let field = u8::try_from(field.index()).unwrap();\n-                    assert!(field < count);\n-                    let lane = fx.bcx.ins().extractlane(val, field);\n-                    let field_layout = layout.field(&*fx, usize::from(field));\n-                    CValue::by_val(lane, field_layout)\n-                }\n-                _ => unreachable!(\"value_field for ByVal with abi {:?}\", layout.abi),\n-            },\n+            CValueInner::ByVal(_) => unreachable!(),\n             CValueInner::ByValPair(val1, val2) => match layout.abi {\n                 Abi::ScalarPair(_, _) => {\n                     let val = match field.as_u32() {\n@@ -258,16 +248,7 @@ impl<'tcx> CValue<'tcx> {\n         let lane_layout = fx.layout_of(lane_ty);\n         assert!(lane_idx < lane_count);\n         match self.0 {\n-            CValueInner::ByVal(val) => match layout.abi {\n-                Abi::Vector { element: _, count: _ } => {\n-                    assert!(lane_count <= u8::MAX.into(), \"SIMD type with more than 255 lanes???\");\n-                    let lane_idx = u8::try_from(lane_idx).unwrap();\n-                    let lane = fx.bcx.ins().extractlane(val, lane_idx);\n-                    CValue::by_val(lane, lane_layout)\n-                }\n-                _ => unreachable!(\"value_lane for ByVal with abi {:?}\", layout.abi),\n-            },\n-            CValueInner::ByValPair(_, _) => unreachable!(),\n+            CValueInner::ByVal(_) | CValueInner::ByValPair(_, _) => unreachable!(),\n             CValueInner::ByRef(ptr, None) => {\n                 let field_offset = lane_layout.size * lane_idx;\n                 let field_ptr = ptr.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap());\n@@ -277,14 +258,6 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n-    pub(crate) fn unsize_value(self, fx: &mut FunctionCx<'_, '_, 'tcx>, dest: CPlace<'tcx>) {\n-        crate::unsize::coerce_unsized_into(fx, self, dest);\n-    }\n-\n-    pub(crate) fn coerce_dyn_star(self, fx: &mut FunctionCx<'_, '_, 'tcx>, dest: CPlace<'tcx>) {\n-        crate::unsize::coerce_dyn_star(fx, self, dest);\n-    }\n-\n     /// If `ty` is signed, `const_val` must already be sign extended.\n     pub(crate) fn const_val(\n         fx: &mut FunctionCx<'_, '_, 'tcx>,\n@@ -345,10 +318,9 @@ pub(crate) struct CPlace<'tcx> {\n }\n \n #[derive(Debug, Copy, Clone)]\n-pub(crate) enum CPlaceInner {\n+enum CPlaceInner {\n     Var(Local, Variable),\n     VarPair(Local, Variable, Variable),\n-    VarLane(Local, Variable, u8),\n     Addr(Pointer, Option<Value>),\n }\n \n@@ -357,10 +329,6 @@ impl<'tcx> CPlace<'tcx> {\n         self.layout\n     }\n \n-    pub(crate) fn inner(&self) -> &CPlaceInner {\n-        &self.inner\n-    }\n-\n     pub(crate) fn new_stack_slot(\n         fx: &mut FunctionCx<'_, '_, 'tcx>,\n         layout: TyAndLayout<'tcx>,\n@@ -442,12 +410,6 @@ impl<'tcx> CPlace<'tcx> {\n                 //fx.bcx.set_val_label(val2, cranelift_codegen::ir::ValueLabel::new(var2.index()));\n                 CValue::by_val_pair(val1, val2, layout)\n             }\n-            CPlaceInner::VarLane(_local, var, lane) => {\n-                let val = fx.bcx.use_var(var);\n-                //fx.bcx.set_val_label(val, cranelift_codegen::ir::ValueLabel::new(var.index()));\n-                let val = fx.bcx.ins().extractlane(val, lane);\n-                CValue::by_val(val, layout)\n-            }\n             CPlaceInner::Addr(ptr, extra) => {\n                 if let Some(extra) = extra {\n                     CValue::by_ref_unsized(ptr, extra, layout)\n@@ -458,21 +420,56 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n+    pub(crate) fn debug_comment(self) -> (&'static str, String) {\n+        match self.inner {\n+            CPlaceInner::Var(_local, var) => (\"ssa\", format!(\"var={}\", var.index())),\n+            CPlaceInner::VarPair(_local, var1, var2) => {\n+                (\"ssa\", format!(\"var=({}, {})\", var1.index(), var2.index()))\n+            }\n+            CPlaceInner::Addr(ptr, meta) => {\n+                let meta =\n+                    if let Some(meta) = meta { format!(\",meta={}\", meta) } else { String::new() };\n+                match ptr.debug_base_and_offset() {\n+                    (crate::pointer::PointerBase::Addr(addr), offset) => {\n+                        (\"reuse\", format!(\"storage={}{}{}\", addr, offset, meta))\n+                    }\n+                    (crate::pointer::PointerBase::Stack(stack_slot), offset) => {\n+                        (\"stack\", format!(\"storage={}{}{}\", stack_slot, offset, meta))\n+                    }\n+                    (crate::pointer::PointerBase::Dangling(align), offset) => {\n+                        (\"zst\", format!(\"align={},offset={}\", align.bytes(), offset))\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     #[track_caller]\n     pub(crate) fn to_ptr(self) -> Pointer {\n-        match self.to_ptr_maybe_unsized() {\n-            (ptr, None) => ptr,\n-            (_, Some(_)) => bug!(\"Expected sized cplace, found {:?}\", self),\n+        match self.inner {\n+            CPlaceInner::Addr(ptr, None) => ptr,\n+            CPlaceInner::Addr(_, Some(_)) => bug!(\"Expected sized cplace, found {:?}\", self),\n+            CPlaceInner::Var(_, _) | CPlaceInner::VarPair(_, _, _) => {\n+                bug!(\"Expected CPlace::Addr, found {:?}\", self)\n+            }\n         }\n     }\n \n     #[track_caller]\n-    pub(crate) fn to_ptr_maybe_unsized(self) -> (Pointer, Option<Value>) {\n+    pub(crate) fn to_ptr_unsized(self) -> (Pointer, Value) {\n         match self.inner {\n-            CPlaceInner::Addr(ptr, extra) => (ptr, extra),\n-            CPlaceInner::Var(_, _)\n-            | CPlaceInner::VarPair(_, _, _)\n-            | CPlaceInner::VarLane(_, _, _) => bug!(\"Expected CPlace::Addr, found {:?}\", self),\n+            CPlaceInner::Addr(ptr, Some(extra)) => (ptr, extra),\n+            CPlaceInner::Addr(_, None) | CPlaceInner::Var(_, _) | CPlaceInner::VarPair(_, _, _) => {\n+                bug!(\"Expected unsized cplace, found {:?}\", self)\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn try_to_ptr(self) -> Option<Pointer> {\n+        match self.inner {\n+            CPlaceInner::Var(_, _) | CPlaceInner::VarPair(_, _, _) => None,\n+            CPlaceInner::Addr(ptr, None) => Some(ptr),\n+            CPlaceInner::Addr(_, Some(_)) => bug!(\"Expected sized cplace, found {:?}\", self),\n         }\n     }\n \n@@ -496,7 +493,7 @@ impl<'tcx> CPlace<'tcx> {\n         from: CValue<'tcx>,\n         method: &'static str,\n     ) {\n-        fn transmute_value<'tcx>(\n+        fn transmute_scalar<'tcx>(\n             fx: &mut FunctionCx<'_, '_, 'tcx>,\n             var: Variable,\n             data: Value,\n@@ -520,7 +517,7 @@ impl<'tcx> CPlace<'tcx> {\n                 | (types::F64, types::I64) => codegen_bitcast(fx, dst_ty, data),\n                 _ if src_ty.is_vector() && dst_ty.is_vector() => codegen_bitcast(fx, dst_ty, data),\n                 _ if src_ty.is_vector() || dst_ty.is_vector() => {\n-                    // FIXME do something more efficient for transmutes between vectors and integers.\n+                    // FIXME(bytecodealliance/wasmtime#6104) do something more efficient for transmutes between vectors and integers.\n                     let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n                         kind: StackSlotKind::ExplicitSlot,\n                         // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n@@ -554,7 +551,7 @@ impl<'tcx> CPlace<'tcx> {\n                 format!(\n                     \"{}: {:?}: {:?} <- {:?}: {:?}\",\n                     method,\n-                    self.inner(),\n+                    self.inner,\n                     self.layout().ty,\n                     from.0,\n                     from.layout().ty\n@@ -563,32 +560,11 @@ impl<'tcx> CPlace<'tcx> {\n         }\n \n         let dst_layout = self.layout();\n-        let to_ptr = match self.inner {\n+        match self.inner {\n             CPlaceInner::Var(_local, var) => {\n-                if let ty::Array(element, len) = dst_layout.ty.kind() {\n-                    // Can only happen for vector types\n-                    let len = u32::try_from(len.eval_target_usize(fx.tcx, ParamEnv::reveal_all()))\n-                        .unwrap();\n-                    let vector_ty = fx.clif_type(*element).unwrap().by(len).unwrap();\n-\n-                    let data = match from.0 {\n-                        CValueInner::ByRef(ptr, None) => {\n-                            let mut flags = MemFlags::new();\n-                            flags.set_notrap();\n-                            ptr.load(fx, vector_ty, flags)\n-                        }\n-                        CValueInner::ByVal(_)\n-                        | CValueInner::ByValPair(_, _)\n-                        | CValueInner::ByRef(_, Some(_)) => bug!(\"array should be ByRef\"),\n-                    };\n-\n-                    fx.bcx.def_var(var, data);\n-                    return;\n-                }\n                 let data = CValue(from.0, dst_layout).load_scalar(fx);\n                 let dst_ty = fx.clif_type(self.layout().ty).unwrap();\n-                transmute_value(fx, var, data, dst_ty);\n-                return;\n+                transmute_scalar(fx, var, data, dst_ty);\n             }\n             CPlaceInner::VarPair(_local, var1, var2) => {\n                 let (data1, data2) = if from.layout().ty == dst_layout.ty {\n@@ -599,80 +575,61 @@ impl<'tcx> CPlace<'tcx> {\n                     CValue(CValueInner::ByRef(ptr, None), dst_layout).load_scalar_pair(fx)\n                 };\n                 let (dst_ty1, dst_ty2) = fx.clif_pair_type(self.layout().ty).unwrap();\n-                transmute_value(fx, var1, data1, dst_ty1);\n-                transmute_value(fx, var2, data2, dst_ty2);\n-                return;\n+                transmute_scalar(fx, var1, data1, dst_ty1);\n+                transmute_scalar(fx, var2, data2, dst_ty2);\n             }\n-            CPlaceInner::VarLane(_local, var, lane) => {\n-                let data = from.load_scalar(fx);\n-\n-                // First get the old vector\n-                let vector = fx.bcx.use_var(var);\n-                //fx.bcx.set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n-\n-                // Next insert the written lane into the vector\n-                let vector = fx.bcx.ins().insertlane(vector, data, lane);\n-\n-                // Finally write the new vector\n-                //fx.bcx.set_val_label(vector, cranelift_codegen::ir::ValueLabel::new(var.index()));\n-                fx.bcx.def_var(var, vector);\n-\n-                return;\n-            }\n-            CPlaceInner::Addr(ptr, None) => {\n+            CPlaceInner::Addr(_, Some(_)) => bug!(\"Can't write value to unsized place {:?}\", self),\n+            CPlaceInner::Addr(to_ptr, None) => {\n                 if dst_layout.size == Size::ZERO || dst_layout.abi == Abi::Uninhabited {\n                     return;\n                 }\n-                ptr\n-            }\n-            CPlaceInner::Addr(_, Some(_)) => bug!(\"Can't write value to unsized place {:?}\", self),\n-        };\n \n-        let mut flags = MemFlags::new();\n-        flags.set_notrap();\n-        match from.layout().abi {\n-            // FIXME make Abi::Vector work too\n-            Abi::Scalar(_) => {\n-                let val = from.load_scalar(fx);\n-                to_ptr.store(fx, val, flags);\n-                return;\n-            }\n-            Abi::ScalarPair(a_scalar, b_scalar) => {\n-                let (value, extra) = from.load_scalar_pair(fx);\n-                let b_offset = scalar_pair_calculate_b_offset(fx.tcx, a_scalar, b_scalar);\n-                to_ptr.store(fx, value, flags);\n-                to_ptr.offset(fx, b_offset).store(fx, extra, flags);\n-                return;\n-            }\n-            _ => {}\n-        }\n+                let mut flags = MemFlags::new();\n+                flags.set_notrap();\n+                match from.layout().abi {\n+                    Abi::Scalar(_) => {\n+                        let val = from.load_scalar(fx);\n+                        to_ptr.store(fx, val, flags);\n+                        return;\n+                    }\n+                    Abi::ScalarPair(a_scalar, b_scalar) => {\n+                        let (value, extra) = from.load_scalar_pair(fx);\n+                        let b_offset = scalar_pair_calculate_b_offset(fx.tcx, a_scalar, b_scalar);\n+                        to_ptr.store(fx, value, flags);\n+                        to_ptr.offset(fx, b_offset).store(fx, extra, flags);\n+                        return;\n+                    }\n+                    _ => {}\n+                }\n \n-        match from.0 {\n-            CValueInner::ByVal(val) => {\n-                to_ptr.store(fx, val, flags);\n-            }\n-            CValueInner::ByValPair(_, _) => {\n-                bug!(\"Non ScalarPair abi {:?} for ByValPair CValue\", dst_layout.abi);\n-            }\n-            CValueInner::ByRef(from_ptr, None) => {\n-                let from_addr = from_ptr.get_addr(fx);\n-                let to_addr = to_ptr.get_addr(fx);\n-                let src_layout = from.1;\n-                let size = dst_layout.size.bytes();\n-                let src_align = src_layout.align.abi.bytes() as u8;\n-                let dst_align = dst_layout.align.abi.bytes() as u8;\n-                fx.bcx.emit_small_memory_copy(\n-                    fx.target_config,\n-                    to_addr,\n-                    from_addr,\n-                    size,\n-                    dst_align,\n-                    src_align,\n-                    true,\n-                    flags,\n-                );\n+                match from.0 {\n+                    CValueInner::ByVal(val) => {\n+                        to_ptr.store(fx, val, flags);\n+                    }\n+                    CValueInner::ByValPair(_, _) => {\n+                        bug!(\"Non ScalarPair abi {:?} for ByValPair CValue\", dst_layout.abi);\n+                    }\n+                    CValueInner::ByRef(from_ptr, None) => {\n+                        let from_addr = from_ptr.get_addr(fx);\n+                        let to_addr = to_ptr.get_addr(fx);\n+                        let src_layout = from.1;\n+                        let size = dst_layout.size.bytes();\n+                        let src_align = src_layout.align.abi.bytes() as u8;\n+                        let dst_align = dst_layout.align.abi.bytes() as u8;\n+                        fx.bcx.emit_small_memory_copy(\n+                            fx.target_config,\n+                            to_addr,\n+                            from_addr,\n+                            size,\n+                            dst_align,\n+                            src_align,\n+                            true,\n+                            flags,\n+                        );\n+                    }\n+                    CValueInner::ByRef(_, Some(_)) => todo!(),\n+                }\n             }\n-            CValueInner::ByRef(_, Some(_)) => todo!(),\n         }\n     }\n \n@@ -692,40 +649,6 @@ impl<'tcx> CPlace<'tcx> {\n         let layout = self.layout();\n \n         match self.inner {\n-            CPlaceInner::Var(local, var) => match layout.ty.kind() {\n-                ty::Array(_, _) => {\n-                    // Can only happen for vector types\n-                    return CPlace {\n-                        inner: CPlaceInner::VarLane(local, var, field.as_u32().try_into().unwrap()),\n-                        layout: layout.field(fx, field.as_u32().try_into().unwrap()),\n-                    };\n-                }\n-                ty::Adt(adt_def, substs) if layout.ty.is_simd() => {\n-                    let f0 = &adt_def.non_enum_variant().fields[FieldIdx::from_u32(0)];\n-                    let f0_ty = f0.ty(fx.tcx, substs);\n-\n-                    match f0_ty.kind() {\n-                        ty::Array(_, _) => {\n-                            assert_eq!(field.as_u32(), 0);\n-                            return CPlace {\n-                                inner: CPlaceInner::Var(local, var),\n-                                layout: layout.field(fx, field.as_u32().try_into().unwrap()),\n-                            };\n-                        }\n-                        _ => {\n-                            return CPlace {\n-                                inner: CPlaceInner::VarLane(\n-                                    local,\n-                                    var,\n-                                    field.as_u32().try_into().unwrap(),\n-                                ),\n-                                layout: layout.field(fx, field.as_u32().try_into().unwrap()),\n-                            };\n-                        }\n-                    }\n-                }\n-                _ => {}\n-            },\n             CPlaceInner::VarPair(local, var1, var2) => {\n                 let layout = layout.field(&*fx, field.index());\n \n@@ -738,7 +661,12 @@ impl<'tcx> CPlace<'tcx> {\n             _ => {}\n         }\n \n-        let (base, extra) = self.to_ptr_maybe_unsized();\n+        let (base, extra) = match self.inner {\n+            CPlaceInner::Addr(ptr, extra) => (ptr, extra),\n+            CPlaceInner::Var(_, _) | CPlaceInner::VarPair(_, _, _) => {\n+                bug!(\"Expected CPlace::Addr, found {:?}\", self)\n+            }\n+        };\n \n         let (field_ptr, field_layout) = codegen_field(fx, base, extra, layout, field);\n         if field_layout.is_unsized() {\n@@ -767,15 +695,8 @@ impl<'tcx> CPlace<'tcx> {\n         assert!(lane_idx < lane_count);\n \n         match self.inner {\n-            CPlaceInner::Var(local, var) => {\n-                assert!(matches!(layout.abi, Abi::Vector { .. }));\n-                CPlace {\n-                    inner: CPlaceInner::VarLane(local, var, lane_idx.try_into().unwrap()),\n-                    layout: lane_layout,\n-                }\n-            }\n+            CPlaceInner::Var(_, _) => unreachable!(),\n             CPlaceInner::VarPair(_, _, _) => unreachable!(),\n-            CPlaceInner::VarLane(_, _, _) => unreachable!(),\n             CPlaceInner::Addr(ptr, None) => {\n                 let field_offset = lane_layout.size * lane_idx;\n                 let field_ptr = ptr.offset_i64(fx, i64::try_from(field_offset.bytes()).unwrap());\n@@ -794,34 +715,13 @@ impl<'tcx> CPlace<'tcx> {\n             ty::Array(elem_ty, _) => {\n                 let elem_layout = fx.layout_of(*elem_ty);\n                 match self.inner {\n-                    CPlaceInner::Var(local, var) => {\n-                        // This is a hack to handle `vector_val.0[1]`. It doesn't allow dynamic\n-                        // indexing.\n-                        let lane_idx = match fx.bcx.func.dfg.insts\n-                            [fx.bcx.func.dfg.value_def(index).unwrap_inst()]\n-                        {\n-                            InstructionData::UnaryImm { opcode: Opcode::Iconst, imm } => imm,\n-                            _ => bug!(\n-                                \"Dynamic indexing into a vector type is not supported: {self:?}[{index}]\"\n-                            ),\n-                        };\n-                        return CPlace {\n-                            inner: CPlaceInner::VarLane(\n-                                local,\n-                                var,\n-                                lane_idx.bits().try_into().unwrap(),\n-                            ),\n-                            layout: elem_layout,\n-                        };\n-                    }\n                     CPlaceInner::Addr(addr, None) => (elem_layout, addr),\n-                    CPlaceInner::Addr(_, Some(_))\n-                    | CPlaceInner::VarPair(_, _, _)\n-                    | CPlaceInner::VarLane(_, _, _) => bug!(\"Can't index into {self:?}\"),\n+                    CPlaceInner::Var(_, _)\n+                    | CPlaceInner::Addr(_, Some(_))\n+                    | CPlaceInner::VarPair(_, _, _) => bug!(\"Can't index into {self:?}\"),\n                 }\n-                // FIXME use VarLane in case of Var with simd type\n             }\n-            ty::Slice(elem_ty) => (fx.layout_of(*elem_ty), self.to_ptr_maybe_unsized().0),\n+            ty::Slice(elem_ty) => (fx.layout_of(*elem_ty), self.to_ptr_unsized().0),\n             _ => bug!(\"place_index({:?})\", self.layout().ty),\n         };\n \n@@ -846,12 +746,8 @@ impl<'tcx> CPlace<'tcx> {\n         layout: TyAndLayout<'tcx>,\n     ) -> CValue<'tcx> {\n         if has_ptr_meta(fx.tcx, self.layout().ty) {\n-            let (ptr, extra) = self.to_ptr_maybe_unsized();\n-            CValue::by_val_pair(\n-                ptr.get_addr(fx),\n-                extra.expect(\"unsized type without metadata\"),\n-                layout,\n-            )\n+            let (ptr, extra) = self.to_ptr_unsized();\n+            CValue::by_val_pair(ptr.get_addr(fx), extra, layout)\n         } else {\n             CValue::by_val(self.to_ptr().get_addr(fx), layout)\n         }"}, {"sha": "a68a10500f508b3147cc166e7100b5f8678a073e", "filename": "compiler/rustc_codegen_cranelift/y.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_cranelift%2Fy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fy.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -3,10 +3,14 @@\n # This block is ignored by rustc\n set -e\n echo \"[BUILD] y.rs\" 1>&2\n-rustc $0 -o ${0/.rs/.bin} -Cdebuginfo=1 --edition 2021 -Cpanic=abort\n+rustc $0 -o ${0/.rs/.bin} -Cdebuginfo=1 --edition 2021\n exec ${0/.rs/.bin} $@\n */\n \n+#![warn(rust_2018_idioms)]\n+#![warn(unused_lifetimes)]\n+#![warn(unreachable_pub)]\n+\n //! The build system for cg_clif\n //!\n //! # Manual compilation"}, {"sha": "738cdb6f119f2c9f369ea24a44be83fbe59c1c2f", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -593,6 +593,8 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n             InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::wreg) => \"w\",\n             InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::LoongArch(LoongArchInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::LoongArch(LoongArchInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_addr) => \"a\",\n             InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_data) => \"d\",\n@@ -667,6 +669,8 @@ fn dummy_output_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, reg: InlineAsmRegCl\n         InlineAsmRegClass::Avr(_) => unimplemented!(),\n         InlineAsmRegClass::Bpf(_) => unimplemented!(),\n         InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::LoongArch(LoongArchInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::LoongArch(LoongArchInlineAsmRegClass::freg) => cx.type_f32(),\n         InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_addr) => cx.type_i32(),\n         InlineAsmRegClass::M68k(M68kInlineAsmRegClass::reg_data) => cx.type_i32(),\n@@ -804,6 +808,7 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n             }\n         }\n         InlineAsmRegClass::Hexagon(_) => None,\n+        InlineAsmRegClass::LoongArch(_) => None,\n         InlineAsmRegClass::Mips(_) => None,\n         InlineAsmRegClass::Nvptx(_) => None,\n         InlineAsmRegClass::PowerPC(_) => None,"}, {"sha": "433b2585f82a844730da8baf4eb28aecdd75d62b", "filename": "compiler/rustc_codegen_gcc/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -17,7 +17,7 @@ use crate::context::CodegenCx;\n pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>) -> Function<'gcc> {\n     let tcx = cx.tcx();\n \n-    assert!(!instance.substs.needs_infer());\n+    assert!(!instance.substs.has_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n \n     let sym = tcx.symbol_name(instance).name;"}, {"sha": "1cabb05de975b0fec950fb6ae965ed4de35ade46", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -27,6 +27,7 @@ extern crate rustc_attr;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n+extern crate rustc_fluent_macro;\n extern crate rustc_hir;\n extern crate rustc_macros;\n extern crate rustc_metadata;\n@@ -76,7 +77,7 @@ use rustc_codegen_ssa::target_features::supported_target_features;\n use rustc_codegen_ssa::traits::{CodegenBackend, ExtraBackendMethods, ModuleBufferMethods, ThinBufferMethods, WriteBackendMethods};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{DiagnosticMessage, ErrorGuaranteed, Handler, SubdiagnosticMessage};\n-use rustc_macros::fluent_messages;\n+use rustc_fluent_macro::fluent_messages;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::ty::TyCtxt;"}, {"sha": "342b830cedb1206922c1b00ee70fc3f0f2891a42", "filename": "compiler/rustc_codegen_gcc/src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -31,7 +31,7 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n     #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n     fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, visibility: Visibility, symbol_name: &str) {\n-        assert!(!instance.substs.needs_infer());\n+        assert!(!instance.substs.has_infer());\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         self.linkage.set(base::linkage_to_gcc(linkage));"}, {"sha": "5e750d91b8251f031525b11880b694ab2c9a1b76", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -22,6 +22,7 @@ rustc_attr = { path = \"../rustc_attr\" }\n rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_fs_util = { path = \"../rustc_fs_util\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n@@ -35,6 +36,5 @@ rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-tempfile = \"3.2.0\"\n serde = { version = \"1\", features = [ \"derive\" ]}\n serde_json = \"1\""}, {"sha": "98d5b3599d9656a9ec6083e9a74a188b5c8b94ac", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -236,6 +236,7 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                 InlineAsmArch::Nvptx64 => {}\n                 InlineAsmArch::PowerPC | InlineAsmArch::PowerPC64 => {}\n                 InlineAsmArch::Hexagon => {}\n+                InlineAsmArch::LoongArch64 => {}\n                 InlineAsmArch::Mips | InlineAsmArch::Mips64 => {}\n                 InlineAsmArch::S390x => {}\n                 InlineAsmArch::SpirV => {}\n@@ -633,6 +634,8 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) ->\n             InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => \"w\",\n             InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::LoongArch(LoongArchInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::LoongArch(LoongArchInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => \"h\",\n@@ -719,6 +722,7 @@ fn modifier_to_llvm(\n             }\n         }\n         InlineAsmRegClass::Hexagon(_) => None,\n+        InlineAsmRegClass::LoongArch(_) => None,\n         InlineAsmRegClass::Mips(_) => None,\n         InlineAsmRegClass::Nvptx(_) => None,\n         InlineAsmRegClass::PowerPC(_) => None,\n@@ -803,6 +807,8 @@ fn dummy_output_type<'ll>(cx: &CodegenCx<'ll, '_>, reg: InlineAsmRegClass) -> &'\n             cx.type_vector(cx.type_i64(), 2)\n         }\n         InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::LoongArch(LoongArchInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::LoongArch(LoongArchInlineAsmRegClass::freg) => cx.type_f32(),\n         InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => cx.type_f32(),\n         InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => cx.type_i16(),"}, {"sha": "30a0cf1d01914c8718b77b9ee9d7ceff6cdabac7", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -27,7 +27,7 @@ pub fn get_fn<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) ->\n \n     debug!(\"get_fn(instance={:?})\", instance);\n \n-    assert!(!instance.substs.needs_infer());\n+    assert!(!instance.substs.has_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n \n     if let Some(&llfn) = cx.instances.borrow().get(&instance) {"}, {"sha": "9127fba388bab308b9673a47002708b772dac6b6", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -10,7 +10,7 @@ use crate::value::Value;\n use rustc_ast::Mutability;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::stable_hasher::{Hash128, HashStable, StableHasher};\n use rustc_hir::def_id::DefId;\n use rustc_middle::bug;\n use rustc_middle::mir::interpret::{ConstAllocation, GlobalAlloc, Scalar};\n@@ -261,7 +261,7 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                             let hash = self.tcx.with_stable_hashing_context(|mut hcx| {\n                                 let mut hasher = StableHasher::new();\n                                 alloc.hash_stable(&mut hcx, &mut hasher);\n-                                hasher.finish::<u128>()\n+                                hasher.finish::<Hash128>()\n                             });\n                             llvm::set_value_name(value, format!(\"alloc_{hash:032x}\").as_bytes());\n                         }"}, {"sha": "2f910c37d610852cdc025e1a7349c954a0ee9613", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::ty::{self, Instance};\n use rustc_session::config::DebugInfo;\n \n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::Idx;\n+use rustc_index::Idx;\n \n /// Produces DIScope DIEs for each MIR Scope which has variables defined in it.\n // FIXME(eddyb) almost all of this should be in `rustc_codegen_ssa::mir::debuginfo`."}, {"sha": "aaf5dbd9930c78f003b4a136acbc5df9c9b8d3d4", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -22,9 +22,9 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &mut Builder<'_,\n             bx.const_bitcast(get_or_insert_gdb_debug_scripts_section_global(bx), bx.type_i8p());\n         // Load just the first byte as that's all that's necessary to force\n         // LLVM to keep around the reference to the global.\n-        let volative_load_instruction = bx.volatile_load(bx.type_i8(), gdb_debug_scripts_section);\n+        let volatile_load_instruction = bx.volatile_load(bx.type_i8(), gdb_debug_scripts_section);\n         unsafe {\n-            llvm::LLVMSetAlignment(volative_load_instruction, 1);\n+            llvm::LLVMSetAlignment(volatile_load_instruction, 1);\n         }\n     }\n }"}, {"sha": "25fe3cb265d7982080fd9851453fc507a5bf3743", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -29,7 +29,6 @@ use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::bug;\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n-use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{\n     self, AdtKind, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt, Visibility,\n };\n@@ -1182,23 +1181,21 @@ fn build_generic_type_param_di_nodes<'ll, 'tcx>(\n             let names = get_parameter_names(cx, generics);\n             let template_params: SmallVec<_> = iter::zip(substs, names)\n                 .filter_map(|(kind, name)| {\n-                    if let GenericArgKind::Type(ty) = kind.unpack() {\n+                    kind.as_type().map(|ty| {\n                         let actual_type =\n                             cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n                         let actual_type_di_node = type_di_node(cx, actual_type);\n                         let name = name.as_str();\n-                        Some(unsafe {\n+                        unsafe {\n                             llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n                                 DIB(cx),\n                                 None,\n                                 name.as_ptr().cast(),\n                                 name.len(),\n                                 actual_type_di_node,\n                             )\n-                        })\n-                    } else {\n-                        None\n-                    }\n+                        }\n+                    })\n                 })\n                 .collect();\n "}, {"sha": "ecb0912d32881bca0ff6f8ace04029438395c0c5", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/cpp_like.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -6,7 +6,7 @@ use rustc_codegen_ssa::{\n     traits::ConstMethods,\n };\n \n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_middle::{\n     bug,\n     ty::{\n@@ -62,7 +62,7 @@ const SINGLE_VARIANT_VIRTUAL_DISR: u64 = 0;\n \n /// In CPP-like mode, we generate a union with a field for each variant and an\n /// explicit tag field. The field of each variant has a struct type\n-/// that encodes the discrimiant of the variant and it's data layout.\n+/// that encodes the discriminant of the variant and it's data layout.\n /// The union also has a nested enumeration type that is only used for encoding\n /// variant names in an efficient way. Its enumerator values do _not_ correspond\n /// to the enum's discriminant values."}, {"sha": "9e0e847a155653226bae977f4464a954ede9dcea", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -3,7 +3,7 @@ use rustc_codegen_ssa::debuginfo::{\n     wants_c_like_enum_debuginfo,\n };\n use rustc_hir::def::CtorKind;\n-use rustc_index::vec::IndexSlice;\n+use rustc_index::IndexSlice;\n use rustc_middle::{\n     bug,\n     mir::{GeneratorLayout, GeneratorSavedLocal},"}, {"sha": "2e9f89f41969642233c5cbe82c7973db64aabdfb", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -21,12 +21,13 @@ use rustc_codegen_ssa::debuginfo::type_names;\n use rustc_codegen_ssa::mir::debuginfo::{DebugScope, FunctionDebugContext, VariableKind};\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::Hash128;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir::def_id::{DefId, DefIdMap};\n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_middle::mir;\n use rustc_middle::ty::layout::LayoutOf;\n-use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n+use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Instance, ParamEnv, Ty, TypeVisitableExt};\n use rustc_session::config::{self, DebugInfo};\n use rustc_session::Session;\n@@ -61,7 +62,7 @@ pub struct CodegenUnitDebugContext<'ll, 'tcx> {\n     llcontext: &'ll llvm::Context,\n     llmod: &'ll llvm::Module,\n     builder: &'ll mut DIBuilder<'ll>,\n-    created_files: RefCell<FxHashMap<Option<(u128, SourceFileHash)>, &'ll DIFile>>,\n+    created_files: RefCell<FxHashMap<Option<(Hash128, SourceFileHash)>, &'ll DIFile>>,\n \n     type_map: metadata::TypeMap<'ll, 'tcx>,\n     namespace_map: RefCell<DefIdMap<&'ll DIScope>>,\n@@ -460,23 +461,21 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 let names = get_parameter_names(cx, generics);\n                 iter::zip(substs, names)\n                     .filter_map(|(kind, name)| {\n-                        if let GenericArgKind::Type(ty) = kind.unpack() {\n+                        kind.as_type().map(|ty| {\n                             let actual_type =\n                                 cx.tcx.normalize_erasing_regions(ParamEnv::reveal_all(), ty);\n                             let actual_type_metadata = type_di_node(cx, actual_type);\n                             let name = name.as_str();\n-                            Some(unsafe {\n+                            unsafe {\n                                 Some(llvm::LLVMRustDIBuilderCreateTemplateTypeParameter(\n                                     DIB(cx),\n                                     None,\n                                     name.as_ptr().cast(),\n                                     name.len(),\n                                     actual_type_metadata,\n                                 ))\n-                            })\n-                        } else {\n-                            None\n-                        }\n+                            }\n+                        })\n                     })\n                     .collect()\n             } else {\n@@ -516,7 +515,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         ty::Adt(def, ..) if !def.is_box() => {\n                             // Again, only create type information if full debuginfo is enabled\n                             if cx.sess().opts.debuginfo == DebugInfo::Full\n-                                && !impl_self_ty.needs_subst()\n+                                && !impl_self_ty.has_param()\n                             {\n                                 Some(type_di_node(cx, impl_self_ty))\n                             } else {"}, {"sha": "8305a0a4c286df2c091c91db271c8953c4ca7f5c", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -34,7 +34,7 @@ use rustc_codegen_ssa::ModuleCodegen;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{DiagnosticMessage, ErrorGuaranteed, FatalError, Handler, SubdiagnosticMessage};\n-use rustc_macros::fluent_messages;\n+use rustc_fluent_macro::fluent_messages;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::ty::query::Providers;\n@@ -69,7 +69,7 @@ mod declare;\n mod errors;\n mod intrinsic;\n \n-// The following is a work around that replaces `pub mod llvm;` and that fixes issue 53912.\n+// The following is a workaround that replaces `pub mod llvm;` and that fixes issue 53912.\n #[path = \"llvm/mod.rs\"]\n mod llvm_;\n pub mod llvm {"}, {"sha": "c95148013eb7479111166c8af4ba5d7a5cb3833d", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -552,6 +552,7 @@ pub enum ArchiveKind {\n     K_BSD,\n     K_DARWIN,\n     K_COFF,\n+    K_AIXBIG,\n }\n \n // LLVMRustThinLTOData"}, {"sha": "4f5cc575da6e5617ccaa135529721f8b1913c9c4", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -137,6 +137,7 @@ impl FromStr for ArchiveKind {\n             \"bsd\" => Ok(ArchiveKind::K_BSD),\n             \"darwin\" => Ok(ArchiveKind::K_DARWIN),\n             \"coff\" => Ok(ArchiveKind::K_COFF),\n+            \"aix_big\" => Ok(ArchiveKind::K_AIXBIG),\n             _ => Err(()),\n         }\n     }"}, {"sha": "59bdc60830f80016fc76d58ab35fd7a9bd5edee5", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> PreDefineMethods<'tcx> for CodegenCx<'_, 'tcx> {\n         visibility: Visibility,\n         symbol_name: &str,\n     ) {\n-        assert!(!instance.substs.needs_infer());\n+        assert!(!instance.substs.has_infer());\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         let lldecl = self.declare_fn(symbol_name, fn_abi);"}, {"sha": "a421535c9b46fcaea13edc40167bcdfdc50d7428", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -7,12 +7,11 @@ edition = \"2021\"\n test = false\n \n [dependencies]\n-ar_archive_writer = \"0.1.1\"\n+ar_archive_writer = \"0.1.3\"\n bitflags = \"1.2.1\"\n cc = \"1.0.69\"\n itertools = \"0.10.1\"\n tracing = \"0.1\"\n-libc = \"0.2.50\"\n jobserver = \"0.1.22\"\n tempfile = \"3.2\"\n thorin-dwp = \"0.4\"\n@@ -29,6 +28,7 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n rustc_attr = { path = \"../rustc_attr\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_symbol_mangling = { path = \"../rustc_symbol_mangling\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n@@ -42,6 +42,9 @@ rustc_query_system = { path = \"../rustc_query_system\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n \n+[target.'cfg(unix)'.dependencies]\n+libc = \"0.2.50\"\n+\n [dependencies.object]\n version = \"0.30.1\"\n default-features = false"}, {"sha": "375fdec10075a39eab98cfb5f854a0b5a45737c8", "filename": "compiler/rustc_codegen_ssa/messages.ftl", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fmessages.ftl?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -148,7 +148,7 @@ codegen_ssa_processing_dymutil_failed = processing debug info with `dsymutil` fa\n \n codegen_ssa_unable_to_run_dsymutil = unable to run `dsymutil`: {$error}\n \n-codegen_ssa_stripping_debu_info_failed = stripping debug info with `{$util}` failed: {$status}\n+codegen_ssa_stripping_debug_info_failed = stripping debug info with `{$util}` failed: {$status}\n     .note = {$output}\n \n codegen_ssa_unable_to_run = unable to run `{$util}`: {$error}\n@@ -291,3 +291,16 @@ codegen_ssa_invalid_monomorphization_unsupported_cast = invalid monomorphization\n codegen_ssa_invalid_monomorphization_unsupported_operation = invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n \n codegen_ssa_invalid_monomorphization_expected_vector_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of vector type `{$vector_type}` to be a signed or unsigned integer type\n+\n+codegen_ssa_invalid_no_sanitize = invalid argument for `no_sanitize`\n+    .note = expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\n+\n+codegen_ssa_invalid_link_ordinal_nargs = incorrect number of arguments to `#[link_ordinal]`\n+    .note = the attribute requires exactly one argument\n+\n+codegen_ssa_illegal_link_ordinal_format = illegal ordinal format in `link_ordinal`\n+    .note = an unsuffixed integer value, e.g., `1`, is expected\n+\n+codegen_ssa_target_feature_safe_trait = `#[target_feature(..)]` cannot be applied to safe trait method\n+    .label = cannot be applied to safe trait method\n+    .label_def = not an `unsafe` function"}, {"sha": "1c464b3eca4979697c3b177e72933de3a2a25d46", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -233,6 +233,7 @@ impl<'a> ArArchiveBuilder<'a> {\n             \"bsd\" => ArchiveKind::Bsd,\n             \"darwin\" => ArchiveKind::Darwin,\n             \"coff\" => ArchiveKind::Coff,\n+            \"aix_big\" => ArchiveKind::AixBig,\n             kind => {\n                 self.sess.emit_fatal(UnknownArchiveKind { kind });\n             }"}, {"sha": "eecfe13bb3eeff8c8ed8148b6f92fed095955ea9", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -349,7 +349,10 @@ fn link_rlib<'a>(\n         let NativeLibKind::Static { bundle: None | Some(true), whole_archive } = lib.kind else {\n             continue;\n         };\n-        if whole_archive == Some(true) && !codegen_results.crate_info.feature_packed_bundled_libs {\n+        if whole_archive == Some(true)\n+            && flavor == RlibFlavor::Normal\n+            && !codegen_results.crate_info.feature_packed_bundled_libs\n+        {\n             sess.emit_err(errors::IncompatibleLinkingModifiers);\n         }\n         if flavor == RlibFlavor::Normal && let Some(filename) = lib.filename {"}, {"sha": "8f2f829c17c1cd76110180d80c3b2b9331d0eeee", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -333,7 +333,7 @@ fn exported_symbols_provider_local(\n             match *mono_item {\n                 MonoItem::Fn(Instance { def: InstanceDef::Item(def), substs }) => {\n                     if substs.non_erasable_generics().next().is_some() {\n-                        let symbol = ExportedSymbol::Generic(def.did, substs);\n+                        let symbol = ExportedSymbol::Generic(def, substs);\n                         symbols.push((\n                             symbol,\n                             SymbolExportInfo {"}, {"sha": "c80347448cbb28192e0f75e4d21f7afc03fe14aa", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -872,7 +872,7 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n     let load_from_incr_comp_dir = |output_path: PathBuf, saved_path: &str| {\n         let source_file = in_incr_comp_dir(&incr_comp_session_dir, saved_path);\n         debug!(\n-            \"copying pre-existing module `{}` from {:?} to {}\",\n+            \"copying preexisting module `{}` from {:?} to {}\",\n             module.name,\n             source_file,\n             output_path.display()"}, {"sha": "5bd42622f2c33c459ca51d249edf119b030eaee1", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -14,6 +14,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span};\n use rustc_target::spec::{abi, SanitizerSet};\n \n+use crate::errors;\n use crate::target_features::from_target_feature;\n use crate::{errors::ExpectedUsedSymbol, target_features::check_target_feature_trait_unsafe};\n \n@@ -156,7 +157,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {\n                     None => {\n                         // Unfortunately, unconditionally using `llvm.used` causes\n                         // issues in handling `.init_array` with the gold linker,\n-                        // but using `llvm.compiler.used` caused a nontrival amount\n+                        // but using `llvm.compiler.used` caused a nontrivial amount\n                         // of unintentional ecosystem breakage -- particularly on\n                         // Mach-O targets.\n                         //\n@@ -334,10 +335,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {\n                                 codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS\n                             }\n                             _ => {\n-                                tcx.sess\n-                                    .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n-                                    .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n-                                    .emit();\n+                                tcx.sess.emit_err(errors::InvalidNoSanitize { span: item.span() });\n                             }\n                         }\n                     }\n@@ -608,10 +606,7 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n     let sole_meta_list = match meta_item_list {\n         Some([item]) => item.lit(),\n         Some(_) => {\n-            tcx.sess\n-                .struct_span_err(attr.span, \"incorrect number of arguments to `#[link_ordinal]`\")\n-                .note(\"the attribute requires exactly one argument\")\n-                .emit();\n+            tcx.sess.emit_err(errors::InvalidLinkOrdinalNargs { span: attr.span });\n             return None;\n         }\n         _ => None,\n@@ -642,10 +637,7 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n             None\n         }\n     } else {\n-        tcx.sess\n-            .struct_span_err(attr.span, \"illegal ordinal format in `link_ordinal`\")\n-            .note(\"an unsuffixed integer value, e.g., `1`, is expected\")\n-            .emit();\n+        tcx.sess.emit_err(errors::InvalidLinkOrdinalFormat { span: attr.span });\n         None\n     }\n }"}, {"sha": "e4da3b8de05126ba8d4b92f812b796511eba306d", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,6 +1,6 @@\n pub use super::ffi::*;\n \n-use rustc_index::vec::{IndexSlice, IndexVec};\n+use rustc_index::{IndexSlice, IndexVec};\n use rustc_middle::mir::coverage::{\n     CodeRegion, CounterValueReference, ExpressionOperandId, InjectedExpressionId,\n     InjectedExpressionIndex, MappedExpressionIndex, Op,"}, {"sha": "03f33d8d8aa7fdc9ea69dc620b2c3781513b82d1", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -12,7 +12,7 @@\n // * `\"` is treated as the start of a string.\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::stable_hasher::{Hash64, HashStable, StableHasher};\n use rustc_hir::def_id::DefId;\n use rustc_hir::definitions::{DefPathData, DefPathDataName, DisambiguatedDefPathData};\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Mutability};\n@@ -675,8 +675,7 @@ fn push_const_param<'tcx>(tcx: TyCtxt<'tcx>, ct: ty::Const<'tcx>, output: &mut S\n                     hcx.while_hashing_spans(false, |hcx| {\n                         ct.to_valtree().hash_stable(hcx, &mut hasher)\n                     });\n-                    let hash: u64 = hasher.finish();\n-                    hash\n+                    hasher.finish::<Hash64>()\n                 });\n \n                 if cpp_like_debuginfo(tcx) {"}, {"sha": "cf4893b822651a77fdf2adcc07177b165505a8c8", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -424,7 +424,7 @@ pub struct UnableToRunDsymutil {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa_stripping_debu_info_failed)]\n+#[diag(codegen_ssa_stripping_debug_info_failed)]\n #[note]\n pub struct StrippingDebugInfoFailed<'a> {\n     pub util: &'a str,\n@@ -981,3 +981,37 @@ impl IntoDiagnosticArg for ExpectedPointerMutability {\n         }\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_invalid_no_sanitize)]\n+#[note]\n+pub struct InvalidNoSanitize {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_invalid_link_ordinal_nargs)]\n+#[note]\n+pub struct InvalidLinkOrdinalNargs {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_illegal_link_ordinal_format)]\n+#[note]\n+pub struct InvalidLinkOrdinalFormat {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_target_feature_safe_trait)]\n+pub struct TargetFeatureSafeTrait {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(codegen_ssa_label_def)]\n+    pub def: Span,\n+}"}, {"sha": "26d55618b490a3dee1be3cc0c2e794b7ffe1449c", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -25,8 +25,8 @@ use rustc_ast as ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_fluent_macro::fluent_messages;\n use rustc_hir::def_id::CrateNum;\n-use rustc_macros::fluent_messages;\n use rustc_middle::dep_graph::WorkProduct;\n use rustc_middle::middle::dependency_format::Dependencies;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;"}, {"sha": "81b49afb88391395061de37d308348f2ec0833d2", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -67,10 +67,10 @@ impl<'a, 'tcx> VirtualIndex {\n /// ref of the type.\n fn expect_dyn_trait_in_self(ty: Ty<'_>) -> ty::PolyExistentialTraitRef<'_> {\n     for arg in ty.peel_refs().walk() {\n-        if let GenericArgKind::Type(ty) = arg.unpack() {\n-            if let ty::Dynamic(data, _, _) = ty.kind() {\n-                return data.principal().expect(\"expected principal trait object\");\n-            }\n+        if let GenericArgKind::Type(ty) = arg.unpack()\n+            && let ty::Dynamic(data, _, _) = ty.kind()\n+        {\n+            return data.principal().expect(\"expected principal trait object\");\n         }\n     }\n "}, {"sha": "0334c7ff13264ab1a9d5214f5cce4a82c349a27c", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -5,7 +5,7 @@ use super::FunctionCx;\n use crate::traits::*;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::{IndexSlice, IndexVec};\n+use rustc_index::{IndexSlice, IndexVec};\n use rustc_middle::mir::traversal;\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{self, Location, TerminatorKind};"}, {"sha": "a0a8246be15248fdb82a7b437ea220d9e034cb6d", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -12,7 +12,6 @@ use crate::MemFlags;\n use rustc_ast as ast;\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir::lang_items::LangItem;\n-use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, AssertKind, SwitchTargets};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf, ValidityRequirement};\n use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n@@ -369,7 +368,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if self.fn_abi.c_variadic {\n             // The `VaList` \"spoofed\" argument is just after all the real arguments.\n             let va_list_arg_idx = self.fn_abi.args.len();\n-            match self.locals[mir::Local::new(1 + va_list_arg_idx)] {\n+            match self.locals[mir::Local::from_usize(1 + va_list_arg_idx)] {\n                 LocalRef::Place(va_list) => {\n                     bx.va_end(va_list.llval);\n                 }"}, {"sha": "4e5e2dd5d506bd182548a32e836b785ccd3fe039", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,5 +1,5 @@\n use crate::traits::*;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir;\n use rustc_middle::ty;\n@@ -494,6 +494,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let Some(dbg_loc) = self.dbg_loc(var.source_info) else { continue };\n \n                         if let Ok(operand) = self.eval_mir_constant_to_operand(bx, &c) {\n+                            self.set_debug_loc(bx, var.source_info);\n                             let base = Self::spill_operand_to_stack(\n                                 &operand,\n                                 Some(var.name.to_string()),"}, {"sha": "1479242f23a6c08ad99b47b4ad5c1a9f2a808fce", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -135,13 +135,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     .unwrap();\n                 OperandRef::from_const(bx, value, ret_ty).immediate_or_packed_pair(bx)\n             }\n-            sym::offset => {\n-                let ty = substs.type_at(0);\n-                let layout = bx.layout_of(ty);\n-                let ptr = args[0].immediate();\n-                let offset = args[1].immediate();\n-                bx.inbounds_gep(bx.backend_type(layout), ptr, &[offset])\n-            }\n             sym::arith_offset => {\n                 let ty = substs.type_at(0);\n                 let layout = bx.layout_of(ty);"}, {"sha": "f706ecea97512f1c62b357d670757b4d2673543d", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -9,7 +9,7 @@ use rustc_target::abi::call::{FnAbi, PassMode};\n use std::iter;\n \n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n \n use self::debuginfo::{FunctionDebugContext, PerLocalVarDebugInfo};\n use self::place::PlaceRef;\n@@ -152,7 +152,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n     instance: Instance<'tcx>,\n ) {\n-    assert!(!instance.substs.needs_infer());\n+    assert!(!instance.substs.has_infer());\n \n     let llfn = cx.get_fn(instance);\n \n@@ -304,7 +304,17 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                     bug!(\"spread argument isn't a tuple?!\");\n                 };\n \n-                let place = PlaceRef::alloca(bx, bx.layout_of(arg_ty));\n+                let layout = bx.layout_of(arg_ty);\n+\n+                // FIXME: support unsized params in \"rust-call\" ABI\n+                if layout.is_unsized() {\n+                    span_bug!(\n+                        arg_decl.source_info.span,\n+                        \"\\\"rust-call\\\" ABI does not support unsized params\",\n+                    );\n+                }\n+\n+                let place = PlaceRef::alloca(bx, layout);\n                 for i in 0..tupled_arg_tys.len() {\n                     let arg = &fx.fn_abi.args[idx];\n                     idx += 1;"}, {"sha": "a58a61cd567fc6139120ef4d2862759777bcc0fb", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -211,7 +211,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n     ) -> V {\n         let dl = &bx.tcx().data_layout;\n         let cast_to_layout = bx.cx().layout_of(cast_to);\n-        let cast_to_size = cast_to_layout.layout.size();\n         let cast_to = bx.cx().immediate_backend_type(cast_to_layout);\n         if self.layout.abi.is_uninhabited() {\n             return bx.cx().const_poison(cast_to);\n@@ -261,21 +260,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     _ => (tag_imm, bx.cx().immediate_backend_type(tag_op.layout)),\n                 };\n \n-                let tag_size = tag_scalar.size(bx.cx());\n-                let max_unsigned = tag_size.unsigned_int_max();\n-                let max_signed = tag_size.signed_int_max() as u128;\n-                let min_signed = max_signed + 1;\n                 let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n-                let niche_end = niche_start.wrapping_add(relative_max as u128) & max_unsigned;\n-                let range = tag_scalar.valid_range(bx.cx());\n-\n-                let sle = |lhs: u128, rhs: u128| -> bool {\n-                    // Signed and unsigned comparisons give the same results,\n-                    // except that in signed comparisons an integer with the\n-                    // sign bit set is less than one with the sign bit clear.\n-                    // Toggle the sign bit to do a signed comparison.\n-                    (lhs ^ min_signed) <= (rhs ^ min_signed)\n-                };\n \n                 // We have a subrange `niche_start..=niche_end` inside `range`.\n                 // If the value of the tag is inside this subrange, it's a\n@@ -291,49 +276,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                 //     untagged_variant\n                 // }\n                 // However, we will likely be able to emit simpler code.\n-\n-                // Find the least and greatest values in `range`, considered\n-                // both as signed and unsigned.\n-                let (low_unsigned, high_unsigned) = if range.start <= range.end {\n-                    (range.start, range.end)\n-                } else {\n-                    (0, max_unsigned)\n-                };\n-                let (low_signed, high_signed) = if sle(range.start, range.end) {\n-                    (range.start, range.end)\n-                } else {\n-                    (min_signed, max_signed)\n-                };\n-\n-                let niches_ule = niche_start <= niche_end;\n-                let niches_sle = sle(niche_start, niche_end);\n-                let cast_smaller = cast_to_size <= tag_size;\n-\n-                // In the algorithm above, we can change\n-                // cast(relative_tag) + niche_variants.start()\n-                // into\n-                // cast(tag + (niche_variants.start() - niche_start))\n-                // if either the casted type is no larger than the original\n-                // type, or if the niche values are contiguous (in either the\n-                // signed or unsigned sense).\n-                let can_incr = cast_smaller || niches_ule || niches_sle;\n-\n-                let data_for_boundary_niche = || -> Option<(IntPredicate, u128)> {\n-                    if !can_incr {\n-                        None\n-                    } else if niche_start == low_unsigned {\n-                        Some((IntPredicate::IntULE, niche_end))\n-                    } else if niche_end == high_unsigned {\n-                        Some((IntPredicate::IntUGE, niche_start))\n-                    } else if niche_start == low_signed {\n-                        Some((IntPredicate::IntSLE, niche_end))\n-                    } else if niche_end == high_signed {\n-                        Some((IntPredicate::IntSGE, niche_start))\n-                    } else {\n-                        None\n-                    }\n-                };\n-\n                 let (is_niche, tagged_discr, delta) = if relative_max == 0 {\n                     // Best case scenario: only one tagged variant. This will\n                     // likely become just a comparison and a jump.\n@@ -349,40 +291,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     let tagged_discr =\n                         bx.cx().const_uint(cast_to, niche_variants.start().as_u32() as u64);\n                     (is_niche, tagged_discr, 0)\n-                } else if let Some((predicate, constant)) = data_for_boundary_niche() {\n-                    // The niche values are either the lowest or the highest in\n-                    // `range`. We can avoid the first subtraction in the\n-                    // algorithm.\n-                    // The algorithm is now this:\n-                    // is_niche = tag <= niche_end\n-                    // discr = if is_niche {\n-                    //     cast(tag + (niche_variants.start() - niche_start))\n-                    // } else {\n-                    //     untagged_variant\n-                    // }\n-                    // (the first line may instead be tag >= niche_start,\n-                    // and may be a signed or unsigned comparison)\n-                    // The arithmetic must be done before the cast, so we can\n-                    // have the correct wrapping behavior. See issue #104519 for\n-                    // the consequences of getting this wrong.\n-                    let is_niche =\n-                        bx.icmp(predicate, tag, bx.cx().const_uint_big(tag_llty, constant));\n-                    let delta = (niche_variants.start().as_u32() as u128).wrapping_sub(niche_start);\n-                    let incr_tag = if delta == 0 {\n-                        tag\n-                    } else {\n-                        bx.add(tag, bx.cx().const_uint_big(tag_llty, delta))\n-                    };\n-\n-                    let cast_tag = if cast_smaller {\n-                        bx.intcast(incr_tag, cast_to, false)\n-                    } else if niches_ule {\n-                        bx.zext(incr_tag, cast_to)\n-                    } else {\n-                        bx.sext(incr_tag, cast_to)\n-                    };\n-\n-                    (is_niche, cast_tag, 0)\n                 } else {\n                     // The special cases don't apply, so we'll have to go with\n                     // the general algorithm."}, {"sha": "64452472eeca45f82c6c2bf5a6f4b28db2f2577e", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 80, "deletions": 8, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -12,6 +12,7 @@ use rustc_middle::mir::Operand;\n use rustc_middle::ty::cast::{CastTy, IntTy};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n+use rustc_session::config::OptLevel;\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_target::abi::{self, FIRST_VARIANT};\n \n@@ -231,10 +232,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         (ScalarOrZst::Scalar(in_scalar), ScalarOrZst::Scalar(out_scalar))\n                             if in_scalar.size(self.cx) == out_scalar.size(self.cx) =>\n                         {\n+                            let operand_bty = bx.backend_type(operand.layout);\n                             let cast_bty = bx.backend_type(cast);\n-                            Some(OperandValue::Immediate(\n-                                self.transmute_immediate(bx, imm, in_scalar, out_scalar, cast_bty),\n-                            ))\n+                            Some(OperandValue::Immediate(self.transmute_immediate(\n+                                bx,\n+                                imm,\n+                                in_scalar,\n+                                operand_bty,\n+                                out_scalar,\n+                                cast_bty,\n+                            )))\n                         }\n                         _ => None,\n                     }\n@@ -250,11 +257,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     && in_a.size(self.cx) == out_a.size(self.cx)\n                     && in_b.size(self.cx) == out_b.size(self.cx)\n                 {\n+                    let in_a_ibty = bx.scalar_pair_element_backend_type(operand.layout, 0, false);\n+                    let in_b_ibty = bx.scalar_pair_element_backend_type(operand.layout, 1, false);\n                     let out_a_ibty = bx.scalar_pair_element_backend_type(cast, 0, false);\n                     let out_b_ibty = bx.scalar_pair_element_backend_type(cast, 1, false);\n                     Some(OperandValue::Pair(\n-                        self.transmute_immediate(bx, imm_a, in_a, out_a, out_a_ibty),\n-                        self.transmute_immediate(bx, imm_b, in_b, out_b, out_b_ibty),\n+                        self.transmute_immediate(bx, imm_a, in_a, in_a_ibty, out_a, out_a_ibty),\n+                        self.transmute_immediate(bx, imm_b, in_b, in_b_ibty, out_b, out_b_ibty),\n                     ))\n                 } else {\n                     None\n@@ -273,13 +282,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx: &mut Bx,\n         mut imm: Bx::Value,\n         from_scalar: abi::Scalar,\n+        from_backend_ty: Bx::Type,\n         to_scalar: abi::Scalar,\n         to_backend_ty: Bx::Type,\n     ) -> Bx::Value {\n         debug_assert_eq!(from_scalar.size(self.cx), to_scalar.size(self.cx));\n \n         use abi::Primitive::*;\n         imm = bx.from_immediate(imm);\n+\n+        // When scalars are passed by value, there's no metadata recording their\n+        // valid ranges. For example, `char`s are passed as just `i32`, with no\n+        // way for LLVM to know that they're 0x10FFFF at most. Thus we assume\n+        // the range of the input value too, not just the output range.\n+        self.assume_scalar_range(bx, imm, from_scalar, from_backend_ty);\n+\n         imm = match (from_scalar.primitive(), to_scalar.primitive()) {\n             (Int(..) | F32 | F64, Int(..) | F32 | F64) => bx.bitcast(imm, to_backend_ty),\n             (Pointer(..), Pointer(..)) => bx.pointercast(imm, to_backend_ty),\n@@ -294,10 +311,55 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bx.bitcast(int_imm, to_backend_ty)\n             }\n         };\n+        self.assume_scalar_range(bx, imm, to_scalar, to_backend_ty);\n         imm = bx.to_immediate_scalar(imm, to_scalar);\n         imm\n     }\n \n+    fn assume_scalar_range(\n+        &self,\n+        bx: &mut Bx,\n+        imm: Bx::Value,\n+        scalar: abi::Scalar,\n+        backend_ty: Bx::Type,\n+    ) {\n+        if matches!(self.cx.sess().opts.optimize, OptLevel::No | OptLevel::Less)\n+            // For now, the critical niches are all over `Int`eger values.\n+            // Should floating-point values or pointers ever get more complex\n+            // niches, then this code will probably want to handle them too.\n+            || !matches!(scalar.primitive(), abi::Primitive::Int(..))\n+            || scalar.is_always_valid(self.cx)\n+        {\n+            return;\n+        }\n+\n+        let abi::WrappingRange { start, end } = scalar.valid_range(self.cx);\n+\n+        if start <= end {\n+            if start > 0 {\n+                let low = bx.const_uint_big(backend_ty, start);\n+                let cmp = bx.icmp(IntPredicate::IntUGE, imm, low);\n+                bx.assume(cmp);\n+            }\n+\n+            let type_max = scalar.size(self.cx).unsigned_int_max();\n+            if end < type_max {\n+                let high = bx.const_uint_big(backend_ty, end);\n+                let cmp = bx.icmp(IntPredicate::IntULE, imm, high);\n+                bx.assume(cmp);\n+            }\n+        } else {\n+            let low = bx.const_uint_big(backend_ty, start);\n+            let cmp_low = bx.icmp(IntPredicate::IntUGE, imm, low);\n+\n+            let high = bx.const_uint_big(backend_ty, end);\n+            let cmp_high = bx.icmp(IntPredicate::IntULE, imm, high);\n+\n+            let or = bx.or(cmp_low, cmp_high);\n+            bx.assume(or);\n+        }\n+    }\n+\n     pub fn codegen_rvalue_unsized(\n         &mut self,\n         bx: &mut Bx,\n@@ -604,13 +666,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n \n-            mir::Rvalue::NullaryOp(null_op, ty) => {\n+            mir::Rvalue::NullaryOp(ref null_op, ty) => {\n                 let ty = self.monomorphize(ty);\n                 assert!(bx.cx().type_is_sized(ty));\n                 let layout = bx.cx().layout_of(ty);\n                 let val = match null_op {\n                     mir::NullOp::SizeOf => layout.size.bytes(),\n                     mir::NullOp::AlignOf => layout.align.abi.bytes(),\n+                    mir::NullOp::OffsetOf(fields) => {\n+                        layout.offset_of_subfield(bx.cx(), fields.iter().map(|f| f.index())).bytes()\n+                    }\n                 };\n                 let val = bx.cx().const_usize(val);\n                 let tcx = self.cx.tcx();\n@@ -754,8 +819,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     .builtin_deref(true)\n                     .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", input_ty))\n                     .ty;\n-                let llty = bx.cx().backend_type(bx.cx().layout_of(pointee_type));\n-                bx.inbounds_gep(llty, lhs, &[rhs])\n+                let pointee_layout = bx.cx().layout_of(pointee_type);\n+                if pointee_layout.is_zst() {\n+                    // `Offset` works in terms of the size of pointee,\n+                    // so offsetting a pointer to ZST is a noop.\n+                    lhs\n+                } else {\n+                    let llty = bx.cx().backend_type(pointee_layout);\n+                    bx.inbounds_gep(llty, lhs, &[rhs])\n+                }\n             }\n             mir::BinOp::Shl => common::build_unchecked_lshift(bx, lhs, rhs),\n             mir::BinOp::Shr => common::build_unchecked_rshift(bx, input_ty, lhs, rhs),"}, {"sha": "a936b62dd4eba4a218cbab6924a016195835ce25", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n use rustc_ast::ast;\n use rustc_attr::InstructionSetAttr;\n use rustc_data_structures::fx::FxHashMap;\n@@ -443,14 +444,10 @@ pub fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_s\n     if let DefKind::AssocFn = tcx.def_kind(id) {\n         let parent_id = tcx.local_parent(id);\n         if let DefKind::Trait | DefKind::Impl { of_trait: true } = tcx.def_kind(parent_id) {\n-            tcx.sess\n-                .struct_span_err(\n-                    attr_span,\n-                    \"`#[target_feature(..)]` cannot be applied to safe trait method\",\n-                )\n-                .span_label(attr_span, \"cannot be applied to safe trait method\")\n-                .span_label(tcx.def_span(id), \"not an `unsafe` function\")\n-                .emit();\n+            tcx.sess.emit_err(errors::TargetFeatureSafeTrait {\n+                span: attr_span,\n+                def: tcx.def_span(id),\n+            });\n         }\n     }\n }"}, {"sha": "74030a43c5053e6b23e1c16441c1bb634554460a", "filename": "compiler/rustc_const_eval/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -14,6 +14,7 @@ rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "99f180f475d6bf4da1efca94722bebd9636fd3aa", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -296,12 +296,12 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n     }\n \n     let cid = key.value;\n-    let def = cid.instance.def.with_opt_param();\n-    let is_static = tcx.is_static(def.did);\n+    let def = cid.instance.def.def_id();\n+    let is_static = tcx.is_static(def);\n \n     let mut ecx = InterpCx::new(\n         tcx,\n-        tcx.def_span(def.did),\n+        tcx.def_span(def),\n         key.param_env,\n         // Statics (and promoteds inside statics) may access other statics, because unlike consts\n         // they do not have to behave \"as if\" they were evaluated at runtime."}, {"sha": "814b67b46ec7a239e726a45add6304d62f662d03", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -375,9 +375,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     ) -> InterpResult<'tcx, &'tcx mir::Body<'tcx>> {\n         match instance {\n             ty::InstanceDef::Item(def) => {\n-                if ecx.tcx.is_ctfe_mir_available(def.did) {\n-                    Ok(ecx.tcx.mir_for_ctfe_opt_const_arg(def))\n-                } else if ecx.tcx.def_kind(def.did) == DefKind::AssocConst {\n+                if ecx.tcx.is_ctfe_mir_available(def) {\n+                    Ok(ecx.tcx.mir_for_ctfe(def))\n+                } else if ecx.tcx.def_kind(def) == DefKind::AssocConst {\n                     let guar = ecx.tcx.sess.delay_span_bug(\n                         rustc_span::DUMMY_SP,\n                         \"This is likely a const item that is missing from its impl\",\n@@ -386,7 +386,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 } else {\n                     // `find_mir_or_eval_fn` checks that this is a const fn before even calling us,\n                     // so this should be unreachable.\n-                    let path = ecx.tcx.def_path_str(def.did);\n+                    let path = ecx.tcx.def_path_str(def);\n                     bug!(\"trying to call extern function `{path}` at compile-time\");\n                 }\n             }\n@@ -410,9 +410,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             // Execution might have wandered off into other crates, so we cannot do a stability-\n             // sensitive check here. But we can at least rule out functions that are not const\n             // at all.\n-            if !ecx.tcx.is_const_fn_raw(def.did) {\n+            if !ecx.tcx.is_const_fn_raw(def) {\n                 // allow calling functions inside a trait marked with #[const_trait].\n-                if !ecx.tcx.is_const_default_method(def.did) {\n+                if !ecx.tcx.is_const_default_method(def) {\n                     // We certainly do *not* want to actually call the fn\n                     // though, so be sure we return here.\n                     throw_unsup_format!(\"calling non-const function `{}`\", instance)"}, {"sha": "015a9beab832d2d388bf90cb2f9752efbeb1f886", "filename": "compiler/rustc_const_eval/src/interpret/discriminant.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fdiscriminant.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -211,18 +211,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             let variant_index_relative = u32::try_from(variant_index_relative)\n                                 .expect(\"we checked that this fits into a u32\");\n                             // Then computing the absolute variant idx should not overflow any more.\n-                            let variant_index = variants_start\n-                                .checked_add(variant_index_relative)\n-                                .expect(\"overflow computing absolute variant idx\");\n-                            let variants_len = op\n+                            let variant_index = VariantIdx::from_u32(\n+                                variants_start\n+                                    .checked_add(variant_index_relative)\n+                                    .expect(\"overflow computing absolute variant idx\"),\n+                            );\n+                            let variants = op\n                                 .layout\n                                 .ty\n                                 .ty_adt_def()\n                                 .expect(\"tagged layout for non adt\")\n-                                .variants()\n-                                .len();\n-                            assert!(usize::try_from(variant_index).unwrap() < variants_len);\n-                            VariantIdx::from_u32(variant_index)\n+                                .variants();\n+                            assert!(variant_index < variants.next_index());\n+                            variant_index\n                         } else {\n                             untagged_variant\n                         }"}, {"sha": "361ce123c78eb904b95cbf02c4362f403e069e7a", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -5,7 +5,7 @@ use std::mem;\n use either::{Either, Left, Right};\n \n use rustc_hir::{self as hir, def_id::DefId, definitions::DefPathData};\n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{ErrorHandled, InterpError};\n use rustc_middle::ty::layout::{\n@@ -132,11 +132,10 @@ pub struct Frame<'mir, 'tcx, Prov: Provenance = AllocId, Extra = ()> {\n }\n \n /// What we store about a frame in an interpreter backtrace.\n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n pub struct FrameInfo<'tcx> {\n     pub instance: ty::Instance<'tcx>,\n     pub span: Span,\n-    pub lint_root: Option<hir::HirId>,\n }\n \n #[derive(Clone, Copy, Eq, PartialEq, Debug)] // Miri debug-prints these\n@@ -462,10 +461,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         instance: ty::InstanceDef<'tcx>,\n         promoted: Option<mir::Promoted>,\n     ) -> InterpResult<'tcx, &'tcx mir::Body<'tcx>> {\n-        let def = instance.with_opt_param();\n         trace!(\"load mir(instance={:?}, promoted={:?})\", instance, promoted);\n         let body = if let Some(promoted) = promoted {\n-            &self.tcx.promoted_mir_opt_const_arg(def)[promoted]\n+            let def = instance.def_id();\n+            &self.tcx.promoted_mir(def)[promoted]\n         } else {\n             M::load_mir(self, instance)?\n         };\n@@ -503,13 +502,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// The `substs` are assumed to already be in our interpreter \"universe\" (param_env).\n     pub(super) fn resolve(\n         &self,\n-        def: ty::WithOptConstParam<DefId>,\n+        def: DefId,\n         substs: SubstsRef<'tcx>,\n     ) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n         trace!(\"resolve: {:?}, {:#?}\", def, substs);\n         trace!(\"param_env: {:#?}\", self.param_env);\n         trace!(\"substs: {:#?}\", substs);\n-        match ty::Instance::resolve_opt_const_arg(*self.tcx, self.param_env, def, substs) {\n+        match ty::Instance::resolve(*self.tcx, self.param_env, def, substs) {\n             Ok(Some(instance)) => Ok(instance),\n             Ok(None) => throw_inval!(TooGeneric),\n \n@@ -947,10 +946,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // This deliberately does *not* honor `requires_caller_location` since it is used for much\n         // more than just panics.\n         for frame in stack.iter().rev() {\n-            let lint_root = frame.lint_root();\n             let span = frame.current_span();\n-\n-            frames.push(FrameInfo { span, instance: frame.instance, lint_root });\n+            frames.push(FrameInfo { span, instance: frame.instance });\n         }\n         trace!(\"generate stacktrace: {:#?}\", frames);\n         frames"}, {"sha": "a77c699c22f7e16ce80f290441dc7b5fa45577d4", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -75,7 +75,7 @@ pub(crate) fn eval_nullary_intrinsic<'tcx>(\n         }\n         sym::type_id => {\n             ensure_monomorphic_enough(tcx, tp_ty)?;\n-            ConstValue::from_u64(tcx.type_id_hash(tp_ty))\n+            ConstValue::from_u64(tcx.type_id_hash(tp_ty).as_u64())\n         }\n         sym::variant_count => match tp_ty.kind() {\n             // Correctly handles non-monomorphic calls, so there is no need for ensure_monomorphic_enough.\n@@ -286,14 +286,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::write_bytes => {\n                 self.write_bytes_intrinsic(&args[0], &args[1], &args[2])?;\n             }\n-            sym::offset => {\n-                let ptr = self.read_pointer(&args[0])?;\n-                let offset_count = self.read_target_isize(&args[1])?;\n-                let pointee_ty = substs.type_at(0);\n-\n-                let offset_ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n-                self.write_pointer(offset_ptr, dest)?;\n-            }\n             sym::arith_offset => {\n                 let ptr = self.read_pointer(&args[0])?;\n                 let offset_count = self.read_target_isize(&args[1])?;"}, {"sha": "b448e3a24c68fb71a66b3b6f1c9c14b7f277c091", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -104,7 +104,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     type FrameExtra;\n \n     /// Extra data stored in every allocation.\n-    type AllocExtra: Debug + Clone + 'static;\n+    type AllocExtra: Debug + Clone + 'tcx;\n \n     /// Type for the bytes of the allocation.\n     type Bytes: AllocBytes + 'static;"}, {"sha": "d5b6a581a79f6ef8f5f6620e498fd8f7b5c4e2ca", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -215,7 +215,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.allocate_raw_ptr(alloc, kind)\n     }\n \n-    /// This can fail only of `alloc` contains provenance.\n+    /// This can fail only if `alloc` contains provenance.\n     pub fn allocate_raw_ptr(\n         &mut self,\n         alloc: Allocation,\n@@ -807,9 +807,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         DumpAllocs { ecx: self, allocs }\n     }\n \n-    /// Print leaked memory. Allocations reachable from `static_roots` or a `Global` allocation\n-    /// are not considered leaked. Leaks whose kind `may_leak()` returns true are not reported.\n-    pub fn leak_report(&self, static_roots: &[AllocId]) -> usize {\n+    /// Find leaked allocations. Allocations reachable from `static_roots` or a `Global` allocation\n+    /// are not considered leaked, as well as leaks whose kind's `may_leak()` returns true.\n+    pub fn find_leaked_allocations(\n+        &self,\n+        static_roots: &[AllocId],\n+    ) -> Vec<(AllocId, MemoryKind<M::MemoryKind>, Allocation<M::Provenance, M::AllocExtra, M::Bytes>)>\n+    {\n         // Collect the set of allocations that are *reachable* from `Global` allocations.\n         let reachable = {\n             let mut reachable = FxHashSet::default();\n@@ -833,14 +837,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n \n         // All allocations that are *not* `reachable` and *not* `may_leak` are considered leaking.\n-        let leaks: Vec<_> = self.memory.alloc_map.filter_map_collect(|&id, &(kind, _)| {\n-            if kind.may_leak() || reachable.contains(&id) { None } else { Some(id) }\n-        });\n-        let n = leaks.len();\n-        if n > 0 {\n-            eprintln!(\"The following memory was leaked: {:?}\", self.dump_allocs(leaks));\n-        }\n-        n\n+        self.memory.alloc_map.filter_map_collect(|id, (kind, alloc)| {\n+            if kind.may_leak() || reachable.contains(id) {\n+                None\n+            } else {\n+                Some((*id, *kind, alloc.clone()))\n+            }\n+        })\n     }\n }\n "}, {"sha": "7186148daf0ba80c8f73abcf1abe28db2698a136", "filename": "compiler/rustc_const_eval/src/interpret/operator.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -299,6 +299,30 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok((val, false, ty))\n     }\n \n+    fn binary_ptr_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: &ImmTy<'tcx, M::Provenance>,\n+        right: &ImmTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<M::Provenance>, bool, Ty<'tcx>)> {\n+        use rustc_middle::mir::BinOp::*;\n+\n+        match bin_op {\n+            // Pointer ops that are always supported.\n+            Offset => {\n+                let ptr = left.to_scalar().to_pointer(self)?;\n+                let offset_count = right.to_scalar().to_target_isize(self)?;\n+                let pointee_ty = left.layout.ty.builtin_deref(true).unwrap().ty;\n+\n+                let offset_ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n+                Ok((Scalar::from_maybe_pointer(offset_ptr, self), false, left.layout.ty))\n+            }\n+\n+            // Fall back to machine hook so Miri can support more pointer ops.\n+            _ => M::binary_ptr_op(self, bin_op, left, right),\n+        }\n+    }\n+\n     /// Returns the result of the specified operation, whether it overflowed, and\n     /// the result type.\n     pub fn overflowing_binary_op(\n@@ -368,7 +392,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     right.layout.ty\n                 );\n \n-                M::binary_ptr_op(self, bin_op, left, right)\n+                self.binary_ptr_op(bin_op, left, right)\n             }\n             _ => span_bug!(\n                 self.cur_span(),"}, {"sha": "2a31a59ad6c7c5d6300b3f3f6ccf43f3ab7ec2f1", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -5,7 +5,7 @@\n use either::{Either, Left, Right};\n \n use rustc_ast::Mutability;\n-use rustc_index::vec::IndexSlice;\n+use rustc_index::IndexSlice;\n use rustc_middle::mir;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};"}, {"sha": "319b80d66e18eda264185a7eba8bd56e516e22c1", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -113,8 +113,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Intrinsic(box intrinsic) => self.emulate_nondiverging_intrinsic(intrinsic)?,\n \n-            // Statements we do not track.\n-            PlaceMention(..) | AscribeUserType(..) => {}\n+            // Evaluate the place expression, without reading from it.\n+            PlaceMention(box place) => {\n+                let _ = self.eval_place(*place)?;\n+            }\n+\n+            // This exists purely to guide borrowck lifetime inference, and does not have\n+            // an operational effect.\n+            AscribeUserType(..) => {}\n \n             // Currently, Miri discards Coverage statements. Coverage statements are only injected\n             // via an optional compile time MIR pass and have no side effects. Since Coverage\n@@ -280,20 +286,23 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_immediate(*val, &dest)?;\n             }\n \n-            NullaryOp(null_op, ty) => {\n+            NullaryOp(ref null_op, ty) => {\n                 let ty = self.subst_from_current_frame_and_normalize_erasing_regions(ty)?;\n                 let layout = self.layout_of(ty)?;\n-                if layout.is_unsized() {\n+                if let mir::NullOp::SizeOf | mir::NullOp::AlignOf = null_op && layout.is_unsized() {\n                     // FIXME: This should be a span_bug (#80742)\n                     self.tcx.sess.delay_span_bug(\n                         self.frame().current_span(),\n-                        &format!(\"Nullary MIR operator called for unsized type {}\", ty),\n+                        &format!(\"{null_op:?} MIR operator called for unsized type {ty}\"),\n                     );\n                     throw_inval!(SizeOfUnsizedType(ty));\n                 }\n                 let val = match null_op {\n                     mir::NullOp::SizeOf => layout.size.bytes(),\n                     mir::NullOp::AlignOf => layout.align.abi.bytes(),\n+                    mir::NullOp::OffsetOf(fields) => {\n+                        layout.offset_of_subfield(self, fields.iter().map(|f| f.index())).bytes()\n+                    }\n                 };\n                 self.write_scalar(Scalar::from_target_usize(val, self), &dest)?;\n             }"}, {"sha": "df3879200101b444bc6737b0db131b042024577d", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -83,8 +83,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         (fn_val, self.fn_abi_of_fn_ptr(fn_sig_binder, extra_args)?, false)\n                     }\n                     ty::FnDef(def_id, substs) => {\n-                        let instance =\n-                            self.resolve(ty::WithOptConstParam::unknown(def_id), substs)?;\n+                        let instance = self.resolve(def_id, substs)?;\n                         (\n                             FnVal::Instance(instance),\n                             self.fn_abi_of_instance(instance, extra_args)?,"}, {"sha": "22bdd4d2c3fbcd165088d7e0f2fd3c8eae02aeb3", "filename": "compiler/rustc_const_eval/src/interpret/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -14,7 +14,7 @@ where\n     T: TypeVisitable<TyCtxt<'tcx>>,\n {\n     debug!(\"ensure_monomorphic_enough: ty={:?}\", ty);\n-    if !ty.needs_subst() {\n+    if !ty.has_param() {\n         return Ok(());\n     }\n \n@@ -27,7 +27,7 @@ where\n         type BreakTy = FoundParam;\n \n         fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if !ty.needs_subst() {\n+            if !ty.has_param() {\n                 return ControlFlow::Continue(());\n             }\n \n@@ -36,7 +36,7 @@ where\n                 ty::Closure(def_id, substs)\n                 | ty::Generator(def_id, substs, ..)\n                 | ty::FnDef(def_id, substs) => {\n-                    let instance = ty::InstanceDef::Item(ty::WithOptConstParam::unknown(def_id));\n+                    let instance = ty::InstanceDef::Item(def_id);\n                     let unused_params = self.tcx.unused_generic_params(instance);\n                     for (index, subst) in substs.into_iter().enumerate() {\n                         let index = index\n@@ -46,7 +46,7 @@ where\n                         // are used and require substitution.\n                         // Just in case there are closures or generators within this subst,\n                         // recurse.\n-                        if unused_params.is_used(index) && subst.needs_subst() {\n+                        if unused_params.is_used(index) && subst.has_param() {\n                             return subst.visit_with(self);\n                         }\n                     }"}, {"sha": "e06b634cdc3309f2ff7b0ef9656d7b4c643a88b4", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -784,7 +784,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             Abi::Scalar(scalar_layout) => {\n                 if !scalar_layout.is_uninit_valid() {\n                     // There is something to check here.\n-                    let scalar = self.read_scalar(op, \"initiailized scalar value\")?;\n+                    let scalar = self.read_scalar(op, \"initialized scalar value\")?;\n                     self.visit_scalar(scalar, scalar_layout)?;\n                 }\n             }\n@@ -794,7 +794,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // the other must be init.\n                 if !a_layout.is_uninit_valid() && !b_layout.is_uninit_valid() {\n                     let (a, b) =\n-                        self.read_immediate(op, \"initiailized scalar value\")?.to_scalar_pair();\n+                        self.read_immediate(op, \"initialized scalar value\")?.to_scalar_pair();\n                     self.visit_scalar(a, a_layout)?;\n                     self.visit_scalar(b, b_layout)?;\n                 }"}, {"sha": "1b66eca97a5781cc6c1605969592ab57f6fa13a0", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -34,7 +34,7 @@ pub mod transform;\n pub mod util;\n \n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n-use rustc_macros::fluent_messages;\n+use rustc_fluent_macro::fluent_messages;\n use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n "}, {"sha": "696c4517700902779a9193c35fd338dfd5d3a68a", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -558,7 +558,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n             Rvalue::Cast(_, _, _) => {}\n \n-            Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) => {}\n+            Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf | NullOp::OffsetOf(_), _) => {}\n             Rvalue::ShallowInitBox(_, _) => {}\n \n             Rvalue::UnaryOp(_, operand) => {\n@@ -874,7 +874,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     debug!(\"Resolving ({:?}) -> {:?}\", callee, instance);\n                     if let Ok(Some(func)) = instance {\n                         if let InstanceDef::Item(def) = func.def {\n-                            callee = def.did;\n+                            callee = def;\n                         }\n                     }\n                 }"}, {"sha": "4fb668545712e58ae0a84807edb15b45015d578a", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -14,14 +14,14 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{suggest_constraining_type_param, Adt, Closure, FnDef, FnPtr, Param, Ty};\n use rustc_middle::ty::{Binder, TraitRef};\n+use rustc_middle::util::{call_kind, CallDesugaringKind, CallKind};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, Pos, Span, Symbol};\n use rustc_trait_selection::traits::SelectionContext;\n \n use super::ConstCx;\n use crate::errors;\n-use crate::util::{call_kind, CallDesugaringKind, CallKind};\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum Status {\n@@ -296,7 +296,7 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                 diag_trait(&mut err, self_ty, tcx.require_lang_item(LangItem::Deref, Some(span)));\n                 err\n             }\n-            _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentV1Methods) => ccx\n+            _ if tcx.opt_parent(callee) == tcx.get_diagnostic_item(sym::ArgumentMethods) => ccx\n                 .tcx\n                 .sess\n                 .create_err(errors::NonConstFmtMacroCall { span, kind: ccx.const_kind() }),\n@@ -610,10 +610,11 @@ pub struct RawPtrComparison;\n impl<'tcx> NonConstOp<'tcx> for RawPtrComparison {\n     fn build_error(\n         &self,\n-        _: &ConstCx<'_, 'tcx>,\n+        ccx: &ConstCx<'_, 'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        span_bug!(span, \"raw ptr comparison should already be caught in the trait system\");\n+        // FIXME(const_trait_impl): revert to span_bug?\n+        ccx.tcx.sess.create_err(errors::RawPtrComparisonErr { span })\n     }\n }\n "}, {"sha": "bf688f2b34e9d16fd9bbfd83bab1c0f1cb89d43b", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -364,9 +364,8 @@ where\n         assert!(promoted.is_none() || Q::ALLOW_PROMOTED);\n \n         // Don't peek inside trait associated constants.\n-        if promoted.is_none() && cx.tcx.trait_of_item(def.did).is_none() {\n-            assert_eq!(def.const_param_did, None, \"expected associated const: {def:?}\");\n-            let qualifs = cx.tcx.at(constant.span).mir_const_qualif(def.did);\n+        if promoted.is_none() && cx.tcx.trait_of_item(def).is_none() {\n+            let qualifs = cx.tcx.at(constant.span).mir_const_qualif(def);\n \n             if !Q::in_qualifs(&qualifs) {\n                 return false;"}, {"sha": "0e2d9ee8fb2fbd8c39a379f732cbbd70cbedf640", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, List, TyCtxt, TypeVisitableExt};\n use rustc_span::Span;\n \n-use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n+use rustc_index::{Idx, IndexSlice, IndexVec};\n \n use std::cell::Cell;\n use std::{cmp, iter, mem};\n@@ -514,6 +514,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n             Rvalue::NullaryOp(op, _) => match op {\n                 NullOp::SizeOf => {}\n                 NullOp::AlignOf => {}\n+                NullOp::OffsetOf(_) => {}\n             },\n \n             Rvalue::ShallowInitBox(_, _) => return Err(Unpromotable),\n@@ -828,15 +829,15 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn promote_candidate(mut self, candidate: Candidate, next_promoted_id: usize) -> Body<'tcx> {\n-        let def = self.source.source.with_opt_param();\n+        let def = self.source.source.def_id();\n         let mut rvalue = {\n             let promoted = &mut self.promoted;\n             let promoted_id = Promoted::new(next_promoted_id);\n             let tcx = self.tcx;\n             let mut promoted_operand = |ty, span| {\n                 promoted.span = span;\n                 promoted.local_decls[RETURN_PLACE] = LocalDecl::new(ty, span);\n-                let substs = tcx.erase_regions(InternalSubsts::identity_for_item(tcx, def.did));\n+                let substs = tcx.erase_regions(InternalSubsts::identity_for_item(tcx, def));\n                 let uneval = mir::UnevaluatedConst { def, substs, promoted: Some(promoted_id) };\n \n                 Operand::Constant(Box::new(Constant {"}, {"sha": "03ab2e568df8028101988b7ab65202d4b4b25c07", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 52, "deletions": 14, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -2,15 +2,16 @@\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_infer::traits::Reveal;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::visit::{NonUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{\n     traversal, BasicBlock, BinOp, Body, BorrowKind, CastKind, CopyNonOverlapping, Local, Location,\n-    MirPass, MirPhase, NonDivergingIntrinsic, Operand, Place, PlaceElem, PlaceRef, ProjectionElem,\n-    RetagKind, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind, Terminator,\n-    TerminatorKind, UnOp, UnwindAction, VarDebugInfo, VarDebugInfoContents, START_BLOCK,\n+    MirPass, MirPhase, NonDivergingIntrinsic, NullOp, Operand, Place, PlaceElem, PlaceRef,\n+    ProjectionElem, RetagKind, RuntimePhase, Rvalue, SourceScope, Statement, StatementKind,\n+    Terminator, TerminatorKind, UnOp, UnwindAction, VarDebugInfo, VarDebugInfoContents,\n+    START_BLOCK,\n };\n use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeVisitableExt};\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n@@ -262,7 +263,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // We sometimes have to use `defining_opaque_types` for subtyping\n         // to succeed here and figuring out how exactly that should work\n         // is annoying. It is harmless enough to just not validate anything\n-        // in that case. We still check this after analysis as all opque\n+        // in that case. We still check this after analysis as all opaque\n         // types have been revealed at this point.\n         if (src, dest).has_opaque_types() {\n             return true;\n@@ -711,10 +712,54 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n+            Rvalue::NullaryOp(NullOp::OffsetOf(fields), container) => {\n+                let fail_out_of_bounds = |this: &Self, location, field, ty| {\n+                    this.fail(location, format!(\"Out of bounds field {field:?} for {ty:?}\"));\n+                };\n+\n+                let mut current_ty = *container;\n+\n+                for field in fields.iter() {\n+                    match current_ty.kind() {\n+                        ty::Tuple(fields) => {\n+                            let Some(&f_ty) = fields.get(field.as_usize()) else {\n+                                fail_out_of_bounds(self, location, field, current_ty);\n+                                return;\n+                            };\n+\n+                            current_ty = self.tcx.normalize_erasing_regions(self.param_env, f_ty);\n+                        }\n+                        ty::Adt(adt_def, substs) => {\n+                            if adt_def.is_enum() {\n+                                self.fail(\n+                                    location,\n+                                    format!(\"Cannot get field offset from enum {current_ty:?}\"),\n+                                );\n+                                return;\n+                            }\n+\n+                            let Some(field) = adt_def.non_enum_variant().fields.get(field) else {\n+                                fail_out_of_bounds(self, location, field, current_ty);\n+                                return;\n+                            };\n+\n+                            let f_ty = field.ty(self.tcx, substs);\n+                            current_ty = self.tcx.normalize_erasing_regions(self.param_env, f_ty);\n+                        }\n+                        _ => {\n+                            self.fail(\n+                                location,\n+                                format!(\"Cannot get field offset from non-adt type {current_ty:?}\"),\n+                            );\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n             Rvalue::Repeat(_, _)\n             | Rvalue::ThreadLocalRef(_)\n             | Rvalue::AddressOf(_, _)\n-            | Rvalue::NullaryOp(_, _)\n+            | Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _)\n             | Rvalue::Discriminant(_) => {}\n         }\n         self.super_rvalue(rvalue, location);\n@@ -757,14 +802,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n-            StatementKind::PlaceMention(..) => {\n-                if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n-                    self.fail(\n-                        location,\n-                        \"`PlaceMention` should have been removed after drop lowering phase\",\n-                    );\n-                }\n-            }\n             StatementKind::AscribeUserType(..) => {\n                 if self.mir_phase >= MirPhase::Runtime(RuntimePhase::Initial) {\n                     self.fail(\n@@ -874,6 +911,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             StatementKind::StorageDead(_)\n             | StatementKind::Coverage(_)\n             | StatementKind::ConstEvalCounter\n+            | StatementKind::PlaceMention(..)\n             | StatementKind::Nop => {}\n         }\n "}, {"sha": "7641f560714d40052f1f28f11afd837d7c603290", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,14 +1,9 @@\n mod alignment;\n-mod call_kind;\n mod check_validity_requirement;\n-pub mod collect_writes;\n mod compare_types;\n-mod find_self_call;\n mod type_name;\n \n pub use self::alignment::is_disaligned;\n-pub use self::call_kind::{call_kind, CallDesugaringKind, CallKind};\n pub use self::check_validity_requirement::check_validity_requirement;\n pub use self::compare_types::{is_equal_up_to_subtyping, is_subtype};\n-pub use self::find_self_call::find_self_call;\n pub use self::type_name::type_name;"}, {"sha": "5e05fe463ed2bb5029a4fe35dcd990a8b5718648", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -21,13 +21,11 @@ rustc-hash = \"1.1.0\"\n rustc_index = { path = \"../rustc_index\", package = \"rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n-serde_json = \"1.0.59\"\n smallvec = { version = \"1.8.1\", features = [\n     \"const_generics\",\n     \"union\",\n     \"may_dangle\",\n ] }\n-stable_deref_trait = \"1.0.0\"\n stacker = \"0.1.15\"\n tempfile = \"3.2\"\n thin-vec = \"0.2.12\""}, {"sha": "0e5ecfd9bff6ea836dacdcc144e7e418abe4f45a", "filename": "compiler/rustc_data_structures/src/aligned.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Faligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Faligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Faligned.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,33 @@\n+use std::ptr::Alignment;\n+\n+/// Returns the ABI-required minimum alignment of a type in bytes.\n+///\n+/// This is equivalent to [`mem::align_of`], but also works for some unsized\n+/// types (e.g. slices or rustc's `List`s).\n+///\n+/// [`mem::align_of`]: std::mem::align_of\n+pub const fn align_of<T: ?Sized + Aligned>() -> Alignment {\n+    T::ALIGN\n+}\n+\n+/// A type with a statically known alignment.\n+///\n+/// # Safety\n+///\n+/// `Self::ALIGN` must be equal to the alignment of `Self`. For sized types it\n+/// is [`mem::align_of<Self>()`], for unsized types it depends on the type, for\n+/// example `[T]` has alignment of `T`.\n+///\n+/// [`mem::align_of<Self>()`]: std::mem::align_of\n+pub unsafe trait Aligned {\n+    /// Alignment of `Self`.\n+    const ALIGN: Alignment;\n+}\n+\n+unsafe impl<T> Aligned for T {\n+    const ALIGN: Alignment = Alignment::of::<Self>();\n+}\n+\n+unsafe impl<T> Aligned for [T] {\n+    const ALIGN: Alignment = Alignment::of::<T>();\n+}"}, {"sha": "6fa76981408ca93be2f5b39b61e2c981eaf5a04e", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,4 +1,4 @@\n-use crate::stable_hasher;\n+use crate::stable_hasher::{Hash64, StableHasher, StableHasherResult};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use std::hash::{Hash, Hasher};\n \n@@ -9,32 +9,49 @@ mod tests;\n #[repr(C)]\n pub struct Fingerprint(u64, u64);\n \n-impl Fingerprint {\n-    pub const ZERO: Fingerprint = Fingerprint(0, 0);\n+pub trait FingerprintComponent {\n+    fn as_u64(&self) -> u64;\n+}\n \n+impl FingerprintComponent for Hash64 {\n     #[inline]\n-    pub fn new(_0: u64, _1: u64) -> Fingerprint {\n-        Fingerprint(_0, _1)\n+    fn as_u64(&self) -> u64 {\n+        Hash64::as_u64(*self)\n+    }\n+}\n+\n+impl FingerprintComponent for u64 {\n+    #[inline]\n+    fn as_u64(&self) -> u64 {\n+        *self\n     }\n+}\n+\n+impl Fingerprint {\n+    pub const ZERO: Fingerprint = Fingerprint(0, 0);\n \n     #[inline]\n-    pub fn from_smaller_hash(hash: u64) -> Fingerprint {\n-        Fingerprint(hash, hash)\n+    pub fn new<A, B>(_0: A, _1: B) -> Fingerprint\n+    where\n+        A: FingerprintComponent,\n+        B: FingerprintComponent,\n+    {\n+        Fingerprint(_0.as_u64(), _1.as_u64())\n     }\n \n     #[inline]\n-    pub fn to_smaller_hash(&self) -> u64 {\n+    pub fn to_smaller_hash(&self) -> Hash64 {\n         // Even though both halves of the fingerprint are expected to be good\n         // quality hash values, let's still combine the two values because the\n         // Fingerprints in DefPathHash have the StableCrateId portion which is\n         // the same for all DefPathHashes from the same crate. Combining the\n         // two halves makes sure we get a good quality hash in such cases too.\n-        self.0.wrapping_mul(3).wrapping_add(self.1)\n+        Hash64::new(self.0.wrapping_mul(3).wrapping_add(self.1))\n     }\n \n     #[inline]\n-    pub fn as_value(&self) -> (u64, u64) {\n-        (self.0, self.1)\n+    pub fn split(&self) -> (Hash64, Hash64) {\n+        (Hash64::new(self.0), Hash64::new(self.1))\n     }\n \n     #[inline]\n@@ -131,9 +148,9 @@ impl FingerprintHasher for crate::unhash::Unhasher {\n     }\n }\n \n-impl stable_hasher::StableHasherResult for Fingerprint {\n+impl StableHasherResult for Fingerprint {\n     #[inline]\n-    fn finish(hasher: stable_hasher::StableHasher) -> Self {\n+    fn finish(hasher: StableHasher) -> Self {\n         let (_0, _1) = hasher.finalize();\n         Fingerprint(_0, _1)\n     }"}, {"sha": "09ec2622a651d448008e3b4c1e5d25ec4613e0c5", "filename": "compiler/rustc_data_structures/src/fingerprint/tests.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint%2Ftests.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,11 +1,12 @@\n use super::*;\n+use crate::stable_hasher::Hash64;\n \n // Check that `combine_commutative` is order independent.\n #[test]\n fn combine_commutative_is_order_independent() {\n-    let a = Fingerprint::new(0xf6622fb349898b06, 0x70be9377b2f9c610);\n-    let b = Fingerprint::new(0xa9562bf5a2a5303c, 0x67d9b6c82034f13d);\n-    let c = Fingerprint::new(0x0d013a27811dbbc3, 0x9a3f7b3d9142ec43);\n+    let a = Fingerprint::new(Hash64::new(0xf6622fb349898b06), Hash64::new(0x70be9377b2f9c610));\n+    let b = Fingerprint::new(Hash64::new(0xa9562bf5a2a5303c), Hash64::new(0x67d9b6c82034f13d));\n+    let c = Fingerprint::new(Hash64::new(0x0d013a27811dbbc3), Hash64::new(0x9a3f7b3d9142ec43));\n     let permutations = [(a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), (c, b, a)];\n     let f = a.combine_commutative(b).combine_commutative(c);\n     for p in &permutations {"}, {"sha": "e3fcaccb1bd5f4aff0947f5c92b32aa9a8a6ca8b", "filename": "compiler/rustc_data_structures/src/functor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffunctor.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,4 +1,4 @@\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::{Idx, IndexVec};\n use std::{mem, rc::Rc, sync::Arc};\n \n pub trait IdFunctor: Sized {"}, {"sha": "e76bdac286411b3b499f117868e300f5dc58fee4", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -10,7 +10,8 @@\n //! <https://www.cs.princeton.edu/courses/archive/spr03/cs423/download/dominators.pdf>\n \n use super::ControlFlowGraph;\n-use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n+use rustc_index::{Idx, IndexSlice, IndexVec};\n+\n use std::cmp::Ordering;\n \n #[cfg(test)]"}, {"sha": "9eb4b5278c07940b30863d5356d2f757a091fc43", "filename": "compiler/rustc_data_structures/src/graph/iterate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,6 +1,6 @@\n use super::{DirectedGraph, WithNumNodes, WithStartNode, WithSuccessors};\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::{IndexSlice, IndexVec};\n+use rustc_index::{IndexSlice, IndexVec};\n use std::ops::ControlFlow;\n \n #[cfg(test)]"}, {"sha": "e06ab2fe36b92571c06815b1c5e6df4b465e845c", "filename": "compiler/rustc_data_structures/src/graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,4 +1,4 @@\n-use rustc_index::vec::Idx;\n+use rustc_index::Idx;\n \n pub mod dominators;\n pub mod implementation;"}, {"sha": "cf9312ea8fb64a95115e7c0765a15a602127438f", "filename": "compiler/rustc_data_structures/src/graph/scc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -8,7 +8,7 @@\n use crate::fx::FxHashSet;\n use crate::graph::vec_graph::VecGraph;\n use crate::graph::{DirectedGraph, GraphSuccessors, WithNumEdges, WithNumNodes, WithSuccessors};\n-use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n+use rustc_index::{Idx, IndexSlice, IndexVec};\n use std::ops::Range;\n \n #[cfg(test)]"}, {"sha": "00f6266ce1df7d28aa41e47b0cc4d26d255609e4", "filename": "compiler/rustc_data_structures/src/graph/vec_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,5 +1,5 @@\n use crate::graph::{DirectedGraph, GraphSuccessors, WithNumEdges, WithNumNodes, WithSuccessors};\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::{Idx, IndexVec};\n \n #[cfg(test)]\n mod tests;"}, {"sha": "ad068cdbc9841eccab6f8f1597e074b6532b3ec2", "filename": "compiler/rustc_data_structures/src/hashes.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fhashes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fhashes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fhashes.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,132 @@\n+//! rustc encodes a lot of hashes. If hashes are stored as `u64` or `u128`, a `derive(Encodable)`\n+//! will apply varint encoding to the hashes, which is less efficient than directly encoding the 8\n+//! or 16 bytes of the hash.\n+//!\n+//! The types in this module represent 64-bit or 128-bit hashes produced by a `StableHasher`.\n+//! `Hash64` and `Hash128` expose some utilty functions to encourage users to not extract the inner\n+//! hash value as an integer type and accidentally apply varint encoding to it.\n+//!\n+//! In contrast with `Fingerprint`, users of these types cannot and should not attempt to construct\n+//! and decompose these types into constitutent pieces. The point of these types is only to\n+//! connect the fact that they can only be produced by a `StableHasher` to their\n+//! `Encode`/`Decode` impls.\n+\n+use crate::stable_hasher::{StableHasher, StableHasherResult};\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use std::fmt;\n+use std::ops::BitXorAssign;\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]\n+pub struct Hash64 {\n+    inner: u64,\n+}\n+\n+impl Hash64 {\n+    pub const ZERO: Hash64 = Hash64 { inner: 0 };\n+\n+    #[inline]\n+    pub(crate) fn new(n: u64) -> Self {\n+        Self { inner: n }\n+    }\n+\n+    #[inline]\n+    pub fn as_u64(self) -> u64 {\n+        self.inner\n+    }\n+}\n+\n+impl BitXorAssign<u64> for Hash64 {\n+    #[inline]\n+    fn bitxor_assign(&mut self, rhs: u64) {\n+        self.inner ^= rhs;\n+    }\n+}\n+\n+impl<S: Encoder> Encodable<S> for Hash64 {\n+    #[inline]\n+    fn encode(&self, s: &mut S) {\n+        s.emit_raw_bytes(&self.inner.to_le_bytes());\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for Hash64 {\n+    #[inline]\n+    fn decode(d: &mut D) -> Self {\n+        Self { inner: u64::from_le_bytes(d.read_raw_bytes(8).try_into().unwrap()) }\n+    }\n+}\n+\n+impl StableHasherResult for Hash64 {\n+    #[inline]\n+    fn finish(hasher: StableHasher) -> Self {\n+        Self { inner: hasher.finalize().0 }\n+    }\n+}\n+\n+impl fmt::Debug for Hash64 {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.inner.fmt(f)\n+    }\n+}\n+\n+impl fmt::LowerHex for Hash64 {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::LowerHex::fmt(&self.inner, f)\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]\n+pub struct Hash128 {\n+    inner: u128,\n+}\n+\n+impl Hash128 {\n+    #[inline]\n+    pub fn truncate(self) -> Hash64 {\n+        Hash64 { inner: self.inner as u64 }\n+    }\n+\n+    #[inline]\n+    pub fn wrapping_add(self, other: Self) -> Self {\n+        Self { inner: self.inner.wrapping_add(other.inner) }\n+    }\n+\n+    #[inline]\n+    pub fn as_u128(self) -> u128 {\n+        self.inner\n+    }\n+}\n+\n+impl<S: Encoder> Encodable<S> for Hash128 {\n+    #[inline]\n+    fn encode(&self, s: &mut S) {\n+        s.emit_raw_bytes(&self.inner.to_le_bytes());\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for Hash128 {\n+    #[inline]\n+    fn decode(d: &mut D) -> Self {\n+        Self { inner: u128::from_le_bytes(d.read_raw_bytes(16).try_into().unwrap()) }\n+    }\n+}\n+\n+impl StableHasherResult for Hash128 {\n+    #[inline]\n+    fn finish(hasher: StableHasher) -> Self {\n+        let (_0, _1) = hasher.finalize();\n+        Self { inner: u128::from(_0) | (u128::from(_1) << 64) }\n+    }\n+}\n+\n+impl fmt::Debug for Hash128 {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.inner.fmt(f)\n+    }\n+}\n+\n+impl fmt::LowerHex for Hash128 {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::LowerHex::fmt(&self.inner, f)\n+    }\n+}"}, {"sha": "004017ec5f31a464a76d3671bd36eca613d8760f", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -29,10 +29,14 @@\n #![feature(get_mut_unchecked)]\n #![feature(lint_reasons)]\n #![feature(unwrap_infallible)]\n+#![feature(strict_provenance)]\n+#![feature(ptr_alignment_type)]\n+#![feature(macro_metavar_expr)]\n #![allow(rustc::default_hash_types)]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n #[macro_use]\n extern crate tracing;\n@@ -82,7 +86,9 @@ pub mod transitive_relation;\n pub mod vec_linked_list;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n+pub mod aligned;\n pub mod frozen;\n+mod hashes;\n pub mod owned_slice;\n pub mod sso;\n pub mod steal;"}, {"sha": "ca908671ae5307b6d78bfc6424040781b1f156bd", "filename": "compiler/rustc_data_structures/src/memmap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fmemmap.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -13,7 +13,8 @@ pub struct Mmap(Vec<u8>);\n impl Mmap {\n     #[inline]\n     pub unsafe fn map(file: File) -> io::Result<Self> {\n-        memmap2::Mmap::map(&file).map(Mmap)\n+        // Safety: this is in fact not safe.\n+        unsafe { memmap2::Mmap::map(&file).map(Mmap) }\n     }\n }\n "}, {"sha": "572bd4ac21c32230d7befa002413b44bf628ed51", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -87,6 +87,7 @@ use crate::fx::FxHashMap;\n use std::borrow::Borrow;\n use std::collections::hash_map::Entry;\n use std::error::Error;\n+use std::fmt::Display;\n use std::fs;\n use std::intrinsics::unlikely;\n use std::path::Path;\n@@ -97,7 +98,6 @@ use std::time::{Duration, Instant};\n pub use measureme::EventId;\n use measureme::{EventIdBuilder, Profiler, SerializableString, StringId};\n use parking_lot::RwLock;\n-use serde_json::json;\n use smallvec::SmallVec;\n \n bitflags::bitflags! {\n@@ -557,7 +557,7 @@ impl SelfProfiler {\n         let crate_name = crate_name.unwrap_or(\"unknown-crate\");\n         // HACK(eddyb) we need to pad the PID, strange as it may seem, as its\n         // length can behave as a source of entropy for heap addresses, when\n-        // ASLR is disabled and the heap is otherwise determinic.\n+        // ASLR is disabled and the heap is otherwise deterministic.\n         let pid: u32 = process::id();\n         let filename = format!(\"{crate_name}-{pid:07}.rustc_profile\");\n         let path = output_directory.join(&filename);\n@@ -763,6 +763,31 @@ impl Drop for VerboseTimingGuard<'_> {\n     }\n }\n \n+struct JsonTimePassesEntry<'a> {\n+    pass: &'a str,\n+    time: f64,\n+    start_rss: Option<usize>,\n+    end_rss: Option<usize>,\n+}\n+\n+impl Display for JsonTimePassesEntry<'_> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        let Self { pass: what, time, start_rss, end_rss } = self;\n+        write!(f, r#\"{{\"pass\":\"{what}\",\"time\":{time},\"rss_start\":\"#).unwrap();\n+        match start_rss {\n+            Some(rss) => write!(f, \"{rss}\")?,\n+            None => write!(f, \"null\")?,\n+        }\n+        write!(f, r#\",\"rss_end\":\"#)?;\n+        match end_rss {\n+            Some(rss) => write!(f, \"{rss}\")?,\n+            None => write!(f, \"null\")?,\n+        }\n+        write!(f, \"}}\")?;\n+        Ok(())\n+    }\n+}\n+\n pub fn print_time_passes_entry(\n     what: &str,\n     dur: Duration,\n@@ -772,13 +797,10 @@ pub fn print_time_passes_entry(\n ) {\n     match format {\n         TimePassesFormat::Json => {\n-            let json = json!({\n-                \"pass\": what,\n-                \"time\": dur.as_secs_f64(),\n-                \"rss_start\": start_rss,\n-                \"rss_end\": end_rss,\n-            });\n-            eprintln!(\"time: {json}\");\n+            let entry =\n+                JsonTimePassesEntry { pass: what, time: dur.as_secs_f64(), start_rss, end_rss };\n+\n+            eprintln!(r#\"time: {entry}\"#);\n             return;\n         }\n         TimePassesFormat::Text => (),\n@@ -894,3 +916,6 @@ cfg_if! {\n         }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "2b09de085da061a752a1c9c0085e2f65082dc899", "filename": "compiler/rustc_data_structures/src/profiling/tests.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling%2Ftests.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,19 @@\n+use super::JsonTimePassesEntry;\n+\n+#[test]\n+fn with_rss() {\n+    let entry =\n+        JsonTimePassesEntry { pass: \"typeck\", time: 56.1, start_rss: Some(10), end_rss: Some(20) };\n+\n+    assert_eq!(entry.to_string(), r#\"{\"pass\":\"typeck\",\"time\":56.1,\"rss_start\":10,\"rss_end\":20}\"#)\n+}\n+\n+#[test]\n+fn no_rss() {\n+    let entry = JsonTimePassesEntry { pass: \"typeck\", time: 56.1, start_rss: None, end_rss: None };\n+\n+    assert_eq!(\n+        entry.to_string(),\n+        r#\"{\"pass\":\"typeck\",\"time\":56.1,\"rss_start\":null,\"rss_end\":null}\"#\n+    )\n+}"}, {"sha": "7ed70ba1e0fc7737a78af1e2a08842919f316922", "filename": "compiler/rustc_data_structures/src/sharded.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,14 +1,10 @@\n use crate::fx::{FxHashMap, FxHasher};\n-use crate::sync::{Lock, LockGuard};\n+use crate::sync::{CacheAligned, Lock, LockGuard};\n use std::borrow::Borrow;\n use std::collections::hash_map::RawEntryMut;\n use std::hash::{Hash, Hasher};\n use std::mem;\n \n-#[derive(Default)]\n-#[cfg_attr(parallel_compiler, repr(align(64)))]\n-struct CacheAligned<T>(T);\n-\n #[cfg(parallel_compiler)]\n // 32 shards is sufficient to reduce contention on an 8-core Ryzen 7 1700,\n // but this should be tested on higher core count CPUs. How the `Sharded` type gets used"}, {"sha": "4a0ed87f77c84e78c3a011b1cbc374062d573c4b", "filename": "compiler/rustc_data_structures/src/sip128.rs", "status": "modified", "additions": 101, "deletions": 95, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -96,28 +96,30 @@ macro_rules! compress {\n unsafe fn copy_nonoverlapping_small(src: *const u8, dst: *mut u8, count: usize) {\n     debug_assert!(count <= 8);\n \n-    if count == 8 {\n-        ptr::copy_nonoverlapping(src, dst, 8);\n-        return;\n-    }\n+    unsafe {\n+        if count == 8 {\n+            ptr::copy_nonoverlapping(src, dst, 8);\n+            return;\n+        }\n \n-    let mut i = 0;\n-    if i + 3 < count {\n-        ptr::copy_nonoverlapping(src.add(i), dst.add(i), 4);\n-        i += 4;\n-    }\n+        let mut i = 0;\n+        if i + 3 < count {\n+            ptr::copy_nonoverlapping(src.add(i), dst.add(i), 4);\n+            i += 4;\n+        }\n \n-    if i + 1 < count {\n-        ptr::copy_nonoverlapping(src.add(i), dst.add(i), 2);\n-        i += 2\n-    }\n+        if i + 1 < count {\n+            ptr::copy_nonoverlapping(src.add(i), dst.add(i), 2);\n+            i += 2\n+        }\n \n-    if i < count {\n-        *dst.add(i) = *src.add(i);\n-        i += 1;\n-    }\n+        if i < count {\n+            *dst.add(i) = *src.add(i);\n+            i += 1;\n+        }\n \n-    debug_assert_eq!(i, count);\n+        debug_assert_eq!(i, count);\n+    }\n }\n \n // # Implementation\n@@ -232,38 +234,40 @@ impl SipHasher128 {\n     // overflow) if it wasn't already.\n     #[inline(never)]\n     unsafe fn short_write_process_buffer<const LEN: usize>(&mut self, bytes: [u8; LEN]) {\n-        let nbuf = self.nbuf;\n-        debug_assert!(LEN <= 8);\n-        debug_assert!(nbuf < BUFFER_SIZE);\n-        debug_assert!(nbuf + LEN >= BUFFER_SIZE);\n-        debug_assert!(nbuf + LEN < BUFFER_WITH_SPILL_SIZE);\n+        unsafe {\n+            let nbuf = self.nbuf;\n+            debug_assert!(LEN <= 8);\n+            debug_assert!(nbuf < BUFFER_SIZE);\n+            debug_assert!(nbuf + LEN >= BUFFER_SIZE);\n+            debug_assert!(nbuf + LEN < BUFFER_WITH_SPILL_SIZE);\n+\n+            // Copy first part of input into end of buffer, possibly into spill\n+            // element. The memcpy call is optimized away because the size is known.\n+            let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);\n+            ptr::copy_nonoverlapping(bytes.as_ptr(), dst, LEN);\n+\n+            // Process buffer.\n+            for i in 0..BUFFER_CAPACITY {\n+                let elem = self.buf.get_unchecked(i).assume_init().to_le();\n+                self.state.v3 ^= elem;\n+                Sip13Rounds::c_rounds(&mut self.state);\n+                self.state.v0 ^= elem;\n+            }\n \n-        // Copy first part of input into end of buffer, possibly into spill\n-        // element. The memcpy call is optimized away because the size is known.\n-        let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);\n-        ptr::copy_nonoverlapping(bytes.as_ptr(), dst, LEN);\n-\n-        // Process buffer.\n-        for i in 0..BUFFER_CAPACITY {\n-            let elem = self.buf.get_unchecked(i).assume_init().to_le();\n-            self.state.v3 ^= elem;\n-            Sip13Rounds::c_rounds(&mut self.state);\n-            self.state.v0 ^= elem;\n+            // Copy remaining input into start of buffer by copying LEN - 1\n+            // elements from spill (at most LEN - 1 bytes could have overflowed\n+            // into the spill). The memcpy call is optimized away because the size\n+            // is known. And the whole copy is optimized away for LEN == 1.\n+            let dst = self.buf.as_mut_ptr() as *mut u8;\n+            let src = self.buf.get_unchecked(BUFFER_SPILL_INDEX) as *const _ as *const u8;\n+            ptr::copy_nonoverlapping(src, dst, LEN - 1);\n+\n+            // This function should only be called when the write fills the buffer.\n+            // Therefore, when LEN == 1, the new `self.nbuf` must be zero.\n+            // LEN is statically known, so the branch is optimized away.\n+            self.nbuf = if LEN == 1 { 0 } else { nbuf + LEN - BUFFER_SIZE };\n+            self.processed += BUFFER_SIZE;\n         }\n-\n-        // Copy remaining input into start of buffer by copying LEN - 1\n-        // elements from spill (at most LEN - 1 bytes could have overflowed\n-        // into the spill). The memcpy call is optimized away because the size\n-        // is known. And the whole copy is optimized away for LEN == 1.\n-        let dst = self.buf.as_mut_ptr() as *mut u8;\n-        let src = self.buf.get_unchecked(BUFFER_SPILL_INDEX) as *const _ as *const u8;\n-        ptr::copy_nonoverlapping(src, dst, LEN - 1);\n-\n-        // This function should only be called when the write fills the buffer.\n-        // Therefore, when LEN == 1, the new `self.nbuf` must be zero.\n-        // LEN is statically known, so the branch is optimized away.\n-        self.nbuf = if LEN == 1 { 0 } else { nbuf + LEN - BUFFER_SIZE };\n-        self.processed += BUFFER_SIZE;\n     }\n \n     // A write function for byte slices.\n@@ -301,57 +305,59 @@ impl SipHasher128 {\n     // containing the byte offset `self.nbuf`.\n     #[inline(never)]\n     unsafe fn slice_write_process_buffer(&mut self, msg: &[u8]) {\n-        let length = msg.len();\n-        let nbuf = self.nbuf;\n-        debug_assert!(nbuf < BUFFER_SIZE);\n-        debug_assert!(nbuf + length >= BUFFER_SIZE);\n-\n-        // Always copy first part of input into current element of buffer.\n-        // This function should only be called when the write fills the buffer,\n-        // so we know that there is enough input to fill the current element.\n-        let valid_in_elem = nbuf % ELEM_SIZE;\n-        let needed_in_elem = ELEM_SIZE - valid_in_elem;\n-\n-        let src = msg.as_ptr();\n-        let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);\n-        copy_nonoverlapping_small(src, dst, needed_in_elem);\n-\n-        // Process buffer.\n+        unsafe {\n+            let length = msg.len();\n+            let nbuf = self.nbuf;\n+            debug_assert!(nbuf < BUFFER_SIZE);\n+            debug_assert!(nbuf + length >= BUFFER_SIZE);\n+\n+            // Always copy first part of input into current element of buffer.\n+            // This function should only be called when the write fills the buffer,\n+            // so we know that there is enough input to fill the current element.\n+            let valid_in_elem = nbuf % ELEM_SIZE;\n+            let needed_in_elem = ELEM_SIZE - valid_in_elem;\n+\n+            let src = msg.as_ptr();\n+            let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);\n+            copy_nonoverlapping_small(src, dst, needed_in_elem);\n+\n+            // Process buffer.\n+\n+            // Using `nbuf / ELEM_SIZE + 1` rather than `(nbuf + needed_in_elem) /\n+            // ELEM_SIZE` to show the compiler that this loop's upper bound is > 0.\n+            // We know that is true, because last step ensured we have a full\n+            // element in the buffer.\n+            let last = nbuf / ELEM_SIZE + 1;\n+\n+            for i in 0..last {\n+                let elem = self.buf.get_unchecked(i).assume_init().to_le();\n+                self.state.v3 ^= elem;\n+                Sip13Rounds::c_rounds(&mut self.state);\n+                self.state.v0 ^= elem;\n+            }\n \n-        // Using `nbuf / ELEM_SIZE + 1` rather than `(nbuf + needed_in_elem) /\n-        // ELEM_SIZE` to show the compiler that this loop's upper bound is > 0.\n-        // We know that is true, because last step ensured we have a full\n-        // element in the buffer.\n-        let last = nbuf / ELEM_SIZE + 1;\n+            // Process the remaining element-sized chunks of input.\n+            let mut processed = needed_in_elem;\n+            let input_left = length - processed;\n+            let elems_left = input_left / ELEM_SIZE;\n+            let extra_bytes_left = input_left % ELEM_SIZE;\n+\n+            for _ in 0..elems_left {\n+                let elem = (msg.as_ptr().add(processed) as *const u64).read_unaligned().to_le();\n+                self.state.v3 ^= elem;\n+                Sip13Rounds::c_rounds(&mut self.state);\n+                self.state.v0 ^= elem;\n+                processed += ELEM_SIZE;\n+            }\n \n-        for i in 0..last {\n-            let elem = self.buf.get_unchecked(i).assume_init().to_le();\n-            self.state.v3 ^= elem;\n-            Sip13Rounds::c_rounds(&mut self.state);\n-            self.state.v0 ^= elem;\n-        }\n+            // Copy remaining input into start of buffer.\n+            let src = msg.as_ptr().add(processed);\n+            let dst = self.buf.as_mut_ptr() as *mut u8;\n+            copy_nonoverlapping_small(src, dst, extra_bytes_left);\n \n-        // Process the remaining element-sized chunks of input.\n-        let mut processed = needed_in_elem;\n-        let input_left = length - processed;\n-        let elems_left = input_left / ELEM_SIZE;\n-        let extra_bytes_left = input_left % ELEM_SIZE;\n-\n-        for _ in 0..elems_left {\n-            let elem = (msg.as_ptr().add(processed) as *const u64).read_unaligned().to_le();\n-            self.state.v3 ^= elem;\n-            Sip13Rounds::c_rounds(&mut self.state);\n-            self.state.v0 ^= elem;\n-            processed += ELEM_SIZE;\n+            self.nbuf = extra_bytes_left;\n+            self.processed += nbuf + processed;\n         }\n-\n-        // Copy remaining input into start of buffer.\n-        let src = msg.as_ptr().add(processed);\n-        let dst = self.buf.as_mut_ptr() as *mut u8;\n-        copy_nonoverlapping_small(src, dst, extra_bytes_left);\n-\n-        self.nbuf = extra_bytes_left;\n-        self.processed += nbuf + processed;\n     }\n \n     #[inline]"}, {"sha": "c172ee1c9706608322445772cd5bb6c4f3b64b65", "filename": "compiler/rustc_data_structures/src/sorted_map/index_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -3,7 +3,7 @@\n use std::hash::{Hash, Hasher};\n \n use crate::stable_hasher::{HashStable, StableHasher};\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::{Idx, IndexVec};\n \n /// An indexed multi-map that preserves insertion order while permitting both *O*(log *n*) lookup of\n /// an item by key and *O*(1) lookup by index."}, {"sha": "99581ed2375903f3f096fdea42e5b58d11d7bedf", "filename": "compiler/rustc_data_structures/src/sso/map.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -256,12 +256,9 @@ impl<K: Eq + Hash, V> SsoHashMap<K, V> {\n     pub fn remove(&mut self, key: &K) -> Option<V> {\n         match self {\n             SsoHashMap::Array(array) => {\n-                if let Some(index) = array.iter().position(|(k, _v)| k == key) {\n-                    Some(array.swap_remove(index).1)\n-                } else {\n-                    None\n-                }\n+                array.iter().position(|(k, _v)| k == key).map(|index| array.swap_remove(index).1)\n             }\n+\n             SsoHashMap::Map(map) => map.remove(key),\n         }\n     }"}, {"sha": "6d57d81c56a4bd213a7ace408b96d0be82b204df", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,14 +1,17 @@\n use crate::sip128::SipHasher128;\n-use rustc_index::bit_set;\n-use rustc_index::vec;\n+use rustc_index::bit_set::{self, BitSet};\n+use rustc_index::{Idx, IndexVec};\n use smallvec::SmallVec;\n+use std::fmt;\n use std::hash::{BuildHasher, Hash, Hasher};\n use std::marker::PhantomData;\n use std::mem;\n \n #[cfg(test)]\n mod tests;\n \n+pub use crate::hashes::{Hash128, Hash64};\n+\n /// When hashing something that ends up affecting properties like symbol names,\n /// we want these symbol names to be calculated independently of other factors\n /// like what architecture you're compiling *from*.\n@@ -20,8 +23,8 @@ pub struct StableHasher {\n     state: SipHasher128,\n }\n \n-impl ::std::fmt::Debug for StableHasher {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+impl fmt::Debug for StableHasher {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{:?}\", self.state)\n     }\n }\n@@ -42,21 +45,6 @@ impl StableHasher {\n     }\n }\n \n-impl StableHasherResult for u128 {\n-    #[inline]\n-    fn finish(hasher: StableHasher) -> Self {\n-        let (_0, _1) = hasher.finalize();\n-        u128::from(_0) | (u128::from(_1) << 64)\n-    }\n-}\n-\n-impl StableHasherResult for u64 {\n-    #[inline]\n-    fn finish(hasher: StableHasher) -> Self {\n-        hasher.finalize().0\n-    }\n-}\n-\n impl StableHasher {\n     #[inline]\n     pub fn finalize(self) -> (u64, u64) {\n@@ -107,7 +95,8 @@ impl Hasher for StableHasher {\n \n     #[inline]\n     fn write_u128(&mut self, i: u128) {\n-        self.state.write(&i.to_le_bytes());\n+        self.write_u64(i as u64);\n+        self.write_u64((i >> 64) as u64);\n     }\n \n     #[inline]\n@@ -286,6 +275,9 @@ impl_stable_traits_for_trivial_type!(i128);\n impl_stable_traits_for_trivial_type!(char);\n impl_stable_traits_for_trivial_type!(());\n \n+impl_stable_traits_for_trivial_type!(Hash64);\n+impl_stable_traits_for_trivial_type!(Hash128);\n+\n impl<CTX> HashStable<CTX> for ! {\n     fn hash_stable(&self, _ctx: &mut CTX, _hasher: &mut StableHasher) {\n         unreachable!()\n@@ -565,7 +557,7 @@ where\n     }\n }\n \n-impl<I: vec::Idx, T, CTX> HashStable<CTX> for vec::IndexVec<I, T>\n+impl<I: Idx, T, CTX> HashStable<CTX> for IndexVec<I, T>\n where\n     T: HashStable<CTX>,\n {\n@@ -577,13 +569,13 @@ where\n     }\n }\n \n-impl<I: vec::Idx, CTX> HashStable<CTX> for bit_set::BitSet<I> {\n+impl<I: Idx, CTX> HashStable<CTX> for BitSet<I> {\n     fn hash_stable(&self, _ctx: &mut CTX, hasher: &mut StableHasher) {\n         ::std::hash::Hash::hash(self, hasher);\n     }\n }\n \n-impl<R: vec::Idx, C: vec::Idx, CTX> HashStable<CTX> for bit_set::BitMatrix<R, C> {\n+impl<R: Idx, C: Idx, CTX> HashStable<CTX> for bit_set::BitMatrix<R, C> {\n     fn hash_stable(&self, _ctx: &mut CTX, hasher: &mut StableHasher) {\n         ::std::hash::Hash::hash(self, hasher);\n     }\n@@ -668,7 +660,7 @@ fn stable_hash_reduce<HCX, I, C, F>(\n                 .map(|value| {\n                     let mut hasher = StableHasher::new();\n                     hash_function(&mut hasher, hcx, value);\n-                    hasher.finish::<u128>()\n+                    hasher.finish::<Hash128>()\n                 })\n                 .reduce(|accum, value| accum.wrapping_add(value));\n             hash.hash_stable(hcx, hasher);"}, {"sha": "c8921f6a7784fbb9c9f4784fd1ee516cecc8018c", "filename": "compiler/rustc_data_structures/src/stable_hasher/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -72,7 +72,7 @@ fn test_hash_isize() {\n     assert_eq!(h.finalize(), expected);\n }\n \n-fn hash<T: HashStable<()>>(t: &T) -> u128 {\n+fn hash<T: HashStable<()>>(t: &T) -> Hash128 {\n     let mut h = StableHasher::new();\n     let ctx = &mut ();\n     t.hash_stable(ctx, &mut h);"}, {"sha": "a3d2724fcdbbb94cb90a4ad004c62643ed0712d8", "filename": "compiler/rustc_data_structures/src/svh.rs", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsvh.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -5,40 +5,30 @@\n //! mismatches where we have two versions of the same crate that were\n //! compiled from distinct sources.\n \n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n+use crate::fingerprint::Fingerprint;\n use std::fmt;\n-use std::hash::{Hash, Hasher};\n \n use crate::stable_hasher;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Encodable, Decodable, Hash)]\n pub struct Svh {\n-    hash: u64,\n+    hash: Fingerprint,\n }\n \n impl Svh {\n     /// Creates a new `Svh` given the hash. If you actually want to\n     /// compute the SVH from some HIR, you want the `calculate_svh`\n     /// function found in `rustc_incremental`.\n-    pub fn new(hash: u64) -> Svh {\n+    pub fn new(hash: Fingerprint) -> Svh {\n         Svh { hash }\n     }\n \n     pub fn as_u64(&self) -> u64 {\n-        self.hash\n+        self.hash.to_smaller_hash().as_u64()\n     }\n \n     pub fn to_string(&self) -> String {\n-        format!(\"{:016x}\", self.hash)\n-    }\n-}\n-\n-impl Hash for Svh {\n-    fn hash<H>(&self, state: &mut H)\n-    where\n-        H: Hasher,\n-    {\n-        self.hash.to_le().hash(state);\n+        format!(\"{:016x}\", self.hash.to_smaller_hash())\n     }\n }\n \n@@ -48,18 +38,6 @@ impl fmt::Display for Svh {\n     }\n }\n \n-impl<S: Encoder> Encodable<S> for Svh {\n-    fn encode(&self, s: &mut S) {\n-        s.emit_u64(self.as_u64().to_le());\n-    }\n-}\n-\n-impl<D: Decoder> Decodable<D> for Svh {\n-    fn decode(d: &mut D) -> Svh {\n-        Svh::new(u64::from_le(d.read_u64()))\n-    }\n-}\n-\n impl<T> stable_hasher::HashStable<T> for Svh {\n     #[inline]\n     fn hash_stable(&self, ctx: &mut T, hasher: &mut stable_hasher::StableHasher) {"}, {"sha": "e73ca56efa0377d0357ce308a2a89f35e4a764d9", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -45,6 +45,9 @@ use std::hash::{BuildHasher, Hash};\n use std::ops::{Deref, DerefMut};\n use std::panic::{catch_unwind, resume_unwind, AssertUnwindSafe};\n \n+mod worker_local;\n+pub use worker_local::{Registry, WorkerLocal};\n+\n pub use std::sync::atomic::Ordering;\n pub use std::sync::atomic::Ordering::SeqCst;\n \n@@ -205,33 +208,6 @@ cfg_if! {\n \n         use std::cell::Cell;\n \n-        #[derive(Debug)]\n-        pub struct WorkerLocal<T>(OneThread<T>);\n-\n-        impl<T> WorkerLocal<T> {\n-            /// Creates a new worker local where the `initial` closure computes the\n-            /// value this worker local should take for each thread in the thread pool.\n-            #[inline]\n-            pub fn new<F: FnMut(usize) -> T>(mut f: F) -> WorkerLocal<T> {\n-                WorkerLocal(OneThread::new(f(0)))\n-            }\n-\n-            /// Returns the worker-local value for each thread\n-            #[inline]\n-            pub fn into_inner(self) -> Vec<T> {\n-                vec![OneThread::into_inner(self.0)]\n-            }\n-        }\n-\n-        impl<T> Deref for WorkerLocal<T> {\n-            type Target = T;\n-\n-            #[inline(always)]\n-            fn deref(&self) -> &T {\n-                &self.0\n-            }\n-        }\n-\n         pub type MTLockRef<'a, T> = &'a mut MTLock<T>;\n \n         #[derive(Debug, Default)]\n@@ -351,8 +327,6 @@ cfg_if! {\n             };\n         }\n \n-        pub use rayon_core::WorkerLocal;\n-\n         pub use rayon::iter::ParallelIterator;\n         use rayon::iter::IntoParallelIterator;\n \n@@ -383,6 +357,10 @@ pub fn assert_send<T: ?Sized + Send>() {}\n pub fn assert_send_val<T: ?Sized + Send>(_t: &T) {}\n pub fn assert_send_sync_val<T: ?Sized + Sync + Send>(_t: &T) {}\n \n+#[derive(Default)]\n+#[cfg_attr(parallel_compiler, repr(align(64)))]\n+pub struct CacheAligned<T>(pub T);\n+\n pub trait HashMapExt<K, V> {\n     /// Same as HashMap::insert, but it may panic if there's already an\n     /// entry for `key` with a value not equal to `value`"}, {"sha": "e36dded9e5e5e4eb0dbe13eded03b612da70c89e", "filename": "compiler/rustc_data_structures/src/sync/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fvec.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,6 +1,6 @@\n use std::marker::PhantomData;\n \n-use rustc_index::vec::Idx;\n+use rustc_index::Idx;\n \n #[derive(Default)]\n pub struct AppendOnlyIndexVec<I: Idx, T: Copy> {"}, {"sha": "bfb04ba8a73f4cff7d5978614dcf0841048ce753", "filename": "compiler/rustc_data_structures/src/sync/worker_local.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fworker_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fworker_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync%2Fworker_local.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,180 @@\n+use crate::sync::Lock;\n+use std::cell::Cell;\n+use std::cell::OnceCell;\n+use std::ops::Deref;\n+use std::ptr;\n+use std::sync::Arc;\n+\n+#[cfg(parallel_compiler)]\n+use {crate::cold_path, crate::sync::CacheAligned};\n+\n+/// A pointer to the `RegistryData` which uniquely identifies a registry.\n+/// This identifier can be reused if the registry gets freed.\n+#[derive(Clone, Copy, PartialEq)]\n+struct RegistryId(*const RegistryData);\n+\n+impl RegistryId {\n+    #[inline(always)]\n+    /// Verifies that the current thread is associated with the registry and returns its unique\n+    /// index within the registry. This panics if the current thread is not associated with this\n+    /// registry.\n+    ///\n+    /// Note that there's a race possible where the identifer in `THREAD_DATA` could be reused\n+    /// so this can succeed from a different registry.\n+    #[cfg(parallel_compiler)]\n+    fn verify(self) -> usize {\n+        let (id, index) = THREAD_DATA.with(|data| (data.registry_id.get(), data.index.get()));\n+\n+        if id == self {\n+            index\n+        } else {\n+            cold_path(|| panic!(\"Unable to verify registry association\"))\n+        }\n+    }\n+}\n+\n+struct RegistryData {\n+    thread_limit: usize,\n+    threads: Lock<usize>,\n+}\n+\n+/// Represents a list of threads which can access worker locals.\n+#[derive(Clone)]\n+pub struct Registry(Arc<RegistryData>);\n+\n+thread_local! {\n+    /// The registry associated with the thread.\n+    /// This allows the `WorkerLocal` type to clone the registry in its constructor.\n+    static REGISTRY: OnceCell<Registry> = OnceCell::new();\n+}\n+\n+struct ThreadData {\n+    registry_id: Cell<RegistryId>,\n+    index: Cell<usize>,\n+}\n+\n+thread_local! {\n+    /// A thread local which contains the identifer of `REGISTRY` but allows for faster access.\n+    /// It also holds the index of the current thread.\n+    static THREAD_DATA: ThreadData = const { ThreadData {\n+        registry_id: Cell::new(RegistryId(ptr::null())),\n+        index: Cell::new(0),\n+    }};\n+}\n+\n+impl Registry {\n+    /// Creates a registry which can hold up to `thread_limit` threads.\n+    pub fn new(thread_limit: usize) -> Self {\n+        Registry(Arc::new(RegistryData { thread_limit, threads: Lock::new(0) }))\n+    }\n+\n+    /// Gets the registry associated with the current thread. Panics if there's no such registry.\n+    pub fn current() -> Self {\n+        REGISTRY.with(|registry| registry.get().cloned().expect(\"No assocated registry\"))\n+    }\n+\n+    /// Registers the current thread with the registry so worker locals can be used on it.\n+    /// Panics if the thread limit is hit or if the thread already has an associated registry.\n+    pub fn register(&self) {\n+        let mut threads = self.0.threads.lock();\n+        if *threads < self.0.thread_limit {\n+            REGISTRY.with(|registry| {\n+                if registry.get().is_some() {\n+                    drop(threads);\n+                    panic!(\"Thread already has a registry\");\n+                }\n+                registry.set(self.clone()).ok();\n+                THREAD_DATA.with(|data| {\n+                    data.registry_id.set(self.id());\n+                    data.index.set(*threads);\n+                });\n+                *threads += 1;\n+            });\n+        } else {\n+            drop(threads);\n+            panic!(\"Thread limit reached\");\n+        }\n+    }\n+\n+    /// Gets the identifer of this registry.\n+    fn id(&self) -> RegistryId {\n+        RegistryId(&*self.0)\n+    }\n+}\n+\n+/// Holds worker local values for each possible thread in a registry. You can only access the\n+/// worker local value through the `Deref` impl on the registry associated with the thread it was\n+/// created on. It will panic otherwise.\n+pub struct WorkerLocal<T> {\n+    #[cfg(not(parallel_compiler))]\n+    local: T,\n+    #[cfg(parallel_compiler)]\n+    locals: Box<[CacheAligned<T>]>,\n+    #[cfg(parallel_compiler)]\n+    registry: Registry,\n+}\n+\n+// This is safe because the `deref` call will return a reference to a `T` unique to each thread\n+// or it will panic for threads without an associated local. So there isn't a need for `T` to do\n+// it's own synchronization. The `verify` method on `RegistryId` has an issue where the the id\n+// can be reused, but `WorkerLocal` has a reference to `Registry` which will prevent any reuse.\n+#[cfg(parallel_compiler)]\n+unsafe impl<T: Send> Sync for WorkerLocal<T> {}\n+\n+impl<T> WorkerLocal<T> {\n+    /// Creates a new worker local where the `initial` closure computes the\n+    /// value this worker local should take for each thread in the registry.\n+    #[inline]\n+    pub fn new<F: FnMut(usize) -> T>(mut initial: F) -> WorkerLocal<T> {\n+        #[cfg(parallel_compiler)]\n+        {\n+            let registry = Registry::current();\n+            WorkerLocal {\n+                locals: (0..registry.0.thread_limit).map(|i| CacheAligned(initial(i))).collect(),\n+                registry,\n+            }\n+        }\n+        #[cfg(not(parallel_compiler))]\n+        {\n+            WorkerLocal { local: initial(0) }\n+        }\n+    }\n+\n+    /// Returns the worker-local values for each thread\n+    #[inline]\n+    pub fn into_inner(self) -> impl Iterator<Item = T> {\n+        #[cfg(parallel_compiler)]\n+        {\n+            self.locals.into_vec().into_iter().map(|local| local.0)\n+        }\n+        #[cfg(not(parallel_compiler))]\n+        {\n+            std::iter::once(self.local)\n+        }\n+    }\n+}\n+\n+impl<T> WorkerLocal<Vec<T>> {\n+    /// Joins the elements of all the worker locals into one Vec\n+    pub fn join(self) -> Vec<T> {\n+        self.into_inner().into_iter().flat_map(|v| v).collect()\n+    }\n+}\n+\n+impl<T> Deref for WorkerLocal<T> {\n+    type Target = T;\n+\n+    #[inline(always)]\n+    #[cfg(not(parallel_compiler))]\n+    fn deref(&self) -> &T {\n+        &self.local\n+    }\n+\n+    #[inline(always)]\n+    #[cfg(parallel_compiler)]\n+    fn deref(&self) -> &T {\n+        // This is safe because `verify` will only return values less than\n+        // `self.registry.thread_limit` which is the size of the `self.locals` array.\n+        unsafe { &self.locals.get_unchecked(self.registry.id().verify()).0 }\n+    }\n+}"}, {"sha": "2914eece6796bd3892d7f6ea212e540a6245f156", "filename": "compiler/rustc_data_structures/src/tagged_ptr.rs", "status": "modified", "additions": 202, "deletions": 87, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -3,166 +3,281 @@\n //! In order to utilize the pointer packing, you must have two types: a pointer,\n //! and a tag.\n //!\n-//! The pointer must implement the `Pointer` trait, with the primary requirement\n-//! being conversion to and from a usize. Note that the pointer must be\n-//! dereferenceable, so raw pointers generally cannot implement the `Pointer`\n-//! trait. This implies that the pointer must also be nonzero.\n+//! The pointer must implement the [`Pointer`] trait, with the primary\n+//! requirement being convertible to and from a raw pointer. Note that the\n+//! pointer must be dereferenceable, so raw pointers generally cannot implement\n+//! the [`Pointer`] trait. This implies that the pointer must also be non-null.\n //!\n-//! Many common pointer types already implement the `Pointer` trait.\n+//! Many common pointer types already implement the [`Pointer`] trait.\n //!\n-//! The tag must implement the `Tag` trait. We assert that the tag and `Pointer`\n-//! are compatible at compile time.\n+//! The tag must implement the [`Tag`] trait.\n+//!\n+//! We assert that the tag and the [`Pointer`] types are compatible at compile\n+//! time.\n \n-use std::mem::ManuallyDrop;\n use std::ops::Deref;\n+use std::ptr::NonNull;\n use std::rc::Rc;\n use std::sync::Arc;\n \n+use crate::aligned::Aligned;\n+\n mod copy;\n mod drop;\n+mod impl_tag;\n \n pub use copy::CopyTaggedPtr;\n pub use drop::TaggedPtr;\n \n-/// This describes the pointer type encapsulated by TaggedPtr.\n+/// This describes the pointer type encapsulated by [`TaggedPtr`] and\n+/// [`CopyTaggedPtr`].\n ///\n /// # Safety\n ///\n-/// The usize returned from `into_usize` must be a valid, dereferenceable,\n-/// pointer to `<Self as Deref>::Target`. Note that pointers to `Pointee` must\n-/// be thin, even though `Pointee` may not be sized.\n+/// The pointer returned from [`into_ptr`] must be a [valid], pointer to\n+/// [`<Self as Deref>::Target`].\n ///\n-/// Note that the returned pointer from `into_usize` should be castable to `&mut\n-/// <Self as Deref>::Target` if `Pointer: DerefMut`.\n+/// Note that if `Self` implements [`DerefMut`] the pointer returned from\n+/// [`into_ptr`] must be valid for writes (and thus calling [`NonNull::as_mut`]\n+/// on it must be safe).\n ///\n-/// The BITS constant must be correct. At least `BITS` bits, least-significant,\n-/// must be zero on all returned pointers from `into_usize`.\n+/// The [`BITS`] constant must be correct. [`BITS`] least-significant bits,\n+/// must be zero on all pointers returned from [`into_ptr`].\n ///\n-/// For example, if the alignment of `Pointee` is 2, then `BITS` should be 1.\n+/// For example, if the alignment of [`Self::Target`] is 2, then `BITS` should be 1.\n+///\n+/// [`BITS`]: Pointer::BITS\n+/// [`into_ptr`]: Pointer::into_ptr\n+/// [valid]: std::ptr#safety\n+/// [`<Self as Deref>::Target`]: Deref::Target\n+/// [`Self::Target`]: Deref::Target\n+/// [`DerefMut`]: std::ops::DerefMut\n pub unsafe trait Pointer: Deref {\n+    /// Number of unused (always zero) **least-significant bits** in this\n+    /// pointer, usually related to the pointees alignment.\n+    ///\n+    /// For example if [`BITS`] = `2`, then given `ptr = Self::into_ptr(..)`,\n+    /// `ptr.addr() & 0b11 == 0` must be true.\n+    ///\n     /// Most likely the value you want to use here is the following, unless\n-    /// your Pointee type is unsized (e.g., `ty::List<T>` in rustc) in which\n-    /// case you'll need to manually figure out what the right type to pass to\n-    /// align_of is.\n+    /// your [`Self::Target`] type is unsized (e.g., `ty::List<T>` in rustc)\n+    /// or your pointer is over/under aligned, in which case you'll need to\n+    /// manually figure out what the right type to pass to [`bits_for`] is, or\n+    /// what the value to set here.\n     ///\n-    /// ```ignore UNSOLVED (what to do about the Self)\n+    /// ```rust\n     /// # use std::ops::Deref;\n-    /// std::mem::align_of::<<Self as Deref>::Target>().trailing_zeros() as usize;\n+    /// # use rustc_data_structures::tagged_ptr::bits_for;\n+    /// # struct T;\n+    /// # impl Deref for T { type Target = u8; fn deref(&self) -> &u8 { &0 } }\n+    /// # impl T {\n+    /// const BITS: u32 = bits_for::<<Self as Deref>::Target>();\n+    /// # }\n     /// ```\n-    const BITS: usize;\n-    fn into_usize(self) -> usize;\n+    ///\n+    /// [`BITS`]: Pointer::BITS\n+    /// [`Self::Target`]: Deref::Target\n+    const BITS: u32;\n \n-    /// # Safety\n+    /// Turns this pointer into a raw, non-null pointer.\n+    ///\n+    /// The inverse of this function is [`from_ptr`].\n     ///\n-    /// The passed `ptr` must be returned from `into_usize`.\n+    /// This function guarantees that the least-significant [`Self::BITS`] bits\n+    /// are zero.\n     ///\n-    /// This acts as `ptr::read` semantically, it should not be called more than\n-    /// once on non-`Copy` `Pointer`s.\n-    unsafe fn from_usize(ptr: usize) -> Self;\n+    /// [`from_ptr`]: Pointer::from_ptr\n+    /// [`Self::BITS`]: Pointer::BITS\n+    fn into_ptr(self) -> NonNull<Self::Target>;\n \n-    /// This provides a reference to the `Pointer` itself, rather than the\n-    /// `Deref::Target`. It is used for cases where we want to call methods that\n-    /// may be implement differently for the Pointer than the Pointee (e.g.,\n-    /// `Rc::clone` vs cloning the inner value).\n+    /// Re-creates the original pointer, from a raw pointer returned by [`into_ptr`].\n     ///\n     /// # Safety\n     ///\n-    /// The passed `ptr` must be returned from `into_usize`.\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R;\n+    /// The passed `ptr` must be returned from [`into_ptr`].\n+    ///\n+    /// This acts as [`ptr::read::<Self>()`] semantically, it should not be called more than\n+    /// once on non-[`Copy`] `Pointer`s.\n+    ///\n+    /// [`into_ptr`]: Pointer::into_ptr\n+    /// [`ptr::read::<Self>()`]: std::ptr::read\n+    unsafe fn from_ptr(ptr: NonNull<Self::Target>) -> Self;\n }\n \n-/// This describes tags that the `TaggedPtr` struct can hold.\n+/// This describes tags that the [`TaggedPtr`] struct can hold.\n ///\n /// # Safety\n ///\n-/// The BITS constant must be correct.\n+/// The [`BITS`] constant must be correct.\n ///\n-/// No more than `BITS` least significant bits may be set in the returned usize.\n+/// No more than [`BITS`] least-significant bits may be set in the returned usize.\n+///\n+/// [`BITS`]: Tag::BITS\n pub unsafe trait Tag: Copy {\n-    const BITS: usize;\n+    /// Number of least-significant bits in the return value of [`into_usize`]\n+    /// which may be non-zero. In other words this is the bit width of the\n+    /// value.\n+    ///\n+    /// [`into_usize`]: Tag::into_usize\n+    const BITS: u32;\n \n+    /// Turns this tag into an integer.\n+    ///\n+    /// The inverse of this function is [`from_usize`].\n+    ///\n+    /// This function guarantees that only the least-significant [`Self::BITS`]\n+    /// bits can be non-zero.\n+    ///\n+    /// [`from_usize`]: Tag::from_usize\n+    /// [`Self::BITS`]: Tag::BITS\n     fn into_usize(self) -> usize;\n \n+    /// Re-creates the tag from the integer returned by [`into_usize`].\n+    ///\n     /// # Safety\n     ///\n-    /// The passed `tag` must be returned from `into_usize`.\n+    /// The passed `tag` must be returned from [`into_usize`].\n+    ///\n+    /// [`into_usize`]: Tag::into_usize\n     unsafe fn from_usize(tag: usize) -> Self;\n }\n \n-unsafe impl<T> Pointer for Box<T> {\n-    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n-    #[inline]\n-    fn into_usize(self) -> usize {\n-        Box::into_raw(self) as usize\n+/// Returns the number of bits available for use for tags in a pointer to `T`\n+/// (this is based on `T`'s alignment).\n+pub const fn bits_for<T: ?Sized + Aligned>() -> u32 {\n+    crate::aligned::align_of::<T>().as_nonzero().trailing_zeros()\n+}\n+\n+/// Returns the correct [`Tag::BITS`] constant for a set of tag values.\n+pub const fn bits_for_tags(mut tags: &[usize]) -> u32 {\n+    let mut bits = 0;\n+\n+    while let &[tag, ref rest @ ..] = tags {\n+        tags = rest;\n+\n+        // bits required to represent `tag`,\n+        // position of the most significant 1\n+        let b = usize::BITS - tag.leading_zeros();\n+        if b > bits {\n+            bits = b;\n+        }\n     }\n+\n+    bits\n+}\n+\n+unsafe impl<T: ?Sized + Aligned> Pointer for Box<T> {\n+    const BITS: u32 = bits_for::<Self::Target>();\n+\n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        Box::from_raw(ptr as *mut T)\n+    fn into_ptr(self) -> NonNull<T> {\n+        // Safety: pointers from `Box::into_raw` are valid & non-null\n+        unsafe { NonNull::new_unchecked(Box::into_raw(self)) }\n     }\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n-        f(&raw)\n+\n+    #[inline]\n+    unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        // Safety: `ptr` comes from `into_ptr` which calls `Box::into_raw`\n+        unsafe { Box::from_raw(ptr.as_ptr()) }\n     }\n }\n \n-unsafe impl<T> Pointer for Rc<T> {\n-    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+unsafe impl<T: ?Sized + Aligned> Pointer for Rc<T> {\n+    const BITS: u32 = bits_for::<Self::Target>();\n+\n     #[inline]\n-    fn into_usize(self) -> usize {\n-        Rc::into_raw(self) as usize\n+    fn into_ptr(self) -> NonNull<T> {\n+        // Safety: pointers from `Rc::into_raw` are valid & non-null\n+        unsafe { NonNull::new_unchecked(Rc::into_raw(self).cast_mut()) }\n     }\n+\n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        Rc::from_raw(ptr as *const T)\n-    }\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n-        f(&raw)\n+    unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        // Safety: `ptr` comes from `into_ptr` which calls `Rc::into_raw`\n+        unsafe { Rc::from_raw(ptr.as_ptr()) }\n     }\n }\n \n-unsafe impl<T> Pointer for Arc<T> {\n-    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+unsafe impl<T: ?Sized + Aligned> Pointer for Arc<T> {\n+    const BITS: u32 = bits_for::<Self::Target>();\n+\n     #[inline]\n-    fn into_usize(self) -> usize {\n-        Arc::into_raw(self) as usize\n+    fn into_ptr(self) -> NonNull<T> {\n+        // Safety: pointers from `Arc::into_raw` are valid & non-null\n+        unsafe { NonNull::new_unchecked(Arc::into_raw(self).cast_mut()) }\n     }\n+\n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        Arc::from_raw(ptr as *const T)\n-    }\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        let raw = ManuallyDrop::new(Self::from_usize(ptr));\n-        f(&raw)\n+    unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        // Safety: `ptr` comes from `into_ptr` which calls `Arc::into_raw`\n+        unsafe { Arc::from_raw(ptr.as_ptr()) }\n     }\n }\n \n-unsafe impl<'a, T: 'a> Pointer for &'a T {\n-    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+unsafe impl<'a, T: 'a + ?Sized + Aligned> Pointer for &'a T {\n+    const BITS: u32 = bits_for::<Self::Target>();\n+\n     #[inline]\n-    fn into_usize(self) -> usize {\n-        self as *const T as usize\n+    fn into_ptr(self) -> NonNull<T> {\n+        NonNull::from(self)\n     }\n+\n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        &*(ptr as *const T)\n-    }\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        f(&*(&ptr as *const usize as *const Self))\n+    unsafe fn from_ptr(ptr: NonNull<T>) -> Self {\n+        // Safety:\n+        // `ptr` comes from `into_ptr` which gets the pointer from a reference\n+        unsafe { ptr.as_ref() }\n     }\n }\n \n-unsafe impl<'a, T: 'a> Pointer for &'a mut T {\n-    const BITS: usize = std::mem::align_of::<T>().trailing_zeros() as usize;\n+unsafe impl<'a, T: 'a + ?Sized + Aligned> Pointer for &'a mut T {\n+    const BITS: u32 = bits_for::<Self::Target>();\n+\n     #[inline]\n-    fn into_usize(self) -> usize {\n-        self as *mut T as usize\n+    fn into_ptr(self) -> NonNull<T> {\n+        NonNull::from(self)\n     }\n+\n     #[inline]\n-    unsafe fn from_usize(ptr: usize) -> Self {\n-        &mut *(ptr as *mut T)\n+    unsafe fn from_ptr(mut ptr: NonNull<T>) -> Self {\n+        // Safety:\n+        // `ptr` comes from `into_ptr` which gets the pointer from a reference\n+        unsafe { ptr.as_mut() }\n+    }\n+}\n+\n+/// A tag type used in [`CopyTaggedPtr`] and [`TaggedPtr`] tests.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[cfg(test)]\n+enum Tag2 {\n+    B00 = 0b00,\n+    B01 = 0b01,\n+    B10 = 0b10,\n+    B11 = 0b11,\n+}\n+\n+#[cfg(test)]\n+unsafe impl Tag for Tag2 {\n+    const BITS: u32 = 2;\n+\n+    fn into_usize(self) -> usize {\n+        self as _\n     }\n-    unsafe fn with_ref<R, F: FnOnce(&Self) -> R>(ptr: usize, f: F) -> R {\n-        f(&*(&ptr as *const usize as *const Self))\n+\n+    unsafe fn from_usize(tag: usize) -> Self {\n+        match tag {\n+            0b00 => Tag2::B00,\n+            0b01 => Tag2::B01,\n+            0b10 => Tag2::B10,\n+            0b11 => Tag2::B11,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+impl<HCX> crate::stable_hasher::HashStable<HCX> for Tag2 {\n+    fn hash_stable(&self, hcx: &mut HCX, hasher: &mut crate::stable_hasher::StableHasher) {\n+        (*self as u8).hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "e893a2c7813469e745d53766674c6ea1a8d25329", "filename": "compiler/rustc_data_structures/src/tagged_ptr/copy.rs", "status": "modified", "additions": 232, "deletions": 89, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,78 +1,94 @@\n use super::{Pointer, Tag};\n use crate::stable_hasher::{HashStable, StableHasher};\n use std::fmt;\n+use std::hash::{Hash, Hasher};\n use std::marker::PhantomData;\n+use std::mem::ManuallyDrop;\n use std::num::NonZeroUsize;\n+use std::ops::{Deref, DerefMut};\n+use std::ptr::NonNull;\n \n-/// A `Copy` TaggedPtr.\n+/// A [`Copy`] tagged pointer.\n ///\n-/// You should use this instead of the `TaggedPtr` type in all cases where\n-/// `P: Copy`.\n+/// This is essentially `{ pointer: P, tag: T }` packed in a single pointer.\n+///\n+/// You should use this instead of the [`TaggedPtr`] type in all cases where\n+/// `P` implements [`Copy`].\n ///\n /// If `COMPARE_PACKED` is true, then the pointers will be compared and hashed without\n-/// unpacking. Otherwise we don't implement PartialEq/Eq/Hash; if you want that,\n-/// wrap the TaggedPtr.\n+/// unpacking. Otherwise we don't implement [`PartialEq`], [`Eq`] and [`Hash`];\n+/// if you want that, wrap the [`CopyTaggedPtr`].\n+///\n+/// [`TaggedPtr`]: crate::tagged_ptr::TaggedPtr\n pub struct CopyTaggedPtr<P, T, const COMPARE_PACKED: bool>\n where\n     P: Pointer,\n     T: Tag,\n {\n-    packed: NonZeroUsize,\n-    data: PhantomData<(P, T)>,\n-}\n-\n-impl<P, T, const COMPARE_PACKED: bool> Copy for CopyTaggedPtr<P, T, COMPARE_PACKED>\n-where\n-    P: Pointer,\n-    T: Tag,\n-    P: Copy,\n-{\n-}\n-\n-impl<P, T, const COMPARE_PACKED: bool> Clone for CopyTaggedPtr<P, T, COMPARE_PACKED>\n-where\n-    P: Pointer,\n-    T: Tag,\n-    P: Copy,\n-{\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n+    /// This is semantically a pair of `pointer: P` and `tag: T` fields,\n+    /// however we pack them in a single pointer, to save space.\n+    ///\n+    /// We pack the tag into the **most**-significant bits of the pointer to\n+    /// ease retrieval of the value. A left shift is a multiplication and\n+    /// those are embeddable in instruction encoding, for example:\n+    ///\n+    /// ```asm\n+    /// // (<https://godbolt.org/z/jqcYPWEr3>)\n+    /// example::shift_read3:\n+    ///     mov     eax, dword ptr [8*rdi]\n+    ///     ret\n+    ///\n+    /// example::mask_read3:\n+    ///     and     rdi, -8\n+    ///     mov     eax, dword ptr [rdi]\n+    ///     ret\n+    /// ```\n+    ///\n+    /// This is ASM outputted by rustc for reads of values behind tagged\n+    /// pointers for different approaches of tagging:\n+    /// - `shift_read3` uses `<< 3` (the tag is in the most-significant bits)\n+    /// - `mask_read3` uses `& !0b111` (the tag is in the least-significant bits)\n+    ///\n+    /// The shift approach thus produces less instructions and is likely faster\n+    /// (see <https://godbolt.org/z/Y913sMdWb>).\n+    ///\n+    /// Encoding diagram:\n+    /// ```text\n+    /// [ packed.addr                     ]\n+    /// [ tag ] [ pointer.addr >> T::BITS ] <-- usize::BITS - T::BITS bits\n+    ///    ^\n+    ///    |\n+    /// T::BITS bits\n+    /// ```\n+    ///\n+    /// The tag can be retrieved by `packed.addr() >> T::BITS` and the pointer\n+    /// can be retrieved by `packed.map_addr(|addr| addr << T::BITS)`.\n+    packed: NonNull<P::Target>,\n+    tag_ghost: PhantomData<T>,\n }\n \n-// We pack the tag into the *upper* bits of the pointer to ease retrieval of the\n-// value; a left shift is a multiplication and those are embeddable in\n-// instruction encoding.\n-impl<P, T, const COMPARE_PACKED: bool> CopyTaggedPtr<P, T, COMPARE_PACKED>\n+// Note that even though `CopyTaggedPtr` is only really expected to work with\n+// `P: Copy`, can't add `P: Copy` bound, because `CopyTaggedPtr` is used in the\n+// `TaggedPtr`'s implementation.\n+impl<P, T, const CP: bool> CopyTaggedPtr<P, T, CP>\n where\n     P: Pointer,\n     T: Tag,\n {\n-    const TAG_BIT_SHIFT: usize = usize::BITS as usize - T::BITS;\n-    const ASSERTION: () = {\n-        assert!(T::BITS <= P::BITS);\n-        // Used for the transmute_copy's below\n-        assert!(std::mem::size_of::<&P::Target>() == std::mem::size_of::<usize>());\n-    };\n-\n+    /// Tags `pointer` with `tag`.\n+    ///\n+    /// Note that this leaks `pointer`: it won't be dropped when\n+    /// `CopyTaggedPtr` is dropped. If you have a pointer with a significant\n+    /// drop, use [`TaggedPtr`] instead.\n+    ///\n+    /// [`TaggedPtr`]: crate::tagged_ptr::TaggedPtr\n+    #[inline]\n     pub fn new(pointer: P, tag: T) -> Self {\n-        // Trigger assert!\n-        let () = Self::ASSERTION;\n-        let packed_tag = tag.into_usize() << Self::TAG_BIT_SHIFT;\n-\n-        Self {\n-            // SAFETY: We know that the pointer is non-null, as it must be\n-            // dereferenceable per `Pointer` safety contract.\n-            packed: unsafe {\n-                NonZeroUsize::new_unchecked((P::into_usize(pointer) >> T::BITS) | packed_tag)\n-            },\n-            data: PhantomData,\n-        }\n+        Self { packed: Self::pack(P::into_ptr(pointer), tag), tag_ghost: PhantomData }\n     }\n \n-    pub(super) fn pointer_raw(&self) -> usize {\n-        self.packed.get() << T::BITS\n-    }\n+    /// Retrieves the pointer.\n+    #[inline]\n     pub fn pointer(self) -> P\n     where\n         P: Copy,\n@@ -81,66 +97,143 @@ where\n         //\n         // Note that this isn't going to double-drop or anything because we have\n         // P: Copy\n-        unsafe { P::from_usize(self.pointer_raw()) }\n-    }\n-    pub fn pointer_ref(&self) -> &P::Target {\n-        // SAFETY: pointer_raw returns the original pointer\n-        unsafe { std::mem::transmute_copy(&self.pointer_raw()) }\n-    }\n-    pub fn pointer_mut(&mut self) -> &mut P::Target\n-    where\n-        P: std::ops::DerefMut,\n-    {\n-        // SAFETY: pointer_raw returns the original pointer\n-        unsafe { std::mem::transmute_copy(&self.pointer_raw()) }\n+        unsafe { P::from_ptr(self.pointer_raw()) }\n     }\n+\n+    /// Retrieves the tag.\n     #[inline]\n     pub fn tag(&self) -> T {\n-        unsafe { T::from_usize(self.packed.get() >> Self::TAG_BIT_SHIFT) }\n+        // Unpack the tag, according to the `self.packed` encoding scheme\n+        let tag = self.packed.addr().get() >> Self::TAG_BIT_SHIFT;\n+\n+        // Safety:\n+        // The shift retrieves the original value from `T::into_usize`,\n+        // satisfying `T::from_usize`'s preconditions.\n+        unsafe { T::from_usize(tag) }\n     }\n+\n+    /// Sets the tag to a new value.\n     #[inline]\n     pub fn set_tag(&mut self, tag: T) {\n-        let mut packed = self.packed.get();\n-        let new_tag = T::into_usize(tag) << Self::TAG_BIT_SHIFT;\n-        let tag_mask = (1 << T::BITS) - 1;\n-        packed &= !(tag_mask << Self::TAG_BIT_SHIFT);\n-        packed |= new_tag;\n-        self.packed = unsafe { NonZeroUsize::new_unchecked(packed) };\n+        self.packed = Self::pack(self.pointer_raw(), tag);\n+    }\n+\n+    const TAG_BIT_SHIFT: u32 = usize::BITS - T::BITS;\n+    const ASSERTION: () = { assert!(T::BITS <= P::BITS) };\n+\n+    /// Pack pointer `ptr` that comes from [`P::into_ptr`] with a `tag`,\n+    /// according to `self.packed` encoding scheme.\n+    ///\n+    /// [`P::into_ptr`]: Pointer::into_ptr\n+    #[inline]\n+    fn pack(ptr: NonNull<P::Target>, tag: T) -> NonNull<P::Target> {\n+        // Trigger assert!\n+        let () = Self::ASSERTION;\n+\n+        let packed_tag = tag.into_usize() << Self::TAG_BIT_SHIFT;\n+\n+        ptr.map_addr(|addr| {\n+            // Safety:\n+            // - The pointer is `NonNull` => it's address is `NonZeroUsize`\n+            // - `P::BITS` least significant bits are always zero (`Pointer` contract)\n+            // - `T::BITS <= P::BITS` (from `Self::ASSERTION`)\n+            //\n+            // Thus `addr >> T::BITS` is guaranteed to be non-zero.\n+            //\n+            // `{non_zero} | packed_tag` can't make the value zero.\n+\n+            let packed = (addr.get() >> T::BITS) | packed_tag;\n+            unsafe { NonZeroUsize::new_unchecked(packed) }\n+        })\n     }\n+\n+    /// Retrieves the original raw pointer from `self.packed`.\n+    #[inline]\n+    pub(super) fn pointer_raw(&self) -> NonNull<P::Target> {\n+        self.packed.map_addr(|addr| unsafe { NonZeroUsize::new_unchecked(addr.get() << T::BITS) })\n+    }\n+\n+    /// This provides a reference to the `P` pointer itself, rather than the\n+    /// `Deref::Target`. It is used for cases where we want to call methods\n+    /// that may be implement differently for the Pointer than the Pointee\n+    /// (e.g., `Rc::clone` vs cloning the inner value).\n+    pub(super) fn with_pointer_ref<R>(&self, f: impl FnOnce(&P) -> R) -> R {\n+        // Safety:\n+        // - `self.raw.pointer_raw()` is originally returned from `P::into_ptr`\n+        //   and as such is valid for `P::from_ptr`.\n+        //   - This also allows us to not care whatever `f` panics or not.\n+        // - Even though we create a copy of the pointer, we store it inside\n+        //   `ManuallyDrop` and only access it by-ref, so we don't double-drop.\n+        //\n+        // Semantically this is just `f(&self.pointer)` (where `self.pointer`\n+        // is non-packed original pointer).\n+        //\n+        // Note that even though `CopyTaggedPtr` is only really expected to\n+        // work with `P: Copy`, we have to assume `P: ?Copy`, because\n+        // `CopyTaggedPtr` is used in the `TaggedPtr`'s implementation.\n+        let ptr = unsafe { ManuallyDrop::new(P::from_ptr(self.pointer_raw())) };\n+        f(&ptr)\n+    }\n+}\n+\n+impl<P, T, const CP: bool> Copy for CopyTaggedPtr<P, T, CP>\n+where\n+    P: Pointer + Copy,\n+    T: Tag,\n+{\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> std::ops::Deref for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> Clone for CopyTaggedPtr<P, T, CP>\n+where\n+    P: Pointer + Copy,\n+    T: Tag,\n+{\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<P, T, const CP: bool> Deref for CopyTaggedPtr<P, T, CP>\n where\n     P: Pointer,\n     T: Tag,\n {\n     type Target = P::Target;\n+\n+    #[inline]\n     fn deref(&self) -> &Self::Target {\n-        self.pointer_ref()\n+        // Safety:\n+        // `pointer_raw` returns the original pointer from `P::into_ptr` which,\n+        // by the `Pointer`'s contract, must be valid.\n+        unsafe { self.pointer_raw().as_ref() }\n     }\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> std::ops::DerefMut for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> DerefMut for CopyTaggedPtr<P, T, CP>\n where\n-    P: Pointer + std::ops::DerefMut,\n+    P: Pointer + DerefMut,\n     T: Tag,\n {\n+    #[inline]\n     fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.pointer_mut()\n+        // Safety:\n+        // `pointer_raw` returns the original pointer from `P::into_ptr` which,\n+        // by the `Pointer`'s contract, must be valid for writes if\n+        // `P: DerefMut`.\n+        unsafe { self.pointer_raw().as_mut() }\n     }\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> fmt::Debug for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> fmt::Debug for CopyTaggedPtr<P, T, CP>\n where\n-    P: Pointer,\n-    P::Target: fmt::Debug,\n+    P: Pointer + fmt::Debug,\n     T: Tag + fmt::Debug,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"CopyTaggedPtr\")\n-            .field(\"pointer\", &self.pointer_ref())\n-            .field(\"tag\", &self.tag())\n-            .finish()\n+        self.with_pointer_ref(|ptr| {\n+            f.debug_struct(\"CopyTaggedPtr\").field(\"pointer\", ptr).field(\"tag\", &self.tag()).finish()\n+        })\n     }\n }\n \n@@ -149,6 +242,7 @@ where\n     P: Pointer,\n     T: Tag,\n {\n+    #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         self.packed == other.packed\n     }\n@@ -161,25 +255,74 @@ where\n {\n }\n \n-impl<P, T> std::hash::Hash for CopyTaggedPtr<P, T, true>\n+impl<P, T> Hash for CopyTaggedPtr<P, T, true>\n where\n     P: Pointer,\n     T: Tag,\n {\n-    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         self.packed.hash(state);\n     }\n }\n \n-impl<P, T, HCX, const COMPARE_PACKED: bool> HashStable<HCX> for CopyTaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, HCX, const CP: bool> HashStable<HCX> for CopyTaggedPtr<P, T, CP>\n where\n     P: Pointer + HashStable<HCX>,\n     T: Tag + HashStable<HCX>,\n {\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n-        unsafe {\n-            Pointer::with_ref(self.pointer_raw(), |p: &P| p.hash_stable(hcx, hasher));\n-        }\n+        self.with_pointer_ref(|ptr| ptr.hash_stable(hcx, hasher));\n         self.tag().hash_stable(hcx, hasher);\n     }\n }\n+\n+// Safety:\n+// `CopyTaggedPtr<P, T, ..>` is semantically just `{ ptr: P, tag: T }`, as such\n+// it's ok to implement `Sync` as long as `P: Sync, T: Sync`\n+unsafe impl<P, T, const CP: bool> Sync for CopyTaggedPtr<P, T, CP>\n+where\n+    P: Sync + Pointer,\n+    T: Sync + Tag,\n+{\n+}\n+\n+// Safety:\n+// `CopyTaggedPtr<P, T, ..>` is semantically just `{ ptr: P, tag: T }`, as such\n+// it's ok to implement `Send` as long as `P: Send, T: Send`\n+unsafe impl<P, T, const CP: bool> Send for CopyTaggedPtr<P, T, CP>\n+where\n+    P: Send + Pointer,\n+    T: Send + Tag,\n+{\n+}\n+\n+/// Test that `new` does not compile if there is not enough alignment for the\n+/// tag in the pointer.\n+///\n+/// ```compile_fail,E0080\n+/// use rustc_data_structures::tagged_ptr::{CopyTaggedPtr, Tag};\n+///\n+/// #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+/// enum Tag2 { B00 = 0b00, B01 = 0b01, B10 = 0b10, B11 = 0b11 };\n+///\n+/// unsafe impl Tag for Tag2 {\n+///     const BITS: u32 = 2;\n+///\n+///     fn into_usize(self) -> usize { todo!() }\n+///     unsafe fn from_usize(tag: usize) -> Self { todo!() }\n+/// }\n+///\n+/// let value = 12u16;\n+/// let reference = &value;\n+/// let tag = Tag2::B01;\n+///\n+/// let _ptr = CopyTaggedPtr::<_, _, true>::new(reference, tag);\n+/// ```\n+// For some reason miri does not get the compile error\n+// probably it `check`s instead of `build`ing?\n+#[cfg(not(miri))]\n+const _: () = ();\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "bfcc2e603de43cc433b7d8262e79095b0747eefb", "filename": "compiler/rustc_data_structures/src/tagged_ptr/copy/tests.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fcopy%2Ftests.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,50 @@\n+use std::ptr;\n+\n+use crate::stable_hasher::{HashStable, StableHasher};\n+use crate::tagged_ptr::{CopyTaggedPtr, Pointer, Tag, Tag2};\n+\n+#[test]\n+fn smoke() {\n+    let value = 12u32;\n+    let reference = &value;\n+    let tag = Tag2::B01;\n+\n+    let ptr = tag_ptr(reference, tag);\n+\n+    assert_eq!(ptr.tag(), tag);\n+    assert_eq!(*ptr, 12);\n+    assert!(ptr::eq(ptr.pointer(), reference));\n+\n+    let copy = ptr;\n+\n+    let mut ptr = ptr;\n+    ptr.set_tag(Tag2::B00);\n+    assert_eq!(ptr.tag(), Tag2::B00);\n+\n+    assert_eq!(copy.tag(), tag);\n+    assert_eq!(*copy, 12);\n+    assert!(ptr::eq(copy.pointer(), reference));\n+}\n+\n+#[test]\n+fn stable_hash_hashes_as_tuple() {\n+    let hash_packed = {\n+        let mut hasher = StableHasher::new();\n+        tag_ptr(&12, Tag2::B11).hash_stable(&mut (), &mut hasher);\n+\n+        hasher.finalize()\n+    };\n+\n+    let hash_tupled = {\n+        let mut hasher = StableHasher::new();\n+        (&12, Tag2::B11).hash_stable(&mut (), &mut hasher);\n+        hasher.finalize()\n+    };\n+\n+    assert_eq!(hash_packed, hash_tupled);\n+}\n+\n+/// Helper to create tagged pointers without specifying `COMPARE_PACKED` if it does not matter.\n+fn tag_ptr<P: Pointer, T: Tag>(ptr: P, tag: T) -> CopyTaggedPtr<P, T, true> {\n+    CopyTaggedPtr::new(ptr, tag)\n+}"}, {"sha": "4e42b5b4afe8a87ee5f6ef3cb928f1991df762f3", "filename": "compiler/rustc_data_structures/src/tagged_ptr/drop.rs", "status": "modified", "additions": 85, "deletions": 39, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,14 +1,21 @@\n-use super::{Pointer, Tag};\n-use crate::stable_hasher::{HashStable, StableHasher};\n use std::fmt;\n+use std::hash::{Hash, Hasher};\n+use std::ops::{Deref, DerefMut};\n \n use super::CopyTaggedPtr;\n+use super::{Pointer, Tag};\n+use crate::stable_hasher::{HashStable, StableHasher};\n \n-/// A TaggedPtr implementing `Drop`.\n+/// A tagged pointer that supports pointers that implement [`Drop`].\n+///\n+/// This is essentially `{ pointer: P, tag: T }` packed in a single pointer.\n+///\n+/// You should use [`CopyTaggedPtr`] instead of the this type in all cases\n+/// where `P` implements [`Copy`].\n ///\n /// If `COMPARE_PACKED` is true, then the pointers will be compared and hashed without\n-/// unpacking. Otherwise we don't implement PartialEq/Eq/Hash; if you want that,\n-/// wrap the TaggedPtr.\n+/// unpacking. Otherwise we don't implement [`PartialEq`], [`Eq`] and [`Hash`];\n+/// if you want that, wrap the [`TaggedPtr`].\n pub struct TaggedPtr<P, T, const COMPARE_PACKED: bool>\n where\n     P: Pointer,\n@@ -17,81 +24,88 @@ where\n     raw: CopyTaggedPtr<P, T, COMPARE_PACKED>,\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> Clone for TaggedPtr<P, T, COMPARE_PACKED>\n-where\n-    P: Pointer + Clone,\n-    T: Tag,\n-{\n-    fn clone(&self) -> Self {\n-        unsafe { Self::new(P::with_ref(self.raw.pointer_raw(), |p| p.clone()), self.raw.tag()) }\n-    }\n-}\n-\n-// We pack the tag into the *upper* bits of the pointer to ease retrieval of the\n-// value; a right shift is a multiplication and those are embeddable in\n-// instruction encoding.\n-impl<P, T, const COMPARE_PACKED: bool> TaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> TaggedPtr<P, T, CP>\n where\n     P: Pointer,\n     T: Tag,\n {\n+    /// Tags `pointer` with `tag`.\n+    #[inline]\n     pub fn new(pointer: P, tag: T) -> Self {\n         TaggedPtr { raw: CopyTaggedPtr::new(pointer, tag) }\n     }\n \n-    pub fn pointer_ref(&self) -> &P::Target {\n-        self.raw.pointer_ref()\n-    }\n+    /// Retrieves the tag.\n+    #[inline]\n     pub fn tag(&self) -> T {\n         self.raw.tag()\n     }\n+\n+    /// Sets the tag to a new value.\n+    #[inline]\n+    pub fn set_tag(&mut self, tag: T) {\n+        self.raw.set_tag(tag)\n+    }\n+}\n+\n+impl<P, T, const CP: bool> Clone for TaggedPtr<P, T, CP>\n+where\n+    P: Pointer + Clone,\n+    T: Tag,\n+{\n+    fn clone(&self) -> Self {\n+        let ptr = self.raw.with_pointer_ref(P::clone);\n+\n+        Self::new(ptr, self.tag())\n+    }\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> std::ops::Deref for TaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> Deref for TaggedPtr<P, T, CP>\n where\n     P: Pointer,\n     T: Tag,\n {\n     type Target = P::Target;\n+\n+    #[inline]\n     fn deref(&self) -> &Self::Target {\n-        self.raw.pointer_ref()\n+        self.raw.deref()\n     }\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> std::ops::DerefMut for TaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> DerefMut for TaggedPtr<P, T, CP>\n where\n-    P: Pointer + std::ops::DerefMut,\n+    P: Pointer + DerefMut,\n     T: Tag,\n {\n+    #[inline]\n     fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.raw.pointer_mut()\n+        self.raw.deref_mut()\n     }\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> Drop for TaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> Drop for TaggedPtr<P, T, CP>\n where\n     P: Pointer,\n     T: Tag,\n {\n     fn drop(&mut self) {\n         // No need to drop the tag, as it's Copy\n         unsafe {\n-            drop(P::from_usize(self.raw.pointer_raw()));\n+            drop(P::from_ptr(self.raw.pointer_raw()));\n         }\n     }\n }\n \n-impl<P, T, const COMPARE_PACKED: bool> fmt::Debug for TaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, const CP: bool> fmt::Debug for TaggedPtr<P, T, CP>\n where\n-    P: Pointer,\n-    P::Target: fmt::Debug,\n+    P: Pointer + fmt::Debug,\n     T: Tag + fmt::Debug,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"TaggedPtr\")\n-            .field(\"pointer\", &self.pointer_ref())\n-            .field(\"tag\", &self.tag())\n-            .finish()\n+        self.raw.with_pointer_ref(|ptr| {\n+            f.debug_struct(\"TaggedPtr\").field(\"pointer\", ptr).field(\"tag\", &self.tag()).finish()\n+        })\n     }\n }\n \n@@ -100,6 +114,7 @@ where\n     P: Pointer,\n     T: Tag,\n {\n+    #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         self.raw.eq(&other.raw)\n     }\n@@ -112,17 +127,18 @@ where\n {\n }\n \n-impl<P, T> std::hash::Hash for TaggedPtr<P, T, true>\n+impl<P, T> Hash for TaggedPtr<P, T, true>\n where\n     P: Pointer,\n     T: Tag,\n {\n-    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         self.raw.hash(state);\n     }\n }\n \n-impl<P, T, HCX, const COMPARE_PACKED: bool> HashStable<HCX> for TaggedPtr<P, T, COMPARE_PACKED>\n+impl<P, T, HCX, const CP: bool> HashStable<HCX> for TaggedPtr<P, T, CP>\n where\n     P: Pointer + HashStable<HCX>,\n     T: Tag + HashStable<HCX>,\n@@ -131,3 +147,33 @@ where\n         self.raw.hash_stable(hcx, hasher);\n     }\n }\n+\n+/// Test that `new` does not compile if there is not enough alignment for the\n+/// tag in the pointer.\n+///\n+/// ```compile_fail,E0080\n+/// use rustc_data_structures::tagged_ptr::{TaggedPtr, Tag};\n+///\n+/// #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+/// enum Tag2 { B00 = 0b00, B01 = 0b01, B10 = 0b10, B11 = 0b11 };\n+///\n+/// unsafe impl Tag for Tag2 {\n+///     const BITS: u32 = 2;\n+///\n+///     fn into_usize(self) -> usize { todo!() }\n+///     unsafe fn from_usize(tag: usize) -> Self { todo!() }\n+/// }\n+///\n+/// let value = 12u16;\n+/// let reference = &value;\n+/// let tag = Tag2::B01;\n+///\n+/// let _ptr = TaggedPtr::<_, _, true>::new(reference, tag);\n+/// ```\n+// For some reason miri does not get the compile error\n+// probably it `check`s instead of `build`ing?\n+#[cfg(not(miri))]\n+const _: () = ();\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "2c17d678d3aa0ae6c84848ca5a5dd66aba95cc53", "filename": "compiler/rustc_data_structures/src/tagged_ptr/drop/tests.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fdrop%2Ftests.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,71 @@\n+use std::{ptr, sync::Arc};\n+\n+use crate::tagged_ptr::{Pointer, Tag, Tag2, TaggedPtr};\n+\n+#[test]\n+fn smoke() {\n+    let value = 12u32;\n+    let reference = &value;\n+    let tag = Tag2::B01;\n+\n+    let ptr = tag_ptr(reference, tag);\n+\n+    assert_eq!(ptr.tag(), tag);\n+    assert_eq!(*ptr, 12);\n+\n+    let clone = ptr.clone();\n+    assert_eq!(clone.tag(), tag);\n+    assert_eq!(*clone, 12);\n+\n+    let mut ptr = ptr;\n+    ptr.set_tag(Tag2::B00);\n+    assert_eq!(ptr.tag(), Tag2::B00);\n+\n+    assert_eq!(clone.tag(), tag);\n+    assert_eq!(*clone, 12);\n+    assert!(ptr::eq(&*ptr, &*clone))\n+}\n+\n+#[test]\n+fn boxed() {\n+    let value = 12u32;\n+    let boxed = Box::new(value);\n+    let tag = Tag2::B01;\n+\n+    let ptr = tag_ptr(boxed, tag);\n+\n+    assert_eq!(ptr.tag(), tag);\n+    assert_eq!(*ptr, 12);\n+\n+    let clone = ptr.clone();\n+    assert_eq!(clone.tag(), tag);\n+    assert_eq!(*clone, 12);\n+\n+    let mut ptr = ptr;\n+    ptr.set_tag(Tag2::B00);\n+    assert_eq!(ptr.tag(), Tag2::B00);\n+\n+    assert_eq!(clone.tag(), tag);\n+    assert_eq!(*clone, 12);\n+    assert!(!ptr::eq(&*ptr, &*clone))\n+}\n+\n+#[test]\n+fn arclones() {\n+    let value = 12u32;\n+    let arc = Arc::new(value);\n+    let tag = Tag2::B01;\n+\n+    let ptr = tag_ptr(arc, tag);\n+\n+    assert_eq!(ptr.tag(), tag);\n+    assert_eq!(*ptr, 12);\n+\n+    let clone = ptr.clone();\n+    assert!(ptr::eq(&*ptr, &*clone))\n+}\n+\n+/// Helper to create tagged pointers without specifying `COMPARE_PACKED` if it does not matter.\n+fn tag_ptr<P: Pointer, T: Tag>(ptr: P, tag: T) -> TaggedPtr<P, T, true> {\n+    TaggedPtr::new(ptr, tag)\n+}"}, {"sha": "cb7f7d318dc416316f73eac6a29ee59cce88e642", "filename": "compiler/rustc_data_structures/src/tagged_ptr/impl_tag.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fimpl_tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fimpl_tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fimpl_tag.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,144 @@\n+/// Implements [`Tag`] for a given type.\n+///\n+/// You can use `impl_tag` on structs and enums.\n+/// You need to specify the type and all its possible values,\n+/// which can only be paths with optional fields.\n+///\n+/// [`Tag`]: crate::tagged_ptr::Tag\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// #![feature(macro_metavar_expr)]\n+/// use rustc_data_structures::{impl_tag, tagged_ptr::Tag};\n+///\n+/// #[derive(Copy, Clone, PartialEq, Debug)]\n+/// enum SomeTag {\n+///     A,\n+///     B,\n+///     X { v: bool },\n+///     Y(bool, bool),\n+/// }\n+///\n+/// impl_tag! {\n+///     // The type for which the `Tag` will be implemented\n+///     impl Tag for SomeTag;\n+///     // You need to specify all possible tag values:\n+///     SomeTag::A, // 0\n+///     SomeTag::B, // 1\n+///     // For variants with fields, you need to specify the fields:\n+///     SomeTag::X { v: true  }, // 2\n+///     SomeTag::X { v: false }, // 3\n+///     // For tuple variants use named syntax:\n+///     SomeTag::Y { 0: true,  1: true  }, // 4\n+///     SomeTag::Y { 0: false, 1: true  }, // 5\n+///     SomeTag::Y { 0: true,  1: false }, // 6\n+///     SomeTag::Y { 0: false, 1: false }, // 7\n+/// }\n+///\n+/// // Tag values are assigned in order:\n+/// assert_eq!(SomeTag::A.into_usize(), 0);\n+/// assert_eq!(SomeTag::X { v: false }.into_usize(), 3);\n+/// assert_eq!(SomeTag::Y(false, true).into_usize(), 5);\n+///\n+/// assert_eq!(unsafe { SomeTag::from_usize(1) }, SomeTag::B);\n+/// assert_eq!(unsafe { SomeTag::from_usize(2) }, SomeTag::X { v: true });\n+/// assert_eq!(unsafe { SomeTag::from_usize(7) }, SomeTag::Y(false, false));\n+/// ```\n+///\n+/// Structs are supported:\n+///\n+/// ```\n+/// #![feature(macro_metavar_expr)]\n+/// # use rustc_data_structures::impl_tag;\n+/// #[derive(Copy, Clone)]\n+/// struct Flags { a: bool, b: bool }\n+///\n+/// impl_tag! {\n+///     impl Tag for Flags;\n+///     Flags { a: true,  b: true  },\n+///     Flags { a: false, b: true  },\n+///     Flags { a: true,  b: false },\n+///     Flags { a: false, b: false },\n+/// }\n+/// ```\n+///\n+/// Not specifying all values results in a compile error:\n+///\n+/// ```compile_fail,E0004\n+/// #![feature(macro_metavar_expr)]\n+/// # use rustc_data_structures::impl_tag;\n+/// #[derive(Copy, Clone)]\n+/// enum E {\n+///     A,\n+///     B,\n+/// }\n+///\n+/// impl_tag! {\n+///     impl Tag for E;\n+///     E::A,\n+/// }\n+/// ```\n+#[macro_export]\n+macro_rules! impl_tag {\n+    (\n+        impl Tag for $Self:ty;\n+        $(\n+            $($path:ident)::* $( { $( $fields:tt )* })?,\n+        )*\n+    ) => {\n+        // Safety:\n+        // `bits_for_tags` is called on the same `${index()}`-es as\n+        // `into_usize` returns, thus `BITS` constant is correct.\n+        unsafe impl $crate::tagged_ptr::Tag for $Self {\n+            const BITS: u32 = $crate::tagged_ptr::bits_for_tags(&[\n+                $(\n+                    ${index()},\n+                    $( ${ignore(path)} )*\n+                )*\n+            ]);\n+\n+            #[inline]\n+            fn into_usize(self) -> usize {\n+                // This forbids use of repeating patterns (`Enum::V`&`Enum::V`, etc)\n+                // (or at least it should, see <https://github.com/rust-lang/rust/issues/110613>)\n+                #[forbid(unreachable_patterns)]\n+                match self {\n+                    // `match` is doing heavy lifting here, by requiring exhaustiveness\n+                    $(\n+                        $($path)::* $( { $( $fields )* } )? => ${index()},\n+                    )*\n+                }\n+            }\n+\n+            #[inline]\n+            unsafe fn from_usize(tag: usize) -> Self {\n+                match tag {\n+                    $(\n+                        ${index()} => $($path)::* $( { $( $fields )* } )?,\n+                    )*\n+\n+                    // Safety:\n+                    // `into_usize` only returns `${index()}` of the same\n+                    // repetition as we are filtering above, thus if this is\n+                    // reached, the safety contract of this function was\n+                    // already breached.\n+                    _ => unsafe {\n+                        debug_assert!(\n+                            false,\n+                            \"invalid tag: {tag}\\\n+                             (this is a bug in the caller of `from_usize`)\"\n+                        );\n+                        std::hint::unreachable_unchecked()\n+                    },\n+                }\n+            }\n+\n+        }\n+    };\n+}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "62c926153e1e9f86fff3e438729bc0f3384ef742", "filename": "compiler/rustc_data_structures/src/tagged_ptr/impl_tag/tests.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fimpl_tag%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fimpl_tag%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftagged_ptr%2Fimpl_tag%2Ftests.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,34 @@\n+#[test]\n+fn bits_constant() {\n+    use crate::tagged_ptr::Tag;\n+\n+    #[derive(Copy, Clone)]\n+    struct Unit;\n+    impl_tag! { impl Tag for Unit; Unit, }\n+    assert_eq!(Unit::BITS, 0);\n+\n+    #[derive(Copy, Clone)]\n+    enum Enum3 {\n+        A,\n+        B,\n+        C,\n+    }\n+    impl_tag! { impl Tag for Enum3; Enum3::A, Enum3::B, Enum3::C, }\n+    assert_eq!(Enum3::BITS, 2);\n+\n+    #[derive(Copy, Clone)]\n+    struct Eight(bool, bool, bool);\n+    impl_tag! {\n+        impl Tag for Eight;\n+        Eight { 0: true,  1: true,  2: true  },\n+        Eight { 0: true,  1: true,  2: false },\n+        Eight { 0: true,  1: false, 2: true  },\n+        Eight { 0: true,  1: false, 2: false },\n+        Eight { 0: false, 1: true,  2: true  },\n+        Eight { 0: false, 1: true,  2: false },\n+        Eight { 0: false, 1: false, 2: true  },\n+        Eight { 0: false, 1: false, 2: false },\n+    }\n+\n+    assert_eq!(Eight::BITS, 3);\n+}"}, {"sha": "fda72c9a3b2042af1b2753b3f61b8403948d4326", "filename": "compiler/rustc_data_structures/src/vec_linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fvec_linked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fvec_linked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_linked_list.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,4 +1,4 @@\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::{Idx, IndexVec};\n \n pub fn iter<Ls>(\n     first: Option<Ls::LinkIndex>,"}, {"sha": "9db6b6f20bede576f74fcddd37e912a562bcd635", "filename": "compiler/rustc_data_structures/src/work_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fwork_queue.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,5 +1,5 @@\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::Idx;\n+use rustc_index::Idx;\n use std::collections::VecDeque;\n \n /// A work queue is a handy data structure for tracking work left to"}, {"sha": "cc4c5a0cacddf596dffd93b409c3d117985f1d5b", "filename": "compiler/rustc_driver_impl/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_driver_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_driver_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -18,6 +18,7 @@ rustc_const_eval = { path = \"../rustc_const_eval\" }\n rustc_error_messages = { path = \"../rustc_error_messages\" }\n rustc_expand = { path = \"../rustc_expand\" }\n rustc_hir_typeck = { path = \"../rustc_hir_typeck\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_incremental = { path = \"../rustc_incremental\" }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_mir_build = { path = \"../rustc_mir_build\" }"}, {"sha": "5fac485de6417dd5c41e73460a3652333a9cfa67", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 49, "deletions": 41, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -28,10 +28,10 @@ use rustc_errors::{\n     DiagnosticMessage, ErrorGuaranteed, PResult, SubdiagnosticMessage, TerminalUrl,\n };\n use rustc_feature::find_gated_cfg;\n+use rustc_fluent_macro::fluent_messages;\n use rustc_interface::util::{self, collect_crate_types, get_codegen_backend};\n use rustc_interface::{interface, Queries};\n use rustc_lint::LintStore;\n-use rustc_macros::fluent_messages;\n use rustc_metadata::locator;\n use rustc_session::config::{nightly_options, CG_OPTIONS, Z_OPTIONS};\n use rustc_session::config::{ErrorOutputType, Input, OutputType, PrintRequest, TrimmedDefPaths};\n@@ -58,8 +58,16 @@ use std::str;\n use std::sync::LazyLock;\n use std::time::Instant;\n \n+// This import blocks the use of panicking `print` and `println` in all the code\n+// below. Please use `safe_print` and `safe_println` to avoid ICE when\n+// encountering an I/O error during print.\n+#[allow(unused_imports)]\n+use std::{compile_error as print, compile_error as println};\n+\n pub mod args;\n pub mod pretty;\n+#[macro_use]\n+mod print;\n mod session_diagnostics;\n \n use crate::session_diagnostics::{\n@@ -511,7 +519,7 @@ fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n             if io::stdout().is_terminal() {\n                 show_content_with_pager(&text);\n             } else {\n-                print!(\"{text}\");\n+                safe_print!(\"{text}\");\n             }\n         }\n         Err(InvalidErrorCode) => {\n@@ -547,7 +555,7 @@ fn show_content_with_pager(content: &str) {\n     // If pager fails for whatever reason, we should still print the content\n     // to standard output\n     if fallback_to_println {\n-        print!(\"{content}\");\n+        safe_print!(\"{content}\");\n     }\n }\n \n@@ -601,7 +609,7 @@ pub fn list_metadata(sess: &Session, metadata_loader: &dyn MetadataLoader) -> Co\n                 let path = &(*ifile);\n                 let mut v = Vec::new();\n                 locator::list_file_metadata(&sess.target, path, metadata_loader, &mut v).unwrap();\n-                println!(\"{}\", String::from_utf8(v).unwrap());\n+                safe_println!(\"{}\", String::from_utf8(v).unwrap());\n             }\n             Input::Str { .. } => {\n                 early_error(ErrorOutputType::default(), \"cannot list metadata for stdin\");\n@@ -642,12 +650,12 @@ fn print_crate_info(\n             TargetList => {\n                 let mut targets = rustc_target::spec::TARGETS.to_vec();\n                 targets.sort_unstable();\n-                println!(\"{}\", targets.join(\"\\n\"));\n+                safe_println!(\"{}\", targets.join(\"\\n\"));\n             }\n-            Sysroot => println!(\"{}\", sess.sysroot.display()),\n-            TargetLibdir => println!(\"{}\", sess.target_tlib_path.dir.display()),\n+            Sysroot => safe_println!(\"{}\", sess.sysroot.display()),\n+            TargetLibdir => safe_println!(\"{}\", sess.target_tlib_path.dir.display()),\n             TargetSpec => {\n-                println!(\"{}\", serde_json::to_string_pretty(&sess.target.to_json()).unwrap());\n+                safe_println!(\"{}\", serde_json::to_string_pretty(&sess.target.to_json()).unwrap());\n             }\n             AllTargetSpecs => {\n                 let mut targets = BTreeMap::new();\n@@ -656,7 +664,7 @@ fn print_crate_info(\n                     let target = Target::expect_builtin(&triple);\n                     targets.insert(name, target.to_json());\n                 }\n-                println!(\"{}\", serde_json::to_string_pretty(&targets).unwrap());\n+                safe_println!(\"{}\", serde_json::to_string_pretty(&targets).unwrap());\n             }\n             FileNames | CrateName => {\n                 let Some(attrs) = attrs.as_ref() else {\n@@ -666,14 +674,14 @@ fn print_crate_info(\n                 let t_outputs = rustc_interface::util::build_output_filenames(attrs, sess);\n                 let id = rustc_session::output::find_crate_name(sess, attrs);\n                 if *req == PrintRequest::CrateName {\n-                    println!(\"{id}\");\n+                    safe_println!(\"{id}\");\n                     continue;\n                 }\n                 let crate_types = collect_crate_types(sess, attrs);\n                 for &style in &crate_types {\n                     let fname =\n                         rustc_session::output::filename_for_input(sess, style, id, &t_outputs);\n-                    println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n+                    safe_println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n                 }\n             }\n             Cfg => {\n@@ -707,13 +715,13 @@ fn print_crate_info(\n \n                 cfgs.sort();\n                 for cfg in cfgs {\n-                    println!(\"{cfg}\");\n+                    safe_println!(\"{cfg}\");\n                 }\n             }\n             CallingConventions => {\n                 let mut calling_conventions = rustc_target::spec::abi::all_names();\n                 calling_conventions.sort_unstable();\n-                println!(\"{}\", calling_conventions.join(\"\\n\"));\n+                safe_println!(\"{}\", calling_conventions.join(\"\\n\"));\n             }\n             RelocationModels\n             | CodeModels\n@@ -733,7 +741,7 @@ fn print_crate_info(\n                     let stable = sess.target.options.supported_split_debuginfo.contains(split);\n                     let unstable_ok = sess.unstable_options();\n                     if stable || unstable_ok {\n-                        println!(\"{split}\");\n+                        safe_println!(\"{split}\");\n                     }\n                 }\n             }\n@@ -770,14 +778,14 @@ pub fn version_at_macro_invocation(\n ) {\n     let verbose = matches.opt_present(\"verbose\");\n \n-    println!(\"{binary} {version}\");\n+    safe_println!(\"{binary} {version}\");\n \n     if verbose {\n-        println!(\"binary: {binary}\");\n-        println!(\"commit-hash: {commit_hash}\");\n-        println!(\"commit-date: {commit_date}\");\n-        println!(\"host: {}\", config::host_triple());\n-        println!(\"release: {release}\");\n+        safe_println!(\"binary: {binary}\");\n+        safe_println!(\"commit-hash: {commit_hash}\");\n+        safe_println!(\"commit-date: {commit_date}\");\n+        safe_println!(\"host: {}\", config::host_triple());\n+        safe_println!(\"release: {release}\");\n \n         let debug_flags = matches.opt_strs(\"Z\");\n         let backend_name = debug_flags.iter().find_map(|x| x.strip_prefix(\"codegen-backend=\"));\n@@ -807,7 +815,7 @@ fn usage(verbose: bool, include_unstable_options: bool, nightly_build: bool) {\n     } else {\n         \"\"\n     };\n-    println!(\n+    safe_println!(\n         \"{options}{at_path}\\nAdditional help:\n     -C help             Print codegen options\n     -W help             \\\n@@ -820,7 +828,7 @@ fn usage(verbose: bool, include_unstable_options: bool, nightly_build: bool) {\n }\n \n fn print_wall_help() {\n-    println!(\n+    safe_println!(\n         \"\n The flag `-Wall` does not exist in `rustc`. Most useful lints are enabled by\n default. Use `rustc -W help` to see all available lints. It's more common to put\n@@ -832,7 +840,7 @@ the command line flag directly.\n \n /// Write to stdout lint command options, together with a list of all available lints\n pub fn describe_lints(sess: &Session, lint_store: &LintStore, loaded_plugins: bool) {\n-    println!(\n+    safe_println!(\n         \"\n Available lint options:\n     -W <foo>           Warn about <foo>\n@@ -877,21 +885,21 @@ Available lint options:\n         s\n     };\n \n-    println!(\"Lint checks provided by rustc:\\n\");\n+    safe_println!(\"Lint checks provided by rustc:\\n\");\n \n     let print_lints = |lints: Vec<&Lint>| {\n-        println!(\"    {}  {:7.7}  {}\", padded(\"name\"), \"default\", \"meaning\");\n-        println!(\"    {}  {:7.7}  {}\", padded(\"----\"), \"-------\", \"-------\");\n+        safe_println!(\"    {}  {:7.7}  {}\", padded(\"name\"), \"default\", \"meaning\");\n+        safe_println!(\"    {}  {:7.7}  {}\", padded(\"----\"), \"-------\", \"-------\");\n         for lint in lints {\n             let name = lint.name_lower().replace('_', \"-\");\n-            println!(\n+            safe_println!(\n                 \"    {}  {:7.7}  {}\",\n                 padded(&name),\n                 lint.default_level(sess.edition()).as_str(),\n                 lint.desc\n             );\n         }\n-        println!(\"\\n\");\n+        safe_println!(\"\\n\");\n     };\n \n     print_lints(builtin);\n@@ -912,14 +920,14 @@ Available lint options:\n         s\n     };\n \n-    println!(\"Lint groups provided by rustc:\\n\");\n+    safe_println!(\"Lint groups provided by rustc:\\n\");\n \n     let print_lint_groups = |lints: Vec<(&'static str, Vec<LintId>)>, all_warnings| {\n-        println!(\"    {}  sub-lints\", padded(\"name\"));\n-        println!(\"    {}  ---------\", padded(\"----\"));\n+        safe_println!(\"    {}  sub-lints\", padded(\"name\"));\n+        safe_println!(\"    {}  ---------\", padded(\"----\"));\n \n         if all_warnings {\n-            println!(\"    {}  all lints that are set to issue warnings\", padded(\"warnings\"));\n+            safe_println!(\"    {}  all lints that are set to issue warnings\", padded(\"warnings\"));\n         }\n \n         for (name, to) in lints {\n@@ -929,26 +937,26 @@ Available lint options:\n                 .map(|x| x.to_string().replace('_', \"-\"))\n                 .collect::<Vec<String>>()\n                 .join(\", \");\n-            println!(\"    {}  {}\", padded(&name), desc);\n+            safe_println!(\"    {}  {}\", padded(&name), desc);\n         }\n-        println!(\"\\n\");\n+        safe_println!(\"\\n\");\n     };\n \n     print_lint_groups(builtin_groups, true);\n \n     match (loaded_plugins, plugin.len(), plugin_groups.len()) {\n         (false, 0, _) | (false, _, 0) => {\n-            println!(\"Lint tools like Clippy can provide additional lints and lint groups.\");\n+            safe_println!(\"Lint tools like Clippy can provide additional lints and lint groups.\");\n         }\n         (false, ..) => panic!(\"didn't load lint plugins but got them anyway!\"),\n-        (true, 0, 0) => println!(\"This crate does not load any lint plugins or lint groups.\"),\n+        (true, 0, 0) => safe_println!(\"This crate does not load any lint plugins or lint groups.\"),\n         (true, l, g) => {\n             if l > 0 {\n-                println!(\"Lint checks provided by plugins loaded by this crate:\\n\");\n+                safe_println!(\"Lint checks provided by plugins loaded by this crate:\\n\");\n                 print_lints(plugin);\n             }\n             if g > 0 {\n-                println!(\"Lint groups provided by plugins loaded by this crate:\\n\");\n+                safe_println!(\"Lint groups provided by plugins loaded by this crate:\\n\");\n                 print_lint_groups(plugin_groups, false);\n             }\n         }\n@@ -996,12 +1004,12 @@ pub fn describe_flag_categories(matches: &Matches) -> bool {\n }\n \n fn describe_debug_flags() {\n-    println!(\"\\nAvailable options:\\n\");\n+    safe_println!(\"\\nAvailable options:\\n\");\n     print_flag_list(\"-Z\", config::Z_OPTIONS);\n }\n \n fn describe_codegen_flags() {\n-    println!(\"\\nAvailable codegen options:\\n\");\n+    safe_println!(\"\\nAvailable codegen options:\\n\");\n     print_flag_list(\"-C\", config::CG_OPTIONS);\n }\n \n@@ -1012,7 +1020,7 @@ fn print_flag_list<T>(\n     let max_len = flag_list.iter().map(|&(name, _, _, _)| name.chars().count()).max().unwrap_or(0);\n \n     for &(name, _, _, desc) in flag_list {\n-        println!(\n+        safe_println!(\n             \"    {} {:>width$}=val -- {}\",\n             cmdline_opt,\n             name.replace('_', \"-\"),"}, {"sha": "ee64b18d3f60cb443d8fe00ce36fbf2da828d85a", "filename": "compiler/rustc_driver_impl/src/pretty.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_driver_impl%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_driver_impl%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Fpretty.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -488,12 +488,7 @@ fn print_with_analysis(tcx: TyCtxt<'_>, ppm: PpMode) -> Result<(), ErrorGuarante\n             abort_on_err(rustc_hir_analysis::check_crate(tcx), tcx.sess);\n             debug!(\"pretty printing THIR tree\");\n             for did in tcx.hir().body_owners() {\n-                let _ = writeln!(\n-                    out,\n-                    \"{:?}:\\n{}\\n\",\n-                    did,\n-                    tcx.thir_tree(ty::WithOptConstParam::unknown(did))\n-                );\n+                let _ = writeln!(out, \"{:?}:\\n{}\\n\", did, tcx.thir_tree(did));\n             }\n             out\n         }\n@@ -503,12 +498,7 @@ fn print_with_analysis(tcx: TyCtxt<'_>, ppm: PpMode) -> Result<(), ErrorGuarante\n             abort_on_err(rustc_hir_analysis::check_crate(tcx), tcx.sess);\n             debug!(\"pretty printing THIR flat\");\n             for did in tcx.hir().body_owners() {\n-                let _ = writeln!(\n-                    out,\n-                    \"{:?}:\\n{}\\n\",\n-                    did,\n-                    tcx.thir_flat(ty::WithOptConstParam::unknown(did))\n-                );\n+                let _ = writeln!(out, \"{:?}:\\n{}\\n\", did, tcx.thir_flat(did));\n             }\n             out\n         }"}, {"sha": "70de55320f7ae1830c196887baf30f5f7671542b", "filename": "compiler/rustc_driver_impl/src/print.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_driver_impl%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_driver_impl%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Fprint.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,20 @@\n+use std::fmt;\n+use std::io::{self, Write as _};\n+\n+macro_rules! safe_print {\n+    ($($arg:tt)*) => {{\n+        $crate::print::print(std::format_args!($($arg)*));\n+    }};\n+}\n+\n+macro_rules! safe_println {\n+    ($($arg:tt)*) => {\n+        safe_print!(\"{}\\n\", std::format_args!($($arg)*))\n+    };\n+}\n+\n+pub(crate) fn print(args: fmt::Arguments<'_>) {\n+    if let Err(_) = io::stdout().write_fmt(args) {\n+        rustc_errors::FatalError.raise();\n+    }\n+}"}, {"sha": "f485112cca29fe156e1d8aff8aba2f8600706279", "filename": "compiler/rustc_error_codes/src/error_codes/E0026.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0026.md", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0026.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0026.md?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,4 +1,4 @@\n-A struct pattern attempted to extract a non-existent field from a struct.\n+A struct pattern attempted to extract a nonexistent field from a struct.\n \n Erroneous code example:\n "}, {"sha": "c6db9b5d61bea64055151c0bcbf8a81a826d67e1", "filename": "compiler/rustc_error_codes/src/error_codes/E0208.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0208.md", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0208.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0208.md?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -32,7 +32,7 @@ error: [-, o]\n This error is deliberately triggered with the `#[rustc_variance]` attribute\n (`#![feature(rustc_attrs)]` must be enabled) and helps to show you the variance\n of the type's generic parameters. You can read more about variance and\n-subtyping in [this section of the Rustnomicon]. For a more in depth look at\n+subtyping in [this section of the Rustonomicon]. For a more in depth look at\n variance (including a more complete list of common variances) see\n [this section of the Reference]. For information on how variance is implemented\n in the compiler, see [this section of `rustc-dev-guide`].\n@@ -41,6 +41,6 @@ This error can be easily fixed by removing the `#[rustc_variance]` attribute,\n the compiler's suggestion to comment it out can be applied automatically with\n `rustfix`.\n \n-[this section of the Rustnomicon]: https://doc.rust-lang.org/nomicon/subtyping.html\n+[this section of the Rustonomicon]: https://doc.rust-lang.org/nomicon/subtyping.html\n [this section of the Reference]: https://doc.rust-lang.org/reference/subtyping.html#variance\n [this section of `rustc-dev-guide`]: https://rustc-dev-guide.rust-lang.org/variance.html"}, {"sha": "c1104a88a7676a4738593cae2594c7e6a5b3b4a4", "filename": "compiler/rustc_error_codes/src/error_codes/E0311.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0311.md", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0311.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0311.md?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -29,7 +29,7 @@ If `no_restriction()` were to use `&T` instead of `&()` as an argument, the\n compiler would have added an implied bound, causing this to compile.\n \n This error can be resolved by explicitly naming the elided lifetime for `x` and\n-then explicily requiring that the generic parameter `T` outlives that lifetime:\n+then explicitly requiring that the generic parameter `T` outlives that lifetime:\n \n ```\n fn no_restriction<'a, T: 'a>(x: &'a ()) -> &'a () {"}, {"sha": "2c33d1e6a24191462c83e2e9df5e82d50f7b6b38", "filename": "compiler/rustc_error_codes/src/error_codes/E0457.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0457.md", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0457.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0457.md?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,6 +1,6 @@\n Plugin `..` only found in rlib format, but must be available in dylib format.\n \n-Erroronous code example:\n+Erroneous code example:\n \n `rlib-plugin.rs`\n ```ignore (needs-linkage-with-other-tests)"}, {"sha": "300a57a1985f5d961c4f2976d01d86a67aa5987b", "filename": "compiler/rustc_error_codes/src/error_codes/E0576.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0576.md", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0576.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0576.md?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -10,7 +10,7 @@ trait Hello {\n }\n ```\n \n-In this example, we tried to use the non-existent associated type `You` of the\n+In this example, we tried to use the nonexistent associated type `You` of the\n `Hello` trait. To fix this error, use an existing associated type:\n \n ```"}, {"sha": "0f5ac94e6d589eb9190e7e4a7181fc4177bf7f0f", "filename": "compiler/rustc_error_codes/src/error_codes/E0609.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0609.md", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0609.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0609.md?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,4 +1,4 @@\n-Attempted to access a non-existent field in a struct.\n+Attempted to access a nonexistent field in a struct.\n \n Erroneous code example:\n "}, {"sha": "481c94266f2716abaeab32fcfffe6242fc90ff12", "filename": "compiler/rustc_error_messages/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_messages%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_messages%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -11,6 +11,7 @@ fluent-syntax = \"0.11\"\n intl-memoizer = \"0.5.1\"\n rustc_baked_icu_data = { path = \"../rustc_baked_icu_data\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "88d94c93bf520bd7d70c92b404886694b5621ed8", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -12,7 +12,8 @@ use fluent_bundle::FluentResource;\n use fluent_syntax::parser::ParserError;\n use icu_provider_adapters::fallback::{LocaleFallbackProvider, LocaleFallbacker};\n use rustc_data_structures::sync::Lrc;\n-use rustc_macros::{fluent_messages, Decodable, Encodable};\n+use rustc_fluent_macro::fluent_messages;\n+use rustc_macros::{Decodable, Encodable};\n use rustc_span::Span;\n use std::borrow::Cow;\n use std::error::Error;"}, {"sha": "46ace8eb2dd8d2d25dba642d54b54f42d7c1261c", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -10,6 +10,7 @@ tracing = \"0.1\"\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_error_messages = { path = \"../rustc_error_messages\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "2498ae2b7bce541fc752740c0e1281853dd0cea6", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1336,6 +1336,7 @@ impl EmitterWriter {\n         //                see?\n         for (text, style) in msg.iter() {\n             let text = self.translate_message(text, args).map_err(Report::new).unwrap();\n+            let text = &normalize_whitespace(&text);\n             let lines = text.split('\\n').collect::<Vec<_>>();\n             if lines.len() > 1 {\n                 for (i, line) in lines.iter().enumerate() {\n@@ -1980,7 +1981,7 @@ impl EmitterWriter {\n             }\n             if let DisplaySuggestion::Add = show_code_change && is_item_attribute {\n                 // The suggestion adds an entire line of code, ending on a newline, so we'll also\n-                // print the *following* line, to provide context of what we're advicing people to\n+                // print the *following* line, to provide context of what we're advising people to\n                 // do. Otherwise you would only see contextless code that can be confused for\n                 // already existing code, despite the colors and UI elements.\n                 // We special case `#[derive(_)]\\n` and other attribute suggestions, because those"}, {"sha": "b65a636d7701c0264652208afe1a27d3230caba1", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -31,15 +31,15 @@ use Level::*;\n use emitter::{is_case_difference, Emitter, EmitterWriter};\n use registry::Registry;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n-use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::stable_hasher::{Hash128, StableHasher};\n use rustc_data_structures::sync::{self, Lock, Lrc};\n use rustc_data_structures::AtomicRef;\n pub use rustc_error_messages::{\n     fallback_fluent_bundle, fluent_bundle, DelayDm, DiagnosticMessage, FluentBundle,\n     LanguageIdentifier, LazyFallbackBundle, MultiSpan, SpanLabel, SubdiagnosticMessage,\n };\n+use rustc_fluent_macro::fluent_messages;\n pub use rustc_lint_defs::{pluralize, Applicability};\n-use rustc_macros::fluent_messages;\n use rustc_span::source_map::SourceMap;\n pub use rustc_span::ErrorGuaranteed;\n use rustc_span::{Loc, Span};\n@@ -427,7 +427,7 @@ struct HandlerInner {\n     /// This set contains a hash of every diagnostic that has been emitted by\n     /// this handler. These hashes is used to avoid emitting the same error\n     /// twice.\n-    emitted_diagnostics: FxHashSet<u128>,\n+    emitted_diagnostics: FxHashSet<Hash128>,\n \n     /// Stashed diagnostics emitted in one stage of the compiler that may be\n     /// stolen by other stages (e.g. to improve them and add more information)."}, {"sha": "2dae0e3f53c3c064010139497a294bd691189743", "filename": "compiler/rustc_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -16,6 +16,7 @@ rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_feature = { path = \"../rustc_feature\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "70d2718b70639937e99ae0213de0589b62cae944", "filename": "compiler/rustc_expand/messages.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fmessages.ftl?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -136,3 +136,7 @@ expand_proc_macro_panicked =\n \n expand_proc_macro_derive_tokens =\n     proc-macro derive produced unparsable tokens\n+\n+expand_duplicate_matcher_binding = duplicate matcher binding\n+    .label = duplicate binding\n+    .label2 = previous binding"}, {"sha": "e3a0ae3570eb074c1a0a37cfaa67d507810c44c4", "filename": "compiler/rustc_expand/src/errors.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -397,3 +397,13 @@ pub struct ProcMacroDeriveTokens {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_duplicate_matcher_binding)]\n+pub struct DuplicateMatcherBinding {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(expand_label2)]\n+    pub prev: Span,\n+}"}, {"sha": "83a5043b0aa6f1c49975bf1c9df05c8b07bac72c", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -21,7 +21,7 @@ extern crate tracing;\n extern crate proc_macro as pm;\n \n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n-use rustc_macros::fluent_messages;\n+use rustc_fluent_macro::fluent_messages;\n \n mod placeholders;\n mod proc_macro_server;"}, {"sha": "75b6396f0be383f4ebd11249820ebb6177b749bd", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -104,6 +104,7 @@\n //! Kleene operators under which a meta-variable is repeating is the concatenation of the stacks\n //! stored when entering a macro definition starting from the state in which the meta-variable is\n //! bound.\n+use crate::errors;\n use crate::mbe::{KleeneToken, TokenTree};\n \n use rustc_ast::token::{Delimiter, Token, TokenKind};\n@@ -281,10 +282,7 @@ fn check_binders(\n                 // Duplicate binders at the top-level macro definition are errors. The lint is only\n                 // for nested macro definitions.\n                 sess.span_diagnostic\n-                    .struct_span_err(span, \"duplicate matcher binding\")\n-                    .span_label(span, \"duplicate binding\")\n-                    .span_label(prev_info.span, \"previous binding\")\n-                    .emit();\n+                    .emit_err(errors::DuplicateMatcherBinding { span, prev: prev_info.span });\n                 *valid = false;\n             } else {\n                 binders.insert(name, BinderInfo { span, ops: ops.into() });"}, {"sha": "3aeb2edb54ca0ac34046dd2d847cb0b8c16212d7", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -341,7 +341,7 @@ pub(super) fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n             Success(named_matches) => {\n                 debug!(\"Parsed arm successfully\");\n                 // The matcher was `Success(..)`ful.\n-                // Merge the gated spans from parsing the matcher with the pre-existing ones.\n+                // Merge the gated spans from parsing the matcher with the preexisting ones.\n                 sess.gated_spans.merge(gated_spans_snapshot);\n \n                 return Ok((i, named_matches));\n@@ -873,7 +873,7 @@ impl<'tt> FirstSets<'tt> {\n     }\n }\n \n-// Most `mbe::TokenTree`s are pre-existing in the matcher, but some are defined\n+// Most `mbe::TokenTree`s are preexisting in the matcher, but some are defined\n // implicitly, such as opening/closing delimiters and sequence repetition ops.\n // This type encapsulates both kinds. It implements `Clone` while avoiding the\n // need for `mbe::TokenTree` to implement `Clone`."}, {"sha": "1e7d07bc22d52421016fd3c939ede69a4f38c0f2", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -18,7 +18,7 @@ use rustc_span::def_id::CrateNum;\n use rustc_span::symbol::{self, sym, Symbol};\n use rustc_span::{BytePos, FileName, Pos, SourceFile, Span};\n use smallvec::{smallvec, SmallVec};\n-use std::ops::Bound;\n+use std::ops::{Bound, Range};\n \n trait FromInternal<T> {\n     fn from_internal(x: T) -> Self;\n@@ -634,6 +634,15 @@ impl server::Span for Rustc<'_, '_> {\n         span.source_callsite()\n     }\n \n+    fn byte_range(&mut self, span: Self::Span) -> Range<usize> {\n+        let source_map = self.sess().source_map();\n+\n+        let relative_start_pos = source_map.lookup_byte_offset(span.lo()).pos;\n+        let relative_end_pos = source_map.lookup_byte_offset(span.hi()).pos;\n+\n+        Range { start: relative_start_pos.0 as usize, end: relative_end_pos.0 as usize }\n+    }\n+\n     fn start(&mut self, span: Self::Span) -> LineColumn {\n         let loc = self.sess().source_map().lookup_char_pos(span.lo());\n         LineColumn { line: loc.line, column: loc.col.to_usize() }"}, {"sha": "8a5e09475ff13e3c6be7e660dbafd600aeb71c23", "filename": "compiler/rustc_expand/src/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftests.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -513,7 +513,7 @@ error: foo\n }\n \n #[test]\n-fn non_overlaping() {\n+fn non_overlapping() {\n     test_harness(\n         r#\"\n fn foo() {\n@@ -552,7 +552,7 @@ error: foo\n }\n \n #[test]\n-fn overlaping_start_and_end() {\n+fn overlapping_start_and_end() {\n     test_harness(\n         r#\"\n fn foo() {"}, {"sha": "3b9fc5e9a513cb19a0742b7c8b33e38400f461e5", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -239,7 +239,7 @@ declare_features! (\n     /// Allows using `Self` and associated types in struct expressions and patterns.\n     (accepted, more_struct_aliases, \"1.16.0\", Some(37544), None),\n     /// Allows using the MOVBE target feature.\n-    (accepted, movbe_target_feature, \"CURRENT_RUSTC_VERSION\", Some(44839), None),\n+    (accepted, movbe_target_feature, \"1.70.0\", Some(44839), None),\n     /// Allows patterns with concurrent by-move and by-ref bindings.\n     /// For example, you can write `Foo(a, ref b)` where `a` is by-move and `b` is by-ref.\n     (accepted, move_ref_pattern, \"1.49.0\", Some(68354), None),"}, {"sha": "052d312d9a0d5bea7a06d5b396c927905147aa4b", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -417,7 +417,7 @@ declare_features! (\n     /// Allows `if let` guard in match arms.\n     (active, if_let_guard, \"1.47.0\", Some(51114), None),\n     /// Allows `impl Trait` to be used inside associated types (RFC 2515).\n-    (active, impl_trait_in_assoc_type, \"CURRENT_RUSTC_VERSION\", Some(63063), None),\n+    (active, impl_trait_in_assoc_type, \"1.70.0\", Some(63063), None),\n     /// Allows `impl Trait` as output type in `Fn` traits in return position of functions.\n     (active, impl_trait_in_fn_trait_return, \"1.64.0\", Some(99697), None),\n     /// Allows referencing `Self` and projections in impl-trait.\n@@ -498,7 +498,7 @@ declare_features! (\n     /// Allows return-position `impl Trait` in traits.\n     (incomplete, return_position_impl_trait_in_trait, \"1.65.0\", Some(91611), None),\n     /// Allows bounding the return type of AFIT/RPITIT.\n-    (incomplete, return_type_notation, \"CURRENT_RUSTC_VERSION\", Some(109417), None),\n+    (incomplete, return_type_notation, \"1.70.0\", Some(109417), None),\n     /// Allows `extern \"rust-cold\"`.\n     (active, rust_cold_cc, \"1.63.0\", Some(97544), None),\n     /// Allows the use of SIMD types in functions declared in `extern` blocks.\n@@ -521,7 +521,7 @@ declare_features! (\n     /// Dyn upcasting is casting, e.g., `dyn Foo -> dyn Bar` where `Foo: Bar`.\n     (active, trait_upcasting, \"1.56.0\", Some(65991), None),\n     /// Allows for transmuting between arrays with sizes that contain generic consts.\n-    (active, transmute_generic_consts, \"CURRENT_RUSTC_VERSION\", Some(109929), None),\n+    (active, transmute_generic_consts, \"1.70.0\", Some(109929), None),\n     /// Allows #[repr(transparent)] on unions (RFC 2645).\n     (active, transparent_unions, \"1.37.0\", Some(60405), None),\n     /// Allows inconsistent bounds in where clauses."}, {"sha": "103e0f344070d355254374573e326761af54131d", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -344,7 +344,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n     ungated!(link_name, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n     ungated!(no_link, Normal, template!(Word), WarnFollowing),\n-    ungated!(repr, Normal, template!(List: \"C\"), DuplicatesOk, @only_local: true),\n+    ungated!(repr, Normal, template!(List: \"C\"), DuplicatesOk),\n     ungated!(export_name, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n     ungated!(link_section, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n     ungated!(no_mangle, Normal, template!(Word), WarnFollowing, @only_local: true),"}, {"sha": "8bca24b2bf01e1bd016fcbeb3deaa171d9c15705", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -53,7 +53,7 @@ declare_features! (\n     (removed, await_macro, \"1.38.0\", Some(50547), None,\n      Some(\"subsumed by `.await` syntax\")),\n     /// Allows using the `box $expr` syntax.\n-    (removed, box_syntax, \"CURRENT_RUSTC_VERSION\", Some(49733), None, Some(\"replaced with `#[rustc_box]`\")),\n+    (removed, box_syntax, \"1.70.0\", Some(49733), None, Some(\"replaced with `#[rustc_box]`\")),\n     /// Allows capturing disjoint fields in a closure/generator (RFC 2229).\n     (removed, capture_disjoint_fields, \"1.49.0\", Some(53488), None, Some(\"stabilized in Rust 2021\")),\n     /// Allows comparing raw pointers during const eval.\n@@ -139,7 +139,7 @@ declare_features! (\n     /// Allows using `#[on_unimplemented(..)]` on traits.\n     /// (Moved to `rustc_attrs`.)\n     (removed, on_unimplemented, \"1.40.0\", None, None, None),\n-    /// A way to temporarily opt out of opt in copy. This will *never* be accepted.\n+    /// A way to temporarily opt out of opt-in copy. This will *never* be accepted.\n     (removed, opt_out_copy, \"1.0.0\", None, None, None),\n     /// Allows features specific to OIBIT (now called auto traits).\n     /// Renamed to `auto_traits`."}, {"sha": "f5a6585b5c68af103f997e19a107933334c2b5d6", "filename": "compiler/rustc_fluent_macro/Cargo.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_fluent_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_fluent_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_fluent_macro%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,16 @@\n+[package]\n+name = \"rustc_fluent_macro\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+[lib]\n+proc-macro = true\n+\n+[dependencies]\n+annotate-snippets = \"0.9\"\n+fluent-bundle = \"0.15.2\"\n+fluent-syntax = \"0.11\"\n+syn = { version = \"2\", features = [\"full\"] }\n+proc-macro2 = \"1\"\n+quote = \"1\"\n+unic-langid = { version = \"0.9.0\", features = [\"macros\"] }"}, {"sha": "9dffc9a7645483c43916b29d15f1c90acae6b3d0", "filename": "compiler/rustc_fluent_macro/src/fluent.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_fluent_macro%2Fsrc%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_fluent_macro%2Fsrc%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_fluent_macro%2Fsrc%2Ffluent.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -68,7 +68,7 @@ fn failed(crate_name: &Ident) -> proc_macro::TokenStream {\n     .into()\n }\n \n-/// See [rustc_macros::fluent_messages].\n+/// See [rustc_fluent_macro::fluent_messages].\n pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n     let crate_name = std::env::var(\"CARGO_PKG_NAME\")\n         // If `CARGO_PKG_NAME` is missing, then we're probably running in a test, so use", "previous_filename": "compiler/rustc_macros/src/diagnostics/fluent.rs"}, {"sha": "a01643cd67d2b4006d28e221762b189b6bf47eb1", "filename": "compiler/rustc_fluent_macro/src/lib.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_fluent_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_fluent_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_fluent_macro%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -0,0 +1,64 @@\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(proc_macro_diagnostic)]\n+#![feature(proc_macro_span)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+#![allow(rustc::default_hash_types)]\n+\n+use proc_macro::TokenStream;\n+\n+mod fluent;\n+\n+/// Implements the `fluent_messages` macro, which performs compile-time validation of the\n+/// compiler's Fluent resources (i.e. that the resources parse and don't multiply define the same\n+/// messages) and generates constants that make using those messages in diagnostics more ergonomic.\n+///\n+/// For example, given the following invocation of the macro..\n+///\n+/// ```ignore (rust)\n+/// fluent_messages! { \"./typeck.ftl\" }\n+/// ```\n+/// ..where `typeck.ftl` has the following contents..\n+///\n+/// ```fluent\n+/// typeck_field_multiply_specified_in_initializer =\n+///     field `{$ident}` specified more than once\n+///     .label = used more than once\n+///     .label_previous_use = first use of `{$ident}`\n+/// ```\n+/// ...then the macro parse the Fluent resource, emitting a diagnostic if it fails to do so, and\n+/// will generate the following code:\n+///\n+/// ```ignore (rust)\n+/// pub static DEFAULT_LOCALE_RESOURCE: &'static [&'static str] = include_str!(\"./typeck.ftl\");\n+///\n+/// mod fluent_generated {\n+///     mod typeck {\n+///         pub const field_multiply_specified_in_initializer: DiagnosticMessage =\n+///             DiagnosticMessage::fluent(\"typeck_field_multiply_specified_in_initializer\");\n+///         pub const field_multiply_specified_in_initializer_label_previous_use: DiagnosticMessage =\n+///             DiagnosticMessage::fluent_attr(\n+///                 \"typeck_field_multiply_specified_in_initializer\",\n+///                 \"previous_use_label\"\n+///             );\n+///     }\n+/// }\n+/// ```\n+/// When emitting a diagnostic, the generated constants can be used as follows:\n+///\n+/// ```ignore (rust)\n+/// let mut err = sess.struct_span_err(\n+///     span,\n+///     fluent::typeck::field_multiply_specified_in_initializer\n+/// );\n+/// err.span_default_label(span);\n+/// err.span_label(\n+///     previous_use_span,\n+///     fluent::typeck::field_multiply_specified_in_initializer_label_previous_use\n+/// );\n+/// err.emit();\n+/// ```\n+#[proc_macro]\n+pub fn fluent_messages(input: TokenStream) -> TokenStream {\n+    fluent::fluent_messages(input)\n+}"}, {"sha": "e213623e06d915478cb8a813e2ce95ce72147bb3", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 3, "deletions": 42, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,56 +1,17 @@\n /// This higher-order macro declares a list of types which can be allocated by `Arena`.\n-///\n-/// Specifying the `decode` modifier will add decode impls for `&T` and `&[T]`,\n-/// where `T` is the type listed. These impls will appear in the implement_ty_decoder! macro.\n+/// Note that all `Copy` types can be allocated by default and need not be specified here.\n #[macro_export]\n macro_rules! arena_types {\n     ($macro:path) => (\n         $macro!([\n             // HIR types\n             [] hir_krate: rustc_hir::Crate<'tcx>,\n-            [] arm: rustc_hir::Arm<'tcx>,\n-            [] asm_operand: (rustc_hir::InlineAsmOperand<'tcx>, rustc_span::Span),\n             [] asm_template: rustc_ast::InlineAsmTemplatePiece,\n             [] attribute: rustc_ast::Attribute,\n-            [] closure: rustc_hir::Closure<'tcx>,\n-            [] block: rustc_hir::Block<'tcx>,\n-            [] bare_fn_ty: rustc_hir::BareFnTy<'tcx>,\n-            [] body: rustc_hir::Body<'tcx>,\n-            [] generics: rustc_hir::Generics<'tcx>,\n-            [] generic_arg: rustc_hir::GenericArg<'tcx>,\n-            [] generic_args: rustc_hir::GenericArgs<'tcx>,\n-            [] generic_bound: rustc_hir::GenericBound<'tcx>,\n-            [] generic_param: rustc_hir::GenericParam<'tcx>,\n-            [] expr: rustc_hir::Expr<'tcx>,\n-            [] impl_: rustc_hir::Impl<'tcx>,\n-            [] let_expr: rustc_hir::Let<'tcx>,\n-            [] expr_field: rustc_hir::ExprField<'tcx>,\n-            [] pat_field: rustc_hir::PatField<'tcx>,\n-            [] fn_decl: rustc_hir::FnDecl<'tcx>,\n-            [] foreign_item: rustc_hir::ForeignItem<'tcx>,\n-            [] foreign_item_ref: rustc_hir::ForeignItemRef,\n-            [] impl_item: rustc_hir::ImplItem<'tcx>,\n-            [] impl_item_ref: rustc_hir::ImplItemRef,\n-            [] item: rustc_hir::Item<'tcx>,\n-            [] inline_asm: rustc_hir::InlineAsm<'tcx>,\n-            [] local: rustc_hir::Local<'tcx>,\n-            [] mod_: rustc_hir::Mod<'tcx>,\n             [] owner_info: rustc_hir::OwnerInfo<'tcx>,\n-            [] param: rustc_hir::Param<'tcx>,\n-            [] pat: rustc_hir::Pat<'tcx>,\n-            [] path: rustc_hir::Path<'tcx>,\n             [] use_path: rustc_hir::UsePath<'tcx>,\n-            [] path_segment: rustc_hir::PathSegment<'tcx>,\n-            [] poly_trait_ref: rustc_hir::PolyTraitRef<'tcx>,\n-            [] qpath: rustc_hir::QPath<'tcx>,\n-            [] stmt: rustc_hir::Stmt<'tcx>,\n-            [] field_def: rustc_hir::FieldDef<'tcx>,\n-            [] trait_item: rustc_hir::TraitItem<'tcx>,\n-            [] trait_item_ref: rustc_hir::TraitItemRef,\n-            [] ty: rustc_hir::Ty<'tcx>,\n-            [] type_binding: rustc_hir::TypeBinding<'tcx>,\n-            [] variant: rustc_hir::Variant<'tcx>,\n-            [] where_predicate: rustc_hir::WherePredicate<'tcx>,\n+            [] lit: rustc_hir::Lit,\n+            [] macro_def: rustc_ast::MacroDef,\n         ]);\n     )\n }"}, {"sha": "30bf8c2ad104bb03e6d01b019d83bf7b27eb38f3", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -234,10 +234,7 @@ impl DefKind {\n \n     #[inline]\n     pub fn is_fn_like(self) -> bool {\n-        match self {\n-            DefKind::Fn | DefKind::AssocFn | DefKind::Closure | DefKind::Generator => true,\n-            _ => false,\n-        }\n+        matches!(self, DefKind::Fn | DefKind::AssocFn | DefKind::Closure | DefKind::Generator)\n     }\n \n     /// Whether `query get_codegen_attrs` should be used with this definition."}, {"sha": "66b153d8931b05ba7360b773c56e0cf04ef9a5d7", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -9,8 +9,8 @@ use crate::def_id::{CrateNum, DefIndex, LocalDefId, StableCrateId, CRATE_DEF_IND\n use crate::def_path_hash_map::DefPathHashMap;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::StableHasher;\n-use rustc_index::vec::IndexVec;\n+use rustc_data_structures::stable_hasher::{Hash64, StableHasher};\n+use rustc_index::IndexVec;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n use std::fmt::{self, Write};\n@@ -130,7 +130,7 @@ impl DefKey {\n \n         disambiguator.hash(&mut hasher);\n \n-        let local_hash: u64 = hasher.finish();\n+        let local_hash = hasher.finish();\n \n         // Construct the new DefPathHash, making sure that the `crate_id`\n         // portion of the hash is properly copied from the parent. This way the\n@@ -325,7 +325,7 @@ impl Definitions {\n             },\n         };\n \n-        let parent_hash = DefPathHash::new(stable_crate_id, 0);\n+        let parent_hash = DefPathHash::new(stable_crate_id, Hash64::ZERO);\n         let def_path_hash = key.compute_stable_hash(parent_hash);\n \n         // Create the root definition."}, {"sha": "e220a0293393e6b0de8c6efc20bd622d43ab8a8a", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 139, "deletions": 117, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -14,7 +14,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_error_messages::MultiSpan;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_macros::HashStable_Generic;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::Spanned;\n@@ -26,7 +26,7 @@ use rustc_target::spec::abi::Abi;\n use smallvec::SmallVec;\n use std::fmt;\n \n-#[derive(Debug, Copy, Clone, Encodable, HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, HashStable_Generic)]\n pub struct Lifetime {\n     pub hir_id: HirId,\n \n@@ -41,8 +41,7 @@ pub struct Lifetime {\n     pub res: LifetimeName,\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Encodable, Hash, Copy)]\n-#[derive(HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, HashStable_Generic)]\n pub enum ParamName {\n     /// Some user-given name like `T` or `'x`.\n     Plain(Ident),\n@@ -85,8 +84,7 @@ impl ParamName {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Encodable, Hash, Copy)]\n-#[derive(HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable_Generic)]\n pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n     Param(LocalDefId),\n@@ -182,7 +180,7 @@ impl Lifetime {\n /// A `Path` is essentially Rust's notion of a name; for instance,\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Path<'hir, R = Res> {\n     pub span: Span,\n     /// The resolution for the path.\n@@ -202,7 +200,7 @@ impl Path<'_> {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct PathSegment<'hir> {\n     /// The identifier portion of this path segment.\n     pub ident: Ident,\n@@ -243,13 +241,13 @@ impl<'hir> PathSegment<'hir> {\n     }\n }\n \n-#[derive(Encodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, Debug, HashStable_Generic)]\n pub struct ConstArg {\n     pub value: AnonConst,\n     pub span: Span,\n }\n \n-#[derive(Encodable, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, Debug, HashStable_Generic)]\n pub struct InferArg {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -261,7 +259,7 @@ impl InferArg {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum GenericArg<'hir> {\n     Lifetime(&'hir Lifetime),\n     Type(&'hir Ty<'hir>),\n@@ -318,7 +316,7 @@ impl GenericArg<'_> {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct GenericArgs<'hir> {\n     /// The generic arguments for this path segment.\n     pub args: &'hir [GenericArg<'hir>],\n@@ -422,8 +420,7 @@ impl<'hir> GenericArgs<'hir> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, HashStable_Generic)]\n pub enum GenericArgsParentheses {\n     No,\n     /// Bounds for `feature(return_type_notation)`, like `T: Trait<method(..): Send>`,\n@@ -435,8 +432,7 @@ pub enum GenericArgsParentheses {\n \n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n /// modifier is `Maybe`. Negative bounds should also be handled here.\n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]\n-#[derive(HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum TraitBoundModifier {\n     None,\n     Maybe,\n@@ -447,7 +443,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(Clone, Debug, HashStable_Generic)]\n+#[derive(Clone, Copy, Debug, HashStable_Generic)]\n pub enum GenericBound<'hir> {\n     Trait(PolyTraitRef<'hir>, TraitBoundModifier),\n     // FIXME(davidtwco): Introduce `PolyTraitRef::LangItem`\n@@ -474,7 +470,7 @@ impl GenericBound<'_> {\n \n pub type GenericBounds<'hir> = &'hir [GenericBound<'hir>];\n \n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum LifetimeParamKind {\n     // Indicates that the lifetime definition was explicitly declared (e.g., in\n     // `fn foo<'a>(x: &'a u8) -> &'a u8 { x }`).\n@@ -488,7 +484,7 @@ pub enum LifetimeParamKind {\n     Error,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum GenericParamKind<'hir> {\n     /// A lifetime definition (e.g., `'a: 'b + 'c + 'd`).\n     Lifetime {\n@@ -505,7 +501,7 @@ pub enum GenericParamKind<'hir> {\n     },\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct GenericParam<'hir> {\n     pub hir_id: HirId,\n     pub def_id: LocalDefId,\n@@ -539,7 +535,7 @@ impl<'hir> GenericParam<'hir> {\n /// early-bound (but can be a late-bound lifetime in functions, for example),\n /// or from a `for<...>` binder, in which case it's late-bound (and notably,\n /// does not show up in the parent item's generics).\n-#[derive(Debug, HashStable_Generic, PartialEq, Eq, Copy, Clone)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum GenericParamSource {\n     // Early or late-bound parameters defined on an item\n     Generics,\n@@ -557,7 +553,7 @@ pub struct GenericParamCount {\n \n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Generics<'hir> {\n     pub params: &'hir [GenericParam<'hir>],\n     pub predicates: &'hir [WherePredicate<'hir>],\n@@ -729,7 +725,7 @@ impl<'hir> Generics<'hir> {\n }\n \n /// A single predicate in a where-clause.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum WherePredicate<'hir> {\n     /// A type binding (e.g., `for<'c> Foo: Send + Clone + 'c`).\n     BoundPredicate(WhereBoundPredicate<'hir>),\n@@ -773,7 +769,7 @@ pub enum PredicateOrigin {\n }\n \n /// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct WhereBoundPredicate<'hir> {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -795,7 +791,7 @@ impl<'hir> WhereBoundPredicate<'hir> {\n }\n \n /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct WhereRegionPredicate<'hir> {\n     pub span: Span,\n     pub in_where_clause: bool,\n@@ -811,7 +807,7 @@ impl<'hir> WhereRegionPredicate<'hir> {\n }\n \n /// An equality predicate (e.g., `T = int`); currently unsupported.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct WhereEqPredicate<'hir> {\n     pub span: Span,\n     pub lhs_ty: &'hir Ty<'hir>,\n@@ -821,7 +817,7 @@ pub struct WhereEqPredicate<'hir> {\n /// HIR node coupled with its parent's id in the same HIR owner.\n ///\n /// The parent is trash when the node is a HIR owner.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Copy, Debug)]\n pub struct ParentedNode<'tcx> {\n     pub parent: ItemLocalId,\n     pub node: Node<'tcx>,\n@@ -863,7 +859,7 @@ pub struct OwnerNodes<'tcx> {\n \n impl<'tcx> OwnerNodes<'tcx> {\n     pub fn node(&self) -> OwnerNode<'tcx> {\n-        use rustc_index::vec::Idx;\n+        use rustc_index::Idx;\n         let node = self.nodes[ItemLocalId::new(0)].as_ref().unwrap().node;\n         let node = node.as_owner().unwrap(); // Indexing must ensure it is an OwnerNode.\n         node\n@@ -959,7 +955,7 @@ pub struct Crate<'hir> {\n     pub opt_hir_hash: Option<Fingerprint>,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Closure<'hir> {\n     pub def_id: LocalDefId,\n     pub binder: ClosureBinder,\n@@ -978,7 +974,7 @@ pub struct Closure<'hir> {\n /// A block of statements `{ .. }`, which may have a label (in this case the\n /// `targeted_by_break` field will be `true`) and may be `unsafe` by means of\n /// the `rules` being anything but `DefaultBlock`.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Block<'hir> {\n     /// Statements in a block.\n     pub stmts: &'hir [Stmt<'hir>],\n@@ -1006,7 +1002,7 @@ impl<'hir> Block<'hir> {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Pat<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1085,7 +1081,7 @@ impl<'hir> Pat<'hir> {\n /// Patterns like the fields of Foo `{ x, ref y, ref mut z }`\n /// are treated the same as` x: x, y: ref y, z: ref mut z`,\n /// except `is_shorthand` is true.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct PatField<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1097,7 +1093,7 @@ pub struct PatField<'hir> {\n     pub span: Span,\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum RangeEnd {\n     Included,\n     Excluded,\n@@ -1141,7 +1137,7 @@ impl fmt::Debug for DotDotPos {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum PatKind<'hir> {\n     /// Represents a wildcard pattern (i.e., `_`).\n     Wild,\n@@ -1197,7 +1193,7 @@ pub enum PatKind<'hir> {\n     Slice(&'hir [Pat<'hir>], Option<&'hir Pat<'hir>>, &'hir [Pat<'hir>]),\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum BinOpKind {\n     /// The `+` operator (addition).\n     Add,\n@@ -1325,7 +1321,7 @@ impl Into<ast::BinOpKind> for BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum UnOp {\n     /// The `*` operator (dereferencing).\n     Deref,\n@@ -1351,15 +1347,15 @@ impl UnOp {\n }\n \n /// A statement.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Stmt<'hir> {\n     pub hir_id: HirId,\n     pub kind: StmtKind<'hir>,\n     pub span: Span,\n }\n \n /// The contents of a statement.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum StmtKind<'hir> {\n     /// A local (`let`) binding.\n     Local(&'hir Local<'hir>),\n@@ -1375,7 +1371,7 @@ pub enum StmtKind<'hir> {\n }\n \n /// Represents a `let` statement (i.e., `let <pat>:<ty> = <init>;`).\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Local<'hir> {\n     pub pat: &'hir Pat<'hir>,\n     /// Type annotation, if any (otherwise the type will be inferred).\n@@ -1393,7 +1389,7 @@ pub struct Local<'hir> {\n \n /// Represents a single arm of a `match` expression, e.g.\n /// `<pat> (if <guard>) => <body>`.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Arm<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1411,7 +1407,7 @@ pub struct Arm<'hir> {\n ///\n /// In an if-let, imagine it as `if (let <pat> = <expr>) { ... }`; in a let-else, it is part of the\n /// desugaring to if-let. Only let-else supports the type annotation at present.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Let<'hir> {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -1420,7 +1416,7 @@ pub struct Let<'hir> {\n     pub init: &'hir Expr<'hir>,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum Guard<'hir> {\n     If(&'hir Expr<'hir>),\n     IfLet(&'hir Let<'hir>),\n@@ -1440,7 +1436,7 @@ impl<'hir> Guard<'hir> {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct ExprField<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n@@ -1450,19 +1446,19 @@ pub struct ExprField<'hir> {\n     pub is_shorthand: bool,\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct BodyId {\n     pub hir_id: HirId,\n }\n@@ -1488,7 +1484,7 @@ pub struct BodyId {\n ///\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Body<'hir> {\n     pub params: &'hir [Param<'hir>],\n     pub value: &'hir Expr<'hir>,\n@@ -1506,7 +1502,7 @@ impl<'hir> Body<'hir> {\n }\n \n /// The type of source expression that caused this generator to be created.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, Debug, Copy, Hash)]\n #[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum GeneratorKind {\n     /// An explicit `async` block or the body of an async function.\n@@ -1539,7 +1535,7 @@ impl GeneratorKind {\n ///\n /// This helps error messages but is also used to drive coercions in\n /// type-checking (see #60424).\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, Copy)]\n #[derive(HashStable_Generic, Encodable, Decodable)]\n pub enum AsyncGeneratorKind {\n     /// An explicit `async` block written by the user.\n@@ -1649,7 +1645,7 @@ impl fmt::Display for ConstContext {\n /// A literal.\n pub type Lit = Spanned<LitKind>;\n \n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum ArrayLen {\n     Infer(HirId, Span),\n     Body(AnonConst),\n@@ -1671,15 +1667,15 @@ impl ArrayLen {\n ///\n /// You can check if this anon const is a default in a const param\n /// `const N: usize = { ... }` with `tcx.hir().opt_const_param_default_param_def_id(..)`\n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub struct AnonConst {\n     pub hir_id: HirId,\n     pub def_id: LocalDefId,\n     pub body: BodyId,\n }\n \n /// An expression.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Expr<'hir> {\n     pub hir_id: HirId,\n     pub kind: ExprKind<'hir>,\n@@ -1715,6 +1711,7 @@ impl Expr<'_> {\n             ExprKind::Continue(..) => ExprPrecedence::Continue,\n             ExprKind::Ret(..) => ExprPrecedence::Ret,\n             ExprKind::InlineAsm(..) => ExprPrecedence::InlineAsm,\n+            ExprKind::OffsetOf(..) => ExprPrecedence::OffsetOf,\n             ExprKind::Struct(..) => ExprPrecedence::Struct,\n             ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n             ExprKind::Yield(..) => ExprPrecedence::Yield,\n@@ -1774,6 +1771,7 @@ impl Expr<'_> {\n             | ExprKind::Loop(..)\n             | ExprKind::Assign(..)\n             | ExprKind::InlineAsm(..)\n+            | ExprKind::OffsetOf(..)\n             | ExprKind::AssignOp(..)\n             | ExprKind::Lit(_)\n             | ExprKind::ConstBlock(..)\n@@ -1818,7 +1816,7 @@ impl Expr<'_> {\n \n     pub fn can_have_side_effects(&self) -> bool {\n         match self.peel_drop_temps().kind {\n-            ExprKind::Path(_) | ExprKind::Lit(_) => false,\n+            ExprKind::Path(_) | ExprKind::Lit(_) | ExprKind::OffsetOf(..) => false,\n             ExprKind::Type(base, _)\n             | ExprKind::Unary(_, base)\n             | ExprKind::Field(base, _)\n@@ -1920,7 +1918,7 @@ pub fn is_range_literal(expr: &Expr<'_>) -> bool {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum ExprKind<'hir> {\n     /// Allow anonymous constants from an inline `const` block\n     ConstBlock(AnonConst),\n@@ -1957,10 +1955,10 @@ pub enum ExprKind<'hir> {\n     /// A unary operation (e.g., `!x`, `*x`).\n     Unary(UnOp, &'hir Expr<'hir>),\n     /// A literal (e.g., `1`, `\"foo\"`).\n-    Lit(Lit),\n+    Lit(&'hir Lit),\n     /// A cast (e.g., `foo as f64`).\n     Cast(&'hir Expr<'hir>, &'hir Ty<'hir>),\n-    /// A type reference (e.g., `Foo`).\n+    /// A type ascription (e.g., `x: Foo`). See RFC 3307.\n     Type(&'hir Expr<'hir>, &'hir Ty<'hir>),\n     /// Wraps the expression in a terminating scope.\n     /// This makes it semantically equivalent to `{ let _t = expr; _t }`.\n@@ -2022,6 +2020,9 @@ pub enum ExprKind<'hir> {\n     /// Inline assembly (from `asm!`), with its outputs and inputs.\n     InlineAsm(&'hir InlineAsm<'hir>),\n \n+    /// Field offset (`offset_of!`)\n+    OffsetOf(&'hir Ty<'hir>, &'hir [Ident]),\n+\n     /// A struct or struct-like variant literal expression.\n     ///\n     /// E.g., `Foo {x: 1, y: 2}`, or `Foo {x: 1, .. base}`,\n@@ -2046,7 +2047,7 @@ pub enum ExprKind<'hir> {\n /// To resolve the path to a `DefId`, call [`qpath_res`].\n ///\n /// [`qpath_res`]: ../../rustc_middle/ty/struct.TypeckResults.html#method.qpath_res\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum QPath<'hir> {\n     /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n     /// type, if the path points to an associated item in a trait.\n@@ -2100,7 +2101,7 @@ impl<'hir> QPath<'hir> {\n }\n \n /// Hints at the original code for a let statement.\n-#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum LocalSource {\n     /// A `match _ { .. }`.\n     Normal,\n@@ -2153,7 +2154,7 @@ impl MatchSource {\n }\n \n /// The loop type that yielded an `ExprKind::Loop`.\n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum LoopSource {\n     /// A `loop { .. }` loop.\n     Loop,\n@@ -2173,7 +2174,7 @@ impl LoopSource {\n     }\n }\n \n-#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum LoopIdError {\n     OutsideLoopScope,\n     UnlabeledCfInWhileCondition,\n@@ -2192,7 +2193,7 @@ impl fmt::Display for LoopIdError {\n     }\n }\n \n-#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub struct Destination {\n     /// This is `Some(_)` iff there is an explicit user-specified 'label\n     pub label: Option<Label>,\n@@ -2203,7 +2204,7 @@ pub struct Destination {\n }\n \n /// The yield kind that caused an `ExprKind::Yield`.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Encodable, Decodable, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum YieldSource {\n     /// An `<expr>.await`.\n     Await { expr: Option<HirId> },\n@@ -2238,15 +2239,15 @@ impl From<GeneratorKind> for YieldSource {\n \n // N.B., if you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct MutTy<'hir> {\n     pub ty: &'hir Ty<'hir>,\n     pub mutbl: Mutability,\n }\n \n /// Represents a function's signature in a trait declaration,\n /// trait implementation, or a free function.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct FnSig<'hir> {\n     pub header: FnHeader,\n     pub decl: &'hir FnDecl<'hir>,\n@@ -2273,7 +2274,7 @@ impl TraitItemId {\n /// possibly including a default implementation. A trait item is\n /// either required (meaning it doesn't have an implementation, just a\n /// signature) or provided (meaning it has a default implementation).\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n     pub owner_id: OwnerId,\n@@ -2322,7 +2323,7 @@ impl<'hir> TraitItem<'hir> {\n }\n \n /// Represents a trait method's body (or just argument names).\n-#[derive(Encodable, Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum TraitFn<'hir> {\n     /// No default body in the trait, just a signature.\n     Required(&'hir [Ident]),\n@@ -2332,7 +2333,7 @@ pub enum TraitFn<'hir> {\n }\n \n /// Represents a trait method or associated constant or type\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum TraitItemKind<'hir> {\n     /// An associated constant with an optional value (otherwise `impl`s must contain a value).\n     Const(&'hir Ty<'hir>, Option<BodyId>),\n@@ -2360,7 +2361,7 @@ impl ImplItemId {\n }\n \n /// Represents anything within an `impl` block.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n     pub owner_id: OwnerId,\n@@ -2410,7 +2411,7 @@ impl<'hir> ImplItem<'hir> {\n }\n \n /// Represents various kinds of content within an `impl`.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum ImplItemKind<'hir> {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression.\n@@ -2439,7 +2440,7 @@ pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n ///    Binding(...),\n /// }\n /// ```\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct TypeBinding<'hir> {\n     pub hir_id: HirId,\n     pub ident: Ident,\n@@ -2448,7 +2449,7 @@ pub struct TypeBinding<'hir> {\n     pub span: Span,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum Term<'hir> {\n     Ty(&'hir Ty<'hir>),\n     Const(AnonConst),\n@@ -2467,7 +2468,7 @@ impl<'hir> From<AnonConst> for Term<'hir> {\n }\n \n // Represents the two kinds of type bindings.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum TypeBindingKind<'hir> {\n     /// E.g., `Foo<Bar: Send>`.\n     Constraint { bounds: &'hir [GenericBound<'hir>] },\n@@ -2490,7 +2491,7 @@ impl TypeBinding<'_> {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Ty<'hir> {\n     pub hir_id: HirId,\n     pub kind: TyKind<'hir>,\n@@ -2635,7 +2636,7 @@ impl PrimTy {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct BareFnTy<'hir> {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n@@ -2644,7 +2645,7 @@ pub struct BareFnTy<'hir> {\n     pub param_names: &'hir [Ident],\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct OpaqueTy<'hir> {\n     pub generics: &'hir Generics<'hir>,\n     pub bounds: GenericBounds<'hir>,\n@@ -2653,7 +2654,7 @@ pub struct OpaqueTy<'hir> {\n }\n \n /// From whence the opaque type came.\n-#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, HashStable_Generic)]\n pub enum OpaqueTyOrigin {\n     /// `-> impl Trait`\n     FnReturn(LocalDefId),\n@@ -2664,7 +2665,7 @@ pub enum OpaqueTyOrigin {\n }\n \n /// The various kinds of types recognized by the compiler.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum TyKind<'hir> {\n     /// A variable length slice (i.e., `[T]`).\n     Slice(&'hir Ty<'hir>),\n@@ -2704,7 +2705,7 @@ pub enum TyKind<'hir> {\n     Err(rustc_span::ErrorGuaranteed),\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum InlineAsmOperand<'hir> {\n     In {\n         reg: InlineAsmRegOrRegClass,\n@@ -2757,7 +2758,7 @@ impl<'hir> InlineAsmOperand<'hir> {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct InlineAsm<'hir> {\n     pub template: &'hir [InlineAsmTemplatePiece],\n     pub template_strs: &'hir [(Symbol, Option<Symbol>, Span)],\n@@ -2767,7 +2768,7 @@ pub struct InlineAsm<'hir> {\n }\n \n /// Represents a parameter in a function header.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Param<'hir> {\n     pub hir_id: HirId,\n     pub pat: &'hir Pat<'hir>,\n@@ -2776,7 +2777,7 @@ pub struct Param<'hir> {\n }\n \n /// Represents the header (not the body) of a function declaration.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct FnDecl<'hir> {\n     /// The types of the function's parameters.\n     ///\n@@ -2813,7 +2814,7 @@ impl ImplicitSelfKind {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Encodable, Decodable, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug)]\n #[derive(HashStable_Generic)]\n pub enum IsAsync {\n     Async,\n@@ -2826,7 +2827,7 @@ impl IsAsync {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Encodable, Decodable, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Encodable, Decodable, HashStable_Generic)]\n pub enum Defaultness {\n     Default { has_value: bool },\n     Final,\n@@ -2849,7 +2850,7 @@ impl Defaultness {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum FnRetTy<'hir> {\n     /// Return type is not specified.\n     ///\n@@ -2882,13 +2883,13 @@ pub enum ClosureBinder {\n     For { span: Span },\n }\n \n-#[derive(Encodable, Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Mod<'hir> {\n     pub spans: ModSpans,\n     pub item_ids: &'hir [ItemId],\n }\n \n-#[derive(Copy, Clone, Debug, HashStable_Generic, Encodable)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub struct ModSpans {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -2897,12 +2898,12 @@ pub struct ModSpans {\n     pub inject_use_span: Span,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct EnumDef<'hir> {\n     pub variants: &'hir [Variant<'hir>],\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Variant<'hir> {\n     /// Name of the variant.\n     pub ident: Ident,\n@@ -2917,7 +2918,7 @@ pub struct Variant<'hir> {\n     pub span: Span,\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum UseKind {\n     /// One import, e.g., `use foo::bar` or `use foo::bar as baz`.\n     /// Also produced for each element of a list `use`, e.g.\n@@ -2939,7 +2940,7 @@ pub enum UseKind {\n /// that the `ref_id` is for. Note that `ref_id`'s value is not the `HirId` of the\n /// trait being referred to but just a unique `HirId` that serves as a key\n /// within the resolution map.\n-#[derive(Clone, Debug, HashStable_Generic)]\n+#[derive(Clone, Debug, Copy, HashStable_Generic)]\n pub struct TraitRef<'hir> {\n     pub path: &'hir Path<'hir>,\n     // Don't hash the `ref_id`. It is tracked via the thing it is used to access.\n@@ -2958,7 +2959,7 @@ impl TraitRef<'_> {\n     }\n }\n \n-#[derive(Clone, Debug, HashStable_Generic)]\n+#[derive(Clone, Debug, Copy, HashStable_Generic)]\n pub struct PolyTraitRef<'hir> {\n     /// The `'a` in `for<'a> Foo<&'a T>`.\n     pub bound_generic_params: &'hir [GenericParam<'hir>],\n@@ -2969,7 +2970,7 @@ pub struct PolyTraitRef<'hir> {\n     pub span: Span,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct FieldDef<'hir> {\n     pub span: Span,\n     pub vis_span: Span,\n@@ -2988,7 +2989,7 @@ impl FieldDef<'_> {\n }\n \n /// Fields and constructor IDs of enum variants and structs.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum VariantData<'hir> {\n     /// A struct variant.\n     ///\n@@ -3058,7 +3059,7 @@ impl ItemId {\n /// An item\n ///\n /// The name might be a dummy name in case of anonymous items\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Item<'hir> {\n     pub ident: Ident,\n     pub owner_id: OwnerId,\n@@ -3146,7 +3147,6 @@ impl<'hir> Item<'hir> {\n         (ty, gen)\n     }\n \n-    /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`.\n     /// Expect an [`ItemKind::OpaqueTy`] or panic.\n     #[track_caller]\n     pub fn expect_opaque_ty(&self) -> &OpaqueTy<'hir> {\n@@ -3168,7 +3168,6 @@ impl<'hir> Item<'hir> {\n         (data, gen)\n     }\n \n-    /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`.\n     /// Expect an [`ItemKind::Union`] or panic.\n     #[track_caller]\n     pub fn expect_union(&self) -> (&VariantData<'hir>, &'hir Generics<'hir>) {\n@@ -3230,7 +3229,7 @@ impl fmt::Display for Unsafety {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n #[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum Constness {\n     Const,\n@@ -3246,7 +3245,7 @@ impl fmt::Display for Constness {\n     }\n }\n \n-#[derive(Copy, Clone, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub constness: Constness,\n@@ -3268,7 +3267,7 @@ impl FnHeader {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum ItemKind<'hir> {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n@@ -3289,7 +3288,7 @@ pub enum ItemKind<'hir> {\n     /// A function declaration.\n     Fn(FnSig<'hir>, &'hir Generics<'hir>, BodyId),\n     /// A MBE macro definition (`macro_rules!` or `macro`).\n-    Macro(ast::MacroDef, MacroKind),\n+    Macro(&'hir ast::MacroDef, MacroKind),\n     /// A module.\n     Mod(&'hir Mod<'hir>),\n     /// An external module, e.g. `extern { .. }`.\n@@ -3315,7 +3314,7 @@ pub enum ItemKind<'hir> {\n     Impl(&'hir Impl<'hir>),\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct Impl<'hir> {\n     pub unsafety: Unsafety,\n     pub polarity: ImplPolarity,\n@@ -3378,7 +3377,7 @@ impl ItemKind<'_> {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Encodable, Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct TraitItemRef {\n     pub id: TraitItemId,\n     pub ident: Ident,\n@@ -3392,7 +3391,7 @@ pub struct TraitItemRef {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct ImplItemRef {\n     pub id: ImplItemId,\n     pub ident: Ident,\n@@ -3402,7 +3401,7 @@ pub struct ImplItemRef {\n     pub trait_item_def_id: Option<DefId>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Encodable, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable_Generic)]\n pub enum AssocItemKind {\n     Const,\n     Fn { has_self: bool },\n@@ -3431,14 +3430,14 @@ impl ForeignItemId {\n /// type or method, and whether it is public). This allows other\n /// passes to find the impl they want without loading the ID (which\n /// means fewer edges in the incremental compilation graph).\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct ForeignItemRef {\n     pub id: ForeignItemId,\n     pub ident: Ident,\n     pub span: Span,\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub struct ForeignItem<'hir> {\n     pub ident: Ident,\n     pub kind: ForeignItemKind<'hir>,\n@@ -3460,7 +3459,7 @@ impl ForeignItem<'_> {\n }\n \n /// An item within an `extern` block.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, Copy, HashStable_Generic)]\n pub enum ForeignItemKind<'hir> {\n     /// A foreign function.\n     Fn(&'hir FnDecl<'hir>, &'hir [Ident], &'hir Generics<'hir>),\n@@ -3471,7 +3470,7 @@ pub enum ForeignItemKind<'hir> {\n }\n \n /// A variable captured by a closure.\n-#[derive(Debug, Copy, Clone, Encodable, HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, HashStable_Generic)]\n pub struct Upvar {\n     /// First span where it is accessed (there can be multiple).\n     pub span: Span,\n@@ -3480,7 +3479,7 @@ pub struct Upvar {\n // The TraitCandidate's import_ids is empty if the trait is defined in the same module, and\n // has length > 0 if the trait is found through an chain of imports, starting with the\n // import/use statement in the scope where the trait is used.\n-#[derive(Encodable, Decodable, Debug, HashStable_Generic)]\n+#[derive(Debug, Clone, HashStable_Generic)]\n pub struct TraitCandidate {\n     pub def_id: DefId,\n     pub import_ids: SmallVec<[LocalDefId; 1]>,\n@@ -3531,12 +3530,20 @@ impl<'hir> OwnerNode<'hir> {\n \n     pub fn body_id(&self) -> Option<BodyId> {\n         match self {\n-            OwnerNode::TraitItem(TraitItem {\n-                kind: TraitItemKind::Fn(_, TraitFn::Provided(body_id)),\n+            OwnerNode::Item(Item {\n+                kind:\n+                    ItemKind::Static(_, _, body) | ItemKind::Const(_, body) | ItemKind::Fn(_, _, body),\n                 ..\n             })\n-            | OwnerNode::ImplItem(ImplItem { kind: ImplItemKind::Fn(_, body_id), .. })\n-            | OwnerNode::Item(Item { kind: ItemKind::Fn(.., body_id), .. }) => Some(*body_id),\n+            | OwnerNode::TraitItem(TraitItem {\n+                kind:\n+                    TraitItemKind::Fn(_, TraitFn::Provided(body)) | TraitItemKind::Const(_, Some(body)),\n+                ..\n+            })\n+            | OwnerNode::ImplItem(ImplItem {\n+                kind: ImplItemKind::Fn(_, body) | ImplItemKind::Const(_, body),\n+                ..\n+            }) => Some(*body),\n             _ => None,\n         }\n     }\n@@ -3731,12 +3738,27 @@ impl<'hir> Node<'hir> {\n \n     pub fn body_id(&self) -> Option<BodyId> {\n         match self {\n-            Node::TraitItem(TraitItem {\n-                kind: TraitItemKind::Fn(_, TraitFn::Provided(body_id)),\n+            Node::Item(Item {\n+                kind:\n+                    ItemKind::Static(_, _, body) | ItemKind::Const(_, body) | ItemKind::Fn(_, _, body),\n                 ..\n             })\n-            | Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(_, body_id), .. })\n-            | Node::Item(Item { kind: ItemKind::Fn(.., body_id), .. }) => Some(*body_id),\n+            | Node::TraitItem(TraitItem {\n+                kind:\n+                    TraitItemKind::Fn(_, TraitFn::Provided(body)) | TraitItemKind::Const(_, Some(body)),\n+                ..\n+            })\n+            | Node::ImplItem(ImplItem {\n+                kind: ImplItemKind::Fn(_, body) | ImplItemKind::Const(_, body),\n+                ..\n+            })\n+            | Node::Expr(Expr {\n+                kind:\n+                    ExprKind::ConstBlock(AnonConst { body, .. })\n+                    | ExprKind::Closure(Closure { body, .. })\n+                    | ExprKind::Repeat(_, ArrayLen::Body(AnonConst { body, .. })),\n+                ..\n+            }) => Some(*body),\n             _ => None,\n         }\n     }"}, {"sha": "d549f52f873a92f8df72bb6288c1f2ac2fec8e91", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -35,7 +35,7 @@ impl OwnerId {\n     }\n }\n \n-impl rustc_index::vec::Idx for OwnerId {\n+impl rustc_index::Idx for OwnerId {\n     #[inline]\n     fn new(idx: usize) -> Self {\n         OwnerId { def_id: LocalDefId { local_def_index: DefIndex::from_usize(idx) } }\n@@ -116,10 +116,7 @@ impl HirId {\n     }\n \n     pub fn index(self) -> (usize, usize) {\n-        (\n-            rustc_index::vec::Idx::index(self.owner.def_id),\n-            rustc_index::vec::Idx::index(self.local_id),\n-        )\n+        (rustc_index::Idx::index(self.owner.def_id), rustc_index::Idx::index(self.local_id))\n     }\n }\n "}, {"sha": "df0047d82e12efe1660f6ddcb718ad7039d49f51", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -786,6 +786,10 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n         ExprKind::InlineAsm(ref asm) => {\n             visitor.visit_inline_asm(asm, expression.hir_id);\n         }\n+        ExprKind::OffsetOf(ref container, ref fields) => {\n+            visitor.visit_ty(container);\n+            walk_list!(visitor, visit_ident, fields.iter().copied());\n+        }\n         ExprKind::Yield(ref subexpression, _) => {\n             visitor.visit_expr(subexpression);\n         }"}, {"sha": "c7ac01b333427e1c4b305b780d0525909bf81578", "filename": "compiler/rustc_hir/src/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftests.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,4 +1,5 @@\n use crate::definitions::{DefKey, DefPathData, DisambiguatedDefPathData};\n+use rustc_data_structures::stable_hasher::Hash64;\n use rustc_span::def_id::{DefPathHash, StableCrateId};\n use rustc_span::edition::Edition;\n use rustc_span::{create_session_if_not_set_then, Symbol};\n@@ -24,7 +25,7 @@ fn def_path_hash_depends_on_crate_id() {\n         assert_ne!(h0.local_hash(), h1.local_hash());\n \n         fn mk_test_hash(stable_crate_id: StableCrateId) -> DefPathHash {\n-            let parent_hash = DefPathHash::new(stable_crate_id, 0);\n+            let parent_hash = DefPathHash::new(stable_crate_id, Hash64::ZERO);\n \n             let key = DefKey {\n                 parent: None,"}, {"sha": "4eb94d5bc634e5b8d3a688cee282f47409a6e6ab", "filename": "compiler/rustc_hir_analysis/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -15,6 +15,7 @@ rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_target = { path = \"../rustc_target\" }\n rustc_session = { path = \"../rustc_session\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n@@ -23,8 +24,7 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n-rustc_lint = { path = \"../rustc_lint\" }\n+rustc_lint_defs = { path = \"../rustc_lint_defs\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }\n rustc_feature = { path = \"../rustc_feature\" }\n-thin-vec = \"0.2.12\"\n tracing = \"0.1\""}, {"sha": "5d45d09797b0be0f6a20019ccbfce8eeeb642ae6", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -225,3 +225,54 @@ hir_analysis_functions_names_duplicated = functions names are duplicated\n \n hir_analysis_simd_ffi_highly_experimental = use of SIMD type{$snip} in FFI is highly experimental and may result in invalid code\n     .help = add `#![feature(simd_ffi)]` to the crate attributes to enable\n+\n+hir_analysis_impl_not_marked_default = `{$ident}` specializes an item from a parent `impl`, but that item is not marked `default`\n+    .label = cannot specialize default item `{$ident}`\n+    .ok_label = parent `impl` is here\n+    .note = to specialize, `{$ident}` in the parent `impl` must be marked `default`\n+\n+hir_analysis_impl_not_marked_default_err = `{$ident}` specializes an item from a parent `impl`, but that item is not marked `default`\n+    .note = parent implementation is in crate `{$cname}`\n+\n+hir_analysis_missing_trait_item = not all trait items implemented, missing: `{$missing_items_msg}`\n+    .label = missing `{$missing_items_msg}` in implementation\n+\n+hir_analysis_missing_trait_item_suggestion = implement the missing item: `{$snippet}`\n+\n+hir_analysis_missing_trait_item_label = `{$item}` from trait\n+\n+hir_analysis_missing_one_of_trait_item = not all trait items implemented, missing one of: `{$missing_items_msg}`\n+    .label = missing one of `{$missing_items_msg}` in implementation\n+    .note = required because of this annotation\n+\n+hir_analysis_missing_trait_item_unstable = not all trait items implemented, missing: `{$missing_item_name}`\n+    .note = default implementation of `{$missing_item_name}` is unstable\n+    .some_note = use of unstable library feature '{$feature}': {$r}\n+    .none_note = use of unstable library feature '{$feature}'\n+\n+hir_analysis_transparent_enum_variant = transparent enum needs exactly one variant, but has {$number}\n+    .label = needs exactly one variant, but has {$number}\n+    .many_label = too many variants in `{$path}`\n+    .multi_label = variant here\n+\n+hir_analysis_transparent_non_zero_sized_enum = the variant of a transparent {$desc} needs at most one non-zero-sized field, but has {$field_count}\n+    .label = needs at most one non-zero-sized field, but has {$field_count}\n+    .labels = this field is non-zero-sized\n+\n+hir_analysis_transparent_non_zero_sized = transparent {$desc} needs at most one non-zero-sized field, but has {$field_count}\n+    .label = needs at most one non-zero-sized field, but has {$field_count}\n+    .labels = this field is non-zero-sized\n+\n+hir_analysis_too_large_static = extern static is too large for the current architecture\n+\n+hir_analysis_specialization_trait = implementing `rustc_specialization_trait` traits is unstable\n+    .help = add `#![feature(min_specialization)]` to the crate attributes to enable\n+\n+hir_analysis_closure_implicit_hrtb = implicit types in closure signatures are forbidden when `for<...>` is present\n+    .label = `for<...>` is here\n+\n+hir_analysis_const_specialize = cannot specialize on const impl with non-const impl\n+\n+hir_analysis_static_specialize = cannot specialize on `'static` lifetime\n+\n+hir_analysis_missing_tilde_const = missing `~const` qualifier for specialization"}, {"sha": "709dea43d84aa5113beb672ce08e14532a1db97a", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -447,14 +447,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         handle_ty_args(has_default, &inf.to_ty())\n                     }\n                     (GenericParamDefKind::Const { .. }, GenericArg::Const(ct)) => {\n-                        ty::Const::from_opt_const_arg_anon_const(\n-                            tcx,\n-                            ty::WithOptConstParam {\n-                                did: ct.value.def_id,\n-                                const_param_did: Some(param.def_id),\n-                            },\n-                        )\n-                        .into()\n+                        let did = ct.value.def_id;\n+                        tcx.feed_anon_const_type(did, tcx.type_of(param.def_id));\n+                        ty::Const::from_anon_const(tcx, did).into()\n                     }\n                     (&GenericParamDefKind::Const { .. }, hir::GenericArg::Infer(inf)) => {\n                         let ty = tcx\n@@ -2061,7 +2056,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             err.note(\"enum variants can't have type parameters\");\n                             let type_name = tcx.item_name(adt_def.did());\n                             let msg = format!(\n-                                \"you might have meant to specity type parameters on enum \\\n+                                \"you might have meant to specify type parameters on enum \\\n                                  `{type_name}`\"\n                             );\n                             let Some(args) = assoc_segment.args else { return; };\n@@ -2323,7 +2318,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let infcx = match self.infcx() {\n             Some(infcx) => infcx,\n             None => {\n-                assert!(!self_ty.needs_infer());\n+                assert!(!self_ty.has_infer());\n                 infcx_ = tcx.infer_ctxt().ignoring_regions().build();\n                 &infcx_\n             }\n@@ -2494,7 +2489,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let infcx = if let Some(infcx) = self.infcx() {\n             infcx\n         } else {\n-            assert!(!qself_ty.needs_infer());\n+            assert!(!qself_ty.has_infer());\n             infcx_ = tcx.infer_ctxt().build();\n             &infcx_\n         };\n@@ -3044,7 +3039,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // the anon const, which is empty. This is why the\n                 // `AlwaysApplicable` impl needs a `T: ?Sized` bound for\n                 // this to compile if we were to normalize here.\n-                if forbid_generic && ty.needs_subst() {\n+                if forbid_generic && ty.has_param() {\n                     let mut err = tcx.sess.struct_span_err(\n                         path.span,\n                         \"generic `Self` types are currently not permitted in anonymous constants\","}, {"sha": "68e957f9d8e3af706aaae468783b51553bd9de30", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -15,7 +15,7 @@ use rustc_infer::infer::opaque_types::ConstrainOpaqueTypeRegionVisitor;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{DefiningAnchor, RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::{Obligation, TraitEngineExt as _};\n-use rustc_lint::builtin::REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS;\n+use rustc_lint_defs::builtin::REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::layout::{LayoutError, MAX_SIMD_LANES};\n@@ -170,9 +170,7 @@ fn check_static_inhabited(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n             if matches!(tcx.def_kind(def_id), DefKind::Static(_)\n                 if tcx.def_kind(tcx.local_parent(def_id)) == DefKind::ForeignMod) =>\n         {\n-            tcx.sess\n-                .struct_span_err(span, \"extern static is too large for the current architecture\")\n-                .emit();\n+            tcx.sess.emit_err(errors::TooLargeStatic { span });\n             return;\n         }\n         // Generic statics are rejected, but we still reach this case.\n@@ -320,7 +318,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n         };\n         let prohibit_opaque = tcx\n             .explicit_item_bounds(def_id)\n-            .iter()\n+            .subst_identity_iter_copied()\n             .try_for_each(|(predicate, _)| predicate.visit_with(&mut visitor));\n \n         if let Some(ty) = prohibit_opaque.break_value() {\n@@ -494,7 +492,7 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n     debug!(\n         \"check_item_type(it.def_id={:?}, it.name={})\",\n         id.owner_id,\n-        tcx.def_path_str(id.owner_id.to_def_id())\n+        tcx.def_path_str(id.owner_id)\n     );\n     let _indenter = indenter();\n     match tcx.def_kind(id.owner_id) {\n@@ -863,7 +861,7 @@ fn check_impl_items_against_trait<'tcx>(\n         if !missing_items.is_empty() {\n             let full_impl_span =\n                 tcx.hir().span_with_body(tcx.hir().local_def_id_to_hir_id(impl_id));\n-            missing_items_err(tcx, tcx.def_span(impl_id), &missing_items, full_impl_span);\n+            missing_items_err(tcx, impl_id, &missing_items, full_impl_span);\n         }\n \n         if let Some(missing_items) = must_implement_one_of {"}, {"sha": "48214b899a4b81f123205feb8aa08303f3198cb3", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -579,7 +579,7 @@ fn compare_asyncness<'tcx>(\n pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m_def_id: LocalDefId,\n-) -> Result<&'tcx FxHashMap<DefId, Ty<'tcx>>, ErrorGuaranteed> {\n+) -> Result<&'tcx FxHashMap<DefId, ty::EarlyBinder<Ty<'tcx>>>, ErrorGuaranteed> {\n     let impl_m = tcx.opt_associated_item(impl_m_def_id.to_def_id()).unwrap();\n     let trait_m = tcx.opt_associated_item(impl_m.trait_item_def_id.unwrap()).unwrap();\n     let impl_trait_ref =\n@@ -782,14 +782,14 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n                     })\n                 });\n                 debug!(%ty);\n-                collected_tys.insert(def_id, ty);\n+                collected_tys.insert(def_id, ty::EarlyBinder(ty));\n             }\n             Err(err) => {\n                 let reported = tcx.sess.delay_span_bug(\n                     return_span,\n                     format!(\"could not fully resolve: {ty} => {err:?}\"),\n                 );\n-                collected_tys.insert(def_id, tcx.ty_error(reported));\n+                collected_tys.insert(def_id, ty::EarlyBinder(tcx.ty_error(reported)));\n             }\n         }\n     }\n@@ -839,7 +839,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ImplTraitInTraitCollector<'_, 'tcx> {\n             });\n             self.types.insert(proj.def_id, (infer_ty, proj.substs));\n             // Recurse into bounds\n-            for (pred, pred_span) in self.interner().bound_explicit_item_bounds(proj.def_id).subst_iter_copied(self.interner(), proj.substs) {\n+            for (pred, pred_span) in self.interner().explicit_item_bounds(proj.def_id).subst_iter_copied(self.interner(), proj.substs) {\n                 let pred = pred.fold_with(self);\n                 let pred = self.ocx.normalize(\n                     &ObligationCause::misc(self.span, self.body_id),\n@@ -1317,7 +1317,7 @@ fn compare_number_of_generics<'tcx>(\n                         impl_count,\n                         kind,\n                         pluralize!(impl_count),\n-                        suffix.unwrap_or_else(String::new),\n+                        suffix.unwrap_or_default(),\n                     ),\n                 );\n             }\n@@ -2023,7 +2023,7 @@ pub(super) fn check_type_bounds<'tcx>(\n     };\n \n     let obligations: Vec<_> = tcx\n-        .bound_explicit_item_bounds(trait_ty.def_id)\n+        .explicit_item_bounds(trait_ty.def_id)\n         .subst_iter_copied(tcx, rebased_substs)\n         .map(|(concrete_ty_bound, span)| {\n             debug!(\"check_type_bounds: concrete_ty_bound = {:?}\", concrete_ty_bound);"}, {"sha": "d505d8b8e0b30ba0b7dd92f8faed485878268003", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -198,7 +198,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             | sym::assert_zero_valid\n             | sym::assert_mem_uninitialized_valid => (1, Vec::new(), tcx.mk_unit()),\n             sym::forget => (1, vec![param(0)], tcx.mk_unit()),\n-            sym::transmute => (2, vec![param(0)], param(1)),\n+            sym::transmute | sym::transmute_unchecked => (2, vec![param(0)], param(1)),\n             sym::prefetch_read_data\n             | sym::prefetch_write_data\n             | sym::prefetch_read_instruction\n@@ -215,7 +215,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n \n             sym::type_name => (1, Vec::new(), tcx.mk_static_str()),\n             sym::type_id => (1, Vec::new(), tcx.types.u64),\n-            sym::offset | sym::arith_offset => (\n+            sym::offset => (2, vec![param(0), param(1)], param(0)),\n+            sym::arith_offset => (\n                 1,\n                 vec![\n                     tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Not }),"}, {"sha": "a28814681dbf66a9a0e728a7a3a4662bfc5d65fe", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -84,33 +84,45 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n             ty::Adt(adt, substs) if adt.repr().simd() => {\n                 let fields = &adt.non_enum_variant().fields;\n                 let elem_ty = fields[FieldIdx::from_u32(0)].ty(self.tcx, substs);\n-                match elem_ty.kind() {\n-                    ty::Never | ty::Error(_) => return None,\n-                    ty::Int(IntTy::I8) | ty::Uint(UintTy::U8) => {\n-                        Some(InlineAsmType::VecI8(fields.len() as u64))\n+\n+                let (size, ty) = match elem_ty.kind() {\n+                    ty::Array(ty, len) => {\n+                        if let Some(len) =\n+                            len.try_eval_target_usize(self.tcx, self.tcx.param_env(adt.did()))\n+                        {\n+                            (len, *ty)\n+                        } else {\n+                            return None;\n+                        }\n                     }\n+                    _ => (fields.len() as u64, elem_ty),\n+                };\n+\n+                match ty.kind() {\n+                    ty::Never | ty::Error(_) => return None,\n+                    ty::Int(IntTy::I8) | ty::Uint(UintTy::U8) => Some(InlineAsmType::VecI8(size)),\n                     ty::Int(IntTy::I16) | ty::Uint(UintTy::U16) => {\n-                        Some(InlineAsmType::VecI16(fields.len() as u64))\n+                        Some(InlineAsmType::VecI16(size))\n                     }\n                     ty::Int(IntTy::I32) | ty::Uint(UintTy::U32) => {\n-                        Some(InlineAsmType::VecI32(fields.len() as u64))\n+                        Some(InlineAsmType::VecI32(size))\n                     }\n                     ty::Int(IntTy::I64) | ty::Uint(UintTy::U64) => {\n-                        Some(InlineAsmType::VecI64(fields.len() as u64))\n+                        Some(InlineAsmType::VecI64(size))\n                     }\n                     ty::Int(IntTy::I128) | ty::Uint(UintTy::U128) => {\n-                        Some(InlineAsmType::VecI128(fields.len() as u64))\n+                        Some(InlineAsmType::VecI128(size))\n                     }\n                     ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize) => {\n                         Some(match self.tcx.sess.target.pointer_width {\n-                            16 => InlineAsmType::VecI16(fields.len() as u64),\n-                            32 => InlineAsmType::VecI32(fields.len() as u64),\n-                            64 => InlineAsmType::VecI64(fields.len() as u64),\n+                            16 => InlineAsmType::VecI16(size),\n+                            32 => InlineAsmType::VecI32(size),\n+                            64 => InlineAsmType::VecI64(size),\n                             _ => unreachable!(),\n                         })\n                     }\n-                    ty::Float(FloatTy::F32) => Some(InlineAsmType::VecF32(fields.len() as u64)),\n-                    ty::Float(FloatTy::F64) => Some(InlineAsmType::VecF64(fields.len() as u64)),\n+                    ty::Float(FloatTy::F32) => Some(InlineAsmType::VecF32(size)),\n+                    ty::Float(FloatTy::F64) => Some(InlineAsmType::VecF64(size)),\n                     _ => None,\n                 }\n             }"}, {"sha": "08154cdae47843ce71c3ce4d0c10266d2f5bf19a", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 106, "deletions": 93, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -74,7 +74,7 @@ pub use check::check_abi;\n \n use check::check_mod_item_types;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder};\n+use rustc_errors::{pluralize, struct_span_err, Diagnostic, DiagnosticBuilder};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_index::bit_set::BitSet;\n@@ -90,6 +90,7 @@ use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::suggestions::ReturnsVisitor;\n use std::num::NonZeroU32;\n \n+use crate::errors;\n use crate::require_c_abi_if_c_variadic;\n use crate::util::common::indenter;\n \n@@ -171,34 +172,18 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId) {\n fn report_forbidden_specialization(tcx: TyCtxt<'_>, impl_item: DefId, parent_impl: DefId) {\n     let span = tcx.def_span(impl_item);\n     let ident = tcx.item_name(impl_item);\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0520,\n-        \"`{}` specializes an item from a parent `impl`, but that item is not marked `default`\",\n-        ident,\n-    );\n-    err.span_label(span, format!(\"cannot specialize default item `{}`\", ident));\n-\n-    match tcx.span_of_impl(parent_impl) {\n-        Ok(span) => {\n-            err.span_label(span, \"parent `impl` is here\");\n-            err.note(&format!(\n-                \"to specialize, `{}` in the parent `impl` must be marked `default`\",\n-                ident\n-            ));\n-        }\n-        Err(cname) => {\n-            err.note(&format!(\"parent implementation is in crate `{cname}`\"));\n-        }\n-    }\n \n-    err.emit();\n+    let err = match tcx.span_of_impl(parent_impl) {\n+        Ok(sp) => errors::ImplNotMarkedDefault::Ok { span, ident, ok_label: sp },\n+        Err(cname) => errors::ImplNotMarkedDefault::Err { span, ident, cname },\n+    };\n+\n+    tcx.sess.emit_err(err);\n }\n \n fn missing_items_err(\n     tcx: TyCtxt<'_>,\n-    impl_span: Span,\n+    impl_def_id: LocalDefId,\n     missing_items: &[ty::AssocItem],\n     full_impl_span: Span,\n ) {\n@@ -211,14 +196,6 @@ fn missing_items_err(\n         .collect::<Vec<_>>()\n         .join(\"`, `\");\n \n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        impl_span,\n-        E0046,\n-        \"not all trait items implemented, missing: `{missing_items_msg}`\",\n-    );\n-    err.span_label(impl_span, format!(\"missing `{missing_items_msg}` in implementation\"));\n-\n     // `Span` before impl block closing brace.\n     let hi = full_impl_span.hi() - BytePos(1);\n     // Point at the place right before the closing brace of the relevant `impl` to suggest\n@@ -227,20 +204,40 @@ fn missing_items_err(\n     // Obtain the level of indentation ending in `sugg_sp`.\n     let padding =\n         tcx.sess.source_map().indentation_before(sugg_sp).unwrap_or_else(|| String::new());\n+    let (mut missing_trait_item, mut missing_trait_item_none, mut missing_trait_item_label) =\n+        (Vec::new(), Vec::new(), Vec::new());\n \n     for &trait_item in missing_items {\n-        let snippet = suggestion_signature(trait_item, tcx);\n+        let snippet = suggestion_signature(\n+            tcx,\n+            trait_item,\n+            tcx.impl_trait_ref(impl_def_id).unwrap().subst_identity(),\n+        );\n         let code = format!(\"{}{}\\n{}\", padding, snippet, padding);\n-        let msg = format!(\"implement the missing item: `{snippet}`\");\n-        let appl = Applicability::HasPlaceholders;\n         if let Some(span) = tcx.hir().span_if_local(trait_item.def_id) {\n-            err.span_label(span, format!(\"`{}` from trait\", trait_item.name));\n-            err.tool_only_span_suggestion(sugg_sp, &msg, code, appl);\n+            missing_trait_item_label\n+                .push(errors::MissingTraitItemLabel { span, item: trait_item.name });\n+            missing_trait_item.push(errors::MissingTraitItemSuggestion {\n+                span: sugg_sp,\n+                code,\n+                snippet,\n+            });\n         } else {\n-            err.span_suggestion_hidden(sugg_sp, &msg, code, appl);\n+            missing_trait_item_none.push(errors::MissingTraitItemSuggestionNone {\n+                span: sugg_sp,\n+                code,\n+                snippet,\n+            })\n         }\n     }\n-    err.emit();\n+\n+    tcx.sess.emit_err(errors::MissingTraitItem {\n+        span: tcx.span_of_impl(impl_def_id.to_def_id()).unwrap(),\n+        missing_items_msg,\n+        missing_trait_item_label,\n+        missing_trait_item,\n+        missing_trait_item_none,\n+    });\n }\n \n fn missing_items_must_implement_one_of_err(\n@@ -252,19 +249,11 @@ fn missing_items_must_implement_one_of_err(\n     let missing_items_msg =\n         missing_items.iter().map(Ident::to_string).collect::<Vec<_>>().join(\"`, `\");\n \n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        impl_span,\n-        E0046,\n-        \"not all trait items implemented, missing one of: `{missing_items_msg}`\",\n-    );\n-    err.span_label(impl_span, format!(\"missing one of `{missing_items_msg}` in implementation\"));\n-\n-    if let Some(annotation_span) = annotation_span {\n-        err.span_note(annotation_span, \"required because of this annotation\");\n-    }\n-\n-    err.emit();\n+    tcx.sess.emit_err(errors::MissingOneOfTraitItem {\n+        span: impl_span,\n+        note: annotation_span,\n+        missing_items_msg,\n+    });\n }\n \n fn default_body_is_unstable(\n@@ -276,36 +265,42 @@ fn default_body_is_unstable(\n     issue: Option<NonZeroU32>,\n ) {\n     let missing_item_name = tcx.associated_item(item_did).name;\n-    let use_of_unstable_library_feature_note = match reason {\n-        Some(r) => format!(\"use of unstable library feature '{feature}': {r}\"),\n-        None => format!(\"use of unstable library feature '{feature}'\"),\n+    let (mut some_note, mut none_note, mut reason_str) = (false, false, String::new());\n+    match reason {\n+        Some(r) => {\n+            some_note = true;\n+            reason_str = r.to_string();\n+        }\n+        None => none_note = true,\n     };\n \n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        impl_span,\n-        E0046,\n-        \"not all trait items implemented, missing: `{missing_item_name}`\",\n-    );\n-    err.note(format!(\"default implementation of `{missing_item_name}` is unstable\"));\n-    err.note(use_of_unstable_library_feature_note);\n+    let mut err = tcx.sess.create_err(errors::MissingTraitItemUnstable {\n+        span: impl_span,\n+        some_note,\n+        none_note,\n+        missing_item_name,\n+        feature,\n+        reason: reason_str,\n+    });\n+\n     rustc_session::parse::add_feature_diagnostics_for_issue(\n         &mut err,\n         &tcx.sess.parse_sess,\n         feature,\n         rustc_feature::GateIssue::Library(issue),\n     );\n+\n     err.emit();\n }\n \n /// Re-sugar `ty::GenericPredicates` in a way suitable to be used in structured suggestions.\n fn bounds_from_generic_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    predicates: ty::GenericPredicates<'tcx>,\n+    predicates: impl IntoIterator<Item = (ty::Predicate<'tcx>, Span)>,\n ) -> (String, String) {\n     let mut types: FxHashMap<Ty<'tcx>, Vec<DefId>> = FxHashMap::default();\n     let mut projections = vec![];\n-    for (predicate, _) in predicates.predicates {\n+    for (predicate, _) in predicates {\n         debug!(\"predicate {:?}\", predicate);\n         let bound_predicate = predicate.kind();\n         match bound_predicate.skip_binder() {\n@@ -367,7 +362,7 @@ fn fn_sig_suggestion<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sig: ty::FnSig<'tcx>,\n     ident: Ident,\n-    predicates: ty::GenericPredicates<'tcx>,\n+    predicates: impl IntoIterator<Item = (ty::Predicate<'tcx>, Span)>,\n     assoc: ty::AssocItem,\n ) -> String {\n     let args = sig\n@@ -436,7 +431,17 @@ pub fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {\n /// Return placeholder code for the given associated item.\n /// Similar to `ty::AssocItem::suggestion`, but appropriate for use as the code snippet of a\n /// structured suggestion.\n-fn suggestion_signature(assoc: ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n+fn suggestion_signature<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    assoc: ty::AssocItem,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+) -> String {\n+    let substs = ty::InternalSubsts::identity_for_item(tcx, assoc.def_id).rebase_onto(\n+        tcx,\n+        assoc.container_id(tcx),\n+        impl_trait_ref.with_self_ty(tcx, tcx.types.self_param).substs,\n+    );\n+\n     match assoc.kind {\n         ty::AssocKind::Fn => {\n             // We skip the binder here because the binder would deanonymize all\n@@ -445,16 +450,22 @@ fn suggestion_signature(assoc: ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n             // regions just fine, showing `fn(&MyType)`.\n             fn_sig_suggestion(\n                 tcx,\n-                tcx.fn_sig(assoc.def_id).subst_identity().skip_binder(),\n+                tcx.fn_sig(assoc.def_id).subst(tcx, substs).skip_binder(),\n                 assoc.ident(tcx),\n-                tcx.predicates_of(assoc.def_id),\n+                tcx.predicates_of(assoc.def_id).instantiate_own(tcx, substs),\n                 assoc,\n             )\n         }\n-        ty::AssocKind::Type => format!(\"type {} = Type;\", assoc.name),\n+        ty::AssocKind::Type => {\n+            let (generics, where_clauses) = bounds_from_generic_predicates(\n+                tcx,\n+                tcx.predicates_of(assoc.def_id).instantiate_own(tcx, substs),\n+            );\n+            format!(\"type {}{generics} = /* Type */{where_clauses};\", assoc.name)\n+        }\n         ty::AssocKind::Const => {\n             let ty = tcx.type_of(assoc.def_id).subst_identity();\n-            let val = ty_kind_suggestion(ty).unwrap_or(\"value\");\n+            let val = ty_kind_suggestion(ty).unwrap_or(\"todo!()\");\n             format!(\"const {}: {} = {};\", assoc.name, ty, val)\n         }\n     }\n@@ -467,16 +478,18 @@ fn bad_variant_count<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>, sp: Span, d\n         .iter()\n         .map(|variant| tcx.hir().span_if_local(variant.def_id).unwrap())\n         .collect();\n-    let msg = format!(\"needs exactly one variant, but has {}\", adt.variants().len(),);\n-    let mut err = struct_span_err!(tcx.sess, sp, E0731, \"transparent enum {msg}\");\n-    err.span_label(sp, &msg);\n+    let (mut spans, mut many) = (Vec::new(), None);\n     if let [start @ .., end] = &*variant_spans {\n-        for variant_span in start {\n-            err.span_label(*variant_span, \"\");\n-        }\n-        err.span_label(*end, &format!(\"too many variants in `{}`\", tcx.def_path_str(did)));\n+        spans = start.to_vec();\n+        many = Some(*end);\n     }\n-    err.emit();\n+    tcx.sess.emit_err(errors::TransparentEnumVariant {\n+        span: sp,\n+        spans,\n+        many,\n+        number: adt.variants().len(),\n+        path: tcx.def_path_str(did),\n+    });\n }\n \n /// Emit an error when encountering two or more non-zero-sized fields in a transparent\n@@ -488,21 +501,21 @@ fn bad_non_zero_sized_fields<'tcx>(\n     field_spans: impl Iterator<Item = Span>,\n     sp: Span,\n ) {\n-    let msg = format!(\"needs at most one non-zero-sized field, but has {field_count}\");\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        sp,\n-        E0690,\n-        \"{}transparent {} {}\",\n-        if adt.is_enum() { \"the variant of a \" } else { \"\" },\n-        adt.descr(),\n-        msg,\n-    );\n-    err.span_label(sp, &msg);\n-    for sp in field_spans {\n-        err.span_label(sp, \"this field is non-zero-sized\");\n+    if adt.is_enum() {\n+        tcx.sess.emit_err(errors::TransparentNonZeroSizedEnum {\n+            span: sp,\n+            spans: field_spans.collect(),\n+            field_count,\n+            desc: adt.descr(),\n+        });\n+    } else {\n+        tcx.sess.emit_err(errors::TransparentNonZeroSized {\n+            span: sp,\n+            spans: field_spans.collect(),\n+            field_count,\n+            desc: adt.descr(),\n+        });\n     }\n-    err.emit();\n }\n \n // FIXME: Consider moving this method to a more fitting place."}, {"sha": "6ab5556e951d939a7704a6e239c9a800c664e27c", "filename": "compiler/rustc_hir_analysis/src/check/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -12,7 +12,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Arm, Block, Expr, Local, Pat, PatKind, Stmt};\n-use rustc_index::vec::Idx;\n+use rustc_index::Idx;\n use rustc_middle::middle::region::*;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::source_map;\n@@ -421,7 +421,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n             let target_scopes = visitor.fixup_scopes.drain(start_point..);\n \n             for scope in target_scopes {\n-                let mut yield_data =\n+                let yield_data =\n                     visitor.scope_tree.yield_in_scope.get_mut(&scope).unwrap().last_mut().unwrap();\n                 let count = yield_data.expr_and_pat_count;\n                 let span = yield_data.span;"}, {"sha": "c066c396766624caeef30d570b96d063cbbf03b4", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -155,7 +155,7 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n \n     debug!(\n         ?item.owner_id,\n-        item.name = ? tcx.def_path_str(def_id.to_def_id())\n+        item.name = ? tcx.def_path_str(def_id)\n     );\n \n     match item.kind {\n@@ -251,7 +251,7 @@ fn check_foreign_item(tcx: TyCtxt<'_>, item: &hir::ForeignItem<'_>) {\n \n     debug!(\n         ?item.owner_id,\n-        item.name = ? tcx.def_path_str(def_id.to_def_id())\n+        item.name = ? tcx.def_path_str(def_id)\n     );\n \n     match item.kind {\n@@ -360,7 +360,9 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n                             tcx,\n                             param_env,\n                             item_def_id,\n-                            tcx.explicit_item_bounds(item_def_id).to_vec(),\n+                            tcx.explicit_item_bounds(item_def_id)\n+                                .subst_identity_iter_copied()\n+                                .collect::<Vec<_>>(),\n                             &FxIndexSet::default(),\n                             gat_def_id.def_id,\n                             gat_generics,\n@@ -1025,7 +1027,7 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n                 packed && {\n                     let ty = tcx.type_of(variant.fields.raw.last().unwrap().did).subst_identity();\n                     let ty = tcx.erase_regions(ty);\n-                    if ty.needs_infer() {\n+                    if ty.has_infer() {\n                         tcx.sess\n                             .delay_span_bug(item.span, &format!(\"inference variables in {:?}\", ty));\n                         // Just treat unresolved type expression as if it needs drop.\n@@ -1125,7 +1127,7 @@ fn check_associated_type_bounds(wfcx: &WfCheckingCtxt<'_, '_>, item: ty::AssocIt\n     let bounds = wfcx.tcx().explicit_item_bounds(item.def_id);\n \n     debug!(\"check_associated_type_bounds: bounds={:?}\", bounds);\n-    let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n+    let wf_obligations = bounds.subst_identity_iter_copied().flat_map(|(bound, bound_span)| {\n         let normalized_bound = wfcx.normalize(span, None, bound);\n         traits::wf::predicate_obligations(\n             wfcx.infcx,\n@@ -1290,7 +1292,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n                     // Ignore dependent defaults -- that is, where the default of one type\n                     // parameter includes another (e.g., `<T, U = T>`). In those cases, we can't\n                     // be sure if it will error or not as user might always specify the other.\n-                    if !ty.needs_subst() {\n+                    if !ty.has_param() {\n                         wfcx.register_wf_obligation(\n                             tcx.def_span(param.def_id),\n                             Some(WellFormedLoc::Ty(param.def_id.expect_local())),\n@@ -1306,7 +1308,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n                     // for `struct Foo<const N: usize, const M: usize = { 1 - 2 }>`\n                     // we should eagerly error.\n                     let default_ct = tcx.const_param_default(param.def_id).subst_identity();\n-                    if !default_ct.needs_subst() {\n+                    if !default_ct.has_param() {\n                         wfcx.register_wf_obligation(\n                             tcx.def_span(param.def_id),\n                             None,\n@@ -1340,7 +1342,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n                 if is_our_default(param) {\n                     let default_ty = tcx.type_of(param.def_id).subst_identity();\n                     // ... and it's not a dependent default, ...\n-                    if !default_ty.needs_subst() {\n+                    if !default_ty.has_param() {\n                         // ... then substitute it with the default.\n                         return default_ty.into();\n                     }\n@@ -1353,7 +1355,7 @@ fn check_where_clauses<'tcx>(wfcx: &WfCheckingCtxt<'_, 'tcx>, span: Span, def_id\n                 if is_our_default(param) {\n                     let default_ct = tcx.const_param_default(param.def_id).subst_identity();\n                     // ... and it's not a dependent default, ...\n-                    if !default_ct.needs_subst() {\n+                    if !default_ct.has_param() {\n                         // ... then substitute it with the default.\n                         return default_ct.into();\n                     }\n@@ -1574,21 +1576,14 @@ impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ImplTraitInTraitFinder<'_, 'tcx> {\n             && let hir::OpaqueTyOrigin::FnReturn(source) | hir::OpaqueTyOrigin::AsyncFn(source) = opaque.origin\n             && source == self.fn_def_id\n         {\n-            let opaque_ty = tcx.fold_regions(unshifted_opaque_ty, |re, depth| {\n-                if let ty::ReLateBound(index, bv) = re.kind() {\n-                    if depth != ty::INNERMOST {\n-                        return tcx.mk_re_error_with_message(\n-                            DUMMY_SP,\n-                            \"we shouldn't walk non-predicate binders with `impl Trait`...\",\n-                        );\n-                    }\n-                    tcx.mk_re_late_bound(index.shifted_out_to_binder(self.depth), bv)\n-                } else {\n-                    re\n+            let opaque_ty = tcx.fold_regions(unshifted_opaque_ty, |re, _depth| {\n+                match re.kind() {\n+                    ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReError(_) => re,\n+                    r => bug!(\"unexpected region: {r:?}\"),\n                 }\n             });\n             for (bound, bound_span) in tcx\n-                .bound_explicit_item_bounds(opaque_ty.def_id)\n+                .explicit_item_bounds(opaque_ty.def_id)\n                 .subst_iter_copied(tcx, opaque_ty.substs)\n             {\n                 let bound = self.wfcx.normalize(bound_span, None, bound);"}, {"sha": "611ce13b739c2b9e4950637f4338ddef01d189c8", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -74,16 +74,15 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n \n     debug!(\"visit_implementation_of_copy: self_type={:?} (free)\", self_type);\n \n-    let span = match tcx.hir().expect_item(impl_did).kind {\n-        ItemKind::Impl(hir::Impl { polarity: hir::ImplPolarity::Negative(_), .. }) => return,\n-        ItemKind::Impl(impl_) => impl_.self_ty.span,\n-        _ => bug!(\"expected Copy impl item\"),\n+    let span = match tcx.hir().expect_item(impl_did).expect_impl() {\n+        hir::Impl { polarity: hir::ImplPolarity::Negative(_), .. } => return,\n+        hir::Impl { self_ty, .. } => self_ty.span,\n     };\n \n     let cause = traits::ObligationCause::misc(span, impl_did);\n     match type_allowed_to_implement_copy(tcx, param_env, self_type, cause) {\n         Ok(()) => {}\n-        Err(CopyImplementationError::InfrigingFields(fields)) => {\n+        Err(CopyImplementationError::InfringingFields(fields)) => {\n             let mut err = struct_span_err!(\n                 tcx.sess,\n                 span,"}, {"sha": "bd6252344b2c2a5413e3cb8eb91473008ff2cdaf", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -3,7 +3,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::Symbol;"}, {"sha": "cd2ec2bef20f9fce53e382ae1d6ac11b7e18457e", "filename": "compiler/rustc_hir_analysis/src/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -5,6 +5,7 @@\n // done by the orphan and overlap modules. Then we build up various\n // mappings. That mapping code resides here.\n \n+use crate::errors;\n use rustc_errors::{error_code, struct_span_err};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n@@ -22,7 +23,7 @@ fn check_impl(tcx: TyCtxt<'_>, impl_def_id: LocalDefId, trait_ref: ty::TraitRef<\n     debug!(\n         \"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n         trait_ref,\n-        tcx.def_path_str(impl_def_id.to_def_id())\n+        tcx.def_path_str(impl_def_id)\n     );\n \n     // Skip impls where one of the self type is an error type.\n@@ -67,13 +68,7 @@ fn enforce_trait_manually_implementable(\n         tcx.trait_def(trait_def_id).specialization_kind\n     {\n         if !tcx.features().specialization && !tcx.features().min_specialization {\n-            tcx.sess\n-                .struct_span_err(\n-                    impl_header_span,\n-                    \"implementing `rustc_specialization_trait` traits is unstable\",\n-                )\n-                .help(\"add `#![feature(min_specialization)]` to the crate attributes to enable\")\n-                .emit();\n+            tcx.sess.emit_err(errors::SpecializationTrait { span: impl_header_span });\n             return;\n         }\n     }"}, {"sha": "89175c0ef745064121c6ebd5ccb0290e1f918204", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -457,7 +457,7 @@ fn emit_newtype_suggestion_for_raw_ptr(\n     ptr_ty: &ty::TypeAndMut<'_>,\n     diag: &mut Diagnostic,\n ) {\n-    if !self_ty.needs_subst() {\n+    if !self_ty.has_param() {\n         let mut_key = ptr_ty.mutbl.prefix_str();\n         let msg_sugg = \"consider introducing a new wrapper type\".to_owned();\n         let sugg = vec!["}, {"sha": "41547dd2a754d356506cf3d9212c389db4750b5c", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -55,7 +55,6 @@ fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n pub fn provide(providers: &mut Providers) {\n     resolve_bound_vars::provide(providers);\n     *providers = Providers {\n-        opt_const_param_of: type_of::opt_const_param_of,\n         type_of: type_of::type_of,\n         item_bounds: item_bounds::item_bounds,\n         explicit_item_bounds: item_bounds::explicit_item_bounds,\n@@ -387,8 +386,10 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n \n     fn ct_infer(&self, ty: Ty<'tcx>, _: Option<&ty::GenericParamDef>, span: Span) -> Const<'tcx> {\n         let ty = self.tcx.fold_regions(ty, |r, _| match *r {\n-            ty::ReErased => self.tcx.lifetimes.re_static,\n-            _ => r,\n+            // This is never reached in practice. If it ever is reached,\n+            // `ReErased` should be changed to `ReStatic`, and any other region\n+            // left alone.\n+            r => bug!(\"unexpected region: {r:?}\"),\n         });\n         self.tcx().const_error_with_message(ty, span, \"bad placeholder constant\")\n     }\n@@ -1147,24 +1148,22 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n \n             let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_ty(ty);\n+\n             let mut diag = bad_placeholder(tcx, visitor.0, \"return type\");\n             let ret_ty = fn_sig.output();\n+            // Don't leak types into signatures unless they're nameable!\n+            // For example, if a function returns itself, we don't want that\n+            // recursive function definition to leak out into the fn sig.\n+            let mut should_recover = false;\n+\n             if let Some(ret_ty) = ret_ty.make_suggestable(tcx, false) {\n                 diag.span_suggestion(\n                     ty.span,\n                     \"replace with the correct return type\",\n                     ret_ty,\n                     Applicability::MachineApplicable,\n                 );\n-            } else if matches!(ret_ty.kind(), ty::FnDef(..))\n-                && let Some(fn_sig) = ret_ty.fn_sig(tcx).make_suggestable(tcx, false)\n-            {\n-                diag.span_suggestion(\n-                    ty.span,\n-                    \"replace with the correct return type\",\n-                    fn_sig,\n-                    Applicability::MachineApplicable,\n-                );\n+                should_recover = true;\n             } else if let Some(sugg) = suggest_impl_trait(tcx, ret_ty, ty.span, def_id) {\n                 diag.span_suggestion(\n                     ty.span,\n@@ -1182,9 +1181,20 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n                      https://doc.rust-lang.org/book/ch13-01-closures.html\",\n                 );\n             }\n-            diag.emit();\n \n-            ty::Binder::dummy(fn_sig)\n+            let guar = diag.emit();\n+\n+            if should_recover {\n+                ty::Binder::dummy(fn_sig)\n+            } else {\n+                ty::Binder::dummy(tcx.mk_fn_sig(\n+                    fn_sig.inputs().iter().copied(),\n+                    tcx.ty_error(guar),\n+                    fn_sig.c_variadic,\n+                    fn_sig.unsafety,\n+                    fn_sig.abi,\n+                ))\n+            }\n         }\n         None => icx.astconv().ty_of_fn(\n             hir_id,\n@@ -1457,10 +1467,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n }\n \n fn is_foreign_item(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n-    match tcx.hir().get_by_def_id(def_id) {\n-        Node::ForeignItem(..) => true,\n-        _ => false,\n-    }\n+    matches!(tcx.hir().get_by_def_id(def_id), Node::ForeignItem(..))\n }\n \n fn generator_kind(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<hir::GeneratorKind> {"}, {"sha": "80d6bc7db9e8f3e54533c5312aa740e4e6f2f16d", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -79,14 +79,14 @@ fn opaque_type_bounds<'tcx>(\n pub(super) fn explicit_item_bounds(\n     tcx: TyCtxt<'_>,\n     def_id: LocalDefId,\n-) -> &'_ [(ty::Predicate<'_>, Span)] {\n+) -> ty::EarlyBinder<&'_ [(ty::Predicate<'_>, Span)]> {\n     match tcx.opt_rpitit_info(def_id.to_def_id()) {\n         // RPITIT's bounds are the same as opaque type bounds, but with\n         // a projection self type.\n         Some(ty::ImplTraitInTraitData::Trait { opaque_def_id, .. }) => {\n             let item = tcx.hir().get_by_def_id(opaque_def_id.expect_local()).expect_item();\n             let opaque_ty = item.expect_opaque_ty();\n-            return opaque_type_bounds(\n+            return ty::EarlyBinder(opaque_type_bounds(\n                 tcx,\n                 opaque_def_id.expect_local(),\n                 opaque_ty.bounds,\n@@ -95,15 +95,15 @@ pub(super) fn explicit_item_bounds(\n                     ty::InternalSubsts::identity_for_item(tcx, def_id),\n                 ),\n                 item.span,\n-            );\n+            ));\n         }\n         // These should have been fed!\n         Some(ty::ImplTraitInTraitData::Impl { .. }) => unreachable!(),\n         None => {}\n     }\n \n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    match tcx.hir().get(hir_id) {\n+    let bounds = match tcx.hir().get(hir_id) {\n         hir::Node::TraitItem(hir::TraitItem {\n             kind: hir::TraitItemKind::Type(bounds, _),\n             span,\n@@ -123,16 +123,18 @@ pub(super) fn explicit_item_bounds(\n             opaque_type_bounds(tcx, def_id, bounds, item_ty, *span)\n         }\n         _ => bug!(\"item_bounds called on {:?}\", def_id),\n-    }\n+    };\n+    ty::EarlyBinder(bounds)\n }\n \n pub(super) fn item_bounds(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n ) -> ty::EarlyBinder<&'_ ty::List<ty::Predicate<'_>>> {\n-    let bounds = tcx.mk_predicates_from_iter(util::elaborate(\n-        tcx,\n-        tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),\n-    ));\n-    ty::EarlyBinder(bounds)\n+    tcx.explicit_item_bounds(def_id).map_bound(|bounds| {\n+        tcx.mk_predicates_from_iter(util::elaborate(\n+            tcx,\n+            bounds.iter().map(|&(bound, _span)| bound),\n+        ))\n+    })\n }"}, {"sha": "8c414521b7653322205b25b966b89e124acd7bef", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -645,9 +645,8 @@ pub(super) fn implied_predicates_with_filter(\n     };\n \n     // Combine the two lists to form the complete set of superbounds:\n-    let implied_bounds = &*tcx\n-        .arena\n-        .alloc_from_iter(superbounds.predicates().into_iter().chain(where_bounds_that_match));\n+    let implied_bounds =\n+        &*tcx.arena.alloc_from_iter(superbounds.predicates().chain(where_bounds_that_match));\n     debug!(?implied_bounds);\n \n     // Now require that immediate supertraits are converted,"}, {"sha": "1c496f867a0630d7df5a3038fa4ed55d2dffea24", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -455,13 +455,9 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n                     .collect::<Vec<_>>();\n \n                 if !infer_spans.is_empty() {\n-                    self.tcx.sess\n-                        .struct_span_err(\n-                            infer_spans,\n-                            \"implicit types in closure signatures are forbidden when `for<...>` is present\",\n-                        )\n-                        .span_label(for_sp, \"`for<...>` is here\")\n-                        .emit();\n+                    self.tcx\n+                        .sess\n+                        .emit_err(errors::ClosureImplicitHrtb { spans: infer_spans, for_sp });\n                 }\n             }\n \n@@ -1333,7 +1329,7 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n \n         // We may fail to resolve higher-ranked lifetimes that are mentioned by APIT.\n         // AST-based resolution does not care for impl-trait desugaring, which are the\n-        // responibility of lowering. This may create a mismatch between the resolution\n+        // responsibility of lowering. This may create a mismatch between the resolution\n         // AST found (`region_def_id`) which points to HRTB, and what HIR allows.\n         // ```\n         // fn foo(x: impl for<'a> Trait<'a, Assoc = impl Copy + 'a>) {}"}, {"sha": "d7d509e5394bcb5a1cba2c5d267ebdca4b38bceb", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 95, "deletions": 160, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,6 +1,6 @@\n use rustc_errors::{Applicability, StashKey};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{HirId, Node};\n@@ -16,22 +16,81 @@ use super::ItemCtxt;\n use super::{bad_placeholder, is_suggestable_infer_ty};\n use crate::errors::UnconstrainedOpaqueType;\n \n-/// Computes the relevant generic parameter for a potential generic const argument.\n-///\n-/// This should be called using the query `tcx.opt_const_param_of`.\n-pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<DefId> {\n+fn anon_const_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Ty<'tcx> {\n     use hir::*;\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n-    match tcx.hir().get(hir_id) {\n-        Node::AnonConst(_) => (),\n-        _ => return None,\n-    };\n+    let Node::AnonConst(_) = tcx.hir().get(hir_id) else { panic!() };\n \n     let parent_node_id = tcx.hir().parent_id(hir_id);\n     let parent_node = tcx.hir().get(parent_node_id);\n \n     let (generics, arg_idx) = match parent_node {\n+        // Easy case: arrays repeat expressions.\n+        Node::Ty(&Ty { kind: TyKind::Array(_, ref constant), .. })\n+        | Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n+            if constant.hir_id() == hir_id =>\n+        {\n+            return tcx.types.usize\n+        }\n+        Node::Ty(&Ty { kind: TyKind::Typeof(ref e), .. }) if e.hir_id == hir_id => {\n+            return tcx.typeck(def_id).node_type(e.hir_id)\n+        }\n+        Node::Expr(&Expr { kind: ExprKind::ConstBlock(ref anon_const), .. })\n+            if anon_const.hir_id == hir_id =>\n+        {\n+            let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+            return substs.as_inline_const().ty()\n+        }\n+        Node::Expr(&Expr { kind: ExprKind::InlineAsm(asm), .. })\n+        | Node::Item(&Item { kind: ItemKind::GlobalAsm(asm), .. })\n+            if asm.operands.iter().any(|(op, _op_sp)| match op {\n+                hir::InlineAsmOperand::Const { anon_const }\n+                | hir::InlineAsmOperand::SymFn { anon_const } => anon_const.hir_id == hir_id,\n+                _ => false,\n+            }) =>\n+        {\n+            return tcx.typeck(def_id).node_type(hir_id)\n+        }\n+        Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => {\n+            return tcx\n+                .adt_def(tcx.hir().get_parent_item(hir_id))\n+                .repr()\n+                .discr_type()\n+                .to_ty(tcx)\n+        }\n+        Node::GenericParam(&GenericParam {\n+            def_id: param_def_id,\n+            kind: GenericParamKind::Const { default: Some(ct), .. },\n+            ..\n+        }) if ct.hir_id == hir_id => {\n+            return tcx.type_of(param_def_id)\n+                .no_bound_vars()\n+                .expect(\"const parameter types cannot be generic\")\n+        }\n+\n+        Node::TypeBinding(binding @ &TypeBinding { hir_id: binding_id, ..  })\n+            if let Node::TraitRef(trait_ref) = tcx.hir().get(\n+                tcx.hir().parent_id(binding_id)\n+            ) =>\n+        {\n+            let Some(trait_def_id) = trait_ref.trait_def_id() else {\n+                return tcx.ty_error_with_message(tcx.def_span(def_id), \"Could not find trait\");\n+            };\n+            let assoc_items = tcx.associated_items(trait_def_id);\n+            let assoc_item = assoc_items.find_by_name_and_kind(\n+                tcx, binding.ident, ty::AssocKind::Const, def_id.to_def_id(),\n+            );\n+            return if let Some(assoc_item) = assoc_item {\n+                tcx.type_of(assoc_item.def_id)\n+                    .no_bound_vars()\n+                    .expect(\"const parameter types cannot be generic\")\n+            } else {\n+                // FIXME(associated_const_equality): add a useful error message here.\n+                tcx.ty_error_with_message(tcx.def_span(def_id), \"Could not find associated const on trait\")\n+            }\n+        }\n+\n         // This match arm is for when the def_id appears in a GAT whose\n         // path can't be resolved without typechecking e.g.\n         //\n@@ -86,11 +145,10 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                 (generics, arg_index)\n             } else {\n                 // I dont think it's possible to reach this but I'm not 100% sure - BoxyUwU\n-                tcx.sess.delay_span_bug(\n+                return tcx.ty_error_with_message(\n                     tcx.def_span(def_id),\n                     \"unexpected non-GAT usage of an anon const\",\n                 );\n-                return None;\n             }\n         }\n         Node::Expr(&Expr {\n@@ -103,7 +161,12 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             // This may fail in case the method/path does not actually exist.\n             // As there is no relevant param for `def_id`, we simply return\n             // `None` here.\n-            let type_dependent_def = tables.type_dependent_def_id(parent_node_id)?;\n+            let Some(type_dependent_def) = tables.type_dependent_def_id(parent_node_id) else {\n+                return tcx.ty_error_with_message(\n+                    tcx.def_span(def_id),\n+                    &format!(\"unable to find type-dependent def for {:?}\", parent_node_id),\n+                );\n+            };\n             let idx = segment\n                 .args\n                 .and_then(|args| {\n@@ -140,19 +203,17 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                     if let Some(path) = get_path_containing_arg_in_pat(pat, hir_id) {\n                         path\n                     } else {\n-                        tcx.sess.delay_span_bug(\n+                        return tcx.ty_error_with_message(\n                             tcx.def_span(def_id),\n                             &format!(\"unable to find const parent for {} in pat {:?}\", hir_id, pat),\n                         );\n-                        return None;\n                     }\n                 }\n                 _ => {\n-                    tcx.sess.delay_span_bug(\n+                    return tcx.ty_error_with_message(\n                         tcx.def_span(def_id),\n                         &format!(\"unexpected const parent path {:?}\", parent_node),\n                     );\n-                    return None;\n                 }\n             };\n \n@@ -171,32 +232,34 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                     .position(|ct| ct.hir_id == hir_id)\n                     .map(|idx| (idx, seg)))\n             }) else {\n-                tcx.sess.delay_span_bug(\n+                return tcx.ty_error_with_message(\n                     tcx.def_span(def_id),\n                     \"no arg matching AnonConst in path\",\n                 );\n-                return None;\n             };\n \n             let generics = match tcx.res_generics_def_id(segment.res) {\n                 Some(def_id) => tcx.generics_of(def_id),\n                 None => {\n-                    tcx.sess.delay_span_bug(\n+                    return tcx.ty_error_with_message(\n                         tcx.def_span(def_id),\n                         &format!(\"unexpected anon const res {:?} in path: {:?}\", segment.res, path),\n                     );\n-                    return None;\n                 }\n             };\n \n             (generics, arg_index)\n         }\n-        _ => return None,\n+\n+        _ => return tcx.ty_error_with_message(\n+            tcx.def_span(def_id),\n+            &format!(\"unexpected const parent in type_of(): {parent_node:?}\"),\n+        ),\n     };\n \n     debug!(?parent_node);\n     debug!(?generics, ?arg_idx);\n-    generics\n+    if let Some(param_def_id) = generics\n         .params\n         .iter()\n         .filter(|param| param.kind.is_ty_or_const())\n@@ -211,6 +274,14 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             }\n             _ => None,\n         })\n+    {\n+        tcx.type_of(param_def_id).no_bound_vars().expect(\"const parameter types cannot be generic\")\n+    } else {\n+        return tcx.ty_error_with_message(\n+            tcx.def_span(def_id),\n+            &format!(\"const generic parameter not found in {generics:?} at position {arg_idx:?}\"),\n+        );\n+    }\n }\n \n fn get_path_containing_arg_in_pat<'hir>(\n@@ -251,7 +322,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n         match tcx.collect_return_position_impl_trait_in_trait_tys(fn_def_id) {\n             Ok(map) => {\n                 let assoc_item = tcx.associated_item(def_id);\n-                return ty::EarlyBinder(map[&assoc_item.trait_item_def_id.unwrap()]);\n+                return map[&assoc_item.trait_item_def_id.unwrap()];\n             }\n             Err(_) => {\n                 return ty::EarlyBinder(tcx.ty_error_with_message(\n@@ -415,143 +486,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n             tcx.typeck(def_id).node_type(hir_id)\n         }\n \n-        Node::AnonConst(_) if let Some(param) = tcx.opt_const_param_of(def_id) => {\n-            // We defer to `type_of` of the corresponding parameter\n-            // for generic arguments.\n-            tcx.type_of(param).subst_identity()\n-        }\n-\n-        Node::AnonConst(_) => {\n-            let parent_node = tcx.hir().get_parent(hir_id);\n-            match parent_node {\n-                Node::Ty(Ty { kind: TyKind::Array(_, constant), .. })\n-                | Node::Expr(Expr { kind: ExprKind::Repeat(_, constant), .. })\n-                    if constant.hir_id() == hir_id =>\n-                {\n-                    tcx.types.usize\n-                }\n-                Node::Ty(Ty { kind: TyKind::Typeof(e), .. }) if e.hir_id == hir_id => {\n-                    tcx.typeck(def_id).node_type(e.hir_id)\n-                }\n-\n-                Node::Expr(Expr { kind: ExprKind::ConstBlock(anon_const), .. })\n-                    if anon_const.hir_id == hir_id =>\n-                {\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    substs.as_inline_const().ty()\n-                }\n-\n-                Node::Expr(&Expr { kind: ExprKind::InlineAsm(asm), .. })\n-                | Node::Item(&Item { kind: ItemKind::GlobalAsm(asm), .. })\n-                    if asm.operands.iter().any(|(op, _op_sp)| match op {\n-                        hir::InlineAsmOperand::Const { anon_const }\n-                        | hir::InlineAsmOperand::SymFn { anon_const } => {\n-                            anon_const.hir_id == hir_id\n-                        }\n-                        _ => false,\n-                    }) =>\n-                {\n-                    tcx.typeck(def_id).node_type(hir_id)\n-                }\n-\n-                Node::Variant(Variant { disr_expr: Some(e), .. }) if e.hir_id == hir_id => {\n-                    tcx.adt_def(tcx.hir().get_parent_item(hir_id)).repr().discr_type().to_ty(tcx)\n-                }\n-\n-                Node::TypeBinding(TypeBinding {\n-                    hir_id: binding_id,\n-                    kind: TypeBindingKind::Equality { term: Term::Const(e) },\n-                    ident,\n-                    ..\n-                }) if let Node::TraitRef(trait_ref) = tcx.hir().get_parent(*binding_id)\n-                    && e.hir_id == hir_id =>\n-                {\n-                    let Some(trait_def_id) = trait_ref.trait_def_id() else {\n-                        return ty::EarlyBinder(tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\"));\n-                    };\n-                    let assoc_items = tcx.associated_items(trait_def_id);\n-                    let assoc_item = assoc_items.find_by_name_and_kind(\n-                        tcx,\n-                        *ident,\n-                        ty::AssocKind::Const,\n-                        def_id.to_def_id(),\n-                    );\n-                    if let Some(assoc_item) = assoc_item {\n-                        tcx.type_of(assoc_item.def_id)\n-                            .no_bound_vars()\n-                            .expect(\"const parameter types cannot be generic\")\n-                    } else {\n-                        // FIXME(associated_const_equality): add a useful error message here.\n-                        tcx.ty_error_with_message(\n-                            DUMMY_SP,\n-                            \"Could not find associated const on trait\",\n-                        )\n-                    }\n-                }\n-\n-                Node::TypeBinding(TypeBinding {\n-                    hir_id: binding_id,\n-                    gen_args,\n-                    kind,\n-                    ident,\n-                    ..\n-                }) if let Node::TraitRef(trait_ref) = tcx.hir().get_parent(*binding_id)\n-                    && let Some((idx, _)) =\n-                        gen_args.args.iter().enumerate().find(|(_, arg)| {\n-                            if let GenericArg::Const(ct) = arg {\n-                                ct.value.hir_id == hir_id\n-                            } else {\n-                                false\n-                            }\n-                        }) =>\n-                {\n-                    let Some(trait_def_id) = trait_ref.trait_def_id() else {\n-                        return ty::EarlyBinder(tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\"));\n-                    };\n-                    let assoc_items = tcx.associated_items(trait_def_id);\n-                    let assoc_item = assoc_items.find_by_name_and_kind(\n-                        tcx,\n-                        *ident,\n-                        match kind {\n-                            // I think `<A: T>` type bindings requires that `A` is a type\n-                            TypeBindingKind::Constraint { .. }\n-                            | TypeBindingKind::Equality { term: Term::Ty(..) } => {\n-                                ty::AssocKind::Type\n-                            }\n-                            TypeBindingKind::Equality { term: Term::Const(..) } => {\n-                                ty::AssocKind::Const\n-                            }\n-                        },\n-                        def_id.to_def_id(),\n-                    );\n-                    if let Some(assoc_item) = assoc_item\n-                        && let param = &tcx.generics_of(assoc_item.def_id).params[idx]\n-                        && matches!(param.kind, ty::GenericParamDefKind::Const { .. })\n-                    {\n-                        tcx.type_of(param.def_id)\n-                            .no_bound_vars()\n-                            .expect(\"const parameter types cannot be generic\")\n-                    } else {\n-                        // FIXME(associated_const_equality): add a useful error message here.\n-                        tcx.ty_error_with_message(\n-                            DUMMY_SP,\n-                            \"Could not find const param on associated item\",\n-                        )\n-                    }\n-                }\n-\n-                Node::GenericParam(&GenericParam {\n-                    def_id: param_def_id,\n-                    kind: GenericParamKind::Const { default: Some(ct), .. },\n-                    ..\n-                }) if ct.hir_id == hir_id => tcx.type_of(param_def_id).subst_identity(),\n-\n-                x => tcx.ty_error_with_message(\n-                    DUMMY_SP,\n-                    &format!(\"unexpected const parent in type_of(): {x:?}\"),\n-                ),\n-            }\n-        }\n+        Node::AnonConst(_) => anon_const_type_of(tcx, def_id),\n \n         Node::GenericParam(param) => match &param.kind {\n             GenericParamKind::Type { default: Some(ty), .. }"}, {"sha": "f82169dee988e2914756a20154df2d590e8a8767", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -631,3 +631,187 @@ pub(crate) struct SIMDFFIHighlyExperimental {\n     pub span: Span,\n     pub snip: String,\n }\n+\n+#[derive(Diagnostic)]\n+\n+pub enum ImplNotMarkedDefault {\n+    #[diag(hir_analysis_impl_not_marked_default, code = \"E0520\")]\n+    #[note]\n+    Ok {\n+        #[primary_span]\n+        #[label]\n+        span: Span,\n+        #[label(hir_analysis_ok_label)]\n+        ok_label: Span,\n+        ident: Symbol,\n+    },\n+    #[diag(hir_analysis_impl_not_marked_default_err, code = \"E0520\")]\n+    #[note]\n+    Err {\n+        #[primary_span]\n+        #[label]\n+        span: Span,\n+        cname: Symbol,\n+        ident: Symbol,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_missing_trait_item, code = \"E0046\")]\n+pub(crate) struct MissingTraitItem {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub missing_trait_item_label: Vec<MissingTraitItemLabel>,\n+    #[subdiagnostic]\n+    pub missing_trait_item: Vec<MissingTraitItemSuggestion>,\n+    #[subdiagnostic]\n+    pub missing_trait_item_none: Vec<MissingTraitItemSuggestionNone>,\n+    pub missing_items_msg: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(hir_analysis_missing_trait_item_label)]\n+pub(crate) struct MissingTraitItemLabel {\n+    #[primary_span]\n+    pub span: Span,\n+    pub item: Symbol,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    hir_analysis_missing_trait_item_suggestion,\n+    style = \"tool-only\",\n+    applicability = \"has-placeholders\",\n+    code = \"{code}\"\n+)]\n+pub(crate) struct MissingTraitItemSuggestion {\n+    #[primary_span]\n+    pub span: Span,\n+    pub code: String,\n+    pub snippet: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    hir_analysis_missing_trait_item_suggestion,\n+    style = \"hidden\",\n+    applicability = \"has-placeholders\",\n+    code = \"{code}\"\n+)]\n+pub(crate) struct MissingTraitItemSuggestionNone {\n+    #[primary_span]\n+    pub span: Span,\n+    pub code: String,\n+    pub snippet: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_missing_one_of_trait_item, code = \"E0046\")]\n+pub(crate) struct MissingOneOfTraitItem {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[note]\n+    pub note: Option<Span>,\n+    pub missing_items_msg: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_missing_trait_item_unstable, code = \"E0046\")]\n+#[note]\n+pub(crate) struct MissingTraitItemUnstable {\n+    #[primary_span]\n+    pub span: Span,\n+    #[note(hir_analysis_some_note)]\n+    pub some_note: bool,\n+    #[note(hir_analysis_none_note)]\n+    pub none_note: bool,\n+    pub missing_item_name: Symbol,\n+    pub feature: Symbol,\n+    pub reason: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_transparent_enum_variant, code = \"E0731\")]\n+pub(crate) struct TransparentEnumVariant {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(hir_analysis_multi_label)]\n+    pub spans: Vec<Span>,\n+    #[label(hir_analysis_many_label)]\n+    pub many: Option<Span>,\n+    pub number: usize,\n+    pub path: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_transparent_non_zero_sized_enum, code = \"E0690\")]\n+pub(crate) struct TransparentNonZeroSizedEnum<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(hir_analysis_labels)]\n+    pub spans: Vec<Span>,\n+    pub field_count: usize,\n+    pub desc: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_transparent_non_zero_sized, code = \"E0690\")]\n+pub(crate) struct TransparentNonZeroSized<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(hir_analysis_labels)]\n+    pub spans: Vec<Span>,\n+    pub field_count: usize,\n+    pub desc: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_too_large_static)]\n+pub(crate) struct TooLargeStatic {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_specialization_trait)]\n+#[help]\n+pub(crate) struct SpecializationTrait {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_closure_implicit_hrtb)]\n+pub(crate) struct ClosureImplicitHrtb {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[label]\n+    pub for_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_const_specialize)]\n+pub(crate) struct ConstSpecialize {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_static_specialize)]\n+pub(crate) struct StaticSpecialize {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_missing_tilde_const)]\n+pub(crate) struct MissingTildeConst {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "c09457e1d65ecb5097dd2f8b02861a4238fdc00e", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -65,8 +65,8 @@\n //! cause use after frees with purely safe code in the same way as specializing\n //! on traits with methods can.\n \n-use crate::constrained_generic_params as cgp;\n use crate::errors::SubstsOnOverriddenImpl;\n+use crate::{constrained_generic_params as cgp, errors};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n@@ -137,9 +137,7 @@ fn check_constness(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node,\n \n     if let hir::Constness::Const = impl2_constness {\n         if let hir::Constness::NotConst = impl1_constness {\n-            tcx.sess\n-                .struct_span_err(span, \"cannot specialize on const impl with non-const impl\")\n-                .emit();\n+            tcx.sess.emit_err(errors::ConstSpecialize { span });\n         }\n     }\n }\n@@ -293,7 +291,7 @@ fn check_static_lifetimes<'tcx>(\n     span: Span,\n ) {\n     if tcx.any_free_region_meets(parent_substs, |r| r.is_static()) {\n-        tcx.sess.struct_span_err(span, \"cannot specialize on `'static` lifetime\").emit();\n+        tcx.sess.emit_err(errors::StaticSpecialize { span });\n     }\n }\n \n@@ -368,7 +366,7 @@ fn check_predicates<'tcx>(\n             wf::obligations(infcx, tcx.param_env(impl1_def_id), impl1_def_id, 0, arg, span)\n                 .unwrap();\n \n-        assert!(!obligations.needs_infer());\n+        assert!(!obligations.has_infer());\n         impl2_predicates\n             .extend(traits::elaborate(tcx, obligations).map(|obligation| obligation.predicate))\n     }\n@@ -438,7 +436,7 @@ fn trait_predicates_eq<'tcx>(\n     // the one on the base.\n     match (trait_pred2.constness, trait_pred1.constness) {\n         (ty::BoundConstness::ConstIfConst, ty::BoundConstness::NotConst) => {\n-            tcx.sess.struct_span_err(span, \"missing `~const` qualifier for specialization\").emit();\n+            tcx.sess.emit_err(errors::MissingTildeConst { span });\n         }\n         _ => {}\n     }"}, {"sha": "a4b797f77f7fe59d7b63f10f8ecaf120fd59b6f1", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -99,10 +99,10 @@ mod variance;\n \n use rustc_errors::ErrorGuaranteed;\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n+use rustc_fluent_macro::fluent_messages;\n use rustc_hir as hir;\n use rustc_hir::Node;\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_macros::fluent_messages;\n use rustc_middle::middle;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -496,8 +496,6 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorGuaranteed> {\n         tcx.hir().for_each_module(|module| tcx.ensure().check_mod_item_types(module))\n     });\n \n-    tcx.sess.time(\"item_bodies_checking\", || tcx.typeck_item_bodies(()));\n-\n     check_unused::check_crate(tcx);\n     check_for_entry_fn(tcx);\n "}, {"sha": "6f0afae1b4c683e96c572d405c0ae0c8b1c2133b", "filename": "compiler/rustc_hir_analysis/src/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n     fn build_constraints_for_item(&mut self, def_id: LocalDefId) {\n         let tcx = self.tcx();\n-        debug!(\"build_constraints_for_item({})\", tcx.def_path_str(def_id.to_def_id()));\n+        debug!(\"build_constraints_for_item({})\", tcx.def_path_str(def_id));\n \n         // Skip items with no generics - there's nothing to infer in them.\n         if tcx.generics_of(def_id).count() == 0 {"}, {"sha": "e735b048d7343f7ed4d29f2a894ec9ed93caf15b", "filename": "compiler/rustc_hir_analysis/src/variance/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -105,7 +105,7 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n             if let ty::RegionKind::ReEarlyBound(ebr) = r.kind() {\n                 self.variances[ebr.index as usize] = ty::Invariant;\n             }\n-            r.super_visit_with(self)\n+            ControlFlow::Continue(())\n         }\n \n         #[instrument(level = \"trace\", skip(self), ret)]\n@@ -153,8 +153,7 @@ fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Varianc\n     let mut collector =\n         OpaqueTypeLifetimeCollector { tcx, root_def_id: item_def_id.to_def_id(), variances };\n     let id_substs = ty::InternalSubsts::identity_for_item(tcx, item_def_id);\n-    for pred in tcx.bound_explicit_item_bounds(item_def_id.to_def_id()).transpose_iter() {\n-        let pred = pred.map_bound(|(pred, _)| *pred).subst(tcx, id_substs);\n+    for (pred, _) in tcx.explicit_item_bounds(item_def_id).subst_iter_copied(tcx, id_substs) {\n         debug!(?pred);\n \n         // We only ignore opaque type substs if the opaque type is the outermost type."}, {"sha": "2db4f1e50d48e4c2fab57aa6cea8cabd69e699fc", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1551,6 +1551,23 @@ impl<'a> State<'a> {\n                 self.word(\"asm!\");\n                 self.print_inline_asm(asm);\n             }\n+            hir::ExprKind::OffsetOf(container, ref fields) => {\n+                self.word(\"offset_of!(\");\n+                self.print_type(container);\n+                self.word(\",\");\n+                self.space();\n+\n+                if let Some((&first, rest)) = fields.split_first() {\n+                    self.print_ident(first);\n+\n+                    for &field in rest {\n+                        self.word(\".\");\n+                        self.print_ident(field);\n+                    }\n+                }\n+\n+                self.word(\")\");\n+            }\n             hir::ExprKind::Yield(expr, _) => {\n                 self.word_space(\"yield\");\n                 self.print_expr_maybe_paren(expr, parser::PREC_JUMP);"}, {"sha": "13e1ea31c4d546a33ffb182b69f10c3bdf213ef4", "filename": "compiler/rustc_hir_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2FCargo.toml?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -12,6 +12,7 @@ rustc_ast = { path = \"../rustc_ast\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_graphviz = { path = \"../rustc_graphviz\" }\n+rustc_fluent_macro = { path = \"../rustc_fluent_macro\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_hir = { path = \"../rustc_hir\" }"}, {"sha": "603ea1440e9ca8d1f6927d289e445abfb80f8a68", "filename": "compiler/rustc_hir_typeck/messages.ftl", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fmessages.ftl?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -3,21 +3,6 @@ hir_typeck_field_multiply_specified_in_initializer =\n     .label = used more than once\n     .previous_use_label = first use of `{$ident}`\n \n-hir_typeck_copy_impl_on_type_with_dtor =\n-    the trait `Copy` cannot be implemented for this type; the type has a destructor\n-    .label = `Copy` not allowed on types with destructors\n-\n-hir_typeck_multiple_relaxed_default_bounds =\n-    type parameter has more than one relaxed default bound, only one is supported\n-\n-hir_typeck_copy_impl_on_non_adt =\n-    the trait `Copy` cannot be implemented for this type\n-    .label = type is not a structure or enumeration\n-\n-hir_typeck_trait_object_declared_with_no_traits =\n-    at least one trait is required for an object type\n-    .alias_span = this alias does not contain a trait\n-\n hir_typeck_functional_record_update_on_non_struct =\n     functional record update syntax requires a struct\n \n@@ -77,3 +62,16 @@ hir_typeck_fru_suggestion =\n         [NONE]{\"\"}\n         *[other] {\" \"}from `{$expr}`\n     }, separate the last named field with a comma\n+\n+hir_typeck_const_select_must_be_const = this argument must be a `const fn`\n+    .help = consult the documentation on `const_eval_select` for more information\n+\n+hir_typeck_const_select_must_be_fn = this argument must be a function item\n+    .note = expected a function item, found {$ty}\n+    .help = consult the documentation on `const_eval_select` for more information\n+\n+hir_typeck_union_pat_multiple_fields = union patterns should have exactly one field\n+hir_typeck_union_pat_dotdot = `..` cannot be used in union patterns\n+\n+hir_typeck_arg_mismatch_indeterminate = argument type mismatch was detected, but rustc had trouble determining where\n+    .note = we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new"}, {"sha": "aefde8109a07a71dd5995a75522c893abff6a7ab", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -530,7 +530,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 for ty in [first_ty, second_ty] {\n                     for (pred, _) in self\n                         .tcx\n-                        .bound_explicit_item_bounds(rpit_def_id)\n+                        .explicit_item_bounds(rpit_def_id)\n                         .subst_iter_copied(self.tcx, substs)\n                     {\n                         let pred = pred.kind().rebind(match pred.kind().skip_binder() {"}, {"sha": "7046269c2de22c953644630010d4a85e7e8f92fa", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -172,7 +172,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => self\n                 .deduce_closure_signature_from_predicates(\n                     expected_ty,\n-                    self.tcx.bound_explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs),\n+                    self.tcx.explicit_item_bounds(def_id).subst_iter_copied(self.tcx, substs),\n                 ),\n             ty::Dynamic(ref object_type, ..) => {\n                 let sig = object_type.projection_bounds().find_map(|pb| {\n@@ -713,13 +713,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => self\n                 .tcx\n-                .bound_explicit_item_bounds(def_id)\n+                .explicit_item_bounds(def_id)\n                 .subst_iter_copied(self.tcx, substs)\n                 .find_map(|(p, s)| get_future_output(p, s))?,\n             ty::Error(_) => return None,\n             ty::Alias(ty::Projection, proj) if self.tcx.is_impl_trait_in_trait(proj.def_id) => self\n                 .tcx\n-                .bound_explicit_item_bounds(proj.def_id)\n+                .explicit_item_bounds(proj.def_id)\n                 .subst_iter_copied(self.tcx, proj.substs)\n                 .find_map(|(p, s)| get_future_output(p, s))?,\n             _ => span_bug!("}, {"sha": "507c24d540cc5412913a653e23f39bb6682bd68c", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -976,7 +976,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Attempt to coerce an expression to a type, and return the\n     /// adjusted type of the expression, if successful.\n     /// Adjustments are only recorded if the coercion succeeded.\n-    /// The expressions *must not* have any pre-existing adjustments.\n+    /// The expressions *must not* have any preexisting adjustments.\n     pub fn try_coerce(\n         &self,\n         expr: &hir::Expr<'_>,\n@@ -1340,7 +1340,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     }\n \n     /// As an optimization, you can create a `CoerceMany` with a\n-    /// pre-existing slice of expressions. In this case, you are\n+    /// preexisting slice of expressions. In this case, you are\n     /// expected to pass each element in the slice to `coerce(...)` in\n     /// order. This is used with arrays in particular to avoid\n     /// needlessly cloning the slice."}, {"sha": "b8222820cf7a4086971261e24e815d4d953de5d1", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 227, "deletions": 188, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,6 +1,5 @@\n use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::MultiSpan;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n@@ -13,15 +12,12 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::fold::{BottomUpFolder, TypeFolder};\n-use rustc_middle::ty::print::{with_forced_trimmed_paths, with_no_trimmed_paths};\n-use rustc_middle::ty::relate::TypeRelation;\n-use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeVisitableExt};\n+use rustc_middle::ty::fold::BottomUpFolder;\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeFoldable};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{BytePos, Span};\n-use rustc_target::abi::FieldIdx;\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::traits::error_reporting::method_chain::CollectAllMismatches;\n use rustc_trait_selection::traits::ObligationCause;\n \n use super::method::probe;\n@@ -62,9 +58,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_into(err, expr, expr_ty, expected)\n             || self.suggest_floating_point_literal(err, expr, expected)\n             || self.suggest_null_ptr_for_literal_zero_given_to_ptr_arg(err, expr, expected)\n-            || self.note_result_coercion(err, expr, expected, expr_ty);\n+            || self.suggest_coercing_result_via_try_operator(err, expr, expected, expr_ty);\n+\n         if !suggested {\n-            self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected, expr.span);\n+            self.note_source_of_type_mismatch_constraint(\n+                err,\n+                expr,\n+                TypeMismatchSource::Ty(expected),\n+            );\n         }\n     }\n \n@@ -218,37 +219,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (expected, Some(err))\n     }\n \n-    pub fn point_at_expr_source_of_inferred_type(\n+    /// Notes the point at which a variable is constrained to some type incompatible\n+    /// with some expectation given by `source`.\n+    pub fn note_source_of_type_mismatch_constraint(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n-        found: Ty<'tcx>,\n-        expected: Ty<'tcx>,\n-        mismatch_span: Span,\n+        source: TypeMismatchSource<'tcx>,\n     ) -> bool {\n-        let map = self.tcx.hir();\n+        let hir = self.tcx.hir();\n \n         let hir::ExprKind::Path(hir::QPath::Resolved(None, p)) = expr.kind else { return false; };\n         let [hir::PathSegment { ident, args: None, .. }] = p.segments else { return false; };\n-        let hir::def::Res::Local(hir_id) = p.res else { return false; };\n-        let Some(hir::Node::Pat(pat)) = map.find(hir_id) else { return false; };\n-        let Some(hir::Node::Local(hir::Local {\n-            ty: None,\n-            init: Some(init),\n-            ..\n-        })) = map.find_parent(pat.hir_id) else { return false; };\n-        let Some(ty) = self.node_ty_opt(init.hir_id) else { return false; };\n-        if ty.is_closure() || init.span.overlaps(expr.span) || pat.span.from_expansion() {\n-            return false;\n-        }\n+        let hir::def::Res::Local(local_hir_id) = p.res else { return false; };\n+        let hir::Node::Pat(pat) = hir.get(local_hir_id) else { return false; };\n+        let (init_ty_hir_id, init) = match hir.get_parent(pat.hir_id) {\n+            hir::Node::Local(hir::Local { ty: Some(ty), init, .. }) => (ty.hir_id, *init),\n+            hir::Node::Local(hir::Local { init: Some(init), .. }) => (init.hir_id, Some(*init)),\n+            _ => return false,\n+        };\n+        let Some(init_ty) = self.node_ty_opt(init_ty_hir_id) else { return false; };\n \n         // Locate all the usages of the relevant binding.\n-        struct FindExprs<'hir> {\n+        struct FindExprs<'tcx> {\n             hir_id: hir::HirId,\n-            uses: Vec<&'hir hir::Expr<'hir>>,\n+            uses: Vec<&'tcx hir::Expr<'tcx>>,\n         }\n-        impl<'v> Visitor<'v> for FindExprs<'v> {\n-            fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+        impl<'tcx> Visitor<'tcx> for FindExprs<'tcx> {\n+            fn visit_expr(&mut self, ex: &'tcx hir::Expr<'tcx>) {\n                 if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = ex.kind\n                     && let hir::def::Res::Local(hir_id) = path.res\n                     && hir_id == self.hir_id\n@@ -259,180 +257,205 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let mut expr_finder = FindExprs { hir_id, uses: vec![] };\n-        let id = map.get_parent_item(hir_id);\n-        let hir_id: hir::HirId = id.into();\n-\n-        let Some(node) = map.find(hir_id) else { return false; };\n-        let Some(body_id) = node.body_id() else { return false; };\n-        let body = map.body(body_id);\n+        let mut expr_finder = FindExprs { hir_id: local_hir_id, uses: init.into_iter().collect() };\n+        let body =\n+            hir.body(hir.maybe_body_owned_by(self.body_id).expect(\"expected item to have body\"));\n         expr_finder.visit_expr(body.value);\n-        // Hack to make equality checks on types with inference variables and regions useful.\n-        let mut eraser = BottomUpFolder {\n+\n+        use rustc_infer::infer::type_variable::*;\n+        use rustc_middle::infer::unify_key::*;\n+        // Replaces all of the variables in the given type with a fresh inference variable.\n+        let mut fudger = BottomUpFolder {\n             tcx: self.tcx,\n+            ty_op: |ty| {\n+                if let ty::Infer(infer) = ty.kind() {\n+                    match infer {\n+                        ty::InferTy::TyVar(_) => self.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::MiscVariable,\n+                            span: DUMMY_SP,\n+                        }),\n+                        ty::InferTy::IntVar(_) => self.next_int_var(),\n+                        ty::InferTy::FloatVar(_) => self.next_float_var(),\n+                        _ => bug!(),\n+                    }\n+                } else {\n+                    ty\n+                }\n+            },\n             lt_op: |_| self.tcx.lifetimes.re_erased,\n-            ct_op: |c| c,\n-            ty_op: |t| match *t.kind() {\n-                ty::Infer(ty::TyVar(_)) => self.tcx.mk_ty_var(ty::TyVid::from_u32(0)),\n-                ty::Infer(ty::IntVar(_)) => self.tcx.mk_int_var(ty::IntVid { index: 0 }),\n-                ty::Infer(ty::FloatVar(_)) => self.tcx.mk_float_var(ty::FloatVid { index: 0 }),\n-                _ => t,\n+            ct_op: |ct| {\n+                if let ty::ConstKind::Infer(_) = ct.kind() {\n+                    self.next_const_var(\n+                        ct.ty(),\n+                        ConstVariableOrigin {\n+                            kind: ConstVariableOriginKind::MiscVariable,\n+                            span: DUMMY_SP,\n+                        },\n+                    )\n+                } else {\n+                    ct\n+                }\n             },\n         };\n-        let mut prev = eraser.fold_ty(ty);\n-        let mut prev_span: Option<Span> = None;\n-\n-        for binding in expr_finder.uses {\n-            // In every expression where the binding is referenced, we will look at that\n-            // expression's type and see if it is where the incorrect found type was fully\n-            // \"materialized\" and point at it. We will also try to provide a suggestion there.\n-            if let Some(hir::Node::Expr(expr)\n-            | hir::Node::Stmt(hir::Stmt {\n-                kind: hir::StmtKind::Expr(expr) | hir::StmtKind::Semi(expr),\n-                ..\n-            })) = &map.find_parent(binding.hir_id)\n-                && let hir::ExprKind::MethodCall(segment, rcvr, args, _span) = expr.kind\n-                && rcvr.hir_id == binding.hir_id\n-                && let Some(def_id) = self.typeck_results.borrow().type_dependent_def_id(expr.hir_id)\n-            {\n-                // We special case methods, because they can influence inference through the\n-                // call's arguments and we can provide a more explicit span.\n-                let sig = self.tcx.fn_sig(def_id).subst_identity();\n-                let def_self_ty = sig.input(0).skip_binder();\n-                let param_tys = sig.inputs().skip_binder().iter().skip(1);\n-                // If there's an arity mismatch, pointing out the call as the source of an inference\n-                // can be misleading, so we skip it.\n-                if param_tys.len() != args.len() {\n-                    continue;\n-                }\n-                let rcvr_ty = self.node_ty(rcvr.hir_id);\n-                // Get the evaluated type *after* calling the method call, so that the influence\n-                // of the arguments can be reflected in the receiver type. The receiver\n-                // expression has the type *before* this analysis is done.\n-                let ty = match self.lookup_probe_for_diagnostic(\n-                    segment.ident,\n-                    rcvr_ty,\n-                    expr,\n-                    probe::ProbeScope::TraitsInScope,\n-                    None,\n-                ) {\n-                    Ok(pick) => eraser.fold_ty(pick.self_ty),\n-                    Err(_) => rcvr_ty,\n+\n+        let expected_ty = match source {\n+            TypeMismatchSource::Ty(expected_ty) => expected_ty,\n+            // Try to deduce what the possible value of `expr` would be if the\n+            // incompatible arg were compatible. For example, given `Vec<i32>`\n+            // and `vec.push(1u32)`, we ideally want to deduce that the type of\n+            // `vec` *should* have been `Vec<u32>`. This will allow us to then\n+            // run the subsequent code with this expectation, finding out exactly\n+            // when this type diverged from our expectation.\n+            TypeMismatchSource::Arg { call_expr, incompatible_arg: idx } => {\n+                let hir::ExprKind::MethodCall(segment, _, args, _) = call_expr.kind else {\n+                    return false;\n                 };\n-                // Remove one layer of references to account for `&mut self` and\n-                // `&self`, so that we can compare it against the binding.\n-                let (ty, def_self_ty) = match (ty.kind(), def_self_ty.kind()) {\n-                    (ty::Ref(_, ty, a), ty::Ref(_, self_ty, b)) if a == b => (*ty, *self_ty),\n-                    _ => (ty, def_self_ty),\n+                let Some(arg_ty) = self.node_ty_opt(args[idx].hir_id) else {\n+                    return false;\n                 };\n-                let mut param_args = FxHashMap::default();\n-                let mut param_expected = FxHashMap::default();\n-                let mut param_found = FxHashMap::default();\n-                if self.can_eq(self.param_env, ty, found) {\n-                    // We only point at the first place where the found type was inferred.\n-                    for (param_ty, arg) in param_tys.zip(args) {\n-                        if def_self_ty.contains(*param_ty) && let ty::Param(_) = param_ty.kind() {\n-                            // We found an argument that references a type parameter in `Self`,\n-                            // so we assume that this is the argument that caused the found\n-                            // type, which we know already because of `can_eq` above was first\n-                            // inferred in this method call.\n-                            let arg_ty = self.node_ty(arg.hir_id);\n-                            if !arg.span.overlaps(mismatch_span) {\n-                                err.span_label(\n-                                    arg.span,\n-                                    &format!(\n-                                        \"this is of type `{arg_ty}`, which causes `{ident}` to be \\\n-                                        inferred as `{ty}`\",\n-                                    ),\n-                                );\n-                            }\n-                            param_args.insert(param_ty, (arg, arg_ty));\n-                        }\n-                    }\n+                let possible_rcvr_ty = expr_finder.uses.iter().find_map(|binding| {\n+                    let possible_rcvr_ty = self.node_ty_opt(binding.hir_id)?;\n+                    // Fudge the receiver, so we can do new inference on it.\n+                    let possible_rcvr_ty = possible_rcvr_ty.fold_with(&mut fudger);\n+                    let method = self\n+                        .lookup_method(\n+                            possible_rcvr_ty,\n+                            segment,\n+                            DUMMY_SP,\n+                            call_expr,\n+                            binding,\n+                            args,\n+                        )\n+                        .ok()?;\n+                    // Unify the method signature with our incompatible arg, to\n+                    // do inference in the *opposite* direction and to find out\n+                    // what our ideal rcvr ty would look like.\n+                    let _ = self\n+                        .at(&ObligationCause::dummy(), self.param_env)\n+                        .eq(DefineOpaqueTypes::No, method.sig.inputs()[idx + 1], arg_ty)\n+                        .ok()?;\n+                    self.select_obligations_where_possible(|errs| {\n+                        // Yeet the errors, we're already reporting errors.\n+                        errs.clear();\n+                    });\n+                    Some(self.resolve_vars_if_possible(possible_rcvr_ty))\n+                });\n+                if let Some(rcvr_ty) = possible_rcvr_ty {\n+                    rcvr_ty\n+                } else {\n+                    return false;\n                 }\n+            }\n+        };\n+\n+        // If our expected_ty does not equal init_ty, then it *began* as incompatible.\n+        // No need to note in this case...\n+        if !self.can_eq(self.param_env, expected_ty, init_ty.fold_with(&mut fudger)) {\n+            return false;\n+        }\n+\n+        for window in expr_finder.uses.windows(2) {\n+            // Bindings always update their recorded type after the fact, so we\n+            // need to look at the *following* usage's type to see when the\n+            // binding became incompatible.\n+            let [binding, next_usage] = *window else { continue; };\n+\n+            // Don't go past the binding (always gonna be a nonsense label if so)\n+            if binding.hir_id == expr.hir_id {\n+                break;\n+            }\n+\n+            let Some(next_use_ty) = self.node_ty_opt(next_usage.hir_id) else { continue; };\n+\n+            // If the type is not constrained in a way making it not possible to\n+            // equate with `expected_ty` by this point, skip.\n+            if self.can_eq(self.param_env, expected_ty, next_use_ty.fold_with(&mut fudger)) {\n+                continue;\n+            }\n \n-                // Here we find, for a type param `T`, the type that `T` is in the current\n-                // method call *and* in the original expected type. That way, we can see if we\n-                // can give any structured suggestion for the function argument.\n-                let mut c = CollectAllMismatches {\n-                    infcx: &self.infcx,\n-                    param_env: self.param_env,\n-                    errors: vec![],\n+            if let hir::Node::Expr(parent_expr) = hir.get_parent(binding.hir_id)\n+                && let hir::ExprKind::MethodCall(segment, rcvr, args, _) = parent_expr.kind\n+                && rcvr.hir_id == binding.hir_id\n+            {\n+                // If our binding became incompatible while it was a receiver\n+                // to a method call, we may be able to make a better guess to\n+                // the source of a type mismatch.\n+                let Some(rcvr_ty) = self.node_ty_opt(rcvr.hir_id) else { continue; };\n+                let rcvr_ty = rcvr_ty.fold_with(&mut fudger);\n+                let Ok(method) =\n+                    self.lookup_method(rcvr_ty, segment, DUMMY_SP, parent_expr, rcvr, args)\n+                else {\n+                    continue;\n                 };\n-                let _ = c.relate(def_self_ty, ty);\n-                for error in c.errors {\n-                    if let TypeError::Sorts(error) = error {\n-                        param_found.insert(error.expected, error.found);\n-                    }\n-                }\n-                c.errors = vec![];\n-                let _ = c.relate(def_self_ty, expected);\n-                for error in c.errors {\n-                    if let TypeError::Sorts(error) = error {\n-                        param_expected.insert(error.expected, error.found);\n-                    }\n-                }\n-                for (param, (arg, arg_ty)) in param_args.iter() {\n-                    let Some(expected) = param_expected.get(param) else { continue; };\n-                    let Some(found) = param_found.get(param) else { continue; };\n-                    if !self.can_eq(self.param_env, *arg_ty, *found) { continue; }\n-                    self.emit_coerce_suggestions(err, arg, *found, *expected, None, None);\n-                }\n \n-                let ty = eraser.fold_ty(ty);\n-                if ty.references_error() {\n-                    break;\n-                }\n-                if ty != prev\n-                    && param_args.is_empty()\n-                    && self.can_eq(self.param_env, ty, found)\n+                let ideal_rcvr_ty = rcvr_ty.fold_with(&mut fudger);\n+                let ideal_method = self\n+                    .lookup_method(ideal_rcvr_ty, segment, DUMMY_SP, parent_expr, rcvr, args)\n+                    .ok()\n+                    .and_then(|method| {\n+                        let _ = self.at(&ObligationCause::dummy(), self.param_env)\n+                            .eq(DefineOpaqueTypes::No, ideal_rcvr_ty, expected_ty)\n+                            .ok()?;\n+                        Some(method)\n+                    });\n+\n+                // Find what argument caused our rcvr to become incompatible\n+                // with the expected ty.\n+                for (idx, (expected_arg_ty, arg_expr)) in\n+                    std::iter::zip(&method.sig.inputs()[1..], args).enumerate()\n                 {\n-                    // We only point at the first place where the found type was inferred.\n-                    if !segment.ident.span.overlaps(mismatch_span) {\n+                    let Some(arg_ty) = self.node_ty_opt(arg_expr.hir_id) else { continue; };\n+                    let arg_ty = arg_ty.fold_with(&mut fudger);\n+                    let _ = self.try_coerce(\n+                        arg_expr,\n+                        arg_ty,\n+                        *expected_arg_ty,\n+                        AllowTwoPhase::No,\n+                        None,\n+                    );\n+                    self.select_obligations_where_possible(|errs| {\n+                        // Yeet the errors, we're already reporting errors.\n+                        errs.clear();\n+                    });\n+                    // If our rcvr, after inference due to unifying the signature\n+                    // with the expected argument type, is still compatible with\n+                    // the rcvr, then it must've not been the source of blame.\n+                    if self.can_eq(self.param_env, rcvr_ty, expected_ty) {\n+                        continue;\n+                    }\n+                    err.span_label(arg_expr.span, format!(\"this argument has type `{arg_ty}`...\"));\n                     err.span_label(\n-                        segment.ident.span,\n-                        with_forced_trimmed_paths!(format!(\n-                            \"here the type of `{ident}` is inferred to be `{ty}`\",\n-                        )),\n-                    );}\n-                    break;\n-                } else if !param_args.is_empty() {\n-                    break;\n-                }\n-                prev = ty;\n-            } else {\n-                let ty = eraser.fold_ty(self.node_ty(binding.hir_id));\n-                if ty.references_error() {\n-                    break;\n-                }\n-                if ty != prev\n-                    && let Some(span) = prev_span\n-                    && self.can_eq(self.param_env, ty, found)\n-                {\n-                    // We only point at the first place where the found type was inferred.\n-                    // We use the *previous* span because if the type is known *here* it means\n-                    // it was *evaluated earlier*. We don't do this for method calls because we\n-                    // evaluate the method's self type eagerly, but not in any other case.\n-                    if !span.overlaps(mismatch_span) {\n-                        err.span_label(\n-                            span,\n-                            with_forced_trimmed_paths!(format!(\n-                                \"here the type of `{ident}` is inferred to be `{ty}`\",\n-                            )),\n+                        binding.span,\n+                        format!(\"... which causes `{ident}` to have type `{next_use_ty}`\"),\n+                    );\n+                    // Using our \"ideal\" method signature, suggest a fix to this\n+                    // blame arg, if possible. Don't do this if we're coming from\n+                    // arg mismatch code, because we'll possibly suggest a mutually\n+                    // incompatible fix at the original mismatch site.\n+                    if matches!(source, TypeMismatchSource::Ty(_))\n+                        && let Some(ideal_method) = ideal_method\n+                    {\n+                        self.emit_type_mismatch_suggestions(\n+                            err,\n+                            arg_expr,\n+                            arg_ty,\n+                            self.resolve_vars_if_possible(ideal_method.sig.inputs()[idx + 1]),\n+                            None,\n+                            None,\n                         );\n                     }\n-                    break;\n+                    return true;\n                 }\n-                prev = ty;\n             }\n-            if binding.hir_id == expr.hir_id {\n-                // Do not look at expressions that come after the expression we were originally\n-                // evaluating and had a type error.\n-                break;\n-            }\n-            prev_span = Some(binding.span);\n+            err.span_label(\n+                binding.span,\n+                format!(\"here the type of `{ident}` is inferred to be `{next_use_ty}`\"),\n+            );\n+            return true;\n         }\n-        true\n+\n+        // We must've not found something that constrained the expr.\n+        false\n     }\n \n     fn annotate_expected_due_to_let_ty(\n@@ -708,7 +731,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n     }\n \n-    pub(crate) fn note_result_coercion(\n+    pub(crate) fn suggest_coercing_result_via_try_operator(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'tcx>,\n@@ -851,7 +874,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     variant.fields.len() == 1\n                 })\n                 .filter_map(|variant| {\n-                    let sole_field = &variant.fields[FieldIdx::from_u32(0)];\n+                    let sole_field = &variant.single_field();\n \n                     let field_is_local = sole_field.did.is_local();\n                     let field_is_accessible =\n@@ -1485,6 +1508,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // FIXME(compiler-errors): We can actually do this if the checked_ty is\n                         // `steps` layers of boxes, not just one, but this is easier and most likely.\n                         || (checked_ty.is_box() && steps == 1)\n+                        // We can always deref a binop that takes its arguments by ref.\n+                        || matches!(\n+                            self.tcx.hir().get_parent(expr.hir_id),\n+                            hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Binary(op, ..), .. })\n+                                if !op.node.is_by_value()\n+                        )\n                     {\n                         let deref_kind = if checked_ty.is_box() {\n                             \"unboxing the value\"\n@@ -2094,3 +2123,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n+\n+pub enum TypeMismatchSource<'tcx> {\n+    /// Expected the binding to have the given type, but it was found to have\n+    /// a different type. Find out when that type first became incompatible.\n+    Ty(Ty<'tcx>),\n+    /// When we fail during method argument checking, try to find out if a previous\n+    /// expression has constrained the method's receiver in a way that makes the\n+    /// argument's type incompatible.\n+    Arg { call_expr: &'tcx hir::Expr<'tcx>, incompatible_arg: usize },\n+}"}, {"sha": "48c40d216034e00c56cda3a76fbdae8a6c942508", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -108,7 +108,7 @@ pub enum ExpectedReturnTypeLabel<'tcx> {\n \n #[derive(Diagnostic)]\n #[diag(hir_typeck_missing_parentheses_in_range, code = \"E0689\")]\n-pub struct MissingParentheseInRange {\n+pub struct MissingParenthesesInRange {\n     #[primary_span]\n     #[label(hir_typeck_missing_parentheses_in_range)]\n     pub span: Span,\n@@ -228,3 +228,42 @@ impl HelpUseLatestEdition {\n         }\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_const_select_must_be_const)]\n+#[help]\n+pub struct ConstSelectMustBeConst {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_const_select_must_be_fn)]\n+#[note]\n+#[help]\n+pub struct ConstSelectMustBeFn<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_union_pat_multiple_fields)]\n+pub struct UnionPatMultipleFields {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_union_pat_dotdot)]\n+pub struct UnionPatDotDot {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_arg_mismatch_indeterminate)]\n+pub struct ArgMismatchIndeterminate {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "3ffc583d43f6125a4b652b99b5fb9d215faaa24d", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 189, "deletions": 13, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -38,6 +38,7 @@ use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::infer::InferOk;\n+use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n@@ -53,6 +54,8 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_target::abi::FieldIdx;\n use rustc_target::spec::abi::Abi::RustIntrinsic;\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n+use rustc_trait_selection::traits::ObligationCtxt;\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -306,6 +309,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.deferred_asm_checks.borrow_mut().push((asm, expr.hir_id));\n                 self.check_expr_asm(asm)\n             }\n+            ExprKind::OffsetOf(container, ref fields) => {\n+                self.check_offset_of(container, fields, expr)\n+            }\n             ExprKind::Break(destination, ref expr_opt) => {\n                 self.check_expr_break(destination, expr_opt.as_deref(), expr)\n             }\n@@ -1735,10 +1741,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 self.check_expr_has_type_or_error(base_expr, adt_ty, |_| {\n                     let base_ty = self.typeck_results.borrow().expr_ty(*base_expr);\n-                    let same_adt = match (adt_ty.kind(), base_ty.kind()) {\n-                        (ty::Adt(adt, _), ty::Adt(base_adt, _)) if adt == base_adt => true,\n-                        _ => false,\n-                    };\n+                    let same_adt = matches!((adt_ty.kind(), base_ty.kind()),\n+                        (ty::Adt(adt, _), ty::Adt(base_adt, _)) if adt == base_adt);\n                     if self.tcx.sess.is_nightly_build() && same_adt {\n                         feature_err(\n                             &self.tcx.sess.parse_sess,\n@@ -2449,15 +2453,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base_did: DefId,\n         return_ty: Option<Ty<'tcx>>,\n     ) -> ErrorGuaranteed {\n-        let struct_path = self.tcx().def_path_str(base_did);\n-        let kind_name = self.tcx().def_descr(base_did);\n-        let mut err = struct_span_err!(\n-            self.tcx().sess,\n-            field.span,\n-            E0616,\n-            \"field `{field}` of {kind_name} `{struct_path}` is private\",\n-        );\n-        err.span_label(field.span, \"private field\");\n+        let mut err = self.private_field_err(field, base_did);\n+\n         // Also check if an accessible method exists, which is often what is meant.\n         if self.method_exists(field, expr_t, expr.hir_id, false, return_ty)\n             && !self.expr_in_place(expr.hir_id)\n@@ -2697,6 +2694,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err\n     }\n \n+    fn private_field_err(\n+        &self,\n+        field: Ident,\n+        base_did: DefId,\n+    ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let struct_path = self.tcx().def_path_str(base_did);\n+        let kind_name = self.tcx().def_descr(base_did);\n+        let mut err = struct_span_err!(\n+            self.tcx().sess,\n+            field.span,\n+            E0616,\n+            \"field `{field}` of {kind_name} `{struct_path}` is private\",\n+        );\n+        err.span_label(field.span, \"private field\");\n+\n+        err\n+    }\n+\n     pub(crate) fn get_field_candidates_considering_privacy(\n         &self,\n         span: Span,\n@@ -2802,6 +2817,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     element_ty\n                 }\n                 None => {\n+                    // Attempt to *shallowly* search for an impl which matches,\n+                    // but has nested obligations which are unsatisfied.\n+                    for (base_t, _) in self.autoderef(base.span, base_t).silence_errors() {\n+                        if let Some((_, index_ty, element_ty)) =\n+                            self.find_and_report_unsatisfied_index_impl(expr.hir_id, base, base_t)\n+                        {\n+                            self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);\n+                            return element_ty;\n+                        }\n+                    }\n+\n                     let mut err = type_error_struct!(\n                         self.tcx.sess,\n                         expr.span,\n@@ -2845,6 +2871,82 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Try to match an implementation of `Index` against a self type, and report\n+    /// the unsatisfied predicates that result from confirming this impl.\n+    ///\n+    /// Given an index expression, sometimes the `Self` type shallowly but does not\n+    /// deeply satisfy an impl predicate. Instead of simply saying that the type\n+    /// does not support being indexed, we want to point out exactly what nested\n+    /// predicates cause this to be, so that the user can add them to fix their code.\n+    fn find_and_report_unsatisfied_index_impl(\n+        &self,\n+        index_expr_hir_id: HirId,\n+        base_expr: &hir::Expr<'_>,\n+        base_ty: Ty<'tcx>,\n+    ) -> Option<(ErrorGuaranteed, Ty<'tcx>, Ty<'tcx>)> {\n+        let index_trait_def_id = self.tcx.lang_items().index_trait()?;\n+        let index_trait_output_def_id = self.tcx.get_diagnostic_item(sym::IndexOutput)?;\n+\n+        let mut relevant_impls = vec![];\n+        self.tcx.for_each_relevant_impl(index_trait_def_id, base_ty, |impl_def_id| {\n+            relevant_impls.push(impl_def_id);\n+        });\n+        let [impl_def_id] = relevant_impls[..] else {\n+            // Only report unsatisfied impl predicates if there's one impl\n+            return None;\n+        };\n+\n+        self.commit_if_ok(|_| {\n+            let ocx = ObligationCtxt::new_in_snapshot(self);\n+            let impl_substs = self.fresh_substs_for_item(base_expr.span, impl_def_id);\n+            let impl_trait_ref =\n+                self.tcx.impl_trait_ref(impl_def_id).unwrap().subst(self.tcx, impl_substs);\n+            let cause = self.misc(base_expr.span);\n+\n+            // Match the impl self type against the base ty. If this fails,\n+            // we just skip this impl, since it's not particularly useful.\n+            let impl_trait_ref = ocx.normalize(&cause, self.param_env, impl_trait_ref);\n+            ocx.eq(&cause, self.param_env, impl_trait_ref.self_ty(), base_ty)?;\n+\n+            // Register the impl's predicates. One of these predicates\n+            // must be unsatisfied, or else we wouldn't have gotten here\n+            // in the first place.\n+            ocx.register_obligations(traits::predicates_for_generics(\n+                |idx, span| {\n+                    traits::ObligationCause::new(\n+                        base_expr.span,\n+                        self.body_id,\n+                        if span.is_dummy() {\n+                            traits::ExprItemObligation(impl_def_id, index_expr_hir_id, idx)\n+                        } else {\n+                            traits::ExprBindingObligation(impl_def_id, span, index_expr_hir_id, idx)\n+                        },\n+                    )\n+                },\n+                self.param_env,\n+                self.tcx.predicates_of(impl_def_id).instantiate(self.tcx, impl_substs),\n+            ));\n+\n+            // Normalize the output type, which we can use later on as the\n+            // return type of the index expression...\n+            let element_ty = ocx.normalize(\n+                &cause,\n+                self.param_env,\n+                self.tcx.mk_projection(index_trait_output_def_id, impl_trait_ref.substs),\n+            );\n+\n+            let errors = ocx.select_where_possible();\n+            // There should be at least one error reported. If not, we\n+            // will still delay a span bug in `report_fulfillment_errors`.\n+            Ok::<_, NoSolution>((\n+                self.err_ctxt().report_fulfillment_errors(&errors),\n+                impl_trait_ref.substs.type_at(1),\n+                element_ty,\n+            ))\n+        })\n+        .ok()\n+    }\n+\n     fn point_at_index_if_possible(\n         &self,\n         errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n@@ -2954,4 +3056,78 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tcx.mk_unit()\n         }\n     }\n+\n+    fn check_offset_of(\n+        &self,\n+        container: &'tcx hir::Ty<'tcx>,\n+        fields: &[Ident],\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let container = self.to_ty(container).normalized;\n+\n+        let mut field_indices = Vec::with_capacity(fields.len());\n+        let mut current_container = container;\n+\n+        for &field in fields {\n+            let container = self.structurally_resolved_type(expr.span, current_container);\n+\n+            match container.kind() {\n+                ty::Adt(container_def, substs) if !container_def.is_enum() => {\n+                    let block = self.tcx.hir().local_def_id_to_hir_id(self.body_id);\n+                    let (ident, def_scope) =\n+                        self.tcx.adjust_ident_and_get_scope(field, container_def.did(), block);\n+\n+                    let fields = &container_def.non_enum_variant().fields;\n+                    if let Some((index, field)) = fields\n+                        .iter_enumerated()\n+                        .find(|(_, f)| f.ident(self.tcx).normalize_to_macros_2_0() == ident)\n+                    {\n+                        let field_ty = self.field_ty(expr.span, field, substs);\n+\n+                        // FIXME: DSTs with static alignment should be allowed\n+                        self.require_type_is_sized(field_ty, expr.span, traits::MiscObligation);\n+\n+                        if field.vis.is_accessible_from(def_scope, self.tcx) {\n+                            self.tcx.check_stability(field.did, Some(expr.hir_id), expr.span, None);\n+                        } else {\n+                            self.private_field_err(ident, container_def.did()).emit();\n+                        }\n+\n+                        // Save the index of all fields regardless of their visibility in case\n+                        // of error recovery.\n+                        field_indices.push(index);\n+                        current_container = field_ty;\n+\n+                        continue;\n+                    }\n+                }\n+                ty::Tuple(tys) => {\n+                    let fstr = field.as_str();\n+\n+                    if let Ok(index) = fstr.parse::<usize>() {\n+                        if fstr == index.to_string() {\n+                            if let Some(&field_ty) = tys.get(index) {\n+                                field_indices.push(index.into());\n+                                current_container = field_ty;\n+\n+                                continue;\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => (),\n+            };\n+\n+            self.no_such_field_err(field, container, expr.hir_id).emit();\n+\n+            break;\n+        }\n+\n+        self.typeck_results\n+            .borrow_mut()\n+            .offset_of_data_mut()\n+            .insert(expr.hir_id, (container, field_indices));\n+\n+        self.tcx.types.usize\n+    }\n }"}, {"sha": "94b6a0f8f47d74d24a041413375c68800ebb5b8e", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -300,6 +300,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             hir::ExprKind::Continue(..)\n             | hir::ExprKind::Lit(..)\n             | hir::ExprKind::ConstBlock(..)\n+            | hir::ExprKind::OffsetOf(..)\n             | hir::ExprKind::Err(_) => {}\n \n             hir::ExprKind::Loop(blk, ..) => {"}, {"sha": "2b5af4bc81bfe688091104a6c9c92733ab26f137", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -420,9 +420,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ast_c: &hir::AnonConst,\n         param_def_id: DefId,\n     ) -> ty::Const<'tcx> {\n-        let const_def =\n-            ty::WithOptConstParam { did: ast_c.def_id, const_param_did: Some(param_def_id) };\n-        let c = ty::Const::from_opt_const_arg_anon_const(self.tcx, const_def);\n+        let did = ast_c.def_id;\n+        self.tcx.feed_anon_const_type(did, self.tcx.type_of(param_def_id));\n+        let c = ty::Const::from_anon_const(self.tcx, did);\n         self.register_wf_obligation(\n             c.into(),\n             self.tcx.hir().span(ast_c.hir_id),\n@@ -827,7 +827,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             QPath::TypeRelative(ref qself, ref segment) => {\n                 // Don't use `self.to_ty`, since this will register a WF obligation.\n-                // If we're trying to call a non-existent method on a trait\n+                // If we're trying to call a nonexistent method on a trait\n                 // (e.g. `MyTrait::missing_method`), then resolution will\n                 // give us a `QPath::TypeRelative` with a trait object as\n                 // `qself`. In that case, we want to avoid registering a WF obligation"}, {"sha": "56c94505727e8a40da64c215b6b56d60d4f4e6bb", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -164,24 +164,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 {\n                     for param in\n                         [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n+                            .into_iter()\n+                            .flatten()\n                     {\n-                        if let Some(param) = param {\n-                            let refined_expr = self.point_at_field_if_possible(\n-                                def_id,\n-                                param,\n-                                variant_def_id,\n-                                fields,\n-                            );\n-\n-                            match refined_expr {\n-                                None => {}\n-                                Some((refined_expr, _)) => {\n-                                    error.obligation.cause.span = refined_expr\n-                                        .span\n-                                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n-                                        .unwrap_or(refined_expr.span);\n-                                    return true;\n-                                }\n+                        let refined_expr =\n+                            self.point_at_field_if_possible(def_id, param, variant_def_id, fields);\n+\n+                        match refined_expr {\n+                            None => {}\n+                            Some((refined_expr, _)) => {\n+                                error.obligation.cause.span = refined_expr\n+                                    .span\n+                                    .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+                                    .unwrap_or(refined_expr.span);\n+                                return true;\n                             }\n                         }\n                     }\n@@ -334,7 +330,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// expression mentioned.\n     ///\n     /// `blame_specific_arg_if_possible` will find the most-specific expression anywhere inside\n-    /// the provided function call expression, and mark it as responsible for the fullfillment\n+    /// the provided function call expression, and mark it as responsible for the fulfillment\n     /// error.\n     fn blame_specific_arg_if_possible(\n         &self,"}, {"sha": "d45e3d395e43053d157cf7ad4e4f475da6c70790", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/arg_matrix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Farg_matrix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Farg_matrix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Farg_matrix.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,6 +1,6 @@\n use std::cmp;\n \n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_middle::ty::error::TypeError;\n \n rustc_index::newtype_index! {"}, {"sha": "f42c825d9e8b18030af7bd3afe53b4870816d5e3", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 18, "deletions": 38, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -2,8 +2,8 @@ use crate::coercion::CoerceMany;\n use crate::fn_ctxt::arg_matrix::{ArgMatrix, Compatibility, Error, ExpectedIdx, ProvidedIdx};\n use crate::gather_locals::Declaration;\n use crate::method::MethodCallee;\n-use crate::Expectation::*;\n use crate::TupleArgumentsFlag::*;\n+use crate::{errors, Expectation::*};\n use crate::{\n     struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, Needs, RawTy,\n     TupleArgumentsFlag,\n@@ -21,7 +21,7 @@ use rustc_hir_analysis::astconv::AstConv;\n use rustc_hir_analysis::check::intrinsicck::InlineAsmCtxt;\n use rustc_hir_analysis::check::potentially_plural_count;\n use rustc_hir_analysis::structured_errors::StructuredDiagnostic;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_infer::infer::error_reporting::{FailureCode, ObligationCauseExt};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::TypeTrace;\n@@ -283,19 +283,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if idx == 1 && !self.tcx.is_const_fn_raw(*def_id) {\n                         self.tcx\n                             .sess\n-                            .struct_span_err(provided_arg.span, \"this argument must be a `const fn`\")\n-                            .help(\"consult the documentation on `const_eval_select` for more information\")\n-                            .emit();\n+                            .emit_err(errors::ConstSelectMustBeConst { span: provided_arg.span });\n                     }\n                 } else {\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(provided_arg.span, \"this argument must be a function item\")\n-                        .note(format!(\"expected a function item, found {checked_ty}\"))\n-                        .help(\n-                            \"consult the documentation on `const_eval_select` for more information\",\n-                        )\n-                        .emit();\n+                    self.tcx.sess.emit_err(errors::ConstSelectMustBeFn {\n+                        span: provided_arg.span,\n+                        ty: checked_ty,\n+                    });\n                 }\n             }\n \n@@ -472,7 +466,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err_code: &str,\n         fn_def_id: Option<DefId>,\n         call_span: Span,\n-        call_expr: &hir::Expr<'tcx>,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n     ) {\n         // Next, let's construct the error\n         let (error_span, full_call_span, call_name, is_method) = match &call_expr.kind {\n@@ -744,17 +738,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if cfg!(debug_assertions) {\n                 span_bug!(error_span, \"expected errors from argument matrix\");\n             } else {\n-                tcx.sess\n-                    .struct_span_err(\n-                        error_span,\n-                        \"argument type mismatch was detected, \\\n-                        but rustc had trouble determining where\",\n-                    )\n-                    .note(\n-                        \"we would appreciate a bug report: \\\n-                        https://github.com/rust-lang/rust/issues/new\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(errors::ArgMismatchIndeterminate { span: error_span });\n             }\n             return;\n         }\n@@ -807,24 +791,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 full_call_span,\n                 format!(\"arguments to this {} are incorrect\", call_name),\n             );\n-            if let (Some(callee_ty), hir::ExprKind::MethodCall(_, rcvr, _, _)) =\n-                (callee_ty, &call_expr.kind)\n+\n+            if let hir::ExprKind::MethodCall(_, rcvr, _, _) = call_expr.kind\n+                && provided_idx.as_usize() == expected_idx.as_usize()\n             {\n-                // Type that would have accepted this argument if it hadn't been inferred earlier.\n-                // FIXME: We leave an inference variable for now, but it'd be nice to get a more\n-                // specific type to increase the accuracy of the diagnostic.\n-                let expected = self.infcx.next_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::MiscVariable,\n-                    span: full_call_span,\n-                });\n-                self.point_at_expr_source_of_inferred_type(\n+                self.note_source_of_type_mismatch_constraint(\n                     &mut err,\n                     rcvr,\n-                    expected,\n-                    callee_ty,\n-                    provided_arg_span,\n+                    crate::demand::TypeMismatchSource::Arg {\n+                        call_expr,\n+                        incompatible_arg: provided_idx.as_usize(),\n+                    },\n                 );\n             }\n+\n             // Call out where the function is defined\n             self.label_fn_like(\n                 &mut err,"}, {"sha": "73a7bbebb6581b7f62e1836dcfdc953ee5528543", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -17,7 +17,6 @@ use rustc_infer::infer;\n use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt, TypeVisitableExt};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n@@ -169,7 +168,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ocx.normalize(&ObligationCause::dummy(), self.param_env, fn_sig);\n                     if ocx.select_all_or_error().is_empty() {\n                         let normalized_fn_sig = self.resolve_vars_if_possible(normalized_fn_sig);\n-                        if !normalized_fn_sig.needs_infer() {\n+                        if !normalized_fn_sig.has_infer() {\n                             return normalized_fn_sig;\n                         }\n                     }\n@@ -250,16 +249,12 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n \n     fn ty_infer(&self, param: Option<&ty::GenericParamDef>, span: Span) -> Ty<'tcx> {\n-        if let Some(param) = param {\n-            if let GenericArgKind::Type(ty) = self.var_for_def(span, param).unpack() {\n-                return ty;\n-            }\n-            unreachable!()\n-        } else {\n-            self.next_ty_var(TypeVariableOrigin {\n+        match param {\n+            Some(param) => self.var_for_def(span, param).as_type().unwrap(),\n+            None => self.next_ty_var(TypeVariableOrigin {\n                 kind: TypeVariableOriginKind::TypeInference,\n                 span,\n-            })\n+            }),\n         }\n     }\n \n@@ -269,16 +264,12 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         param: Option<&ty::GenericParamDef>,\n         span: Span,\n     ) -> Const<'tcx> {\n-        if let Some(param) = param {\n-            if let GenericArgKind::Const(ct) = self.var_for_def(span, param).unpack() {\n-                return ct;\n-            }\n-            unreachable!()\n-        } else {\n-            self.next_const_var(\n+        match param {\n+            Some(param) => self.var_for_def(span, param).as_const().unwrap(),\n+            None => self.next_const_var(\n                 ty,\n                 ConstVariableOrigin { kind: ConstVariableOriginKind::ConstInference, span },\n-            )\n+            ),\n         }\n     }\n "}, {"sha": "82fc1256bba64ac901a74231adb4b31fd527976a", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -794,7 +794,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return;\n         };\n \n-        // get all where BoundPredicates here, because they are used in to cases below\n+        // get all where BoundPredicates here, because they are used in two cases below\n         let where_predicates = predicates\n             .iter()\n             .filter_map(|p| match p {\n@@ -1252,7 +1252,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 node: rustc_ast::LitKind::Int(lit, rustc_ast::LitIntType::Unsuffixed),\n                 span,\n             }) => {\n-                let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) else { return false; };\n+                let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(*span) else { return false; };\n                 if !(snippet.starts_with(\"0x\") || snippet.starts_with(\"0X\")) {\n                     return false;\n                 }\n@@ -1311,7 +1311,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // We have satisfied all requirements to provide a suggestion. Emit it.\n         err.span_suggestion(\n-            span,\n+            *span,\n             format!(\"if you meant to create a null pointer, use `{null_path_str}()`\"),\n             null_path_str + \"()\",\n             Applicability::MachineApplicable,\n@@ -1384,7 +1384,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         let item_ty = self.tcx.type_of(item.def_id).subst_identity();\n         // FIXME(compiler-errors): This check is *so* rudimentary\n-        if item_ty.needs_subst() {\n+        if item_ty.has_param() {\n             return false;\n         }\n         if self.can_coerce(item_ty, expected_ty) {"}, {"sha": "e4a62ec05aef1254a86e87629b2267ceb339828d", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -8,7 +8,7 @@ use hir::{\n };\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::{\n     hir::map::Map,\n@@ -215,6 +215,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n             | ExprKind::Continue(..)\n             | ExprKind::Ret(..)\n             | ExprKind::InlineAsm(..)\n+            | ExprKind::OffsetOf(..)\n             | ExprKind::Struct(..)\n             | ExprKind::Repeat(..)\n             | ExprKind::Yield(..)\n@@ -485,6 +486,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DropRangeVisitor<'a, 'tcx> {\n             | ExprKind::Field(..)\n             | ExprKind::Index(..)\n             | ExprKind::InlineAsm(..)\n+            | ExprKind::OffsetOf(..)\n             | ExprKind::Let(..)\n             | ExprKind::Lit(..)\n             | ExprKind::Path(..)"}, {"sha": "633b478895b10fae3dc8cd7468a7f9e08eb72617", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_propagate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -1,5 +1,5 @@\n use super::{DropRangesBuilder, PostOrderId};\n-use rustc_index::{bit_set::BitSet, vec::IndexVec};\n+use rustc_index::{bit_set::BitSet, IndexVec};\n use std::collections::BTreeMap;\n \n impl DropRangesBuilder {"}, {"sha": "cd3966a1214e744b336bcdd6cff7d6abad4b7da5", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -20,7 +20,7 @@ use hir::{Body, HirId, HirIdMap, Node};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::IndexVec;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n use rustc_middle::ty;\n@@ -268,8 +268,7 @@ impl DropRangesBuilder {\n \n     fn node_mut(&mut self, id: PostOrderId) -> &mut NodeInfo {\n         let size = self.num_values();\n-        self.nodes.ensure_contains_elem(id, || NodeInfo::new(size));\n-        &mut self.nodes[id]\n+        self.nodes.ensure_contains_elem(id, || NodeInfo::new(size))\n     }\n \n     fn add_control_edge(&mut self, from: PostOrderId, to: PostOrderId) {"}, {"sha": "5136d895f22686c06176b822177441c066ed05d6", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -202,7 +202,7 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n         // If the type being assigned needs dropped, then the mutation counts as a borrow\n         // since it is essentially doing `Drop::drop(&mut x); x = new_value;`.\n         let ty = self.tcx.erase_regions(assignee_place.place.base_ty);\n-        if ty.needs_infer() {\n+        if ty.has_infer() {\n             self.tcx.sess.delay_span_bug(\n                 self.tcx.hir().span(assignee_place.hir_id),\n                 &format!(\"inference variables in {ty}\"),"}, {"sha": "915280a5bea022db041a18aac4821d5f65fd43d9", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/697d13084476d8058423b226578a58a8c7d5c86a/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=697d13084476d8058423b226578a58a8c7d5c86a", "patch": "@@ -460,7 +460,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                 // Avoid ICEs in needs_drop.\n                 let ty = self.fcx.resolve_vars_if_possible(ty);\n                 let ty = self.fcx.tcx.erase_regions(ty);\n-                if ty.needs_infer() {\n+                if ty.has_infer() {\n                     self.fcx\n                         .tcx\n                         .sess\n@@ -571,7 +571,7 @@ fn check_must_not_suspend_ty<'tcx>(\n         // FIXME: support adding the attribute to TAITs\n         ty::Alias(ty::Opaque, ty::AliasTy { def_id: def, .. }) => {\n             let mut has_emitted = false;\n-            for &(predicate, _) in fcx.tcx.explicit_item_bounds(def) {\n+            for &(predicate, _) in fcx.tcx.explicit_item_bounds(def).skip_binder() {\n                 // We only look at the `DefId`, so it is safe to skip the binder here.\n                 if let ty::PredicateKind::Clause(ty::Clause::Trait(ref poly_trait_predicate)) =\n                     predicate.kind().skip_binder()\n@@ -650,7 +650,7 @@ fn check_must_not_suspend_ty<'tcx>(\n                 },\n             )\n         }\n-        // If drop tracking is enabled, we want to look through references, since the referrent\n+        // If drop tracking is enabled, we want to look through references, since the referent\n         // may not be considered live across the await point.\n         ty::Ref(_region, ty, _mutability) if fcx.sess().opts.unstable_opts.drop_tracking => {\n             let descr_pre = &format!(\"{}reference{} to \", data.descr_pre, plural_suffix);"}]}