{"sha": "3e018ce194ab16125747220676dd8a20aecd5196", "node_id": "C_kwDOAAsO6NoAKDNlMDE4Y2UxOTRhYjE2MTI1NzQ3MjIwNjc2ZGQ4YTIwYWVjZDUxOTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-13T08:22:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-13T08:22:52Z"}, "message": "Auto merge of #87264 - mystor:expand_literal, r=petrochenkov\n\nproc_macro: Add an expand_expr method to TokenStream\n\nThis feature is aimed at giving proc macros access to powers similar to those used by builtin macros such as `format_args!` or `concat!`. These macros are able to accept macros in place of string literal parameters, such as the format string, as they perform recursive macro expansion while being expanded.\n\nThis can be especially useful in many cases thanks to helper macros like `concat!`, `stringify!` and `include_str!` which are often used to construct string literals at compile-time in user code.\n\nFor now, this method only allows expanding macros which produce literals, although more expressions will be supported before the method is stabilized.\n\nIn earlier versions of this PR, this method exclusively returned `Literal`, and spans on returned literals were stripped of expansion context before being returned to be as conservative as possible about permission leakage. The method's naming has been generalized to eventually support arbitrary expressions, and the context stripping has been removed (https://github.com/rust-lang/rust/pull/87264#discussion_r674863279), which should allow for more general APIs like \"format_args_implicits\" (https://github.com/rust-lang/rust/issues/67984) to be supported as well.\n\n## API Surface\n\n```rust\nimpl TokenStream {\n    pub fn expand_expr(&self) -> Result<TokenStream, ExpandError>;\n}\n\n#[non_exhaustive]\npub struct ExpandError;\n\nimpl Debug for ExpandError { ... }\nimpl Display for ExpandError { ... }\nimpl Error for ExpandError {}\nimpl !Send for ExpandError {}\nimpl !Sync for ExpandError {}\n```", "tree": {"sha": "5f2d831fe3033b39ba5df1757ff76fadc4e7d8ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f2d831fe3033b39ba5df1757ff76fadc4e7d8ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e018ce194ab16125747220676dd8a20aecd5196", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e018ce194ab16125747220676dd8a20aecd5196", "html_url": "https://github.com/rust-lang/rust/commit/3e018ce194ab16125747220676dd8a20aecd5196", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e018ce194ab16125747220676dd8a20aecd5196/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7594067b69eac2395f7b3b42d519a559dae2d9d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7594067b69eac2395f7b3b42d519a559dae2d9d9", "html_url": "https://github.com/rust-lang/rust/commit/7594067b69eac2395f7b3b42d519a559dae2d9d9"}, {"sha": "3e4d3d2a295d87b2d7ac45a06a727605e8ea21db", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e4d3d2a295d87b2d7ac45a06a727605e8ea21db", "html_url": "https://github.com/rust-lang/rust/commit/3e4d3d2a295d87b2d7ac45a06a727605e8ea21db"}], "stats": {"total": 496, "additions": 421, "deletions": 75}, "files": [{"sha": "42c17a60a5d4e1b25e73bb5cf043c49bb72cea6b", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3e018ce194ab16125747220676dd8a20aecd5196/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e018ce194ab16125747220676dd8a20aecd5196/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=3e018ce194ab16125747220676dd8a20aecd5196", "patch": "@@ -24,8 +24,9 @@ impl base::ProcMacro for BangProcMacro {\n         span: Span,\n         input: TokenStream,\n     ) -> Result<TokenStream, ErrorReported> {\n+        let proc_macro_backtrace = ecx.ecfg.proc_macro_backtrace;\n         let server = proc_macro_server::Rustc::new(ecx);\n-        self.client.run(&EXEC_STRATEGY, server, input, ecx.ecfg.proc_macro_backtrace).map_err(|e| {\n+        self.client.run(&EXEC_STRATEGY, server, input, proc_macro_backtrace).map_err(|e| {\n             let mut err = ecx.struct_span_err(span, \"proc macro panicked\");\n             if let Some(s) = e.as_str() {\n                 err.help(&format!(\"message: {}\", s));\n@@ -48,9 +49,10 @@ impl base::AttrProcMacro for AttrProcMacro {\n         annotation: TokenStream,\n         annotated: TokenStream,\n     ) -> Result<TokenStream, ErrorReported> {\n+        let proc_macro_backtrace = ecx.ecfg.proc_macro_backtrace;\n         let server = proc_macro_server::Rustc::new(ecx);\n         self.client\n-            .run(&EXEC_STRATEGY, server, annotation, annotated, ecx.ecfg.proc_macro_backtrace)\n+            .run(&EXEC_STRATEGY, server, annotation, annotated, proc_macro_backtrace)\n             .map_err(|e| {\n                 let mut err = ecx.struct_span_err(span, \"custom attribute panicked\");\n                 if let Some(s) = e.as_str() {\n@@ -97,19 +99,19 @@ impl MultiItemModifier for ProcMacroDerive {\n             nt_to_tokenstream(&item, &ecx.sess.parse_sess, CanSynthesizeMissingTokens::No)\n         };\n \n+        let proc_macro_backtrace = ecx.ecfg.proc_macro_backtrace;\n         let server = proc_macro_server::Rustc::new(ecx);\n-        let stream =\n-            match self.client.run(&EXEC_STRATEGY, server, input, ecx.ecfg.proc_macro_backtrace) {\n-                Ok(stream) => stream,\n-                Err(e) => {\n-                    let mut err = ecx.struct_span_err(span, \"proc-macro derive panicked\");\n-                    if let Some(s) = e.as_str() {\n-                        err.help(&format!(\"message: {}\", s));\n-                    }\n-                    err.emit();\n-                    return ExpandResult::Ready(vec![]);\n+        let stream = match self.client.run(&EXEC_STRATEGY, server, input, proc_macro_backtrace) {\n+            Ok(stream) => stream,\n+            Err(e) => {\n+                let mut err = ecx.struct_span_err(span, \"proc-macro derive panicked\");\n+                if let Some(s) = e.as_str() {\n+                    err.help(&format!(\"message: {}\", s));\n                 }\n-            };\n+                err.emit();\n+                return ExpandResult::Ready(vec![]);\n+            }\n+        };\n \n         let error_count_before = ecx.sess.parse_sess.span_diagnostic.err_count();\n         let mut parser ="}, {"sha": "fa9e98be9e881f6b0c1bdd51aa4dae4e784a2319", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 107, "deletions": 55, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/3e018ce194ab16125747220676dd8a20aecd5196/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e018ce194ab16125747220676dd8a20aecd5196/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=3e018ce194ab16125747220676dd8a20aecd5196", "patch": "@@ -1,4 +1,4 @@\n-use crate::base::{ExtCtxt, ResolverExpand};\n+use crate::base::ExtCtxt;\n \n use rustc_ast as ast;\n use rustc_ast::token::{self, Nonterminal, NtIdent};\n@@ -7,7 +7,7 @@ use rustc_ast::tokenstream::{DelimSpan, Spacing::*, TokenStream, TreeAndSpacing}\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::Diagnostic;\n+use rustc_errors::{Diagnostic, PResult};\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n use rustc_lint_defs::BuiltinLintDiagnostics;\n use rustc_parse::lexer::nfc_normalize;\n@@ -53,11 +53,11 @@ impl ToInternal<token::DelimToken> for Delimiter {\n     }\n }\n \n-impl FromInternal<(TreeAndSpacing, &'_ mut Vec<Self>, &mut Rustc<'_>)>\n+impl FromInternal<(TreeAndSpacing, &'_ mut Vec<Self>, &mut Rustc<'_, '_>)>\n     for TokenTree<Group, Punct, Ident, Literal>\n {\n     fn from_internal(\n-        ((tree, spacing), stack, rustc): (TreeAndSpacing, &mut Vec<Self>, &mut Rustc<'_>),\n+        ((tree, spacing), stack, rustc): (TreeAndSpacing, &mut Vec<Self>, &mut Rustc<'_, '_>),\n     ) -> Self {\n         use rustc_ast::token::*;\n \n@@ -146,10 +146,10 @@ impl FromInternal<(TreeAndSpacing, &'_ mut Vec<Self>, &mut Rustc<'_>)>\n             SingleQuote => op!('\\''),\n \n             Ident(name, false) if name == kw::DollarCrate => tt!(Ident::dollar_crate()),\n-            Ident(name, is_raw) => tt!(Ident::new(rustc.sess, name, is_raw)),\n+            Ident(name, is_raw) => tt!(Ident::new(rustc.sess(), name, is_raw)),\n             Lifetime(name) => {\n                 let ident = symbol::Ident::new(name, span).without_first_quote();\n-                stack.push(tt!(Ident::new(rustc.sess, ident.name, false)));\n+                stack.push(tt!(Ident::new(rustc.sess(), ident.name, false)));\n                 tt!(Punct::new('\\'', true))\n             }\n             Literal(lit) => tt!(Literal { lit }),\n@@ -181,15 +181,15 @@ impl FromInternal<(TreeAndSpacing, &'_ mut Vec<Self>, &mut Rustc<'_>)>\n             Interpolated(nt)\n                 if let Some((name, is_raw)) = ident_name_compatibility_hack(&nt, span, rustc) =>\n             {\n-                TokenTree::Ident(Ident::new(rustc.sess, name.name, is_raw, name.span))\n+                TokenTree::Ident(Ident::new(rustc.sess(), name.name, is_raw, name.span))\n             }\n             Interpolated(nt) => {\n-                let stream = nt_to_tokenstream(&nt, rustc.sess, CanSynthesizeMissingTokens::No);\n+                let stream = nt_to_tokenstream(&nt, rustc.sess(), CanSynthesizeMissingTokens::No);\n                 TokenTree::Group(Group {\n                     delimiter: Delimiter::None,\n                     stream,\n                     span: DelimSpan::from_single(span),\n-                    flatten: crate::base::pretty_printing_compatibility_hack(&nt, rustc.sess),\n+                    flatten: crate::base::pretty_printing_compatibility_hack(&nt, rustc.sess()),\n                 })\n             }\n \n@@ -355,38 +355,38 @@ pub struct Literal {\n     span: Span,\n }\n \n-pub(crate) struct Rustc<'a> {\n-    resolver: &'a dyn ResolverExpand,\n-    sess: &'a ParseSess,\n+pub(crate) struct Rustc<'a, 'b> {\n+    ecx: &'a mut ExtCtxt<'b>,\n     def_site: Span,\n     call_site: Span,\n     mixed_site: Span,\n-    span_debug: bool,\n     krate: CrateNum,\n     rebased_spans: FxHashMap<usize, Span>,\n }\n \n-impl<'a> Rustc<'a> {\n-    pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n-        let expn_data = cx.current_expansion.id.expn_data();\n+impl<'a, 'b> Rustc<'a, 'b> {\n+    pub fn new(ecx: &'a mut ExtCtxt<'b>) -> Self {\n+        let expn_data = ecx.current_expansion.id.expn_data();\n         Rustc {\n-            resolver: cx.resolver,\n-            sess: cx.parse_sess(),\n-            def_site: cx.with_def_site_ctxt(expn_data.def_site),\n-            call_site: cx.with_call_site_ctxt(expn_data.call_site),\n-            mixed_site: cx.with_mixed_site_ctxt(expn_data.call_site),\n-            span_debug: cx.ecfg.span_debug,\n+            def_site: ecx.with_def_site_ctxt(expn_data.def_site),\n+            call_site: ecx.with_call_site_ctxt(expn_data.call_site),\n+            mixed_site: ecx.with_mixed_site_ctxt(expn_data.call_site),\n             krate: expn_data.macro_def_id.unwrap().krate,\n             rebased_spans: FxHashMap::default(),\n+            ecx,\n         }\n     }\n \n+    fn sess(&self) -> &ParseSess {\n+        self.ecx.parse_sess()\n+    }\n+\n     fn lit(&mut self, kind: token::LitKind, symbol: Symbol, suffix: Option<Symbol>) -> Literal {\n         Literal { lit: token::Lit::new(kind, symbol, suffix), span: server::Span::call_site(self) }\n     }\n }\n \n-impl server::Types for Rustc<'_> {\n+impl server::Types for Rustc<'_, '_> {\n     type FreeFunctions = FreeFunctions;\n     type TokenStream = TokenStream;\n     type TokenStreamBuilder = tokenstream::TokenStreamBuilder;\n@@ -401,17 +401,20 @@ impl server::Types for Rustc<'_> {\n     type Span = Span;\n }\n \n-impl server::FreeFunctions for Rustc<'_> {\n+impl server::FreeFunctions for Rustc<'_, '_> {\n     fn track_env_var(&mut self, var: &str, value: Option<&str>) {\n-        self.sess.env_depinfo.borrow_mut().insert((Symbol::intern(var), value.map(Symbol::intern)));\n+        self.sess()\n+            .env_depinfo\n+            .borrow_mut()\n+            .insert((Symbol::intern(var), value.map(Symbol::intern)));\n     }\n \n     fn track_path(&mut self, path: &str) {\n-        self.sess.file_depinfo.borrow_mut().insert(Symbol::intern(path));\n+        self.sess().file_depinfo.borrow_mut().insert(Symbol::intern(path));\n     }\n }\n \n-impl server::TokenStream for Rustc<'_> {\n+impl server::TokenStream for Rustc<'_, '_> {\n     fn new(&mut self) -> Self::TokenStream {\n         TokenStream::default()\n     }\n@@ -422,13 +425,62 @@ impl server::TokenStream for Rustc<'_> {\n         parse_stream_from_source_str(\n             FileName::proc_macro_source_code(src),\n             src.to_string(),\n-            self.sess,\n+            self.sess(),\n             Some(self.call_site),\n         )\n     }\n     fn to_string(&mut self, stream: &Self::TokenStream) -> String {\n         pprust::tts_to_string(stream)\n     }\n+    fn expand_expr(&mut self, stream: &Self::TokenStream) -> Result<Self::TokenStream, ()> {\n+        // Parse the expression from our tokenstream.\n+        let expr: PResult<'_, _> = try {\n+            let mut p = rustc_parse::stream_to_parser(\n+                self.sess(),\n+                stream.clone(),\n+                Some(\"proc_macro expand expr\"),\n+            );\n+            let expr = p.parse_expr()?;\n+            if p.token != token::Eof {\n+                p.unexpected()?;\n+            }\n+            expr\n+        };\n+        let expr = expr.map_err(|mut err| err.emit())?;\n+\n+        // Perform eager expansion on the expression.\n+        let expr = self\n+            .ecx\n+            .expander()\n+            .fully_expand_fragment(crate::expand::AstFragment::Expr(expr))\n+            .make_expr();\n+\n+        // NOTE: For now, limit `expand_expr` to exclusively expand to literals.\n+        // This may be relaxed in the future.\n+        // We don't use `nt_to_tokenstream` as the tokenstream currently cannot\n+        // be recovered in the general case.\n+        match &expr.kind {\n+            ast::ExprKind::Lit(l) => {\n+                Ok(tokenstream::TokenTree::token(token::Literal(l.token), l.span).into())\n+            }\n+            ast::ExprKind::Unary(ast::UnOp::Neg, e) => match &e.kind {\n+                ast::ExprKind::Lit(l) => match l.token {\n+                    token::Lit { kind: token::Integer | token::Float, .. } => {\n+                        Ok(std::array::IntoIter::new([\n+                            // FIXME: The span of the `-` token is lost when\n+                            // parsing, so we cannot faithfully recover it here.\n+                            tokenstream::TokenTree::token(token::BinOp(token::Minus), e.span),\n+                            tokenstream::TokenTree::token(token::Literal(l.token), l.span),\n+                        ])\n+                        .collect())\n+                    }\n+                    _ => Err(()),\n+                },\n+                _ => Err(()),\n+            },\n+            _ => Err(()),\n+        }\n+    }\n     fn from_token_tree(\n         &mut self,\n         tree: TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>,\n@@ -440,7 +492,7 @@ impl server::TokenStream for Rustc<'_> {\n     }\n }\n \n-impl server::TokenStreamBuilder for Rustc<'_> {\n+impl server::TokenStreamBuilder for Rustc<'_, '_> {\n     fn new(&mut self) -> Self::TokenStreamBuilder {\n         tokenstream::TokenStreamBuilder::new()\n     }\n@@ -452,7 +504,7 @@ impl server::TokenStreamBuilder for Rustc<'_> {\n     }\n }\n \n-impl server::TokenStreamIter for Rustc<'_> {\n+impl server::TokenStreamIter for Rustc<'_, '_> {\n     fn next(\n         &mut self,\n         iter: &mut Self::TokenStreamIter,\n@@ -477,7 +529,7 @@ impl server::TokenStreamIter for Rustc<'_> {\n     }\n }\n \n-impl server::Group for Rustc<'_> {\n+impl server::Group for Rustc<'_, '_> {\n     fn new(&mut self, delimiter: Delimiter, stream: Self::TokenStream) -> Self::Group {\n         Group {\n             delimiter,\n@@ -506,7 +558,7 @@ impl server::Group for Rustc<'_> {\n     }\n }\n \n-impl server::Punct for Rustc<'_> {\n+impl server::Punct for Rustc<'_, '_> {\n     fn new(&mut self, ch: char, spacing: Spacing) -> Self::Punct {\n         Punct::new(ch, spacing == Spacing::Joint, server::Span::call_site(self))\n     }\n@@ -524,9 +576,9 @@ impl server::Punct for Rustc<'_> {\n     }\n }\n \n-impl server::Ident for Rustc<'_> {\n+impl server::Ident for Rustc<'_, '_> {\n     fn new(&mut self, string: &str, span: Self::Span, is_raw: bool) -> Self::Ident {\n-        Ident::new(self.sess, Symbol::intern(string), is_raw, span)\n+        Ident::new(self.sess(), Symbol::intern(string), is_raw, span)\n     }\n     fn span(&mut self, ident: Self::Ident) -> Self::Span {\n         ident.span\n@@ -536,10 +588,10 @@ impl server::Ident for Rustc<'_> {\n     }\n }\n \n-impl server::Literal for Rustc<'_> {\n+impl server::Literal for Rustc<'_, '_> {\n     fn from_str(&mut self, s: &str) -> Result<Self::Literal, ()> {\n         let name = FileName::proc_macro_source_code(s);\n-        let mut parser = rustc_parse::new_parser_from_source_str(self.sess, name, s.to_owned());\n+        let mut parser = rustc_parse::new_parser_from_source_str(self.sess(), name, s.to_owned());\n \n         let first_span = parser.token.span.data();\n         let minus_present = parser.eat(&token::BinOp(token::Minus));\n@@ -675,7 +727,7 @@ impl server::Literal for Rustc<'_> {\n     }\n }\n \n-impl server::SourceFile for Rustc<'_> {\n+impl server::SourceFile for Rustc<'_, '_> {\n     fn eq(&mut self, file1: &Self::SourceFile, file2: &Self::SourceFile) -> bool {\n         Lrc::ptr_eq(file1, file2)\n     }\n@@ -695,7 +747,7 @@ impl server::SourceFile for Rustc<'_> {\n     }\n }\n \n-impl server::MultiSpan for Rustc<'_> {\n+impl server::MultiSpan for Rustc<'_, '_> {\n     fn new(&mut self) -> Self::MultiSpan {\n         vec![]\n     }\n@@ -704,7 +756,7 @@ impl server::MultiSpan for Rustc<'_> {\n     }\n }\n \n-impl server::Diagnostic for Rustc<'_> {\n+impl server::Diagnostic for Rustc<'_, '_> {\n     fn new(&mut self, level: Level, msg: &str, spans: Self::MultiSpan) -> Self::Diagnostic {\n         let mut diag = Diagnostic::new(level.to_internal(), msg);\n         diag.set_span(MultiSpan::from_spans(spans));\n@@ -720,13 +772,13 @@ impl server::Diagnostic for Rustc<'_> {\n         diag.sub(level.to_internal(), msg, MultiSpan::from_spans(spans), None);\n     }\n     fn emit(&mut self, diag: Self::Diagnostic) {\n-        self.sess.span_diagnostic.emit_diagnostic(&diag);\n+        self.sess().span_diagnostic.emit_diagnostic(&diag);\n     }\n }\n \n-impl server::Span for Rustc<'_> {\n+impl server::Span for Rustc<'_, '_> {\n     fn debug(&mut self, span: Self::Span) -> String {\n-        if self.span_debug {\n+        if self.ecx.ecfg.span_debug {\n             format!(\"{:?}\", span)\n         } else {\n             format!(\"{:?} bytes({}..{})\", span.ctxt(), span.lo().0, span.hi().0)\n@@ -742,7 +794,7 @@ impl server::Span for Rustc<'_> {\n         self.mixed_site\n     }\n     fn source_file(&mut self, span: Self::Span) -> Self::SourceFile {\n-        self.sess.source_map().lookup_char_pos(span.lo()).file\n+        self.sess().source_map().lookup_char_pos(span.lo()).file\n     }\n     fn parent(&mut self, span: Self::Span) -> Option<Self::Span> {\n         span.parent_callsite()\n@@ -751,11 +803,11 @@ impl server::Span for Rustc<'_> {\n         span.source_callsite()\n     }\n     fn start(&mut self, span: Self::Span) -> LineColumn {\n-        let loc = self.sess.source_map().lookup_char_pos(span.lo());\n+        let loc = self.sess().source_map().lookup_char_pos(span.lo());\n         LineColumn { line: loc.line, column: loc.col.to_usize() }\n     }\n     fn end(&mut self, span: Self::Span) -> LineColumn {\n-        let loc = self.sess.source_map().lookup_char_pos(span.hi());\n+        let loc = self.sess().source_map().lookup_char_pos(span.hi());\n         LineColumn { line: loc.line, column: loc.col.to_usize() }\n     }\n     fn before(&mut self, span: Self::Span) -> Self::Span {\n@@ -765,8 +817,8 @@ impl server::Span for Rustc<'_> {\n         span.shrink_to_hi()\n     }\n     fn join(&mut self, first: Self::Span, second: Self::Span) -> Option<Self::Span> {\n-        let self_loc = self.sess.source_map().lookup_char_pos(first.lo());\n-        let other_loc = self.sess.source_map().lookup_char_pos(second.lo());\n+        let self_loc = self.sess().source_map().lookup_char_pos(first.lo());\n+        let other_loc = self.sess().source_map().lookup_char_pos(second.lo());\n \n         if self_loc.file.name != other_loc.file.name {\n             return None;\n@@ -778,7 +830,7 @@ impl server::Span for Rustc<'_> {\n         span.with_ctxt(at.ctxt())\n     }\n     fn source_text(&mut self, span: Self::Span) -> Option<String> {\n-        self.sess.source_map().span_to_snippet(span).ok()\n+        self.sess().source_map().span_to_snippet(span).ok()\n     }\n     /// Saves the provided span into the metadata of\n     /// *the crate we are currently compiling*, which must\n@@ -805,10 +857,10 @@ impl server::Span for Rustc<'_> {\n     /// since we've loaded `my_proc_macro` from disk in order to execute it).\n     /// In this way, we have obtained a span pointing into `my_proc_macro`\n     fn save_span(&mut self, span: Self::Span) -> usize {\n-        self.sess.save_proc_macro_span(span)\n+        self.sess().save_proc_macro_span(span)\n     }\n     fn recover_proc_macro_span(&mut self, id: usize) -> Self::Span {\n-        let (resolver, krate, def_site) = (self.resolver, self.krate, self.def_site);\n+        let (resolver, krate, def_site) = (&*self.ecx.resolver, self.krate, self.def_site);\n         *self.rebased_spans.entry(id).or_insert_with(|| {\n             // FIXME: `SyntaxContext` for spans from proc macro crates is lost during encoding,\n             // replace it with a def-site context until we are encoding it properly.\n@@ -821,11 +873,11 @@ impl server::Span for Rustc<'_> {\n fn ident_name_compatibility_hack(\n     nt: &Nonterminal,\n     orig_span: Span,\n-    rustc: &mut Rustc<'_>,\n+    rustc: &mut Rustc<'_, '_>,\n ) -> Option<(rustc_span::symbol::Ident, bool)> {\n     if let NtIdent(ident, is_raw) = nt {\n         if let ExpnKind::Macro(_, macro_name) = orig_span.ctxt().outer_expn_data().kind {\n-            let source_map = rustc.sess.source_map();\n+            let source_map = rustc.sess().source_map();\n             let filename = source_map.span_to_filename(orig_span);\n             if let FileName::Real(RealFileName::LocalPath(path)) = filename {\n                 let matches_prefix = |prefix, filename| {\n@@ -846,7 +898,7 @@ fn ident_name_compatibility_hack(\n                     let snippet = source_map.span_to_snippet(orig_span);\n                     if snippet.as_deref() == Ok(\"$name\") {\n                         if time_macros_impl {\n-                            rustc.sess.buffer_lint_with_diagnostic(\n+                            rustc.sess().buffer_lint_with_diagnostic(\n                                 &PROC_MACRO_BACK_COMPAT,\n                                 orig_span,\n                                 ast::CRATE_NODE_ID,\n@@ -871,7 +923,7 @@ fn ident_name_compatibility_hack(\n                                         .and_then(|c| c.parse::<u32>().ok())\n                                         .map_or(false, |v| v < 40)\n                                 {\n-                                    rustc.sess.buffer_lint_with_diagnostic(\n+                                    rustc.sess().buffer_lint_with_diagnostic(\n                                         &PROC_MACRO_BACK_COMPAT,\n                                         orig_span,\n                                         ast::CRATE_NODE_ID,\n@@ -894,7 +946,7 @@ fn ident_name_compatibility_hack(\n                             source_map.span_to_filename(rustc.def_site)\n                         {\n                             if macro_path.to_string_lossy().contains(\"pin-project-internal-0.\") {\n-                                rustc.sess.buffer_lint_with_diagnostic(\n+                                rustc.sess().buffer_lint_with_diagnostic(\n                                     &PROC_MACRO_BACK_COMPAT,\n                                     orig_span,\n                                     ast::CRATE_NODE_ID,"}, {"sha": "2df287f7d93007f6546677246651401be51c33a2", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e018ce194ab16125747220676dd8a20aecd5196/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e018ce194ab16125747220676dd8a20aecd5196/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=3e018ce194ab16125747220676dd8a20aecd5196", "patch": "@@ -62,6 +62,7 @@ macro_rules! with_api {\n                 fn clone($self: &$S::TokenStream) -> $S::TokenStream;\n                 fn new() -> $S::TokenStream;\n                 fn is_empty($self: &$S::TokenStream) -> bool;\n+                fn expand_expr($self: &$S::TokenStream) -> Result<$S::TokenStream, ()>;\n                 fn from_str(src: &str) -> $S::TokenStream;\n                 fn to_string($self: &$S::TokenStream) -> String;\n                 fn from_token_tree("}, {"sha": "ef96d72a38b54728f46f66f297dbf812b3746b04", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3e018ce194ab16125747220676dd8a20aecd5196/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e018ce194ab16125747220676dd8a20aecd5196/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=3e018ce194ab16125747220676dd8a20aecd5196", "patch": "@@ -88,12 +88,6 @@ impl !Sync for TokenStream {}\n #[derive(Debug)]\n pub struct LexError;\n \n-impl LexError {\n-    fn new() -> Self {\n-        LexError\n-    }\n-}\n-\n #[stable(feature = \"proc_macro_lexerror_impls\", since = \"1.44.0\")]\n impl fmt::Display for LexError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -109,6 +103,28 @@ impl !Send for LexError {}\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl !Sync for LexError {}\n \n+/// Error returned from `TokenStream::expand_expr`.\n+#[unstable(feature = \"proc_macro_expand\", issue = \"90765\")]\n+#[non_exhaustive]\n+#[derive(Debug)]\n+pub struct ExpandError;\n+\n+#[unstable(feature = \"proc_macro_expand\", issue = \"90765\")]\n+impl fmt::Display for ExpandError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(\"macro expansion failed\")\n+    }\n+}\n+\n+#[unstable(feature = \"proc_macro_expand\", issue = \"90765\")]\n+impl error::Error for ExpandError {}\n+\n+#[unstable(feature = \"proc_macro_expand\", issue = \"90765\")]\n+impl !Send for ExpandError {}\n+\n+#[unstable(feature = \"proc_macro_expand\", issue = \"90765\")]\n+impl !Sync for ExpandError {}\n+\n impl TokenStream {\n     /// Returns an empty `TokenStream` containing no token trees.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n@@ -121,6 +137,24 @@ impl TokenStream {\n     pub fn is_empty(&self) -> bool {\n         self.0.is_empty()\n     }\n+\n+    /// Parses this `TokenStream` as an expression and attempts to expand any\n+    /// macros within it. Returns the expanded `TokenStream`.\n+    ///\n+    /// Currently only expressions expanding to literals will succeed, although\n+    /// this may be relaxed in the future.\n+    ///\n+    /// NOTE: In error conditions, `expand_expr` may leave macros unexpanded,\n+    /// report an error, failing compilation, and/or return an `Err(..)`. The\n+    /// specific behavior for any error condition, and what conditions are\n+    /// considered errors, is unspecified and may change in the future.\n+    #[unstable(feature = \"proc_macro_expand\", issue = \"90765\")]\n+    pub fn expand_expr(&self) -> Result<TokenStream, ExpandError> {\n+        match bridge::client::TokenStream::expand_expr(&self.0) {\n+            Ok(stream) => Ok(TokenStream(stream)),\n+            Err(_) => Err(ExpandError),\n+        }\n+    }\n }\n \n /// Attempts to break the string into tokens and parse those tokens into a token stream.\n@@ -1211,7 +1245,7 @@ impl FromStr for Literal {\n     fn from_str(src: &str) -> Result<Self, LexError> {\n         match bridge::client::Literal::from_str(src) {\n             Ok(literal) => Ok(Literal(literal)),\n-            Err(()) => Err(LexError::new()),\n+            Err(()) => Err(LexError),\n         }\n     }\n }"}, {"sha": "2bc34f3c6bfc072a427d6041e3249ce4faa41117", "filename": "src/test/ui/proc-macro/auxiliary/expand-expr.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/3e018ce194ab16125747220676dd8a20aecd5196/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e018ce194ab16125747220676dd8a20aecd5196/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-expr.rs?ref=3e018ce194ab16125747220676dd8a20aecd5196", "patch": "@@ -0,0 +1,80 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![deny(warnings)]\n+#![feature(proc_macro_expand, proc_macro_span)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::*;\n+use std::str::FromStr;\n+\n+#[proc_macro]\n+pub fn expand_expr_is(input: TokenStream) -> TokenStream {\n+    let mut iter = input.into_iter();\n+    let mut expected_tts = Vec::new();\n+    loop {\n+        match iter.next() {\n+            Some(TokenTree::Punct(ref p)) if p.as_char() == ',' => break,\n+            Some(tt) => expected_tts.push(tt),\n+            None => panic!(\"expected comma\"),\n+        }\n+    }\n+\n+    let expected = expected_tts.into_iter().collect::<TokenStream>();\n+    let expanded = iter.collect::<TokenStream>().expand_expr().expect(\"expand_expr failed\");\n+    assert!(\n+        expected.to_string() == expanded.to_string(),\n+        \"assert failed\\nexpected: `{}`\\nexpanded: `{}`\",\n+        expected.to_string(),\n+        expanded.to_string()\n+    );\n+\n+    TokenStream::new()\n+}\n+\n+#[proc_macro]\n+pub fn expand_expr_fail(input: TokenStream) -> TokenStream {\n+    match input.expand_expr() {\n+        Ok(ts) => panic!(\"expand_expr unexpectedly succeeded: `{}`\", ts),\n+        Err(_) => TokenStream::new(),\n+    }\n+}\n+\n+#[proc_macro]\n+pub fn check_expand_expr_file(ts: TokenStream) -> TokenStream {\n+    // Check that the passed in `file!()` invocation and a parsed `file!`\n+    // invocation expand to the same literal.\n+    let input_t = ts.expand_expr().expect(\"expand_expr failed on macro input\").to_string();\n+    let parse_t = TokenStream::from_str(\"file!{}\")\n+    .unwrap()\n+        .expand_expr()\n+        .expect(\"expand_expr failed on internal macro\")\n+        .to_string();\n+    assert_eq!(input_t, parse_t);\n+\n+    // Check that the literal matches `Span::call_site().source_file().path()`\n+    let expect_t =\n+        Literal::string(&Span::call_site().source_file().path().to_string_lossy()).to_string();\n+    assert_eq!(input_t, expect_t);\n+\n+    TokenStream::new()\n+}\n+\n+#[proc_macro]\n+pub fn recursive_expand(_: TokenStream) -> TokenStream {\n+    // Recursively call until we hit the recursion limit and get an error.\n+    //\n+    // NOTE: This doesn't panic if expansion fails because that'll cause a very\n+    // large number of errors to fill the output.\n+    TokenStream::from_str(\"recursive_expand!{}\")\n+        .unwrap()\n+        .expand_expr()\n+        .unwrap_or(std::iter::once(TokenTree::Literal(Literal::u32_suffixed(0))).collect())\n+}\n+\n+#[proc_macro]\n+pub fn echo_pm(input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "b4720047d6cff5f5d08f59820c5551498dfd3026", "filename": "src/test/ui/proc-macro/auxiliary/included-file.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e018ce194ab16125747220676dd8a20aecd5196/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fincluded-file.txt", "raw_url": "https://github.com/rust-lang/rust/raw/3e018ce194ab16125747220676dd8a20aecd5196/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fincluded-file.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fincluded-file.txt?ref=3e018ce194ab16125747220676dd8a20aecd5196", "patch": "@@ -0,0 +1 @@\n+Included file contents"}, {"sha": "d1146d970306264b1485cfc6f243bd51134a62f4", "filename": "src/test/ui/proc-macro/expand-expr.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/3e018ce194ab16125747220676dd8a20aecd5196/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e018ce194ab16125747220676dd8a20aecd5196/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.rs?ref=3e018ce194ab16125747220676dd8a20aecd5196", "patch": "@@ -0,0 +1,121 @@\n+// aux-build:expand-expr.rs\n+\n+extern crate expand_expr;\n+\n+use expand_expr::{\n+    check_expand_expr_file, echo_pm, expand_expr_fail, expand_expr_is, recursive_expand,\n+};\n+\n+// Check builtin macros can be expanded.\n+\n+expand_expr_is!(11u32, line!());\n+expand_expr_is!(24u32, column!());\n+\n+expand_expr_is!(\"Hello, World!\", concat!(\"Hello, \", \"World\", \"!\"));\n+expand_expr_is!(\"int10floats5.3booltrue\", concat!(\"int\", 10, \"floats\", 5.3, \"bool\", true));\n+expand_expr_is!(\"Hello\", concat!(r##\"Hello\"##));\n+\n+expand_expr_is!(\"Included file contents\\n\", include_str!(\"auxiliary/included-file.txt\"));\n+expand_expr_is!(b\"Included file contents\\n\", include_bytes!(\"auxiliary/included-file.txt\"));\n+\n+expand_expr_is!(\n+    \"contents: Included file contents\\n\",\n+    concat!(\"contents: \", include_str!(\"auxiliary/included-file.txt\"))\n+);\n+\n+// Correct value is checked for multiple sources.\n+check_expand_expr_file!(file!());\n+\n+expand_expr_is!(\"hello\", stringify!(hello));\n+expand_expr_is!(\"10 + 20\", stringify!(10 + 20));\n+\n+macro_rules! echo_tts {\n+    ($($t:tt)*) => { $($t)* };  //~ ERROR: expected expression, found `$`\n+}\n+\n+macro_rules! echo_lit {\n+    ($l:literal) => {\n+        $l\n+    };\n+}\n+\n+macro_rules! echo_expr {\n+    ($e:expr) => {\n+        $e\n+    };\n+}\n+\n+macro_rules! simple_lit {\n+    ($l:literal) => {\n+        expand_expr_is!($l, $l);\n+        expand_expr_is!($l, echo_lit!($l));\n+        expand_expr_is!($l, echo_expr!($l));\n+        expand_expr_is!($l, echo_tts!($l));\n+        expand_expr_is!($l, echo_pm!($l));\n+        const _: () = {\n+            macro_rules! mac {\n+                () => {\n+                    $l\n+                };\n+            }\n+            expand_expr_is!($l, mac!());\n+            expand_expr_is!($l, echo_expr!(mac!()));\n+            expand_expr_is!($l, echo_tts!(mac!()));\n+            expand_expr_is!($l, echo_pm!(mac!()));\n+        };\n+    };\n+}\n+\n+simple_lit!(\"Hello, World\");\n+simple_lit!('c');\n+simple_lit!(b'c');\n+simple_lit!(10);\n+simple_lit!(10.0);\n+simple_lit!(10.0f64);\n+simple_lit!(-3.14159);\n+simple_lit!(-3.5e10);\n+simple_lit!(0xFEED);\n+simple_lit!(-0xFEED);\n+simple_lit!(0b0100);\n+simple_lit!(-0b0100);\n+simple_lit!(\"string\");\n+simple_lit!(r##\"raw string\"##);\n+simple_lit!(b\"byte string\");\n+simple_lit!(br##\"raw byte string\"##);\n+simple_lit!(true);\n+simple_lit!(false);\n+\n+// Ensure char escapes aren't normalized by expansion\n+simple_lit!(\"\\u{0}\");\n+simple_lit!(\"\\0\");\n+simple_lit!(\"\\x00\");\n+simple_lit!('\\u{0}');\n+simple_lit!('\\0');\n+simple_lit!('\\x00');\n+simple_lit!(b\"\\x00\");\n+simple_lit!(b\"\\0\");\n+simple_lit!(b'\\x00');\n+simple_lit!(b'\\0');\n+\n+// Extra tokens after the string literal aren't ignored\n+expand_expr_fail!(\"string\"; hello); //~ ERROR: expected one of `.`, `?`, or an operator, found `;`\n+\n+// Invalid expressions produce errors in addition to returning `Err(())`.\n+expand_expr_fail!($); //~ ERROR: expected expression, found `$`\n+expand_expr_fail!(echo_tts!($));\n+expand_expr_fail!(echo_pm!($)); //~ ERROR: expected expression, found `$`\n+\n+// We get errors reported and recover during macro expansion if the macro\n+// doesn't produce a valid expression.\n+expand_expr_is!(\"string\", echo_tts!(\"string\"; hello)); //~ ERROR: macro expansion ignores token `hello` and any following\n+expand_expr_is!(\"string\", echo_pm!(\"string\"; hello)); //~ ERROR: macro expansion ignores token `;` and any following\n+\n+// For now, fail if a non-literal expression is expanded.\n+expand_expr_fail!(arbitrary_expression() + \"etc\");\n+expand_expr_fail!(echo_tts!(arbitrary_expression() + \"etc\"));\n+expand_expr_fail!(echo_expr!(arbitrary_expression() + \"etc\"));\n+expand_expr_fail!(echo_pm!(arbitrary_expression() + \"etc\"));\n+\n+const _: u32 = recursive_expand!(); //~ ERROR: recursion limit reached while expanding `recursive_expand!`\n+\n+fn main() {}"}, {"sha": "8dc2d0cfc2f8505d3aaf50d0827c2afeea04befa", "filename": "src/test/ui/proc-macro/expand-expr.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3e018ce194ab16125747220676dd8a20aecd5196/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e018ce194ab16125747220676dd8a20aecd5196/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.stderr?ref=3e018ce194ab16125747220676dd8a20aecd5196", "patch": "@@ -0,0 +1,55 @@\n+error: expected one of `.`, `?`, or an operator, found `;`\n+  --> $DIR/expand-expr.rs:101:27\n+   |\n+LL | expand_expr_fail!(\"string\"; hello);\n+   |                           ^ expected one of `.`, `?`, or an operator\n+\n+error: expected expression, found `$`\n+  --> $DIR/expand-expr.rs:104:19\n+   |\n+LL | expand_expr_fail!($);\n+   |                   ^ expected expression\n+\n+error: expected expression, found `$`\n+  --> $DIR/expand-expr.rs:33:23\n+   |\n+LL |     ($($t:tt)*) => { $($t)* };\n+   |                       ^^^^ expected expression\n+\n+error: expected expression, found `$`\n+  --> $DIR/expand-expr.rs:106:28\n+   |\n+LL | expand_expr_fail!(echo_pm!($));\n+   |                            ^ expected expression\n+\n+error: macro expansion ignores token `hello` and any following\n+  --> $DIR/expand-expr.rs:110:47\n+   |\n+LL | expand_expr_is!(\"string\", echo_tts!(\"string\"; hello));\n+   |                           --------------------^^^^^-- help: you might be missing a semicolon here: `;`\n+   |                           |\n+   |                           caused by the macro expansion here\n+   |\n+   = note: the usage of `echo_tts!` is likely invalid in expression context\n+\n+error: macro expansion ignores token `;` and any following\n+  --> $DIR/expand-expr.rs:111:44\n+   |\n+LL | expand_expr_is!(\"string\", echo_pm!(\"string\"; hello));\n+   |                           -----------------^-------- help: you might be missing a semicolon here: `;`\n+   |                           |\n+   |                           caused by the macro expansion here\n+   |\n+   = note: the usage of `echo_pm!` is likely invalid in expression context\n+\n+error: recursion limit reached while expanding `recursive_expand!`\n+  --> $DIR/expand-expr.rs:119:16\n+   |\n+LL | const _: u32 = recursive_expand!();\n+   |                ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`expand_expr`)\n+   = note: this error originates in the macro `recursive_expand` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 7 previous errors\n+"}]}