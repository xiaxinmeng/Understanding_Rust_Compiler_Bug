{"sha": "d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NjhkNjNiMWY5ZjVmYzQ3ZTQyMDJlMmEyYTg0MTQyZmY2MjAyZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-25T03:07:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-25T03:07:03Z"}, "message": "Auto merge of #85273 - LeSeulArtichaut:thir-query, r=nikomatsakis\n\nMake building THIR a stealable query\n\nThis PR creates a stealable `thir_body` query so that we can build the THIR only once for THIR unsafeck and MIR build.\n\nBlocked on #83842.\nr? `@nikomatsakis`", "tree": {"sha": "b5e1b4ef2806451f5234cb61e6b3b2c15db3aace", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5e1b4ef2806451f5234cb61e6b3b2c15db3aace"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "html_url": "https://github.com/rust-lang/rust/commit/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "126561cb31e8ebe1e2dd9dfd0d3ca621308dc56f", "url": "https://api.github.com/repos/rust-lang/rust/commits/126561cb31e8ebe1e2dd9dfd0d3ca621308dc56f", "html_url": "https://github.com/rust-lang/rust/commit/126561cb31e8ebe1e2dd9dfd0d3ca621308dc56f"}, {"sha": "af3d9a3aa307a1a1d2badb2be580a624a18b2858", "url": "https://api.github.com/repos/rust-lang/rust/commits/af3d9a3aa307a1a1d2badb2be580a624a18b2858", "html_url": "https://github.com/rust-lang/rust/commit/af3d9a3aa307a1a1d2badb2be580a624a18b2858"}], "stats": {"total": 1859, "additions": 937, "deletions": 922}, "files": [{"sha": "70ffff1ab99809f522bb4289788706acc71d63ba", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -873,9 +873,8 @@ fn analysis(tcx: TyCtxt<'_>, (): ()) -> Result<()> {\n \n     sess.time(\"MIR_effect_checking\", || {\n         for def_id in tcx.body_owners() {\n-            if tcx.sess.opts.debugging_opts.thir_unsafeck {\n-                tcx.ensure().thir_check_unsafety(def_id);\n-            } else {\n+            tcx.ensure().thir_check_unsafety(def_id);\n+            if !tcx.sess.opts.debugging_opts.thir_unsafeck {\n                 mir::transform::check_unsafety::check_unsafety(tcx, def_id);\n             }\n "}, {"sha": "a89d00e26ac192c4a175aec0f0e3dd7881747187", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -14,6 +14,7 @@ macro_rules! arena_types {\n             [] layouts: rustc_target::abi::Layout,\n             // AdtDef are interned and compared by address\n             [] adt_def: rustc_middle::ty::AdtDef,\n+            [] steal_thir: rustc_data_structures::steal::Steal<rustc_middle::thir::Thir<$tcx>>,\n             [] steal_mir: rustc_data_structures::steal::Steal<rustc_middle::mir::Body<$tcx>>,\n             [decode] mir: rustc_middle::mir::Body<$tcx>,\n             [] steal_promoted:"}, {"sha": "8476929eaeced2b1d230e5e6f6d964e2e7d2a088", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -285,7 +285,7 @@ pub type DepNode = rustc_query_system::dep_graph::DepNode<DepKind>;\n // required that their size stay the same, but we don't want to change\n // it inadvertently. This assert just ensures we're aware of any change.\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-static_assert_size!(DepNode, 17);\n+static_assert_size!(DepNode, 18);\n \n #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n static_assert_size!(DepNode, 24);"}, {"sha": "04124ca0281933fa23dde8d50c9953659b5909bc", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -83,6 +83,7 @@ pub mod infer;\n pub mod lint;\n pub mod middle;\n pub mod mir;\n+pub mod thir;\n pub mod traits;\n pub mod ty;\n "}, {"sha": "9125be33c93da983cf1233f7183cd6ea43ea4cb7", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -220,6 +220,11 @@ rustc_queries! {\n         desc { \"checking if the crate is_panic_runtime\" }\n     }\n \n+    /// Fetch the THIR for a given body. If typeck for that body failed, returns an empty `Thir`.\n+    query thir_body(key: ty::WithOptConstParam<LocalDefId>) -> (&'tcx Steal<thir::Thir<'tcx>>, thir::ExprId) {\n+        desc { |tcx| \"building THIR for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n+    }\n+\n     /// Set of all the `DefId`s in this crate that have MIR associated with\n     /// them. This includes all the body owners, but also things like struct\n     /// constructors."}, {"sha": "a5069113702c24db931404c2832688c587fd7a75", "filename": "compiler/rustc_middle/src/thir.rs", "status": "added", "additions": 747, "deletions": 0, "changes": 747, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -0,0 +1,747 @@\n+use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n+use rustc_hir as hir;\n+use rustc_hir::def::CtorKind;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::RangeEnd;\n+use rustc_index::newtype_index;\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::infer::canonical::Canonical;\n+use rustc_middle::middle::region;\n+use rustc_middle::mir::{\n+    BinOp, BorrowKind, FakeReadCause, Field, Mutability, UnOp, UserTypeProjection,\n+};\n+use rustc_middle::ty::adjustment::PointerCast;\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::{self, AdtDef, Const, Ty, UpvarSubsts, UserType};\n+use rustc_middle::ty::{\n+    CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n+};\n+use rustc_span::{Span, Symbol, DUMMY_SP};\n+use rustc_target::abi::VariantIdx;\n+use rustc_target::asm::InlineAsmRegOrRegClass;\n+\n+use std::fmt;\n+use std::ops::Index;\n+\n+newtype_index! {\n+    #[derive(HashStable)]\n+    pub struct ArmId {\n+        DEBUG_FORMAT = \"a{}\"\n+    }\n+}\n+\n+newtype_index! {\n+    #[derive(HashStable)]\n+    pub struct ExprId {\n+        DEBUG_FORMAT = \"e{}\"\n+    }\n+}\n+\n+newtype_index! {\n+    #[derive(HashStable)]\n+    pub struct StmtId {\n+        DEBUG_FORMAT = \"s{}\"\n+    }\n+}\n+\n+macro_rules! thir_with_elements {\n+    ($($name:ident: $id:ty => $value:ty,)*) => {\n+        #[derive(Debug, HashStable)]\n+        pub struct Thir<'tcx> {\n+            $(\n+                pub $name: IndexVec<$id, $value>,\n+            )*\n+        }\n+\n+        impl<'tcx> Thir<'tcx> {\n+            pub fn new() -> Thir<'tcx> {\n+                Thir {\n+                    $(\n+                        $name: IndexVec::new(),\n+                    )*\n+                }\n+            }\n+        }\n+\n+        $(\n+            impl<'tcx> Index<$id> for Thir<'tcx> {\n+                type Output = $value;\n+                fn index(&self, index: $id) -> &Self::Output {\n+                    &self.$name[index]\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+thir_with_elements! {\n+    arms: ArmId => Arm<'tcx>,\n+    exprs: ExprId => Expr<'tcx>,\n+    stmts: StmtId => Stmt<'tcx>,\n+}\n+\n+#[derive(Copy, Clone, Debug, HashStable)]\n+pub enum LintLevel {\n+    Inherited,\n+    Explicit(hir::HirId),\n+}\n+\n+#[derive(Debug, HashStable)]\n+pub struct Block {\n+    pub targeted_by_break: bool,\n+    pub region_scope: region::Scope,\n+    pub opt_destruction_scope: Option<region::Scope>,\n+    pub span: Span,\n+    pub stmts: Box<[StmtId]>,\n+    pub expr: Option<ExprId>,\n+    pub safety_mode: BlockSafety,\n+}\n+\n+#[derive(Copy, Clone, Debug, HashStable)]\n+pub enum BlockSafety {\n+    Safe,\n+    ExplicitUnsafe(hir::HirId),\n+    PushUnsafe,\n+    PopUnsafe,\n+}\n+\n+#[derive(Debug, HashStable)]\n+pub struct Stmt<'tcx> {\n+    pub kind: StmtKind<'tcx>,\n+    pub opt_destruction_scope: Option<region::Scope>,\n+}\n+\n+#[derive(Debug, HashStable)]\n+pub enum StmtKind<'tcx> {\n+    Expr {\n+        /// scope for this statement; may be used as lifetime of temporaries\n+        scope: region::Scope,\n+\n+        /// expression being evaluated in this statement\n+        expr: ExprId,\n+    },\n+\n+    Let {\n+        /// scope for variables bound in this let; covers this and\n+        /// remaining statements in block\n+        remainder_scope: region::Scope,\n+\n+        /// scope for the initialization itself; might be used as\n+        /// lifetime of temporaries\n+        init_scope: region::Scope,\n+\n+        /// `let <PAT> = ...`\n+        ///\n+        /// if a type is included, it is added as an ascription pattern\n+        pattern: Pat<'tcx>,\n+\n+        /// let pat: ty = <INIT> ...\n+        initializer: Option<ExprId>,\n+\n+        /// the lint level for this let-statement\n+        lint_level: LintLevel,\n+    },\n+}\n+\n+// `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+rustc_data_structures::static_assert_size!(Expr<'_>, 144);\n+\n+/// The Thir trait implementor lowers their expressions (`&'tcx H::Expr`)\n+/// into instances of this `Expr` enum. This lowering can be done\n+/// basically as lazily or as eagerly as desired: every recursive\n+/// reference to an expression in this enum is an `ExprId`, which\n+/// may in turn be another instance of this enum (boxed), or else an\n+/// unlowered `&'tcx H::Expr`. Note that instances of `Expr` are very\n+/// short-lived. They are created by `Thir::to_expr`, analyzed and\n+/// converted into MIR, and then discarded.\n+///\n+/// If you compare `Expr` to the full compiler AST, you will see it is\n+/// a good bit simpler. In fact, a number of the more straight-forward\n+/// MIR simplifications are already done in the impl of `Thir`. For\n+/// example, method calls and overloaded operators are absent: they are\n+/// expected to be converted into `Expr::Call` instances.\n+#[derive(Debug, HashStable)]\n+pub struct Expr<'tcx> {\n+    /// type of this expression\n+    pub ty: Ty<'tcx>,\n+\n+    /// lifetime of this expression if it should be spilled into a\n+    /// temporary; should be None only if in a constant context\n+    pub temp_lifetime: Option<region::Scope>,\n+\n+    /// span of the expression in the source\n+    pub span: Span,\n+\n+    /// kind of expression\n+    pub kind: ExprKind<'tcx>,\n+}\n+\n+#[derive(Debug, HashStable)]\n+pub enum ExprKind<'tcx> {\n+    Scope {\n+        region_scope: region::Scope,\n+        lint_level: LintLevel,\n+        value: ExprId,\n+    },\n+    Box {\n+        value: ExprId,\n+    },\n+    If {\n+        cond: ExprId,\n+        then: ExprId,\n+        else_opt: Option<ExprId>,\n+    },\n+    Call {\n+        ty: Ty<'tcx>,\n+        fun: ExprId,\n+        args: Box<[ExprId]>,\n+        /// Whether this is from a call in HIR, rather than from an overloaded\n+        /// operator. `true` for overloaded function call.\n+        from_hir_call: bool,\n+        /// This `Span` is the span of the function, without the dot and receiver\n+        /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n+        fn_span: Span,\n+    },\n+    Deref {\n+        arg: ExprId,\n+    }, // NOT overloaded!\n+    Binary {\n+        op: BinOp,\n+        lhs: ExprId,\n+        rhs: ExprId,\n+    }, // NOT overloaded!\n+    LogicalOp {\n+        op: LogicalOp,\n+        lhs: ExprId,\n+        rhs: ExprId,\n+    }, // NOT overloaded!\n+    // LogicalOp is distinct from BinaryOp because of lazy evaluation of the operands.\n+    Unary {\n+        op: UnOp,\n+        arg: ExprId,\n+    }, // NOT overloaded!\n+    Cast {\n+        source: ExprId,\n+    },\n+    Use {\n+        source: ExprId,\n+    }, // Use a lexpr to get a vexpr.\n+    NeverToAny {\n+        source: ExprId,\n+    },\n+    Pointer {\n+        cast: PointerCast,\n+        source: ExprId,\n+    },\n+    Loop {\n+        body: ExprId,\n+    },\n+    Match {\n+        scrutinee: ExprId,\n+        arms: Box<[ArmId]>,\n+    },\n+    Block {\n+        body: Block,\n+    },\n+    Assign {\n+        lhs: ExprId,\n+        rhs: ExprId,\n+    },\n+    AssignOp {\n+        op: BinOp,\n+        lhs: ExprId,\n+        rhs: ExprId,\n+    },\n+    Field {\n+        lhs: ExprId,\n+        name: Field,\n+    },\n+    Index {\n+        lhs: ExprId,\n+        index: ExprId,\n+    },\n+    VarRef {\n+        id: hir::HirId,\n+    },\n+    /// Used to represent upvars mentioned in a closure/generator\n+    UpvarRef {\n+        /// DefId of the closure/generator\n+        closure_def_id: DefId,\n+\n+        /// HirId of the root variable\n+        var_hir_id: hir::HirId,\n+    },\n+    Borrow {\n+        borrow_kind: BorrowKind,\n+        arg: ExprId,\n+    },\n+    /// A `&raw [const|mut] $place_expr` raw borrow resulting in type `*[const|mut] T`.\n+    AddressOf {\n+        mutability: hir::Mutability,\n+        arg: ExprId,\n+    },\n+    Break {\n+        label: region::Scope,\n+        value: Option<ExprId>,\n+    },\n+    Continue {\n+        label: region::Scope,\n+    },\n+    Return {\n+        value: Option<ExprId>,\n+    },\n+    ConstBlock {\n+        value: &'tcx Const<'tcx>,\n+    },\n+    Repeat {\n+        value: ExprId,\n+        count: &'tcx Const<'tcx>,\n+    },\n+    Array {\n+        fields: Box<[ExprId]>,\n+    },\n+    Tuple {\n+        fields: Box<[ExprId]>,\n+    },\n+    Adt {\n+        adt_def: &'tcx AdtDef,\n+        variant_index: VariantIdx,\n+        substs: SubstsRef<'tcx>,\n+\n+        /// Optional user-given substs: for something like `let x =\n+        /// Bar::<T> { ... }`.\n+        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n+\n+        fields: Box<[FieldExpr]>,\n+        base: Option<FruInfo<'tcx>>,\n+    },\n+    PlaceTypeAscription {\n+        source: ExprId,\n+        /// Type that the user gave to this expression\n+        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n+    },\n+    ValueTypeAscription {\n+        source: ExprId,\n+        /// Type that the user gave to this expression\n+        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n+    },\n+    Closure {\n+        closure_id: DefId,\n+        substs: UpvarSubsts<'tcx>,\n+        upvars: Box<[ExprId]>,\n+        movability: Option<hir::Movability>,\n+        fake_reads: Vec<(ExprId, FakeReadCause, hir::HirId)>,\n+    },\n+    Literal {\n+        literal: &'tcx Const<'tcx>,\n+        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n+        /// The `DefId` of the `const` item this literal\n+        /// was produced from, if this is not a user-written\n+        /// literal value.\n+        const_id: Option<DefId>,\n+    },\n+    /// A literal containing the address of a `static`.\n+    ///\n+    /// This is only distinguished from `Literal` so that we can register some\n+    /// info for diagnostics.\n+    StaticRef {\n+        literal: &'tcx Const<'tcx>,\n+        def_id: DefId,\n+    },\n+    InlineAsm {\n+        template: &'tcx [InlineAsmTemplatePiece],\n+        operands: Box<[InlineAsmOperand<'tcx>]>,\n+        options: InlineAsmOptions,\n+        line_spans: &'tcx [Span],\n+    },\n+    /// An expression taking a reference to a thread local.\n+    ThreadLocalRef(DefId),\n+    LlvmInlineAsm {\n+        asm: &'tcx hir::LlvmInlineAsmInner,\n+        outputs: Box<[ExprId]>,\n+        inputs: Box<[ExprId]>,\n+    },\n+    Yield {\n+        value: ExprId,\n+    },\n+}\n+\n+#[derive(Debug, HashStable)]\n+pub struct FieldExpr {\n+    pub name: Field,\n+    pub expr: ExprId,\n+}\n+\n+#[derive(Debug, HashStable)]\n+pub struct FruInfo<'tcx> {\n+    pub base: ExprId,\n+    pub field_types: Box<[Ty<'tcx>]>,\n+}\n+\n+#[derive(Debug, HashStable)]\n+pub struct Arm<'tcx> {\n+    pub pattern: Pat<'tcx>,\n+    pub guard: Option<Guard<'tcx>>,\n+    pub body: ExprId,\n+    pub lint_level: LintLevel,\n+    pub scope: region::Scope,\n+    pub span: Span,\n+}\n+\n+#[derive(Debug, HashStable)]\n+pub enum Guard<'tcx> {\n+    If(ExprId),\n+    IfLet(Pat<'tcx>, ExprId),\n+}\n+\n+#[derive(Copy, Clone, Debug, HashStable)]\n+pub enum LogicalOp {\n+    And,\n+    Or,\n+}\n+\n+#[derive(Debug, HashStable)]\n+pub enum InlineAsmOperand<'tcx> {\n+    In {\n+        reg: InlineAsmRegOrRegClass,\n+        expr: ExprId,\n+    },\n+    Out {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        expr: Option<ExprId>,\n+    },\n+    InOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        expr: ExprId,\n+    },\n+    SplitInOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        in_expr: ExprId,\n+        out_expr: Option<ExprId>,\n+    },\n+    Const {\n+        value: &'tcx Const<'tcx>,\n+        span: Span,\n+    },\n+    SymFn {\n+        expr: ExprId,\n+    },\n+    SymStatic {\n+        def_id: DefId,\n+    },\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, HashStable)]\n+pub enum BindingMode {\n+    ByValue,\n+    ByRef(BorrowKind),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, HashStable)]\n+pub struct FieldPat<'tcx> {\n+    pub field: Field,\n+    pub pattern: Pat<'tcx>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, HashStable)]\n+pub struct Pat<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub span: Span,\n+    pub kind: Box<PatKind<'tcx>>,\n+}\n+\n+impl<'tcx> Pat<'tcx> {\n+    pub fn wildcard_from_ty(ty: Ty<'tcx>) -> Self {\n+        Pat { ty, span: DUMMY_SP, kind: Box::new(PatKind::Wild) }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, HashStable)]\n+pub struct PatTyProj<'tcx> {\n+    pub user_ty: CanonicalUserType<'tcx>,\n+}\n+\n+impl<'tcx> PatTyProj<'tcx> {\n+    pub fn from_user_type(user_annotation: CanonicalUserType<'tcx>) -> Self {\n+        Self { user_ty: user_annotation }\n+    }\n+\n+    pub fn user_ty(\n+        self,\n+        annotations: &mut CanonicalUserTypeAnnotations<'tcx>,\n+        inferred_ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> UserTypeProjection {\n+        UserTypeProjection {\n+            base: annotations.push(CanonicalUserTypeAnnotation {\n+                span,\n+                user_ty: self.user_ty,\n+                inferred_ty,\n+            }),\n+            projs: Vec::new(),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, HashStable)]\n+pub struct Ascription<'tcx> {\n+    pub user_ty: PatTyProj<'tcx>,\n+    /// Variance to use when relating the type `user_ty` to the **type of the value being\n+    /// matched**. Typically, this is `Variance::Covariant`, since the value being matched must\n+    /// have a type that is some subtype of the ascribed type.\n+    ///\n+    /// Note that this variance does not apply for any bindings within subpatterns. The type\n+    /// assigned to those bindings must be exactly equal to the `user_ty` given here.\n+    ///\n+    /// The only place where this field is not `Covariant` is when matching constants, where\n+    /// we currently use `Contravariant` -- this is because the constant type just needs to\n+    /// be \"comparable\" to the type of the input value. So, for example:\n+    ///\n+    /// ```text\n+    /// match x { \"foo\" => .. }\n+    /// ```\n+    ///\n+    /// requires that `&'static str <: T_x`, where `T_x` is the type of `x`. Really, we should\n+    /// probably be checking for a `PartialEq` impl instead, but this preserves the behavior\n+    /// of the old type-check for now. See #57280 for details.\n+    pub variance: ty::Variance,\n+    pub user_ty_span: Span,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, HashStable)]\n+pub enum PatKind<'tcx> {\n+    Wild,\n+\n+    AscribeUserType {\n+        ascription: Ascription<'tcx>,\n+        subpattern: Pat<'tcx>,\n+    },\n+\n+    /// `x`, `ref x`, `x @ P`, etc.\n+    Binding {\n+        mutability: Mutability,\n+        name: Symbol,\n+        mode: BindingMode,\n+        var: hir::HirId,\n+        ty: Ty<'tcx>,\n+        subpattern: Option<Pat<'tcx>>,\n+        /// Is this the leftmost occurrence of the binding, i.e., is `var` the\n+        /// `HirId` of this pattern?\n+        is_primary: bool,\n+    },\n+\n+    /// `Foo(...)` or `Foo{...}` or `Foo`, where `Foo` is a variant name from an ADT with\n+    /// multiple variants.\n+    Variant {\n+        adt_def: &'tcx AdtDef,\n+        substs: SubstsRef<'tcx>,\n+        variant_index: VariantIdx,\n+        subpatterns: Vec<FieldPat<'tcx>>,\n+    },\n+\n+    /// `(...)`, `Foo(...)`, `Foo{...}`, or `Foo`, where `Foo` is a variant name from an ADT with\n+    /// a single variant.\n+    Leaf {\n+        subpatterns: Vec<FieldPat<'tcx>>,\n+    },\n+\n+    /// `box P`, `&P`, `&mut P`, etc.\n+    Deref {\n+        subpattern: Pat<'tcx>,\n+    },\n+\n+    /// One of the following:\n+    /// * `&str`, which will be handled as a string pattern and thus exhaustiveness\n+    ///   checking will detect if you use the same string twice in different patterns.\n+    /// * integer, bool, char or float, which will be handled by exhaustivenes to cover exactly\n+    ///   its own value, similar to `&str`, but these values are much simpler.\n+    /// * Opaque constants, that must not be matched structurally. So anything that does not derive\n+    ///   `PartialEq` and `Eq`.\n+    Constant {\n+        value: &'tcx ty::Const<'tcx>,\n+    },\n+\n+    Range(PatRange<'tcx>),\n+\n+    /// Matches against a slice, checking the length and extracting elements.\n+    /// irrefutable when there is a slice pattern and both `prefix` and `suffix` are empty.\n+    /// e.g., `&[ref xs @ ..]`.\n+    Slice {\n+        prefix: Vec<Pat<'tcx>>,\n+        slice: Option<Pat<'tcx>>,\n+        suffix: Vec<Pat<'tcx>>,\n+    },\n+\n+    /// Fixed match against an array; irrefutable.\n+    Array {\n+        prefix: Vec<Pat<'tcx>>,\n+        slice: Option<Pat<'tcx>>,\n+        suffix: Vec<Pat<'tcx>>,\n+    },\n+\n+    /// An or-pattern, e.g. `p | q`.\n+    /// Invariant: `pats.len() >= 2`.\n+    Or {\n+        pats: Vec<Pat<'tcx>>,\n+    },\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, HashStable)]\n+pub struct PatRange<'tcx> {\n+    pub lo: &'tcx ty::Const<'tcx>,\n+    pub hi: &'tcx ty::Const<'tcx>,\n+    pub end: RangeEnd,\n+}\n+\n+impl<'tcx> fmt::Display for Pat<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Printing lists is a chore.\n+        let mut first = true;\n+        let mut start_or_continue = |s| {\n+            if first {\n+                first = false;\n+                \"\"\n+            } else {\n+                s\n+            }\n+        };\n+        let mut start_or_comma = || start_or_continue(\", \");\n+\n+        match *self.kind {\n+            PatKind::Wild => write!(f, \"_\"),\n+            PatKind::AscribeUserType { ref subpattern, .. } => write!(f, \"{}: _\", subpattern),\n+            PatKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n+                let is_mut = match mode {\n+                    BindingMode::ByValue => mutability == Mutability::Mut,\n+                    BindingMode::ByRef(bk) => {\n+                        write!(f, \"ref \")?;\n+                        matches!(bk, BorrowKind::Mut { .. })\n+                    }\n+                };\n+                if is_mut {\n+                    write!(f, \"mut \")?;\n+                }\n+                write!(f, \"{}\", name)?;\n+                if let Some(ref subpattern) = *subpattern {\n+                    write!(f, \" @ {}\", subpattern)?;\n+                }\n+                Ok(())\n+            }\n+            PatKind::Variant { ref subpatterns, .. } | PatKind::Leaf { ref subpatterns } => {\n+                let variant = match *self.kind {\n+                    PatKind::Variant { adt_def, variant_index, .. } => {\n+                        Some(&adt_def.variants[variant_index])\n+                    }\n+                    _ => {\n+                        if let ty::Adt(adt, _) = self.ty.kind() {\n+                            if !adt.is_enum() {\n+                                Some(&adt.variants[VariantIdx::new(0)])\n+                            } else {\n+                                None\n+                            }\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                };\n+\n+                if let Some(variant) = variant {\n+                    write!(f, \"{}\", variant.ident)?;\n+\n+                    // Only for Adt we can have `S {...}`,\n+                    // which we handle separately here.\n+                    if variant.ctor_kind == CtorKind::Fictive {\n+                        write!(f, \" {{ \")?;\n+\n+                        let mut printed = 0;\n+                        for p in subpatterns {\n+                            if let PatKind::Wild = *p.pattern.kind {\n+                                continue;\n+                            }\n+                            let name = variant.fields[p.field.index()].ident;\n+                            write!(f, \"{}{}: {}\", start_or_comma(), name, p.pattern)?;\n+                            printed += 1;\n+                        }\n+\n+                        if printed < variant.fields.len() {\n+                            write!(f, \"{}..\", start_or_comma())?;\n+                        }\n+\n+                        return write!(f, \" }}\");\n+                    }\n+                }\n+\n+                let num_fields = variant.map_or(subpatterns.len(), |v| v.fields.len());\n+                if num_fields != 0 || variant.is_none() {\n+                    write!(f, \"(\")?;\n+                    for i in 0..num_fields {\n+                        write!(f, \"{}\", start_or_comma())?;\n+\n+                        // Common case: the field is where we expect it.\n+                        if let Some(p) = subpatterns.get(i) {\n+                            if p.field.index() == i {\n+                                write!(f, \"{}\", p.pattern)?;\n+                                continue;\n+                            }\n+                        }\n+\n+                        // Otherwise, we have to go looking for it.\n+                        if let Some(p) = subpatterns.iter().find(|p| p.field.index() == i) {\n+                            write!(f, \"{}\", p.pattern)?;\n+                        } else {\n+                            write!(f, \"_\")?;\n+                        }\n+                    }\n+                    write!(f, \")\")?;\n+                }\n+\n+                Ok(())\n+            }\n+            PatKind::Deref { ref subpattern } => {\n+                match self.ty.kind() {\n+                    ty::Adt(def, _) if def.is_box() => write!(f, \"box \")?,\n+                    ty::Ref(_, _, mutbl) => {\n+                        write!(f, \"&{}\", mutbl.prefix_str())?;\n+                    }\n+                    _ => bug!(\"{} is a bad Deref pattern type\", self.ty),\n+                }\n+                write!(f, \"{}\", subpattern)\n+            }\n+            PatKind::Constant { value } => write!(f, \"{}\", value),\n+            PatKind::Range(PatRange { lo, hi, end }) => {\n+                write!(f, \"{}\", lo)?;\n+                write!(f, \"{}\", end)?;\n+                write!(f, \"{}\", hi)\n+            }\n+            PatKind::Slice { ref prefix, ref slice, ref suffix }\n+            | PatKind::Array { ref prefix, ref slice, ref suffix } => {\n+                write!(f, \"[\")?;\n+                for p in prefix {\n+                    write!(f, \"{}{}\", start_or_comma(), p)?;\n+                }\n+                if let Some(ref slice) = *slice {\n+                    write!(f, \"{}\", start_or_comma())?;\n+                    match *slice.kind {\n+                        PatKind::Wild => {}\n+                        _ => write!(f, \"{}\", slice)?,\n+                    }\n+                    write!(f, \"..\")?;\n+                }\n+                for p in suffix {\n+                    write!(f, \"{}{}\", start_or_comma(), p)?;\n+                }\n+                write!(f, \"]\")\n+            }\n+            PatKind::Or { ref pats } => {\n+                for pat in pats {\n+                    write!(f, \"{}{}\", start_or_continue(\" | \"), pat)?;\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+}"}, {"sha": "cb08d7671bd29cbdb58dd0ec25ac89f3b9122d6f", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -13,6 +13,7 @@ use crate::middle::resolve_lifetime::{self, LifetimeScopeForPath, ObjectLifetime\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstValue, Scalar};\n use crate::mir::{Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n+use crate::thir::Thir;\n use crate::traits;\n use crate::ty::query::{self, OnDiskCache, TyCtxtAt};\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSubsts};\n@@ -1041,6 +1042,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    pub fn alloc_steal_thir(self, thir: Thir<'tcx>) -> &'tcx Steal<Thir<'tcx>> {\n+        self.arena.alloc(Steal::new(thir))\n+    }\n+\n     pub fn alloc_steal_mir(self, mir: Body<'tcx>) -> &'tcx Steal<Body<'tcx>> {\n         self.arena.alloc(Steal::new(mir))\n     }"}, {"sha": "3bdb438896bf2de56865941b6c536011a74f9f39", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -18,6 +18,7 @@ use crate::mir::interpret::GlobalId;\n use crate::mir::interpret::{ConstAlloc, LitToConstError, LitToConstInput};\n use crate::mir::interpret::{ConstValue, EvalToAllocationRawResult, EvalToConstValueResult};\n use crate::mir::mono::CodegenUnit;\n+use crate::thir;\n use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n     CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,"}, {"sha": "f35ecb4d3cd58d3390ec40771b357311f45d99c7", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -669,7 +669,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     }\n }\n \n-#[derive(Debug, Copy, Clone)]\n+#[derive(Debug, Copy, Clone, HashStable)]\n pub enum UpvarSubsts<'tcx> {\n     Closure(SubstsRef<'tcx>),\n     Generator(SubstsRef<'tcx>),"}, {"sha": "8426b24270d668ab1d1ef24501cdd03fea31d286", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -1,8 +1,8 @@\n use crate::build::matches::ArmHasGuard;\n use crate::build::ForGuard::OutsideGuard;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n-use crate::thir::*;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::*;\n use rustc_session::lint::builtin::UNSAFE_OP_IN_UNSAFE_FN;\n use rustc_session::lint::Level;\n use rustc_span::Span;"}, {"sha": "5e305ebba2ff46df57b1501d2e78ea6713baf86d", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -1,8 +1,8 @@\n //! See docs in build/expr/mod.rs\n \n use crate::build::Builder;\n-use crate::thir::*;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::*;\n use rustc_middle::ty::CanonicalUserTypeAnnotation;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {"}, {"sha": "b2a1dbf4c525dc66d09b77be04bfbc9e2edcbeea", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -2,9 +2,9 @@\n \n use crate::build::expr::category::Category;\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n-use crate::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::*;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Returns an operand suitable for use until the end of the current"}, {"sha": "842d7666742f65354d41988f73e45871c7610bdf", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -3,13 +3,13 @@\n use crate::build::expr::category::Category;\n use crate::build::ForGuard::{OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n-use crate::thir::*;\n use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind::BoundsCheck;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::*;\n use rustc_middle::ty::AdtDef;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n use rustc_span::Span;"}, {"sha": "2eb6597e81d0e9ced8949a01eb6ae1b9fd576404", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -5,11 +5,11 @@ use rustc_index::vec::Idx;\n use crate::build::expr::as_place::PlaceBase;\n use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n-use crate::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::Place;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::*;\n use rustc_middle::ty::{self, Ty, UpvarSubsts};\n use rustc_span::Span;\n "}, {"sha": "45e0243c88a0a36e46582fb7fc0a8eb6a83a45e4", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -2,10 +2,10 @@\n \n use crate::build::scope::DropKind;\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n-use crate::thir::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::*;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building"}, {"sha": "c834ce6ce68fd160b0073e4f1ff7ad3cc9e90c0a", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -1,4 +1,4 @@\n-use crate::thir::*;\n+use rustc_middle::thir::*;\n \n #[derive(Debug, PartialEq)]\n crate enum Category {"}, {"sha": "f2b00f0f6edaaeb0cc8e0de0f05c21518633bb00", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -2,13 +2,13 @@\n \n use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n-use crate::thir::*;\n use rustc_ast::InlineAsmOptions;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::*;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation};\n use std::iter;\n \n@@ -337,8 +337,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.unit()\n             }\n             ExprKind::InlineAsm { template, ref operands, options, line_spans } => {\n-                use crate::thir;\n-                use rustc_middle::mir;\n+                use rustc_middle::{mir, thir};\n                 let operands = operands\n                     .into_iter()\n                     .map(|op| match *op {"}, {"sha": "b03a6bb1a2b2a510925ae79ed686219622cfa5aa", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -1,8 +1,8 @@\n use crate::build::scope::BreakableTarget;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n-use crate::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::*;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Builds a block of MIR statements to evaluate the THIR `expr`."}, {"sha": "8164529dd1ff7d6e3e7c9368d0ec9bba5cbe844d", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -10,7 +10,6 @@ use crate::build::scope::DropKind;\n use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n-use crate::thir::{self, *};\n use rustc_data_structures::{\n     fx::{FxHashSet, FxIndexMap},\n     stack::ensure_sufficient_stack,\n@@ -19,6 +18,7 @@ use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::{self, *};\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n@@ -432,7 +432,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         ..\n                     },\n                 ascription:\n-                    thir::pattern::Ascription { user_ty: pat_ascription_ty, variance: _, user_ty_span },\n+                    thir::Ascription { user_ty: pat_ascription_ty, variance: _, user_ty_span },\n             } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n@@ -687,7 +687,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             PatKind::AscribeUserType {\n                 ref subpattern,\n-                ascription: thir::pattern::Ascription { ref user_ty, user_ty_span, variance: _ },\n+                ascription: thir::Ascription { ref user_ty, user_ty_span, variance: _ },\n             } => {\n                 // This corresponds to something like\n                 //"}, {"sha": "13cfc3695cc9f03b560451551902052e2b9fa014", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -15,8 +15,8 @@\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::{Ascription, Binding, Candidate, MatchPair};\n use crate::build::Builder;\n-use crate::thir::{self, *};\n use rustc_hir::RangeEnd;\n+use rustc_middle::thir::{self, *};\n use rustc_middle::ty;\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_target::abi::{Integer, Size};\n@@ -152,7 +152,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         match *match_pair.pattern.kind {\n             PatKind::AscribeUserType {\n                 ref subpattern,\n-                ascription: thir::pattern::Ascription { variance, user_ty, user_ty_span },\n+                ascription: thir::Ascription { variance, user_ty, user_ty_span },\n             } => {\n                 // Apply the type ascription to the value at `match_pair.place`, which is the\n                 candidate.ascriptions.push(Ascription {"}, {"sha": "c87f42738c67fa3645d0e627a7dcc9efb0ea13a1", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -9,11 +9,11 @@ use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::{Candidate, MatchPair, Test, TestKind};\n use crate::build::Builder;\n use crate::thir::pattern::compare_const_vals;\n-use crate::thir::*;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::{LangItem, RangeEnd};\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::*;\n use rustc_middle::ty::subst::{GenericArg, Subst};\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, adjustment::PointerCast, Ty, TyCtxt};"}, {"sha": "3cf8ae6efd946f33ae207347cd2b70af0a790023", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -1,8 +1,8 @@\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::MatchPair;\n use crate::build::Builder;\n-use crate::thir::*;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::*;\n use rustc_middle::ty;\n use smallvec::SmallVec;\n use std::convert::TryInto;"}, {"sha": "d8f1f5b97eeaaaeb332d46cce26fde930db701e3", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -1,7 +1,7 @@\n use crate::build;\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::scope::DropKind;\n-use crate::thir::{build_thir, BindingMode, Expr, ExprId, LintLevel, Pat, PatKind, Thir};\n+use crate::thir::pattern::pat_from_hir;\n use rustc_attr::{self as attr, UnwindAttr};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n@@ -13,6 +13,7 @@ use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::{BindingMode, Expr, ExprId, LintLevel, PatKind, Thir};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeckResults};\n use rustc_span::symbol::{kw, sym};\n@@ -45,6 +46,16 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n     let body_owner_kind = tcx.hir().body_owner_kind(id);\n     let typeck_results = tcx.typeck_opt_const_arg(def);\n \n+    // Ensure unsafeck is ran before we steal the THIR.\n+    match def {\n+        ty::WithOptConstParam { did, const_param_did: Some(const_param_did) } => {\n+            tcx.ensure().thir_check_unsafety_for_const_arg((did, const_param_did))\n+        }\n+        ty::WithOptConstParam { did, const_param_did: None } => {\n+            tcx.ensure().thir_check_unsafety(did)\n+        }\n+    }\n+\n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span, span_with_body) = match tcx.hir().get(id) {\n         Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(_, decl, body_id, _, _), .. }) => {\n@@ -104,7 +115,10 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n             };\n \n             let body = tcx.hir().body(body_id);\n-            let (thir, expr) = build_thir(tcx, def, &body.value);\n+            let (thir, expr) = tcx.thir_body(def);\n+            // We ran all queries that depended on THIR at the beginning\n+            // of `mir_build`, so now we can steal it\n+            let thir = thir.steal();\n             let ty = tcx.type_of(fn_def_id);\n             let mut abi = fn_sig.abi;\n             let implicit_argument = match ty.kind() {\n@@ -212,8 +226,10 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n \n             let return_ty = typeck_results.node_type(id);\n \n-            let ast_expr = &tcx.hir().body(body_id).value;\n-            let (thir, expr) = build_thir(tcx, def, ast_expr);\n+            let (thir, expr) = tcx.thir_body(def);\n+            // We ran all queries that depended on THIR at the beginning\n+            // of `mir_build`, so now we can steal it\n+            let thir = thir.steal();\n \n             build::construct_const(&thir, &infcx, expr, def, id, return_ty, return_ty_span)\n         };\n@@ -1016,7 +1032,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Node::Pat(pat) | Node::Binding(pat) => pat,\n                     node => bug!(\"pattern became {:?}\", node),\n                 };\n-                let pattern = Pat::from_hir(tcx, self.param_env, self.typeck_results, pat);\n+                let pattern = pat_from_hir(tcx, self.param_env, self.typeck_results, pat);\n                 let original_source_scope = self.source_scope;\n                 let span = pattern.span;\n                 self.set_correct_source_scope_for_arg(arg.hir_id, original_source_scope, span);"}, {"sha": "3de894bd37056e2c1f87097dd88c037171852ae2", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -82,11 +82,12 @@ that contains only loops and breakable blocks. It tracks where a `break`,\n */\n \n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n-use crate::thir::{Expr, LintLevel};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n+use rustc_middle::thir::{Expr, LintLevel};\n+\n use rustc_span::{Span, DUMMY_SP};\n \n #[derive(Debug)]"}, {"sha": "7e64c5f189eddd52b4eaeffb27eb5c30847d9703", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -1,8 +1,8 @@\n use crate::thir::visit::{self, Visitor};\n-use crate::thir::*;\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_middle::thir::*;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::builtin::{UNSAFE_OP_IN_UNSAFE_FN, UNUSED_UNSAFE};\n use rustc_session::lint::Level;\n@@ -328,26 +328,33 @@ impl UnsafeOpKind {\n \n // FIXME: checking unsafety for closures should be handled by their parent body,\n // as they inherit their \"safety context\" from their declaration site.\n-pub fn check_unsafety<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    thir: &Thir<'tcx>,\n-    expr: ExprId,\n-    def_id: LocalDefId,\n-    hir_id: hir::HirId,\n-) {\n+pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalDefId>) {\n+    // THIR unsafeck is gated under `-Z thir-unsafeck`\n+    if !tcx.sess.opts.debugging_opts.thir_unsafeck {\n+        return;\n+    }\n+\n+    let (thir, expr) = tcx.thir_body(def);\n+    let thir = &thir.borrow();\n+    // If `thir` is empty, a type error occured, skip this body.\n+    if thir.exprs.is_empty() {\n+        return;\n+    }\n+\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n     let body_unsafety = tcx.hir().fn_sig_by_hir_id(hir_id).map_or(BodyUnsafety::Safe, |fn_sig| {\n         if fn_sig.header.unsafety == hir::Unsafety::Unsafe {\n             BodyUnsafety::Unsafe(fn_sig.span)\n         } else {\n             BodyUnsafety::Safe\n         }\n     });\n-    let body_target_features = &tcx.codegen_fn_attrs(def_id).target_features;\n+    let body_target_features = &tcx.codegen_fn_attrs(def.did).target_features;\n     let safety_context =\n         if body_unsafety.is_unsafe() { SafetyContext::UnsafeFn } else { SafetyContext::Safe };\n     let is_const = match tcx.hir().body_owner_kind(hir_id) {\n         hir::BodyOwnerKind::Closure => false,\n-        hir::BodyOwnerKind::Fn => tcx.is_const_fn_raw(def_id.to_def_id()),\n+        hir::BodyOwnerKind::Fn => tcx.is_const_fn_raw(def.did.to_def_id()),\n         hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => true,\n     };\n     let mut visitor = UnsafetyVisitor {\n@@ -362,28 +369,17 @@ pub fn check_unsafety<'tcx>(\n     visitor.visit_expr(&thir[expr]);\n }\n \n-crate fn thir_check_unsafety_inner<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def: ty::WithOptConstParam<LocalDefId>,\n-) {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n-    let body_id = tcx.hir().body_owned_by(hir_id);\n-    let body = tcx.hir().body(body_id);\n-    let (thir, expr) = cx::build_thir(tcx, def, &body.value);\n-    check_unsafety(tcx, &thir, expr, def.did, hir_id);\n-}\n-\n crate fn thir_check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n     if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n         tcx.thir_check_unsafety_for_const_arg(def)\n     } else {\n-        thir_check_unsafety_inner(tcx, ty::WithOptConstParam::unknown(def_id))\n+        check_unsafety(tcx, ty::WithOptConstParam::unknown(def_id))\n     }\n }\n \n crate fn thir_check_unsafety_for_const_arg<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (did, param_did): (LocalDefId, DefId),\n ) {\n-    thir_check_unsafety_inner(tcx, ty::WithOptConstParam { did, const_param_did: Some(param_did) })\n+    check_unsafety(tcx, ty::WithOptConstParam { did, const_param_did: Some(param_did) })\n }"}, {"sha": "67455beb07ca25c02756a129389c07e84827624c", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -31,4 +31,5 @@ pub fn provide(providers: &mut Providers) {\n     providers.mir_built = build::mir_built;\n     providers.thir_check_unsafety = check_unsafety::thir_check_unsafety;\n     providers.thir_check_unsafety_for_const_arg = check_unsafety::thir_check_unsafety_for_const_arg;\n+    providers.thir_body = thir::cx::thir_body;\n }"}, {"sha": "77235fe9ab33b5f890244e5e1d55ffc79702dce5", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -1,8 +1,8 @@\n use crate::thir::cx::Cx;\n-use crate::thir::{self, *};\n \n use rustc_hir as hir;\n use rustc_middle::middle::region;\n+use rustc_middle::thir::*;\n use rustc_middle::ty;\n \n use rustc_index::vec::Idx;\n@@ -81,7 +81,7 @@ impl<'tcx> Cx<'tcx> {\n                                     ty: pattern.ty,\n                                     span: pattern.span,\n                                     kind: Box::new(PatKind::AscribeUserType {\n-                                        ascription: thir::pattern::Ascription {\n+                                        ascription: Ascription {\n                                             user_ty: PatTyProj::from_user_type(user_ty),\n                                             user_ty_span: ty.span,\n                                             variance: ty::Variance::Covariant,"}, {"sha": "aa4acfab5c81039c32df9f1b56f0dfbefe823ea8", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -1,21 +1,24 @@\n use crate::thir::cx::Cx;\n use crate::thir::util::UserAnnotatedTyHelpers;\n-use crate::thir::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_index::vec::Idx;\n use rustc_middle::hir::place::Place as HirPlace;\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n+use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::mir::BorrowKind;\n+use rustc_middle::mir::{BinOp, BorrowKind, Field, UnOp};\n+use rustc_middle::thir::*;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AutoBorrow, AutoBorrowMutability, PointerCast,\n };\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{self, AdtKind, Ty};\n+use rustc_middle::ty::{self, AdtKind, Ty, UpvarSubsts, UserType};\n+use rustc_span::def_id::DefId;\n use rustc_span::Span;\n+use rustc_target::abi::VariantIdx;\n \n impl<'tcx> Cx<'tcx> {\n     crate fn mirror_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) -> ExprId {"}, {"sha": "49ba71e3520d756989fbf75b3070b17d82d68c31", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -2,25 +2,32 @@\n //! structures into the THIR. The `builder` is generally ignorant of the tcx,\n //! etc., and instead goes through the `Cx` for most of its work.\n \n+use crate::thir::pattern::pat_from_hir;\n use crate::thir::util::UserAnnotatedTyHelpers;\n-use crate::thir::*;\n \n use rustc_ast as ast;\n+use rustc_data_structures::steal::Steal;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::Node;\n use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n+use rustc_middle::thir::*;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::Span;\n \n-pub fn build_thir<'tcx>(\n+crate fn thir_body<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     owner_def: ty::WithOptConstParam<LocalDefId>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-) -> (Thir<'tcx>, ExprId) {\n+) -> (&'tcx Steal<Thir<'tcx>>, ExprId) {\n+    let hir = tcx.hir();\n+    let body = hir.body(hir.body_owned_by(hir.local_def_id_to_hir_id(owner_def.did)));\n     let mut cx = Cx::new(tcx, owner_def);\n-    let expr = cx.mirror_expr(expr);\n-    (cx.thir, expr)\n+    if cx.typeck_results.tainted_by_errors.is_some() {\n+        return (tcx.alloc_steal_thir(Thir::new()), ExprId::from_u32(0));\n+    }\n+    let expr = cx.mirror_expr(&body.value);\n+    (tcx.alloc_steal_thir(cx.thir), expr)\n }\n \n struct Cx<'tcx> {\n@@ -79,7 +86,7 @@ impl<'tcx> Cx<'tcx> {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node),\n         };\n-        Pat::from_hir(self.tcx, self.param_env, self.typeck_results(), p)\n+        pat_from_hir(self.tcx, self.param_env, self.typeck_results(), p)\n     }\n }\n "}, {"sha": "e5123d8ef0c997e972d34768e5be1689b8546157", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 0, "deletions": 427, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -4,438 +4,11 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n-use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_index::newtype_index;\n-use rustc_index::vec::IndexVec;\n-use rustc_middle::infer::canonical::Canonical;\n-use rustc_middle::middle::region;\n-use rustc_middle::mir::{BinOp, BorrowKind, FakeReadCause, Field, UnOp};\n-use rustc_middle::ty::adjustment::PointerCast;\n-use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{AdtDef, Const, Ty, UpvarSubsts, UserType};\n-use rustc_span::Span;\n-use rustc_target::abi::VariantIdx;\n-use rustc_target::asm::InlineAsmRegOrRegClass;\n-\n-use std::ops::Index;\n-\n crate mod constant;\n \n crate mod cx;\n-pub use cx::build_thir;\n \n crate mod pattern;\n-pub use self::pattern::{Ascription, BindingMode, FieldPat, Pat, PatKind, PatRange, PatTyProj};\n \n mod util;\n pub mod visit;\n-\n-newtype_index! {\n-    pub struct ArmId {\n-        DEBUG_FORMAT = \"a{}\"\n-    }\n-}\n-\n-newtype_index! {\n-    pub struct ExprId {\n-        DEBUG_FORMAT = \"e{}\"\n-    }\n-}\n-\n-newtype_index! {\n-    pub struct StmtId {\n-        DEBUG_FORMAT = \"s{}\"\n-    }\n-}\n-\n-macro_rules! thir_with_elements {\n-    ($($name:ident: $id:ty => $value:ty,)*) => {\n-        pub struct Thir<'tcx> {\n-            $(\n-                $name: IndexVec<$id, $value>,\n-            )*\n-        }\n-\n-        impl<'tcx> Thir<'tcx> {\n-            fn new() -> Thir<'tcx> {\n-                Thir {\n-                    $(\n-                        $name: IndexVec::new(),\n-                    )*\n-                }\n-            }\n-        }\n-\n-        $(\n-            impl<'tcx> Index<$id> for Thir<'tcx> {\n-                type Output = $value;\n-                fn index(&self, index: $id) -> &Self::Output {\n-                    &self.$name[index]\n-                }\n-            }\n-        )*\n-    }\n-}\n-\n-thir_with_elements! {\n-    arms: ArmId => Arm<'tcx>,\n-    exprs: ExprId => Expr<'tcx>,\n-    stmts: StmtId => Stmt<'tcx>,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum LintLevel {\n-    Inherited,\n-    Explicit(hir::HirId),\n-}\n-\n-#[derive(Debug)]\n-pub struct Block {\n-    pub targeted_by_break: bool,\n-    pub region_scope: region::Scope,\n-    pub opt_destruction_scope: Option<region::Scope>,\n-    pub span: Span,\n-    pub stmts: Box<[StmtId]>,\n-    pub expr: Option<ExprId>,\n-    pub safety_mode: BlockSafety,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum BlockSafety {\n-    Safe,\n-    ExplicitUnsafe(hir::HirId),\n-    PushUnsafe,\n-    PopUnsafe,\n-}\n-\n-#[derive(Debug)]\n-pub struct Stmt<'tcx> {\n-    pub kind: StmtKind<'tcx>,\n-    pub opt_destruction_scope: Option<region::Scope>,\n-}\n-\n-#[derive(Debug)]\n-pub enum StmtKind<'tcx> {\n-    Expr {\n-        /// scope for this statement; may be used as lifetime of temporaries\n-        scope: region::Scope,\n-\n-        /// expression being evaluated in this statement\n-        expr: ExprId,\n-    },\n-\n-    Let {\n-        /// scope for variables bound in this let; covers this and\n-        /// remaining statements in block\n-        remainder_scope: region::Scope,\n-\n-        /// scope for the initialization itself; might be used as\n-        /// lifetime of temporaries\n-        init_scope: region::Scope,\n-\n-        /// `let <PAT> = ...`\n-        ///\n-        /// if a type is included, it is added as an ascription pattern\n-        pattern: Pat<'tcx>,\n-\n-        /// let pat: ty = <INIT> ...\n-        initializer: Option<ExprId>,\n-\n-        /// the lint level for this let-statement\n-        lint_level: LintLevel,\n-    },\n-}\n-\n-// `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Expr<'_>, 144);\n-\n-/// The Thir trait implementor lowers their expressions (`&'tcx H::Expr`)\n-/// into instances of this `Expr` enum. This lowering can be done\n-/// basically as lazily or as eagerly as desired: every recursive\n-/// reference to an expression in this enum is an `ExprId`, which\n-/// may in turn be another instance of this enum (boxed), or else an\n-/// unlowered `&'tcx H::Expr`. Note that instances of `Expr` are very\n-/// short-lived. They are created by `Thir::to_expr`, analyzed and\n-/// converted into MIR, and then discarded.\n-///\n-/// If you compare `Expr` to the full compiler AST, you will see it is\n-/// a good bit simpler. In fact, a number of the more straight-forward\n-/// MIR simplifications are already done in the impl of `Thir`. For\n-/// example, method calls and overloaded operators are absent: they are\n-/// expected to be converted into `Expr::Call` instances.\n-#[derive(Debug)]\n-pub struct Expr<'tcx> {\n-    /// type of this expression\n-    pub ty: Ty<'tcx>,\n-\n-    /// lifetime of this expression if it should be spilled into a\n-    /// temporary; should be None only if in a constant context\n-    pub temp_lifetime: Option<region::Scope>,\n-\n-    /// span of the expression in the source\n-    pub span: Span,\n-\n-    /// kind of expression\n-    pub kind: ExprKind<'tcx>,\n-}\n-\n-#[derive(Debug)]\n-pub enum ExprKind<'tcx> {\n-    Scope {\n-        region_scope: region::Scope,\n-        lint_level: LintLevel,\n-        value: ExprId,\n-    },\n-    Box {\n-        value: ExprId,\n-    },\n-    If {\n-        cond: ExprId,\n-        then: ExprId,\n-        else_opt: Option<ExprId>,\n-    },\n-    Call {\n-        ty: Ty<'tcx>,\n-        fun: ExprId,\n-        args: Box<[ExprId]>,\n-        /// Whether this is from a call in HIR, rather than from an overloaded\n-        /// operator. `true` for overloaded function call.\n-        from_hir_call: bool,\n-        /// This `Span` is the span of the function, without the dot and receiver\n-        /// (e.g. `foo(a, b)` in `x.foo(a, b)`\n-        fn_span: Span,\n-    },\n-    Deref {\n-        arg: ExprId,\n-    }, // NOT overloaded!\n-    Binary {\n-        op: BinOp,\n-        lhs: ExprId,\n-        rhs: ExprId,\n-    }, // NOT overloaded!\n-    LogicalOp {\n-        op: LogicalOp,\n-        lhs: ExprId,\n-        rhs: ExprId,\n-    }, // NOT overloaded!\n-    // LogicalOp is distinct from BinaryOp because of lazy evaluation of the operands.\n-    Unary {\n-        op: UnOp,\n-        arg: ExprId,\n-    }, // NOT overloaded!\n-    Cast {\n-        source: ExprId,\n-    },\n-    Use {\n-        source: ExprId,\n-    }, // Use a lexpr to get a vexpr.\n-    NeverToAny {\n-        source: ExprId,\n-    },\n-    Pointer {\n-        cast: PointerCast,\n-        source: ExprId,\n-    },\n-    Loop {\n-        body: ExprId,\n-    },\n-    Match {\n-        scrutinee: ExprId,\n-        arms: Box<[ArmId]>,\n-    },\n-    Block {\n-        body: Block,\n-    },\n-    Assign {\n-        lhs: ExprId,\n-        rhs: ExprId,\n-    },\n-    AssignOp {\n-        op: BinOp,\n-        lhs: ExprId,\n-        rhs: ExprId,\n-    },\n-    Field {\n-        lhs: ExprId,\n-        name: Field,\n-    },\n-    Index {\n-        lhs: ExprId,\n-        index: ExprId,\n-    },\n-    VarRef {\n-        id: hir::HirId,\n-    },\n-    /// Used to represent upvars mentioned in a closure/generator\n-    UpvarRef {\n-        /// DefId of the closure/generator\n-        closure_def_id: DefId,\n-\n-        /// HirId of the root variable\n-        var_hir_id: hir::HirId,\n-    },\n-    Borrow {\n-        borrow_kind: BorrowKind,\n-        arg: ExprId,\n-    },\n-    /// A `&raw [const|mut] $place_expr` raw borrow resulting in type `*[const|mut] T`.\n-    AddressOf {\n-        mutability: hir::Mutability,\n-        arg: ExprId,\n-    },\n-    Break {\n-        label: region::Scope,\n-        value: Option<ExprId>,\n-    },\n-    Continue {\n-        label: region::Scope,\n-    },\n-    Return {\n-        value: Option<ExprId>,\n-    },\n-    ConstBlock {\n-        value: &'tcx Const<'tcx>,\n-    },\n-    Repeat {\n-        value: ExprId,\n-        count: &'tcx Const<'tcx>,\n-    },\n-    Array {\n-        fields: Box<[ExprId]>,\n-    },\n-    Tuple {\n-        fields: Box<[ExprId]>,\n-    },\n-    Adt {\n-        adt_def: &'tcx AdtDef,\n-        variant_index: VariantIdx,\n-        substs: SubstsRef<'tcx>,\n-\n-        /// Optional user-given substs: for something like `let x =\n-        /// Bar::<T> { ... }`.\n-        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n-\n-        fields: Box<[FieldExpr]>,\n-        base: Option<FruInfo<'tcx>>,\n-    },\n-    PlaceTypeAscription {\n-        source: ExprId,\n-        /// Type that the user gave to this expression\n-        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n-    },\n-    ValueTypeAscription {\n-        source: ExprId,\n-        /// Type that the user gave to this expression\n-        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n-    },\n-    Closure {\n-        closure_id: DefId,\n-        substs: UpvarSubsts<'tcx>,\n-        upvars: Box<[ExprId]>,\n-        movability: Option<hir::Movability>,\n-        fake_reads: Vec<(ExprId, FakeReadCause, hir::HirId)>,\n-    },\n-    Literal {\n-        literal: &'tcx Const<'tcx>,\n-        user_ty: Option<Canonical<'tcx, UserType<'tcx>>>,\n-        /// The `DefId` of the `const` item this literal\n-        /// was produced from, if this is not a user-written\n-        /// literal value.\n-        const_id: Option<DefId>,\n-    },\n-    /// A literal containing the address of a `static`.\n-    ///\n-    /// This is only distinguished from `Literal` so that we can register some\n-    /// info for diagnostics.\n-    StaticRef {\n-        literal: &'tcx Const<'tcx>,\n-        def_id: DefId,\n-    },\n-    InlineAsm {\n-        template: &'tcx [InlineAsmTemplatePiece],\n-        operands: Box<[InlineAsmOperand<'tcx>]>,\n-        options: InlineAsmOptions,\n-        line_spans: &'tcx [Span],\n-    },\n-    /// An expression taking a reference to a thread local.\n-    ThreadLocalRef(DefId),\n-    LlvmInlineAsm {\n-        asm: &'tcx hir::LlvmInlineAsmInner,\n-        outputs: Box<[ExprId]>,\n-        inputs: Box<[ExprId]>,\n-    },\n-    Yield {\n-        value: ExprId,\n-    },\n-}\n-\n-#[derive(Debug)]\n-pub struct FieldExpr {\n-    pub name: Field,\n-    pub expr: ExprId,\n-}\n-\n-#[derive(Debug)]\n-pub struct FruInfo<'tcx> {\n-    pub base: ExprId,\n-    pub field_types: Box<[Ty<'tcx>]>,\n-}\n-\n-#[derive(Debug)]\n-pub struct Arm<'tcx> {\n-    pub pattern: Pat<'tcx>,\n-    pub guard: Option<Guard<'tcx>>,\n-    pub body: ExprId,\n-    pub lint_level: LintLevel,\n-    pub scope: region::Scope,\n-    pub span: Span,\n-}\n-\n-#[derive(Debug)]\n-pub enum Guard<'tcx> {\n-    If(ExprId),\n-    IfLet(Pat<'tcx>, ExprId),\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum LogicalOp {\n-    And,\n-    Or,\n-}\n-\n-#[derive(Debug)]\n-pub enum InlineAsmOperand<'tcx> {\n-    In {\n-        reg: InlineAsmRegOrRegClass,\n-        expr: ExprId,\n-    },\n-    Out {\n-        reg: InlineAsmRegOrRegClass,\n-        late: bool,\n-        expr: Option<ExprId>,\n-    },\n-    InOut {\n-        reg: InlineAsmRegOrRegClass,\n-        late: bool,\n-        expr: ExprId,\n-    },\n-    SplitInOut {\n-        reg: InlineAsmRegOrRegClass,\n-        late: bool,\n-        in_expr: ExprId,\n-        out_expr: Option<ExprId>,\n-    },\n-    Const {\n-        value: &'tcx Const<'tcx>,\n-        span: Span,\n-    },\n-    SymFn {\n-        expr: ExprId,\n-    },\n-    SymStatic {\n-        def_id: DefId,\n-    },\n-}"}, {"sha": "389a7595315c6b2f6656768dec17afa08d4334e3", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -1,8 +1,8 @@\n use super::usefulness::{\n-    compute_match_usefulness, expand_pattern, MatchArm, MatchCheckCtxt, Reachability,\n+    compute_match_usefulness, expand_pattern, is_wildcard, MatchArm, MatchCheckCtxt, Reachability,\n     UsefulnessReport,\n };\n-use super::{PatCtxt, PatKind, PatternError};\n+use super::{PatCtxt, PatternError};\n \n use rustc_arena::TypedArena;\n use rustc_ast::Mutability;\n@@ -12,6 +12,7 @@ use rustc_hir::def::*;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{HirId, Pat};\n+use rustc_middle::thir::PatKind;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::builtin::BINDINGS_WITH_VARIANT_NAME;\n use rustc_session::lint::builtin::{IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS};\n@@ -344,7 +345,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n \n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n fn pat_is_catchall(pat: &super::Pat<'_>) -> bool {\n-    use super::PatKind::*;\n+    use PatKind::*;\n     match &*pat.kind {\n         Binding { subpattern: None, .. } => true,\n         Binding { subpattern: Some(s), .. } | Deref { subpattern: s } => pat_is_catchall(s),\n@@ -514,7 +515,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     if (scrut_ty == cx.tcx.types.usize || scrut_ty == cx.tcx.types.isize)\n         && !is_empty_match\n         && witnesses.len() == 1\n-        && witnesses[0].is_wildcard()\n+        && is_wildcard(&witnesses[0])\n     {\n         err.note(&format!(\n             \"`{}` does not have a fixed maximum value, \\"}, {"sha": "369fff00456a79421e123c81bc41ae7acaf2c9f2", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -2,6 +2,7 @@ use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::mir::Field;\n+use rustc_middle::thir::{FieldPat, Pat, PatKind};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n use rustc_session::lint;\n@@ -12,7 +13,7 @@ use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligation};\n \n use std::cell::Cell;\n \n-use super::{FieldPat, Pat, PatCtxt, PatKind};\n+use super::PatCtxt;\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// Converts an evaluated constant to a pattern (if possible)."}, {"sha": "4b5b648c5044f3b743755150c2755602279734be", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -46,15 +46,15 @@ use self::Constructor::*;\n use self::SliceKind::*;\n \n use super::compare_const_vals;\n-use super::usefulness::{MatchCheckCtxt, PatCtxt};\n-use super::{FieldPat, Pat, PatKind, PatRange};\n+use super::usefulness::{is_wildcard, MatchCheckCtxt, PatCtxt};\n \n use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n \n use rustc_hir::{HirId, RangeEnd};\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::mir::Field;\n+use rustc_middle::thir::{FieldPat, Pat, PatKind, PatRange};\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n use rustc_session::lint;\n@@ -1245,13 +1245,13 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         // of reporting `[x, _, .., _, y]`, we prefer to report `[x, .., y]`.\n                         // This is incorrect if the size is not known, since `[_, ..]` captures\n                         // arrays of lengths `>= 1` whereas `[..]` captures any length.\n-                        while !prefix.is_empty() && prefix.last().unwrap().is_wildcard() {\n+                        while !prefix.is_empty() && is_wildcard(prefix.last().unwrap()) {\n                             prefix.pop();\n                         }\n                     }\n                     let suffix: Vec<_> = if slice.array_len.is_some() {\n                         // Same as above.\n-                        subpatterns.skip_while(Pat::is_wildcard).collect()\n+                        subpatterns.skip_while(is_wildcard).collect()\n                     } else {\n                         subpatterns.collect()\n                     };"}, {"sha": "3225d302cb30c45e58440a2cdf11b21b4c10be10", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 17, "deletions": 334, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -11,24 +11,20 @@ use crate::thir::util::UserAnnotatedTyHelpers;\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::RangeEnd;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{get_slice_bytes, ConstValue};\n use rustc_middle::mir::interpret::{ErrorHandled, LitToConstError, LitToConstInput};\n use rustc_middle::mir::UserTypeProjection;\n use rustc_middle::mir::{BorrowKind, Field, Mutability};\n+use rustc_middle::thir::{Ascription, BindingMode, FieldPat, Pat, PatKind, PatRange, PatTyProj};\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n use rustc_middle::ty::{self, AdtDef, DefIdTree, Region, Ty, TyCtxt, UserType};\n-use rustc_middle::ty::{\n-    CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n-};\n-use rustc_span::{Span, Symbol, DUMMY_SP};\n-use rustc_target::abi::VariantIdx;\n+use rustc_span::{Span, Symbol};\n \n use std::cmp::Ordering;\n-use std::fmt;\n \n #[derive(Clone, Debug)]\n crate enum PatternError {\n@@ -39,317 +35,6 @@ crate enum PatternError {\n     NonConstPath(Span),\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub enum BindingMode {\n-    ByValue,\n-    ByRef(BorrowKind),\n-}\n-\n-#[derive(Clone, Debug, PartialEq)]\n-pub struct FieldPat<'tcx> {\n-    pub field: Field,\n-    pub pattern: Pat<'tcx>,\n-}\n-\n-#[derive(Clone, Debug, PartialEq)]\n-pub struct Pat<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub span: Span,\n-    pub kind: Box<PatKind<'tcx>>,\n-}\n-\n-impl<'tcx> Pat<'tcx> {\n-    pub(crate) fn wildcard_from_ty(ty: Ty<'tcx>) -> Self {\n-        Pat { ty, span: DUMMY_SP, kind: Box::new(PatKind::Wild) }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct PatTyProj<'tcx> {\n-    pub user_ty: CanonicalUserType<'tcx>,\n-}\n-\n-impl<'tcx> PatTyProj<'tcx> {\n-    pub(crate) fn from_user_type(user_annotation: CanonicalUserType<'tcx>) -> Self {\n-        Self { user_ty: user_annotation }\n-    }\n-\n-    pub(crate) fn user_ty(\n-        self,\n-        annotations: &mut CanonicalUserTypeAnnotations<'tcx>,\n-        inferred_ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> UserTypeProjection {\n-        UserTypeProjection {\n-            base: annotations.push(CanonicalUserTypeAnnotation {\n-                span,\n-                user_ty: self.user_ty,\n-                inferred_ty,\n-            }),\n-            projs: Vec::new(),\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct Ascription<'tcx> {\n-    pub user_ty: PatTyProj<'tcx>,\n-    /// Variance to use when relating the type `user_ty` to the **type of the value being\n-    /// matched**. Typically, this is `Variance::Covariant`, since the value being matched must\n-    /// have a type that is some subtype of the ascribed type.\n-    ///\n-    /// Note that this variance does not apply for any bindings within subpatterns. The type\n-    /// assigned to those bindings must be exactly equal to the `user_ty` given here.\n-    ///\n-    /// The only place where this field is not `Covariant` is when matching constants, where\n-    /// we currently use `Contravariant` -- this is because the constant type just needs to\n-    /// be \"comparable\" to the type of the input value. So, for example:\n-    ///\n-    /// ```text\n-    /// match x { \"foo\" => .. }\n-    /// ```\n-    ///\n-    /// requires that `&'static str <: T_x`, where `T_x` is the type of `x`. Really, we should\n-    /// probably be checking for a `PartialEq` impl instead, but this preserves the behavior\n-    /// of the old type-check for now. See #57280 for details.\n-    pub variance: ty::Variance,\n-    pub user_ty_span: Span,\n-}\n-\n-#[derive(Clone, Debug, PartialEq)]\n-pub enum PatKind<'tcx> {\n-    Wild,\n-\n-    AscribeUserType {\n-        ascription: Ascription<'tcx>,\n-        subpattern: Pat<'tcx>,\n-    },\n-\n-    /// `x`, `ref x`, `x @ P`, etc.\n-    Binding {\n-        mutability: Mutability,\n-        name: Symbol,\n-        mode: BindingMode,\n-        var: hir::HirId,\n-        ty: Ty<'tcx>,\n-        subpattern: Option<Pat<'tcx>>,\n-        /// Is this the leftmost occurrence of the binding, i.e., is `var` the\n-        /// `HirId` of this pattern?\n-        is_primary: bool,\n-    },\n-\n-    /// `Foo(...)` or `Foo{...}` or `Foo`, where `Foo` is a variant name from an ADT with\n-    /// multiple variants.\n-    Variant {\n-        adt_def: &'tcx AdtDef,\n-        substs: SubstsRef<'tcx>,\n-        variant_index: VariantIdx,\n-        subpatterns: Vec<FieldPat<'tcx>>,\n-    },\n-\n-    /// `(...)`, `Foo(...)`, `Foo{...}`, or `Foo`, where `Foo` is a variant name from an ADT with\n-    /// a single variant.\n-    Leaf {\n-        subpatterns: Vec<FieldPat<'tcx>>,\n-    },\n-\n-    /// `box P`, `&P`, `&mut P`, etc.\n-    Deref {\n-        subpattern: Pat<'tcx>,\n-    },\n-\n-    /// One of the following:\n-    /// * `&str`, which will be handled as a string pattern and thus exhaustiveness\n-    ///   checking will detect if you use the same string twice in different patterns.\n-    /// * integer, bool, char or float, which will be handled by exhaustivenes to cover exactly\n-    ///   its own value, similar to `&str`, but these values are much simpler.\n-    /// * Opaque constants, that must not be matched structurally. So anything that does not derive\n-    ///   `PartialEq` and `Eq`.\n-    Constant {\n-        value: &'tcx ty::Const<'tcx>,\n-    },\n-\n-    Range(PatRange<'tcx>),\n-\n-    /// Matches against a slice, checking the length and extracting elements.\n-    /// irrefutable when there is a slice pattern and both `prefix` and `suffix` are empty.\n-    /// e.g., `&[ref xs @ ..]`.\n-    Slice {\n-        prefix: Vec<Pat<'tcx>>,\n-        slice: Option<Pat<'tcx>>,\n-        suffix: Vec<Pat<'tcx>>,\n-    },\n-\n-    /// Fixed match against an array; irrefutable.\n-    Array {\n-        prefix: Vec<Pat<'tcx>>,\n-        slice: Option<Pat<'tcx>>,\n-        suffix: Vec<Pat<'tcx>>,\n-    },\n-\n-    /// An or-pattern, e.g. `p | q`.\n-    /// Invariant: `pats.len() >= 2`.\n-    Or {\n-        pats: Vec<Pat<'tcx>>,\n-    },\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub struct PatRange<'tcx> {\n-    pub lo: &'tcx ty::Const<'tcx>,\n-    pub hi: &'tcx ty::Const<'tcx>,\n-    pub end: RangeEnd,\n-}\n-\n-impl<'tcx> fmt::Display for Pat<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Printing lists is a chore.\n-        let mut first = true;\n-        let mut start_or_continue = |s| {\n-            if first {\n-                first = false;\n-                \"\"\n-            } else {\n-                s\n-            }\n-        };\n-        let mut start_or_comma = || start_or_continue(\", \");\n-\n-        match *self.kind {\n-            PatKind::Wild => write!(f, \"_\"),\n-            PatKind::AscribeUserType { ref subpattern, .. } => write!(f, \"{}: _\", subpattern),\n-            PatKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n-                let is_mut = match mode {\n-                    BindingMode::ByValue => mutability == Mutability::Mut,\n-                    BindingMode::ByRef(bk) => {\n-                        write!(f, \"ref \")?;\n-                        matches!(bk, BorrowKind::Mut { .. })\n-                    }\n-                };\n-                if is_mut {\n-                    write!(f, \"mut \")?;\n-                }\n-                write!(f, \"{}\", name)?;\n-                if let Some(ref subpattern) = *subpattern {\n-                    write!(f, \" @ {}\", subpattern)?;\n-                }\n-                Ok(())\n-            }\n-            PatKind::Variant { ref subpatterns, .. } | PatKind::Leaf { ref subpatterns } => {\n-                let variant = match *self.kind {\n-                    PatKind::Variant { adt_def, variant_index, .. } => {\n-                        Some(&adt_def.variants[variant_index])\n-                    }\n-                    _ => {\n-                        if let ty::Adt(adt, _) = self.ty.kind() {\n-                            if !adt.is_enum() {\n-                                Some(&adt.variants[VariantIdx::new(0)])\n-                            } else {\n-                                None\n-                            }\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                };\n-\n-                if let Some(variant) = variant {\n-                    write!(f, \"{}\", variant.ident)?;\n-\n-                    // Only for Adt we can have `S {...}`,\n-                    // which we handle separately here.\n-                    if variant.ctor_kind == CtorKind::Fictive {\n-                        write!(f, \" {{ \")?;\n-\n-                        let mut printed = 0;\n-                        for p in subpatterns {\n-                            if let PatKind::Wild = *p.pattern.kind {\n-                                continue;\n-                            }\n-                            let name = variant.fields[p.field.index()].ident;\n-                            write!(f, \"{}{}: {}\", start_or_comma(), name, p.pattern)?;\n-                            printed += 1;\n-                        }\n-\n-                        if printed < variant.fields.len() {\n-                            write!(f, \"{}..\", start_or_comma())?;\n-                        }\n-\n-                        return write!(f, \" }}\");\n-                    }\n-                }\n-\n-                let num_fields = variant.map_or(subpatterns.len(), |v| v.fields.len());\n-                if num_fields != 0 || variant.is_none() {\n-                    write!(f, \"(\")?;\n-                    for i in 0..num_fields {\n-                        write!(f, \"{}\", start_or_comma())?;\n-\n-                        // Common case: the field is where we expect it.\n-                        if let Some(p) = subpatterns.get(i) {\n-                            if p.field.index() == i {\n-                                write!(f, \"{}\", p.pattern)?;\n-                                continue;\n-                            }\n-                        }\n-\n-                        // Otherwise, we have to go looking for it.\n-                        if let Some(p) = subpatterns.iter().find(|p| p.field.index() == i) {\n-                            write!(f, \"{}\", p.pattern)?;\n-                        } else {\n-                            write!(f, \"_\")?;\n-                        }\n-                    }\n-                    write!(f, \")\")?;\n-                }\n-\n-                Ok(())\n-            }\n-            PatKind::Deref { ref subpattern } => {\n-                match self.ty.kind() {\n-                    ty::Adt(def, _) if def.is_box() => write!(f, \"box \")?,\n-                    ty::Ref(_, _, mutbl) => {\n-                        write!(f, \"&{}\", mutbl.prefix_str())?;\n-                    }\n-                    _ => bug!(\"{} is a bad Deref pattern type\", self.ty),\n-                }\n-                write!(f, \"{}\", subpattern)\n-            }\n-            PatKind::Constant { value } => write!(f, \"{}\", value),\n-            PatKind::Range(PatRange { lo, hi, end }) => {\n-                write!(f, \"{}\", lo)?;\n-                write!(f, \"{}\", end)?;\n-                write!(f, \"{}\", hi)\n-            }\n-            PatKind::Slice { ref prefix, ref slice, ref suffix }\n-            | PatKind::Array { ref prefix, ref slice, ref suffix } => {\n-                write!(f, \"[\")?;\n-                for p in prefix {\n-                    write!(f, \"{}{}\", start_or_comma(), p)?;\n-                }\n-                if let Some(ref slice) = *slice {\n-                    write!(f, \"{}\", start_or_comma())?;\n-                    match *slice.kind {\n-                        PatKind::Wild => {}\n-                        _ => write!(f, \"{}\", slice)?,\n-                    }\n-                    write!(f, \"..\")?;\n-                }\n-                for p in suffix {\n-                    write!(f, \"{}{}\", start_or_comma(), p)?;\n-                }\n-                write!(f, \"]\")\n-            }\n-            PatKind::Or { ref pats } => {\n-                for pat in pats {\n-                    write!(f, \"{}{}\", start_or_continue(\" | \"), pat)?;\n-                }\n-                Ok(())\n-            }\n-        }\n-    }\n-}\n-\n crate struct PatCtxt<'a, 'tcx> {\n     crate tcx: TyCtxt<'tcx>,\n     crate param_env: ty::ParamEnv<'tcx>,\n@@ -358,22 +43,20 @@ crate struct PatCtxt<'a, 'tcx> {\n     include_lint_checks: bool,\n }\n \n-impl<'a, 'tcx> Pat<'tcx> {\n-    crate fn from_hir(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        typeck_results: &'a ty::TypeckResults<'tcx>,\n-        pat: &'tcx hir::Pat<'tcx>,\n-    ) -> Self {\n-        let mut pcx = PatCtxt::new(tcx, param_env, typeck_results);\n-        let result = pcx.lower_pattern(pat);\n-        if !pcx.errors.is_empty() {\n-            let msg = format!(\"encountered errors lowering pattern: {:?}\", pcx.errors);\n-            tcx.sess.delay_span_bug(pat.span, &msg);\n-        }\n-        debug!(\"Pat::from_hir({:?}) = {:?}\", pat, result);\n-        result\n-    }\n+crate fn pat_from_hir<'a, 'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+    pat: &'tcx hir::Pat<'tcx>,\n+) -> Pat<'tcx> {\n+    let mut pcx = PatCtxt::new(tcx, param_env, typeck_results);\n+    let result = pcx.lower_pattern(pat);\n+    if !pcx.errors.is_empty() {\n+        let msg = format!(\"encountered errors lowering pattern: {:?}\", pcx.errors);\n+        tcx.sess.delay_span_bug(pat.span, &msg);\n+    }\n+    debug!(\"pat_from_hir({:?}) = {:?}\", pat, result);\n+    result\n }\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {"}, {"sha": "5d4eb75155a676cdca5b8f3e051b57b4d0aed65a", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -284,7 +284,6 @@ use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n use super::deconstruct_pat::{Constructor, Fields, SplitWildcard};\n-use super::{Pat, PatKind};\n use super::{PatternFoldable, PatternFolder};\n \n use rustc_data_structures::captures::Captures;\n@@ -293,6 +292,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_arena::TypedArena;\n use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n+use rustc_middle::thir::{Pat, PatKind};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n \n@@ -382,31 +382,29 @@ impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n     }\n }\n \n-impl<'tcx> Pat<'tcx> {\n-    pub(super) fn is_wildcard(&self) -> bool {\n-        matches!(*self.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n-    }\n+pub(super) fn is_wildcard(pat: &Pat<'_>) -> bool {\n+    matches!(*pat.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n+}\n \n-    fn is_or_pat(&self) -> bool {\n-        matches!(*self.kind, PatKind::Or { .. })\n-    }\n+fn is_or_pat(pat: &Pat<'_>) -> bool {\n+    matches!(*pat.kind, PatKind::Or { .. })\n+}\n \n-    /// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n-    fn expand_or_pat(&self) -> Vec<&Self> {\n-        fn expand<'p, 'tcx>(pat: &'p Pat<'tcx>, vec: &mut Vec<&'p Pat<'tcx>>) {\n-            if let PatKind::Or { pats } = pat.kind.as_ref() {\n-                for pat in pats {\n-                    expand(pat, vec);\n-                }\n-            } else {\n-                vec.push(pat)\n+/// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n+fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n+    fn expand<'p, 'tcx>(pat: &'p Pat<'tcx>, vec: &mut Vec<&'p Pat<'tcx>>) {\n+        if let PatKind::Or { pats } = pat.kind.as_ref() {\n+            for pat in pats {\n+                expand(pat, vec);\n             }\n+        } else {\n+            vec.push(pat)\n         }\n-\n-        let mut pats = Vec::new();\n-        expand(self, &mut pats);\n-        pats\n     }\n+\n+    let mut pats = Vec::new();\n+    expand(pat, &mut pats);\n+    pats\n }\n \n /// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n@@ -451,7 +449,7 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     // Recursively expand the first pattern into its subpatterns. Only useful if the pattern is an\n     // or-pattern. Panics if `self` is empty.\n     fn expand_or_pat<'a>(&'a self) -> impl Iterator<Item = PatStack<'p, 'tcx>> + Captures<'a> {\n-        self.head().expand_or_pat().into_iter().map(move |pat| {\n+        expand_or_pat(self.head()).into_iter().map(move |pat| {\n             let mut new_patstack = PatStack::from_pattern(pat);\n             new_patstack.pats.extend_from_slice(&self.pats[1..]);\n             new_patstack\n@@ -525,7 +523,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     /// Pushes a new row to the matrix. If the row starts with an or-pattern, this recursively\n     /// expands it.\n     fn push(&mut self, row: PatStack<'p, 'tcx>) {\n-        if !row.is_empty() && row.head().is_or_pat() {\n+        if !row.is_empty() && is_or_pat(row.head()) {\n             for row in row.expand_or_pat() {\n                 self.patterns.push(row);\n             }\n@@ -760,7 +758,7 @@ impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n                     }\n                 }\n                 SubPatSet::Alt { subpats, pat, alt_count, .. } => {\n-                    let expanded = pat.expand_or_pat();\n+                    let expanded = expand_or_pat(pat);\n                     for i in 0..*alt_count {\n                         let sub_set = subpats.get(&i).unwrap_or(&SubPatSet::Empty);\n                         if sub_set.is_empty() {\n@@ -1118,7 +1116,7 @@ fn is_useful<'p, 'tcx>(\n     let pcx = PatCtxt { cx, ty, span: v.head().span, is_top_level };\n \n     // If the first pattern is an or-pattern, expand it.\n-    let ret = if v.head().is_or_pat() {\n+    let ret = if is_or_pat(v.head()) {\n         debug!(\"expanding or-pattern\");\n         let v_head = v.head();\n         let vs: Vec<_> = v.expand_or_pat().collect();\n@@ -1174,7 +1172,7 @@ fn is_useful<'p, 'tcx>(\n #[derive(Clone, Copy)]\n crate struct MatchArm<'p, 'tcx> {\n     /// The pattern must have been lowered through `check_match::MatchVisitor::lower_pattern`.\n-    crate pat: &'p super::Pat<'tcx>,\n+    crate pat: &'p Pat<'tcx>,\n     crate hir_id: HirId,\n     crate has_guard: bool,\n }\n@@ -1196,7 +1194,7 @@ crate struct UsefulnessReport<'p, 'tcx> {\n     crate arm_usefulness: Vec<(MatchArm<'p, 'tcx>, Reachability)>,\n     /// If the match is exhaustive, this is empty. If not, this contains witnesses for the lack of\n     /// exhaustiveness.\n-    crate non_exhaustiveness_witnesses: Vec<super::Pat<'tcx>>,\n+    crate non_exhaustiveness_witnesses: Vec<Pat<'tcx>>,\n }\n \n /// The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which\n@@ -1232,7 +1230,7 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n         })\n         .collect();\n \n-    let wild_pattern = cx.pattern_arena.alloc(super::Pat::wildcard_from_ty(scrut_ty));\n+    let wild_pattern = cx.pattern_arena.alloc(Pat::wildcard_from_ty(scrut_ty));\n     let v = PatStack::from_pattern(wild_pattern);\n     let usefulness = is_useful(cx, &matrix, &v, ConstructWitness, scrut_hir_id, false, true);\n     let non_exhaustiveness_witnesses = match usefulness {"}, {"sha": "1a60b1de7fd984e44237ccc53cffdbf1f1230cf6", "filename": "compiler/rustc_mir_build/src/thir/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fvisit.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -1,4 +1,5 @@\n-use crate::thir::*;\n+use rustc_middle::thir::*;\n+use rustc_middle::ty::Const;\n \n pub trait Visitor<'a, 'tcx: 'a>: Sized {\n     fn thir(&self) -> &'a Thir<'tcx>;"}, {"sha": "fc37822cb7b6c018f3dd59e5eb0ee91cce2cec4d", "filename": "src/test/ui/async-await/async-unsafe-fn-call-in-safe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/src%2Ftest%2Fui%2Fasync-await%2Fasync-unsafe-fn-call-in-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/src%2Ftest%2Fui%2Fasync-await%2Fasync-unsafe-fn-call-in-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-unsafe-fn-call-in-safe.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -16,6 +16,6 @@ async fn g() {\n }\n \n fn main() {\n-    S::f(); //~ ERROR call to unsafe function is unsafe\n-    f(); //~ ERROR call to unsafe function is unsafe\n+    S::f(); //[mir]~ ERROR call to unsafe function is unsafe\n+    f(); //[mir]~ ERROR call to unsafe function is unsafe\n }"}, {"sha": "21ba45d7f1e15fbebaa8d44b89c58f5c5dbdc684", "filename": "src/test/ui/async-await/async-unsafe-fn-call-in-safe.thir.stderr", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/src%2Ftest%2Fui%2Fasync-await%2Fasync-unsafe-fn-call-in-safe.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/src%2Ftest%2Fui%2Fasync-await%2Fasync-unsafe-fn-call-in-safe.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-unsafe-fn-call-in-safe.thir.stderr?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -14,22 +14,6 @@ LL |     f();\n    |\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n \n-error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/async-unsafe-fn-call-in-safe.rs:19:5\n-   |\n-LL |     S::f();\n-   |     ^^^^^^ call to unsafe function\n-   |\n-   = note: consult the function's documentation for information on how to avoid undefined behavior\n-\n-error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/async-unsafe-fn-call-in-safe.rs:20:5\n-   |\n-LL |     f();\n-   |     ^^^ call to unsafe function\n-   |\n-   = note: consult the function's documentation for information on how to avoid undefined behavior\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0133`."}, {"sha": "031e67a1e3c3f18dcf7f199406a6e977f966ca69", "filename": "src/test/ui/consts/const-extern-fn/const-extern-fn-requires-unsafe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-requires-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-requires-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-requires-unsafe.rs?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -9,5 +9,5 @@ fn main() {\n     let a: [u8; foo()];\n     //~^ ERROR call to unsafe function is unsafe and requires unsafe function or block\n     foo();\n-    //~^ ERROR call to unsafe function is unsafe and requires unsafe function or block\n+    //[mir]~^ ERROR call to unsafe function is unsafe and requires unsafe function or block\n }"}, {"sha": "c6077da768baca3007784029d9389ae9881516f0", "filename": "src/test/ui/consts/const-extern-fn/const-extern-fn-requires-unsafe.thir.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-requires-unsafe.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-requires-unsafe.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-requires-unsafe.thir.stderr?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -1,11 +1,3 @@\n-error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/const-extern-fn-requires-unsafe.rs:11:5\n-   |\n-LL |     foo();\n-   |     ^^^^^ call to unsafe function\n-   |\n-   = note: consult the function's documentation for information on how to avoid undefined behavior\n-\n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n   --> $DIR/const-extern-fn-requires-unsafe.rs:9:17\n    |\n@@ -14,6 +6,6 @@ LL |     let a: [u8; foo()];\n    |\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0133`."}, {"sha": "df0de7a959030649f4536062140bb05726c6c7ec", "filename": "src/test/ui/feature-gates/feature-gate-const_fn_transmute.thir.stderr", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_fn_transmute.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_fn_transmute.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_fn_transmute.thir.stderr?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -58,6 +58,14 @@ LL | const unsafe fn unsafe_transmute_fn_core_intrinsic() -> u32 { core::intrins\n    = help: add `#![feature(const_fn_transmute)]` to the crate attributes to enable\n    = note: `transmute` is only allowed in constants and statics for now\n \n+error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n+  --> $DIR/feature-gate-const_fn_transmute.rs:29:39\n+   |\n+LL | const fn safe_transmute_fn() -> u32 { mem::transmute(Foo(3)) }\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n error[E0658]: `transmute` is not allowed in constant functions\n   --> $DIR/feature-gate-const_fn_transmute.rs:29:39\n    |\n@@ -68,49 +76,41 @@ LL | const fn safe_transmute_fn() -> u32 { mem::transmute(Foo(3)) }\n    = help: add `#![feature(const_fn_transmute)]` to the crate attributes to enable\n    = note: `transmute` is only allowed in constants and statics for now\n \n-error[E0658]: `transmute` is not allowed in constant functions\n+error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n   --> $DIR/feature-gate-const_fn_transmute.rs:33:49\n    |\n LL | const fn safe_transmute_fn_intrinsic() -> u32 { std::intrinsics::transmute(Foo(3)) }\n-   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n    |\n-   = note: see issue #53605 <https://github.com/rust-lang/rust/issues/53605> for more information\n-   = help: add `#![feature(const_fn_transmute)]` to the crate attributes to enable\n-   = note: `transmute` is only allowed in constants and statics for now\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n \n error[E0658]: `transmute` is not allowed in constant functions\n-  --> $DIR/feature-gate-const_fn_transmute.rs:37:54\n+  --> $DIR/feature-gate-const_fn_transmute.rs:33:49\n    |\n-LL | const fn safe_transmute_fn_core_intrinsic() -> u32 { core::intrinsics::transmute(Foo(3)) }\n-   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | const fn safe_transmute_fn_intrinsic() -> u32 { std::intrinsics::transmute(Foo(3)) }\n+   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #53605 <https://github.com/rust-lang/rust/issues/53605> for more information\n    = help: add `#![feature(const_fn_transmute)]` to the crate attributes to enable\n    = note: `transmute` is only allowed in constants and statics for now\n \n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/feature-gate-const_fn_transmute.rs:29:39\n-   |\n-LL | const fn safe_transmute_fn() -> u32 { mem::transmute(Foo(3)) }\n-   |                                       ^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n-   |\n-   = note: consult the function's documentation for information on how to avoid undefined behavior\n-\n-error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/feature-gate-const_fn_transmute.rs:33:49\n+  --> $DIR/feature-gate-const_fn_transmute.rs:37:54\n    |\n-LL | const fn safe_transmute_fn_intrinsic() -> u32 { std::intrinsics::transmute(Foo(3)) }\n-   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n+LL | const fn safe_transmute_fn_core_intrinsic() -> u32 { core::intrinsics::transmute(Foo(3)) }\n+   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n    |\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n \n-error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n+error[E0658]: `transmute` is not allowed in constant functions\n   --> $DIR/feature-gate-const_fn_transmute.rs:37:54\n    |\n LL | const fn safe_transmute_fn_core_intrinsic() -> u32 { core::intrinsics::transmute(Foo(3)) }\n-   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n+   |                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: consult the function's documentation for information on how to avoid undefined behavior\n+   = note: see issue #53605 <https://github.com/rust-lang/rust/issues/53605> for more information\n+   = help: add `#![feature(const_fn_transmute)]` to the crate attributes to enable\n+   = note: `transmute` is only allowed in constants and statics for now\n \n error: aborting due to 12 previous errors\n "}, {"sha": "435334c322808bbf92107c9a36a0cc378cf2a5c8", "filename": "src/test/ui/issues/issue-16538.thir.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/src%2Ftest%2Fui%2Fissues%2Fissue-16538.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d568d63b1f9f5fc47e4202e2a2a84142ff6202d8/src%2Ftest%2Fui%2Fissues%2Fissue-16538.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16538.thir.stderr?ref=d568d63b1f9f5fc47e4202e2a2a84142ff6202d8", "patch": "@@ -1,3 +1,11 @@\n+error[E0133]: use of extern static is unsafe and requires unsafe function or block\n+  --> $DIR/issue-16538.rs:14:34\n+   |\n+LL | static foo: *const Y::X = Y::foo(Y::x as *const Y::X);\n+   |                                  ^^^^ use of extern static\n+   |\n+   = note: extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+\n error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n   --> $DIR/issue-16538.rs:14:27\n    |\n@@ -13,14 +21,6 @@ LL | static foo: *const Y::X = Y::foo(Y::x as *const Y::X);\n    = help: the trait `Sync` is not implemented for `*const usize`\n    = note: shared static variables must have a type that implements `Sync`\n \n-error[E0133]: use of extern static is unsafe and requires unsafe function or block\n-  --> $DIR/issue-16538.rs:14:34\n-   |\n-LL | static foo: *const Y::X = Y::foo(Y::x as *const Y::X);\n-   |                                  ^^^^ use of extern static\n-   |\n-   = note: extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n-\n error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0015, E0133, E0277."}]}