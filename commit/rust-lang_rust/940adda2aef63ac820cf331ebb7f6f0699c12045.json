{"sha": "940adda2aef63ac820cf331ebb7f6f0699c12045", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MGFkZGEyYWVmNjNhYzgyMGNmMzMxZWJiN2Y2ZjA2OTljMTIwNDU=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-02-16T18:36:47Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-03-14T22:04:40Z"}, "message": "Move specialization graph walks to iterators; make associated type\nprojection sensitive to \"mode\" (most importantly, trans vs middle).\n\nThis commit introduces several pieces of iteration infrastructure in the\nspecialization graph data structure, as well as various helpers for\nfinding the definition of a given item, given its kind and name.\n\nIn addition, associated type projection is now *mode-sensitive*, with\nthree possible modes:\n\n- **Topmost**. This means that projection is only possible if there is a\n    non-`default` definition of the associated type directly on the\n    selected impl. This mode is a bit of a hack: it's used during early\n    coherence checking before we have built the specialization\n    graph (and therefore before we can walk up the specialization\n    parents to find other definitions). Eventually, this should be\n    replaced with a less \"staged\" construction of the specialization\n    graph.\n\n- **AnyFinal**. Projection succeeds for any non-`default` associated\n    type definition, even if it is defined by a parent impl. Used\n    throughout typechecking.\n\n- **Any**. Projection always succeeds. Used by trans.\n\nThe lasting distinction here is between `AnyFinal` and `Any` -- we wish\nto treat `default` associated types opaquely for typechecking purposes.\n\nIn addition to the above, the commit includes a few other minor review fixes.", "tree": {"sha": "844f0e38e37dbd31a78a2659076c7d2b38789869", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/844f0e38e37dbd31a78a2659076c7d2b38789869"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/940adda2aef63ac820cf331ebb7f6f0699c12045", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/940adda2aef63ac820cf331ebb7f6f0699c12045", "html_url": "https://github.com/rust-lang/rust/commit/940adda2aef63ac820cf331ebb7f6f0699c12045", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/940adda2aef63ac820cf331ebb7f6f0699c12045/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "462c83e272e2ba268aaf11ef00e9d47c52011b90", "url": "https://api.github.com/repos/rust-lang/rust/commits/462c83e272e2ba268aaf11ef00e9d47c52011b90", "html_url": "https://github.com/rust-lang/rust/commit/462c83e272e2ba268aaf11ef00e9d47c52011b90"}], "stats": {"total": 1639, "additions": 989, "deletions": 650}, "files": [{"sha": "bc3d3e48d6b1af2758660157f57eb080084cbfc9", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -10,6 +10,7 @@\n \n //! See `README.md` for high-level documentation\n \n+use super::build_selcx;\n use super::{SelectionContext, Obligation, ObligationCause};\n use super::util;\n \n@@ -36,7 +37,7 @@ pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n            impl1_def_id,\n            impl2_def_id);\n \n-    let selcx = &mut SelectionContext::intercrate(infcx);\n+    let selcx = &mut build_selcx(infcx).project_topmost().intercrate().build();\n     overlap(selcx, impl1_def_id, impl2_def_id)\n }\n "}, {"sha": "d9fc53ff2c261a8d5d6ad5f65ea657836fb05af5", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -45,13 +45,11 @@ pub use self::object_safety::object_safety_violations;\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::is_vtable_safe_method;\n-pub use self::select::EvaluationCache;\n-pub use self::select::SelectionContext;\n-pub use self::select::SelectionCache;\n+pub use self::select::{EvaluationCache, SelectionContextBuilder, build_selcx};\n+pub use self::select::{ProjectionMode, SelectionContext, SelectionCache};\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n-pub use self::specialize::{Overlap, SpecializationGraph, specializes};\n-pub use self::specialize::{ItemSource, get_impl_item_or_default, get_parent_impl_item};\n+pub use self::specialize::{Overlap, specialization_graph, specializes, translate_substs};\n pub use self::util::elaborate_predicates;\n pub use self::util::get_vtable_index_of_object_method;\n pub use self::util::trait_ref_for_builtin_bound;"}, {"sha": "20d6c0b6fc0384f0b6b56f31690f424d45dd332e", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 100, "deletions": 45, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -11,8 +11,9 @@\n //! Code for projecting associated types out of trait references.\n \n use super::elaborate_predicates;\n-use super::get_impl_item_or_default;\n use super::report_overflow_error;\n+use super::specialization_graph;\n+use super::translate_substs;\n use super::Obligation;\n use super::ObligationCause;\n use super::PredicateObligation;\n@@ -22,14 +23,18 @@ use super::VtableClosureData;\n use super::VtableImplData;\n use super::util;\n \n+use middle::def_id::DefId;\n use middle::infer::{self, TypeOrigin};\n use middle::subst::Subst;\n use middle::ty::{self, ToPredicate, RegionEscape, HasTypeFlags, ToPolyTraitRef, Ty, TyCtxt};\n use middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_front::hir;\n use syntax::parse::token;\n+use syntax::ast;\n use util::common::FN_OUTPUT_NAME;\n \n+use std::rc::Rc;\n+\n pub type PolyProjectionObligation<'tcx> =\n     Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n \n@@ -568,7 +573,49 @@ fn project_type<'cx,'tcx>(\n \n     assert!(candidates.vec.len() <= 1);\n \n-    match candidates.vec.pop() {\n+    let possible_candidate = candidates.vec.pop().and_then(|candidate| {\n+        // In Any (i.e. trans) mode, all projections succeed;\n+        // otherwise, we need to be sensitive to `default` and\n+        // specialization.\n+        if !selcx.projection_mode().any() {\n+            if let ProjectionTyCandidate::Impl(ref impl_data) = candidate {\n+                if let Some(node_item) = assoc_ty_def(selcx,\n+                                                      impl_data.impl_def_id,\n+                                                      obligation.predicate.item_name) {\n+                    if node_item.node.is_from_trait() {\n+                        if node_item.item.ty.is_some() {\n+                            // If the associated type has a default from the\n+                            // trait, that should be considered `default` and\n+                            // hence not projected.\n+                            //\n+                            // Note, however, that we allow a projection from\n+                            // the trait specifically in the case that the trait\n+                            // does *not* give a default. This is purely to\n+                            // avoid spurious errors: the situation can only\n+                            // arise when *no* impl in the specialization chain\n+                            // has provided a definition for the type. When we\n+                            // confirm the candidate, we'll turn the projection\n+                            // into a TyError, since the actual error will be\n+                            // reported in `check_impl_items_against_trait`.\n+                            return None;\n+                        }\n+                    } else if node_item.item.defaultness.is_default() {\n+                        return None;\n+                    }\n+                } else {\n+                    // Normally this situation could only arise througha\n+                    // compiler bug, but at coherence-checking time we only look\n+                    // at the topmost impl (we don't even consider the trait\n+                    // itself) for the definition -- so we can fail to find a\n+                    // definition of the type even if it exists.\n+                    return None;\n+                }\n+            }\n+        }\n+        Some(candidate)\n+    });\n+\n+    match possible_candidate {\n         Some(candidate) => {\n             let (ty, obligations) = confirm_candidate(selcx, obligation, candidate);\n             Ok(ProjectedTy::Progress(ty, obligations))\n@@ -744,28 +791,6 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n \n     match vtable {\n         super::VtableImpl(data) => {\n-            if data.substs.types.needs_infer() {\n-                let assoc_ty_opt = get_impl_item_or_default(selcx.tcx(), data.impl_def_id, |cand| {\n-                    if let &ty::TypeTraitItem(ref assoc_ty) = cand {\n-                        if assoc_ty.name == obligation.predicate.item_name {\n-                            return Some(assoc_ty.defaultness);\n-                        }\n-                    }\n-                    None\n-                });\n-\n-                if let Some((defaultness, source)) = assoc_ty_opt {\n-                    if !source.is_from_trait() && defaultness == hir::Defaultness::Default {\n-                        // FIXME: is it OK to not mark as ambiguous?\n-                        return Ok(());\n-                    }\n-                } else {\n-                    selcx.tcx().sess.span_bug(obligation.cause.span,\n-                                              &format!(\"No associated type for {:?}\",\n-                                                       obligation_trait_ref));\n-                }\n-            }\n-\n             debug!(\"assemble_candidates_from_impls: impl candidate {:?}\",\n                    data);\n \n@@ -967,29 +992,59 @@ fn confirm_impl_candidate<'cx,'tcx>(\n {\n     let VtableImplData { substs, nested, impl_def_id } = impl_vtable;\n \n-    get_impl_item_or_default(selcx.tcx(), impl_def_id, |cand| {\n-        if let &ty::TypeTraitItem(ref assoc_ty) = cand {\n-            if assoc_ty.name == obligation.predicate.item_name {\n-                if let Some(ty) = assoc_ty.ty {\n-                    return Some(ty)\n-                } else {\n-                    // This means that the impl is missing a definition for the\n-                    // associated type. This error will be reported by the type\n-                    // checker method `check_impl_items_against_trait`, so here\n-                    // we just return TyError.\n-                    debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n-                           assoc_ty.name,\n-                           obligation.predicate.trait_ref);\n-                    return Some(selcx.tcx().types.err);\n+    let tcx = selcx.tcx();\n+    let trait_ref = obligation.predicate.trait_ref;\n+    let assoc_ty = assoc_ty_def(selcx, impl_def_id, obligation.predicate.item_name);\n+\n+    match assoc_ty {\n+        Some(node_item) => {\n+            let ty = node_item.item.ty.unwrap_or_else(|| {\n+                // This means that the impl is missing a definition for the\n+                // associated type. This error will be reported by the type\n+                // checker method `check_impl_items_against_trait`, so here we\n+                // just return TyError.\n+                debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n+                       node_item.item.name,\n+                       obligation.predicate.trait_ref);\n+                tcx.types.err\n+            });\n+            let substs = translate_substs(tcx, impl_def_id, substs, node_item.node);\n+            (ty.subst(tcx, &substs), nested)\n+        }\n+        None => {\n+            tcx.sess.span_bug(obligation.cause.span,\n+                              &format!(\"No associated type for {:?}\", trait_ref));\n+        }\n+    }\n+}\n+\n+/// Locate the definition of an associated type in the specialization hierarchy,\n+/// starting from the given impl.\n+///\n+/// Based on the \"projection mode\", this lookup may in fact only examine the\n+/// topmost impl. See the comments for `ProjectionMode` for more details.\n+fn assoc_ty_def<'cx, 'tcx>(selcx: &SelectionContext<'cx, 'tcx>, impl_def_id: DefId, assoc_ty_name: ast::Name)\n+                           -> Option<specialization_graph::NodeItem<Rc<ty::AssociatedType<'tcx>>>>\n+{\n+    let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n+\n+    if selcx.projection_mode().topmost() {\n+        let impl_node = specialization_graph::Node::Impl(impl_def_id);\n+        for item in impl_node.items(selcx.tcx()) {\n+            if let ty::TypeTraitItem(assoc_ty) = item {\n+                if assoc_ty.name == assoc_ty_name {\n+                    return Some(specialization_graph::NodeItem {\n+                        node: specialization_graph::Node::Impl(impl_def_id),\n+                        item: assoc_ty,\n+                    });\n                 }\n             }\n         }\n         None\n-    }).map(|(ty, source)| {\n-        (ty.subst(selcx.tcx(), &source.translate_substs(selcx.tcx(), substs)), nested)\n-    }).unwrap_or_else(|| {\n-        selcx.tcx().sess.span_bug(obligation.cause.span,\n-                                  &format!(\"No associated type for {:?}\",\n-                                           obligation.predicate.trait_ref));\n-    })\n+    } else {\n+        selcx.tcx().lookup_trait_def(trait_def_id)\n+            .ancestors(impl_def_id)\n+            .type_defs(selcx.tcx(), assoc_ty_name)\n+            .next()\n+    }\n }"}, {"sha": "83e02d16c3b81889480a9436b6492a661b0fd469", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 132, "deletions": 14, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -76,8 +76,99 @@ pub struct SelectionContext<'cx, 'tcx:'cx> {\n     /// other words, we consider `$0 : Bar` to be unimplemented if\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n-\n     intercrate: bool,\n+\n+    /// Sadly, the behavior of projection varies a bit depending on the\n+    /// stage of compilation. The specifics are given in the\n+    /// documentation for `ProjectionMode`.\n+    projection_mode: ProjectionMode,\n+}\n+\n+/// Depending on the stage of compilation, we want projection to be\n+/// more or less conservative.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum ProjectionMode {\n+    /// At coherence-checking time, we're still constructing the\n+    /// specialization graph, and thus we only project project\n+    /// non-`default` associated types that are defined directly in\n+    /// the applicable impl. (This behavior should be improved over\n+    /// time, to allow for successful projections modulo cycles\n+    /// between different impls).\n+    // TODO: Add tracking issue to do better here.\n+    ///\n+    /// Here's an example that will fail due to the restriction:\n+    ///\n+    /// ```\n+    /// trait Assoc {\n+    ///     type Output;\n+    /// }\n+    ///\n+    /// impl<T> Assoc for T {\n+    ///     type Output = bool;\n+    /// }\n+    ///\n+    /// impl Assoc for u8 {} // <- inherits the non-default type from above\n+    ///\n+    /// trait Foo {}\n+    /// impl Foo for u32 {}\n+    /// impl Foo for <u8 as Assoc>::Output {}  // <- this projection will fail\n+    /// ```\n+    ///\n+    /// The projection would succeed if `Output` had been defined\n+    /// directly in the impl for `u8`.\n+    // TODO: Add test\n+    Topmost,\n+\n+    /// At type-checking time, we refuse to project any associated\n+    /// type that is marked `default`. Non-`default` (\"final\") types\n+    /// are always projected. This is necessary in general for\n+    /// soundness of specialization. However, we *could* allow\n+    /// projections in fully-monomorphic cases. We choose not to,\n+    /// because we prefer for `default type` to force the type\n+    /// definition to be treated abstractly by any consumers of the\n+    /// impl. Concretely, that means that the following example will\n+    /// fail to compile:\n+    ///\n+    /// ```\n+    /// trait Assoc {\n+    ///     type Output;\n+    /// }\n+    ///\n+    /// impl<T> Assoc for T {\n+    ///     default type Output = bool;\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let <() as Assoc>::Output = true;\n+    /// }\n+    // TODO: Add test\n+    AnyFinal,\n+\n+    /// At trans time, all projections will succeed.\n+    Any,\n+}\n+\n+impl ProjectionMode {\n+    pub fn topmost(&self) -> bool {\n+        match *self {\n+            ProjectionMode::Topmost => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn any_final(&self) -> bool {\n+        match *self {\n+            ProjectionMode::AnyFinal => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn any(&self) -> bool {\n+        match *self {\n+            ProjectionMode::Any => true,\n+            _ => false,\n+        }\n+    }\n }\n \n // A stack that walks back up the stack frame.\n@@ -257,22 +348,45 @@ pub struct EvaluationCache<'tcx> {\n     hashmap: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n }\n \n-impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n-    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>)\n-               -> SelectionContext<'cx, 'tcx> {\n-        SelectionContext {\n-            infcx: infcx,\n-            freshener: infcx.freshener(),\n-            intercrate: false,\n-        }\n+pub struct SelectionContextBuilder<'cx, 'tcx: 'cx>(SelectionContext<'cx, 'tcx>);\n+\n+impl<'cx, 'tcx> SelectionContextBuilder<'cx, 'tcx> {\n+    pub fn intercrate(mut self) -> Self {\n+        self.0.intercrate = true;\n+        self\n     }\n \n-    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>)\n-                      -> SelectionContext<'cx, 'tcx> {\n+    pub fn project_any(mut self) -> Self {\n+        self.0.projection_mode = ProjectionMode::Any;\n+        self\n+    }\n+\n+    pub fn project_any_final(mut self) -> Self {\n+        self.0.projection_mode = ProjectionMode::AnyFinal;\n+        self\n+    }\n+\n+    pub fn project_topmost(mut self) -> Self {\n+        self.0.projection_mode = ProjectionMode::Topmost;\n+        self\n+    }\n+\n+    pub fn build(self) -> SelectionContext<'cx, 'tcx> {\n+        self.0\n+    }\n+}\n+\n+pub fn build_selcx<'cx, 'tcx>(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContextBuilder<'cx, 'tcx> {\n+    SelectionContextBuilder(SelectionContext::new(infcx))\n+}\n+\n+impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n+    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n             freshener: infcx.freshener(),\n-            intercrate: true,\n+            intercrate: false,\n+            projection_mode: ProjectionMode::AnyFinal,\n         }\n     }\n \n@@ -292,6 +406,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx\n     }\n \n+    pub fn projection_mode(&self) -> ProjectionMode {\n+        self.projection_mode\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Selection\n     //\n@@ -565,7 +683,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // this crate, perhaps the type would be unified with\n         // something from another crate that does provide an impl.\n         //\n-        // In intracrate mode, we must still be conservative. The reason is\n+        // In intra mode, we must still be conservative. The reason is\n         // that we want to avoid cycles. Imagine an impl like:\n         //\n         //     impl<T:Eq> Eq for Vec<T>\n@@ -780,7 +898,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         if !self.is_knowable(stack) {\n-            debug!(\"intercrate not knowable\");\n+            debug!(\"coherence stage: not knowable\");\n             return Ok(None);\n         }\n "}, {"sha": "2c501c1a48103b6bfab3e7a9d264cb2180890ff6", "filename": "src/librustc/middle/traits/specialize.rs", "status": "removed", "additions": 0, "deletions": 454, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/462c83e272e2ba268aaf11ef00e9d47c52011b90/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/462c83e272e2ba268aaf11ef00e9d47c52011b90/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize.rs?ref=462c83e272e2ba268aaf11ef00e9d47c52011b90", "patch": "@@ -1,454 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Logic and data structures related to impl specialization, explained in\n-// greater detail below.\n-//\n-// At the moment, this implementation support only the simple \"chain\" rule:\n-// If any two impls overlap, one must be a strict subset of the other.\n-//\n-// See traits/README.md for a bit more detail on how specialization\n-// fits together with the rest of the trait machinery.\n-\n-use super::util;\n-use super::SelectionContext;\n-\n-use middle::cstore::CrateStore;\n-use middle::def_id::DefId;\n-use middle::infer::{self, InferCtxt, TypeOrigin};\n-use middle::region;\n-use middle::subst::{Subst, Substs};\n-use middle::traits;\n-use middle::ty::{self, ImplOrTraitItem};\n-use syntax::codemap::DUMMY_SP;\n-use util::nodemap::DefIdMap;\n-\n-/// A per-trait graph of impls in specialization order.\n-///\n-/// The graph provides two key services:\n-///\n-/// - Construction, which implicitly checks for overlapping impls (i.e., impls\n-///   that overlap but where neither specializes the other -- an artifact of the\n-///   simple \"chain\" rule.\n-///\n-/// - Parent extraction. In particular, the graph can give you the *immediate*\n-///   parents of a given specializing impl, which is needed for extracting\n-///   default items amongst other thigns. In the simple \"chain\" rule, every impl\n-///   has at most one parent.\n-pub struct SpecializationGraph {\n-    // all impls have a parent; the \"root\" impls have as their parent the def_id\n-    // of the trait\n-    parent: DefIdMap<DefId>,\n-\n-    // the \"root\" impls are found by looking up the trait's def_id.\n-    children: DefIdMap<Vec<DefId>>,\n-}\n-\n-/// Information pertinent to an overlapping impl error.\n-pub struct Overlap<'a, 'tcx: 'a> {\n-    pub in_context: InferCtxt<'a, 'tcx>,\n-    pub with_impl: DefId,\n-    pub on_trait_ref: ty::TraitRef<'tcx>,\n-}\n-\n-impl SpecializationGraph {\n-    pub fn new() -> SpecializationGraph {\n-        SpecializationGraph {\n-            parent: Default::default(),\n-            children: Default::default(),\n-        }\n-    }\n-\n-    /// Insert a local impl into the specialization graph. If an existing impl\n-    /// conflicts with it (has overlap, but neither specializes the other),\n-    /// information about the area of overlap is returned in the `Err`.\n-    pub fn insert<'a, 'tcx>(&mut self,\n-                            tcx: &'a ty::ctxt<'tcx>,\n-                            impl_def_id: DefId)\n-                            -> Result<(), Overlap<'a, 'tcx>> {\n-        assert!(impl_def_id.is_local());\n-\n-        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n-        let mut parent = trait_ref.def_id;\n-        let mut my_children = vec![];\n-\n-        // descend the existing tree, looking for the right location to add this impl\n-        'descend: loop {\n-            let mut possible_siblings = self.children.entry(parent).or_insert(vec![]);\n-\n-            for slot in possible_siblings.iter_mut() {\n-                let possible_sibling = *slot;\n-\n-                let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n-                let overlap = traits::overlapping_impls(&infcx, possible_sibling, impl_def_id);\n-\n-                if let Some(trait_ref) = overlap {\n-                    if !tcx.sess.features.borrow().specialization {\n-                        // if specialization is not turned on, all overlaps\n-                        // should immediately trigger an error\n-\n-                        return Err(Overlap {\n-                            with_impl: possible_sibling,\n-                            on_trait_ref: trait_ref,\n-                            in_context: infcx,\n-                        });\n-                    }\n-\n-                    let le = specializes(tcx, impl_def_id, possible_sibling);\n-                    let ge = specializes(tcx, possible_sibling, impl_def_id);\n-\n-                    if le && !ge {\n-                        // the impl specializes possible_sibling\n-                        parent = possible_sibling;\n-                        continue 'descend;\n-                    } else if ge && !le {\n-                        // possible_sibling specializes the impl\n-                        *slot = impl_def_id;\n-                        self.parent.insert(possible_sibling, impl_def_id);\n-                        my_children.push(possible_sibling);\n-                    } else {\n-                        // overlap, but no specialization; error out\n-                        return Err(Overlap {\n-                            with_impl: possible_sibling,\n-                            on_trait_ref: trait_ref,\n-                            in_context: infcx,\n-                        });\n-                    }\n-\n-                    break 'descend;\n-                }\n-            }\n-\n-            // no overlap with any potential siblings, so add as a new sibling\n-            self.parent.insert(impl_def_id, parent);\n-            possible_siblings.push(impl_def_id);\n-            break;\n-        }\n-\n-        if self.children.insert(impl_def_id, my_children).is_some() {\n-            tcx.sess\n-               .bug(\"When inserting an impl into the specialization graph, existing children for \\\n-                     the impl were already present.\");\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Insert cached metadata mapping from a child impl back to its parent.\n-    pub fn record_impl_from_cstore(&mut self, parent: DefId, child: DefId) {\n-        if self.parent.insert(child, parent).is_some() {\n-            panic!(\"When recording an impl from the crate store, information about its parent \\\n-                    was already present.\");\n-        }\n-\n-        self.children.entry(parent).or_insert(vec![]).push(child);\n-    }\n-\n-    /// The parent of a given impl, which is the def id of the trait when the\n-    /// impl is a \"specialization root\".\n-    pub fn parent(&self, child: DefId) -> DefId {\n-        *self.parent.get(&child).unwrap()\n-    }\n-}\n-\n-/// When we have selected one impl, but are actually using item definitions from\n-/// a parent impl providing a default, we need a way to translate between the\n-/// type parameters of the two impls. Here the `source_impl` is the one we've\n-/// selected, and `source_substs` is a substitution of its generics (and possibly\n-/// some relevant `FnSpace` variables as well). And `target_impl` is the impl\n-/// we're actually going to get the definition from.\n-fn translate_substs_between_impls<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                        source_impl: DefId,\n-                                        source_substs: Substs<'tcx>,\n-                                        target_impl: DefId)\n-                                        -> Substs<'tcx> {\n-\n-    // We need to build a subst that covers all the generics of\n-    // `target_impl`. Start by introducing fresh infer variables:\n-    let target_generics = tcx.lookup_item_type(target_impl).generics;\n-    let mut infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n-    let mut target_substs = infcx.fresh_substs_for_generics(DUMMY_SP, &target_generics);\n-    if source_substs.regions.is_erased() {\n-        target_substs = target_substs.erase_regions()\n-    }\n-\n-    if !fulfill_implication(&mut infcx,\n-                            source_impl,\n-                            source_substs.clone(),\n-                            target_impl,\n-                            target_substs.clone()) {\n-        tcx.sess\n-           .bug(\"When translating substitutions for specialization, the expected specializaiton \\\n-                 failed to hold\")\n-    }\n-\n-    // Now resolve the *substitution* we built for the target earlier, replacing\n-    // the inference variables inside with whatever we got from fulfillment. We\n-    // also carry along any FnSpace substitutions, which don't need to be\n-    // adjusted when mapping from one impl to another.\n-    infcx.resolve_type_vars_if_possible(&target_substs)\n-         .with_method_from_subst(&source_substs)\n-}\n-\n-/// When we've selected an impl but need to use an item definition provided by\n-/// the trait itself, we need to translate the substitution applied to the impl\n-/// to one that makes sense for the trait.\n-fn translate_substs_from_impl_to_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                             source_impl: DefId,\n-                                             source_substs: Substs<'tcx>)\n-                                             -> Substs<'tcx> {\n-\n-    let source_trait_ref = tcx.impl_trait_ref(source_impl).unwrap().subst(tcx, &source_substs);\n-\n-    let mut new_substs = source_trait_ref.substs.clone();\n-    if source_substs.regions.is_erased() {\n-        new_substs = new_substs.erase_regions()\n-    }\n-\n-    // Carry any FnSpace substitutions along; they don't need to be adjusted\n-    new_substs.with_method_from_subst(&source_substs)\n-}\n-\n-#[derive(Debug, Copy, Clone)]\n-/// When looking up an item in an impl, it may turn out that the item\n-/// is actually provided as a default by a more generic impl, or by\n-/// the trait itself. This enum says where the item came from.\n-pub enum ItemSource {\n-    Impl {\n-        requested_impl: DefId,\n-        actual_impl: DefId,\n-    },\n-    Trait {\n-        requested_impl: DefId,\n-    },\n-}\n-\n-impl ItemSource {\n-    pub fn is_from_trait(&self) -> bool {\n-        match *self {\n-            ItemSource::Trait { .. } => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Given a subst for the requested impl, translate it to a subst\n-    /// appropriate for the actual item definition (whether it be in that impl,\n-    /// a parent impl, or the trait).\n-    pub fn translate_substs<'tcx>(&self,\n-                                  tcx: &ty::ctxt<'tcx>,\n-                                  requested_impl_substs: Substs<'tcx>)\n-                                  -> Substs<'tcx> {\n-        match *self {\n-            ItemSource::Impl { requested_impl, actual_impl } => {\n-                // no need to translate if we're targetting the impl we started with\n-                if requested_impl == actual_impl {\n-                    return requested_impl_substs;\n-                }\n-\n-                translate_substs_between_impls(tcx,\n-                                               requested_impl,\n-                                               requested_impl_substs,\n-                                               actual_impl)\n-\n-            }\n-            ItemSource::Trait { requested_impl } => {\n-                translate_substs_from_impl_to_trait(tcx, requested_impl, requested_impl_substs)\n-            }\n-        }\n-    }\n-}\n-\n-/// Lookup the definition of an item within `requested_impl` or its specialization\n-/// parents, including provided items from the trait itself.\n-///\n-/// The closure `f` works in the style of `filter_map`.\n-pub fn get_impl_item_or_default<'tcx, I, F>(tcx: &ty::ctxt<'tcx>,\n-                                            requested_impl: DefId,\n-                                            mut f: F)\n-                                            -> Option<(I, ItemSource)>\n-    where F: for<'a> FnMut(&ImplOrTraitItem<'tcx>) -> Option<I>\n-{\n-    let impl_or_trait_items_map = tcx.impl_or_trait_items.borrow();\n-    let trait_def_id = tcx.trait_id_of_impl(requested_impl).unwrap();\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-\n-    // Walk up the specialization tree, looking for a matching item definition\n-\n-    let mut current_impl = requested_impl;\n-    loop {\n-        for impl_item_id in &tcx.impl_items.borrow()[&current_impl] {\n-            let impl_item = &impl_or_trait_items_map[&impl_item_id.def_id()];\n-            if let Some(t) = f(impl_item) {\n-                let source = ItemSource::Impl {\n-                    requested_impl: requested_impl,\n-                    actual_impl: current_impl,\n-                };\n-                return Some((t, source));\n-            }\n-        }\n-\n-        if let Some(parent) = trait_def.parent_of_impl(current_impl) {\n-            current_impl = parent;\n-        } else {\n-            break;\n-        }\n-    }\n-\n-    // The item isn't defined anywhere in the hierarchy. Get the\n-    // default from the trait.\n-\n-    for trait_item in tcx.trait_items(trait_def_id).iter() {\n-        if let Some(t) = f(trait_item) {\n-            return Some((t, ItemSource::Trait { requested_impl: requested_impl }));\n-        }\n-    }\n-\n-    None\n-}\n-\n-/// Convenience function for locating an item defined in a specialization parent, if any.\n-pub fn get_parent_impl_item<'tcx, I, F>(tcx: &ty::ctxt<'tcx>,\n-                                        child_impl: DefId,\n-                                        f: F)\n-                                        -> Option<(I, DefId)>\n-    where F: for<'a> FnMut(&ImplOrTraitItem<'tcx>) -> Option<I>\n-{\n-    let trait_def_id = tcx.trait_id_of_impl(child_impl).unwrap();\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-\n-    trait_def.parent_of_impl(child_impl)\n-             .and_then(|parent_impl| get_impl_item_or_default(tcx, parent_impl, f))\n-             .and_then(|(item, source)| {\n-                 match source {\n-                     ItemSource::Trait { .. } => None,\n-                     ItemSource::Impl { actual_impl, .. } => Some((item, actual_impl)),\n-                 }\n-             })\n-}\n-\n-fn skolemizing_subst_for_impl<'a>(tcx: &ty::ctxt<'a>, impl_def_id: DefId) -> Substs<'a> {\n-    let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n-\n-    let types = impl_generics.types.map(|def| tcx.mk_param_from_def(def));\n-\n-    // FIXME: figure out what we actually want here\n-    let regions = impl_generics.regions.map(|_| ty::Region::ReStatic);\n-    // |d| infcx.next_region_var(infer::RegionVariableOrigin::EarlyBoundRegion(span, d.name)));\n-\n-    Substs::new(types, regions)\n-}\n-\n-/// Is impl1 a specialization of impl2?\n-///\n-/// Specialization is determined by the sets of types to which the impls apply;\n-/// impl1 specializes impl2 if it applies to a subset of the types impl2 applies\n-/// to.\n-pub fn specializes(tcx: &ty::ctxt, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n-    // We determine whether there's a subset relationship by:\n-    //\n-    // - skolemizing impl1,\n-    // - instantiating impl2 with fresh inference variables,\n-    // - assuming the where clauses for impl1,\n-    // - unifying,\n-    // - attempting to prove the where clauses for impl2\n-    //\n-    // The last three steps are essentially checking for an implication between two impls\n-    // after appropriate substitutions. This is what `fulfill_implication` checks for.\n-    //\n-    // See RFC 1210 for more details and justification.\n-\n-    let mut infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n-\n-    let impl1_substs = skolemizing_subst_for_impl(tcx, impl1_def_id);\n-    let impl2_substs = util::fresh_type_vars_for_impl(&infcx, DUMMY_SP, impl2_def_id);\n-\n-    fulfill_implication(&mut infcx,\n-                        impl1_def_id,\n-                        impl1_substs,\n-                        impl2_def_id,\n-                        impl2_substs)\n-}\n-\n-/// Does impl1 (instantiated with the impl1_substs) imply impl2\n-/// (instantiated with impl2_substs)?\n-///\n-/// Mutates the `infcx` in two ways:\n-/// - by adding the obligations of impl1 to the parameter environment\n-/// - via fulfillment, so that if the implication holds the various unifications\n-fn fulfill_implication<'a, 'tcx>(infcx: &mut InferCtxt<'a, 'tcx>,\n-                                 impl1_def_id: DefId,\n-                                 impl1_substs: Substs<'tcx>,\n-                                 impl2_def_id: DefId,\n-                                 impl2_substs: Substs<'tcx>)\n-                                 -> bool {\n-    let tcx = &infcx.tcx;\n-\n-    let (impl1_trait_ref, impl1_obligations) = {\n-        let selcx = &mut SelectionContext::new(&infcx);\n-        util::impl_trait_ref_and_oblig(selcx, impl1_def_id, &impl1_substs)\n-    };\n-\n-    let impl1_predicates: Vec<_> = impl1_obligations.iter()\n-                                                    .cloned()\n-                                                    .map(|oblig| oblig.predicate)\n-                                                    .collect();\n-\n-    infcx.parameter_environment = ty::ParameterEnvironment {\n-        tcx: tcx,\n-        free_substs: impl1_substs,\n-        implicit_region_bound: ty::ReEmpty, // FIXME: is this OK?\n-        caller_bounds: impl1_predicates,\n-        selection_cache: traits::SelectionCache::new(),\n-        evaluation_cache: traits::EvaluationCache::new(),\n-        free_id_outlive: region::DUMMY_CODE_EXTENT, // FIXME: is this OK?\n-    };\n-\n-    let selcx = &mut SelectionContext::new(&infcx);\n-    let (impl2_trait_ref, impl2_obligations) = util::impl_trait_ref_and_oblig(selcx,\n-                                                                              impl2_def_id,\n-                                                                              &impl2_substs);\n-\n-    // do the impls unify? If not, no specialization.\n-    if let Err(_) = infer::mk_eq_trait_refs(&infcx,\n-                                            true,\n-                                            TypeOrigin::Misc(DUMMY_SP),\n-                                            impl1_trait_ref,\n-                                            impl2_trait_ref) {\n-        debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n-               impl1_trait_ref,\n-               impl2_trait_ref);\n-        return false;\n-    }\n-\n-    let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n-\n-    // attempt to prove all of the predicates for impl2 given those for impl1\n-    // (which are packed up in penv)\n-\n-    for oblig in impl2_obligations.into_iter() {\n-        fulfill_cx.register_predicate_obligation(&infcx, oblig);\n-    }\n-\n-    if let Err(errors) = infer::drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()) {\n-        // no dice!\n-        debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n-                {:?}\",\n-               impl1_trait_ref,\n-               impl2_trait_ref,\n-               errors,\n-               infcx.parameter_environment.caller_bounds);\n-        false\n-    } else {\n-        debug!(\"fulfill_implication: an impl for {:?} specializes {:?} (`where` clauses elided)\",\n-               impl1_trait_ref,\n-               impl2_trait_ref);\n-        true\n-    }\n-}"}, {"sha": "2dc4926736e602607dcc43dac9925eec772e8fe6", "filename": "src/librustc/middle/traits/specialize/mod.rs", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fmod.rs?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -0,0 +1,244 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Logic and data structures related to impl specialization, explained in\n+// greater detail below.\n+//\n+// At the moment, this implementation support only the simple \"chain\" rule:\n+// If any two impls overlap, one must be a strict subset of the other.\n+//\n+// See traits/README.md for a bit more detail on how specialization\n+// fits together with the rest of the trait machinery.\n+\n+use super::{util, build_selcx, SelectionContext};\n+\n+use middle::cstore::CrateStore;\n+use middle::def_id::DefId;\n+use middle::infer::{self, InferCtxt, TypeOrigin};\n+use middle::region;\n+use middle::subst::{Subst, Substs};\n+use middle::traits;\n+use middle::ty;\n+use syntax::codemap::DUMMY_SP;\n+\n+pub mod specialization_graph;\n+\n+/// Information pertinent to an overlapping impl error.\n+pub struct Overlap<'a, 'tcx: 'a> {\n+    pub in_context: InferCtxt<'a, 'tcx>,\n+    pub with_impl: DefId,\n+    pub on_trait_ref: ty::TraitRef<'tcx>,\n+}\n+\n+/// Given a subst for the requested impl, translate it to a subst\n+/// appropriate for the actual item definition (whether it be in that impl,\n+/// a parent impl, or the trait).\n+pub fn translate_substs<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              from_impl: DefId,\n+                              from_impl_substs: Substs<'tcx>,\n+                              to_node: specialization_graph::Node)\n+                              -> Substs<'tcx> {\n+    match to_node {\n+        specialization_graph::Node::Impl(to_impl) => {\n+            // no need to translate if we're targetting the impl we started with\n+            if from_impl == to_impl {\n+                return from_impl_substs;\n+            }\n+\n+            translate_substs_between_impls(tcx, from_impl, from_impl_substs, to_impl)\n+\n+        }\n+        specialization_graph::Node::Trait(..) => {\n+            translate_substs_from_impl_to_trait(tcx, from_impl, from_impl_substs)\n+        }\n+    }\n+}\n+\n+/// When we have selected one impl, but are actually using item definitions from\n+/// a parent impl providing a default, we need a way to translate between the\n+/// type parameters of the two impls. Here the `source_impl` is the one we've\n+/// selected, and `source_substs` is a substitution of its generics (and possibly\n+/// some relevant `FnSpace` variables as well). And `target_impl` is the impl\n+/// we're actually going to get the definition from.\n+fn translate_substs_between_impls<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                        source_impl: DefId,\n+                                        source_substs: Substs<'tcx>,\n+                                        target_impl: DefId)\n+                                        -> Substs<'tcx> {\n+\n+    // We need to build a subst that covers all the generics of\n+    // `target_impl`. Start by introducing fresh infer variables:\n+    let target_generics = tcx.lookup_item_type(target_impl).generics;\n+    let mut infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n+    let mut target_substs = infcx.fresh_substs_for_generics(DUMMY_SP, &target_generics);\n+    if source_substs.regions.is_erased() {\n+        target_substs = target_substs.erase_regions()\n+    }\n+\n+    if !fulfill_implication(&mut infcx,\n+                            source_impl,\n+                            source_substs.clone(),\n+                            target_impl,\n+                            target_substs.clone()) {\n+        tcx.sess\n+           .bug(\"When translating substitutions for specialization, the expected specializaiton \\\n+                 failed to hold\")\n+    }\n+\n+    // Now resolve the *substitution* we built for the target earlier, replacing\n+    // the inference variables inside with whatever we got from fulfillment. We\n+    // also carry along any FnSpace substitutions, which don't need to be\n+    // adjusted when mapping from one impl to another.\n+    infcx.resolve_type_vars_if_possible(&target_substs)\n+         .with_method_from_subst(&source_substs)\n+}\n+\n+/// When we've selected an impl but need to use an item definition provided by\n+/// the trait itself, we need to translate the substitution applied to the impl\n+/// to one that makes sense for the trait.\n+fn translate_substs_from_impl_to_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                             source_impl: DefId,\n+                                             source_substs: Substs<'tcx>)\n+                                             -> Substs<'tcx> {\n+\n+    let source_trait_ref = tcx.impl_trait_ref(source_impl).unwrap().subst(tcx, &source_substs);\n+\n+    let mut new_substs = source_trait_ref.substs.clone();\n+    if source_substs.regions.is_erased() {\n+        new_substs = new_substs.erase_regions()\n+    }\n+\n+    // Carry any FnSpace substitutions along; they don't need to be adjusted\n+    new_substs.with_method_from_subst(&source_substs)\n+}\n+\n+fn skolemizing_subst_for_impl<'a>(tcx: &ty::ctxt<'a>, impl_def_id: DefId) -> Substs<'a> {\n+    let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n+\n+    let types = impl_generics.types.map(|def| tcx.mk_param_from_def(def));\n+\n+    // FIXME: figure out what we actually want here\n+    let regions = impl_generics.regions.map(|_| ty::Region::ReStatic);\n+    // |d| infcx.next_region_var(infer::RegionVariableOrigin::EarlyBoundRegion(span, d.name)));\n+\n+    Substs::new(types, regions)\n+}\n+\n+/// Is impl1 a specialization of impl2?\n+///\n+/// Specialization is determined by the sets of types to which the impls apply;\n+/// impl1 specializes impl2 if it applies to a subset of the types impl2 applies\n+/// to.\n+pub fn specializes(tcx: &ty::ctxt, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n+    if !tcx.sess.features.borrow().specialization {\n+        return false;\n+    }\n+\n+    // We determine whether there's a subset relationship by:\n+    //\n+    // - skolemizing impl1,\n+    // - instantiating impl2 with fresh inference variables,\n+    // - assuming the where clauses for impl1,\n+    // - unifying,\n+    // - attempting to prove the where clauses for impl2\n+    //\n+    // The last three steps are essentially checking for an implication between two impls\n+    // after appropriate substitutions. This is what `fulfill_implication` checks for.\n+    //\n+    // See RFC 1210 for more details and justification.\n+\n+    let mut infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n+\n+    let impl1_substs = skolemizing_subst_for_impl(tcx, impl1_def_id);\n+    let impl2_substs = util::fresh_type_vars_for_impl(&infcx, DUMMY_SP, impl2_def_id);\n+\n+    fulfill_implication(&mut infcx,\n+                        impl1_def_id,\n+                        impl1_substs,\n+                        impl2_def_id,\n+                        impl2_substs)\n+}\n+\n+/// Does impl1 (instantiated with the impl1_substs) imply impl2\n+/// (instantiated with impl2_substs)?\n+///\n+/// Mutates the `infcx` in two ways:\n+/// - by adding the obligations of impl1 to the parameter environment\n+/// - via fulfillment, so that if the implication holds the various unifications\n+fn fulfill_implication<'a, 'tcx>(infcx: &mut InferCtxt<'a, 'tcx>,\n+                                 impl1_def_id: DefId,\n+                                 impl1_substs: Substs<'tcx>,\n+                                 impl2_def_id: DefId,\n+                                 impl2_substs: Substs<'tcx>)\n+                                 -> bool {\n+    let tcx = &infcx.tcx;\n+\n+    let (impl1_trait_ref, impl1_obligations) = {\n+        let selcx = &mut SelectionContext::new(&infcx);\n+        util::impl_trait_ref_and_oblig(selcx, impl1_def_id, &impl1_substs)\n+    };\n+\n+    let impl1_predicates: Vec<_> = impl1_obligations.iter()\n+                                                    .cloned()\n+                                                    .map(|oblig| oblig.predicate)\n+                                                    .collect();\n+\n+    infcx.parameter_environment = ty::ParameterEnvironment {\n+        tcx: tcx,\n+        free_substs: impl1_substs,\n+        implicit_region_bound: ty::ReEmpty, // FIXME: is this OK?\n+        caller_bounds: impl1_predicates,\n+        selection_cache: traits::SelectionCache::new(),\n+        evaluation_cache: traits::EvaluationCache::new(),\n+        free_id_outlive: region::DUMMY_CODE_EXTENT, // FIXME: is this OK?\n+    };\n+\n+    let selcx = &mut build_selcx(&infcx).project_topmost().build();\n+    let (impl2_trait_ref, impl2_obligations) = util::impl_trait_ref_and_oblig(selcx,\n+                                                                              impl2_def_id,\n+                                                                              &impl2_substs);\n+\n+    // do the impls unify? If not, no specialization.\n+    if let Err(_) = infer::mk_eq_trait_refs(&infcx,\n+                                            true,\n+                                            TypeOrigin::Misc(DUMMY_SP),\n+                                            impl1_trait_ref,\n+                                            impl2_trait_ref) {\n+        debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n+               impl1_trait_ref,\n+               impl2_trait_ref);\n+        return false;\n+    }\n+\n+    let mut fulfill_cx = infcx.fulfillment_cx.borrow_mut();\n+\n+    // attempt to prove all of the predicates for impl2 given those for impl1\n+    // (which are packed up in penv)\n+\n+    for oblig in impl2_obligations.into_iter() {\n+        fulfill_cx.register_predicate_obligation(&infcx, oblig);\n+    }\n+\n+    if let Err(errors) = infer::drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()) {\n+        // no dice!\n+        debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n+                {:?}\",\n+               impl1_trait_ref,\n+               impl2_trait_ref,\n+               errors,\n+               infcx.parameter_environment.caller_bounds);\n+        false\n+    } else {\n+        debug!(\"fulfill_implication: an impl for {:?} specializes {:?} (`where` clauses elided)\",\n+               impl1_trait_ref,\n+               impl2_trait_ref);\n+        true\n+    }\n+}"}, {"sha": "01f3b6333f84afcfb49f82815ee856f455ee31bd", "filename": "src/librustc/middle/traits/specialize/specialization_graph.rs", "status": "added", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -0,0 +1,382 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell;\n+use std::rc::Rc;\n+\n+use super::{Overlap, specializes};\n+\n+use middle::cstore::CrateStore;\n+use middle::def_id::DefId;\n+use middle::infer;\n+use middle::traits;\n+use middle::ty::{self, ImplOrTraitItem, TraitDef, TypeFoldable};\n+use syntax::ast::Name;\n+use util::nodemap::DefIdMap;\n+\n+/// A per-trait graph of impls in specialization order. At the moment, this\n+/// graph forms a tree rooted with the trait itself, with all other nodes\n+/// representing impls, and parent-child relationships representing\n+/// specializations.\n+///\n+/// The graph provides two key services:\n+///\n+/// - Construction, which implicitly checks for overlapping impls (i.e., impls\n+///   that overlap but where neither specializes the other -- an artifact of the\n+///   simple \"chain\" rule.\n+///\n+/// - Parent extraction. In particular, the graph can give you the *immediate*\n+///   parents of a given specializing impl, which is needed for extracting\n+///   default items amongst other thigns. In the simple \"chain\" rule, every impl\n+///   has at most one parent.\n+pub struct Graph {\n+    // all impls have a parent; the \"root\" impls have as their parent the def_id\n+    // of the trait\n+    parent: DefIdMap<DefId>,\n+\n+    // the \"root\" impls are found by looking up the trait's def_id.\n+    children: DefIdMap<Vec<DefId>>,\n+}\n+\n+impl Graph {\n+    pub fn new() -> Graph {\n+        Graph {\n+            parent: Default::default(),\n+            children: Default::default(),\n+        }\n+    }\n+\n+    /// Insert a local impl into the specialization graph. If an existing impl\n+    /// conflicts with it (has overlap, but neither specializes the other),\n+    /// information about the area of overlap is returned in the `Err`.\n+    pub fn insert<'a, 'tcx>(&mut self,\n+                            tcx: &'a ty::ctxt<'tcx>,\n+                            impl_def_id: DefId)\n+                            -> Result<(), Overlap<'a, 'tcx>> {\n+        assert!(impl_def_id.is_local());\n+\n+        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        let trait_def_id = trait_ref.def_id;\n+\n+        // if the reference itself contains an earlier error (e.g., due to a\n+        // resolution failure), then we just insert the impl at the top level of\n+        // the graph and claim that there's no overlap (in order to supress\n+        // bogus errors).\n+        if trait_ref.references_error() {\n+            debug!(\"Inserting dummy node for erroneous TraitRef {:?}, \\\n+                    impl_def_id={:?}, trait_def_id={:?}\",\n+                   trait_ref, impl_def_id, trait_def_id);\n+\n+            self.parent.insert(impl_def_id, trait_def_id);\n+            self.children.entry(trait_def_id).or_insert(vec![]).push(impl_def_id);\n+            return Ok(());\n+        }\n+\n+        let mut parent = trait_def_id;\n+\n+        // Ugly hack around borrowck limitations. Assigned only in the case\n+        // where we bump downward an existing node in the graph.\n+        let child_to_insert;\n+\n+        'descend: loop {\n+            let mut possible_siblings = self.children.entry(parent).or_insert(vec![]);\n+\n+            for slot in possible_siblings.iter_mut() {\n+                let possible_sibling = *slot;\n+\n+                let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None);\n+                let overlap = traits::overlapping_impls(&infcx, possible_sibling, impl_def_id);\n+\n+                if let Some(trait_ref) = overlap {\n+                    let le = specializes(tcx, impl_def_id, possible_sibling);\n+                    let ge = specializes(tcx, possible_sibling, impl_def_id);\n+\n+                    if le && !ge {\n+                        // the impl specializes possible_sibling\n+                        parent = possible_sibling;\n+                        continue 'descend;\n+                    } else if ge && !le {\n+                        // possible_sibling specializes the impl\n+                        *slot = impl_def_id;\n+                        self.parent.insert(possible_sibling, impl_def_id);\n+                        // we have to defer the insertion, because we can't\n+                        // relinquish the borrow of `self.children`\n+                        child_to_insert = possible_sibling;\n+                        break 'descend;\n+                    } else {\n+                        // overlap, but no specialization; error out\n+                        return Err(Overlap {\n+                            with_impl: possible_sibling,\n+                            on_trait_ref: trait_ref,\n+                            in_context: infcx,\n+                        });\n+                    }\n+                }\n+            }\n+\n+            // no overlap with any potential siblings, so add as a new sibling\n+            self.parent.insert(impl_def_id, parent);\n+            possible_siblings.push(impl_def_id);\n+            return Ok(());\n+        }\n+\n+        self.children.insert(impl_def_id, vec![child_to_insert]);\n+        Ok(())\n+    }\n+\n+    /// Insert cached metadata mapping from a child impl back to its parent.\n+    pub fn record_impl_from_cstore(&mut self, parent: DefId, child: DefId) {\n+        if self.parent.insert(child, parent).is_some() {\n+            panic!(\"When recording an impl from the crate store, information about its parent \\\n+                    was already present.\");\n+        }\n+\n+        self.children.entry(parent).or_insert(vec![]).push(child);\n+    }\n+\n+    /// The parent of a given impl, which is the def id of the trait when the\n+    /// impl is a \"specialization root\".\n+    pub fn parent(&self, child: DefId) -> DefId {\n+        *self.parent.get(&child).unwrap()\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+/// A node in the specialization graph is either an impl or a trait\n+/// definition; either can serve as a source of item definitions.\n+/// There is always exactly one trait definition node: the root.\n+pub enum Node {\n+    Impl(DefId),\n+    Trait(DefId),\n+}\n+\n+impl Node {\n+    pub fn is_from_trait(&self) -> bool {\n+        match *self {\n+            Node::Trait(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Iterate over the items defined directly by the given (impl or trait) node.\n+    pub fn items<'a, 'tcx>(&self, tcx: &'a ty::ctxt<'tcx>) -> NodeItems<'a, 'tcx> {\n+        match *self {\n+            Node::Impl(impl_def_id) => {\n+                NodeItems::Impl {\n+                    tcx: tcx,\n+                    items: cell::Ref::map(tcx.impl_items.borrow(),\n+                                          |impl_items| &impl_items[&impl_def_id]),\n+                    idx: 0,\n+                }\n+            }\n+            Node::Trait(trait_def_id) => {\n+                NodeItems::Trait {\n+                    items: tcx.trait_items(trait_def_id).clone(),\n+                    idx: 0,\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn def_id(&self) -> DefId {\n+        match *self {\n+            Node::Impl(did) => did,\n+            Node::Trait(did) => did,\n+        }\n+    }\n+}\n+\n+/// An iterator over the items defined within a trait or impl.\n+pub enum NodeItems<'a, 'tcx: 'a> {\n+    Impl {\n+        tcx: &'a ty::ctxt<'tcx>,\n+        items: cell::Ref<'a, Vec<ty::ImplOrTraitItemId>>,\n+        idx: usize,\n+    },\n+    Trait {\n+        items: Rc<Vec<ImplOrTraitItem<'tcx>>>,\n+        idx: usize,\n+    },\n+}\n+\n+impl<'a, 'tcx> Iterator for NodeItems<'a, 'tcx> {\n+    type Item = ImplOrTraitItem<'tcx>;\n+    fn next(&mut self) -> Option<ImplOrTraitItem<'tcx>> {\n+        match *self {\n+            NodeItems::Impl { tcx, ref items, ref mut idx } => {\n+                let items_table = tcx.impl_or_trait_items.borrow();\n+                if *idx < items.len() {\n+                    let item_def_id = items[*idx].def_id();\n+                    let item = items_table[&item_def_id].clone();\n+                    *idx += 1;\n+                    Some(item)\n+                } else {\n+                    None\n+                }\n+            }\n+            NodeItems::Trait { ref items, ref mut idx } => {\n+                if *idx < items.len() {\n+                    let item = items[*idx].clone();\n+                    *idx += 1;\n+                    Some(item)\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub struct Ancestors<'a, 'tcx: 'a> {\n+    trait_def: &'a TraitDef<'tcx>,\n+    current_source: Option<Node>,\n+}\n+\n+impl<'a, 'tcx> Iterator for Ancestors<'a, 'tcx> {\n+    type Item = Node;\n+    fn next(&mut self) -> Option<Node> {\n+        let cur = self.current_source.take();\n+        if let Some(Node::Impl(cur_impl)) = cur {\n+            let parent = self.trait_def.specialization_graph.borrow().parent(cur_impl);\n+            if parent == self.trait_def.def_id() {\n+                self.current_source = Some(Node::Trait(parent));\n+            } else {\n+                self.current_source = Some(Node::Impl(parent));\n+            }\n+        }\n+        cur\n+    }\n+}\n+\n+pub struct NodeItem<T> {\n+    pub node: Node,\n+    pub item: T,\n+}\n+\n+impl<T> NodeItem<T> {\n+    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> NodeItem<U> {\n+        NodeItem {\n+            node: self.node,\n+            item: f(self.item),\n+        }\n+    }\n+}\n+\n+pub struct TypeDefs<'a, 'tcx: 'a> {\n+    // generally only invoked once or twice, so the box doesn't hurt\n+    iter: Box<Iterator<Item = NodeItem<Rc<ty::AssociatedType<'tcx>>>> + 'a>,\n+}\n+\n+impl<'a, 'tcx> Iterator for TypeDefs<'a, 'tcx> {\n+    type Item = NodeItem<Rc<ty::AssociatedType<'tcx>>>;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.iter.next()\n+    }\n+}\n+\n+pub struct FnDefs<'a, 'tcx: 'a> {\n+    // generally only invoked once or twice, so the box doesn't hurt\n+    iter: Box<Iterator<Item = NodeItem<Rc<ty::Method<'tcx>>>> + 'a>,\n+}\n+\n+impl<'a, 'tcx> Iterator for FnDefs<'a, 'tcx> {\n+    type Item = NodeItem<Rc<ty::Method<'tcx>>>;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.iter.next()\n+    }\n+}\n+\n+pub struct ConstDefs<'a, 'tcx: 'a> {\n+    // generally only invoked once or twice, so the box doesn't hurt\n+    iter: Box<Iterator<Item = NodeItem<Rc<ty::AssociatedConst<'tcx>>>> + 'a>,\n+}\n+\n+impl<'a, 'tcx> Iterator for ConstDefs<'a, 'tcx> {\n+    type Item = NodeItem<Rc<ty::AssociatedConst<'tcx>>>;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.iter.next()\n+    }\n+}\n+\n+impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n+    /// Seach the items from the given ancestors, returning each type definition\n+    /// with the given name.\n+    pub fn type_defs(self, tcx: &'a ty::ctxt<'tcx>, name: Name) -> TypeDefs<'a, 'tcx> {\n+        let iter = self.flat_map(move |node| {\n+            node.items(tcx)\n+                .filter_map(move |item| {\n+                    if let ty::TypeTraitItem(assoc_ty) = item {\n+                        if assoc_ty.name == name {\n+                            return Some(NodeItem {\n+                                node: node,\n+                                item: assoc_ty,\n+                            });\n+                        }\n+                    }\n+                    None\n+                })\n+\n+        });\n+        TypeDefs { iter: Box::new(iter) }\n+    }\n+\n+    /// Seach the items from the given ancestors, returning each fn definition\n+    /// with the given name.\n+    pub fn fn_defs(self, tcx: &'a ty::ctxt<'tcx>, name: Name) -> FnDefs<'a, 'tcx> {\n+        let iter = self.flat_map(move |node| {\n+            node.items(tcx)\n+                .filter_map(move |item| {\n+                    if let ty::MethodTraitItem(method) = item {\n+                        if method.name == name {\n+                            return Some(NodeItem {\n+                                node: node,\n+                                item: method,\n+                            });\n+                        }\n+                    }\n+                    None\n+                })\n+\n+        });\n+        FnDefs { iter: Box::new(iter) }\n+    }\n+\n+    /// Seach the items from the given ancestors, returning each const\n+    /// definition with the given name.\n+    pub fn const_defs(self, tcx: &'a ty::ctxt<'tcx>, name: Name) -> ConstDefs<'a, 'tcx> {\n+        let iter = self.flat_map(move |node| {\n+            node.items(tcx)\n+                .filter_map(move |item| {\n+                    if let ty::ConstTraitItem(konst) = item {\n+                        if konst.name == name {\n+                            return Some(NodeItem {\n+                                node: node,\n+                                item: konst,\n+                            });\n+                        }\n+                    }\n+                    None\n+                })\n+\n+        });\n+        ConstDefs { iter: Box::new(iter) }\n+    }\n+}\n+\n+/// Walk up the specialization ancestors of a given impl, starting with that\n+/// impl itself.\n+pub fn ancestors<'a, 'tcx>(trait_def: &'a TraitDef<'tcx>,\n+                           start_from_impl: DefId)\n+                           -> Ancestors<'a, 'tcx> {\n+    Ancestors {\n+        trait_def: trait_def,\n+        current_source: Some(Node::Impl(start_from_impl)),\n+    }\n+}"}, {"sha": "c4e820bde8f578cb9af3b1c558825da27ba93054", "filename": "src/librustc/middle/ty/trait_def.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Ftrait_def.rs?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -10,7 +10,7 @@\n \n use dep_graph::DepNode;\n use middle::def_id::DefId;\n-use middle::traits;\n+use middle::traits::{self, specialization_graph};\n use middle::ty;\n use middle::ty::fast_reject;\n use middle::ty::{Ty, TyCtxt, TraitRef};\n@@ -61,7 +61,7 @@ pub struct TraitDef<'tcx> {\n     blanket_impls: RefCell<Vec<DefId>>,\n \n     /// The specialization order for impls of this trait.\n-    pub specialization_graph: RefCell<traits::SpecializationGraph>,\n+    pub specialization_graph: RefCell<traits::specialization_graph::Graph>,\n \n     /// Various flags\n     pub flags: Cell<TraitFlags>\n@@ -83,7 +83,7 @@ impl<'tcx> TraitDef<'tcx> {\n             nonblanket_impls: RefCell::new(FnvHashMap()),\n             blanket_impls: RefCell::new(vec![]),\n             flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n-            specialization_graph: RefCell::new(traits::SpecializationGraph::new()),\n+            specialization_graph: RefCell::new(traits::specialization_graph::Graph::new()),\n         }\n     }\n \n@@ -170,7 +170,7 @@ impl<'tcx> TraitDef<'tcx> {\n     /// Records a trait-to-implementation mapping for a non-local impl.\n     ///\n     /// The `parent_impl` is the immediately-less-specialized impl, or the\n-    /// trait's def ID if the impl is maximally-specialized -- information that\n+    /// trait's def ID if the impl is is not a specialization -- information that\n     /// should be pulled from the metadata.\n     pub fn record_remote_impl(&self,\n                               tcx: &TyCtxt<'tcx>,\n@@ -201,10 +201,8 @@ impl<'tcx> TraitDef<'tcx> {\n             .insert(tcx, impl_def_id)\n     }\n \n-    /// Returns the immediately less specialized impl, if any.\n-    pub fn parent_of_impl(&self, impl_def_id: DefId) -> Option<DefId> {\n-        let parent = self.specialization_graph.borrow().parent(impl_def_id);\n-        if parent == self.trait_ref.def_id { None } else { Some(parent) }\n+    pub fn ancestors<'a>(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a, 'tcx> {\n+        specialization_graph::ancestors(self, of_impl)\n     }\n \n         pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &TyCtxt<'tcx>, mut f: F)  {"}, {"sha": "982a2bacce1648459cffea4dc3cde3e83d0fb5b2", "filename": "src/librustc_data_structures/obligation_forest/README.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2FREADME.md?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -60,7 +60,7 @@ which includes three bits of information:\n   `process_obligations` would simply yield back further ambiguous\n   results. This is used by the `FulfillmentContext` to decide when it\n   has reached a steady state.\n-  \n+\n #### Snapshots\n \n The `ObligationForest` supports a limited form of snapshots; see\n@@ -79,5 +79,3 @@ parent and (for convenience) its root (which may be itself). It also\n has a current state, described by `NodeState`. After each\n processing step, we compress the vector to remove completed and error\n nodes, which aren't needed anymore.\n-\n-  "}, {"sha": "0b1418fc878452b83ecb51a054e6a3f47abe1b7e", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -1053,6 +1053,16 @@ pub enum Defaultness {\n     Final,\n }\n \n+impl Defaultness {\n+    pub fn is_final(&self) -> bool {\n+        *self == Defaultness::Final\n+    }\n+\n+    pub fn is_default(&self) -> bool {\n+        *self == Defaultness::Default\n+    }\n+}\n+\n impl fmt::Display for Unsafety {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(match *self {"}, {"sha": "707657cfa26bb2155ce7de3ab9dde7f1ae09c891", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -1171,7 +1171,14 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         if let Some(trait_ref) = tcx.impl_trait_ref(did) {\n             encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n \n-            let parent = tcx.lookup_trait_def(trait_ref.def_id).parent_of_impl(did);\n+            let trait_def = tcx.lookup_trait_def(trait_ref.def_id);\n+            let parent = trait_def.ancestors(did)\n+                .skip(1)\n+                .next()\n+                .and_then(|node| match node {\n+                    specialization_graph::Node::Impl(parent) => Some(parent),\n+                    _ => None,\n+                });\n             encode_parent_impl(rbml_w, parent);\n         }\n         encode_path(rbml_w, path.clone());"}, {"sha": "dd144de6ec5e403b92ff3cd202a6fabe7c5fb5e5", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -1138,7 +1138,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n     let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n-    let mut selcx = traits::SelectionContext::new(&infcx);\n+    let mut selcx = traits::build_selcx(&infcx).project_any().build();\n \n     let obligation =\n         traits::Obligation::new(traits::ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n@@ -1199,7 +1199,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let tcx = ccx.tcx();\n     let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n-    let mut selcx = traits::SelectionContext::new(&infcx);\n+    let mut selcx = traits::build_selcx(&infcx).project_any().build();\n     let mut fulfill_cx = traits::FulfillmentContext::new();\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: predicates, obligations } ="}, {"sha": "2f5f052a72a85a69d91adf9b345b52077d2b7a34", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -486,21 +486,19 @@ pub fn get_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n     assert!(!substs.types.needs_infer());\n \n-    traits::get_impl_item_or_default(tcx, impl_def_id, |cand| {\n-        if let &ty::MethodTraitItem(ref meth) = cand {\n-            if meth.name == name {\n-                return Some(meth.clone())\n+    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+\n+    match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n+        Some(node_item) => {\n+            ImplMethod {\n+                method: node_item.item,\n+                substs: traits::translate_substs(tcx, impl_def_id, substs, node_item.node),\n+                is_provided: node_item.node.is_from_trait(),\n             }\n         }\n-        None\n-    }).map(|(meth, source)| {\n-        ImplMethod {\n-            method: meth,\n-            substs: source.translate_substs(tcx, substs),\n-            is_provided: source.is_from_trait(),\n+        None => {\n+            tcx.sess.bug(&format!(\"method {:?} not found in {:?}\", name, impl_def_id))\n         }\n-    }).unwrap_or_else(|| {\n-        tcx.sess.bug(&format!(\"method {:?} not found in {:?}\",\n-                              name, impl_def_id))\n-    })\n+    }\n }"}, {"sha": "bb94d80474afb0f55196e603cc1ff4c212f21729", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 81, "deletions": 99, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -127,7 +127,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n \n use rustc_front::intravisit::{self, Visitor};\n use rustc_front::hir;\n-use rustc_front::hir::{Visibility, PatKind, Defaultness};\n+use rustc_front::hir::{Visibility, PatKind};\n use rustc_front::print::pprust;\n use rustc_back::slice;\n \n@@ -864,42 +864,71 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     check_bare_fn(ccx, &sig.decl, body, id, span, fty, param_env);\n }\n \n-fn check_specialization_validity<'tcx, F>(tcx: &ty::ctxt<'tcx>,\n-                                          impl_id: DefId,\n-                                          impl_item: &hir::ImplItem,\n-                                          f: F)\n-    where F: FnMut(&ty::ImplOrTraitItem<'tcx>) -> Option<hir::Defaultness>\n+fn report_forbidden_specialization(tcx: &ty::ctxt,\n+                                   impl_item: &hir::ImplItem,\n+                                   parent_impl: DefId)\n {\n-    let parent_item_opt = traits::get_parent_impl_item(tcx, impl_id, f);\n-    if let Some((Defaultness::Final, parent_impl)) = parent_item_opt {\n-        let mut err = struct_span_err!(\n-            tcx.sess, impl_item.span, E0520,\n-            \"item `{}` is provided by an implementation that \\\n-             specializes another, but the item in the parent \\\n-             implementations is not marked `default` and so it \\\n-             cannot be specialized.\",\n-            impl_item.name);\n-\n-        match tcx.span_of_impl(parent_impl) {\n-            Ok(span) => {\n-                err.span_note(span, \"parent implementation is here:\");\n-            }\n-            Err(cname) => {\n-                err.note(&format!(\"parent implementation is in crate `{}`\", cname));\n-            }\n+    let mut err = struct_span_err!(\n+        tcx.sess, impl_item.span, E0520,\n+        \"item `{}` is provided by an implementation that specializes \\\n+         another, but the item in the parent implementations is not \\\n+         marked `default` and so it cannot be specialized.\",\n+        impl_item.name);\n+\n+    match tcx.span_of_impl(parent_impl) {\n+        Ok(span) => {\n+            err.span_note(span, \"parent implementation is here:\");\n         }\n+        Err(cname) => {\n+            err.note(&format!(\"parent implementation is in crate `{}`\", cname));\n+        }\n+    }\n \n-        err.emit();\n+    err.emit();\n+}\n+\n+fn check_specialization_validity<'tcx>(tcx: &ty::ctxt<'tcx>, trait_def: &ty::TraitDef<'tcx>,\n+                                       impl_id: DefId, impl_item: &hir::ImplItem)\n+{\n+    let ancestors = trait_def.ancestors(impl_id);\n+\n+    let parent = match impl_item.node {\n+        hir::ImplItemKind::Const(..) => {\n+            ancestors.const_defs(tcx, impl_item.name).skip(1).next()\n+                .map(|node_item| node_item.map(|parent| parent.defaultness))\n+        }\n+        hir::ImplItemKind::Method(..) => {\n+            ancestors.fn_defs(tcx, impl_item.name).skip(1).next()\n+                .map(|node_item| node_item.map(|parent| parent.defaultness))\n+\n+        }\n+        hir::ImplItemKind::Type(_) => {\n+            ancestors.type_defs(tcx, impl_item.name).skip(1).next()\n+                .map(|node_item| node_item.map(|parent| parent.defaultness))\n+        }\n+    };\n+\n+    if let Some(parent) = parent {\n+        if parent.item.is_final() {\n+            report_forbidden_specialization(tcx, impl_item, parent.node.def_id());\n+        }\n     }\n+\n }\n \n fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_span: Span,\n                                             impl_id: DefId,\n                                             impl_trait_ref: &ty::TraitRef<'tcx>,\n                                             impl_items: &[hir::ImplItem]) {\n-    // Locate trait methods\n+    // If the trait reference itself is erroneous (so the compilation is going\n+    // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n+    // isn't populated for such impls.\n+    if impl_trait_ref.references_error() { return; }\n+\n+    // Locate trait definition and items\n     let tcx = ccx.tcx;\n+    let trait_def = tcx.lookup_trait_def(impl_trait_ref.def_id);\n     let trait_items = tcx.trait_items(impl_trait_ref.def_id);\n     let mut overridden_associated_type = None;\n \n@@ -910,6 +939,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let ty_trait_item = trait_items.iter()\n             .find(|ac| ac.name() == ty_impl_item.name());\n \n+        // Check that impl definition matches trait definition\n         if let Some(ty_trait_item) = ty_trait_item {\n             match impl_item.node {\n                 hir::ImplItemKind::Const(..) => {\n@@ -932,15 +962,6 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   impl_const.name,\n                                   impl_trait_ref)\n                     }\n-\n-                    check_specialization_validity(ccx.tcx, impl_id, impl_item, |cand| {\n-                        if let &ty::ConstTraitItem(ref trait_const) = cand {\n-                            if trait_const.name == impl_item.name {\n-                                return Some(trait_const.defaultness);\n-                            }\n-                        }\n-                        None\n-                    });\n                 }\n                 hir::ImplItemKind::Method(ref sig, ref body) => {\n                     check_trait_fn_not_const(ccx, impl_item.span, sig.constness);\n@@ -964,15 +985,6 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   impl_method.name,\n                                   impl_trait_ref)\n                     }\n-\n-                    check_specialization_validity(ccx.tcx, impl_id, impl_item, |cand| {\n-                        if let &ty::MethodTraitItem(ref meth) = cand {\n-                            if meth.name == impl_method.name {\n-                                return Some(meth.defaultness);\n-                            }\n-                        }\n-                        None\n-                    });\n                 }\n                 hir::ImplItemKind::Type(_) => {\n                     let impl_type = match ty_impl_item {\n@@ -991,18 +1003,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   impl_type.name,\n                                   impl_trait_ref)\n                     }\n-\n-                    check_specialization_validity(ccx.tcx, impl_id, impl_item, |cand| {\n-                        if let &ty::TypeTraitItem(ref at) = cand {\n-                            if at.name == impl_item.name {\n-                                return Some(at.defaultness);\n-                            }\n-                        }\n-                        None\n-                    });\n                 }\n             }\n         }\n+\n+        check_specialization_validity(tcx, trait_def, impl_id, impl_item);\n     }\n \n     // Check for missing items from trait\n@@ -1011,67 +1016,44 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let mut invalidated_items = Vec::new();\n     let associated_type_overridden = overridden_associated_type.is_some();\n     for trait_item in trait_items.iter() {\n+        let is_implemented;\n+        let is_provided;\n+\n         match *trait_item {\n             ty::ConstTraitItem(ref associated_const) => {\n-                let is_implemented = impl_items.iter().any(|ii| {\n+                is_provided = associated_const.has_value;\n+                is_implemented = impl_items.iter().any(|ii| {\n                     match ii.node {\n                         hir::ImplItemKind::Const(..) => {\n                             ii.name == associated_const.name\n                         }\n                         _ => false,\n                     }\n                 });\n-                let is_provided = associated_const.has_value;\n-\n-                if !is_implemented {\n-                    if !is_provided {\n-                        missing_items.push(associated_const.name);\n-                    } else if associated_type_overridden {\n-                        invalidated_items.push(associated_const.name);\n-                    }\n-                }\n             }\n             ty::MethodTraitItem(ref trait_method) => {\n-                let search_result = traits::get_impl_item_or_default(tcx, impl_id, |cand| {\n-                    if let &ty::MethodTraitItem(ref meth) = cand {\n-                        if meth.name == trait_method.name {\n-                            return Some(());\n-                        }\n-                    }\n-                    None\n-                });\n-\n-                if let Some((_, source)) = search_result {\n-                    if source.is_from_trait() {\n-                        let is_provided =\n-                            provided_methods.iter().any(|m| m.name == trait_method.name);\n-                        if !is_provided {\n-                            missing_items.push(trait_method.name);\n-                        } else if associated_type_overridden {\n-                            invalidated_items.push(trait_method.name);\n-                        }\n-                    }\n-                } else {\n-                    missing_items.push(trait_method.name);\n-                }\n+                is_provided = provided_methods.iter().any(|m| m.name == trait_method.name);\n+                is_implemented = trait_def.ancestors(impl_id)\n+                    .fn_defs(tcx, trait_method.name)\n+                    .next()\n+                    .map(|node_item| !node_item.node.is_from_trait())\n+                    .unwrap_or(false);\n             }\n             ty::TypeTraitItem(ref trait_assoc_ty) => {\n-                let search_result = traits::get_impl_item_or_default(tcx, impl_id, |cand| {\n-                    if let &ty::TypeTraitItem(ref assoc_ty) = cand {\n-                        if assoc_ty.name == trait_assoc_ty.name && assoc_ty.ty.is_some() {\n-                            return Some(());\n-                        }\n-                    }\n-                    None\n-                });\n+                is_provided = trait_assoc_ty.ty.is_some();\n+                is_implemented = trait_def.ancestors(impl_id)\n+                    .type_defs(tcx, trait_assoc_ty.name)\n+                    .next()\n+                    .map(|node_item| !node_item.node.is_from_trait())\n+                    .unwrap_or(false);\n+            }\n+        }\n \n-                if let Some((_, source)) = search_result {\n-                    if source.is_from_trait() && associated_type_overridden {\n-                        invalidated_items.push(trait_assoc_ty.name);\n-                    }\n-                } else {\n-                    missing_items.push(trait_assoc_ty.name);\n-                }\n+        if !is_implemented {\n+            if !is_provided {\n+                missing_items.push(trait_item.name());\n+            } else if associated_type_overridden {\n+                invalidated_items.push(trait_item.name());\n             }\n         }\n     }"}, {"sha": "4a5dbe20b7879c093ca3a97aed01887a73307d33", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -128,7 +128,8 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n \n-                let _task = self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n+                let _task = self.tcx.dep_graph.in_task(\n+                    DepNode::CoherenceOverlapCheck(trait_def_id));\n \n                 let def = self.tcx.lookup_trait_def(trait_def_id);\n \n@@ -161,7 +162,8 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                             err.span_note(span, \"conflicting implementation is here:\");\n                         }\n                         Err(cname) => {\n-                            err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n+                            err.note(&format!(\"conflicting implementation in crate `{}`\",\n+                                              cname));\n                         }\n                     }\n "}, {"sha": "88cd00e69c4222f6f5cb2299990a3c7cd4ca7f3c", "filename": "src/test/compile-fail/specialization-no-default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Ftest%2Fcompile-fail%2Fspecialization-no-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/940adda2aef63ac820cf331ebb7f6f0699c12045/src%2Ftest%2Fcompile-fail%2Fspecialization-no-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspecialization-no-default.rs?ref=940adda2aef63ac820cf331ebb7f6f0699c12045", "patch": "@@ -65,7 +65,7 @@ impl<T: Clone> Baz for T {\n }\n \n impl Baz for i32 {\n-    fn baz(&self) {}\n+    fn baz(&self) {} //~ ERROR E0520\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -86,7 +86,7 @@ impl<T: Clone> Redundant for T {\n }\n \n impl Redundant for i32 {\n-    default fn redundant(&self) {}\n+    default fn redundant(&self) {} //~ ERROR E0520\n }\n \n fn main() {}"}]}