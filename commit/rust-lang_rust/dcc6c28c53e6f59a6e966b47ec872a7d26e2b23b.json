{"sha": "dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjYzZjMjhjNTNlNmY1OWE2ZTk2NmI0N2VjODcyYTdkMjZlMmIyM2I=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-09-25T01:12:59Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2019-09-28T00:11:13Z"}, "message": "Introduce a `ConstPropMachine`\n\nThis allows us to avoid changing things directly in the miri engine just\nfor const prop.", "tree": {"sha": "2370be1acc6d03db908a1e8afe86f19d00a81bdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2370be1acc6d03db908a1e8afe86f19d00a81bdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b", "html_url": "https://github.com/rust-lang/rust/commit/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e58e2e3a3f3cda15bad6cbb87242eaf555dda85", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e58e2e3a3f3cda15bad6cbb87242eaf555dda85", "html_url": "https://github.com/rust-lang/rust/commit/4e58e2e3a3f3cda15bad6cbb87242eaf555dda85"}], "stats": {"total": 216, "additions": 177, "deletions": 39}, "files": [{"sha": "71967b513a049455ec509bf8a730a6e45b63cf40", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b", "patch": "@@ -389,14 +389,6 @@ pub enum UnsupportedOpInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n \n-    /// Error used by the `ConstProp` pass when an attempt is made\n-    /// to read an uninitialized local.\n-    UninitializedLocal,\n-\n-    /// Error used by the `ConstProp` pass to prevent reading statics\n-    /// while evaluating `const` items.\n-    ReadOfStaticInConst,\n-\n     /// FIXME(#64506) Error used to work around accessing projections of\n     /// uninhabited types.\n     UninhabitedValue,\n@@ -523,8 +515,6 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n                     addresses, e.g., comparing pointers into different allocations\"),\n             DeadLocal =>\n                 write!(f, \"tried to access a dead local variable\"),\n-            UninitializedLocal =>\n-                write!(f, \"tried to access an uninitialized local variable\"),\n             DerefFunctionPointer =>\n                 write!(f, \"tried to dereference a function pointer\"),\n             ExecuteMemory =>\n@@ -566,8 +556,6 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n                     not a power of two\"),\n             Unsupported(ref msg) =>\n                 write!(f, \"{}\", msg),\n-            ReadOfStaticInConst =>\n-                write!(f, \"tried to read from a static during const evaluation\"),\n             UninhabitedValue =>\n                 write!(f, \"tried to use an uninhabited value\"),\n         }"}, {"sha": "bb02b99dd8d87df01fc721a9841af1d446e666cc", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b", "patch": "@@ -21,7 +21,7 @@ use syntax::source_map::{Span, DUMMY_SP};\n \n use crate::interpret::{self,\n     PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar, Pointer,\n-    RawConst, ConstValue,\n+    RawConst, ConstValue, Machine,\n     InterpResult, InterpErrorInfo, GlobalId, InterpCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind, Memory,\n     snapshot, RefTracking, intern_const_alloc_recursive,\n@@ -41,7 +41,7 @@ const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n /// that inform us about the generic bounds of the constant. E.g., using an associated constant\n /// of a function's generic parameter will require knowledge about the bounds on the generic\n /// parameter. These bounds are passed to `mk_eval_cx` via the `ParamEnv` argument.\n-pub(crate) fn mk_eval_cx<'mir, 'tcx>(\n+fn mk_eval_cx<'mir, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -169,7 +169,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n }\n \n #[derive(Clone, Debug)]\n-enum ConstEvalError {\n+pub enum ConstEvalError {\n     NeedsRfc(String),\n }\n \n@@ -521,8 +521,8 @@ pub fn const_variant_index<'tcx>(\n /// Turn an interpreter error into something to report to the user.\n /// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n /// Should be called only if the error is actually going to to be reported!\n-pub fn error_to_const_error<'mir, 'tcx>(\n-    ecx: &InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n+pub fn error_to_const_error<'mir, 'tcx, M: Machine<'mir, 'tcx>>(\n+    ecx: &InterpCx<'mir, 'tcx, M>,\n     mut error: InterpErrorInfo<'tcx>,\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();"}, {"sha": "fdf85260c3d961273e0079ad5e9994f3e993ae11", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b", "patch": "@@ -135,8 +135,7 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n         match self.value {\n             LocalValue::Dead => throw_unsup!(DeadLocal),\n             LocalValue::Uninitialized =>\n-                // this is reachable from ConstProp\n-                throw_unsup!(UninitializedLocal),\n+                bug!(\"The type checker should prevent reading from a never-written local\"),\n             LocalValue::Live(val) => Ok(val),\n         }\n     }"}, {"sha": "e0be53b80d734df6bf6e69b45c6b1cdd98265ded", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b", "patch": "@@ -12,6 +12,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use super::{\n     Allocation, AllocId, InterpResult, Scalar, AllocationExtra,\n     InterpCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory,\n+    Frame, Operand,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -184,6 +185,23 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx>;\n \n+    /// Called to read the specified `local` from the `frame`.\n+    fn access_local(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+        local: mir::Local,\n+    ) -> InterpResult<'tcx, Operand<Self::PointerTag>> {\n+        frame.locals[local].access()\n+    }\n+\n+    /// Called before a `StaticKind::Static` value is read.\n+    fn before_eval_static(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _place_static: &mir::Static<'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n     /// to always first construct it without extra and then add the extra."}, {"sha": "861e5ebef877deb024ed8654ff39c56d4b706b5e", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b", "patch": "@@ -458,7 +458,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Do not read from ZST, they might not be initialized\n             Operand::Immediate(Scalar::zst().into())\n         } else {\n-            frame.locals[local].access()?\n+            M::access_local(&self, frame, local)?\n         };\n         Ok(OpTy { op, layout })\n     }"}, {"sha": "c882f4ef4ddf32b4349129422e3eaf121dfd0a14", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b", "patch": "@@ -601,15 +601,8 @@ where\n             }\n \n             StaticKind::Static => {\n-                //if the first frame on the stack isn't a static item, then we shouldn't\n-                //eval any static places (unless -Z unleash-the-miri-inside-of-you is on)\n-                if let ty::InstanceDef::Item(item_def_id) = self.stack[0].instance.def {\n-                    if !self.tcx.is_static(item_def_id) &&\n-                        !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-                        trace!(\"eval_static_to_mplace: can't eval static in constant\");\n-                        throw_unsup!(ReadOfStaticInConst);\n-                    }\n-                }\n+                M::before_eval_static(self, place_static)?;\n+\n                 let ty = place_static.ty;\n                 assert!(!ty.needs_subst());\n                 let layout = self.layout_of(ty)?;"}, {"sha": "ce1acc3b7edf96f53f44ed14d71d299937abca43", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 149, "deletions": 8, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b", "patch": "@@ -1,14 +1,16 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n+use std::borrow::Cow;\n use std::cell::Cell;\n \n use rustc::hir::def::DefKind;\n+use rustc::hir::def_id::DefId;\n use rustc::mir::{\n     AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue,\n-    Local, NullOp, UnOp, StatementKind, Statement, LocalKind,\n+    Local, NullOp, UnOp, StatementKind, Statement, LocalKind, Static,\n     TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo, BinOp,\n-    SourceScope, SourceScopeLocalData, LocalDecl,\n+    SourceScope, SourceScopeLocalData, LocalDecl, BasicBlock,\n };\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, MutVisitor, NonMutatingUseContext,\n@@ -17,18 +19,19 @@ use rustc::mir::interpret::{Scalar, InterpResult, PanicInfo};\n use rustc::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n use syntax_pos::{Span, DUMMY_SP};\n use rustc::ty::subst::InternalSubsts;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::ty::layout::{\n     LayoutOf, TyLayout, LayoutError, HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n use crate::interpret::{\n     self, InterpCx, ScalarMaybeUndef, Immediate, OpTy,\n-    StackPopCleanup, LocalValue, LocalState,\n-};\n-use crate::const_eval::{\n-    CompileTimeInterpreter, error_to_const_error, mk_eval_cx,\n+    StackPopCleanup, LocalValue, LocalState, AllocId, Frame,\n+    Allocation, MemoryKind, ImmTy, Pointer, Memory, PlaceTy,\n+    Operand as InterpOperand,\n };\n+use crate::const_eval::error_to_const_error;\n use crate::transform::{MirPass, MirSource};\n \n pub struct ConstProp;\n@@ -111,11 +114,149 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n     }\n }\n \n+struct ConstPropMachine;\n+\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n+    type MemoryKinds= !;\n+    type PointerTag = ();\n+    type ExtraFnVal = !;\n+\n+    type FrameExtra = ();\n+    type MemoryExtra = ();\n+    type AllocExtra = ();\n+\n+    type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n+\n+    const STATIC_KIND: Option<!> = None;\n+\n+    const CHECK_ALIGN: bool = false;\n+\n+    #[inline(always)]\n+    fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+        false\n+    }\n+\n+    fn find_fn(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _args: &[OpTy<'tcx>],\n+        _dest: Option<PlaceTy<'tcx>>,\n+        _ret: Option<BasicBlock>,\n+    ) -> InterpResult<'tcx, Option<&'mir Body<'tcx>>> {\n+        Ok(None)\n+    }\n+\n+    fn call_extra_fn(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        fn_val: !,\n+        _args: &[OpTy<'tcx>],\n+        _dest: Option<PlaceTy<'tcx>>,\n+        _ret: Option<BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        match fn_val {}\n+    }\n+\n+    fn call_intrinsic(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _instance: ty::Instance<'tcx>,\n+        _args: &[OpTy<'tcx>],\n+        _dest: PlaceTy<'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        throw_unsup_format!(\"calling intrinsics isn't supported in ConstProp\");\n+    }\n+\n+    fn ptr_to_int(\n+        _mem: &Memory<'mir, 'tcx, Self>,\n+        _ptr: Pointer,\n+    ) -> InterpResult<'tcx, u64> {\n+        throw_unsup_format!(\"ptr-to-int casts aren't supported in ConstProp\");\n+    }\n+\n+    fn binary_ptr_op(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _bin_op: BinOp,\n+        _left: ImmTy<'tcx>,\n+        _right: ImmTy<'tcx>,\n+    ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n+        // We can't do this because aliasing of memory can differ between const eval and llvm\n+        throw_unsup_format!(\"pointer arithmetic or comparisons aren't supported in ConstProp\");\n+    }\n+\n+    fn find_foreign_static(\n+        _tcx: TyCtxt<'tcx>,\n+        _def_id: DefId,\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n+        throw_unsup!(ReadForeignStatic)\n+    }\n+\n+    #[inline(always)]\n+    fn tag_allocation<'b>(\n+        _memory_extra: &(),\n+        _id: AllocId,\n+        alloc: Cow<'b, Allocation>,\n+        _kind: Option<MemoryKind<!>>,\n+    ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n+        // We do not use a tag so we can just cheaply forward the allocation\n+        (alloc, ())\n+    }\n+\n+    #[inline(always)]\n+    fn tag_static_base_pointer(\n+        _memory_extra: &(),\n+        _id: AllocId,\n+    ) -> Self::PointerTag {\n+        ()\n+    }\n+\n+    fn box_alloc(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        _dest: PlaceTy<'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        throw_unsup_format!(\"can't const prop `box` keyword\");\n+    }\n+\n+    fn access_local(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n+        local: Local,\n+    ) -> InterpResult<'tcx, InterpOperand<Self::PointerTag>> {\n+        let l = &frame.locals[local];\n+\n+        if l.value == LocalValue::Uninitialized {\n+            throw_unsup_format!(\"tried to access an uninitialized local\");\n+        }\n+\n+        l.access()\n+    }\n+\n+    fn before_eval_static(\n+        _ecx: &InterpCx<'mir, 'tcx, Self>,\n+        _place_static: &Static<'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        throw_unsup_format!(\"can't eval statics in ConstProp\");\n+    }\n+\n+    fn before_terminator(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    #[inline(always)]\n+    fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    /// Called immediately before a stack frame gets popped.\n+    #[inline(always)]\n+    fn stack_pop(_ecx: &mut InterpCx<'mir, 'tcx, Self>, _extra: ()) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+}\n+\n type Const<'tcx> = OpTy<'tcx>;\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'mir, 'tcx> {\n-    ecx: InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n+    ecx: InterpCx<'mir, 'tcx, ConstPropMachine>,\n     tcx: TyCtxt<'tcx>,\n     source: MirSource<'tcx>,\n     can_const_prop: IndexVec<Local, bool>,\n@@ -158,7 +299,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let def_id = source.def_id();\n         let param_env = tcx.param_env(def_id);\n         let span = tcx.def_span(def_id);\n-        let mut ecx = mk_eval_cx(tcx, span, param_env);\n+        let mut ecx = InterpCx::new(tcx.at(span), param_env, ConstPropMachine, ());\n         let can_const_prop = CanConstProp::check(body);\n \n         ecx.push_stack_frame("}, {"sha": "2f90f7f9e035b1befb39830a50518acd357fb655", "filename": "src/test/ui/issues/issue-52060.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Ftest%2Fui%2Fissues%2Fissue-52060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b/src%2Ftest%2Fui%2Fissues%2Fissue-52060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52060.stderr?ref=dcc6c28c53e6f59a6e966b47ec872a7d26e2b23b", "patch": "@@ -6,5 +6,4 @@ LL | static B: [u32; 1] = [0; A.len()];\n \n error: aborting due to previous error\n \n-Some errors have detailed explanations: E0013, E0080.\n-For more information about an error, try `rustc --explain E0013`.\n+For more information about this error, try `rustc --explain E0013`."}]}