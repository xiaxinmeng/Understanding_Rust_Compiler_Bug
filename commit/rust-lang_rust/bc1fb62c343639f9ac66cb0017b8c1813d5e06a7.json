{"sha": "bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMWZiNjJjMzQzNjM5ZjlhYzY2Y2IwMDE3YjhjMTgxM2Q1ZTA2YTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-08T03:04:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-08T03:04:44Z"}, "message": "auto merge of #4745 : jld/rust/constenum-bis, r=graydon\n\nThere were a bunch of problems with consts where an enum was contained within some other type (vector, tuple, struct, etc.); some of these would cause LLVM assertion failures, and some would silently read from the wrong address.  These changes should fix all of that.\r\n\r\nIt would be good if someone with access to a win32 host could do the equivalent of `make check-stageN-rpass TESTNAME=enum` on that platform before merging this.", "tree": {"sha": "bcae3b3bd57ecb8abe468a4e0ae256827bb28b02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bcae3b3bd57ecb8abe468a4e0ae256827bb28b02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "html_url": "https://github.com/rust-lang/rust/commit/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6647a3402bf75368de1a692370c558d423f36940", "url": "https://api.github.com/repos/rust-lang/rust/commits/6647a3402bf75368de1a692370c558d423f36940", "html_url": "https://github.com/rust-lang/rust/commit/6647a3402bf75368de1a692370c558d423f36940"}, {"sha": "e89d9853a68c684c089d6b9be22b572d9866e580", "url": "https://api.github.com/repos/rust-lang/rust/commits/e89d9853a68c684c089d6b9be22b572d9866e580", "html_url": "https://github.com/rust-lang/rust/commit/e89d9853a68c684c089d6b9be22b572d9866e580"}], "stats": {"total": 269, "additions": 247, "deletions": 22}, "files": [{"sha": "3a419ac9f59b442df914b4cb545efa993476e845", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "patch": "@@ -382,6 +382,7 @@ pub extern mod llvm {\n     pub unsafe fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n \n     /* Operations on Users */\n+    pub unsafe fn LLVMGetNumOperands(Val: ValueRef) -> c_int;\n     pub unsafe fn LLVMGetOperand(Val: ValueRef, Index: c_uint) -> ValueRef;\n     pub unsafe fn LLVMSetOperand(Val: ValueRef, Index: c_uint, Op: ValueRef);\n "}, {"sha": "5af62eda1fe4f69bed7cb540544d72e6aeee2261", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 44, "deletions": 22, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "patch": "@@ -73,9 +73,15 @@ pub fn const_vec(cx: @crate_ctxt, e: @ast::expr, es: &[@ast::expr])\n         let vec_ty = ty::expr_ty(cx.tcx, e);\n         let unit_ty = ty::sequence_element_type(cx.tcx, vec_ty);\n         let llunitty = type_of::type_of(cx, unit_ty);\n-        let v = C_array(llunitty, es.map(|e| const_expr(cx, *e)));\n         let unit_sz = machine::llsize_of(cx, llunitty);\n         let sz = llvm::LLVMConstMul(C_uint(cx, es.len()), unit_sz);\n+        let vs = es.map(|e| const_expr(cx, *e));\n+        // If the vector contains enums, an LLVM array won't work.\n+        let v = if vs.any(|vi| val_ty(*vi) != llunitty) {\n+            C_struct(vs)\n+        } else {\n+            C_array(llunitty, vs)\n+        };\n         return (v, sz, llunitty);\n     }\n }\n@@ -279,15 +285,17 @@ pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n               // call. Despite that being \"a const\", it's not the kind of\n               // const you can ask for the integer-value of, evidently. This\n               // might be an LLVM bug, not sure. In any case, to work around\n-              // this we drop down to the array-type level here and just ask\n-              // how long the array-type itself is, ignoring the length we\n-              // pulled out of the slice. This in turn only works because we\n-              // picked out the original globalvar via const_deref and so can\n-              // recover the array-size of the underlying array, and all this\n-              // will hold together exactly as long as we _don't_ support\n-              // const sub-slices (that is, slices that represent something\n-              // other than a whole array).  At that point we'll have more and\n-              // uglier work to do here, but for now this should work.\n+              // this we obtain the initializer and count how many elements it\n+              // has, ignoring the length we pulled out of the slice. (Note\n+              // that the initializer might be a struct rather than an array,\n+              // if enums are involved.) This only works because we picked out\n+              // the original globalvar via const_deref and so can recover the\n+              // array-size of the underlying array (or the element count of\n+              // the underlying struct), and all this will hold together\n+              // exactly as long as we _don't_ support const sub-slices (that\n+              // is, slices that represent something other than a whole\n+              // array).  At that point we'll have more and uglier work to do\n+              // here, but for now this should work.\n               //\n               // In the future, what we should be doing here is the\n               // moral equivalent of:\n@@ -299,7 +307,7 @@ pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n               // not want to consider sizeof() a constant expression\n               // we can get the value (as a number) out of.\n \n-              let len = llvm::LLVMGetArrayLength(val_ty(arr)) as u64;\n+              let len = llvm::LLVMGetNumOperands(arr) as u64;\n               let len = match ty::get(bt).sty {\n                   ty::ty_estr(*) => {assert len > 0; len - 1},\n                   _ => len\n@@ -346,10 +354,8 @@ pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n           }\n           ast::expr_addr_of(ast::m_imm, sub) => {\n             let cv = const_expr(cx, sub);\n-            let subty = ty::expr_ty(cx.tcx, sub),\n-            llty = type_of::type_of(cx, subty);\n             let gv = do str::as_c_str(\"const\") |name| {\n-                llvm::LLVMAddGlobal(cx.llmod, llty, name)\n+                llvm::LLVMAddGlobal(cx.llmod, val_ty(cv), name)\n             };\n             llvm::LLVMSetInitializer(gv, cv);\n             llvm::LLVMSetGlobalConstant(gv, True);\n@@ -377,8 +383,7 @@ pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n                       }\n                   })\n               };\n-              let llty = type_of::type_of(cx, ety);\n-              C_named_struct(llty, [C_struct(cs)])\n+              C_struct([C_struct(cs)])\n           }\n           ast::expr_vec(es, ast::m_imm) => {\n             let (v, _, _) = const_vec(cx, e, es);\n@@ -434,7 +439,13 @@ pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n                     let lldiscrim = base::get_discrim_val(cx, e.span,\n                                                           enum_did,\n                                                           variant_did);\n-                    C_struct(~[lldiscrim])\n+                    // However, we still have to pad it out to the\n+                    // size of the full enum; see the expr_call case,\n+                    // below.\n+                    let ety = ty::expr_ty(cx.tcx, e);\n+                    let size = machine::static_size_of_enum(cx, ety);\n+                    let padding = C_null(T_array(T_i8(), size));\n+                    C_struct(~[lldiscrim, padding])\n                 }\n                 Some(ast::def_struct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx, e);\n@@ -450,14 +461,12 @@ pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n           ast::expr_call(callee, args, _) => {\n             match cx.tcx.def_map.find(&callee.id) {\n                 Some(ast::def_struct(def_id)) => {\n-                    let ety = ty::expr_ty(cx.tcx, e);\n-                    let llty = type_of::type_of(cx, ety);\n                     let llstructbody =\n                         C_struct(args.map(|a| const_expr(cx, *a)));\n                     if ty::ty_dtor(cx.tcx, def_id).is_present() {\n-                        C_named_struct(llty, ~[ llstructbody, C_u8(0) ])\n+                        C_struct(~[ llstructbody, C_u8(0) ])\n                     } else {\n-                        C_named_struct(llty, ~[ llstructbody ])\n+                        C_struct(~[ llstructbody ])\n                     }\n                 }\n             Some(ast::def_variant(tid, vid)) => {\n@@ -470,7 +479,20 @@ pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n \n                 // FIXME (#1645): enum body alignment is generaly wrong.\n                 if !degen {\n-                    C_packed_struct(~[discrim, c_args])\n+                    // Pad out the data to the size of its type_of;\n+                    // this is necessary if the enum is contained\n+                    // within an aggregate (tuple, struct, vector) so\n+                    // that the next element is at the right offset.\n+                    let actual_size =\n+                        machine::llsize_of_real(cx, llvm::LLVMTypeOf(c_args));\n+                    let padding =\n+                        C_null(T_array(T_i8(), size - actual_size));\n+                    // A packed_struct has an alignment of 1; thus,\n+                    // wrapping one around c_args will misalign it the\n+                    // same way we normally misalign enum bodies\n+                    // without affecting its internal alignment or\n+                    // changing the alignment of the enum.\n+                    C_struct(~[discrim, C_packed_struct(~[c_args]), padding])\n                 } else if size == 0 {\n                     C_struct(~[discrim])\n                 } else {"}, {"sha": "6ca27fb58b0c2e319c0edd0b1d1c1280f58a0d52", "filename": "src/test/run-pass/const-enum-ptr.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-ptr.rs?ref=bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum E { V0, V1(int) }\n+const C: &static/E = &V0;\n+\n+fn main() {\n+    match *C {\n+        V0 => (),\n+        _ => die!()\n+    }\n+}"}, {"sha": "463b8452bb8ef4f6c09363d2fc4aead7c60a54c4", "filename": "src/test/run-pass/const-enum-struct.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-struct.rs?ref=bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum E { V16(u16), V32(u32) }\n+struct S { a: E, b: u16, c: u16 }\n+const C: S = S { a: V16(0xDEAD), b: 0x600D, c: 0xBAD };\n+\n+fn main() {\n+    let n = C.b;\n+    assert n != 0xBAD;\n+    assert n == 0x600D;\n+}"}, {"sha": "f34549326780e35baffd59101e64ec41e034c214", "filename": "src/test/run-pass/const-enum-struct2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-struct2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-struct2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-struct2.rs?ref=bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum E { V0, V16(u16) }\n+struct S { a: E, b: u16, c: u16 }\n+const C: S = S { a: V0, b: 0x600D, c: 0xBAD };\n+\n+fn main() {\n+    let n = C.b;\n+    assert n != 0xBAD;\n+    assert n == 0x600D;\n+}"}, {"sha": "a55554921c497ad078c26a5f9d79165e5c83f33e", "filename": "src/test/run-pass/const-enum-tuple.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-tuple.rs?ref=bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum E { V16(u16), V32(u32) }\n+const C: (E, u16, u16) = (V16(0xDEAD), 0x600D, 0xBAD);\n+\n+fn main() {\n+    let (_, n, _) = C;\n+    assert n != 0xBAD;\n+    assert n == 0x600D;\n+}"}, {"sha": "c02bdc74cfe44b8dea300d978fa2103e9e16b95f", "filename": "src/test/run-pass/const-enum-tuple2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-tuple2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-tuple2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-tuple2.rs?ref=bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum E { V0, V16(u16) }\n+const C: (E, u16, u16) = (V0, 0x600D, 0xBAD);\n+\n+fn main() {\n+    let (_, n, _) = C;\n+    assert n != 0xBAD;\n+    assert n == 0x600D;\n+}"}, {"sha": "d9194ff26b1da2da2efff09f563fb83780f1ea4a", "filename": "src/test/run-pass/const-enum-tuplestruct.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-tuplestruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-tuplestruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-tuplestruct.rs?ref=bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum E { V16(u16), V32(u32) }\n+struct S(E, u16, u16);\n+const C: S = S(V16(0xDEAD), 0x600D, 0xBAD);\n+\n+fn main() {\n+    let S(_, n, _) = C;\n+    assert n != 0xBAD;\n+    assert n == 0x600D;\n+}"}, {"sha": "b6d9d01479e1351736ba35923988c56e2f4155e0", "filename": "src/test/run-pass/const-enum-tuplestruct2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-tuplestruct2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-tuplestruct2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-tuplestruct2.rs?ref=bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum E { V0, V16(u16) }\n+struct S(E, u16, u16);\n+const C: S = S(V0, 0x600D, 0xBAD);\n+\n+fn main() {\n+    let S(_, n, _) = C;\n+    assert n != 0xBAD;\n+    assert n == 0x600D;\n+}"}, {"sha": "b386bbf7f5e76c9463b34017c4dba84f2180d0d0", "filename": "src/test/run-pass/const-enum-vec-index.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vec-index.rs?ref=bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum E { V1(int), V0 }\n+const C: &[E] = &[V0, V1(0xDEADBEE)];\n+const C0: E = C[0];\n+const C1: E = C[1];\n+\n+fn main() {\n+    match C0 { \n+        V0 => (),\n+        _ => die!()\n+    }\n+    match C1 {\n+        V1(n) => assert(n == 0xDEADBEE),\n+        _ => die!()\n+    }\n+}"}, {"sha": "a7b0373848080c90c15496a1cb940ef46af70360", "filename": "src/test/run-pass/const-enum-vec-ptr.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-vec-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-vec-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vec-ptr.rs?ref=bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum E { V1(int), V0 }\n+const C: &static/[E] = &[V0, V1(0xDEADBEE), V0];\n+\n+fn main() {\n+    match C[1] {\n+        V1(n) => assert(n == 0xDEADBEE),\n+        _ => die!()\n+    }\n+    match C[2] { \n+        V0 => (),\n+        _ => die!()\n+    }\n+}"}, {"sha": "4925d6c0f07df319647a5c265b9e83ed407915a6", "filename": "src/test/run-pass/const-enum-vector.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc1fb62c343639f9ac66cb0017b8c1813d5e06a7/src%2Ftest%2Frun-pass%2Fconst-enum-vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-vector.rs?ref=bc1fb62c343639f9ac66cb0017b8c1813d5e06a7", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum E { V1(int), V0 }\n+const C: [E * 3] = [V0, V1(0xDEADBEE), V0];\n+\n+fn main() {\n+    match C[1] {\n+        V1(n) => assert(n == 0xDEADBEE),\n+        _ => die!()\n+    }\n+    match C[2] { \n+        V0 => (),\n+        _ => die!()\n+    }\n+}"}]}