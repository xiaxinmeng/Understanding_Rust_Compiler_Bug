{"sha": "56ebfb185b2e144d5404eda1fc40b0070a3122f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2ZWJmYjE4NWIyZTE0NGQ1NDA0ZWRhMWZjNDBiMDA3MGEzMTIyZjM=", "commit": {"author": {"name": "Tim Vermeulen", "email": "tvermeulen@me.com", "date": "2019-06-02T11:31:49Z"}, "committer": {"name": "Tim Vermeulen", "email": "tvermeulen@me.com", "date": "2019-07-09T21:38:57Z"}, "message": "Implement DoubleEndedIterator for iter::{StepBy, Peekable, Take}", "tree": {"sha": "11e7fde867528e87491c3d216dc3a7a62ebc96f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11e7fde867528e87491c3d216dc3a7a62ebc96f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56ebfb185b2e144d5404eda1fc40b0070a3122f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56ebfb185b2e144d5404eda1fc40b0070a3122f3", "html_url": "https://github.com/rust-lang/rust/commit/56ebfb185b2e144d5404eda1fc40b0070a3122f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56ebfb185b2e144d5404eda1fc40b0070a3122f3/comments", "author": {"login": "timvermeulen", "id": 2904179, "node_id": "MDQ6VXNlcjI5MDQxNzk=", "avatar_url": "https://avatars.githubusercontent.com/u/2904179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timvermeulen", "html_url": "https://github.com/timvermeulen", "followers_url": "https://api.github.com/users/timvermeulen/followers", "following_url": "https://api.github.com/users/timvermeulen/following{/other_user}", "gists_url": "https://api.github.com/users/timvermeulen/gists{/gist_id}", "starred_url": "https://api.github.com/users/timvermeulen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timvermeulen/subscriptions", "organizations_url": "https://api.github.com/users/timvermeulen/orgs", "repos_url": "https://api.github.com/users/timvermeulen/repos", "events_url": "https://api.github.com/users/timvermeulen/events{/privacy}", "received_events_url": "https://api.github.com/users/timvermeulen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "timvermeulen", "id": 2904179, "node_id": "MDQ6VXNlcjI5MDQxNzk=", "avatar_url": "https://avatars.githubusercontent.com/u/2904179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timvermeulen", "html_url": "https://github.com/timvermeulen", "followers_url": "https://api.github.com/users/timvermeulen/followers", "following_url": "https://api.github.com/users/timvermeulen/following{/other_user}", "gists_url": "https://api.github.com/users/timvermeulen/gists{/gist_id}", "starred_url": "https://api.github.com/users/timvermeulen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timvermeulen/subscriptions", "organizations_url": "https://api.github.com/users/timvermeulen/orgs", "repos_url": "https://api.github.com/users/timvermeulen/repos", "events_url": "https://api.github.com/users/timvermeulen/events{/privacy}", "received_events_url": "https://api.github.com/users/timvermeulen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "538e17a3fdb517e0cd63f7c16d3292e7d710f7c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/538e17a3fdb517e0cd63f7c16d3292e7d710f7c7", "html_url": "https://github.com/rust-lang/rust/commit/538e17a3fdb517e0cd63f7c16d3292e7d710f7c7"}], "stats": {"total": 309, "additions": 296, "deletions": 13}, "files": [{"sha": "00053d9da84e02130f64a5845c3cc8789cca0288", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/56ebfb185b2e144d5404eda1fc40b0070a3122f3/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ebfb185b2e144d5404eda1fc40b0070a3122f3/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=56ebfb185b2e144d5404eda1fc40b0070a3122f3", "patch": "@@ -485,6 +485,39 @@ impl<I> Iterator for StepBy<I> where I: Iterator {\n     }\n }\n \n+impl<I> StepBy<I> where I: ExactSizeIterator {\n+    // The zero-based index starting from the end of the iterator of the\n+    // last element. Used in the `DoubleEndedIterator` implementation.\n+    fn next_back_index(&self) -> usize {\n+        let rem = self.iter.len() % (self.step + 1);\n+        if self.first_take {\n+            if rem == 0 { self.step } else { rem - 1 }\n+        } else {\n+            rem\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"double_ended_step_by_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for StepBy<I> where I: DoubleEndedIterator + ExactSizeIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.iter.nth_back(self.next_back_index())\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        // `self.iter.nth_back(usize::MAX)` does the right thing here when `n`\n+        // is out of bounds because the length of `self.iter` does not exceed\n+        // `usize::MAX` (because `I: ExactSizeIterator`) and `nth_back` is\n+        // zero-indexed\n+        let n = n\n+            .saturating_mul(self.step + 1)\n+            .saturating_add(self.next_back_index());\n+        self.iter.nth_back(n)\n+    }\n+}\n+\n // StepBy can only make the iterator shorter, so the len will still fit.\n #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}\n@@ -1158,6 +1191,45 @@ impl<I: Iterator> Iterator for Peekable<I> {\n     }\n }\n \n+#[stable(feature = \"double_ended_peek_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for Peekable<I> where I: DoubleEndedIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.iter.next_back().or_else(|| self.peeked.take().and_then(|x| x))\n+    }\n+\n+    #[inline]\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n+        Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n+    {\n+        match self.peeked.take() {\n+            Some(None) => return Try::from_ok(init),\n+            Some(Some(v)) => match self.iter.try_rfold(init, &mut f).into_result() {\n+                Ok(acc) => f(acc, v),\n+                Err(e) => {\n+                    self.peeked = Some(Some(v));\n+                    Try::from_error(e)\n+                }\n+            },\n+            None => self.iter.try_rfold(init, f),\n+        }\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        match self.peeked {\n+            Some(None) => return init,\n+            Some(Some(v)) => {\n+                let acc = self.iter.rfold(init, &mut fold);\n+                fold(acc, v)\n+            }\n+            None => self.iter.rfold(init, fold),\n+        }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n \n@@ -1613,6 +1685,51 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n }\n \n+#[stable(feature = \"double_ended_take_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for Take<I> where I: DoubleEndedIterator + ExactSizeIterator {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.n == 0 {\n+            None\n+        } else {\n+            let n = self.n;\n+            self.n -= 1;\n+            self.iter.nth_back(self.iter.len().saturating_sub(n))\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.iter.len();\n+        if self.n > n {\n+            let m = len.saturating_sub(self.n) + n;\n+            self.n -= n + 1;\n+            self.iter.nth_back(m)\n+        } else {\n+            if len > 0 {\n+                self.iter.nth_back(len - 1);\n+            }\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok = Acc>\n+    {\n+        if self.n == 0 {\n+            Try::from_ok(init)\n+        } else {\n+            let len = self.iter.len();\n+            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n+                Try::from_ok(init)\n+            } else {\n+                self.iter.try_rfold(init, fold)\n+            }\n+        }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n "}, {"sha": "60efeda3a40ec1ddb8d4918dd08cca3a83759ada", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 179, "deletions": 13, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/56ebfb185b2e144d5404eda1fc40b0070a3122f3/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ebfb185b2e144d5404eda1fc40b0070a3122f3/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=56ebfb185b2e144d5404eda1fc40b0070a3122f3", "patch": "@@ -188,6 +188,19 @@ fn test_iterator_step_by() {\n     assert_eq!(it.next(), Some(6));\n     assert_eq!(it.next(), Some(9));\n     assert_eq!(it.next(), None);\n+\n+    let mut it = (0..3).step_by(1);\n+    assert_eq!(it.next_back(), Some(2));\n+    assert_eq!(it.next_back(), Some(1));\n+    assert_eq!(it.next_back(), Some(0));\n+    assert_eq!(it.next_back(), None);\n+\n+    let mut it = (0..11).step_by(3);\n+    assert_eq!(it.next_back(), Some(9));\n+    assert_eq!(it.next_back(), Some(6));\n+    assert_eq!(it.next_back(), Some(3));\n+    assert_eq!(it.next_back(), Some(0));\n+    assert_eq!(it.next_back(), None);\n }\n \n #[test]\n@@ -252,6 +265,31 @@ fn test_iterator_step_by_nth_overflow() {\n     assert_eq!(it.0, (usize::MAX as Bigger) * 1);\n }\n \n+#[test]\n+fn test_iterator_step_by_nth_back() {\n+    let mut it = (0..16).step_by(5);\n+    assert_eq!(it.nth_back(0), Some(15));\n+    assert_eq!(it.nth_back(0), Some(10));\n+    assert_eq!(it.nth_back(0), Some(5));\n+    assert_eq!(it.nth_back(0), Some(0));\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let mut it = (0..16).step_by(5);\n+    assert_eq!(it.next(), Some(0)); // to set `first_take` to `false`\n+    assert_eq!(it.nth_back(0), Some(15));\n+    assert_eq!(it.nth_back(0), Some(10));\n+    assert_eq!(it.nth_back(0), Some(5));\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let it = || (0..18).step_by(5);\n+    assert_eq!(it().nth_back(0), Some(15));\n+    assert_eq!(it().nth_back(1), Some(10));\n+    assert_eq!(it().nth_back(2), Some(5));\n+    assert_eq!(it().nth_back(3), Some(0));\n+    assert_eq!(it().nth_back(4), None);\n+    assert_eq!(it().nth_back(42), None);\n+}\n+\n #[test]\n #[should_panic]\n fn test_iterator_step_by_zero() {\n@@ -465,8 +503,8 @@ fn test_iterator_filter_fold() {\n #[test]\n fn test_iterator_peekable() {\n     let xs = vec![0, 1, 2, 3, 4, 5];\n-    let mut it = xs.iter().cloned().peekable();\n \n+    let mut it = xs.iter().cloned().peekable();\n     assert_eq!(it.len(), 6);\n     assert_eq!(it.peek().unwrap(), &0);\n     assert_eq!(it.len(), 6);\n@@ -492,6 +530,33 @@ fn test_iterator_peekable() {\n     assert_eq!(it.len(), 0);\n     assert!(it.next().is_none());\n     assert_eq!(it.len(), 0);\n+\n+    let mut it = xs.iter().cloned().peekable();\n+    assert_eq!(it.len(), 6);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 6);\n+    assert_eq!(it.next_back().unwrap(), 5);\n+    assert_eq!(it.len(), 5);\n+    assert_eq!(it.next_back().unwrap(), 4);\n+    assert_eq!(it.len(), 4);\n+    assert_eq!(it.next_back().unwrap(), 3);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 3);\n+    assert_eq!(it.next_back().unwrap(), 2);\n+    assert_eq!(it.len(), 2);\n+    assert_eq!(it.next_back().unwrap(), 1);\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.peek().unwrap(), &0);\n+    assert_eq!(it.len(), 1);\n+    assert_eq!(it.next_back().unwrap(), 0);\n+    assert_eq!(it.len(), 0);\n+    assert!(it.peek().is_none());\n+    assert_eq!(it.len(), 0);\n+    assert!(it.next_back().is_none());\n+    assert_eq!(it.len(), 0);\n }\n \n #[test]\n@@ -564,6 +629,18 @@ fn test_iterator_peekable_fold() {\n     assert_eq!(i, xs.len());\n }\n \n+#[test]\n+fn test_iterator_peekable_rfold() {\n+    let xs = [0, 1, 2, 3, 4, 5];\n+    let mut it = xs.iter().peekable();\n+    assert_eq!(it.peek(), Some(&&0));\n+    let i = it.rfold(0, |i, &x| {\n+        assert_eq!(x, xs[xs.len() - 1 - i]);\n+        i + 1\n+    });\n+    assert_eq!(i, xs.len());\n+}\n+\n /// This is an iterator that follows the Iterator contract,\n /// but it is not fused. After having returned None once, it will start\n /// producing elements if .next() is called again.\n@@ -812,13 +889,25 @@ fn test_iterator_skip_fold() {\n fn test_iterator_take() {\n     let xs = [0, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n     let ys = [0, 1, 2, 3, 5];\n-    let mut it = xs.iter().take(5);\n+\n+    let mut it = xs.iter().take(ys.len());\n     let mut i = 0;\n-    assert_eq!(it.len(), 5);\n+    assert_eq!(it.len(), ys.len());\n     while let Some(&x) = it.next() {\n         assert_eq!(x, ys[i]);\n         i += 1;\n-        assert_eq!(it.len(), 5-i);\n+        assert_eq!(it.len(), ys.len() - i);\n+    }\n+    assert_eq!(i, ys.len());\n+    assert_eq!(it.len(), 0);\n+\n+    let mut it = xs.iter().take(ys.len());\n+    let mut i = 0;\n+    assert_eq!(it.len(), ys.len());\n+    while let Some(&x) = it.next_back() {\n+        i += 1;\n+        assert_eq!(x, ys[ys.len() - i]);\n+        assert_eq!(it.len(), ys.len() - i);\n     }\n     assert_eq!(i, ys.len());\n     assert_eq!(it.len(), 0);\n@@ -848,19 +937,51 @@ fn test_iterator_take_nth() {\n     }\n }\n \n+#[test]\n+fn test_iterator_take_nth_back() {\n+    let xs = [0, 1, 2, 4, 5];\n+    let mut it = xs.iter();\n+    {\n+        let mut take = it.by_ref().take(3);\n+        let mut i = 0;\n+        while let Some(&x) = take.nth_back(0) {\n+            i += 1;\n+            assert_eq!(x, 3 - i);\n+        }\n+    }\n+    assert_eq!(it.nth_back(0), None);\n+\n+    let xs = [0, 1, 2, 3, 4];\n+    let mut it = xs.iter().take(7);\n+    assert_eq!(it.nth_back(1), Some(&3));\n+    assert_eq!(it.nth_back(1), Some(&1));\n+    assert_eq!(it.nth_back(1), None);\n+}\n+\n #[test]\n fn test_iterator_take_short() {\n     let xs = [0, 1, 2, 3];\n-    let ys = [0, 1, 2, 3];\n+\n     let mut it = xs.iter().take(5);\n     let mut i = 0;\n-    assert_eq!(it.len(), 4);\n+    assert_eq!(it.len(), xs.len());\n     while let Some(&x) = it.next() {\n-        assert_eq!(x, ys[i]);\n+        assert_eq!(x, xs[i]);\n         i += 1;\n-        assert_eq!(it.len(), 4-i);\n+        assert_eq!(it.len(), xs.len() - i);\n     }\n-    assert_eq!(i, ys.len());\n+    assert_eq!(i, xs.len());\n+    assert_eq!(it.len(), 0);\n+\n+    let mut it = xs.iter().take(5);\n+    let mut i = 0;\n+    assert_eq!(it.len(), xs.len());\n+    while let Some(&x) = it.next_back() {\n+        i += 1;\n+        assert_eq!(x, xs[xs.len() - i]);\n+        assert_eq!(it.len(), xs.len() - i);\n+    }\n+    assert_eq!(i, xs.len());\n     assert_eq!(it.len(), 0);\n }\n \n@@ -2241,17 +2362,50 @@ fn test_enumerate_try_folds() {\n }\n \n #[test]\n-fn test_peek_try_fold() {\n+fn test_peek_try_folds() {\n     let f = &|acc, x| i32::checked_add(2*acc, x);\n+\n     assert_eq!((1..20).peekable().try_fold(7, f), (1..20).try_fold(7, f));\n+    assert_eq!((1..20).peekable().try_rfold(7, f), (1..20).try_rfold(7, f));\n+\n     let mut iter = (1..20).peekable();\n     assert_eq!(iter.peek(), Some(&1));\n     assert_eq!(iter.try_fold(7, f), (1..20).try_fold(7, f));\n \n+    let mut iter = (1..20).peekable();\n+    assert_eq!(iter.peek(), Some(&1));\n+    assert_eq!(iter.try_rfold(7, f), (1..20).try_rfold(7, f));\n+\n     let mut iter = [100, 20, 30, 40, 50, 60, 70].iter().cloned().peekable();\n     assert_eq!(iter.peek(), Some(&100));\n     assert_eq!(iter.try_fold(0, i8::checked_add), None);\n     assert_eq!(iter.peek(), Some(&40));\n+\n+    let mut iter = [100, 20, 30, 40, 50, 60, 70].iter().cloned().peekable();\n+    assert_eq!(iter.peek(), Some(&100));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.peek(), Some(&100));\n+    assert_eq!(iter.next_back(), Some(50));\n+\n+    let mut iter = (2..5).peekable();\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_for_each(Err), Err(2));\n+    assert_eq!(iter.peek(), Some(&3));\n+    assert_eq!(iter.try_for_each(Err), Err(3));\n+    assert_eq!(iter.peek(), Some(&4));\n+    assert_eq!(iter.try_for_each(Err), Err(4));\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.try_for_each(Err), Ok(()));\n+\n+    let mut iter = (2..5).peekable();\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(4));\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(3));\n+    assert_eq!(iter.peek(), Some(&2));\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Err(2));\n+    assert_eq!(iter.peek(), None);\n+    assert_eq!(iter.try_rfold((), |(), x| Err(x)), Ok(()));\n }\n \n #[test]\n@@ -2300,13 +2454,25 @@ fn test_skip_try_folds() {\n fn test_take_try_folds() {\n     let f = &|acc, x| i32::checked_add(2*acc, x);\n     assert_eq!((10..30).take(10).try_fold(7, f), (10..20).try_fold(7, f));\n-    //assert_eq!((10..30).take(10).try_rfold(7, f), (10..20).try_rfold(7, f));\n+    assert_eq!((10..30).take(10).try_rfold(7, f), (10..20).try_rfold(7, f));\n \n     let mut iter = (10..30).take(20);\n     assert_eq!(iter.try_fold(0, i8::checked_add), None);\n     assert_eq!(iter.next(), Some(20));\n-    //assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n-    //assert_eq!(iter.next_back(), Some(24));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(24));\n+\n+    let mut iter = (2..20).take(3);\n+    assert_eq!(iter.try_for_each(Err), Err(2));\n+    assert_eq!(iter.try_for_each(Err), Err(3));\n+    assert_eq!(iter.try_for_each(Err), Err(4));\n+    assert_eq!(iter.try_for_each(Err), Ok(()));\n+\n+    let mut iter = (2..20).take(3).rev();\n+    assert_eq!(iter.try_for_each(Err), Err(4));\n+    assert_eq!(iter.try_for_each(Err), Err(3));\n+    assert_eq!(iter.try_for_each(Err), Err(2));\n+    assert_eq!(iter.try_for_each(Err), Ok(()));\n }\n \n #[test]"}]}