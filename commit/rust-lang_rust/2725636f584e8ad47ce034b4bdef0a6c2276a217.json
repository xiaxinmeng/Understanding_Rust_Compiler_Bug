{"sha": "2725636f584e8ad47ce034b4bdef0a6c2276a217", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MjU2MzZmNTg0ZThhZDQ3Y2UwMzRiNGJkZWYwYTZjMjI3NmEyMTc=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-07-12T04:23:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-07-12T04:23:18Z"}, "message": "Merge pull request #1782 from topecongiro/rfc/combining-match-arm\n\nRfc: combining match arm", "tree": {"sha": "fabf1c7bf2b985b1d118601345ef96e7a35f0b04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fabf1c7bf2b985b1d118601345ef96e7a35f0b04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2725636f584e8ad47ce034b4bdef0a6c2276a217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2725636f584e8ad47ce034b4bdef0a6c2276a217", "html_url": "https://github.com/rust-lang/rust/commit/2725636f584e8ad47ce034b4bdef0a6c2276a217", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2725636f584e8ad47ce034b4bdef0a6c2276a217/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3552595a3b40abd1aa5a24074f4ab2caa2fa034f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3552595a3b40abd1aa5a24074f4ab2caa2fa034f", "html_url": "https://github.com/rust-lang/rust/commit/3552595a3b40abd1aa5a24074f4ab2caa2fa034f"}, {"sha": "c11aac04a34b64fc90a5da5602a5b14a818fd71c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c11aac04a34b64fc90a5da5602a5b14a818fd71c", "html_url": "https://github.com/rust-lang/rust/commit/c11aac04a34b64fc90a5da5602a5b14a818fd71c"}], "stats": {"total": 1390, "additions": 614, "deletions": 776}, "files": [{"sha": "58124b8bc9333a51d129b1d8cc3a9a62e7fb6218", "filename": "Configurations.md", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/Configurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/Configurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Configurations.md?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -1986,7 +1986,7 @@ Break comments to fit on the line\n \n ## `wrap_match_arms`\n \n-Wrap multiline match arms in blocks\n+Wrap the body of arms in blocks when it does not fit on the same line with the pattern of arms\n \n - **Default value**: `true`\n - **Possible values**: `true`, `false`\n@@ -1995,13 +1995,9 @@ Wrap multiline match arms in blocks\n \n ```rust\n match lorem {\n-    true => {\n-        let ipsum = dolor;\n-        println!(\"{}\", ipsum);\n-    }\n-    false => {\n-        println!(\"{}\", sit)\n-    }\n+    true =>\n+        foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x),\n+    false => println!(\"{}\", sit),\n }\n ```\n \n@@ -2010,8 +2006,7 @@ match lorem {\n ```rust\n match lorem {\n     true => {\n-        let ipsum = dolor;\n-        println!(\"{}\", ipsum);\n+        foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x)\n     }\n     false => println!(\"{}\", sit),\n }"}, {"sha": "3f7d11c0a97de22fa867ce7287ec2351fac116d2", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -90,13 +90,11 @@ fn execute() -> i32 {\n             print_usage(&opts, &e.to_string());\n             failure\n         }\n-        Ok(status) => {\n-            if status.success() {\n-                success\n-            } else {\n-                status.code().unwrap_or(failure)\n-            }\n-        }\n+        Ok(status) => if status.success() {\n+            success\n+        } else {\n+            status.code().unwrap_or(failure)\n+        },\n     }\n }\n \n@@ -324,12 +322,10 @@ fn format_files(\n         .args(fmt_args)\n         .spawn()\n         .map_err(|e| match e.kind() {\n-            std::io::ErrorKind::NotFound => {\n-                std::io::Error::new(\n-                    std::io::ErrorKind::Other,\n-                    \"Could not run rustfmt, please make sure it is in your PATH.\",\n-                )\n-            }\n+            std::io::ErrorKind::NotFound => std::io::Error::new(\n+                std::io::ErrorKind::Other,\n+                \"Could not run rustfmt, please make sure it is in your PATH.\",\n+            ),\n             _ => e,\n         })?;\n     command.wait()"}, {"sha": "1660e113dcd23cd199ebf2544719fd4c9e28a197", "filename": "src/chains.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -444,12 +444,10 @@ fn rewrite_method_call_with_overflow(\n             None => return false,\n         };\n         let types = match segment.parameters {\n-            Some(ref params) => {\n-                match **params {\n-                    ast::PathParameters::AngleBracketed(ref data) => &data.types[..],\n-                    _ => &[],\n-                }\n-            }\n+            Some(ref params) => match **params {\n+                ast::PathParameters::AngleBracketed(ref data) => &data.types[..],\n+                _ => &[],\n+            },\n             _ => &[],\n         };\n         let mut last_rewrite = rewrite_method_call(\n@@ -516,12 +514,10 @@ fn rewrite_chain_subexpr(\n     match expr.node {\n         ast::ExprKind::MethodCall(ref segment, ref expressions) => {\n             let types = match segment.parameters {\n-                Some(ref params) => {\n-                    match **params {\n-                        ast::PathParameters::AngleBracketed(ref data) => &data.types[..],\n-                        _ => &[],\n-                    }\n-                }\n+                Some(ref params) => match **params {\n+                    ast::PathParameters::AngleBracketed(ref data) => &data.types[..],\n+                    _ => &[],\n+                },\n                 _ => &[],\n             };\n             rewrite_method_call(segment.identifier, types, expressions, span, context, shape)"}, {"sha": "df97c2bfef3ec5eee31a217698e90a1115fefa60", "filename": "src/comment.rs", "status": "modified", "additions": 38, "deletions": 50, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -342,14 +342,12 @@ impl FindUncommented for str {\n                 None => {\n                     return Some(i - pat.len());\n                 }\n-                Some(c) => {\n-                    match kind {\n-                        FullCodeCharKind::Normal if b == c => {}\n-                        _ => {\n-                            needle_iter = pat.chars();\n-                        }\n+                Some(c) => match kind {\n+                    FullCodeCharKind::Normal if b == c => {}\n+                    _ => {\n+                        needle_iter = pat.chars();\n                     }\n-                }\n+                },\n             }\n         }\n \n@@ -494,42 +492,34 @@ where\n         let item = try_opt!(self.base.next());\n         let chr = item.get_char();\n         self.status = match self.status {\n-            CharClassesStatus::LitString => {\n-                match chr {\n-                    '\"' => CharClassesStatus::Normal,\n-                    '\\\\' => CharClassesStatus::LitStringEscape,\n-                    _ => CharClassesStatus::LitString,\n-                }\n-            }\n+            CharClassesStatus::LitString => match chr {\n+                '\"' => CharClassesStatus::Normal,\n+                '\\\\' => CharClassesStatus::LitStringEscape,\n+                _ => CharClassesStatus::LitString,\n+            },\n             CharClassesStatus::LitStringEscape => CharClassesStatus::LitString,\n-            CharClassesStatus::LitChar => {\n-                match chr {\n-                    '\\\\' => CharClassesStatus::LitCharEscape,\n-                    '\\'' => CharClassesStatus::Normal,\n-                    _ => CharClassesStatus::LitChar,\n-                }\n-            }\n+            CharClassesStatus::LitChar => match chr {\n+                '\\\\' => CharClassesStatus::LitCharEscape,\n+                '\\'' => CharClassesStatus::Normal,\n+                _ => CharClassesStatus::LitChar,\n+            },\n             CharClassesStatus::LitCharEscape => CharClassesStatus::LitChar,\n-            CharClassesStatus::Normal => {\n-                match chr {\n-                    '\"' => CharClassesStatus::LitString,\n-                    '\\'' => CharClassesStatus::LitChar,\n-                    '/' => {\n-                        match self.base.peek() {\n-                            Some(next) if next.get_char() == '*' => {\n-                                self.status = CharClassesStatus::BlockCommentOpening(1);\n-                                return Some((FullCodeCharKind::StartComment, item));\n-                            }\n-                            Some(next) if next.get_char() == '/' => {\n-                                self.status = CharClassesStatus::LineComment;\n-                                return Some((FullCodeCharKind::StartComment, item));\n-                            }\n-                            _ => CharClassesStatus::Normal,\n-                        }\n+            CharClassesStatus::Normal => match chr {\n+                '\"' => CharClassesStatus::LitString,\n+                '\\'' => CharClassesStatus::LitChar,\n+                '/' => match self.base.peek() {\n+                    Some(next) if next.get_char() == '*' => {\n+                        self.status = CharClassesStatus::BlockCommentOpening(1);\n+                        return Some((FullCodeCharKind::StartComment, item));\n+                    }\n+                    Some(next) if next.get_char() == '/' => {\n+                        self.status = CharClassesStatus::LineComment;\n+                        return Some((FullCodeCharKind::StartComment, item));\n                     }\n                     _ => CharClassesStatus::Normal,\n-                }\n-            }\n+                },\n+                _ => CharClassesStatus::Normal,\n+            },\n             CharClassesStatus::BlockComment(deepness) => {\n                 assert!(deepness != 0);\n                 self.status = match self.base.peek() {\n@@ -558,18 +548,16 @@ where\n                     return Some((FullCodeCharKind::InComment, item));\n                 }\n             }\n-            CharClassesStatus::LineComment => {\n-                match chr {\n-                    '\\n' => {\n-                        self.status = CharClassesStatus::Normal;\n-                        return Some((FullCodeCharKind::EndComment, item));\n-                    }\n-                    _ => {\n-                        self.status = CharClassesStatus::LineComment;\n-                        return Some((FullCodeCharKind::InComment, item));\n-                    }\n+            CharClassesStatus::LineComment => match chr {\n+                '\\n' => {\n+                    self.status = CharClassesStatus::Normal;\n+                    return Some((FullCodeCharKind::EndComment, item));\n                 }\n-            }\n+                _ => {\n+                    self.status = CharClassesStatus::LineComment;\n+                    return Some((FullCodeCharKind::InComment, item));\n+                }\n+            },\n         };\n         Some((FullCodeCharKind::Normal, item))\n     }"}, {"sha": "2fe6d3ea6b633beca3381222e3c2ac4dba8a0400", "filename": "src/config.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -482,11 +482,9 @@ pub fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n             Ok(ref md) if md.is_file() => return Ok(Some(config_file)),\n             // Return the error if it's something other than `NotFound`; otherwise we didn't\n             // find the project file yet, and continue searching.\n-            Err(e) => {\n-                if e.kind() != ErrorKind::NotFound {\n-                    return Err(e);\n-                }\n-            }\n+            Err(e) => if e.kind() != ErrorKind::NotFound {\n+                return Err(e);\n+            },\n             _ => {}\n         }\n     }\n@@ -572,7 +570,8 @@ create_config! {\n     wrap_comments: bool, false, \"Break comments to fit on the line\";\n     comment_width: usize, 80, \"Maximum length of comments. No effect unless wrap_comments = true\";\n     normalize_comments: bool, false, \"Convert /* */ comments to // comments where possible\";\n-    wrap_match_arms: bool, true, \"Wrap multiline match arms in blocks\";\n+    wrap_match_arms: bool, true, \"Wrap the body of arms in blocks when it does not fit on \\\n+                                  the same line with the pattern of arms\";\n     match_block_trailing_comma: bool, false,\n         \"Put a trailing comma after a block based match arm (non-block arms are not affected)\";\n     indent_match_arms: bool, true, \"Indent match arms instead of keeping them at the same \\"}, {"sha": "9adb601c9cb3f532dfe447dc2708554838909f4a", "filename": "src/expr.rs", "status": "modified", "additions": 307, "deletions": 357, "changes": 664, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -88,29 +88,23 @@ pub fn format_expr(\n         }\n     }\n     let expr_rw = match expr.node {\n-        ast::ExprKind::Array(ref expr_vec) => {\n-            rewrite_array(\n-                expr_vec.iter().map(|e| &**e),\n-                mk_sp(context.codemap.span_after(expr.span, \"[\"), expr.span.hi),\n-                context,\n-                shape,\n-                false,\n-            )\n-        }\n-        ast::ExprKind::Lit(ref l) => {\n-            match l.node {\n-                ast::LitKind::Str(_, ast::StrStyle::Cooked) => {\n-                    rewrite_string_lit(context, l.span, shape)\n-                }\n-                _ => {\n-                    wrap_str(\n-                        context.snippet(expr.span),\n-                        context.config.max_width(),\n-                        shape,\n-                    )\n-                }\n+        ast::ExprKind::Array(ref expr_vec) => rewrite_array(\n+            expr_vec.iter().map(|e| &**e),\n+            mk_sp(context.codemap.span_after(expr.span, \"[\"), expr.span.hi),\n+            context,\n+            shape,\n+            false,\n+        ),\n+        ast::ExprKind::Lit(ref l) => match l.node {\n+            ast::LitKind::Str(_, ast::StrStyle::Cooked) => {\n+                rewrite_string_lit(context, l.span, shape)\n             }\n-        }\n+            _ => wrap_str(\n+                context.snippet(expr.span),\n+                context.config.max_width(),\n+                shape,\n+            ),\n+        },\n         ast::ExprKind::Call(ref callee, ref args) => {\n             let inner_span = mk_sp(callee.span.hi, expr.span.hi);\n             rewrite_call_with_binary_search(\n@@ -135,33 +129,27 @@ pub fn format_expr(\n             )\n         }\n         ast::ExprKind::Unary(ref op, ref subexpr) => rewrite_unary_op(context, op, subexpr, shape),\n-        ast::ExprKind::Struct(ref path, ref fields, ref base) => {\n-            rewrite_struct_lit(\n-                context,\n-                path,\n-                fields,\n-                base.as_ref().map(|e| &**e),\n-                expr.span,\n-                shape,\n-            )\n-        }\n-        ast::ExprKind::Tup(ref items) => {\n-            rewrite_tuple(\n-                context,\n-                &items.iter().map(|x| &**x).collect::<Vec<_>>()[..],\n-                expr.span,\n-                shape,\n-            )\n-        }\n+        ast::ExprKind::Struct(ref path, ref fields, ref base) => rewrite_struct_lit(\n+            context,\n+            path,\n+            fields,\n+            base.as_ref().map(|e| &**e),\n+            expr.span,\n+            shape,\n+        ),\n+        ast::ExprKind::Tup(ref items) => rewrite_tuple(\n+            context,\n+            &items.iter().map(|x| &**x).collect::<Vec<_>>()[..],\n+            expr.span,\n+            shape,\n+        ),\n         ast::ExprKind::If(..) |\n         ast::ExprKind::IfLet(..) |\n         ast::ExprKind::ForLoop(..) |\n         ast::ExprKind::Loop(..) |\n         ast::ExprKind::While(..) |\n-        ast::ExprKind::WhileLet(..) => {\n-            to_control_flow(expr, expr_type)\n-                .and_then(|control_flow| control_flow.rewrite(context, shape))\n-        }\n+        ast::ExprKind::WhileLet(..) => to_control_flow(expr, expr_type)\n+            .and_then(|control_flow| control_flow.rewrite(context, shape)),\n         ast::ExprKind::Block(ref block) => {\n             match expr_type {\n                 ExprType::Statement => {\n@@ -271,14 +259,12 @@ pub fn format_expr(\n \n             fn needs_space_before_range(context: &RewriteContext, lhs: &ast::Expr) -> bool {\n                 match lhs.node {\n-                    ast::ExprKind::Lit(ref lit) => {\n-                        match lit.node {\n-                            ast::LitKind::FloatUnsuffixed(..) => {\n-                                context.snippet(lit.span).ends_with('.')\n-                            }\n-                            _ => false,\n+                    ast::ExprKind::Lit(ref lit) => match lit.node {\n+                        ast::LitKind::FloatUnsuffixed(..) => {\n+                            context.snippet(lit.span).ends_with('.')\n                         }\n-                    }\n+                        _ => false,\n+                    },\n                     _ => false,\n                 }\n             }\n@@ -315,13 +301,11 @@ pub fn format_expr(\n         }\n         // We do not format these expressions yet, but they should still\n         // satisfy our width restrictions.\n-        ast::ExprKind::InPlace(..) | ast::ExprKind::InlineAsm(..) => {\n-            wrap_str(\n-                context.snippet(expr.span),\n-                context.config.max_width(),\n-                shape,\n-            )\n-        }\n+        ast::ExprKind::InPlace(..) | ast::ExprKind::InlineAsm(..) => wrap_str(\n+            context.snippet(expr.span),\n+            context.config.max_width(),\n+            shape,\n+        ),\n         ast::ExprKind::Catch(ref block) => {\n             if let rewrite @ Some(_) =\n                 rewrite_single_line_block(context, \"do catch \", block, shape)\n@@ -338,14 +322,12 @@ pub fn format_expr(\n         }\n     };\n     match (attr_rw, expr_rw) {\n-        (Some(attr_str), Some(expr_str)) => {\n-            recover_comment_removed(\n-                combine_attr_and_expr(context, shape, &attr_str, &expr_str),\n-                expr.span,\n-                context,\n-                shape,\n-            )\n-        }\n+        (Some(attr_str), Some(expr_str)) => recover_comment_removed(\n+            combine_attr_and_expr(context, shape, &attr_str, &expr_str),\n+            expr.span,\n+            context,\n+            shape,\n+        ),\n         _ => None,\n     }\n }\n@@ -460,22 +442,18 @@ where\n     };\n \n     let mut nested_shape = match context.config.array_layout() {\n-        IndentStyle::Block => {\n-            try_opt!(\n-                shape\n-                    .block()\n-                    .block_indent(context.config.tab_spaces())\n-                    .with_max_width(context.config)\n-                    .sub_width(1)\n-            )\n-        }\n-        IndentStyle::Visual => {\n-            try_opt!(\n-                shape\n-                    .visual_indent(bracket_size)\n-                    .sub_width(bracket_size * 2)\n-            )\n-        }\n+        IndentStyle::Block => try_opt!(\n+            shape\n+                .block()\n+                .block_indent(context.config.tab_spaces())\n+                .with_max_width(context.config)\n+                .sub_width(1)\n+        ),\n+        IndentStyle::Visual => try_opt!(\n+            shape\n+                .visual_indent(bracket_size)\n+                .sub_width(bracket_size * 2)\n+        ),\n     };\n \n     let items = itemize_list(\n@@ -513,17 +491,15 @@ where\n                 None => DefinitiveListTactic::Vertical,\n             }\n         }\n-        IndentStyle::Visual => {\n-            if has_long_item || items.iter().any(ListItem::is_multiline) {\n-                definitive_tactic(\n-                    &items,\n-                    ListTactic::LimitedHorizontalVertical(context.config.array_width()),\n-                    nested_shape.width,\n-                )\n-            } else {\n-                DefinitiveListTactic::Mixed\n-            }\n-        }\n+        IndentStyle::Visual => if has_long_item || items.iter().any(ListItem::is_multiline) {\n+            definitive_tactic(\n+                &items,\n+                ListTactic::LimitedHorizontalVertical(context.config.array_width()),\n+                nested_shape.width,\n+            )\n+        } else {\n+            DefinitiveListTactic::Mixed\n+        },\n     };\n     if context.config.array_horizontal_layout_threshold() > 0 &&\n         items.len() > context.config.array_horizontal_layout_threshold()\n@@ -965,15 +941,13 @@ fn rewrite_cond(context: &RewriteContext, expr: &ast::Expr, shape: Shape) -> Opt\n         ast::ExprKind::Block(ref block) if block.stmts.len() == 1 => {\n             stmt_expr(&block.stmts[0]).and_then(|e| rewrite_cond(context, e, shape))\n         }\n-        _ => {\n-            to_control_flow(expr, ExprType::SubExpression).and_then(|control_flow| {\n-                let alt_block_sep =\n-                    String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n-                control_flow\n-                    .rewrite_cond(context, shape, &alt_block_sep)\n-                    .and_then(|rw| Some(rw.0))\n-            })\n-        }\n+        _ => to_control_flow(expr, ExprType::SubExpression).and_then(|control_flow| {\n+            let alt_block_sep =\n+                String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n+            control_flow\n+                .rewrite_cond(context, shape, &alt_block_sep)\n+                .and_then(|rw| Some(rw.0))\n+        }),\n     }\n }\n \n@@ -996,17 +970,15 @@ struct ControlFlow<'a> {\n \n fn to_control_flow<'a>(expr: &'a ast::Expr, expr_type: ExprType) -> Option<ControlFlow<'a>> {\n     match expr.node {\n-        ast::ExprKind::If(ref cond, ref if_block, ref else_block) => {\n-            Some(ControlFlow::new_if(\n-                cond,\n-                None,\n-                if_block,\n-                else_block.as_ref().map(|e| &**e),\n-                expr_type == ExprType::SubExpression,\n-                false,\n-                expr.span,\n-            ))\n-        }\n+        ast::ExprKind::If(ref cond, ref if_block, ref else_block) => Some(ControlFlow::new_if(\n+            cond,\n+            None,\n+            if_block,\n+            else_block.as_ref().map(|e| &**e),\n+            expr_type == ExprType::SubExpression,\n+            false,\n+            expr.span,\n+        )),\n         ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n             Some(ControlFlow::new_if(\n                 cond,\n@@ -1021,21 +993,15 @@ fn to_control_flow<'a>(expr: &'a ast::Expr, expr_type: ExprType) -> Option<Contr\n         ast::ExprKind::ForLoop(ref pat, ref cond, ref block, label) => {\n             Some(ControlFlow::new_for(pat, cond, block, label, expr.span))\n         }\n-        ast::ExprKind::Loop(ref block, label) => Some(\n-            ControlFlow::new_loop(block, label, expr.span),\n-        ),\n-        ast::ExprKind::While(ref cond, ref block, label) => Some(\n-            ControlFlow::new_while(None, cond, block, label, expr.span),\n-        ),\n-        ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => {\n-            Some(ControlFlow::new_while(\n-                Some(pat),\n-                cond,\n-                block,\n-                label,\n-                expr.span,\n-            ))\n+        ast::ExprKind::Loop(ref block, label) => {\n+            Some(ControlFlow::new_loop(block, label, expr.span))\n         }\n+        ast::ExprKind::While(ref cond, ref block, label) => {\n+            Some(ControlFlow::new_while(None, cond, block, label, expr.span))\n+        }\n+        ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => Some(\n+            ControlFlow::new_while(Some(pat), cond, block, label, expr.span),\n+        ),\n         _ => None,\n     }\n }\n@@ -1553,27 +1519,96 @@ fn rewrite_match(\n         ControlBraceStyle::AlwaysNextLine => alt_block_sep.as_str(),\n         _ => \" \",\n     };\n-    let mut result = format!(\"match {}{}{{\", cond_str, block_sep);\n+\n+    Some(format!(\n+        \"match {}{}{{{}\\n{}}}\",\n+        cond_str,\n+        block_sep,\n+        try_opt!(rewrite_match_arms(context, arms, shape, span, cond.span.hi)),\n+        shape.indent.to_string(context.config),\n+    ))\n+}\n+\n+fn arm_comma(config: &Config, body: &ast::Expr) -> &'static str {\n+    if config.match_block_trailing_comma() {\n+        \",\"\n+    } else if let ast::ExprKind::Block(ref block) = body.node {\n+        if let ast::BlockCheckMode::Default = block.rules {\n+            \"\"\n+        } else {\n+            \",\"\n+        }\n+    } else {\n+        \",\"\n+    }\n+}\n+\n+fn rewrite_match_pattern(\n+    context: &RewriteContext,\n+    pats: &Vec<ptr::P<ast::Pat>>,\n+    guard: &Option<ptr::P<ast::Expr>>,\n+    shape: Shape,\n+) -> Option<String> {\n+    // Patterns\n+    // 5 = ` => {`\n+    let pat_shape = try_opt!(shape.sub_width(5));\n+\n+    let pat_strs = try_opt!(\n+        pats.iter()\n+            .map(|p| p.rewrite(context, pat_shape))\n+            .collect::<Option<Vec<_>>>()\n+    );\n+\n+    let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n+    let tactic = definitive_tactic(&items, ListTactic::HorizontalVertical, pat_shape.width);\n+    let fmt = ListFormatting {\n+        tactic: tactic,\n+        separator: \" |\",\n+        trailing_separator: SeparatorTactic::Never,\n+        shape: pat_shape,\n+        ends_with_newline: false,\n+        config: context.config,\n+    };\n+    let pats_str = try_opt!(write_list(&items, &fmt));\n+\n+    // Guard\n+    let guard_str = try_opt!(rewrite_guard(\n+        context,\n+        guard,\n+        shape,\n+        trimmed_last_line_width(&pats_str),\n+    ));\n+\n+    Some(format!(\"{}{}\", pats_str, guard_str))\n+}\n+\n+fn rewrite_match_arms(\n+    context: &RewriteContext,\n+    arms: &[ast::Arm],\n+    shape: Shape,\n+    span: Span,\n+    cond_end_pos: BytePos,\n+) -> Option<String> {\n+    let mut result = String::new();\n \n     let arm_shape = if context.config.indent_match_arms() {\n         shape.block_indent(context.config.tab_spaces())\n     } else {\n         shape.block_indent(0)\n-    };\n-\n+    }.with_max_width(context.config);\n     let arm_indent_str = arm_shape.indent.to_string(context.config);\n \n     let open_brace_pos = context\n         .codemap\n-        .span_after(mk_sp(cond.span.hi, arm_start_pos(&arms[0])), \"{\");\n+        .span_after(mk_sp(cond_end_pos, arms[0].span().lo), \"{\");\n \n     let arm_num = arms.len();\n     for (i, arm) in arms.iter().enumerate() {\n         // Make sure we get the stuff between arms.\n         let missed_str = if i == 0 {\n-            context.snippet(mk_sp(open_brace_pos, arm_start_pos(arm)))\n+            context.snippet(mk_sp(open_brace_pos, arm.span().lo))\n         } else {\n-            context.snippet(mk_sp(arm_end_pos(&arms[i - 1]), arm_start_pos(arm)))\n+            context.snippet(mk_sp(arms[i - 1].span().hi, arm.span().lo))\n         };\n         let comment = try_opt!(rewrite_match_arm_comment(\n             context,\n@@ -1585,7 +1620,7 @@ fn rewrite_match(\n         result.push('\\n');\n         result.push_str(&arm_indent_str);\n \n-        let arm_str = arm.rewrite(&context, arm_shape.with_max_width(context.config));\n+        let arm_str = rewrite_match_arm(context, arm, arm_shape);\n         if let Some(ref arm_str) = arm_str {\n             // Trim the trailing comma if necessary.\n             if i == arm_num - 1 && context.config.trailing_comma() == SeparatorTactic::Never &&\n@@ -1597,15 +1632,15 @@ fn rewrite_match(\n             }\n         } else {\n             // We couldn't format the arm, just reproduce the source.\n-            let snippet = context.snippet(mk_sp(arm_start_pos(arm), arm_end_pos(arm)));\n+            let snippet = context.snippet(arm.span());\n             result.push_str(&snippet);\n             if context.config.trailing_comma() != SeparatorTactic::Never {\n                 result.push_str(arm_comma(context.config, &arm.body))\n             }\n         }\n     }\n     // BytePos(1) = closing match brace.\n-    let last_span = mk_sp(arm_end_pos(&arms[arms.len() - 1]), span.hi - BytePos(1));\n+    let last_span = mk_sp(arms[arms.len() - 1].span().hi, span.hi - BytePos(1));\n     let last_comment = context.snippet(last_span);\n     let comment = try_opt!(rewrite_match_arm_comment(\n         context,\n@@ -1614,223 +1649,146 @@ fn rewrite_match(\n         &arm_indent_str,\n     ));\n     result.push_str(&comment);\n-    result.push('\\n');\n-    result.push_str(&shape.indent.to_string(context.config));\n-    result.push('}');\n-    Some(result)\n-}\n-\n-fn arm_start_pos(arm: &ast::Arm) -> BytePos {\n-    let &ast::Arm {\n-        ref attrs,\n-        ref pats,\n-        ..\n-    } = arm;\n-    if !attrs.is_empty() {\n-        return attrs[0].span.lo;\n-    }\n-\n-    pats[0].span.lo\n-}\n \n-fn arm_end_pos(arm: &ast::Arm) -> BytePos {\n-    arm.body.span.hi\n+    Some(result)\n }\n \n-fn arm_comma(config: &Config, body: &ast::Expr) -> &'static str {\n-    if config.match_block_trailing_comma() {\n-        \",\"\n-    } else if let ast::ExprKind::Block(ref block) = body.node {\n-        if let ast::BlockCheckMode::Default = block.rules {\n-            \"\"\n-        } else {\n-            \",\"\n+fn rewrite_match_arm(context: &RewriteContext, arm: &ast::Arm, shape: Shape) -> Option<String> {\n+    let attr_str = if !arm.attrs.is_empty() {\n+        if contains_skip(&arm.attrs) {\n+            return None;\n         }\n+        format!(\n+            \"{}\\n{}\",\n+            try_opt!(arm.attrs.rewrite(context, shape)),\n+            shape.indent.to_string(context.config)\n+        )\n     } else {\n-        \",\"\n-    }\n+        String::new()\n+    };\n+    let pats_str = try_opt!(rewrite_match_pattern(context, &arm.pats, &arm.guard, shape));\n+    let pats_str = attr_str + &pats_str;\n+    rewrite_match_body(context, &arm.body, &pats_str, shape, arm.guard.is_some())\n }\n \n-// Match arms.\n-impl Rewrite for ast::Arm {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        debug!(\"Arm::rewrite {:?} {:?}\", self, shape);\n-        let &ast::Arm {\n-            ref attrs,\n-            ref pats,\n-            ref guard,\n-            ref body,\n-        } = self;\n-\n-        let attr_str = if !attrs.is_empty() {\n-            if contains_skip(attrs) {\n-                return None;\n+fn rewrite_match_body(\n+    context: &RewriteContext,\n+    body: &ptr::P<ast::Expr>,\n+    pats_str: &str,\n+    shape: Shape,\n+    has_guard: bool,\n+) -> Option<String> {\n+    let (extend, body) = match body.node {\n+        ast::ExprKind::Block(ref block)\n+            if !is_unsafe_block(block) && is_simple_block(block, context.codemap) => {\n+            if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n+                (expr.can_be_overflowed(context, 1), &**expr)\n+            } else {\n+                (false, &**body)\n             }\n-            format!(\n-                \"{}\\n{}\",\n-                try_opt!(attrs.rewrite(context, shape)),\n-                shape.indent.to_string(context.config)\n-            )\n-        } else {\n-            String::new()\n-        };\n-\n-        // Patterns\n-        // 5 = ` => {`\n-        let pat_shape = try_opt!(shape.sub_width(5));\n-\n-        let pat_strs = try_opt!(\n-            pats.iter()\n-                .map(|p| p.rewrite(context, pat_shape))\n-                .collect::<Option<Vec<_>>>()\n-        );\n-\n-        let all_simple = pat_strs.iter().all(|p| !p.contains('\\n'));\n-        let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n-        let mut tactic = definitive_tactic(&items, ListTactic::HorizontalVertical, pat_shape.width);\n-        if tactic == DefinitiveListTactic::Horizontal && all_simple {\n-            tactic = DefinitiveListTactic::Mixed;\n-        }\n-        let fmt = ListFormatting {\n-            tactic: tactic,\n-            separator: \" |\",\n-            trailing_separator: SeparatorTactic::Never,\n-            shape: pat_shape,\n-            ends_with_newline: false,\n-            config: context.config,\n-        };\n-        let pats_str = try_opt!(write_list(&items, &fmt));\n-\n-        let guard_str = try_opt!(rewrite_guard(\n-            context,\n-            guard,\n-            shape,\n-            trimmed_last_line_width(&pats_str),\n-        ));\n+        }\n+        _ => (body.can_be_overflowed(context, 1), &**body),\n+    };\n \n-        let pats_len = pats_str.len();\n-        let pats_str = format!(\"{}{}\", pats_str, guard_str);\n+    let comma = arm_comma(&context.config, body);\n+    let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n+    let alt_block_sep = alt_block_sep.as_str();\n+    let is_block = if let ast::ExprKind::Block(..) = body.node {\n+        true\n+    } else {\n+        false\n+    };\n \n-        let (mut extend, body) = match body.node {\n-            ast::ExprKind::Block(ref block)\n-                if !is_unsafe_block(block) && is_simple_block(block, context.codemap) &&\n-                    context.config.wrap_match_arms() => {\n-                if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n-                    (false, &**expr)\n-                } else {\n-                    (false, &**body)\n-                }\n+    let combine_orig_body = |body_str: &str| {\n+        let block_sep = match context.config.control_brace_style() {\n+            ControlBraceStyle::AlwaysNextLine if is_block => alt_block_sep,\n+            _ if has_guard && pats_str.contains('\\n') && is_block && body_str != \"{}\" => {\n+                alt_block_sep\n             }\n-            ast::ExprKind::Call(_, ref args) => (args.len() == 1, &**body),\n-            ast::ExprKind::Closure(..) | ast::ExprKind::Struct(..) | ast::ExprKind::Tup(..) => (\n-                true,\n-                &**body,\n-            ),\n-            _ => (false, &**body),\n+            _ => \" \",\n         };\n-        extend &= context.use_block_indent();\n-\n-        let comma = arm_comma(&context.config, body);\n-        let alt_block_sep =\n-            String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n-\n-        let pat_width = extra_offset(&pats_str, shape);\n-        // Let's try and get the arm body on the same line as the condition.\n-        // 4 = ` => `.len()\n-        if shape.width > pat_width + comma.len() + 4 {\n-            let arm_shape = shape\n-                .offset_left(pat_width + 4)\n-                .unwrap()\n-                .sub_width(comma.len())\n-                .unwrap();\n-            let rewrite = nop_block_collapse(\n-                format_expr(body, ExprType::Statement, context, arm_shape),\n-                arm_shape.width,\n-            );\n-            let is_block = if let ast::ExprKind::Block(..) = body.node {\n-                true\n-            } else {\n-                false\n-            };\n-\n-            match rewrite {\n-                Some(ref body_str)\n-                    if (!body_str.contains('\\n') && body_str.len() <= arm_shape.width) ||\n-                        !context.config.wrap_match_arms() ||\n-                        (extend && first_line_width(body_str) <= arm_shape.width) ||\n-                        is_block =>\n-                {\n-                    let block_sep = match context.config.control_brace_style() {\n-                        ControlBraceStyle::AlwaysNextLine if is_block => alt_block_sep.as_str(),\n-                        _ if guard.is_some() && pats_str.contains('\\n') && is_block &&\n-                            body_str != \"{}\" &&\n-                            pats_len > context.config.tab_spaces() => alt_block_sep.as_str(),\n-                        _ => \" \",\n-                    };\n \n-                    return Some(format!(\n-                        \"{}{} =>{}{}{}\",\n-                        attr_str.trim_left(),\n-                        pats_str,\n-                        block_sep,\n-                        body_str,\n-                        comma\n-                    ));\n-                }\n-                _ => {}\n-            }\n-        }\n+        Some(format!(\"{} =>{}{}{}\", pats_str, block_sep, body_str, comma))\n+    };\n \n-        // FIXME: we're doing a second rewrite of the expr; This may not be\n-        // necessary.\n-        let body_shape = try_opt!(shape.block_left(context.config.tab_spaces()));\n-        let next_line_body = try_opt!(nop_block_collapse(\n-            format_expr(body, ExprType::Statement, context, body_shape),\n-            body_shape.width,\n-        ));\n+    let combine_next_line_body = |body_str: &str| {\n         let indent_str = shape\n             .indent\n             .block_indent(context.config)\n             .to_string(context.config);\n         let (body_prefix, body_suffix) = if context.config.wrap_match_arms() {\n-            if context.config.match_block_trailing_comma() {\n-                (\"{\", \"},\")\n+            let comma = if context.config.match_block_trailing_comma() {\n+                \",\"\n             } else {\n-                (\"{\", \"}\")\n-            }\n+                \"\"\n+            };\n+            (\n+                \"{\",\n+                format!(\"\\n{}}}{}\", shape.indent.to_string(context.config), comma),\n+            )\n         } else {\n-            (\"\", \",\")\n+            (\"\", String::from(\",\"))\n         };\n \n-\n         let block_sep = match context.config.control_brace_style() {\n-            ControlBraceStyle::AlwaysNextLine => alt_block_sep + body_prefix + \"\\n\",\n+            ControlBraceStyle::AlwaysNextLine => format!(\"{}{}\\n\", alt_block_sep, body_prefix),\n             _ if body_prefix.is_empty() => \"\\n\".to_owned(),\n             _ => \" \".to_owned() + body_prefix + \"\\n\",\n-        };\n+        } + &indent_str;\n \n-        if context.config.wrap_match_arms() {\n-            Some(format!(\n-                \"{}{} =>{}{}{}\\n{}{}\",\n-                attr_str.trim_left(),\n-                pats_str,\n-                block_sep,\n-                indent_str,\n-                next_line_body,\n-                shape.indent.to_string(context.config),\n-                body_suffix\n-            ))\n-        } else {\n-            Some(format!(\n-                \"{}{} =>{}{}{}{}\",\n-                attr_str.trim_left(),\n-                pats_str,\n-                block_sep,\n-                indent_str,\n-                next_line_body,\n-                body_suffix\n-            ))\n+        Some(format!(\n+            \"{} =>{}{}{}\",\n+            pats_str,\n+            block_sep,\n+            body_str,\n+            body_suffix\n+        ))\n+    };\n+\n+    // Let's try and get the arm body on the same line as the condition.\n+    // 4 = ` => `.len()\n+    let orig_arm_shape = shape\n+        .offset_left(extra_offset(&pats_str, shape) + 4)\n+        .and_then(|shape| shape.sub_width(comma.len()));\n+    let orig_body = if let Some(arm_shape) = orig_arm_shape {\n+        let rewrite = nop_block_collapse(\n+            format_expr(body, ExprType::Statement, context, arm_shape),\n+            arm_shape.width,\n+        );\n+\n+        match rewrite {\n+            Some(ref body_str)\n+                if ((!body_str.contains('\\n')) && first_line_width(body_str) <= arm_shape.width) ||\n+                    is_block =>\n+            {\n+                return combine_orig_body(body_str);\n+            }\n+            _ => rewrite,\n         }\n+    } else {\n+        None\n+    };\n+    let orig_budget = orig_arm_shape.map_or(0, |shape| shape.width);\n+\n+    // Try putting body on the next line and see if it looks better.\n+    let next_line_body_shape =\n+        Shape::indented(shape.indent.block_indent(context.config), context.config);\n+    let next_line_body = nop_block_collapse(\n+        format_expr(body, ExprType::Statement, context, next_line_body_shape),\n+        next_line_body_shape.width,\n+    );\n+    match (orig_body, next_line_body) {\n+        (Some(ref orig_str), Some(ref next_line_str))\n+            if prefer_next_line(orig_str, next_line_str) => combine_next_line_body(next_line_str),\n+        (Some(ref orig_str), _) if extend && first_line_width(orig_str) <= orig_budget => {\n+            combine_orig_body(orig_str)\n+        }\n+        (Some(ref orig_str), Some(ref next_line_str)) if orig_str.contains('\\n') => {\n+            combine_next_line_body(next_line_str)\n+        }\n+        (None, Some(ref next_line_str)) => combine_next_line_body(next_line_str),\n+        (None, None) => None,\n+        (Some(ref orig_str), _) => combine_orig_body(orig_str),\n     }\n }\n \n@@ -1846,14 +1804,11 @@ fn rewrite_guard(\n     if let Some(ref guard) = *guard {\n         // First try to fit the guard string on the same line as the pattern.\n         // 4 = ` if `, 5 = ` => {`\n-        if let Some(cond_shape) = shape\n+        let cond_shape = shape\n             .offset_left(pattern_width + 4)\n-            .and_then(|s| s.sub_width(5))\n-        {\n-            if let Some(cond_str) = guard\n-                .rewrite(context, cond_shape)\n-                .and_then(|s| s.rewrite(context, cond_shape))\n-            {\n+            .and_then(|s| s.sub_width(5));\n+        if let Some(cond_shape) = cond_shape {\n+            if let Some(cond_str) = guard.rewrite(context, cond_shape) {\n                 if !cond_str.contains('\\n') || pattern_width <= context.config.tab_spaces() {\n                     return Some(format!(\" if {}\", cond_str));\n                 }\n@@ -1862,11 +1817,10 @@ fn rewrite_guard(\n \n         // Not enough space to put the guard after the pattern, try a newline.\n         // 3 = `if `, 5 = ` => {`\n-        if let Some(cond_shape) =\n-            Shape::indented(shape.indent.block_indent(context.config), context.config)\n-                .offset_left(3)\n-                .and_then(|s| s.sub_width(5))\n-        {\n+        let cond_shape = Shape::indented(shape.indent.block_indent(context.config), context.config)\n+            .offset_left(3)\n+            .and_then(|s| s.sub_width(5));\n+        if let Some(cond_shape) = cond_shape {\n             if let Some(cond_str) = guard.rewrite(context, cond_shape) {\n                 return Some(format!(\n                     \"\\n{}if {}\",\n@@ -2514,26 +2468,22 @@ fn rewrite_index(\n     let index_shape = try_opt!(index_shape.sub_width(rbr.len() + rhs_overhead));\n     let new_index_rw = index.rewrite(context, index_shape);\n     match (orig_index_rw, new_index_rw) {\n-        (_, Some(ref new_index_str)) if !new_index_str.contains('\\n') => {\n-            Some(format!(\n-                \"{}\\n{}{}{}{}\",\n-                expr_str,\n-                indent.to_string(&context.config),\n-                lbr,\n-                new_index_str,\n-                rbr\n-            ))\n-        }\n-        (None, Some(ref new_index_str)) => {\n-            Some(format!(\n-                \"{}\\n{}{}{}{}\",\n-                expr_str,\n-                indent.to_string(&context.config),\n-                lbr,\n-                new_index_str,\n-                rbr\n-            ))\n-        }\n+        (_, Some(ref new_index_str)) if !new_index_str.contains('\\n') => Some(format!(\n+            \"{}\\n{}{}{}{}\",\n+            expr_str,\n+            indent.to_string(&context.config),\n+            lbr,\n+            new_index_str,\n+            rbr\n+        )),\n+        (None, Some(ref new_index_str)) => Some(format!(\n+            \"{}\\n{}{}{}{}\",\n+            expr_str,\n+            indent.to_string(&context.config),\n+            lbr,\n+            new_index_str,\n+            rbr\n+        )),\n         (Some(ref index_str), _) => Some(format!(\"{}{}{}{}\", expr_str, lbr, index_str, rbr)),\n         _ => None,\n     }"}, {"sha": "d284b235c5e55309247974ce1a31fb1b7e71f053", "filename": "src/imports.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -60,12 +60,10 @@ fn compare_path_list_items(a: &ast::PathListItem, b: &ast::PathListItem) -> Orde\n     };\n     if name_ordering == Ordering::Equal {\n         match a.node.rename {\n-            Some(a_rename) => {\n-                match b.node.rename {\n-                    Some(b_rename) => a_rename.name.as_str().cmp(&b_rename.name.as_str()),\n-                    None => Ordering::Greater,\n-                }\n-            }\n+            Some(a_rename) => match b.node.rename {\n+                Some(b_rename) => a_rename.name.as_str().cmp(&b_rename.name.as_str()),\n+                None => Ordering::Greater,\n+            },\n             None => Ordering::Less,\n         }\n     } else {\n@@ -159,9 +157,9 @@ impl Rewrite for ast::ViewPath {\n     // Returns an empty string when the ViewPath is empty (like foo::bar::{})\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         match self.node {\n-            ast::ViewPath_::ViewPathList(_, ref path_list) if path_list.is_empty() => Some(\n-                String::new(),\n-            ),\n+            ast::ViewPath_::ViewPathList(_, ref path_list) if path_list.is_empty() => {\n+                Some(String::new())\n+            }\n             ast::ViewPath_::ViewPathList(ref path, ref path_list) => {\n                 rewrite_use_list(shape, path, path_list, self.span, context)\n             }"}, {"sha": "432fb797a6e481a1b373d21f58d790256c901ed0", "filename": "src/issues.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -189,25 +189,19 @@ impl BadIssueSeeker {\n         }\n \n         match part {\n-            NumberPart::OpenParen => {\n-                if c != '(' {\n-                    return IssueClassification::Bad(issue);\n-                } else {\n-                    part = NumberPart::Pound;\n-                }\n-            }\n-            NumberPart::Pound => {\n-                if c == '#' {\n-                    part = NumberPart::Number;\n-                }\n-            }\n-            NumberPart::Number => {\n-                if c >= '0' && c <= '9' {\n-                    part = NumberPart::CloseParen;\n-                } else {\n-                    return IssueClassification::Bad(issue);\n-                }\n-            }\n+            NumberPart::OpenParen => if c != '(' {\n+                return IssueClassification::Bad(issue);\n+            } else {\n+                part = NumberPart::Pound;\n+            },\n+            NumberPart::Pound => if c == '#' {\n+                part = NumberPart::Number;\n+            },\n+            NumberPart::Number => if c >= '0' && c <= '9' {\n+                part = NumberPart::CloseParen;\n+            } else {\n+                return IssueClassification::Bad(issue);\n+            },\n             NumberPart::CloseParen => {}\n         }\n "}, {"sha": "7e79e0a0b45c2bd68ea25215c7867f9ae0a46455", "filename": "src/items.rs", "status": "modified", "additions": 82, "deletions": 106, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -362,12 +362,10 @@ impl<'a> FmtVisitor<'a> {\n                             ).map(|s| s + suffix)\n                                 .or_else(|| Some(self.snippet(e.span)))\n                         }\n-                        None => {\n-                            stmt.rewrite(\n-                                &self.get_context(),\n-                                Shape::indented(self.block_indent, self.config),\n-                            )\n-                        }\n+                        None => stmt.rewrite(\n+                            &self.get_context(),\n+                            Shape::indented(self.block_indent, self.config),\n+                        ),\n                     }\n                 } else {\n                     None\n@@ -418,13 +416,11 @@ impl<'a> FmtVisitor<'a> {\n         let variant_list = self.format_variant_list(enum_def, body_start, span.hi - BytePos(1));\n         match variant_list {\n             Some(ref body_str) => self.buffer.push_str(body_str),\n-            None => {\n-                if contains_comment(&enum_snippet[brace_pos..]) {\n-                    self.format_missing_no_indent(span.hi - BytePos(1))\n-                } else {\n-                    self.format_missing(span.hi - BytePos(1))\n-                }\n-            }\n+            None => if contains_comment(&enum_snippet[brace_pos..]) {\n+                self.format_missing_no_indent(span.hi - BytePos(1))\n+            } else {\n+                self.format_missing(span.hi - BytePos(1))\n+            },\n         }\n         self.block_indent = self.block_indent.block_unindent(self.config);\n \n@@ -620,14 +616,12 @@ pub fn format_impl(\n                 result.push_str(&offset.to_string(context.config));\n             }\n             BraceStyle::PreferSameLine => result.push(' '),\n-            BraceStyle::SameLineWhere => {\n-                if !where_clause_str.is_empty() {\n-                    result.push('\\n');\n-                    result.push_str(&offset.to_string(context.config));\n-                } else {\n-                    result.push(' ');\n-                }\n-            }\n+            BraceStyle::SameLineWhere => if !where_clause_str.is_empty() {\n+                result.push('\\n');\n+                result.push_str(&offset.to_string(context.config));\n+            } else {\n+                result.push(' ');\n+            },\n         }\n \n         result.push('{');\n@@ -876,31 +870,27 @@ pub fn format_struct(\n ) -> Option<String> {\n     match *struct_def {\n         ast::VariantData::Unit(..) => Some(format_unit_struct(item_name, ident, vis)),\n-        ast::VariantData::Tuple(ref fields, _) => {\n-            format_tuple_struct(\n-                context,\n-                item_name,\n-                ident,\n-                vis,\n-                fields,\n-                generics,\n-                span,\n-                offset,\n-            )\n-        }\n-        ast::VariantData::Struct(ref fields, _) => {\n-            format_struct_struct(\n-                context,\n-                item_name,\n-                ident,\n-                vis,\n-                fields,\n-                generics,\n-                span,\n-                offset,\n-                one_line_width,\n-            )\n-        }\n+        ast::VariantData::Tuple(ref fields, _) => format_tuple_struct(\n+            context,\n+            item_name,\n+            ident,\n+            vis,\n+            fields,\n+            generics,\n+            span,\n+            offset,\n+        ),\n+        ast::VariantData::Struct(ref fields, _) => format_struct_struct(\n+            context,\n+            item_name,\n+            ident,\n+            vis,\n+            fields,\n+            generics,\n+            span,\n+            offset,\n+            one_line_width,\n+        ),\n     }\n }\n \n@@ -1003,16 +993,14 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                 result.push_str(&offset.to_string(context.config));\n             }\n             BraceStyle::PreferSameLine => result.push(' '),\n-            BraceStyle::SameLineWhere => {\n-                if !where_clause_str.is_empty() &&\n-                    (!trait_items.is_empty() || result.contains('\\n'))\n-                {\n-                    result.push('\\n');\n-                    result.push_str(&offset.to_string(context.config));\n-                } else {\n-                    result.push(' ');\n-                }\n-            }\n+            BraceStyle::SameLineWhere => if !where_clause_str.is_empty() &&\n+                (!trait_items.is_empty() || result.contains('\\n'))\n+            {\n+                result.push('\\n');\n+                result.push_str(&offset.to_string(context.config));\n+            } else {\n+                result.push(' ');\n+            },\n         }\n         result.push('{');\n \n@@ -1072,19 +1060,17 @@ pub fn format_struct_struct(\n     let body_lo = context.codemap.span_after(span, \"{\");\n \n     let generics_str = match generics {\n-        Some(g) => {\n-            try_opt!(format_generics(\n-                context,\n-                g,\n-                \"{\",\n-                \"{\",\n-                context.config.item_brace_style(),\n-                fields.is_empty(),\n-                offset,\n-                mk_sp(span.lo, body_lo),\n-                last_line_width(&result),\n-            ))\n-        }\n+        Some(g) => try_opt!(format_generics(\n+            context,\n+            g,\n+            \"{\",\n+            \"{\",\n+            context.config.item_brace_style(),\n+            fields.is_empty(),\n+            offset,\n+            mk_sp(span.lo, body_lo),\n+            last_line_width(&result),\n+        )),\n         None => {\n             // 3 = ` {}`, 2 = ` {`.\n             let overhead = if fields.is_empty() { 3 } else { 2 };\n@@ -1416,16 +1402,14 @@ pub fn rewrite_struct_field_prefix(\n \n     let type_annotation_spacing = type_annotation_spacing(context.config);\n     Some(match field.ident {\n-        Some(name) => {\n-            format!(\n-                \"{}{}{}{}{}:\",\n-                attr_str,\n-                missing_comment,\n-                vis,\n-                name,\n-                type_annotation_spacing.0\n-            )\n-        }\n+        Some(name) => format!(\n+            \"{}{}{}{}{}:\",\n+            attr_str,\n+            missing_comment,\n+            vis,\n+            name,\n+            type_annotation_spacing.0\n+        ),\n         None => format!(\"{}{}{}\", attr_str, missing_comment, vis),\n     })\n }\n@@ -1492,19 +1476,15 @@ pub fn rewrite_struct_field(\n \n     match ty_rewritten {\n         // If we start from the next line and type fits in a single line, then do so.\n-        Some(ref ty) => {\n-            match rewrite_type_in_next_line() {\n-                Some(ref new_ty) if !new_ty.contains('\\n') => {\n-                    Some(format!(\n-                        \"{}\\n{}{}\",\n-                        prefix,\n-                        type_offset.to_string(&context.config),\n-                        &new_ty\n-                    ))\n-                }\n-                _ => Some(prefix + &ty),\n-            }\n-        }\n+        Some(ref ty) => match rewrite_type_in_next_line() {\n+            Some(ref new_ty) if !new_ty.contains('\\n') => Some(format!(\n+                \"{}\\n{}{}\",\n+                prefix,\n+                type_offset.to_string(&context.config),\n+                &new_ty\n+            )),\n+            _ => Some(prefix + &ty),\n+        },\n         _ => {\n             let ty = try_opt!(rewrite_type_in_next_line());\n             Some(format!(\n@@ -2221,20 +2201,16 @@ fn rewrite_args(\n         .map_or(false, |s| s.trim().starts_with(\"//\"));\n \n     let (indent, trailing_comma, end_with_newline) = match context.config.fn_args_layout() {\n-        IndentStyle::Block if fits_in_one_line => {\n-            (\n-                indent.block_indent(context.config),\n-                SeparatorTactic::Never,\n-                true,\n-            )\n-        }\n-        IndentStyle::Block => {\n-            (\n-                indent.block_indent(context.config),\n-                context.config.trailing_comma(),\n-                true,\n-            )\n-        }\n+        IndentStyle::Block if fits_in_one_line => (\n+            indent.block_indent(context.config),\n+            SeparatorTactic::Never,\n+            true,\n+        ),\n+        IndentStyle::Block => (\n+            indent.block_indent(context.config),\n+            context.config.trailing_comma(),\n+            true,\n+        ),\n         IndentStyle::Visual if last_line_ends_with_comment => {\n             (arg_indent, context.config.trailing_comma(), true)\n         }"}, {"sha": "030d18c3000fe2388235f7b1d7c79a9aba32c2d0", "filename": "src/lib.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -104,6 +104,17 @@ impl Spanned for ast::Ty {\n     }\n }\n \n+impl Spanned for ast::Arm {\n+    fn span(&self) -> Span {\n+        let hi = self.body.span.hi;\n+        if self.attrs.is_empty() {\n+            mk_sp(self.pats[0].span.lo, hi)\n+        } else {\n+            mk_sp(self.attrs[0].span.lo, hi)\n+        }\n+    }\n+}\n+\n impl Spanned for ast::Arg {\n     fn span(&self) -> Span {\n         if items::is_named_arg(self) {\n@@ -431,14 +442,12 @@ pub enum ErrorKind {\n impl fmt::Display for ErrorKind {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         match *self {\n-            ErrorKind::LineOverflow(found, maximum) => {\n-                write!(\n-                    fmt,\n-                    \"line exceeded maximum length (maximum: {}, found: {})\",\n-                    maximum,\n-                    found\n-                )\n-            }\n+            ErrorKind::LineOverflow(found, maximum) => write!(\n+                fmt,\n+                \"line exceeded maximum length (maximum: {}, found: {})\",\n+                maximum,\n+                found\n+            ),\n             ErrorKind::TrailingWhitespace => write!(fmt, \"left behind trailing whitespace\"),\n             ErrorKind::BadIssue(issue) => write!(fmt, \"found {}\", issue),\n         }"}, {"sha": "4bd7d76483a9b201b35b15cf9cea41ba90cb2cde", "filename": "src/lists.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -440,29 +440,23 @@ where\n                         // Comment belongs to next item.\n                         (Some(i), None) if i > separator_index => separator_index + 1,\n                         // Block-style post-comment before the separator.\n-                        (Some(i), None) => {\n-                            cmp::max(\n-                                find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                separator_index + 1,\n-                            )\n-                        }\n+                        (Some(i), None) => cmp::max(\n+                            find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                            separator_index + 1,\n+                        ),\n                         // Block-style post-comment. Either before or after the separator.\n-                        (Some(i), Some(j)) if i < j => {\n-                            cmp::max(\n-                                find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                separator_index + 1,\n-                            )\n-                        }\n+                        (Some(i), Some(j)) if i < j => cmp::max(\n+                            find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                            separator_index + 1,\n+                        ),\n                         // Potential *single* line comment.\n                         (_, Some(j)) if j > separator_index => j + 1,\n                         _ => post_snippet.len(),\n                     }\n                 }\n-                None => {\n-                    post_snippet\n-                        .find_uncommented(self.terminator)\n-                        .unwrap_or(post_snippet.len())\n-                }\n+                None => post_snippet\n+                    .find_uncommented(self.terminator)\n+                    .unwrap_or(post_snippet.len()),\n             };\n \n             if !post_snippet.is_empty() && comment_end > 0 {\n@@ -595,11 +589,9 @@ pub fn struct_lit_shape(\n     suffix_width: usize,\n ) -> Option<(Option<Shape>, Shape)> {\n     let v_shape = match context.config.struct_lit_style() {\n-        IndentStyle::Visual => {\n-            try_opt!(\n-                try_opt!(shape.visual_indent(0).shrink_left(prefix_width)).sub_width(suffix_width)\n-            )\n-        }\n+        IndentStyle::Visual => try_opt!(\n+            try_opt!(shape.visual_indent(0).shrink_left(prefix_width)).sub_width(suffix_width)\n+        ),\n         IndentStyle::Block => {\n             let shape = shape.block_indent(context.config.tab_spaces());\n             Shape {"}, {"sha": "3f4adf881200761bf6896a6bf115d10cd0e2bb32", "filename": "src/macros.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -80,13 +80,11 @@ pub fn rewrite_macro(\n \n     let macro_name = match extra_ident {\n         None => format!(\"{}!\", mac.node.path),\n-        Some(ident) => {\n-            if ident == symbol::keywords::Invalid.ident() {\n-                format!(\"{}!\", mac.node.path)\n-            } else {\n-                format!(\"{}! {}\", mac.node.path, ident)\n-            }\n-        }\n+        Some(ident) => if ident == symbol::keywords::Invalid.ident() {\n+            format!(\"{}!\", mac.node.path)\n+        } else {\n+            format!(\"{}! {}\", mac.node.path, ident)\n+        },\n     };\n \n     let style = if FORCED_BRACKET_MACROS.contains(&&macro_name[..]) {"}, {"sha": "bcc57f93189a90f4e16531463d2822def087965b", "filename": "src/patterns.rs", "status": "modified", "additions": 23, "deletions": 35, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -54,23 +54,15 @@ impl Rewrite for Pat {\n                 let result = format!(\"{}{}{}{}\", prefix, mut_infix, id_str, sub_pat);\n                 wrap_str(result, context.config.max_width(), shape)\n             }\n-            PatKind::Wild => {\n-                if 1 <= shape.width {\n-                    Some(\"_\".to_owned())\n-                } else {\n-                    None\n-                }\n-            }\n-            PatKind::Range(ref lhs, ref rhs, ref end_kind) => {\n-                match *end_kind {\n-                    RangeEnd::Included => {\n-                        rewrite_pair(&**lhs, &**rhs, \"\", \"...\", \"\", context, shape)\n-                    }\n-                    RangeEnd::Excluded => {\n-                        rewrite_pair(&**lhs, &**rhs, \"\", \"..\", \"\", context, shape)\n-                    }\n-                }\n-            }\n+            PatKind::Wild => if 1 <= shape.width {\n+                Some(\"_\".to_owned())\n+            } else {\n+                None\n+            },\n+            PatKind::Range(ref lhs, ref rhs, ref end_kind) => match *end_kind {\n+                RangeEnd::Included => rewrite_pair(&**lhs, &**rhs, \"\", \"...\", \"\", context, shape),\n+                RangeEnd::Excluded => rewrite_pair(&**lhs, &**rhs, \"\", \"..\", \"\", context, shape),\n+            },\n             PatKind::Ref(ref pat, mutability) => {\n                 let prefix = format!(\"&{}\", format_mutability(mutability));\n                 rewrite_unary_prefix(context, &prefix, &**pat, shape)\n@@ -121,13 +113,11 @@ impl Rewrite for Pat {\n                 rewrite_struct_pat(path, fields, elipses, self.span, context, shape)\n             }\n             // FIXME(#819) format pattern macros.\n-            PatKind::Mac(..) => {\n-                wrap_str(\n-                    context.snippet(self.span),\n-                    context.config.max_width(),\n-                    shape,\n-                )\n-            }\n+            PatKind::Mac(..) => wrap_str(\n+                context.snippet(self.span),\n+                context.config.max_width(),\n+                shape,\n+            ),\n         }\n     }\n }\n@@ -250,18 +240,16 @@ impl<'a> Spanned for TuplePatField<'a> {\n \n pub fn can_be_overflowed_pat(context: &RewriteContext, pat: &TuplePatField, len: usize) -> bool {\n     match pat {\n-        &TuplePatField::Pat(ref pat) => {\n-            match pat.node {\n-                ast::PatKind::Path(..) | ast::PatKind::Tuple(..) | ast::PatKind::Struct(..) => {\n-                    context.use_block_indent() && len == 1\n-                }\n-                ast::PatKind::Ref(ref p, _) | ast::PatKind::Box(ref p) => {\n-                    can_be_overflowed_pat(context, &TuplePatField::Pat(p), len)\n-                }\n-                ast::PatKind::Lit(ref expr) => can_be_overflowed_expr(context, expr, len),\n-                _ => false,\n+        &TuplePatField::Pat(ref pat) => match pat.node {\n+            ast::PatKind::Path(..) | ast::PatKind::Tuple(..) | ast::PatKind::Struct(..) => {\n+                context.use_block_indent() && len == 1\n             }\n-        }\n+            ast::PatKind::Ref(ref p, _) | ast::PatKind::Box(ref p) => {\n+                can_be_overflowed_pat(context, &TuplePatField::Pat(p), len)\n+            }\n+            ast::PatKind::Lit(ref expr) => can_be_overflowed_expr(context, expr, len),\n+            _ => false,\n+        },\n         &TuplePatField::Dotdot(..) => false,\n     }\n }"}, {"sha": "edab375b02defae31e4e5ac556164cd8de4e713d", "filename": "src/types.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -474,14 +474,12 @@ impl Rewrite for ast::WherePredicate {\n                 ref lifetime,\n                 ref bounds,\n                 ..\n-            }) => {\n-                try_opt!(rewrite_bounded_lifetime(\n-                    lifetime,\n-                    bounds.iter(),\n-                    context,\n-                    shape,\n-                ))\n-            }\n+            }) => try_opt!(rewrite_bounded_lifetime(\n+                lifetime,\n+                bounds.iter(),\n+                context,\n+                shape,\n+            )),\n             ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n                 ref lhs_ty,\n                 ref rhs_ty,\n@@ -727,14 +725,12 @@ impl Rewrite for ast::Ty {\n                         format!(\"[{}]\", ty_str)\n                     })\n             }\n-            ast::TyKind::Tup(ref items) => {\n-                rewrite_tuple(\n-                    context,\n-                    &items.iter().map(|x| &**x).collect::<Vec<_>>()[..],\n-                    self.span,\n-                    shape,\n-                )\n-            }\n+            ast::TyKind::Tup(ref items) => rewrite_tuple(\n+                context,\n+                &items.iter().map(|x| &**x).collect::<Vec<_>>()[..],\n+                self.span,\n+                shape,\n+            ),\n             ast::TyKind::Path(ref q_self, ref path) => {\n                 rewrite_path(context, PathContext::Type, q_self.as_ref(), path, shape)\n             }\n@@ -744,21 +740,17 @@ impl Rewrite for ast::Ty {\n                 let rbr = if use_spaces { \" ]\" } else { \"]\" };\n                 rewrite_pair(&**ty, &**repeats, lbr, \"; \", rbr, context, shape)\n             }\n-            ast::TyKind::Infer => {\n-                if shape.width >= 1 {\n-                    Some(\"_\".to_owned())\n-                } else {\n-                    None\n-                }\n-            }\n+            ast::TyKind::Infer => if shape.width >= 1 {\n+                Some(\"_\".to_owned())\n+            } else {\n+                None\n+            },\n             ast::TyKind::BareFn(ref bare_fn) => rewrite_bare_fn(bare_fn, self.span, context, shape),\n             ast::TyKind::Never => Some(String::from(\"!\")),\n             ast::TyKind::Mac(..) => None,\n             ast::TyKind::ImplicitSelf => Some(String::from(\"\")),\n-            ast::TyKind::ImplTrait(ref it) => {\n-                it.rewrite(context, shape)\n-                    .map(|it_str| format!(\"impl {}\", it_str))\n-            }\n+            ast::TyKind::ImplTrait(ref it) => it.rewrite(context, shape)\n+                .map(|it_str| format!(\"impl {}\", it_str)),\n             ast::TyKind::Err | ast::TyKind::Typeof(..) => unreachable!(),\n         }\n     }"}, {"sha": "2e0dce52e913e83728e8c70874c5f819c142a8bc", "filename": "src/utils.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -25,11 +25,9 @@ use SKIP_ANNOTATION;\n pub fn extra_offset(text: &str, shape: Shape) -> usize {\n     match text.rfind('\\n') {\n         // 1 for newline character\n-        Some(idx) => {\n-            text.len()\n-                .checked_sub(idx + 1 + shape.used_width())\n-                .unwrap_or(0)\n-        }\n+        Some(idx) => text.len()\n+            .checked_sub(idx + 1 + shape.used_width())\n+            .unwrap_or(0),\n         None => text.len(),\n     }\n }\n@@ -168,15 +166,13 @@ pub fn semicolon_for_expr(expr: &ast::Expr) -> bool {\n #[inline]\n pub fn semicolon_for_stmt(stmt: &ast::Stmt) -> bool {\n     match stmt.node {\n-        ast::StmtKind::Semi(ref expr) => {\n-            match expr.node {\n-                ast::ExprKind::While(..) |\n-                ast::ExprKind::WhileLet(..) |\n-                ast::ExprKind::Loop(..) |\n-                ast::ExprKind::ForLoop(..) => false,\n-                _ => true,\n-            }\n-        }\n+        ast::StmtKind::Semi(ref expr) => match expr.node {\n+            ast::ExprKind::While(..) |\n+            ast::ExprKind::WhileLet(..) |\n+            ast::ExprKind::Loop(..) |\n+            ast::ExprKind::ForLoop(..) => false,\n+            _ => true,\n+        },\n         ast::StmtKind::Expr(..) => false,\n         _ => true,\n     }"}, {"sha": "a1258092e8d8544035d3a2f935382d6833cd2d98", "filename": "src/visitor.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -289,12 +289,10 @@ impl<'a> FmtVisitor<'a> {\n                     assert!(!self.visit_attrs(&attrs));\n                 }\n             }\n-            _ => {\n-                if self.visit_attrs(&item.attrs) {\n-                    self.push_rewrite(item.span, None);\n-                    return;\n-                }\n-            }\n+            _ => if self.visit_attrs(&item.attrs) {\n+                self.push_rewrite(item.span, None);\n+                return;\n+            },\n         }\n \n         match item.node {"}, {"sha": "d1c05c27fd75a43f41fbe51846fafa14c0287dfa", "filename": "tests/source/configs-wrap_match_arms-false.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Fsource%2Fconfigs-wrap_match_arms-false.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Fsource%2Fconfigs-wrap_match_arms-false.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs-wrap_match_arms-false.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -3,10 +3,7 @@\n \n fn main() {\n     match lorem {\n-        true => {\n-            let ipsum = dolor;\n-            println!(\"{:?}\", ipsum);\n-        }\n+        true => foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x),\n         false => {\n             println!(\"{}\", sit)\n         }"}, {"sha": "8ddc5ebdc2e3878271489ba35307aef87f688842", "filename": "tests/source/configs-wrap_match_arms-true.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Fsource%2Fconfigs-wrap_match_arms-true.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Fsource%2Fconfigs-wrap_match_arms-true.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fconfigs-wrap_match_arms-true.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -3,10 +3,7 @@\n \n fn main() {\n     match lorem {\n-        true => {\n-            let ipsum = dolor;\n-            println!(\"{}\", ipsum);\n-        }\n+        true => foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x),\n         false => {\n             println!(\"{}\", sit)\n         }"}, {"sha": "e4ca37bc6e55ff515de16de4460849cd892a110d", "filename": "tests/target/configs-wrap_match_arms-false.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Fconfigs-wrap_match_arms-false.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Fconfigs-wrap_match_arms-false.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-wrap_match_arms-false.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -3,12 +3,8 @@\n \n fn main() {\n     match lorem {\n-        true => {\n-            let ipsum = dolor;\n-            println!(\"{:?}\", ipsum);\n-        }\n-        false => {\n-            println!(\"{}\", sit)\n-        }\n+        true =>\n+            foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x),\n+        false => println!(\"{}\", sit),\n     }\n }"}, {"sha": "f6307e53e435499ab2e7e42cfe02a142ffbb436c", "filename": "tests/target/configs-wrap_match_arms-true.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Fconfigs-wrap_match_arms-true.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Fconfigs-wrap_match_arms-true.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-wrap_match_arms-true.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -4,8 +4,7 @@\n fn main() {\n     match lorem {\n         true => {\n-            let ipsum = dolor;\n-            println!(\"{}\", ipsum);\n+            foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x)\n         }\n         false => println!(\"{}\", sit),\n     }"}, {"sha": "5b68b3748991957a6357499c9f07b17c927a042c", "filename": "tests/target/expr-block.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr-block.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -173,17 +173,15 @@ fn macros() {\n     baz!(one_item_macro_which_is_also_loooooooooooooooooooooooooooooooooooooooooooooooong);\n \n     let _ = match option {\n-        None => {\n-            baz!(\n-                function,\n-                like,\n-                macro_as,\n-                expression,\n-                which,\n-                is,\n-                loooooooooooooooong\n-            )\n-        }\n+        None => baz!(\n+            function,\n+            like,\n+            macro_as,\n+            expression,\n+            which,\n+            is,\n+            loooooooooooooooong\n+        ),\n         Some(p) => baz!(one_item_macro_as_expression_which_is_also_loooooooooooooooong),\n     };\n }\n@@ -318,12 +316,10 @@ fn combine_block() {\n         y => func(\n             xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n         ),\n-        _ => {\n-            func(\n-                x,\n-                yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy,\n-                zzz,\n-            )\n-        }\n+        _ => func(\n+            x,\n+            yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy,\n+            zzz,\n+        ),\n     }\n }"}, {"sha": "e0b34dbe03d910b86318bb2b7777044b21856564", "filename": "tests/target/indent_match_arms.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Findent_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Findent_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Findent_match_arms.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -15,14 +15,12 @@ fn main() {\n     2 => \"two\",\n     3 => \"three\",\n     4 => \"four\",\n-    5 => {\n-        match y {\n-        'a' => 'A',\n-        'b' => 'B',\n-        'c' => 'C',\n-        _ => \"Nope\",\n-        }\n-    }\n+    5 => match y {\n+    'a' => 'A',\n+    'b' => 'B',\n+    'c' => 'C',\n+    _ => \"Nope\",\n+    },\n     _ => \"something else\",\n     }\n "}, {"sha": "2cf65509c931d9245ac3f1d58e03b9fbc7d86772", "filename": "tests/target/issue-1350.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Fissue-1350.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Fissue-1350.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-1350.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -5,12 +5,10 @@ impl Struct {\n     fn fun() {\n         let result = match <R::RequestResult as serde::Deserialize>::deserialize(&json) {\n             Ok(v) => v,\n-            Err(e) => {\n-                match <R::ErrorResult as serde::Deserialize>::deserialize(&json) {\n-                    Ok(v) => return Err(Error::with_json(v)),\n-                    Err(e2) => return Err(Error::with_json(e)),\n-                }\n-            }\n+            Err(e) => match <R::ErrorResult as serde::Deserialize>::deserialize(&json) {\n+                Ok(v) => return Err(Error::with_json(v)),\n+                Err(e2) => return Err(Error::with_json(e)),\n+            },\n         };\n     }\n }"}, {"sha": "1457109821880441e2c3ee1a747dbd4da0d9a0e8", "filename": "tests/target/match-nowrap.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Fmatch-nowrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Fmatch-nowrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch-nowrap.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -4,9 +4,7 @@\n \n fn foo() {\n     match x {\n-        a => {\n-            foo()\n-        }\n+        a => foo(),\n         b => (\n             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n             bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb,"}, {"sha": "433eacb7ac65c6c3d29b04202dc1f1cf0422c563", "filename": "tests/target/match.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -215,14 +215,12 @@ fn issue355() {\n         wc => println![\"a\", b], // comment\n         xc => vec![1, 2], // comment\n         yc => vec![3; 4], // comment\n-        yd => {\n-            looooooooooooooooooooooooooooooooooooooooooooooooooooooooong_func(\n-                aaaaaaaaaa,\n-                bbbbbbbbbb,\n-                cccccccccc,\n-                dddddddddd,\n-            )\n-        }\n+        yd => looooooooooooooooooooooooooooooooooooooooooooooooooooooooong_func(\n+            aaaaaaaaaa,\n+            bbbbbbbbbb,\n+            cccccccccc,\n+            dddddddddd,\n+        ),\n     }\n }\n \n@@ -342,14 +340,12 @@ fn issue1371() {\n         }\n         sfEvtLostFocus => LostFocus,\n         sfEvtGainedFocus => GainedFocus,\n-        sfEvtTextEntered => {\n-            TextEntered {\n-                unicode: unsafe {\n-                    ::std::char::from_u32((*event.text.as_ref()).unicode)\n-                        .expect(\"Invalid unicode encountered on TextEntered event\")\n-                },\n-            }\n-        }\n+        sfEvtTextEntered => TextEntered {\n+            unicode: unsafe {\n+                ::std::char::from_u32((*event.text.as_ref()).unicode)\n+                    .expect(\"Invalid unicode encountered on TextEntered event\")\n+            },\n+        },\n         sfEvtKeyPressed => {\n             let e = unsafe { event.key.as_ref() };\n "}, {"sha": "339873a3f97d04c91d340ad5094581cad02db0fb", "filename": "tests/target/nested-visual-block.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Fnested-visual-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2725636f584e8ad47ce034b4bdef0a6c2276a217/tests%2Ftarget%2Fnested-visual-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fnested-visual-block.rs?ref=2725636f584e8ad47ce034b4bdef0a6c2276a217", "patch": "@@ -19,13 +19,11 @@ fn main() {\n         },\n         |item| {\n             match *item {\n-                StructLitField::Regular(ref field) => {\n-                    rewrite_field(\n-                        inner_context,\n-                        &field,\n-                        &Constraints::new(v_budget.checked_sub(1).unwrap_or(0), indent),\n-                    )\n-                }\n+                StructLitField::Regular(ref field) => rewrite_field(\n+                    inner_context,\n+                    &field,\n+                    &Constraints::new(v_budget.checked_sub(1).unwrap_or(0), indent),\n+                ),\n                 StructLitField::Base(ref expr) => {\n                     // 2 = ..\n                     expr.rewrite("}]}