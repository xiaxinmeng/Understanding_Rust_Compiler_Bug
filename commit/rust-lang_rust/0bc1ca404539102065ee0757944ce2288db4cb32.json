{"sha": "0bc1ca404539102065ee0757944ce2288db4cb32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiYzFjYTQwNDUzOTEwMjA2NWVlMDc1Nzk0NGNlMjI4OGRiNGNiMzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-21T00:12:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-21T00:12:09Z"}, "message": "auto merge of #8631 : anasazi/rust/homing-io, r=brson\n\nlibuv handles are tied to the event loop that created them. In order to perform IO, the handle must be on the thread with its home event loop. Thus, when as task wants to do IO it must first go to the IO handle's home event loop and pin itself to the corresponding scheduler while the IO action is in flight. Once the IO action completes, the task is unpinned and either returns to its home scheduler if it is a pinned task, or otherwise stays on the current scheduler.\r\n\r\nMaking new blocking IO implementations (i.e. files) thread safe is rather simple. Add a home field to the IO handle's struct in uvio and implement the HomingIO trait. Wrap every IO call in the HomingIO.home_for_io method, which will take care of the scheduling.\r\n\r\nI'm not sure if this remains thread safe in the presence of asynchronous IO at the libuv level. If we decide to do that, then this set up should be revisited.", "tree": {"sha": "b52c5d124c4321244e781047080edb4153381fca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b52c5d124c4321244e781047080edb4153381fca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bc1ca404539102065ee0757944ce2288db4cb32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bc1ca404539102065ee0757944ce2288db4cb32", "html_url": "https://github.com/rust-lang/rust/commit/0bc1ca404539102065ee0757944ce2288db4cb32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bc1ca404539102065ee0757944ce2288db4cb32/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cd978fbc75a691a144dcafe99a08531a424fcd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cd978fbc75a691a144dcafe99a08531a424fcd0", "html_url": "https://github.com/rust-lang/rust/commit/3cd978fbc75a691a144dcafe99a08531a424fcd0"}, {"sha": "35e844ffc1e3c022e868817ad1c548b900db800a", "url": "https://api.github.com/repos/rust-lang/rust/commits/35e844ffc1e3c022e868817ad1c548b900db800a", "html_url": "https://github.com/rust-lang/rust/commit/35e844ffc1e3c022e868817ad1c548b900db800a"}], "stats": {"total": 1036, "additions": 688, "deletions": 348}, "files": [{"sha": "3b3ea80eafa8fac1e30a85781393130f5cdb5642", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=0bc1ca404539102065ee0757944ce2288db4cb32", "patch": "@@ -17,7 +17,7 @@ use option::{Option, None, Some};\n \n type Port = u16;\n \n-#[deriving(Eq, TotalEq)]\n+#[deriving(Eq, TotalEq, Clone)]\n pub enum IpAddr {\n     Ipv4Addr(u8, u8, u8, u8),\n     Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16)\n@@ -62,7 +62,7 @@ impl ToStr for IpAddr {\n     }\n }\n \n-#[deriving(Eq, TotalEq)]\n+#[deriving(Eq, TotalEq, Clone)]\n pub struct SocketAddr {\n     ip: IpAddr,\n     port: Port,"}, {"sha": "746fa5668a5f0651e9f898598570ceda87d78715", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=0bc1ca404539102065ee0757944ce2288db4cb32", "patch": "@@ -88,9 +88,7 @@ impl Writer for TcpStream {\n     fn write(&mut self, buf: &[u8]) {\n         match (**self).write(buf) {\n             Ok(_) => (),\n-            Err(ioerr) => {\n-                io_error::cond.raise(ioerr);\n-            }\n+            Err(ioerr) => io_error::cond.raise(ioerr),\n         }\n     }\n \n@@ -129,9 +127,7 @@ impl TcpListener {\n impl Listener<TcpStream> for TcpListener {\n     fn accept(&mut self) -> Option<TcpStream> {\n         match (**self).accept() {\n-            Ok(s) => {\n-                Some(TcpStream::new(s))\n-            }\n+            Ok(s) => Some(TcpStream::new(s)),\n             Err(ioerr) => {\n                 io_error::cond.raise(ioerr);\n                 return None;"}, {"sha": "bfd1ed48ac180d1ac50eb383681c060dba746f2a", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=0bc1ca404539102065ee0757944ce2288db4cb32", "patch": "@@ -41,7 +41,7 @@ impl Timer {\n }\n \n impl RtioTimer for Timer {\n-    fn sleep(&self, msecs: u64) {\n+    fn sleep(&mut self, msecs: u64) {\n         (**self).sleep(msecs);\n     }\n }\n@@ -50,15 +50,11 @@ impl RtioTimer for Timer {\n mod test {\n     use super::*;\n     use rt::test::*;\n-    use option::{Some, None};\n     #[test]\n     fn test_io_timer_sleep_simple() {\n         do run_in_newsched_task {\n             let timer = Timer::new();\n-            match timer {\n-                Some(t) => t.sleep(1),\n-                None => assert!(false)\n-            }\n+            do timer.map_move |mut t| { t.sleep(1) };\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "f36c96706e5d6313bddeb6d82f85927a4649617d", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=0bc1ca404539102065ee0757944ce2288db4cb32", "patch": "@@ -91,5 +91,5 @@ pub trait RtioUdpSocket : RtioSocket {\n }\n \n pub trait RtioTimer {\n-    fn sleep(&self, msecs: u64);\n+    fn sleep(&mut self, msecs: u64);\n }"}, {"sha": "e8d0296e543a44afbc7e24ba5754a37016a4116c", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=0bc1ca404539102065ee0757944ce2288db4cb32", "patch": "@@ -190,9 +190,10 @@ impl StreamWatcher {\n \n         extern fn close_cb(handle: *uvll::uv_stream_t) {\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            stream_watcher.get_watcher_data().close_cb.take_unwrap()();\n+            let cb = stream_watcher.get_watcher_data().close_cb.take_unwrap();\n             stream_watcher.drop_watcher_data();\n             unsafe { free_handle(handle as *c_void) }\n+            cb();\n         }\n     }\n }\n@@ -411,9 +412,10 @@ impl UdpWatcher {\n \n         extern fn close_cb(handle: *uvll::uv_udp_t) {\n             let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n-            udp_watcher.get_watcher_data().close_cb.take_unwrap()();\n+            let cb = udp_watcher.get_watcher_data().close_cb.take_unwrap();\n             udp_watcher.drop_watcher_data();\n             unsafe { free_handle(handle as *c_void) }\n+            cb();\n         }\n     }\n }"}, {"sha": "f6a2d1be512c21b7504be53e070bf00fe306d9ce", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 665, "deletions": 329, "changes": 994, "blob_url": "https://github.com/rust-lang/rust/blob/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=0bc1ca404539102065ee0757944ce2288db4cb32", "patch": "@@ -23,7 +23,7 @@ use rt::io::net::ip::{SocketAddr, IpAddr};\n use rt::io::{standard_error, OtherIoError};\n use rt::local::Local;\n use rt::rtio::*;\n-use rt::sched::Scheduler;\n+use rt::sched::{Scheduler, SchedHandle};\n use rt::tube::Tube;\n use rt::uv::*;\n use rt::uv::idle::IdleWatcher;\n@@ -37,6 +37,49 @@ use unstable::sync::Exclusive;\n                             run_in_newsched_task};\n #[cfg(test)] use iterator::{Iterator, range};\n \n+// XXX we should not be calling uvll functions in here.\n+\n+trait HomingIO {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle;\n+    /* XXX This will move pinned tasks to do IO on the proper scheduler\n+     * and then move them back to their home.\n+     */\n+    fn home_for_io<A>(&mut self, io: &fn(&mut Self) -> A) -> A {\n+        use rt::sched::{PinnedTask, TaskFromFriend};\n+        // go home\n+        let old_home = Cell::new_empty();\n+        let old_home_ptr = &old_home;\n+        let scheduler = Local::take::<Scheduler>();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            // get the old home first\n+            do task.wake().map_move |mut task| {\n+                old_home_ptr.put_back(task.take_unwrap_home());\n+                self.home().send(PinnedTask(task));\n+            };\n+        }\n+\n+        // do IO\n+        let a = io(self);\n+\n+        // unhome home\n+        let scheduler = Local::take::<Scheduler>();\n+        do scheduler.deschedule_running_task_and_then |scheduler, task| {\n+            do task.wake().map_move |mut task| {\n+                task.give_home(old_home.take());\n+                scheduler.make_handle().send(TaskFromFriend(task));\n+            };\n+        }\n+\n+        // return the result of the IO\n+        a\n+    }\n+}\n+\n+// get a handle for the current scheduler\n+macro_rules! get_handle_to_current_scheduler(\n+    () => (do Local::borrow::<Scheduler, SchedHandle> |sched| { sched.make_handle() })\n+)\n+\n enum SocketNameKind {\n     TcpPeer,\n     Tcp,\n@@ -45,12 +88,10 @@ enum SocketNameKind {\n \n fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n                                                  handle: U) -> Result<SocketAddr, IoError> {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     let getsockname = match sk {\n-        TcpPeer => uvll::rust_uv_tcp_getpeername,\n-        Tcp     => uvll::rust_uv_tcp_getsockname,\n-        Udp     => uvll::rust_uv_udp_getsockname\n+        TcpPeer => uvll::tcp_getpeername,\n+        Tcp     => uvll::tcp_getsockname,\n+        Udp     => uvll::udp_getsockname,\n     };\n \n     // Allocate a sockaddr_storage\n@@ -80,6 +121,7 @@ fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n \n }\n \n+// Obviously an Event Loop is always home.\n pub struct UvEventLoop {\n     uvio: UvIoFactory\n }\n@@ -196,6 +238,7 @@ fn test_callback_run_once() {\n     }\n }\n \n+// The entire point of async is to call into a loop from other threads so it does not need to home.\n pub struct UvRemoteCallback {\n     // The uv async handle for triggering the callback\n     async: AsyncWatcher,\n@@ -326,40 +369,38 @@ impl IoFactory for UvIoFactory {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n \n-        let scheduler = Local::take::<Scheduler>();\n-\n         // Block this task and take ownership, switch to scheduler context\n+        let scheduler = Local::take::<Scheduler>();\n         do scheduler.deschedule_running_task_and_then |_, task| {\n \n-            rtdebug!(\"connect: entered scheduler context\");\n-            let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n+            let mut tcp = TcpWatcher::new(self.uv_loop());\n             let task_cell = Cell::new(task);\n \n             // Wait for a connection\n-            do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                rtdebug!(\"connect: in connect callback\");\n-                if status.is_none() {\n-                    rtdebug!(\"status is none\");\n-                    let tcp_watcher =\n-                        NativeHandle::from_native_handle(stream_watcher.native_handle());\n-                    let res = Ok(~UvTcpStream(tcp_watcher));\n-\n-                    // Store the stream in the task's stack\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-\n-                    // Context switch\n-                    let scheduler = Local::take::<Scheduler>();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                } else {\n-                    rtdebug!(\"status is some\");\n-                    let task_cell = Cell::new(task_cell.take());\n-                    do stream_watcher.close {\n-                        let res = Err(uv_error_to_io_error(status.unwrap()));\n+            do tcp.connect(addr) |stream, status| {\n+                match status {\n+                    None => {\n+                        let tcp = NativeHandle::from_native_handle(stream.native_handle());\n+                        let home = get_handle_to_current_scheduler!();\n+                        let res = Ok(~UvTcpStream { watcher: tcp, home: home });\n+\n+                        // Store the stream in the task's stack\n                         unsafe { (*result_cell_ptr).put_back(res); }\n+\n+                        // Context switch\n                         let scheduler = Local::take::<Scheduler>();\n                         scheduler.resume_blocked_task_immediately(task_cell.take());\n                     }\n-                };\n+                    Some(_) => {\n+                        let task_cell = Cell::new(task_cell.take());\n+                        do stream.close {\n+                            let res = Err(uv_error_to_io_error(status.unwrap()));\n+                            unsafe { (*result_cell_ptr).put_back(res); }\n+                            let scheduler = Local::take::<Scheduler>();\n+                            scheduler.resume_blocked_task_immediately(task_cell.take());\n+                        }\n+                    }\n+                }\n             }\n         }\n \n@@ -370,7 +411,10 @@ impl IoFactory for UvIoFactory {\n     fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListenerObject, IoError> {\n         let mut watcher = TcpWatcher::new(self.uv_loop());\n         match watcher.bind(addr) {\n-            Ok(_) => Ok(~UvTcpListener::new(watcher)),\n+            Ok(_) => {\n+                let home = get_handle_to_current_scheduler!();\n+                Ok(~UvTcpListener::new(watcher, home))\n+            }\n             Err(uverr) => {\n                 let scheduler = Local::take::<Scheduler>();\n                 do scheduler.deschedule_running_task_and_then |_, task| {\n@@ -388,7 +432,10 @@ impl IoFactory for UvIoFactory {\n     fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocketObject, IoError> {\n         let mut watcher = UdpWatcher::new(self.uv_loop());\n         match watcher.bind(addr) {\n-            Ok(_) => Ok(~UvUdpSocket(watcher)),\n+            Ok(_) => {\n+                let home = get_handle_to_current_scheduler!();\n+                Ok(~UvUdpSocket { watcher: watcher, home: home })\n+            }\n             Err(uverr) => {\n                 let scheduler = Local::take::<Scheduler>();\n                 do scheduler.deschedule_running_task_and_then |_, task| {\n@@ -404,22 +451,30 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn timer_init(&mut self) -> Result<~RtioTimerObject, IoError> {\n-        Ok(~UvTimer(TimerWatcher::new(self.uv_loop())))\n+        let watcher = TimerWatcher::new(self.uv_loop());\n+        let home = get_handle_to_current_scheduler!();\n+        Ok(~UvTimer::new(watcher, home))\n     }\n }\n \n pub struct UvTcpListener {\n     watcher: TcpWatcher,\n     listening: bool,\n-    incoming_streams: Tube<Result<~RtioTcpStreamObject, IoError>>\n+    incoming_streams: Tube<Result<~RtioTcpStreamObject, IoError>>,\n+    home: SchedHandle,\n+}\n+\n+impl HomingIO for UvTcpListener {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n }\n \n impl UvTcpListener {\n-    fn new(watcher: TcpWatcher) -> UvTcpListener {\n+    fn new(watcher: TcpWatcher, home: SchedHandle) -> UvTcpListener {\n         UvTcpListener {\n             watcher: watcher,\n             listening: false,\n-            incoming_streams: Tube::new()\n+            incoming_streams: Tube::new(),\n+            home: home,\n         }\n     }\n \n@@ -428,450 +483,512 @@ impl UvTcpListener {\n \n impl Drop for UvTcpListener {\n     fn drop(&self) {\n-        let watcher = self.watcher();\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do watcher.as_stream().close {\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+        // XXX need mutable finalizer\n+        let self_ = unsafe { transmute::<&UvTcpListener, &mut UvTcpListener>(self) };\n+        do self_.home_for_io |self_| {\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.watcher().as_stream().close {\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n         }\n     }\n }\n \n impl RtioSocket for UvTcpListener {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        socket_name(Tcp, self.watcher)\n+        do self.home_for_io |self_| {\n+          socket_name(Tcp, self_.watcher)\n+        }\n     }\n }\n \n impl RtioTcpListener for UvTcpListener {\n \n     fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n-        rtdebug!(\"entering listen\");\n-\n-        if self.listening {\n-            return self.incoming_streams.recv();\n-        }\n-\n-        self.listening = true;\n-\n-        let server_tcp_watcher = self.watcher();\n-        let incoming_streams_cell = Cell::new(self.incoming_streams.clone());\n-\n-        let incoming_streams_cell = Cell::new(incoming_streams_cell.take());\n-        let mut server_tcp_watcher = server_tcp_watcher;\n-        do server_tcp_watcher.listen |mut server_stream_watcher, status| {\n-            let maybe_stream = if status.is_none() {\n-                let mut loop_ = server_stream_watcher.event_loop();\n-                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-                // XXX: Need's to be surfaced in interface\n-                server_stream_watcher.accept(client_tcp_watcher.as_stream());\n-                Ok(~UvTcpStream(client_tcp_watcher))\n-            } else {\n-                Err(standard_error(OtherIoError))\n-            };\n+        do self.home_for_io |self_| {\n+\n+            if !self_.listening {\n+                self_.listening = true;\n+\n+                let incoming_streams_cell = Cell::new(self_.incoming_streams.clone());\n+\n+                do self_.watcher().listen |mut server, status| {\n+                    let stream = match status {\n+                        Some(_) => Err(standard_error(OtherIoError)),\n+                        None => {\n+                            let client = TcpWatcher::new(&server.event_loop());\n+                            // XXX: needs to be surfaced in interface\n+                            server.accept(client.as_stream());\n+                            let home = get_handle_to_current_scheduler!();\n+                            Ok(~UvTcpStream { watcher: client, home: home })\n+                        }\n+                    };\n+\n+                    let mut incoming_streams = incoming_streams_cell.take();\n+                    incoming_streams.send(stream);\n+                    incoming_streams_cell.put_back(incoming_streams);\n+                }\n \n-            let mut incoming_streams = incoming_streams_cell.take();\n-            incoming_streams.send(maybe_stream);\n-            incoming_streams_cell.put_back(incoming_streams);\n+            }\n+            self_.incoming_streams.recv()\n         }\n-\n-        return self.incoming_streams.recv();\n     }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let r = unsafe {\n-            uvll::rust_uv_tcp_simultaneous_accepts(self.watcher.native_handle(), 1 as c_int)\n-        };\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                uvll::tcp_simultaneous_accepts(self_.watcher().native_handle(), 1 as c_int)\n+            };\n \n-        match status_to_maybe_uv_error(self.watcher, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher(), r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let r = unsafe {\n-            uvll::rust_uv_tcp_simultaneous_accepts(self.watcher.native_handle(), 0 as c_int)\n-        };\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                uvll::tcp_simultaneous_accepts(self_.watcher().native_handle(), 0 as c_int)\n+            };\n \n-        match status_to_maybe_uv_error(self.watcher, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher(), r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n }\n \n-pub struct UvTcpStream(TcpWatcher);\n+pub struct UvTcpStream {\n+    watcher: TcpWatcher,\n+    home: SchedHandle,\n+}\n+\n+impl HomingIO for UvTcpStream {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n \n impl Drop for UvTcpStream {\n     fn drop(&self) {\n-        rtdebug!(\"closing tcp stream\");\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do self.as_stream().close {\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+        // XXX need mutable finalizer\n+        let this = unsafe { transmute::<&UvTcpStream, &mut UvTcpStream>(self) };\n+        do this.home_for_io |self_| {\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.as_stream().close {\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n         }\n     }\n }\n \n impl RtioSocket for UvTcpStream {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        socket_name(Tcp, **self)\n+        do self.home_for_io |self_| {\n+            socket_name(Tcp, self_.watcher)\n+        }\n     }\n }\n \n impl RtioTcpStream for UvTcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n-\n-        let scheduler = Local::take::<Scheduler>();\n-        let buf_ptr: *&mut [u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |_sched, task| {\n-            rtdebug!(\"read: entered scheduler context\");\n-            let task_cell = Cell::new(task);\n-            // XXX: We shouldn't reallocate these callbacks every\n-            // call to read\n-            let alloc: AllocCallback = |_| unsafe {\n-                slice_to_uv_buf(*buf_ptr)\n-            };\n-            let mut watcher = self.as_stream();\n-            do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n-\n-                // Stop reading so that no read callbacks are\n-                // triggered before the user calls `read` again.\n-                // XXX: Is there a performance impact to calling\n-                // stop here?\n-                watcher.read_stop();\n-\n-                let result = if status.is_none() {\n-                    assert!(nread >= 0);\n-                    Ok(nread as uint)\n-                } else {\n-                    Err(uv_error_to_io_error(status.unwrap()))\n+        do self.home_for_io |self_| {\n+            let result_cell = Cell::new_empty();\n+            let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n+\n+            let scheduler = Local::take::<Scheduler>();\n+            let buf_ptr: *&mut [u8] = &buf;\n+            do scheduler.deschedule_running_task_and_then |_sched, task| {\n+                let task_cell = Cell::new(task);\n+                // XXX: We shouldn't reallocate these callbacks every\n+                // call to read\n+                let alloc: AllocCallback = |_| unsafe {\n+                    slice_to_uv_buf(*buf_ptr)\n                 };\n+                let mut watcher = self_.watcher.as_stream();\n+                do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n \n-                unsafe { (*result_cell_ptr).put_back(result); }\n+                    // Stop reading so that no read callbacks are\n+                    // triggered before the user calls `read` again.\n+                    // XXX: Is there a performance impact to calling\n+                    // stop here?\n+                    watcher.read_stop();\n \n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    let result = if status.is_none() {\n+                        assert!(nread >= 0);\n+                        Ok(nread as uint)\n+                    } else {\n+                        Err(uv_error_to_io_error(status.unwrap()))\n+                    };\n+\n+                    unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n-        }\n \n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+            assert!(!result_cell.is_empty());\n+            result_cell.take()\n+        }\n     }\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-        let scheduler = Local::take::<Scheduler>();\n-        let buf_ptr: *&[u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-            let mut watcher = self.as_stream();\n-            do watcher.write(buf) |_watcher, status| {\n-                let result = if status.is_none() {\n-                    Ok(())\n-                } else {\n-                    Err(uv_error_to_io_error(status.unwrap()))\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(result); }\n+        do self.home_for_io |self_| {\n+            let result_cell = Cell::new_empty();\n+            let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+            let scheduler = Local::take::<Scheduler>();\n+            let buf_ptr: *&[u8] = &buf;\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+                let mut watcher = self_.watcher.as_stream();\n+                do watcher.write(buf) |_watcher, status| {\n+                    let result = if status.is_none() {\n+                        Ok(())\n+                    } else {\n+                        Err(uv_error_to_io_error(status.unwrap()))\n+                    };\n+\n+                    unsafe { (*result_cell_ptr).put_back(result); }\n \n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n-        }\n \n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+            assert!(!result_cell.is_empty());\n+            result_cell.take()\n+        }\n     }\n \n     fn peer_name(&mut self) -> Result<SocketAddr, IoError> {\n-        socket_name(TcpPeer, **self)\n+        do self.home_for_io |self_| {\n+            socket_name(TcpPeer, self_.watcher)\n+        }\n     }\n \n     fn control_congestion(&mut self) -> Result<(), IoError> {\n-        #[fixed_stack_segment]; #[inline(never)];\n+        do self.home_for_io |self_| {\n+            let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 0 as c_int) };\n \n-        let r = unsafe {\n-            uvll::rust_uv_tcp_nodelay(self.native_handle(), 0 as c_int)\n-        };\n-\n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn nodelay(&mut self) -> Result<(), IoError> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let r = unsafe {\n-            uvll::rust_uv_tcp_nodelay(self.native_handle(), 1 as c_int)\n-        };\n+        do self.home_for_io |self_| {\n+            let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 1 as c_int) };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let r = unsafe {\n-            uvll::rust_uv_tcp_keepalive(self.native_handle(), 1 as c_int,\n-                                        delay_in_seconds as c_uint)\n-        };\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                uvll::tcp_keepalive(self_.watcher.native_handle(), 1 as c_int,\n+                                    delay_in_seconds as c_uint)\n+            };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn letdie(&mut self) -> Result<(), IoError> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let r = unsafe {\n-            uvll::rust_uv_tcp_keepalive(self.native_handle(), 0 as c_int, 0 as c_uint)\n-        };\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                uvll::tcp_keepalive(self_.watcher.native_handle(), 0 as c_int, 0 as c_uint)\n+            };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n }\n \n-pub struct UvUdpSocket(UdpWatcher);\n+pub struct UvUdpSocket {\n+    watcher: UdpWatcher,\n+    home: SchedHandle,\n+}\n+\n+impl HomingIO for UvUdpSocket {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n \n impl Drop for UvUdpSocket {\n     fn drop(&self) {\n-        rtdebug!(\"closing udp socket\");\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do self.close {\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+        // XXX need mutable finalizer\n+        let this = unsafe { transmute::<&UvUdpSocket, &mut UvUdpSocket>(self) };\n+        do this.home_for_io |_| {\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do this.watcher.close {\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n         }\n     }\n }\n \n impl RtioSocket for UvUdpSocket {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        socket_name(Udp, **self)\n+        do self.home_for_io |self_| {\n+            socket_name(Udp, self_.watcher)\n+        }\n     }\n }\n \n impl RtioUdpSocket for UvUdpSocket {\n     fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, SocketAddr), IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(uint, SocketAddr), IoError>> = &result_cell;\n-\n-        let scheduler = Local::take::<Scheduler>();\n-        let buf_ptr: *&mut [u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |_sched, task| {\n-            rtdebug!(\"recvfrom: entered scheduler context\");\n-            let task_cell = Cell::new(task);\n-            let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n-            do self.recv_start(alloc) |mut watcher, nread, _buf, addr, flags, status| {\n-                let _ = flags; // XXX add handling for partials?\n-\n-                watcher.recv_stop();\n-\n-                let result = match status {\n-                    None => {\n-                        assert!(nread >= 0);\n-                        Ok((nread as uint, addr))\n-                    }\n-                    Some(err) => Err(uv_error_to_io_error(err))\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(result); }\n+        do self.home_for_io |self_| {\n+            let result_cell = Cell::new_empty();\n+            let result_cell_ptr: *Cell<Result<(uint, SocketAddr), IoError>> = &result_cell;\n+\n+            let scheduler = Local::take::<Scheduler>();\n+            let buf_ptr: *&mut [u8] = &buf;\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n+                do self_.watcher.recv_start(alloc) |mut watcher, nread, _buf, addr, flags, status| {\n+                    let _ = flags; // /XXX add handling for partials?\n+\n+                    watcher.recv_stop();\n+\n+                    let result = match status {\n+                        None => {\n+                            assert!(nread >= 0);\n+                            Ok((nread as uint, addr))\n+                        }\n+                        Some(err) => Err(uv_error_to_io_error(err)),\n+                    };\n+\n+                    unsafe { (*result_cell_ptr).put_back(result); }\n \n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n-        }\n \n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+            assert!(!result_cell.is_empty());\n+            result_cell.take()\n+        }\n     }\n \n     fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-        let scheduler = Local::take::<Scheduler>();\n-        let buf_ptr: *&[u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-            do self.send(buf, dst) |_watcher, status| {\n+        do self.home_for_io |self_| {\n+            let result_cell = Cell::new_empty();\n+            let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+            let scheduler = Local::take::<Scheduler>();\n+            let buf_ptr: *&[u8] = &buf;\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+                do self_.watcher.send(buf, dst) |_watcher, status| {\n+\n+                    let result = match status {\n+                        None => Ok(()),\n+                        Some(err) => Err(uv_error_to_io_error(err)),\n+                    };\n+\n+                    unsafe { (*result_cell_ptr).put_back(result); }\n \n-                let result = match status {\n-                    None => Ok(()),\n-                    Some(err) => Err(uv_error_to_io_error(err)),\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n-        }\n \n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+            assert!(!result_cell.is_empty());\n+            result_cell.take()\n+        }\n     }\n \n     fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-        let r = unsafe {\n-            do multi.to_str().with_c_str |m_addr| {\n-                uvll::udp_set_membership(self.native_handle(), m_addr,\n-                                         ptr::null(), uvll::UV_JOIN_GROUP)\n-            }\n-        };\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                do multi.to_str().with_c_str |m_addr| {\n+                    uvll::udp_set_membership(self_.watcher.native_handle(), m_addr,\n+                                             ptr::null(), uvll::UV_JOIN_GROUP)\n+                }\n+            };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-        let r = unsafe {\n-            do multi.to_str().with_c_str |m_addr| {\n-                uvll::udp_set_membership(self.native_handle(), m_addr,\n-                                         ptr::null(), uvll::UV_LEAVE_GROUP)\n-            }\n-        };\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                do multi.to_str().with_c_str |m_addr| {\n+                    uvll::udp_set_membership(self_.watcher.native_handle(), m_addr,\n+                                             ptr::null(), uvll::UV_LEAVE_GROUP)\n+                }\n+            };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-        let r = unsafe {\n-            uvll::udp_set_multicast_loop(self.native_handle(), 1 as c_int)\n-        };\n+        do self.home_for_io |self_| {\n+\n+            let r = unsafe {\n+                uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 1 as c_int)\n+            };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-        let r = unsafe {\n-            uvll::udp_set_multicast_loop(self.native_handle(), 0 as c_int)\n-        };\n+        do self.home_for_io |self_| {\n+\n+            let r = unsafe {\n+                uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 0 as c_int)\n+            };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-        let r = unsafe {\n-            uvll::udp_set_multicast_ttl(self.native_handle(), ttl as c_int)\n-        };\n+        do self.home_for_io |self_| {\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            let r = unsafe {\n+                uvll::udp_set_multicast_ttl(self_.watcher.native_handle(), ttl as c_int)\n+            };\n+\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-        let r = unsafe {\n-            uvll::udp_set_ttl(self.native_handle(), ttl as c_int)\n-        };\n+        do self.home_for_io |self_| {\n+\n+            let r = unsafe {\n+                uvll::udp_set_ttl(self_.watcher.native_handle(), ttl as c_int)\n+            };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn hear_broadcasts(&mut self) -> Result<(), IoError> {\n-        let r = unsafe {\n-            uvll::udp_set_broadcast(self.native_handle(), 1 as c_int)\n-        };\n+        do self.home_for_io |self_| {\n+\n+            let r = unsafe {\n+                uvll::udp_set_broadcast(self_.watcher.native_handle(), 1 as c_int)\n+            };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn ignore_broadcasts(&mut self) -> Result<(), IoError> {\n-        let r = unsafe {\n-            uvll::udp_set_broadcast(self.native_handle(), 0 as c_int)\n-        };\n+        do self.home_for_io |self_| {\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            let r = unsafe {\n+                uvll::udp_set_broadcast(self_.watcher.native_handle(), 0 as c_int)\n+            };\n+\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n }\n \n-pub struct UvTimer(timer::TimerWatcher);\n+pub struct UvTimer {\n+    watcher: timer::TimerWatcher,\n+    home: SchedHandle,\n+}\n+\n+impl HomingIO for UvTimer {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n \n impl UvTimer {\n-    fn new(w: timer::TimerWatcher) -> UvTimer {\n-        UvTimer(w)\n+    fn new(w: timer::TimerWatcher, home: SchedHandle) -> UvTimer {\n+        UvTimer { watcher: w, home: home }\n     }\n }\n \n impl Drop for UvTimer {\n     fn drop(&self) {\n-        rtdebug!(\"closing UvTimer\");\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do self.close {\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+        let self_ = unsafe { transmute::<&UvTimer, &mut UvTimer>(self) };\n+        do self_.home_for_io |self_| {\n+            rtdebug!(\"closing UvTimer\");\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.close {\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n         }\n     }\n }\n \n impl RtioTimer for UvTimer {\n-    fn sleep(&self, msecs: u64) {\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_sched, task| {\n-            rtdebug!(\"sleep: entered scheduler context\");\n-            let task_cell = Cell::new(task);\n-            let mut watcher = **self;\n-            do watcher.start(msecs, 0) |_, status| {\n-                assert!(status.is_none());\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+    fn sleep(&mut self, msecs: u64) {\n+        do self.home_for_io |self_| {\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_sched, task| {\n+                rtdebug!(\"sleep: entered scheduler context\");\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.start(msecs, 0) |_, status| {\n+                    assert!(status.is_none());\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n+            self_.watcher.stop();\n         }\n-        let mut w = **self;\n-        w.stop();\n     }\n }\n \n@@ -899,6 +1016,152 @@ fn test_simple_udp_io_bind_only() {\n     }\n }\n \n+#[test]\n+fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n+    use rt::sleeper_list::SleeperList;\n+    use rt::work_queue::WorkQueue;\n+    use rt::thread::Thread;\n+    use rt::task::Task;\n+    use rt::sched::{Shutdown, TaskFromFriend};\n+    do run_in_bare_thread {\n+        let sleepers = SleeperList::new();\n+        let work_queue1 = WorkQueue::new();\n+        let work_queue2 = WorkQueue::new();\n+        let queues = ~[work_queue1.clone(), work_queue2.clone()];\n+\n+        let mut sched1 = ~Scheduler::new(~UvEventLoop::new(), work_queue1, queues.clone(),\n+                                         sleepers.clone());\n+        let mut sched2 = ~Scheduler::new(~UvEventLoop::new(), work_queue2, queues.clone(),\n+                                         sleepers.clone());\n+\n+        let handle1 = Cell::new(sched1.make_handle());\n+        let handle2 = Cell::new(sched2.make_handle());\n+        let tasksFriendHandle = Cell::new(sched2.make_handle());\n+\n+        let on_exit: ~fn(bool) = |exit_status| {\n+            handle1.take().send(Shutdown);\n+            handle2.take().send(Shutdown);\n+            rtassert!(exit_status);\n+        };\n+\n+        let test_function: ~fn() = || {\n+            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let addr = next_test_ip4();\n+            let maybe_socket = unsafe { (*io).udp_bind(addr) };\n+            // this socket is bound to this event loop\n+            assert!(maybe_socket.is_ok());\n+\n+            // block self on sched1\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                // unblock task\n+                do task.wake().map_move |task| {\n+                  // send self to sched2\n+                  tasksFriendHandle.take().send(TaskFromFriend(task));\n+                };\n+                // sched1 should now sleep since it has nothing else to do\n+            }\n+            // sched2 will wake up and get the task\n+            // as we do nothing else, the function ends and the socket goes out of scope\n+            // sched2 will start to run the destructor\n+            // the destructor will first block the task, set it's home as sched1, then enqueue it\n+            // sched2 will dequeue the task, see that it has a home, and send it to sched1\n+            // sched1 will wake up, exec the close function on the correct loop, and then we're done\n+        };\n+\n+        let mut main_task = ~Task::new_root(&mut sched1.stack_pool, None, test_function);\n+        main_task.death.on_exit = Some(on_exit);\n+        let main_task = Cell::new(main_task);\n+\n+        let null_task = Cell::new(~do Task::new_root(&mut sched2.stack_pool, None) || {});\n+\n+        let sched1 = Cell::new(sched1);\n+        let sched2 = Cell::new(sched2);\n+\n+        let thread1 = do Thread::start {\n+            sched1.take().bootstrap(main_task.take());\n+        };\n+        let thread2 = do Thread::start {\n+            sched2.take().bootstrap(null_task.take());\n+        };\n+\n+        thread1.join();\n+        thread2.join();\n+    }\n+}\n+\n+#[test]\n+fn test_simple_homed_udp_io_bind_then_move_handle_then_home_and_close() {\n+    use rt::sleeper_list::SleeperList;\n+    use rt::work_queue::WorkQueue;\n+    use rt::thread::Thread;\n+    use rt::task::Task;\n+    use rt::comm::oneshot;\n+    use rt::sched::Shutdown;\n+    do run_in_bare_thread {\n+        let sleepers = SleeperList::new();\n+        let work_queue1 = WorkQueue::new();\n+        let work_queue2 = WorkQueue::new();\n+        let queues = ~[work_queue1.clone(), work_queue2.clone()];\n+\n+        let mut sched1 = ~Scheduler::new(~UvEventLoop::new(), work_queue1, queues.clone(),\n+                                         sleepers.clone());\n+        let mut sched2 = ~Scheduler::new(~UvEventLoop::new(), work_queue2, queues.clone(),\n+                                         sleepers.clone());\n+\n+        let handle1 = Cell::new(sched1.make_handle());\n+        let handle2 = Cell::new(sched2.make_handle());\n+\n+        let (port, chan) = oneshot();\n+        let port = Cell::new(port);\n+        let chan = Cell::new(chan);\n+\n+        let body1: ~fn() = || {\n+            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let addr = next_test_ip4();\n+            let socket = unsafe { (*io).udp_bind(addr) };\n+            assert!(socket.is_ok());\n+            chan.take().send(socket);\n+        };\n+\n+        let body2: ~fn() = || {\n+            let socket = port.take().recv();\n+            assert!(socket.is_ok());\n+            /* The socket goes out of scope and the destructor is called.\n+             * The destructor:\n+             *  - sends itself back to sched1\n+             *  - frees the socket\n+             *  - resets the home of the task to whatever it was previously\n+             */\n+        };\n+\n+        let on_exit: ~fn(bool) = |exit| {\n+            handle1.take().send(Shutdown);\n+            handle2.take().send(Shutdown);\n+            rtassert!(exit);\n+        };\n+\n+        let task1 = Cell::new(~Task::new_root(&mut sched1.stack_pool, None, body1));\n+\n+        let mut task2 = ~Task::new_root(&mut sched2.stack_pool, None, body2);\n+        task2.death.on_exit = Some(on_exit);\n+        let task2 = Cell::new(task2);\n+\n+        let sched1 = Cell::new(sched1);\n+        let sched2 = Cell::new(sched2);\n+\n+        let thread1 = do Thread::start {\n+            sched1.take().bootstrap(task1.take());\n+        };\n+        let thread2 = do Thread::start {\n+            sched2.take().bootstrap(task2.take());\n+        };\n+\n+        thread1.join();\n+        thread2.join();\n+    }\n+}\n+\n #[test]\n fn test_simple_tcp_server_and_client() {\n     do run_in_newsched_task {\n@@ -930,6 +1193,85 @@ fn test_simple_tcp_server_and_client() {\n     }\n }\n \n+#[test]\n+fn test_simple_tcp_server_and_client_on_diff_threads() {\n+    use rt::sleeper_list::SleeperList;\n+    use rt::work_queue::WorkQueue;\n+    use rt::thread::Thread;\n+    use rt::task::Task;\n+    use rt::sched::{Shutdown};\n+    do run_in_bare_thread {\n+        let sleepers = SleeperList::new();\n+\n+        let server_addr = next_test_ip4();\n+        let client_addr = server_addr.clone();\n+\n+        let server_work_queue = WorkQueue::new();\n+        let client_work_queue = WorkQueue::new();\n+        let queues = ~[server_work_queue.clone(), client_work_queue.clone()];\n+\n+        let mut server_sched = ~Scheduler::new(~UvEventLoop::new(), server_work_queue,\n+                                               queues.clone(), sleepers.clone());\n+        let mut client_sched = ~Scheduler::new(~UvEventLoop::new(), client_work_queue,\n+                                               queues.clone(), sleepers.clone());\n+\n+        let server_handle = Cell::new(server_sched.make_handle());\n+        let client_handle = Cell::new(client_sched.make_handle());\n+\n+        let server_on_exit: ~fn(bool) = |exit_status| {\n+            server_handle.take().send(Shutdown);\n+            rtassert!(exit_status);\n+        };\n+\n+        let client_on_exit: ~fn(bool) = |exit_status| {\n+            client_handle.take().send(Shutdown);\n+            rtassert!(exit_status);\n+        };\n+\n+        let server_fn: ~fn() = || {\n+            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let mut listener = unsafe { (*io).tcp_bind(server_addr).unwrap() };\n+            let mut stream = listener.accept().unwrap();\n+            let mut buf = [0, .. 2048];\n+            let nread = stream.read(buf).unwrap();\n+            assert_eq!(nread, 8);\n+            for i in range(0u, nread) {\n+                assert_eq!(buf[i], i as u8);\n+            }\n+        };\n+\n+        let client_fn: ~fn() = || {\n+            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let mut stream = unsafe { (*io).tcp_connect(client_addr) };\n+            while stream.is_err() {\n+                stream = unsafe { (*io).tcp_connect(client_addr) };\n+            }\n+            stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n+        };\n+\n+        let mut server_task = ~Task::new_root(&mut server_sched.stack_pool, None, server_fn);\n+        server_task.death.on_exit = Some(server_on_exit);\n+        let server_task = Cell::new(server_task);\n+\n+        let mut client_task = ~Task::new_root(&mut client_sched.stack_pool, None, client_fn);\n+        client_task.death.on_exit = Some(client_on_exit);\n+        let client_task = Cell::new(client_task);\n+\n+        let server_sched = Cell::new(server_sched);\n+        let client_sched = Cell::new(client_sched);\n+\n+        let server_thread = do Thread::start {\n+            server_sched.take().bootstrap(server_task.take());\n+        };\n+        let client_thread = do Thread::start {\n+            client_sched.take().bootstrap(client_task.take());\n+        };\n+\n+        server_thread.join();\n+        client_thread.join();\n+    }\n+}\n+\n #[test]\n fn test_simple_udp_server_and_client() {\n     do run_in_newsched_task {\n@@ -1146,19 +1488,13 @@ fn test_udp_many_read() {\n     }\n }\n \n-fn test_timer_sleep_simple_impl() {\n-    unsafe {\n-        let io = Local::unsafe_borrow::<IoFactoryObject>();\n-        let timer = (*io).timer_init();\n-        match timer {\n-            Ok(t) => t.sleep(1),\n-            Err(_) => assert!(false)\n-        }\n-    }\n-}\n #[test]\n fn test_timer_sleep_simple() {\n     do run_in_newsched_task {\n-        test_timer_sleep_simple_impl();\n+        unsafe {\n+            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let timer = (*io).timer_init();\n+            do timer.map_move |mut t| { t.sleep(1) };\n+        }\n     }\n }"}, {"sha": "0ea2175336ab02aefae3f50aa5225b20db43529c", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=0bc1ca404539102065ee0757944ce2288db4cb32", "patch": "@@ -172,6 +172,7 @@ fn request_sanity_check() {\n     }\n }\n \n+// XXX Event loops ignore SIGPIPE by default.\n pub unsafe fn loop_new() -> *c_void {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -287,7 +288,7 @@ pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_\n     return rust_uv_get_udp_handle_from_send_req(send_req);\n }\n \n-pub unsafe fn udp_get_sockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int {\n+pub unsafe fn udp_getsockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n \n     return rust_uv_udp_getsockname(handle, name);"}, {"sha": "b5d6e02b46a4c54a6b0a1100314d86d4b5c8676b", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0bc1ca404539102065ee0757944ce2288db4cb32/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=0bc1ca404539102065ee0757944ce2288db4cb32", "patch": "@@ -13,12 +13,21 @@\n #include <malloc.h>\n #endif\n \n+#ifndef __WIN32__\n+// for signal\n+#include <signal.h>\n+#endif\n+\n #include \"uv.h\"\n \n #include \"rust_globals.h\"\n \n extern \"C\" void*\n rust_uv_loop_new() {\n+// XXX libuv doesn't always ignore SIGPIPE even though we don't need it.\n+#ifndef __WIN32__\n+    signal(SIGPIPE, SIG_IGN);\n+#endif\n     return (void*)uv_loop_new();\n }\n "}]}