{"sha": "72750c7c6ec3678158473f07e98fa72f5115a3dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNzUwYzdjNmVjMzY3ODE1ODQ3M2YwN2U5OGZhNzJmNTExNWEzZGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-09T17:45:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-10T15:25:37Z"}, "message": "std: Consider directory junctions as directories\n\nPreviously on Windows a directory junction would return false from `is_dir`,\ncausing various odd behavior, specifically calls to `create_dir_all` might fail\nwhen they would otherwise continue to succeed.\n\nCloses #26716", "tree": {"sha": "29e2cc3e7e74f5807343fec600c61489426d1758", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29e2cc3e7e74f5807343fec600c61489426d1758"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72750c7c6ec3678158473f07e98fa72f5115a3dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72750c7c6ec3678158473f07e98fa72f5115a3dc", "html_url": "https://github.com/rust-lang/rust/commit/72750c7c6ec3678158473f07e98fa72f5115a3dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72750c7c6ec3678158473f07e98fa72f5115a3dc/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdcce3ba4491436e6603833cee19533003993117", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdcce3ba4491436e6603833cee19533003993117", "html_url": "https://github.com/rust-lang/rust/commit/cdcce3ba4491436e6603833cee19533003993117"}], "stats": {"total": 260, "additions": 225, "deletions": 35}, "files": [{"sha": "06c14b39e124a640e9b6f85be6b565f1b6cb5af5", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/72750c7c6ec3678158473f07e98fa72f5115a3dc/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72750c7c6ec3678158473f07e98fa72f5115a3dc/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=72750c7c6ec3678158473f07e98fa72f5115a3dc", "patch": "@@ -53,9 +53,13 @@ pub const WSA_FLAG_NO_HANDLE_INHERIT: libc::DWORD = 0x80;\n pub const ERROR_NO_MORE_FILES: libc::DWORD = 18;\n pub const TOKEN_READ: libc::DWORD = 0x20008;\n pub const FILE_FLAG_OPEN_REPARSE_POINT: libc::DWORD = 0x00200000;\n+pub const FILE_FLAG_BACKUP_SEMANTICS: libc::DWORD = 0x02000000;\n pub const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\n pub const FSCTL_GET_REPARSE_POINT: libc::DWORD = 0x900a8;\n pub const IO_REPARSE_TAG_SYMLINK: libc::DWORD = 0xa000000c;\n+pub const IO_REPARSE_TAG_MOUNT_POINT: libc::DWORD = 0xa0000003;\n+pub const FSCTL_SET_REPARSE_POINT: libc::DWORD = 0x900a4;\n+pub const FSCTL_DELETE_REPARSE_POINT: libc::DWORD = 0x900ac;\n \n pub const SYMBOLIC_LINK_FLAG_DIRECTORY: libc::DWORD = 0x1;\n \n@@ -71,6 +75,9 @@ pub const PROGRESS_CANCEL: libc::DWORD = 1;\n pub const PROGRESS_STOP: libc::DWORD = 2;\n pub const PROGRESS_QUIET: libc::DWORD = 3;\n \n+pub const TOKEN_ADJUST_PRIVILEGES: libc::DWORD = 0x0020;\n+pub const SE_PRIVILEGE_ENABLED: libc::DWORD = 2;\n+\n #[repr(C)]\n #[cfg(target_arch = \"x86\")]\n pub struct WSADATA {\n@@ -287,6 +294,40 @@ pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE {\n };\n pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: 0 as *mut _ };\n \n+#[repr(C)]\n+pub struct LUID {\n+    pub LowPart: libc::DWORD,\n+    pub HighPart: libc::c_long,\n+}\n+\n+pub type PLUID = *mut LUID;\n+\n+#[repr(C)]\n+pub struct TOKEN_PRIVILEGES {\n+    pub PrivilegeCount: libc::DWORD,\n+    pub Privileges: [LUID_AND_ATTRIBUTES; 1],\n+}\n+\n+pub type PTOKEN_PRIVILEGES = *mut TOKEN_PRIVILEGES;\n+\n+#[repr(C)]\n+pub struct LUID_AND_ATTRIBUTES {\n+    pub Luid: LUID,\n+    pub Attributes: libc::DWORD,\n+}\n+\n+#[repr(C)]\n+pub struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n+    pub ReparseTag: libc::DWORD,\n+    pub ReparseDataLength: libc::DWORD,\n+    pub Reserved: libc::WORD,\n+    pub ReparseTargetLength: libc::WORD,\n+    pub ReparseTargetMaximumLength: libc::WORD,\n+    pub Reserved1: libc::WORD,\n+    pub ReparseTarget: libc::WCHAR,\n+}\n+\n+\n #[link(name = \"ws2_32\")]\n #[link(name = \"userenv\")]\n extern \"system\" {\n@@ -437,6 +478,15 @@ extern \"system\" {\n                        lpData: libc::LPVOID,\n                        pbCancel: LPBOOL,\n                        dwCopyFlags: libc::DWORD) -> libc::BOOL;\n+    pub fn LookupPrivilegeValueW(lpSystemName: libc::LPCWSTR,\n+                                 lpName: libc::LPCWSTR,\n+                                 lpLuid: PLUID) -> libc::BOOL;\n+    pub fn AdjustTokenPrivileges(TokenHandle: libc::HANDLE,\n+                                 DisableAllPrivileges: libc::BOOL,\n+                                 NewState: PTOKEN_PRIVILEGES,\n+                                 BufferLength: libc::DWORD,\n+                                 PreviousState: PTOKEN_PRIVILEGES,\n+                                 ReturnLength: *mut libc::DWORD) -> libc::BOOL;\n }\n \n // Functions that aren't available on Windows XP, but we still use them and just"}, {"sha": "890cc455d5df2a2816e3b2eeb9531e337b4a392e", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 175, "deletions": 35, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/72750c7c6ec3678158473f07e98fa72f5115a3dc/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72750c7c6ec3678158473f07e98fa72f5115a3dc/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=72750c7c6ec3678158473f07e98fa72f5115a3dc", "patch": "@@ -30,12 +30,12 @@ pub struct File { handle: Handle }\n \n pub struct FileAttr {\n     data: c::WIN32_FILE_ATTRIBUTE_DATA,\n-    is_symlink: bool,\n+    reparse_tag: libc::DWORD,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub enum FileType {\n-    Dir, File, Symlink, ReparsePoint\n+    Dir, File, Symlink, ReparsePoint, MountPoint,\n }\n \n pub struct ReadDir {\n@@ -133,7 +133,7 @@ impl DirEntry {\n \n     pub fn file_type(&self) -> io::Result<FileType> {\n         Ok(FileType::new(self.data.dwFileAttributes,\n-                         self.data.dwReserved0 == c::IO_REPARSE_TAG_SYMLINK))\n+                         /* reparse_tag = */ self.data.dwReserved0))\n     }\n \n     pub fn metadata(&self) -> io::Result<FileAttr> {\n@@ -146,7 +146,7 @@ impl DirEntry {\n                 nFileSizeHigh: self.data.nFileSizeHigh,\n                 nFileSizeLow: self.data.nFileSizeLow,\n             },\n-            is_symlink: self.data.dwReserved0 == c::IO_REPARSE_TAG_SYMLINK,\n+            reparse_tag: self.data.dwReserved0,\n         })\n     }\n }\n@@ -218,10 +218,12 @@ impl OpenOptions {\n }\n \n impl File {\n-    fn open_reparse_point(path: &Path) -> io::Result<File> {\n+    fn open_reparse_point(path: &Path, write: bool) -> io::Result<File> {\n         let mut opts = OpenOptions::new();\n-        opts.read(true);\n-        opts.flags_and_attributes(c::FILE_FLAG_OPEN_REPARSE_POINT);\n+        opts.read(!write);\n+        opts.write(write);\n+        opts.flags_and_attributes(c::FILE_FLAG_OPEN_REPARSE_POINT |\n+                                  c::FILE_FLAG_BACKUP_SEMANTICS);\n         File::open(path, &opts)\n     }\n \n@@ -278,10 +280,13 @@ impl File {\n                     nFileSizeHigh: info.nFileSizeHigh,\n                     nFileSizeLow: info.nFileSizeLow,\n                 },\n-                is_symlink: false,\n+                reparse_tag: 0,\n             };\n             if attr.is_reparse_point() {\n-                attr.is_symlink = self.is_symlink();\n+                let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+                if let Ok((_, buf)) = self.reparse_point(&mut b) {\n+                    attr.reparse_tag = buf.ReparseTag;\n+                }\n             }\n             Ok(attr)\n         }\n@@ -314,15 +319,11 @@ impl File {\n \n     pub fn handle(&self) -> &Handle { &self.handle }\n \n-    fn is_symlink(&self) -> bool {\n-        self.readlink().is_ok()\n-    }\n-\n-    fn readlink(&self) -> io::Result<PathBuf> {\n-        let mut space = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n-        let mut bytes = 0;\n-\n+    fn reparse_point<'a>(&self,\n+                         space: &'a mut [u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE])\n+                         -> io::Result<(libc::DWORD, &'a c::REPARSE_DATA_BUFFER)> {\n         unsafe {\n+            let mut bytes = 0;\n             try!(cvt({\n                 c::DeviceIoControl(self.handle.raw(),\n                                    c::FSCTL_GET_REPARSE_POINT,\n@@ -333,12 +334,20 @@ impl File {\n                                    &mut bytes,\n                                    0 as *mut _)\n             }));\n-            let buf: *const c::REPARSE_DATA_BUFFER = space.as_ptr() as *const _;\n-            if (*buf).ReparseTag != c::IO_REPARSE_TAG_SYMLINK {\n-                return Err(io::Error::new(io::ErrorKind::Other, \"not a symlink\"))\n-            }\n+            Ok((bytes, &*(space.as_ptr() as *const c::REPARSE_DATA_BUFFER)))\n+        }\n+    }\n+\n+    fn readlink(&self) -> io::Result<PathBuf> {\n+        let mut space = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+        let (_bytes, buf) = try!(self.reparse_point(&mut space));\n+        if buf.ReparseTag != c::IO_REPARSE_TAG_SYMLINK {\n+            return Err(io::Error::new(io::ErrorKind::Other, \"not a symlink\"))\n+        }\n+\n+        unsafe {\n             let info: *const c::SYMBOLIC_LINK_REPARSE_BUFFER =\n-                    &(*buf).rest as *const _ as *const _;\n+                    &buf.rest as *const _ as *const _;\n             let path_buffer = &(*info).PathBuffer as *const _ as *const u16;\n             let subst_off = (*info).SubstituteNameOffset / 2;\n             let subst_ptr = path_buffer.offset(subst_off as isize);\n@@ -383,7 +392,7 @@ impl FileAttr {\n     pub fn attrs(&self) -> u32 { self.data.dwFileAttributes as u32 }\n \n     pub fn file_type(&self) -> FileType {\n-        FileType::new(self.data.dwFileAttributes, self.is_symlink)\n+        FileType::new(self.data.dwFileAttributes, self.reparse_tag)\n     }\n \n     pub fn created(&self) -> u64 { self.to_u64(&self.data.ftCreationTime) }\n@@ -414,12 +423,12 @@ impl FilePermissions {\n }\n \n impl FileType {\n-    fn new(attrs: libc::DWORD, is_symlink: bool) -> FileType {\n+    fn new(attrs: libc::DWORD, reparse_tag: libc::DWORD) -> FileType {\n         if attrs & libc::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n-            if is_symlink {\n-                FileType::Symlink\n-            } else {\n-                FileType::ReparsePoint\n+            match reparse_tag {\n+                c::IO_REPARSE_TAG_SYMLINK => FileType::Symlink,\n+                c::IO_REPARSE_TAG_MOUNT_POINT => FileType::MountPoint,\n+                _ => FileType::ReparsePoint,\n             }\n         } else if attrs & c::FILE_ATTRIBUTE_DIRECTORY != 0 {\n             FileType::Dir\n@@ -430,7 +439,9 @@ impl FileType {\n \n     pub fn is_dir(&self) -> bool { *self == FileType::Dir }\n     pub fn is_file(&self) -> bool { *self == FileType::File }\n-    pub fn is_symlink(&self) -> bool { *self == FileType::Symlink }\n+    pub fn is_symlink(&self) -> bool {\n+        *self == FileType::Symlink || *self == FileType::MountPoint\n+    }\n }\n \n impl DirBuilder {\n@@ -488,7 +499,7 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let file = try!(File::open_reparse_point(p));\n+    let file = try!(File::open_reparse_point(p, false));\n     file.readlink()\n }\n \n@@ -517,8 +528,15 @@ pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n     let attr = try!(lstat(p));\n-    if attr.data.dwFileAttributes & libc::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n-        let opts = OpenOptions::new();\n+\n+    // If this is a reparse point, then we need to reopen the file to get the\n+    // actual destination. We also pass the FILE_FLAG_BACKUP_SEMANTICS flag to\n+    // ensure that we can open directories (this path may be a directory\n+    // junction). Once the file is opened we ask the opened handle what its\n+    // metadata information is.\n+    if attr.is_reparse_point() {\n+        let mut opts = OpenOptions::new();\n+        opts.flags_and_attributes(c::FILE_FLAG_BACKUP_SEMANTICS);\n         let file = try!(File::open(p, &opts));\n         file.file_attr()\n     } else {\n@@ -534,9 +552,10 @@ pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n                                          c::GetFileExInfoStandard,\n                                          &mut attr.data as *mut _ as *mut _)));\n         if attr.is_reparse_point() {\n-            attr.is_symlink = File::open_reparse_point(p).map(|f| {\n-                f.is_symlink()\n-            }).unwrap_or(false);\n+            attr.reparse_tag = File::open_reparse_point(p, false).and_then(|f| {\n+                let mut b = [0; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+                f.reparse_point(&mut b).map(|(_, b)| b.ReparseTag)\n+            }).unwrap_or(0);\n         }\n         Ok(attr)\n     }\n@@ -600,3 +619,124 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     }));\n     Ok(size as u64)\n }\n+\n+#[test]\n+fn directory_junctions_are_directories() {\n+    use ffi::OsStr;\n+    use env;\n+    use rand::{self, StdRng, Rng};\n+\n+    macro_rules! t {\n+        ($e:expr) => (match $e {\n+            Ok(e) => e,\n+            Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n+        })\n+    }\n+\n+    let d = DirBuilder::new();\n+    let p = env::temp_dir();\n+    let mut r = rand::thread_rng();\n+    let ret = p.join(&format!(\"rust-{}\", r.next_u32()));\n+    let foo = ret.join(\"foo\");\n+    let bar = ret.join(\"bar\");\n+    t!(d.mkdir(&ret));\n+    t!(d.mkdir(&foo));\n+    t!(d.mkdir(&bar));\n+\n+    t!(create_junction(&bar, &foo));\n+    let metadata = stat(&bar);\n+    t!(delete_junction(&bar));\n+\n+    t!(rmdir(&foo));\n+    t!(rmdir(&bar));\n+    t!(rmdir(&ret));\n+\n+    let metadata = t!(metadata);\n+    assert!(metadata.file_type().is_dir());\n+\n+    // Creating a directory junction on windows involves dealing with reparse\n+    // points and the DeviceIoControl function, and this code is a skeleton of\n+    // what can be found here:\n+    //\n+    // http://www.flexhex.com/docs/articles/hard-links.phtml\n+    fn create_junction(src: &Path, dst: &Path) -> io::Result<()> {\n+        let f = try!(opendir(src, true));\n+        let h = f.handle().raw();\n+\n+        unsafe {\n+            let mut data = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+            let mut db = data.as_mut_ptr()\n+                            as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n+            let mut buf = &mut (*db).ReparseTarget as *mut _;\n+            let mut i = 0;\n+            let v = br\"\\??\\\";\n+            let v = v.iter().map(|x| *x as u16);\n+            for c in v.chain(dst.as_os_str().encode_wide()) {\n+                *buf.offset(i) = c;\n+                i += 1;\n+            }\n+            *buf.offset(i) = 0;\n+            i += 1;\n+            (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n+            (*db).ReparseTargetMaximumLength = (i * 2) as libc::WORD;\n+            (*db).ReparseTargetLength = ((i - 1) * 2) as libc::WORD;\n+            (*db).ReparseDataLength =\n+                    (*db).ReparseTargetLength as libc::DWORD + 12;\n+\n+            let mut ret = 0;\n+            cvt(c::DeviceIoControl(h as *mut _,\n+                                   c::FSCTL_SET_REPARSE_POINT,\n+                                   data.as_ptr() as *mut _,\n+                                   (*db).ReparseDataLength + 8,\n+                                   0 as *mut _, 0,\n+                                   &mut ret,\n+                                   0 as *mut _)).map(|_| ())\n+        }\n+    }\n+\n+    fn opendir(p: &Path, write: bool) -> io::Result<File> {\n+        unsafe {\n+            let mut token = 0 as *mut _;\n+            let mut tp: c::TOKEN_PRIVILEGES = mem::zeroed();\n+            try!(cvt(c::OpenProcessToken(c::GetCurrentProcess(),\n+                                         c::TOKEN_ADJUST_PRIVILEGES,\n+                                         &mut token)));\n+            let name: &OsStr = if write {\n+                \"SeRestorePrivilege\".as_ref()\n+            } else {\n+                \"SeBackupPrivilege\".as_ref()\n+            };\n+            let name = name.encode_wide().chain(Some(0)).collect::<Vec<_>>();\n+            try!(cvt(c::LookupPrivilegeValueW(0 as *const _,\n+                                              name.as_ptr(),\n+                                              &mut tp.Privileges[0].Luid)));\n+            tp.PrivilegeCount = 1;\n+            tp.Privileges[0].Attributes = c::SE_PRIVILEGE_ENABLED;\n+            let size = mem::size_of::<c::TOKEN_PRIVILEGES>() as libc::DWORD;\n+            try!(cvt(c::AdjustTokenPrivileges(token, libc::FALSE, &mut tp, size,\n+                                              0 as *mut _, 0 as *mut _)));\n+            try!(cvt(libc::CloseHandle(token)));\n+\n+            File::open_reparse_point(p, write)\n+        }\n+    }\n+\n+    fn delete_junction(p: &Path) -> io::Result<()> {\n+        unsafe {\n+            let f = try!(opendir(p, true));\n+            let h = f.handle().raw();\n+            let mut data = [0u8; c::MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+            let mut db = data.as_mut_ptr()\n+                            as *mut c::REPARSE_MOUNTPOINT_DATA_BUFFER;\n+            (*db).ReparseTag = c::IO_REPARSE_TAG_MOUNT_POINT;\n+            let mut bytes = 0;\n+            cvt(c::DeviceIoControl(h as *mut _,\n+                                   c::FSCTL_DELETE_REPARSE_POINT,\n+                                   data.as_ptr() as *mut _,\n+                                   (*db).ReparseDataLength + 8,\n+                                   0 as *mut _, 0,\n+                                   &mut bytes,\n+                                   0 as *mut _)).map(|_| ())\n+        }\n+    }\n+}"}]}