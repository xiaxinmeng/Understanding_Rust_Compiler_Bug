{"sha": "7946597f7556dc8e1ad05e02d7e82b4ff800a5ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5NDY1OTdmNzU1NmRjOGUxYWQwNWUwMmQ3ZTgyYjRmZjgwMGE1YWM=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-12-11T14:30:14Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2017-01-03T07:48:29Z"}, "message": "Refactor is_uninhabited\n\nWe now cache the inhabitedness of types in the GlobalCtxt.\n\nRather than calculating whether a type is visibly uninhabited from a given\nNodeId we calculate the full set of NodeIds from which a type is visibly\nuninhabited then cache that set. We can then use that to answer queries about\nthe inhabitedness of a type relative to any given node.", "tree": {"sha": "f3a24de5d4cb2bd712cf14b0c14152cc1f563ead", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3a24de5d4cb2bd712cf14b0c14152cc1f563ead"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac", "html_url": "https://github.com/rust-lang/rust/commit/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9482492ab65820773ba0b5bd1ad81da5f5858c6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9482492ab65820773ba0b5bd1ad81da5f5858c6c", "html_url": "https://github.com/rust-lang/rust/commit/9482492ab65820773ba0b5bd1ad81da5f5858c6c"}], "stats": {"total": 381, "additions": 294, "deletions": 87}, "files": [{"sha": "6c7946a528e04abde35140b1cb8fa8c57e70109a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7946597f7556dc8e1ad05e02d7e82b4ff800a5ac", "patch": "@@ -33,6 +33,7 @@ use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n+use ty::inhabitedness::NodeForrest;\n use ty::maps;\n use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n@@ -459,6 +460,8 @@ pub struct GlobalCtxt<'tcx> {\n     // FIXME dep tracking -- should be harmless enough\n     pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n \n+    pub inhabitedness_cache: RefCell<FxHashMap<Ty<'tcx>, NodeForrest>>,\n+\n     pub lang_items: middle::lang_items::LanguageItems,\n \n     /// Maps from def-id of a type or region parameter to its\n@@ -760,6 +763,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             associated_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             ty_param_defs: RefCell::new(NodeMap()),\n             normalized_cache: RefCell::new(FxHashMap()),\n+            inhabitedness_cache: RefCell::new(FxHashMap()),\n             lang_items: lang_items,\n             inherent_impls: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             used_unsafe: RefCell::new(NodeSet()),"}, {"sha": "54fdbe1a34af8e79b54a3eea0e53ad029473e343", "filename": "src/librustc/ty/inhabitedness.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac/src%2Flibrustc%2Fty%2Finhabitedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac/src%2Flibrustc%2Fty%2Finhabitedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness.rs?ref=7946597f7556dc8e1ad05e02d7e82b4ff800a5ac", "patch": "@@ -0,0 +1,261 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem;\n+use rustc_data_structures::small_vec::SmallVec;\n+use syntax::ast::{CRATE_NODE_ID, NodeId};\n+use util::nodemap::FxHashSet;\n+use ty::context::TyCtxt;\n+use ty::{AdtDef, VariantDef, FieldDef, TyS};\n+use ty::{DefId, Substs};\n+use ty::{AdtKind, Visibility, NodeIdTree};\n+use ty::TypeVariants::*;\n+\n+/// Represents a set of nodes closed under the ancestor relation. That is, if a\n+/// node is in this set then so are all its descendants.\n+#[derive(Clone)]\n+pub struct NodeForrest {\n+    /// The minimal set of nodes required to represent the whole set.\n+    /// If A and B are nodes in the NodeForrest, and A is a desecendant\n+    /// of B, then only B will be in root_nodes.\n+    /// We use a SmallVec here because (for its use in this module) its rare\n+    /// that this will contain more than one or two nodes.\n+    root_nodes: SmallVec<[NodeId; 1]>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> NodeForrest {\n+    /// Create an empty set.\n+    pub fn empty() -> NodeForrest {\n+        NodeForrest {\n+            root_nodes: SmallVec::new(),\n+        }\n+    }\n+\n+    /// Create a set containing every node.\n+    #[inline]\n+    pub fn full() -> NodeForrest {\n+        NodeForrest::from_node(CRATE_NODE_ID)\n+    }\n+\n+    /// Create a set containing a node and all its descendants.\n+    pub fn from_node(node: NodeId) -> NodeForrest {\n+        let mut root_nodes = SmallVec::new();\n+        root_nodes.push(node);\n+        NodeForrest {\n+            root_nodes: root_nodes,\n+        }\n+    }\n+\n+    /// Test whether the set is empty.\n+    pub fn is_empty(&self) -> bool {\n+        self.root_nodes.is_empty()\n+    }\n+\n+    /// Test whether the set conains a node.\n+    pub fn contains(&self,\n+                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    node: NodeId) -> bool\n+    {\n+        for root_node in self.root_nodes.iter() {\n+            if tcx.map.is_descendant_of(node, *root_node) {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Calculate the intersection of a collection of sets.\n+    pub fn intersection<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                           iter: I) -> NodeForrest\n+            where I: IntoIterator<Item=NodeForrest>\n+    {\n+        let mut ret = NodeForrest::full();\n+        let mut next_ret = SmallVec::new();\n+        let mut old_ret: SmallVec<[NodeId; 1]> = SmallVec::new();\n+        for next_set in iter {\n+            for node in ret.root_nodes.drain(..) {\n+                if next_set.contains(tcx, node) {\n+                    next_ret.push(node);\n+                } else {\n+                    old_ret.push(node);\n+                }\n+            }\n+            ret.root_nodes.extend(old_ret.drain(..));\n+\n+            for node in next_set.root_nodes {\n+                if ret.contains(tcx, node) {\n+                    next_ret.push(node);\n+                }\n+            }\n+\n+            mem::swap(&mut next_ret, &mut ret.root_nodes);\n+            next_ret.drain(..);\n+        }\n+        ret\n+    }\n+\n+    /// Calculate the union of a collection of sets.\n+    pub fn union<I>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    iter: I) -> NodeForrest\n+            where I: IntoIterator<Item=NodeForrest>\n+    {\n+        let mut ret = NodeForrest::empty();\n+        let mut next_ret = SmallVec::new();\n+        for next_set in iter {\n+            for node in ret.root_nodes.drain(..) {\n+                if !next_set.contains(tcx, node) {\n+                    next_ret.push(node);\n+                }\n+            }\n+\n+            for node in next_set.root_nodes {\n+                if !next_ret.contains(&node) {\n+                    next_ret.push(node);\n+                }\n+            }\n+\n+            mem::swap(&mut next_ret, &mut ret.root_nodes);\n+            next_ret.drain(..);\n+        }\n+        ret\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> AdtDef {\n+    /// Calculate the set of  nodes from which this adt is visibly uninhabited.\n+    pub fn uninhabited_from(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                substs: &'tcx Substs<'tcx>) -> NodeForrest\n+    {\n+        if !visited.insert((self.did, substs)) {\n+            return NodeForrest::empty();\n+        }\n+\n+        let ret = NodeForrest::intersection(tcx, self.variants.iter().map(|v| {\n+            v.uninhabited_from(visited, tcx, substs, self.adt_kind())\n+        }));\n+        visited.remove(&(self.did, substs));\n+        ret\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> VariantDef {\n+    /// Calculate the set of  nodes from which this variant is visibly uninhabited.\n+    pub fn uninhabited_from(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                substs: &'tcx Substs<'tcx>,\n+                adt_kind: AdtKind) -> NodeForrest\n+    {\n+        match adt_kind {\n+            AdtKind::Union => {\n+                NodeForrest::intersection(tcx, self.fields.iter().map(|f| {\n+                    f.uninhabited_from(visited, tcx, substs, false)\n+                }))\n+            },\n+            AdtKind::Struct => {\n+                NodeForrest::union(tcx, self.fields.iter().map(|f| {\n+                    f.uninhabited_from(visited, tcx, substs, false)\n+                }))\n+            },\n+            AdtKind::Enum => {\n+                NodeForrest::union(tcx, self.fields.iter().map(|f| {\n+                    f.uninhabited_from(visited, tcx, substs, true)\n+                }))\n+            },\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> FieldDef {\n+    /// Calculate the set of  nodes from which this field is visibly uninhabited.\n+    pub fn uninhabited_from(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                substs: &'tcx Substs<'tcx>,\n+                is_enum: bool) -> NodeForrest\n+    {\n+        if let Visibility::PrivateExternal = self.vis {\n+            return NodeForrest::empty();\n+        }\n+\n+        let data_inhabitedness = self.ty(tcx, substs).uninhabited_from(visited, tcx);\n+        match self.vis {\n+            Visibility::Restricted(from) if !is_enum => {\n+                let node_set = NodeForrest::from_node(from);\n+                let iter = Some(node_set).into_iter().chain(Some(data_inhabitedness));\n+                NodeForrest::intersection(tcx, iter)\n+            },\n+            _ => data_inhabitedness,\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n+    /// Calculate the set of  nodes from which this type is visibly uninhabited.\n+    pub fn uninhabited_from(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> NodeForrest\n+    {\n+        match tcx.lift_to_global(&self) {\n+            Some(global_ty) => {\n+                {\n+                    let cache = tcx.inhabitedness_cache.borrow();\n+                    if let Some(closed_node_set) = cache.get(&global_ty) {\n+                        return closed_node_set.clone();\n+                    }\n+                }\n+                let node_set = global_ty.uninhabited_from_inner(visited, tcx);\n+                let mut cache = tcx.inhabitedness_cache.borrow_mut();\n+                cache.insert(global_ty, node_set.clone());\n+                node_set\n+            },\n+            None => {\n+                let node_set = self.uninhabited_from_inner(visited, tcx);\n+                node_set\n+            },\n+        }\n+    }\n+\n+    fn uninhabited_from_inner(\n+                &self,\n+                visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                tcx: TyCtxt<'a, 'gcx, 'tcx>) -> NodeForrest\n+    {\n+        match self.sty {\n+            TyAdt(def, substs) => {\n+                def.uninhabited_from(visited, tcx, substs)\n+            },\n+\n+            TyNever => NodeForrest::full(),\n+            TyTuple(ref tys) => {\n+                NodeForrest::union(tcx, tys.iter().map(|ty| {\n+                    ty.uninhabited_from(visited, tcx)\n+                }))\n+            },\n+            TyArray(ty, len) => {\n+                if len == 0 {\n+                    NodeForrest::empty()\n+                } else {\n+                    ty.uninhabited_from(visited, tcx)\n+                }\n+            }\n+            TyRef(_, ref tm) => tm.ty.uninhabited_from(visited, tcx),\n+\n+            _ => NodeForrest::empty(),\n+        }\n+    }\n+}\n+"}, {"sha": "7cfc0f74214da142cf30adff6f110e2966ce7855", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7946597f7556dc8e1ad05e02d7e82b4ff800a5ac", "patch": "@@ -29,7 +29,7 @@ use ty;\n use ty::subst::{Subst, Substs};\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n-use util::nodemap::{NodeSet, NodeMap, FxHashMap, FxHashSet};\n+use util::nodemap::{NodeSet, NodeMap, FxHashMap};\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n@@ -78,6 +78,7 @@ pub mod cast;\n pub mod error;\n pub mod fast_reject;\n pub mod fold;\n+pub mod inhabitedness;\n pub mod item_path;\n pub mod layout;\n pub mod _match;\n@@ -1406,20 +1407,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK_VALID)\n     }\n \n-    #[inline]\n-    pub fn is_uninhabited_recurse(&self,\n-                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                                  block: Option<NodeId>,\n-                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  substs: &'tcx Substs<'tcx>) -> bool {\n-        if !visited.insert((self.did, substs)) {\n-            return false;\n-        };\n-        self.variants.iter().all(|v| {\n-            v.is_uninhabited_recurse(visited, block, tcx, substs, self.adt_kind())\n-        })\n-    }\n-\n     #[inline]\n     pub fn is_struct(&self) -> bool {\n         !self.is_union() && !self.is_enum()\n@@ -1754,51 +1741,12 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     pub fn field_named(&self, name: ast::Name) -> &FieldDef {\n         self.find_field_named(name).unwrap()\n     }\n-\n-    #[inline]\n-    pub fn is_uninhabited_recurse(&self,\n-                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                                  block: Option<NodeId>,\n-                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  substs: &'tcx Substs<'tcx>,\n-                                  adt_kind: AdtKind) -> bool {\n-        match adt_kind {\n-            AdtKind::Union => {\n-                self.fields.iter().all(|f| {\n-                    f.is_uninhabited_recurse(visited, block, tcx, substs, false)\n-                })\n-            },\n-            AdtKind::Struct => {\n-                self.fields.iter().any(|f| {\n-                    f.is_uninhabited_recurse(visited, block, tcx, substs, false)\n-                })\n-            },\n-            AdtKind::Enum => {\n-                self.fields.iter().any(|f| {\n-                    f.is_uninhabited_recurse(visited, block, tcx, substs, true)\n-                })\n-            },\n-        }\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> FieldDef {\n     pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n         tcx.item_type(self.did).subst(tcx, subst)\n     }\n-\n-    #[inline]\n-    pub fn is_uninhabited_recurse(&self,\n-                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                                  block: Option<NodeId>,\n-                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  substs: &'tcx Substs<'tcx>,\n-                                  is_enum: bool) -> bool {\n-        let visible = is_enum || block.map_or(true, |b| {\n-            tcx.vis_is_accessible_from(self.vis, b)\n-        });\n-        visible && self.ty(tcx, substs).is_uninhabited_recurse(visited, block, tcx)\n-    }\n }\n \n /// Records the substitutions used to translate the polytype for an"}, {"sha": "340b7415f5cb30b3e6bb2b8b704a2f472bd302b3", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=7946597f7556dc8e1ad05e02d7e82b4ff800a5ac", "patch": "@@ -979,29 +979,21 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    /// Checks whether a type is uninhabited.\n-    /// If `block` is `Some(id)` it also checks that the uninhabited-ness is visible from `id`.\n-    pub fn is_uninhabited(&self, block: Option<NodeId>, cx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+    /// Checks whether a type is visibly uninhabited from a particular node.\n+    pub fn is_uninhabited_from(&self, block: NodeId, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         let mut visited = FxHashSet::default();\n-        self.is_uninhabited_recurse(&mut visited, block, cx)\n+        let node_set = self.uninhabited_from(&mut visited, tcx);\n+        node_set.contains(tcx, block)\n     }\n \n-    pub fn is_uninhabited_recurse(&self,\n-                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                                  block: Option<NodeId>,\n-                                  cx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        match self.sty {\n-            TyAdt(def, substs) => {\n-                def.is_uninhabited_recurse(visited, block, cx, substs)\n-            },\n-\n-            TyNever => true,\n-            TyTuple(ref tys) => tys.iter().any(|ty| ty.is_uninhabited_recurse(visited, block, cx)),\n-            TyArray(ty, len) => len > 0 && ty.is_uninhabited_recurse(visited, block, cx),\n-            TyRef(_, ref tm) => tm.ty.is_uninhabited_recurse(visited, block, cx),\n-\n-            _ => false,\n-        }\n+    /// Checks whether a type is uninhabited.\n+    /// Note: just because a type is uninhabited, that doesn't mean that it's\n+    /// *visibly* uninhabited outside its module. You sometimes may want\n+    /// `is_uninhabited_from` instead.\n+    pub fn is_uninhabited_anywhere(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+        let mut visited = FxHashSet::default();\n+        let node_set = self.uninhabited_from(&mut visited, tcx);\n+        !node_set.is_empty()\n     }\n \n     pub fn is_primitive(&self) -> bool {"}, {"sha": "ea01857745e56fdf54446e40b11206c18424e7ec", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=7946597f7556dc8e1ad05e02d7e82b4ff800a5ac", "patch": "@@ -379,14 +379,14 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n         ty::TySlice(ref sub_ty) => {\n-            if sub_ty.is_uninhabited(Some(cx.node), cx.tcx) {\n+            if sub_ty.is_uninhabited_from(cx.node, cx.tcx) {\n                 vec![Slice(0)]\n             } else {\n                 (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect()\n             }\n         }\n         ty::TyArray(ref sub_ty, length) => {\n-            if length == 0 || !sub_ty.is_uninhabited(Some(cx.node), cx.tcx) {\n+            if length == 0 || !sub_ty.is_uninhabited_from(cx.node, cx.tcx) {\n                 vec![Slice(length)]\n             } else {\n                 vec![]\n@@ -395,18 +395,18 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         ty::TyAdt(def, substs) if def.is_enum() && def.variants.len() != 1 => {\n             def.variants.iter().filter_map(|v| {\n                 let mut visited = FxHashSet::default();\n-                if v.is_uninhabited_recurse(&mut visited,\n-                                            Some(cx.node),\n-                                            cx.tcx, substs,\n-                                            AdtKind::Enum) {\n+                let node_set = v.uninhabited_from(&mut visited,\n+                                                  cx.tcx, substs,\n+                                                  AdtKind::Enum);\n+                if node_set.contains(cx.tcx, cx.node) {\n                     None\n                 } else {\n                     Some(Variant(v.did))\n                 }\n             }).collect()\n         }\n         _ => {\n-            if pcx.ty.is_uninhabited(Some(cx.node), cx.tcx) {\n+            if pcx.ty.is_uninhabited_from(cx.node, cx.tcx) {\n                 vec![]\n             } else {\n                 vec![Single]"}, {"sha": "b071834122367421000e107fd2e06fd2324baba9", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7946597f7556dc8e1ad05e02d7e82b4ff800a5ac/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=7946597f7556dc8e1ad05e02d7e82b4ff800a5ac", "patch": "@@ -100,12 +100,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             PatternKind::Variant { adt_def, substs, variant_index, ref subpatterns } => {\n                 let irrefutable = adt_def.variants.iter().enumerate().all(|(i, v)| {\n-                    let mut visited = FxHashSet::default();\n-                    i == variant_index || v.is_uninhabited_recurse(&mut visited,\n-                                                                   None,\n-                                                                   self.hir.tcx(),\n-                                                                   substs,\n-                                                                   adt_def.adt_kind())\n+                    i == variant_index || {\n+                        let mut visited = FxHashSet::default();\n+                        let node_set = v.uninhabited_from(&mut visited,\n+                                                          self.hir.tcx(),\n+                                                          substs,\n+                                                          adt_def.adt_kind());\n+                        !node_set.is_empty()\n+                    }\n                 });\n                 if irrefutable {\n                     let lvalue = match_pair.lvalue.downcast(adt_def, variant_index);"}]}