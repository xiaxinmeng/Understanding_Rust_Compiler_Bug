{"sha": "a246d4f599dcf2612fa99720fb4ca98101ed93fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNDZkNGY1OTlkY2YyNjEyZmE5OTcyMGZiNGNhOTgxMDFlZDkzZmI=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-10-23T10:14:58Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-10-23T10:14:58Z"}, "message": "cfg: move tests to separate file\n\nthat way we don't have to re-check the entire project when a test is\nchanged", "tree": {"sha": "5972eedd06b94860d1c87a6711766377585a04b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5972eedd06b94860d1c87a6711766377585a04b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a246d4f599dcf2612fa99720fb4ca98101ed93fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a246d4f599dcf2612fa99720fb4ca98101ed93fb", "html_url": "https://github.com/rust-lang/rust/commit/a246d4f599dcf2612fa99720fb4ca98101ed93fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a246d4f599dcf2612fa99720fb4ca98101ed93fb/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dab8870f5c6d90ea1a327037825dc87a46778045", "url": "https://api.github.com/repos/rust-lang/rust/commits/dab8870f5c6d90ea1a327037825dc87a46778045", "html_url": "https://github.com/rust-lang/rust/commit/dab8870f5c6d90ea1a327037825dc87a46778045"}], "stats": {"total": 403, "additions": 195, "deletions": 208}, "files": [{"sha": "42327f1e147bbbadf2aaae0b9411aec2cea3434c", "filename": "crates/cfg/src/cfg_expr.rs", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a246d4f599dcf2612fa99720fb4ca98101ed93fb/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a246d4f599dcf2612fa99720fb4ca98101ed93fb/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs?ref=a246d4f599dcf2612fa99720fb4ca98101ed93fb", "patch": "@@ -128,53 +128,3 @@ fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n     }\n     Some(ret)\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use mbe::ast_to_token_tree;\n-    use syntax::ast::{self, AstNode};\n-\n-    fn assert_parse_result(input: &str, expected: CfgExpr) {\n-        let (tt, _) = {\n-            let source_file = ast::SourceFile::parse(input).ok().unwrap();\n-            let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-            ast_to_token_tree(&tt).unwrap()\n-        };\n-        let cfg = CfgExpr::parse(&tt);\n-        assert_eq!(cfg, expected);\n-    }\n-\n-    #[test]\n-    fn test_cfg_expr_parser() {\n-        assert_parse_result(\"#![cfg(foo)]\", CfgAtom::Flag(\"foo\".into()).into());\n-        assert_parse_result(\"#![cfg(foo,)]\", CfgAtom::Flag(\"foo\".into()).into());\n-        assert_parse_result(\n-            \"#![cfg(not(foo))]\",\n-            CfgExpr::Not(Box::new(CfgAtom::Flag(\"foo\".into()).into())),\n-        );\n-        assert_parse_result(\"#![cfg(foo(bar))]\", CfgExpr::Invalid);\n-\n-        // Only take the first\n-        assert_parse_result(r#\"#![cfg(foo, bar = \"baz\")]\"#, CfgAtom::Flag(\"foo\".into()).into());\n-\n-        assert_parse_result(\n-            r#\"#![cfg(all(foo, bar = \"baz\"))]\"#,\n-            CfgExpr::All(vec![\n-                CfgAtom::Flag(\"foo\".into()).into(),\n-                CfgAtom::KeyValue { key: \"bar\".into(), value: \"baz\".into() }.into(),\n-            ]),\n-        );\n-\n-        assert_parse_result(\n-            r#\"#![cfg(any(not(), all(), , bar = \"baz\",))]\"#,\n-            CfgExpr::Any(vec![\n-                CfgExpr::Not(Box::new(CfgExpr::Invalid)),\n-                CfgExpr::All(vec![]),\n-                CfgExpr::Invalid,\n-                CfgAtom::KeyValue { key: \"bar\".into(), value: \"baz\".into() }.into(),\n-            ]),\n-        );\n-    }\n-}"}, {"sha": "580c9a9a2c1832d50f7845089cf0ad8936c981f0", "filename": "crates/cfg/src/dnf.rs", "status": "modified", "additions": 0, "deletions": 158, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/a246d4f599dcf2612fa99720fb4ca98101ed93fb/crates%2Fcfg%2Fsrc%2Fdnf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a246d4f599dcf2612fa99720fb4ca98101ed93fb/crates%2Fcfg%2Fsrc%2Fdnf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Fdnf.rs?ref=a246d4f599dcf2612fa99720fb4ca98101ed93fb", "patch": "@@ -318,161 +318,3 @@ fn make_nnf(expr: CfgExpr) -> CfgExpr {\n         },\n     }\n }\n-\n-#[cfg(test)]\n-mod test {\n-    use expect_test::{expect, Expect};\n-    use mbe::ast_to_token_tree;\n-    use syntax::{ast, AstNode};\n-\n-    use super::*;\n-\n-    fn check_dnf(input: &str, expect: Expect) {\n-        let (tt, _) = {\n-            let source_file = ast::SourceFile::parse(input).ok().unwrap();\n-            let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-            ast_to_token_tree(&tt).unwrap()\n-        };\n-        let cfg = CfgExpr::parse(&tt);\n-        let actual = format!(\"#![cfg({})]\", DnfExpr::new(cfg));\n-        expect.assert_eq(&actual);\n-    }\n-\n-    fn check_why_inactive(input: &str, opts: &CfgOptions, expect: Expect) {\n-        let (tt, _) = {\n-            let source_file = ast::SourceFile::parse(input).ok().unwrap();\n-            let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-            ast_to_token_tree(&tt).unwrap()\n-        };\n-        let cfg = CfgExpr::parse(&tt);\n-        let dnf = DnfExpr::new(cfg);\n-        let why_inactive = dnf.why_inactive(opts).unwrap().to_string();\n-        expect.assert_eq(&why_inactive);\n-    }\n-\n-    #[track_caller]\n-    fn check_enable_hints(input: &str, opts: &CfgOptions, expected_hints: &[&str]) {\n-        let (tt, _) = {\n-            let source_file = ast::SourceFile::parse(input).ok().unwrap();\n-            let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-            ast_to_token_tree(&tt).unwrap()\n-        };\n-        let cfg = CfgExpr::parse(&tt);\n-        let dnf = DnfExpr::new(cfg);\n-        let hints = dnf.compute_enable_hints(opts).map(|diff| diff.to_string()).collect::<Vec<_>>();\n-        assert_eq!(hints, expected_hints);\n-    }\n-\n-    #[test]\n-    fn smoke() {\n-        check_dnf(\"#![cfg(test)]\", expect![[r#\"#![cfg(test)]\"#]]);\n-        check_dnf(\"#![cfg(not(test))]\", expect![[r#\"#![cfg(not(test))]\"#]]);\n-        check_dnf(\"#![cfg(not(not(test)))]\", expect![[r#\"#![cfg(test)]\"#]]);\n-\n-        check_dnf(\"#![cfg(all(a, b))]\", expect![[r#\"#![cfg(all(a, b))]\"#]]);\n-        check_dnf(\"#![cfg(any(a, b))]\", expect![[r#\"#![cfg(any(a, b))]\"#]]);\n-\n-        check_dnf(\"#![cfg(not(a))]\", expect![[r#\"#![cfg(not(a))]\"#]]);\n-    }\n-\n-    #[test]\n-    fn distribute() {\n-        check_dnf(\"#![cfg(all(any(a, b), c))]\", expect![[r#\"#![cfg(any(all(a, c), all(b, c)))]\"#]]);\n-        check_dnf(\"#![cfg(all(c, any(a, b)))]\", expect![[r#\"#![cfg(any(all(c, a), all(c, b)))]\"#]]);\n-        check_dnf(\n-            \"#![cfg(all(any(a, b), any(c, d)))]\",\n-            expect![[r#\"#![cfg(any(all(a, c), all(a, d), all(b, c), all(b, d)))]\"#]],\n-        );\n-\n-        check_dnf(\n-            \"#![cfg(all(any(a, b, c), any(d, e, f), g))]\",\n-            expect![[\n-                r#\"#![cfg(any(all(a, d, g), all(a, e, g), all(a, f, g), all(b, d, g), all(b, e, g), all(b, f, g), all(c, d, g), all(c, e, g), all(c, f, g)))]\"#\n-            ]],\n-        );\n-    }\n-\n-    #[test]\n-    fn demorgan() {\n-        check_dnf(\"#![cfg(not(all(a, b)))]\", expect![[r#\"#![cfg(any(not(a), not(b)))]\"#]]);\n-        check_dnf(\"#![cfg(not(any(a, b)))]\", expect![[r#\"#![cfg(all(not(a), not(b)))]\"#]]);\n-\n-        check_dnf(\"#![cfg(not(all(not(a), b)))]\", expect![[r#\"#![cfg(any(a, not(b)))]\"#]]);\n-        check_dnf(\"#![cfg(not(any(a, not(b))))]\", expect![[r#\"#![cfg(all(not(a), b))]\"#]]);\n-    }\n-\n-    #[test]\n-    fn nested() {\n-        check_dnf(\n-            \"#![cfg(all(any(a), not(all(any(b)))))]\",\n-            expect![[r#\"#![cfg(all(a, not(b)))]\"#]],\n-        );\n-\n-        check_dnf(\"#![cfg(any(any(a, b)))]\", expect![[r#\"#![cfg(any(a, b))]\"#]]);\n-        check_dnf(\"#![cfg(not(any(any(a, b))))]\", expect![[r#\"#![cfg(all(not(a), not(b)))]\"#]]);\n-        check_dnf(\"#![cfg(all(all(a, b)))]\", expect![[r#\"#![cfg(all(a, b))]\"#]]);\n-        check_dnf(\"#![cfg(not(all(all(a, b))))]\", expect![[r#\"#![cfg(any(not(a), not(b)))]\"#]]);\n-    }\n-\n-    #[test]\n-    fn hints() {\n-        let mut opts = CfgOptions::default();\n-\n-        check_enable_hints(\"#![cfg(test)]\", &opts, &[\"enable test\"]);\n-        check_enable_hints(\"#![cfg(not(test))]\", &opts, &[]);\n-\n-        check_enable_hints(\"#![cfg(any(a, b))]\", &opts, &[\"enable a\", \"enable b\"]);\n-        check_enable_hints(\"#![cfg(any(b, a))]\", &opts, &[\"enable b\", \"enable a\"]);\n-\n-        check_enable_hints(\"#![cfg(all(a, b))]\", &opts, &[\"enable a and b\"]);\n-\n-        opts.insert_atom(\"test\".into());\n-\n-        check_enable_hints(\"#![cfg(test)]\", &opts, &[]);\n-        check_enable_hints(\"#![cfg(not(test))]\", &opts, &[\"disable test\"]);\n-    }\n-\n-    /// Tests that we don't suggest hints for cfgs that express an inconsistent formula.\n-    #[test]\n-    fn hints_impossible() {\n-        let mut opts = CfgOptions::default();\n-\n-        check_enable_hints(\"#![cfg(all(test, not(test)))]\", &opts, &[]);\n-\n-        opts.insert_atom(\"test\".into());\n-\n-        check_enable_hints(\"#![cfg(all(test, not(test)))]\", &opts, &[]);\n-    }\n-\n-    #[test]\n-    fn why_inactive() {\n-        let mut opts = CfgOptions::default();\n-        opts.insert_atom(\"test\".into());\n-        opts.insert_atom(\"test2\".into());\n-\n-        check_why_inactive(\"#![cfg(a)]\", &opts, expect![[\"a is disabled\"]]);\n-        check_why_inactive(\"#![cfg(not(test))]\", &opts, expect![[\"test is enabled\"]]);\n-\n-        check_why_inactive(\n-            \"#![cfg(all(not(test), not(test2)))]\",\n-            &opts,\n-            expect![[\"test and test2 are enabled\"]],\n-        );\n-        check_why_inactive(\"#![cfg(all(a, b))]\", &opts, expect![[\"a and b are disabled\"]]);\n-        check_why_inactive(\n-            \"#![cfg(all(not(test), a))]\",\n-            &opts,\n-            expect![[\"test is enabled and a is disabled\"]],\n-        );\n-        check_why_inactive(\n-            \"#![cfg(all(not(test), test2, a))]\",\n-            &opts,\n-            expect![[\"test is enabled and a is disabled\"]],\n-        );\n-        check_why_inactive(\n-            \"#![cfg(all(not(test), not(test2), a))]\",\n-            &opts,\n-            expect![[\"test and test2 are enabled and a is disabled\"]],\n-        );\n-    }\n-}"}, {"sha": "d0e08cf5f7741ea63570d52cdd82915813b43826", "filename": "crates/cfg/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a246d4f599dcf2612fa99720fb4ca98101ed93fb/crates%2Fcfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a246d4f599dcf2612fa99720fb4ca98101ed93fb/crates%2Fcfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Flib.rs?ref=a246d4f599dcf2612fa99720fb4ca98101ed93fb", "patch": "@@ -2,6 +2,8 @@\n \n mod cfg_expr;\n mod dnf;\n+#[cfg(test)]\n+mod tests;\n \n use std::fmt;\n "}, {"sha": "bd0f9ec4835df4a1655f4325df585d0eed3b3c67", "filename": "crates/cfg/src/tests.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/a246d4f599dcf2612fa99720fb4ca98101ed93fb/crates%2Fcfg%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a246d4f599dcf2612fa99720fb4ca98101ed93fb/crates%2Fcfg%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Ftests.rs?ref=a246d4f599dcf2612fa99720fb4ca98101ed93fb", "patch": "@@ -0,0 +1,193 @@\n+use expect_test::{expect, Expect};\n+use mbe::ast_to_token_tree;\n+use syntax::{ast, AstNode};\n+\n+use crate::{CfgAtom, CfgExpr, CfgOptions, DnfExpr};\n+\n+fn assert_parse_result(input: &str, expected: CfgExpr) {\n+    let (tt, _) = {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        ast_to_token_tree(&tt).unwrap()\n+    };\n+    let cfg = CfgExpr::parse(&tt);\n+    assert_eq!(cfg, expected);\n+}\n+\n+fn check_dnf(input: &str, expect: Expect) {\n+    let (tt, _) = {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        ast_to_token_tree(&tt).unwrap()\n+    };\n+    let cfg = CfgExpr::parse(&tt);\n+    let actual = format!(\"#![cfg({})]\", DnfExpr::new(cfg));\n+    expect.assert_eq(&actual);\n+}\n+\n+fn check_why_inactive(input: &str, opts: &CfgOptions, expect: Expect) {\n+    let (tt, _) = {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        ast_to_token_tree(&tt).unwrap()\n+    };\n+    let cfg = CfgExpr::parse(&tt);\n+    let dnf = DnfExpr::new(cfg);\n+    let why_inactive = dnf.why_inactive(opts).unwrap().to_string();\n+    expect.assert_eq(&why_inactive);\n+}\n+\n+#[track_caller]\n+fn check_enable_hints(input: &str, opts: &CfgOptions, expected_hints: &[&str]) {\n+    let (tt, _) = {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        ast_to_token_tree(&tt).unwrap()\n+    };\n+    let cfg = CfgExpr::parse(&tt);\n+    let dnf = DnfExpr::new(cfg);\n+    let hints = dnf.compute_enable_hints(opts).map(|diff| diff.to_string()).collect::<Vec<_>>();\n+    assert_eq!(hints, expected_hints);\n+}\n+\n+#[test]\n+fn test_cfg_expr_parser() {\n+    assert_parse_result(\"#![cfg(foo)]\", CfgAtom::Flag(\"foo\".into()).into());\n+    assert_parse_result(\"#![cfg(foo,)]\", CfgAtom::Flag(\"foo\".into()).into());\n+    assert_parse_result(\n+        \"#![cfg(not(foo))]\",\n+        CfgExpr::Not(Box::new(CfgAtom::Flag(\"foo\".into()).into())),\n+    );\n+    assert_parse_result(\"#![cfg(foo(bar))]\", CfgExpr::Invalid);\n+\n+    // Only take the first\n+    assert_parse_result(r#\"#![cfg(foo, bar = \"baz\")]\"#, CfgAtom::Flag(\"foo\".into()).into());\n+\n+    assert_parse_result(\n+        r#\"#![cfg(all(foo, bar = \"baz\"))]\"#,\n+        CfgExpr::All(vec![\n+            CfgAtom::Flag(\"foo\".into()).into(),\n+            CfgAtom::KeyValue { key: \"bar\".into(), value: \"baz\".into() }.into(),\n+        ]),\n+    );\n+\n+    assert_parse_result(\n+        r#\"#![cfg(any(not(), all(), , bar = \"baz\",))]\"#,\n+        CfgExpr::Any(vec![\n+            CfgExpr::Not(Box::new(CfgExpr::Invalid)),\n+            CfgExpr::All(vec![]),\n+            CfgExpr::Invalid,\n+            CfgAtom::KeyValue { key: \"bar\".into(), value: \"baz\".into() }.into(),\n+        ]),\n+    );\n+}\n+\n+#[test]\n+fn smoke() {\n+    check_dnf(\"#![cfg(test)]\", expect![[r#\"#![cfg(test)]\"#]]);\n+    check_dnf(\"#![cfg(not(test))]\", expect![[r#\"#![cfg(not(test))]\"#]]);\n+    check_dnf(\"#![cfg(not(not(test)))]\", expect![[r#\"#![cfg(test)]\"#]]);\n+\n+    check_dnf(\"#![cfg(all(a, b))]\", expect![[r#\"#![cfg(all(a, b))]\"#]]);\n+    check_dnf(\"#![cfg(any(a, b))]\", expect![[r#\"#![cfg(any(a, b))]\"#]]);\n+\n+    check_dnf(\"#![cfg(not(a))]\", expect![[r#\"#![cfg(not(a))]\"#]]);\n+}\n+\n+#[test]\n+fn distribute() {\n+    check_dnf(\"#![cfg(all(any(a, b), c))]\", expect![[r#\"#![cfg(any(all(a, c), all(b, c)))]\"#]]);\n+    check_dnf(\"#![cfg(all(c, any(a, b)))]\", expect![[r#\"#![cfg(any(all(c, a), all(c, b)))]\"#]]);\n+    check_dnf(\n+        \"#![cfg(all(any(a, b), any(c, d)))]\",\n+        expect![[r#\"#![cfg(any(all(a, c), all(a, d), all(b, c), all(b, d)))]\"#]],\n+    );\n+\n+    check_dnf(\n+        \"#![cfg(all(any(a, b, c), any(d, e, f), g))]\",\n+        expect![[\n+            r#\"#![cfg(any(all(a, d, g), all(a, e, g), all(a, f, g), all(b, d, g), all(b, e, g), all(b, f, g), all(c, d, g), all(c, e, g), all(c, f, g)))]\"#\n+        ]],\n+    );\n+}\n+\n+#[test]\n+fn demorgan() {\n+    check_dnf(\"#![cfg(not(all(a, b)))]\", expect![[r#\"#![cfg(any(not(a), not(b)))]\"#]]);\n+    check_dnf(\"#![cfg(not(any(a, b)))]\", expect![[r#\"#![cfg(all(not(a), not(b)))]\"#]]);\n+\n+    check_dnf(\"#![cfg(not(all(not(a), b)))]\", expect![[r#\"#![cfg(any(a, not(b)))]\"#]]);\n+    check_dnf(\"#![cfg(not(any(a, not(b))))]\", expect![[r#\"#![cfg(all(not(a), b))]\"#]]);\n+}\n+\n+#[test]\n+fn nested() {\n+    check_dnf(\"#![cfg(all(any(a), not(all(any(b)))))]\", expect![[r#\"#![cfg(all(a, not(b)))]\"#]]);\n+\n+    check_dnf(\"#![cfg(any(any(a, b)))]\", expect![[r#\"#![cfg(any(a, b))]\"#]]);\n+    check_dnf(\"#![cfg(not(any(any(a, b))))]\", expect![[r#\"#![cfg(all(not(a), not(b)))]\"#]]);\n+    check_dnf(\"#![cfg(all(all(a, b)))]\", expect![[r#\"#![cfg(all(a, b))]\"#]]);\n+    check_dnf(\"#![cfg(not(all(all(a, b))))]\", expect![[r#\"#![cfg(any(not(a), not(b)))]\"#]]);\n+}\n+\n+#[test]\n+fn hints() {\n+    let mut opts = CfgOptions::default();\n+\n+    check_enable_hints(\"#![cfg(test)]\", &opts, &[\"enable test\"]);\n+    check_enable_hints(\"#![cfg(not(test))]\", &opts, &[]);\n+\n+    check_enable_hints(\"#![cfg(any(a, b))]\", &opts, &[\"enable a\", \"enable b\"]);\n+    check_enable_hints(\"#![cfg(any(b, a))]\", &opts, &[\"enable b\", \"enable a\"]);\n+\n+    check_enable_hints(\"#![cfg(all(a, b))]\", &opts, &[\"enable a and b\"]);\n+\n+    opts.insert_atom(\"test\".into());\n+\n+    check_enable_hints(\"#![cfg(test)]\", &opts, &[]);\n+    check_enable_hints(\"#![cfg(not(test))]\", &opts, &[\"disable test\"]);\n+}\n+\n+/// Tests that we don't suggest hints for cfgs that express an inconsistent formula.\n+#[test]\n+fn hints_impossible() {\n+    let mut opts = CfgOptions::default();\n+\n+    check_enable_hints(\"#![cfg(all(test, not(test)))]\", &opts, &[]);\n+\n+    opts.insert_atom(\"test\".into());\n+\n+    check_enable_hints(\"#![cfg(all(test, not(test)))]\", &opts, &[]);\n+}\n+\n+#[test]\n+fn why_inactive() {\n+    let mut opts = CfgOptions::default();\n+    opts.insert_atom(\"test\".into());\n+    opts.insert_atom(\"test2\".into());\n+\n+    check_why_inactive(\"#![cfg(a)]\", &opts, expect![[\"a is disabled\"]]);\n+    check_why_inactive(\"#![cfg(not(test))]\", &opts, expect![[\"test is enabled\"]]);\n+\n+    check_why_inactive(\n+        \"#![cfg(all(not(test), not(test2)))]\",\n+        &opts,\n+        expect![[\"test and test2 are enabled\"]],\n+    );\n+    check_why_inactive(\"#![cfg(all(a, b))]\", &opts, expect![[\"a and b are disabled\"]]);\n+    check_why_inactive(\n+        \"#![cfg(all(not(test), a))]\",\n+        &opts,\n+        expect![[\"test is enabled and a is disabled\"]],\n+    );\n+    check_why_inactive(\n+        \"#![cfg(all(not(test), test2, a))]\",\n+        &opts,\n+        expect![[\"test is enabled and a is disabled\"]],\n+    );\n+    check_why_inactive(\n+        \"#![cfg(all(not(test), not(test2), a))]\",\n+        &opts,\n+        expect![[\"test and test2 are enabled and a is disabled\"]],\n+    );\n+}"}]}