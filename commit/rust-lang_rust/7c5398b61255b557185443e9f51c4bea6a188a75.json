{"sha": "7c5398b61255b557185443e9f51c4bea6a188a75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNTM5OGI2MTI1NWI1NTcxODU0NDNlOWY1MWM0YmVhNmExODhhNzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-01T14:00:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-01T14:00:44Z"}, "message": "auto merge of #8276 : kballard/rust/iterator-protocol, r=cmr\n\nr? @thestinger", "tree": {"sha": "0fec57018c36098d9c708e1e46f16f32a590c01b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fec57018c36098d9c708e1e46f16f32a590c01b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c5398b61255b557185443e9f51c4bea6a188a75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c5398b61255b557185443e9f51c4bea6a188a75", "html_url": "https://github.com/rust-lang/rust/commit/7c5398b61255b557185443e9f51c4bea6a188a75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c5398b61255b557185443e9f51c4bea6a188a75/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66593a733d763e01e6765c7a52476c7693eb211a", "url": "https://api.github.com/repos/rust-lang/rust/commits/66593a733d763e01e6765c7a52476c7693eb211a", "html_url": "https://github.com/rust-lang/rust/commit/66593a733d763e01e6765c7a52476c7693eb211a"}, {"sha": "a3d18bc95b1639cf3cb967165f7104e2c79893f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3d18bc95b1639cf3cb967165f7104e2c79893f5", "html_url": "https://github.com/rust-lang/rust/commit/a3d18bc95b1639cf3cb967165f7104e2c79893f5"}], "stats": {"total": 165, "additions": 157, "deletions": 8}, "files": [{"sha": "7851e9852c115893a6f4cdba9c33f9c1501ab9b3", "filename": "doc/tutorial-container.md", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7c5398b61255b557185443e9f51c4bea6a188a75/doc%2Ftutorial-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/7c5398b61255b557185443e9f51c4bea6a188a75/doc%2Ftutorial-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-container.md?ref=7c5398b61255b557185443e9f51c4bea6a188a75", "patch": "@@ -105,14 +105,18 @@ impl Iterator<int> for ZeroStream {\n }\n ~~~\n \n+In general, you cannot rely on the behavior of the `next()` method after it has\n+returned `None`. Some iterators may return `None` forever. Others may behave\n+differently.\n+\n ## Container iterators\n \n Containers implement iteration over the contained elements by returning an\n iterator object. For example, vector slices several iterators available:\n \n * `iter()` and `rev_iter()`, for immutable references to the elements\n * `mut_iter()` and `mut_rev_iter()`, for mutable references to the elements\n-* `move_iter()` and `move_rev_iter`, to move the elements out by-value\n+* `move_iter()` and `move_rev_iter()`, to move the elements out by-value\n \n A typical mutable container will implement at least `iter()`, `mut_iter()` and\n `move_iter()` along with the reverse variants if it maintains an order.\n@@ -149,7 +153,7 @@ let result = xs.iter().fold(0, |accumulator, item| accumulator - *item);\n assert_eq!(result, -41);\n ~~~\n \n-Some adaptors return an adaptor object implementing the `Iterator` trait itself:\n+Most adaptors return an adaptor object implementing the `Iterator` trait itself:\n \n ~~~\n let xs = [1, 9, 2, 3, 14, 12];\n@@ -158,6 +162,35 @@ let sum = xs.iter().chain(ys.iter()).fold(0, |a, b| a + *b);\n assert_eq!(sum, 57);\n ~~~\n \n+Some iterator adaptors may return `None` before exhausting the underlying\n+iterator. Additionally, if these iterator adaptors are called again after\n+returning `None`, they may call their underlying iterator again even if the\n+adaptor will continue to return `None` forever. This may not be desired if the\n+underlying iterator has side-effects.\n+\n+In order to provide a guarantee about behavior once `None` has been returned, an\n+iterator adaptor named `fuse()` is provided. This returns an iterator that will\n+never call its underlying iterator again once `None` has been returned:\n+\n+~~~\n+let xs = [1,2,3,4,5];\n+let mut calls = 0;\n+let it = xs.iter().scan((), |_, x| {\n+    calls += 1;\n+    if *x < 3 { Some(x) } else { None }});\n+// the iterator will only yield 1 and 2 before returning None\n+// If we were to call it 5 times, calls would end up as 5, despite only 2 values\n+// being yielded (and therefore 3 unique calls being made). The fuse() adaptor\n+// can fix this.\n+let mut it = it.fuse();\n+it.next();\n+it.next();\n+it.next();\n+it.next();\n+it.next();\n+assert_eq!(calls, 3);\n+~~~\n+\n ## For loops\n \n The function `range` (or `range_inclusive`) allows to simply iterate through a given range:"}, {"sha": "3b4c31349c9c27881b83dff4e85dd861102ef175", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 122, "deletions": 6, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/7c5398b61255b557185443e9f51c4bea6a188a75/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c5398b61255b557185443e9f51c4bea6a188a75/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=7c5398b61255b557185443e9f51c4bea6a188a75", "patch": "@@ -41,6 +41,13 @@ pub trait Extendable<A>: FromIterator<A> {\n /// An interface for dealing with \"external iterators\". These types of iterators\n /// can be resumed at any time as all state is stored internally as opposed to\n /// being located on the call stack.\n+///\n+/// The Iterator protocol states that an iterator yields a (potentially-empty,\n+/// potentially-infinite) sequence of values, and returns `None` to signal that\n+/// it's finished. The Iterator protocol does not define behavior after `None`\n+/// is returned. A concrete Iterator implementation may choose to behave however\n+/// it wishes, either by returning `None` infinitely, or by doing something\n+/// else.\n pub trait Iterator<A> {\n     /// Advance the iterator and return the next value. Return `None` when the end is reached.\n     fn next(&mut self) -> Option<A>;\n@@ -300,6 +307,36 @@ pub trait Iterator<A> {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n \n+    /// Creates an iterator that yields `None` forever after the underlying\n+    /// iterator yields `None`. Random-access iterator behavior is not\n+    /// affected, only single and double-ended iterator behavior.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// fn process<U: Iterator<int>>(it: U) -> int {\n+    ///     let mut it = it.fuse();\n+    ///     let mut sum = 0;\n+    ///     for x in it {\n+    ///         if x > 5 {\n+    ///             break;\n+    ///         }\n+    ///         sum += x;\n+    ///     }\n+    ///     // did we exhaust the iterator?\n+    ///     if it.next().is_none() {\n+    ///         sum += 1000;\n+    ///     }\n+    ///     sum\n+    /// }\n+    /// let x = ~[1,2,3,7,8,9];\n+    /// assert_eq!(process(x.move_iter()), 1006);\n+    /// ~~~\n+    #[inline]\n+    fn fuse(self) -> Fuse<Self> {\n+        Fuse{iter: self, done: false}\n+    }\n+\n     /// Creates an iterator that calls a function with a reference to each\n     /// element before yielding it. This is often useful for debugging an\n     /// iterator pipeline.\n@@ -892,9 +929,12 @@ pub struct Zip<T, U> {\n impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for Zip<T, U> {\n     #[inline]\n     fn next(&mut self) -> Option<(A, B)> {\n-        match (self.a.next(), self.b.next()) {\n-            (Some(x), Some(y)) => Some((x, y)),\n-            _ => None\n+        match self.a.next() {\n+            None => None,\n+            Some(x) => match self.b.next() {\n+                None => None,\n+                Some(y) => Some((x, y))\n+            }\n         }\n     }\n \n@@ -925,9 +965,12 @@ RandomAccessIterator<(A, B)> for Zip<T, U> {\n \n     #[inline]\n     fn idx(&self, index: uint) -> Option<(A, B)> {\n-        match (self.a.idx(index), self.b.idx(index)) {\n-            (Some(x), Some(y)) => Some((x, y)),\n-            _ => None\n+        match self.a.idx(index) {\n+            None => None,\n+            Some(x) => match self.b.idx(index) {\n+                None => None,\n+                Some(y) => Some((x, y))\n+            }\n         }\n     }\n }\n@@ -1421,6 +1464,79 @@ impl<'self,\n     }\n }\n \n+/// An iterator that yields `None` forever after the underlying iterator\n+/// yields `None` once.\n+#[deriving(Clone, DeepClone)]\n+pub struct Fuse<T> {\n+    priv iter: T,\n+    priv done: bool\n+}\n+\n+impl<A, T: Iterator<A>> Iterator<A> for Fuse<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        if self.done {\n+            None\n+        } else {\n+            match self.iter.next() {\n+                None => {\n+                    self.done = true;\n+                    None\n+                }\n+                x => x\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.done {\n+            (0, Some(0))\n+        } else {\n+            self.iter.size_hint()\n+        }\n+    }\n+}\n+\n+impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Fuse<T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        if self.done {\n+            None\n+        } else {\n+            match self.iter.next_back() {\n+                None => {\n+                    self.done = true;\n+                    None\n+                }\n+                x => x\n+            }\n+        }\n+    }\n+}\n+\n+// Allow RandomAccessIterators to be fused without affecting random-access behavior\n+impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Fuse<T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.iter.indexable()\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<A> {\n+        self.iter.idx(index)\n+    }\n+}\n+\n+impl<T> Fuse<T> {\n+    /// Resets the fuse such that the next call to .next() or .next_back() will\n+    /// call the underlying iterator again even if it prevously returned None.\n+    #[inline]\n+    fn reset_fuse(&mut self) {\n+        self.done = false\n+    }\n+}\n+\n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n pub struct Inspect<'self, A, T> {"}]}