{"sha": "0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNWZkOGY3Y2JmMDRlZGE3NjNlNTViYzlhMzhkYWQ1ZjdlYzkxN2Q=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-03T18:26:35Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-06T14:00:00Z"}, "message": "move assists to a separate crate", "tree": {"sha": "4af15c8906b85de01a15c717bc1fac388952cd3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4af15c8906b85de01a15c717bc1fac388952cd3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "html_url": "https://github.com/rust-lang/rust/commit/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9", "html_url": "https://github.com/rust-lang/rust/commit/736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9"}], "stats": {"total": 1162, "additions": 582, "deletions": 580}, "files": [{"sha": "15cd4386c592ec08ace160b5df028ea3c46f6312", "filename": "Cargo.lock", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -912,6 +912,19 @@ dependencies = [\n name = \"ra_arena\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"ra_assists\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_db 0.1.0\",\n+ \"ra_hir 0.1.0\",\n+ \"ra_ide_api_light 0.1.0\",\n+ \"ra_syntax 0.1.0\",\n+ \"ra_text_edit 0.1.0\",\n+ \"test_utils 0.1.0\",\n+]\n+\n [[package]]\n name = \"ra_cli\"\n version = \"0.1.0\"\n@@ -970,6 +983,7 @@ dependencies = [\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_assists 0.1.0\",\n  \"ra_db 0.1.0\",\n  \"ra_hir 0.1.0\",\n  \"ra_ide_api_light 0.1.0\","}, {"sha": "20bc253e30b759302103e6af75827d86e38d5142", "filename": "crates/ra_assists/Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2FCargo.toml?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -0,0 +1,17 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_assists\"\n+version = \"0.1.0\"\n+authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n+\n+[dependencies]\n+join_to_string = \"0.1.3\"\n+\n+ra_ide_api_light = { path = \"../ra_ide_api_light\" }\n+ra_syntax = { path = \"../ra_syntax\" }\n+ra_text_edit = { path = \"../ra_text_edit\" }\n+ra_db = { path = \"../ra_db\" }\n+hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n+\n+[dev-dependencies]\n+test_utils = { path = \"../test_utils\" }"}, {"sha": "01a4079f68b1d292e14492f21b04463d77f3962c", "filename": "crates/ra_assists/src/add_derive.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_derive.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -1,12 +1,13 @@\n+use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner},\n     SyntaxKind::{WHITESPACE, COMMENT},\n     TextUnit,\n };\n \n-use crate::assists::{AssistCtx, Assist};\n+use crate::{AssistCtx, Assist};\n \n-pub fn add_derive(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_derive(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let nominal = ctx.node_at_offset::<ast::NominalDef>()?;\n     let node_start = derive_insertion_offset(nominal)?;\n     ctx.build(\"add `#[derive]`\", |edit| {\n@@ -39,7 +40,7 @@ fn derive_insertion_offset(nominal: &ast::NominalDef) -> Option<TextUnit> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::assists::check_assist;\n+    use crate::helpers::check_assist;\n \n     #[test]\n     fn add_derive_new() {", "previous_filename": "crates/ra_ide_api_light/src/assists/add_derive.rs"}, {"sha": "699508f9151298fc84747c8c0272fbac02250c13", "filename": "crates/ra_assists/src/add_impl.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_impl.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -1,12 +1,13 @@\n use join_to_string::join;\n+use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, AstNode, AstToken, NameOwner, TypeParamsOwner},\n     TextUnit,\n };\n \n-use crate::assists::{AssistCtx, Assist};\n+use crate::{AssistCtx, Assist};\n \n-pub fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn add_impl(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let nominal = ctx.node_at_offset::<ast::NominalDef>()?;\n     let name = nominal.name()?;\n     ctx.build(\"add impl\", |edit| {\n@@ -42,7 +43,7 @@ pub fn add_impl(ctx: AssistCtx) -> Option<Assist> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::assists::check_assist;\n+    use crate::helpers::check_assist;\n \n     #[test]\n     fn test_add_impl() {", "previous_filename": "crates/ra_ide_api_light/src/assists/add_impl.rs"}, {"sha": "6d09bde52af5d58426975b13cc5d9a86316e7392", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -0,0 +1,154 @@\n+use hir::db::HirDatabase;\n+use ra_text_edit::TextEditBuilder;\n+use ra_db::FileRange;\n+use ra_syntax::{\n+    SourceFile, TextRange, AstNode, TextUnit, SyntaxNode,\n+    algo::{find_leaf_at_offset, find_node_at_offset, find_covering_node, LeafAtOffset},\n+};\n+use ra_ide_api_light::formatting::{leading_indent, reindent};\n+\n+use crate::{AssistLabel, AssistAction};\n+\n+pub(crate) enum Assist {\n+    Unresolved(AssistLabel),\n+    Resolved(AssistLabel, AssistAction),\n+}\n+\n+/// `AssistCtx` allows to apply an assist or check if it could be applied.\n+///\n+/// Assists use a somewhat overengineered approach, given the current needs. The\n+/// assists workflow consists of two phases. In the first phase, a user asks for\n+/// the list of available assists. In the second phase, the user picks a\n+/// particular assist and it gets applied.\n+///\n+/// There are two peculiarities here:\n+///\n+/// * first, we ideally avoid computing more things then necessary to answer\n+///   \"is assist applicable\" in the first phase.\n+/// * second, when we are applying assist, we don't have a guarantee that there\n+///   weren't any changes between the point when user asked for assists and when\n+///   they applied a particular assist. So, when applying assist, we need to do\n+///   all the checks from scratch.\n+///\n+/// To avoid repeating the same code twice for both \"check\" and \"apply\"\n+/// functions, we use an approach reminiscent of that of Django's function based\n+/// views dealing with forms. Each assist receives a runtime parameter,\n+/// `should_compute_edit`. It first check if an edit is applicable (potentially\n+/// computing info required to compute the actual edit). If it is applicable,\n+/// and `should_compute_edit` is `true`, it then computes the actual edit.\n+///\n+/// So, to implement the original assists workflow, we can first apply each edit\n+/// with `should_compute_edit = false`, and then applying the selected edit\n+/// again, with `should_compute_edit = true` this time.\n+///\n+/// Note, however, that we don't actually use such two-phase logic at the\n+/// moment, because the LSP API is pretty awkward in this place, and it's much\n+/// easier to just compute the edit eagerly :-)#[derive(Debug, Clone)]\n+#[derive(Debug)]\n+pub(crate) struct AssistCtx<'a, DB> {\n+    pub(crate) db: &'a DB,\n+    pub(crate) frange: FileRange,\n+    source_file: &'a SourceFile,\n+    should_compute_edit: bool,\n+}\n+\n+impl<'a, DB> Clone for AssistCtx<'a, DB> {\n+    fn clone(&self) -> Self {\n+        AssistCtx {\n+            db: self.db,\n+            frange: self.frange,\n+            source_file: self.source_file,\n+            should_compute_edit: self.should_compute_edit,\n+        }\n+    }\n+}\n+\n+impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n+    pub(crate) fn with_ctx<F, T>(db: &DB, frange: FileRange, should_compute_edit: bool, f: F) -> T\n+    where\n+        F: FnOnce(AssistCtx<DB>) -> T,\n+    {\n+        let source_file = &db.parse(frange.file_id);\n+        let ctx = AssistCtx {\n+            db,\n+            frange,\n+            source_file,\n+            should_compute_edit,\n+        };\n+        f(ctx)\n+    }\n+\n+    pub(crate) fn build(\n+        self,\n+        label: impl Into<String>,\n+        f: impl FnOnce(&mut AssistBuilder),\n+    ) -> Option<Assist> {\n+        let label = AssistLabel {\n+            label: label.into(),\n+        };\n+        if !self.should_compute_edit {\n+            return Some(Assist::Unresolved(label));\n+        }\n+        let action = {\n+            let mut edit = AssistBuilder::default();\n+            f(&mut edit);\n+            edit.build()\n+        };\n+        Some(Assist::Resolved(label, action))\n+    }\n+\n+    pub(crate) fn leaf_at_offset(&self) -> LeafAtOffset<&'a SyntaxNode> {\n+        find_leaf_at_offset(self.source_file.syntax(), self.frange.range.start())\n+    }\n+\n+    pub(crate) fn node_at_offset<N: AstNode>(&self) -> Option<&'a N> {\n+        find_node_at_offset(self.source_file.syntax(), self.frange.range.start())\n+    }\n+    pub(crate) fn covering_node(&self) -> &'a SyntaxNode {\n+        find_covering_node(self.source_file.syntax(), self.frange.range)\n+    }\n+}\n+\n+#[derive(Default)]\n+pub(crate) struct AssistBuilder {\n+    edit: TextEditBuilder,\n+    cursor_position: Option<TextUnit>,\n+}\n+\n+impl AssistBuilder {\n+    pub(crate) fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {\n+        self.edit.replace(range, replace_with.into())\n+    }\n+\n+    pub(crate) fn replace_node_and_indent(\n+        &mut self,\n+        node: &SyntaxNode,\n+        replace_with: impl Into<String>,\n+    ) {\n+        let mut replace_with = replace_with.into();\n+        if let Some(indent) = leading_indent(node) {\n+            replace_with = reindent(&replace_with, indent)\n+        }\n+        self.replace(node.range(), replace_with)\n+    }\n+\n+    #[allow(unused)]\n+    pub(crate) fn delete(&mut self, range: TextRange) {\n+        self.edit.delete(range)\n+    }\n+\n+    pub(crate) fn insert(&mut self, offset: TextUnit, text: impl Into<String>) {\n+        self.edit.insert(offset, text.into())\n+    }\n+\n+    pub(crate) fn set_cursor(&mut self, offset: TextUnit) {\n+        self.cursor_position = Some(offset)\n+    }\n+\n+    fn build(self) -> AssistAction {\n+        AssistAction {\n+            edit: self.edit.finish(),\n+            cursor_position: self.cursor_position,\n+        }\n+    }\n+}"}, {"sha": "4cd32985e095fdc6d516152bdb0a6faa6d545af9", "filename": "crates/ra_assists/src/change_visibility.rs", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -1,19 +1,20 @@\n+use hir::db::HirDatabase;\n use ra_syntax::{\n     AstNode, SyntaxNode, TextUnit,\n     ast::{self, VisibilityOwner, NameOwner},\n     SyntaxKind::{VISIBILITY, FN_KW, MOD_KW, STRUCT_KW, ENUM_KW, TRAIT_KW, FN_DEF, MODULE, STRUCT_DEF, ENUM_DEF, TRAIT_DEF, IDENT, WHITESPACE, COMMENT, ATTR},\n };\n \n-use crate::assists::{AssistCtx, Assist};\n+use crate::{AssistCtx, Assist};\n \n-pub fn change_visibility(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn change_visibility(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     if let Some(vis) = ctx.node_at_offset::<ast::Visibility>() {\n         return change_vis(ctx, vis);\n     }\n     add_vis(ctx)\n }\n \n-fn add_vis(ctx: AssistCtx) -> Option<Assist> {\n+fn add_vis(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let item_keyword = ctx.leaf_at_offset().find(|leaf| match leaf.kind() {\n         FN_KW | MOD_KW | STRUCT_KW | ENUM_KW | TRAIT_KW => true,\n         _ => false,\n@@ -57,7 +58,7 @@ fn vis_offset(node: &SyntaxNode) -> TextUnit {\n         .unwrap_or(node.range().start())\n }\n \n-fn change_vis(ctx: AssistCtx, vis: &ast::Visibility) -> Option<Assist> {\n+fn change_vis(ctx: AssistCtx<impl HirDatabase>, vis: &ast::Visibility) -> Option<Assist> {\n     if vis.syntax().text() == \"pub\" {\n         return ctx.build(\"chage to pub(crate)\", |edit| {\n             edit.replace(vis.syntax().range(), \"pub(crate)\");\n@@ -76,7 +77,7 @@ fn change_vis(ctx: AssistCtx, vis: &ast::Visibility) -> Option<Assist> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::assists::check_assist;\n+    use crate::helpers::check_assist;\n \n     #[test]\n     fn change_visibility_adds_pub_crate_to_items() {", "previous_filename": "crates/ra_ide_api_light/src/assists/change_visibility.rs"}, {"sha": "9aa37d94cdbbbf2fa29c2fa2d6538e99a05d1732", "filename": "crates/ra_assists/src/fill_match_arms.rs", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_match_arms.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -0,0 +1,145 @@\n+use std::fmt::Write;\n+\n+use hir::{\n+    AdtDef, Ty, FieldSource, source_binder,\n+    db::HirDatabase,\n+};\n+use ra_syntax::ast::{self, AstNode};\n+\n+use crate::{AssistCtx, Assist};\n+\n+pub(crate) fn fill_match_arms(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let match_expr = ctx.node_at_offset::<ast::MatchExpr>()?;\n+\n+    // We already have some match arms, so we don't provide any assists.\n+    match match_expr.match_arm_list() {\n+        Some(arm_list) if arm_list.arms().count() > 0 => {\n+            return None;\n+        }\n+        _ => {}\n+    }\n+\n+    let expr = match_expr.expr()?;\n+    let function =\n+        source_binder::function_from_child_node(ctx.db, ctx.frange.file_id, expr.syntax())?;\n+    let infer_result = function.infer(ctx.db);\n+    let syntax_mapping = function.body_syntax_mapping(ctx.db);\n+    let node_expr = syntax_mapping.node_expr(expr)?;\n+    let match_expr_ty = infer_result[node_expr].clone();\n+    let enum_def = match match_expr_ty {\n+        Ty::Adt {\n+            def_id: AdtDef::Enum(e),\n+            ..\n+        } => e,\n+        _ => return None,\n+    };\n+    let enum_name = enum_def.name(ctx.db)?;\n+    let db = ctx.db;\n+\n+    ctx.build(\"fill match arms\", |edit| {\n+        let mut buf = format!(\"match {} {{\\n\", expr.syntax().text().to_string());\n+        let variants = enum_def.variants(db);\n+        for variant in variants {\n+            let name = match variant.name(db) {\n+                Some(it) => it,\n+                None => continue,\n+            };\n+            write!(&mut buf, \"    {}::{}\", enum_name, name.to_string()).unwrap();\n+\n+            let pat = variant\n+                .fields(db)\n+                .into_iter()\n+                .map(|field| {\n+                    let name = field.name(db).to_string();\n+                    let (_, source) = field.source(db);\n+                    match source {\n+                        FieldSource::Named(_) => name,\n+                        FieldSource::Pos(_) => \"_\".to_string(),\n+                    }\n+                })\n+                .collect::<Vec<_>>();\n+\n+            match pat.first().map(|s| s.as_str()) {\n+                Some(\"_\") => write!(&mut buf, \"({})\", pat.join(\", \")).unwrap(),\n+                Some(_) => write!(&mut buf, \"{{{}}}\", pat.join(\", \")).unwrap(),\n+                None => (),\n+            };\n+\n+            buf.push_str(\" => (),\\n\");\n+        }\n+        buf.push_str(\"}\");\n+        edit.set_cursor(expr.syntax().range().start());\n+        edit.replace_node_and_indent(match_expr.syntax(), buf);\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::helpers::check_assist;\n+\n+    use super::fill_match_arms;\n+\n+    #[test]\n+    fn fill_match_arms_empty_body() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs,\n+                Cs(String),\n+                Ds(String, String),\n+                Es{x: usize, y: usize}\n+            }\n+\n+            fn main() {\n+                let a = A::As;\n+                match a<|> {}\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs,\n+                Cs(String),\n+                Ds(String, String),\n+                Es{x: usize, y: usize}\n+            }\n+\n+            fn main() {\n+                let a = A::As;\n+                match <|>a {\n+                    A::As => (),\n+                    A::Bs => (),\n+                    A::Cs(_) => (),\n+                    A::Ds(_, _) => (),\n+                    A::Es{x, y} => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+    #[test]\n+    fn fill_match_arms_no_body() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum E { X, Y}\n+\n+            fn main() {\n+                match E::X<|>\n+            }\n+            \"#,\n+            r#\"\n+            enum E { X, Y}\n+\n+            fn main() {\n+                match <|>E::X {\n+                    E::X => (),\n+                    E::Y => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+}"}, {"sha": "a49820c2957df9c6729768e7eace0fc902d89e18", "filename": "crates/ra_assists/src/flip_comma.rs", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -1,11 +1,12 @@\n+use hir::db::HirDatabase;\n use ra_syntax::{\n     Direction,\n     SyntaxKind::COMMA,\n };\n \n-use crate::assists::{non_trivia_sibling, AssistCtx, Assist};\n+use crate::{AssistCtx, Assist, non_trivia_sibling};\n \n-pub fn flip_comma(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn flip_comma(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let comma = ctx.leaf_at_offset().find(|leaf| leaf.kind() == COMMA)?;\n     let prev = non_trivia_sibling(comma, Direction::Prev)?;\n     let next = non_trivia_sibling(comma, Direction::Next)?;\n@@ -18,7 +19,8 @@ pub fn flip_comma(ctx: AssistCtx) -> Option<Assist> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::assists::check_assist;\n+\n+    use crate::helpers::check_assist;\n \n     #[test]\n     fn flip_comma_works_for_function_parameters() {", "previous_filename": "crates/ra_ide_api_light/src/assists/flip_comma.rs"}, {"sha": "c937a816cdaecd2c25c95c43bc59c8009bc30ecd", "filename": "crates/ra_assists/src/introduce_variable.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fintroduce_variable.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -1,13 +1,14 @@\n+use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, AstNode},\n     SyntaxKind::{\n         WHITESPACE, MATCH_ARM, LAMBDA_EXPR, PATH_EXPR, BREAK_EXPR, LOOP_EXPR, RETURN_EXPR, COMMENT\n     }, SyntaxNode, TextUnit,\n };\n \n-use crate::assists::{AssistCtx, Assist};\n+use crate::{AssistCtx, Assist};\n \n-pub fn introduce_variable<'a>(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn introduce_variable<'a>(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let node = ctx.covering_node();\n     if !valid_covering_node(node) {\n         return None;\n@@ -103,7 +104,7 @@ fn anchor_stmt(expr: &ast::Expr) -> Option<(&SyntaxNode, bool)> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::assists::{ check_assist, check_assist_not_applicable, check_assist_range };\n+    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_range};\n \n     #[test]\n     fn test_introduce_var_simple() {", "previous_filename": "crates/ra_ide_api_light/src/assists/introduce_variable.rs"}, {"sha": "4e97a84c20dd3041313a4a8d1332025487226871", "filename": "crates/ra_assists/src/lib.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -0,0 +1,170 @@\n+//! `ra_assits` crate provides a bunch of code assists, aslo known as code\n+//! actions (in LSP) or intentions (in IntelliJ).\n+//!\n+//! An assist is a micro-refactoring, which is automatically activated in\n+//! certain context. For example, if the cursor is over `,`, a \"swap `,`\" assist\n+//! becomes available.\n+\n+mod assist_ctx;\n+\n+use ra_text_edit::TextEdit;\n+use ra_syntax::{TextUnit, SyntaxNode, Direction};\n+use ra_db::FileRange;\n+use hir::db::HirDatabase;\n+\n+pub(crate) use crate::assist_ctx::{AssistCtx, Assist};\n+\n+#[derive(Debug)]\n+pub struct AssistLabel {\n+    /// Short description of the assist, as shown in the UI.\n+    pub label: String,\n+}\n+\n+pub struct AssistAction {\n+    pub edit: TextEdit,\n+    pub cursor_position: Option<TextUnit>,\n+}\n+\n+/// Return all the assists applicable at the given position.\n+///\n+/// Assists are returned in the \"unresolved\" state, that is only labels are\n+/// returned, without actual edits.\n+pub fn applicable_assists<H>(db: &H, range: FileRange) -> Vec<AssistLabel>\n+where\n+    H: HirDatabase + 'static,\n+{\n+    AssistCtx::with_ctx(db, range, false, |ctx| {\n+        all_assists()\n+            .iter()\n+            .filter_map(|f| f(ctx.clone()))\n+            .map(|a| match a {\n+                Assist::Unresolved(label) => label,\n+                Assist::Resolved(..) => unreachable!(),\n+            })\n+            .collect()\n+    })\n+}\n+\n+/// Return all the assists applicable at the given position.\n+///\n+/// Assists are returned in the \"resolved\" state, that is with edit fully\n+/// computed.\n+pub fn assists<H>(db: &H, range: FileRange) -> Vec<(AssistLabel, AssistAction)>\n+where\n+    H: HirDatabase + 'static,\n+{\n+    AssistCtx::with_ctx(db, range, false, |ctx| {\n+        all_assists()\n+            .iter()\n+            .filter_map(|f| f(ctx.clone()))\n+            .map(|a| match a {\n+                Assist::Resolved(label, action) => (label, action),\n+                Assist::Unresolved(..) => unreachable!(),\n+            })\n+            .collect()\n+    })\n+}\n+\n+mod add_derive;\n+mod add_impl;\n+mod flip_comma;\n+mod change_visibility;\n+mod fill_match_arms;\n+mod introduce_variable;\n+mod replace_if_let_with_match;\n+mod split_import;\n+fn all_assists<DB: HirDatabase>() -> &'static [fn(AssistCtx<DB>) -> Option<Assist>] {\n+    &[\n+        add_derive::add_derive,\n+        add_impl::add_impl,\n+        change_visibility::change_visibility,\n+        fill_match_arms::fill_match_arms,\n+        flip_comma::flip_comma,\n+        introduce_variable::introduce_variable,\n+        replace_if_let_with_match::replace_if_let_with_match,\n+        split_import::split_import,\n+    ]\n+}\n+\n+fn non_trivia_sibling(node: &SyntaxNode, direction: Direction) -> Option<&SyntaxNode> {\n+    node.siblings(direction)\n+        .skip(1)\n+        .find(|node| !node.kind().is_trivia())\n+}\n+\n+#[cfg(test)]\n+mod helpers {\n+    use hir::mock::MockDatabase;\n+    use ra_syntax::TextRange;\n+    use ra_db::FileRange;\n+    use test_utils::{extract_offset, assert_eq_text, add_cursor, extract_range};\n+\n+    use crate::{AssistCtx, Assist};\n+\n+    pub(crate) fn check_assist(\n+        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        before: &str,\n+        after: &str,\n+    ) {\n+        let (before_cursor_pos, before) = extract_offset(before);\n+        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let frange = FileRange {\n+            file_id,\n+            range: TextRange::offset_len(before_cursor_pos, 0.into()),\n+        };\n+        let assist =\n+            AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n+        let action = match assist {\n+            Assist::Unresolved(_) => unreachable!(),\n+            Assist::Resolved(_, it) => it,\n+        };\n+\n+        let actual = action.edit.apply(&before);\n+        let actual_cursor_pos = match action.cursor_position {\n+            None => action\n+                .edit\n+                .apply_to_offset(before_cursor_pos)\n+                .expect(\"cursor position is affected by the edit\"),\n+            Some(off) => off,\n+        };\n+        let actual = add_cursor(&actual, actual_cursor_pos);\n+        assert_eq_text!(after, &actual);\n+    }\n+\n+    pub(crate) fn check_assist_range(\n+        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        before: &str,\n+        after: &str,\n+    ) {\n+        let (range, before) = extract_range(before);\n+        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let frange = FileRange { file_id, range };\n+        let assist =\n+            AssistCtx::with_ctx(&db, frange, true, assist).expect(\"code action is not applicable\");\n+        let action = match assist {\n+            Assist::Unresolved(_) => unreachable!(),\n+            Assist::Resolved(_, it) => it,\n+        };\n+\n+        let mut actual = action.edit.apply(&before);\n+        if let Some(pos) = action.cursor_position {\n+            actual = add_cursor(&actual, pos);\n+        }\n+        assert_eq_text!(after, &actual);\n+    }\n+\n+    pub(crate) fn check_assist_not_applicable(\n+        assist: fn(AssistCtx<MockDatabase>) -> Option<Assist>,\n+        before: &str,\n+    ) {\n+        let (before_cursor_pos, before) = extract_offset(before);\n+        let (db, _source_root, file_id) = MockDatabase::with_single_file(&before);\n+        let frange = FileRange {\n+            file_id,\n+            range: TextRange::offset_len(before_cursor_pos, 0.into()),\n+        };\n+        let assist = AssistCtx::with_ctx(&db, frange, true, assist);\n+        assert!(assist.is_none());\n+    }\n+\n+}"}, {"sha": "f6af47ec9133370f417726607d8a0d0064dc8311", "filename": "crates/ra_assists/src/replace_if_let_with_match.rs", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Freplace_if_let_with_match.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -1,11 +1,10 @@\n use ra_syntax::{AstNode, ast};\n+use ra_ide_api_light::formatting::extract_trivial_expression;\n+use hir::db::HirDatabase;\n \n-use crate::{\n-    assists::{AssistCtx, Assist},\n-    formatting::extract_trivial_expression,\n-};\n+use crate::{AssistCtx, Assist};\n \n-pub fn replace_if_let_with_match(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn replace_if_let_with_match(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let if_expr: &ast::IfExpr = ctx.node_at_offset()?;\n     let cond = if_expr.condition()?;\n     let pat = cond.pat()?;\n@@ -51,7 +50,7 @@ fn format_arm(block: &ast::Block) -> String {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::assists::check_assist;\n+    use crate::helpers::check_assist;\n \n     #[test]\n     fn test_replace_if_let_with_match_unwraps_simple_expressions() {", "previous_filename": "crates/ra_ide_api_light/src/assists/replace_if_let_with_match.rs"}, {"sha": "7e34be0878f260ea26db98abd998fb73e9dc081b", "filename": "crates/ra_assists/src/split_import.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_assists%2Fsrc%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fsplit_import.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -1,12 +1,13 @@\n+use hir::db::HirDatabase;\n use ra_syntax::{\n     TextUnit, AstNode, SyntaxKind::COLONCOLON,\n     ast,\n     algo::generate,\n };\n \n-use crate::assists::{AssistCtx, Assist};\n+use crate::{AssistCtx, Assist};\n \n-pub fn split_import(ctx: AssistCtx) -> Option<Assist> {\n+pub(crate) fn split_import(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let colon_colon = ctx\n         .leaf_at_offset()\n         .find(|leaf| leaf.kind() == COLONCOLON)?;\n@@ -34,7 +35,7 @@ pub fn split_import(ctx: AssistCtx) -> Option<Assist> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::assists::check_assist;\n+    use crate::helpers::check_assist;\n \n     #[test]\n     fn test_split_import() {", "previous_filename": "crates/ra_ide_api_light/src/assists/split_import.rs"}, {"sha": "66634e05b37913a402691fdebdcdd412f4881fcf", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -70,7 +70,7 @@ pub struct FileRange {\n /// Database which stores all significant input facts: source code and project\n /// model. Everything else in rust-analyzer is derived from these queries.\n #[salsa::query_group(SourceDatabaseStorage)]\n-pub trait SourceDatabase: CheckCanceled {\n+pub trait SourceDatabase: CheckCanceled + std::fmt::Debug {\n     /// Text of the file.\n     #[salsa::input]\n     fn file_text(&self, file_id: FileId) -> Arc<String>;"}, {"sha": "a9cd955cf05f105512f041a1a599c22b9a944e1e", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -18,8 +18,7 @@ macro_rules! impl_froms {\n }\n \n pub mod db;\n-#[cfg(test)]\n-mod mock;\n+pub mod mock;\n mod query_definitions;\n mod path;\n pub mod source_binder;"}, {"sha": "87095fb21924e54b7c272591d9d0a360d15b4d43", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -17,7 +17,7 @@ pub const WORKSPACE: SourceRootId = SourceRootId(0);\n     db::PersistentHirDatabaseStorage\n )]\n #[derive(Debug)]\n-pub(crate) struct MockDatabase {\n+pub struct MockDatabase {\n     events: Mutex<Option<Vec<salsa::Event<MockDatabase>>>>,\n     runtime: salsa::Runtime<MockDatabase>,\n     interner: Arc<HirInterner>,\n@@ -27,21 +27,21 @@ pub(crate) struct MockDatabase {\n impl panic::RefUnwindSafe for MockDatabase {}\n \n impl MockDatabase {\n-    pub(crate) fn with_files(fixture: &str) -> (MockDatabase, SourceRoot) {\n+    pub fn with_files(fixture: &str) -> (MockDatabase, SourceRoot) {\n         let (db, source_root, position) = MockDatabase::from_fixture(fixture);\n         assert!(position.is_none());\n         (db, source_root)\n     }\n \n-    pub(crate) fn with_single_file(text: &str) -> (MockDatabase, SourceRoot, FileId) {\n+    pub fn with_single_file(text: &str) -> (MockDatabase, SourceRoot, FileId) {\n         let mut db = MockDatabase::default();\n         let mut source_root = SourceRoot::default();\n         let file_id = db.add_file(WORKSPACE, &mut source_root, \"/main.rs\", text);\n         db.set_source_root(WORKSPACE, Arc::new(source_root.clone()));\n         (db, source_root, file_id)\n     }\n \n-    pub(crate) fn with_position(fixture: &str) -> (MockDatabase, FilePosition) {\n+    pub fn with_position(fixture: &str) -> (MockDatabase, FilePosition) {\n         let (db, _, position) = MockDatabase::from_fixture(fixture);\n         let position = position.expect(\"expected a marker ( <|> )\");\n         (db, position)\n@@ -166,13 +166,13 @@ impl AsRef<HirInterner> for MockDatabase {\n }\n \n impl MockDatabase {\n-    pub(crate) fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event<MockDatabase>> {\n+    pub fn log(&self, f: impl FnOnce()) -> Vec<salsa::Event<MockDatabase>> {\n         *self.events.lock() = Some(Vec::new());\n         f();\n         self.events.lock().take().unwrap()\n     }\n \n-    pub(crate) fn log_executed(&self, f: impl FnOnce()) -> Vec<String> {\n+    pub fn log_executed(&self, f: impl FnOnce()) -> Vec<String> {\n         let events = self.log(f);\n         events\n             .into_iter()"}, {"sha": "95cccf8cf944930f7366da17d85ddf8a8cf27ab1", "filename": "crates/ra_ide_api/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_ide_api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_ide_api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2FCargo.toml?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -24,6 +24,7 @@ ra_text_edit = { path = \"../ra_text_edit\" }\n ra_db = { path = \"../ra_db\" }\n hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n test_utils = { path = \"../test_utils\" }\n+ra_assists = { path = \"../ra_assists\" }\n \n [dev-dependencies]\n insta = \"0.6.1\""}, {"sha": "2a96fdf471daf80aaa83ee14b6f1b23145412515", "filename": "crates/ra_ide_api/src/assists.rs", "status": "modified", "additions": 22, "deletions": 87, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_ide_api%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_ide_api%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fassists.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -1,89 +1,24 @@\n-mod fill_match_arm;\n-\n-use ra_syntax::{\n-    TextRange, SourceFile, AstNode,\n-    algo::find_node_at_offset,\n-};\n-use ra_ide_api_light::{\n-    LocalEdit,\n-    assists::{\n-        Assist,\n-        AssistBuilder\n-    }\n-};\n-use crate::{\n-    db::RootDatabase,\n-    FileId\n-};\n-\n-/// Return all the assists applicable at the given position.\n-pub(crate) fn assists(\n-    db: &RootDatabase,\n-    file_id: FileId,\n-    file: &SourceFile,\n-    range: TextRange,\n-) -> Vec<LocalEdit> {\n-    let ctx = AssistCtx::new(db, file_id, file, range);\n-    [fill_match_arm::fill_match_arm]\n-        .iter()\n-        .filter_map(|&assist| ctx.clone().apply(assist))\n+use ra_db::{FileRange, FilePosition};\n+\n+use crate::{SourceFileEdit, SourceChange, db::RootDatabase};\n+\n+pub(crate) fn assists(db: &RootDatabase, frange: FileRange) -> Vec<SourceChange> {\n+    ra_assists::assists(db, frange)\n+        .into_iter()\n+        .map(|(label, action)| {\n+            let file_id = frange.file_id;\n+            let file_edit = SourceFileEdit {\n+                file_id,\n+                edit: action.edit,\n+            };\n+            SourceChange {\n+                label: label.label,\n+                source_file_edits: vec![file_edit],\n+                file_system_edits: vec![],\n+                cursor_position: action\n+                    .cursor_position\n+                    .map(|offset| FilePosition { offset, file_id }),\n+            }\n+        })\n         .collect()\n }\n-\n-#[derive(Debug, Clone)]\n-pub struct AssistCtx<'a> {\n-    file_id: FileId,\n-    source_file: &'a SourceFile,\n-    db: &'a RootDatabase,\n-    range: TextRange,\n-    should_compute_edit: bool,\n-}\n-\n-impl<'a> AssistCtx<'a> {\n-    pub(crate) fn new(\n-        db: &'a RootDatabase,\n-        file_id: FileId,\n-        source_file: &'a SourceFile,\n-        range: TextRange,\n-    ) -> AssistCtx<'a> {\n-        AssistCtx {\n-            source_file,\n-            file_id,\n-            db,\n-            range,\n-            should_compute_edit: false,\n-        }\n-    }\n-\n-    pub fn apply(mut self, assist: fn(AssistCtx) -> Option<Assist>) -> Option<LocalEdit> {\n-        self.should_compute_edit = true;\n-        match assist(self) {\n-            None => None,\n-            Some(Assist::Edit(e)) => Some(e),\n-            Some(Assist::Applicable) => unreachable!(),\n-        }\n-    }\n-\n-    #[allow(unused)]\n-    pub fn check(mut self, assist: fn(AssistCtx) -> Option<Assist>) -> bool {\n-        self.should_compute_edit = false;\n-        match assist(self) {\n-            None => false,\n-            Some(Assist::Edit(_)) => unreachable!(),\n-            Some(Assist::Applicable) => true,\n-        }\n-    }\n-\n-    fn build(self, label: impl Into<String>, f: impl FnOnce(&mut AssistBuilder)) -> Option<Assist> {\n-        if !self.should_compute_edit {\n-            return Some(Assist::Applicable);\n-        }\n-        let mut edit = AssistBuilder::default();\n-        f(&mut edit);\n-        Some(edit.build(label))\n-    }\n-\n-    pub(crate) fn node_at_offset<N: AstNode>(&self) -> Option<&'a N> {\n-        find_node_at_offset(self.source_file.syntax(), self.range.start())\n-    }\n-}"}, {"sha": "6ae829d8569d264b73c0c893ca20c29280122ae5", "filename": "crates/ra_ide_api/src/assists/fill_match_arm.rs", "status": "removed", "additions": 0, "deletions": 157, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9/crates%2Fra_ide_api%2Fsrc%2Fassists%2Ffill_match_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9/crates%2Fra_ide_api%2Fsrc%2Fassists%2Ffill_match_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fassists%2Ffill_match_arm.rs?ref=736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9", "patch": "@@ -1,157 +0,0 @@\n-use std::fmt::Write;\n-use hir::{\n-    AdtDef,\n-    source_binder,\n-    Ty,\n-    FieldSource,\n-};\n-use ra_ide_api_light::{\n-    assists::{\n-        Assist,\n-        AssistBuilder\n-    }\n-};\n-use ra_syntax::{\n-    ast::{\n-        self,\n-        AstNode,\n-    }\n-};\n-\n-use crate::assists::AssistCtx;\n-\n-pub fn fill_match_arm(ctx: AssistCtx) -> Option<Assist> {\n-    let match_expr = ctx.node_at_offset::<ast::MatchExpr>()?;\n-\n-    // We already have some match arms, so we don't provide any assists.\n-    match match_expr.match_arm_list() {\n-        Some(arm_list) if arm_list.arms().count() > 0 => {\n-            return None;\n-        }\n-        _ => {}\n-    }\n-\n-    let expr = match_expr.expr()?;\n-    let function = source_binder::function_from_child_node(ctx.db, ctx.file_id, expr.syntax())?;\n-    let infer_result = function.infer(ctx.db);\n-    let syntax_mapping = function.body_syntax_mapping(ctx.db);\n-    let node_expr = syntax_mapping.node_expr(expr)?;\n-    let match_expr_ty = infer_result[node_expr].clone();\n-    match match_expr_ty {\n-        Ty::Adt { def_id, .. } => match def_id {\n-            AdtDef::Enum(e) => {\n-                let mut buf = format!(\"match {} {{\\n\", expr.syntax().text().to_string());\n-                let variants = e.variants(ctx.db);\n-                for variant in variants {\n-                    let name = variant.name(ctx.db)?;\n-                    write!(\n-                        &mut buf,\n-                        \"    {}::{}\",\n-                        e.name(ctx.db)?.to_string(),\n-                        name.to_string()\n-                    )\n-                    .expect(\"write fmt\");\n-\n-                    let pat = variant\n-                        .fields(ctx.db)\n-                        .into_iter()\n-                        .map(|field| {\n-                            let name = field.name(ctx.db).to_string();\n-                            let (_, source) = field.source(ctx.db);\n-                            match source {\n-                                FieldSource::Named(_) => name,\n-                                FieldSource::Pos(_) => \"_\".to_string(),\n-                            }\n-                        })\n-                        .collect::<Vec<_>>();\n-\n-                    match pat.first().map(|s| s.as_str()) {\n-                        Some(\"_\") => write!(&mut buf, \"({})\", pat.join(\", \")).expect(\"write fmt\"),\n-                        Some(_) => write!(&mut buf, \"{{{}}}\", pat.join(\", \")).expect(\"write fmt\"),\n-                        None => (),\n-                    };\n-\n-                    buf.push_str(\" => (),\\n\");\n-                }\n-                buf.push_str(\"}\");\n-                ctx.build(\"fill match arms\", |edit: &mut AssistBuilder| {\n-                    edit.replace_node_and_indent(match_expr.syntax(), buf);\n-                })\n-            }\n-            _ => None,\n-        },\n-        _ => None,\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use insta::assert_debug_snapshot_matches;\n-\n-    use ra_syntax::{TextRange, TextUnit};\n-\n-    use crate::{\n-        FileRange,\n-        mock_analysis::{analysis_and_position, single_file_with_position}\n-};\n-    use ra_db::SourceDatabase;\n-\n-    fn test_assit(name: &str, code: &str) {\n-        let (analysis, position) = if code.contains(\"//-\") {\n-            analysis_and_position(code)\n-        } else {\n-            single_file_with_position(code)\n-        };\n-        let frange = FileRange {\n-            file_id: position.file_id,\n-            range: TextRange::offset_len(position.offset, TextUnit::from(1)),\n-        };\n-        let source_file = analysis\n-            .with_db(|db| db.parse(frange.file_id))\n-            .expect(\"source file\");\n-        let ret = analysis\n-            .with_db(|db| crate::assists::assists(db, frange.file_id, &source_file, frange.range))\n-            .expect(\"assists\");\n-\n-        assert_debug_snapshot_matches!(name, ret);\n-    }\n-\n-    #[test]\n-    fn test_fill_match_arm() {\n-        test_assit(\n-            \"fill_match_arm1\",\n-            r#\"\n-        enum A {\n-            As,\n-            Bs,\n-            Cs(String),\n-            Ds(String, String),\n-            Es{x: usize, y: usize}\n-        }\n-\n-        fn main() {\n-            let a = A::As;\n-            match a<|>\n-        }\n-        \"#,\n-        );\n-\n-        test_assit(\n-            \"fill_match_arm2\",\n-            r#\"\n-        enum A {\n-            As,\n-            Bs,\n-            Cs(String),\n-            Ds(String, String),\n-            Es{x: usize, y: usize}\n-        }\n-\n-        fn main() {\n-            let a = A::As;\n-            match a<|> {}\n-        }\n-        \"#,\n-        );\n-    }\n-}"}, {"sha": "980726d92f6a3ee25aa5161c5560e7e88d5b17f9", "filename": "crates/ra_ide_api/src/assists/snapshots/tests__fill_match_arm1.snap", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9/crates%2Fra_ide_api%2Fsrc%2Fassists%2Fsnapshots%2Ftests__fill_match_arm1.snap", "raw_url": "https://github.com/rust-lang/rust/raw/736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9/crates%2Fra_ide_api%2Fsrc%2Fassists%2Fsnapshots%2Ftests__fill_match_arm1.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fassists%2Fsnapshots%2Ftests__fill_match_arm1.snap?ref=736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9", "patch": "@@ -1,20 +0,0 @@\n----\n-created: \"2019-02-03T15:38:46.094184+00:00\"\n-creator: insta@0.5.2\n-expression: ret\n-source: crates/ra_ide_api/src/assits/fill_match_arm.rs\n----\n-[\n-    LocalEdit {\n-        label: \"fill match arms\",\n-        edit: TextEdit {\n-            atoms: [\n-                AtomTextEdit {\n-                    delete: [211; 218),\n-                    insert: \"match a {\\n                A::As => (),\\n                A::Bs => (),\\n                A::Cs(_) => (),\\n                A::Ds(_, _) => (),\\n                A::Es{x, y} => (),\\n            }\"\n-                }\n-            ]\n-        },\n-        cursor_position: None\n-    }\n-]"}, {"sha": "cee0efe74a60966487ee7099c6351a0ab954131a", "filename": "crates/ra_ide_api/src/assists/snapshots/tests__fill_match_arm2.snap", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9/crates%2Fra_ide_api%2Fsrc%2Fassists%2Fsnapshots%2Ftests__fill_match_arm2.snap", "raw_url": "https://github.com/rust-lang/rust/raw/736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9/crates%2Fra_ide_api%2Fsrc%2Fassists%2Fsnapshots%2Ftests__fill_match_arm2.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fassists%2Fsnapshots%2Ftests__fill_match_arm2.snap?ref=736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9", "patch": "@@ -1,20 +0,0 @@\n----\n-created: \"2019-02-03T15:41:34.640074+00:00\"\n-creator: insta@0.5.2\n-expression: ret\n-source: crates/ra_ide_api/src/assits/fill_match_arm.rs\n----\n-[\n-    LocalEdit {\n-        label: \"fill match arms\",\n-        edit: TextEdit {\n-            atoms: [\n-                AtomTextEdit {\n-                    delete: [211; 221),\n-                    insert: \"match a {\\n                A::As => (),\\n                A::Bs => (),\\n                A::Cs(_) => (),\\n                A::Ds(_, _) => (),\\n                A::Es{x, y} => (),\\n            }\"\n-                }\n-            ]\n-        },\n-        cursor_position: None\n-    }\n-]"}, {"sha": "b139efabf6d96ef212f69ffbc4a0f6bbaa7e18c4", "filename": "crates/ra_ide_api/src/imp.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_ide_api%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_ide_api%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fimp.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -19,7 +19,7 @@ use ra_syntax::{\n \n use crate::{\n     AnalysisChange,\n-    CrateId, db, Diagnostic, FileId, FilePosition, FileRange, FileSystemEdit,\n+    CrateId, db, Diagnostic, FileId, FilePosition, FileSystemEdit,\n     Query, RootChange, SourceChange, SourceFileEdit,\n     symbol_index::{FileSymbol, SymbolsDatabase},\n     status::syntax_tree_stats\n@@ -236,15 +236,6 @@ impl db::RootDatabase {\n         res\n     }\n \n-    pub(crate) fn assists(&self, frange: FileRange) -> Vec<SourceChange> {\n-        let file = self.parse(frange.file_id);\n-        ra_ide_api_light::assists::assists(&file, frange.range)\n-            .into_iter()\n-            .chain(crate::assists::assists(self, frange.file_id, &file, frange.range).into_iter())\n-            .map(|local_edit| SourceChange::from_local_edit(frange.file_id, local_edit))\n-            .collect()\n-    }\n-\n     pub(crate) fn index_resolve(&self, name_ref: &ast::NameRef) -> Vec<FileSymbol> {\n         let name = name_ref.text();\n         let mut query = Query::new(name.to_string());"}, {"sha": "8beaba5de3b6d12dbd39d2c2b028e0a878ce432e", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -477,7 +477,7 @@ impl Analysis {\n     /// Computes assists (aks code actons aka intentions) for the given\n     /// position.\n     pub fn assists(&self, frange: FileRange) -> Cancelable<Vec<SourceChange>> {\n-        self.with_db(|db| db.assists(frange))\n+        self.with_db(|db| assists::assists(db, frange))\n     }\n \n     /// Computes the set of diagnostics for the given file."}, {"sha": "e578805f1078de373075180f88123b5608cdd1d8", "filename": "crates/ra_ide_api_light/src/assists.rs", "status": "removed", "additions": 0, "deletions": 215, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fassists.rs?ref=736a55c97e69f95e6ff4a0c3dafb2018e8ea05f9", "patch": "@@ -1,215 +0,0 @@\n-//! This modules contains various \"assists\": suggestions for source code edits\n-//! which are likely to occur at a given cursor position. For example, if the\n-//! cursor is on the `,`, a possible assist is swapping the elements around the\n-//! comma.\n-\n-mod flip_comma;\n-mod add_derive;\n-mod add_impl;\n-mod introduce_variable;\n-mod change_visibility;\n-mod split_import;\n-mod replace_if_let_with_match;\n-\n-use ra_text_edit::{TextEdit, TextEditBuilder};\n-use ra_syntax::{\n-    Direction, SyntaxNode, TextUnit, TextRange, SourceFile, AstNode,\n-    algo::{find_leaf_at_offset, find_node_at_offset, find_covering_node, LeafAtOffset},\n-};\n-use itertools::Itertools;\n-\n-use crate::formatting::leading_indent;\n-\n-pub use self::{\n-    flip_comma::flip_comma,\n-    add_derive::add_derive,\n-    add_impl::add_impl,\n-    introduce_variable::introduce_variable,\n-    change_visibility::change_visibility,\n-    split_import::split_import,\n-    replace_if_let_with_match::replace_if_let_with_match,\n-};\n-\n-/// Return all the assists applicable at the given position.\n-pub fn assists(file: &SourceFile, range: TextRange) -> Vec<LocalEdit> {\n-    let ctx = AssistCtx::new(file, range);\n-    [\n-        flip_comma,\n-        add_derive,\n-        add_impl,\n-        introduce_variable,\n-        change_visibility,\n-        split_import,\n-        replace_if_let_with_match,\n-    ]\n-    .iter()\n-    .filter_map(|&assist| ctx.clone().apply(assist))\n-    .collect()\n-}\n-\n-#[derive(Debug)]\n-pub struct LocalEdit {\n-    pub label: String,\n-    pub edit: TextEdit,\n-    pub cursor_position: Option<TextUnit>,\n-}\n-\n-fn non_trivia_sibling(node: &SyntaxNode, direction: Direction) -> Option<&SyntaxNode> {\n-    node.siblings(direction)\n-        .skip(1)\n-        .find(|node| !node.kind().is_trivia())\n-}\n-\n-/// `AssistCtx` allows to apply an assist or check if it could be applied.\n-///\n-/// Assists use a somewhat overengineered approach, given the current needs. The\n-/// assists workflow consists of two phases. In the first phase, a user asks for\n-/// the list of available assists. In the second phase, the user picks a\n-/// particular assist and it gets applied.\n-///\n-/// There are two peculiarities here:\n-///\n-/// * first, we ideally avoid computing more things then necessary to answer\n-///   \"is assist applicable\" in the first phase.\n-/// * second, when we are applying assist, we don't have a guarantee that there\n-///   weren't any changes between the point when user asked for assists and when\n-///   they applied a particular assist. So, when applying assist, we need to do\n-///   all the checks from scratch.\n-///\n-/// To avoid repeating the same code twice for both \"check\" and \"apply\"\n-/// functions, we use an approach reminiscent of that of Django's function based\n-/// views dealing with forms. Each assist receives a runtime parameter,\n-/// `should_compute_edit`. It first check if an edit is applicable (potentially\n-/// computing info required to compute the actual edit). If it is applicable,\n-/// and `should_compute_edit` is `true`, it then computes the actual edit.\n-///\n-/// So, to implement the original assists workflow, we can first apply each edit\n-/// with `should_compute_edit = false`, and then applying the selected edit\n-/// again, with `should_compute_edit = true` this time.\n-///\n-/// Note, however, that we don't actually use such two-phase logic at the\n-/// moment, because the LSP API is pretty awkward in this place, and it's much\n-/// easier to just compute the edit eagerly :-)\n-#[derive(Debug, Clone)]\n-pub struct AssistCtx<'a> {\n-    source_file: &'a SourceFile,\n-    range: TextRange,\n-    should_compute_edit: bool,\n-}\n-\n-#[derive(Debug)]\n-pub enum Assist {\n-    Applicable,\n-    Edit(LocalEdit),\n-}\n-\n-#[derive(Default)]\n-pub struct AssistBuilder {\n-    edit: TextEditBuilder,\n-    cursor_position: Option<TextUnit>,\n-}\n-\n-impl<'a> AssistCtx<'a> {\n-    pub fn new(source_file: &'a SourceFile, range: TextRange) -> AssistCtx {\n-        AssistCtx {\n-            source_file,\n-            range,\n-            should_compute_edit: false,\n-        }\n-    }\n-\n-    pub fn apply(mut self, assist: fn(AssistCtx) -> Option<Assist>) -> Option<LocalEdit> {\n-        self.should_compute_edit = true;\n-        match assist(self) {\n-            None => None,\n-            Some(Assist::Edit(e)) => Some(e),\n-            Some(Assist::Applicable) => unreachable!(),\n-        }\n-    }\n-\n-    pub fn check(mut self, assist: fn(AssistCtx) -> Option<Assist>) -> bool {\n-        self.should_compute_edit = false;\n-        match assist(self) {\n-            None => false,\n-            Some(Assist::Edit(_)) => unreachable!(),\n-            Some(Assist::Applicable) => true,\n-        }\n-    }\n-\n-    fn build(self, label: impl Into<String>, f: impl FnOnce(&mut AssistBuilder)) -> Option<Assist> {\n-        if !self.should_compute_edit {\n-            return Some(Assist::Applicable);\n-        }\n-        let mut edit = AssistBuilder::default();\n-        f(&mut edit);\n-        Some(edit.build(label))\n-    }\n-\n-    pub(crate) fn leaf_at_offset(&self) -> LeafAtOffset<&'a SyntaxNode> {\n-        find_leaf_at_offset(self.source_file.syntax(), self.range.start())\n-    }\n-    pub(crate) fn node_at_offset<N: AstNode>(&self) -> Option<&'a N> {\n-        find_node_at_offset(self.source_file.syntax(), self.range.start())\n-    }\n-    pub(crate) fn covering_node(&self) -> &'a SyntaxNode {\n-        find_covering_node(self.source_file.syntax(), self.range)\n-    }\n-}\n-\n-impl AssistBuilder {\n-    fn replace(&mut self, range: TextRange, replace_with: impl Into<String>) {\n-        self.edit.replace(range, replace_with.into())\n-    }\n-    pub fn replace_node_and_indent(&mut self, node: &SyntaxNode, replace_with: impl Into<String>) {\n-        let mut replace_with = replace_with.into();\n-        if let Some(indent) = leading_indent(node) {\n-            replace_with = reindent(&replace_with, indent)\n-        }\n-        self.replace(node.range(), replace_with)\n-    }\n-    #[allow(unused)]\n-    fn delete(&mut self, range: TextRange) {\n-        self.edit.delete(range)\n-    }\n-    fn insert(&mut self, offset: TextUnit, text: impl Into<String>) {\n-        self.edit.insert(offset, text.into())\n-    }\n-    fn set_cursor(&mut self, offset: TextUnit) {\n-        self.cursor_position = Some(offset)\n-    }\n-    pub fn build(self, label: impl Into<String>) -> Assist {\n-        Assist::Edit(LocalEdit {\n-            label: label.into(),\n-            cursor_position: self.cursor_position,\n-            edit: self.edit.finish(),\n-        })\n-    }\n-}\n-\n-fn reindent(text: &str, indent: &str) -> String {\n-    let indent = format!(\"\\n{}\", indent);\n-    text.lines().intersperse(&indent).collect()\n-}\n-\n-#[cfg(test)]\n-fn check_assist(assist: fn(AssistCtx) -> Option<Assist>, before: &str, after: &str) {\n-    crate::test_utils::check_action(before, after, |file, off| {\n-        let range = TextRange::offset_len(off, 0.into());\n-        AssistCtx::new(file, range).apply(assist)\n-    })\n-}\n-\n-#[cfg(test)]\n-fn check_assist_not_applicable(assist: fn(AssistCtx) -> Option<Assist>, text: &str) {\n-    crate::test_utils::check_action_not_applicable(text, |file, off| {\n-        let range = TextRange::offset_len(off, 0.into());\n-        AssistCtx::new(file, range).apply(assist)\n-    })\n-}\n-\n-#[cfg(test)]\n-fn check_assist_range(assist: fn(AssistCtx) -> Option<Assist>, before: &str, after: &str) {\n-    crate::test_utils::check_action_range(before, after, |file, range| {\n-        AssistCtx::new(file, range).apply(assist)\n-    })\n-}"}, {"sha": "46ffa7d9604796023ccd6facf52cdca197e62dfc", "filename": "crates/ra_ide_api_light/src/formatting.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_ide_api_light%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_ide_api_light%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Fformatting.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -1,12 +1,18 @@\n+use itertools::Itertools;\n use ra_syntax::{\n     AstNode,\n     SyntaxNode, SyntaxKind::*,\n     ast::{self, AstToken},\n     algo::generate,\n };\n \n+pub fn reindent(text: &str, indent: &str) -> String {\n+    let indent = format!(\"\\n{}\", indent);\n+    text.lines().intersperse(&indent).collect()\n+}\n+\n /// If the node is on the beginning of the line, calculate indent.\n-pub(crate) fn leading_indent(node: &SyntaxNode) -> Option<&str> {\n+pub fn leading_indent(node: &SyntaxNode) -> Option<&str> {\n     for leaf in prev_leaves(node) {\n         if let Some(ws) = ast::Whitespace::cast(leaf) {\n             let ws_text = ws.text();\n@@ -32,7 +38,7 @@ fn prev_leaf(node: &SyntaxNode) -> Option<&SyntaxNode> {\n     .last()\n }\n \n-pub(crate) fn extract_trivial_expression(block: &ast::Block) -> Option<&ast::Expr> {\n+pub fn extract_trivial_expression(block: &ast::Block) -> Option<&ast::Expr> {\n     let expr = block.expr()?;\n     if expr.syntax().text().contains('\\n') {\n         return None;"}, {"sha": "17044270c609ca3e4ccbf4d989ddc7aff7e381a8", "filename": "crates/ra_ide_api_light/src/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Flib.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -3,7 +3,7 @@\n //! This usually means functions which take syntax tree as an input and produce\n //! an edit or some auxiliary info.\n \n-pub mod assists;\n+pub mod formatting;\n mod extend_selection;\n mod folding_ranges;\n mod line_index;\n@@ -14,10 +14,15 @@ mod test_utils;\n mod join_lines;\n mod typing;\n mod diagnostics;\n-pub(crate) mod formatting;\n+\n+#[derive(Debug)]\n+pub struct LocalEdit {\n+    pub label: String,\n+    pub edit: ra_text_edit::TextEdit,\n+    pub cursor_position: Option<TextUnit>,\n+}\n \n pub use self::{\n-    assists::LocalEdit,\n     extend_selection::extend_selection,\n     folding_ranges::{folding_ranges, Fold, FoldKind},\n     line_index::{LineCol, LineIndex},"}, {"sha": "bfac0fce36919789cf312542665cd2a8f775bbea", "filename": "crates/ra_ide_api_light/src/test_utils.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_ide_api_light%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d/crates%2Fra_ide_api_light%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api_light%2Fsrc%2Ftest_utils.rs?ref=0c5fd8f7cbf04eda763e55bc9a38dad5f7ec917d", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{SourceFile, TextRange, TextUnit};\n+use ra_syntax::{SourceFile, TextUnit};\n \n use crate::LocalEdit;\n pub use test_utils::*;\n@@ -22,32 +22,3 @@ pub fn check_action<F: Fn(&SourceFile, TextUnit) -> Option<LocalEdit>>(\n     let actual = add_cursor(&actual, actual_cursor_pos);\n     assert_eq_text!(after, &actual);\n }\n-\n-pub fn check_action_not_applicable<F: Fn(&SourceFile, TextUnit) -> Option<LocalEdit>>(\n-    text: &str,\n-    f: F,\n-) {\n-    let (text_cursor_pos, text) = extract_offset(text);\n-    let file = SourceFile::parse(&text);\n-    assert!(\n-        f(&file, text_cursor_pos).is_none(),\n-        \"code action is applicable but it shouldn't\"\n-    );\n-}\n-\n-pub fn check_action_range<F: Fn(&SourceFile, TextRange) -> Option<LocalEdit>>(\n-    before: &str,\n-    after: &str,\n-    f: F,\n-) {\n-    let (range, before) = extract_range(before);\n-    let file = SourceFile::parse(&before);\n-    let result = f(&file, range).expect(\"code action is not applicable\");\n-    let actual = result.edit.apply(&before);\n-    let actual_cursor_pos = match result.cursor_position {\n-        None => result.edit.apply_to_offset(range.start()).unwrap(),\n-        Some(off) => off,\n-    };\n-    let actual = add_cursor(&actual, actual_cursor_pos);\n-    assert_eq_text!(after, &actual);\n-}"}]}