{"sha": "a5b09d35473615e7142f5570f5c5fad0caf68bd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YjA5ZDM1NDczNjE1ZTcxNDJmNTU3MGY1YzVmYWQwY2FmNjhiZDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-31T19:12:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-31T19:12:14Z"}, "message": "Auto merge of #70625 - Dylan-DPC:rollup-o8n2hw8, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #69425 (add fn make_contiguous to VecDeque)\n - #69458 (improve folder name for persistent doc tests)\n - #70268 (Document ThreadSanitizer in unstable-book)\n - #70600 (Ensure there are versions of test code for aarch64 windows)\n - #70606 (Clean up E0466 explanation)\n - #70614 (remove unnecessary relocation check in const_prop)\n - #70623 (Fix broken link in README)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "251cbaeb04db25a9a11452b69625b0e0d3abe107", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/251cbaeb04db25a9a11452b69625b0e0d3abe107"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5b09d35473615e7142f5570f5c5fad0caf68bd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5b09d35473615e7142f5570f5c5fad0caf68bd2", "html_url": "https://github.com/rust-lang/rust/commit/a5b09d35473615e7142f5570f5c5fad0caf68bd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5b09d35473615e7142f5570f5c5fad0caf68bd2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "html_url": "https://github.com/rust-lang/rust/commit/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6"}, {"sha": "011c0906cde560631b35bd767c39d48ac17b1d39", "url": "https://api.github.com/repos/rust-lang/rust/commits/011c0906cde560631b35bd767c39d48ac17b1d39", "html_url": "https://github.com/rust-lang/rust/commit/011c0906cde560631b35bd767c39d48ac17b1d39"}], "stats": {"total": 659, "additions": 454, "deletions": 205}, "files": [{"sha": "6f184e252182a80dc25e7ed953df8542488e4bac", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5b09d35473615e7142f5570f5c5fad0caf68bd2/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a5b09d35473615e7142f5570f5c5fad0caf68bd2/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a5b09d35473615e7142f5570f5c5fad0caf68bd2", "patch": "@@ -256,7 +256,7 @@ Also, you may find the [rustdocs for the compiler itself][rustdocs] useful.\n \n [rust-discord]: https://discord.gg/rust-lang\n [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/about-this-guide.html\n-[rustdocs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/\n+[rustdocs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/\n \n ## License\n "}, {"sha": "7ebd8054ba0b0d19361365675332ba55b1d32eb2", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 150, "deletions": 86, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=a5b09d35473615e7142f5570f5c5fad0caf68bd2", "patch": "@@ -6,73 +6,78 @@ The tracking issue for this feature is: [#39699](https://github.com/rust-lang/ru\n \n This feature allows for use of one of following sanitizers:\n \n-* [AddressSanitizer][clang-asan] a faster memory error detector. Can\n-  detect out-of-bounds access to heap, stack, and globals, use after free, use\n-  after return, double free, invalid free, memory leaks.\n+* [AddressSanitizer][clang-asan] a fast memory error detector.\n * [LeakSanitizer][clang-lsan] a run-time memory leak detector.\n * [MemorySanitizer][clang-msan] a detector of uninitialized reads.\n * [ThreadSanitizer][clang-tsan] a fast data race detector.\n \n-To enable a sanitizer compile with `-Zsanitizer=...` option, where value is one\n-of `address`, `leak`, `memory` or `thread`.\n+To enable a sanitizer compile with `-Zsanitizer=address`, `-Zsanitizer=leak`,\n+`-Zsanitizer=memory` or `-Zsanitizer=thread`. Only a single sanitizer can be\n+enabled at a time.\n \n-# Examples\n+# AddressSanitizer\n \n-This sections show various issues that can be detected with sanitizers.  For\n-simplicity, the examples are prepared under assumption that optimization level\n-used is zero.\n+AddressSanitizer is a memory error detector. It can detect the following types\n+of bugs:\n \n-## AddressSanitizer\n+* Out of bound accesses to heap, stack and globals\n+* Use after free\n+* Use after return (runtime flag `ASAN_OPTIONS=detect_stack_use_after_return=1`)\n+* Use after scope\n+* Double-free, invalid free\n+* Memory leaks\n+\n+AddressSanitizer is supported on the following targets:\n+\n+* `x86_64-apple-darwin`\n+* `x86_64-unknown-linux-gnu`\n+\n+AddressSanitizer works with non-instrumented code although it will impede its\n+ability to detect some bugs.  It is not expected to produce false positive\n+reports.\n+\n+## Examples\n \n Stack buffer overflow:\n \n-```shell\n-$ cat a.rs\n+```rust\n fn main() {\n     let xs = [0, 1, 2, 3];\n     let _y = unsafe { *xs.as_ptr().offset(4) };\n }\n-$ rustc -Zsanitizer=address a.rs\n-$ ./a\n-=================================================================\n-==10029==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffcc15f43d0 at pc 0x55f77dc015c5 bp 0x7ffcc15f4390 sp 0x7ffcc15f4388\n-READ of size 4 at 0x7ffcc15f43d0 thread T0\n-    #0 0x55f77dc015c4 in a::main::hab3bd2a745c2d0ac (/tmp/a+0xa5c4)\n-    #1 0x55f77dc01cdb in std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::haa8c76d1faa7b7ca (/tmp/a+0xacdb)\n-    #2 0x55f77dc90f02 in std::rt::lang_start_internal::_$u7b$$u7b$closure$u7d$$u7d$::hfeb9a1aef9ac820d /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/rt.rs:48:12\n-    #3 0x55f77dc90f02 in std::panicking::try::do_call::h12f0919717b8e0a6 /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panicking.rs:288:39\n-    #4 0x55f77dc926c9 in __rust_maybe_catch_panic /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libpanic_unwind/lib.rs:80:7\n-    #5 0x55f77dc9197c in std::panicking::try::h413b21cdcd6cfd86 /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panicking.rs:267:12\n-    #6 0x55f77dc9197c in std::panic::catch_unwind::hc5cc8ef2fd73424d /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/panic.rs:396:8\n-    #7 0x55f77dc9197c in std::rt::lang_start_internal::h2039f418ab92218f /rustc/c27f7568bc74c418996892028a629eed5a7f5f00/src/libstd/rt.rs:47:24\n-    #8 0x55f77dc01c61 in std::rt::lang_start::ha905d28f6b61d691 (/tmp/a+0xac61)\n-    #9 0x55f77dc0163a in main (/tmp/a+0xa63a)\n-    #10 0x7f9b3cf5bbba in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26bba)\n-    #11 0x55f77dc01289 in _start (/tmp/a+0xa289)\n-\n-Address 0x7ffcc15f43d0 is located in stack of thread T0 at offset 48 in frame\n-    #0 0x55f77dc0135f in a::main::hab3bd2a745c2d0ac (/tmp/a+0xa35f)\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n+==37882==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe400e6250 at pc 0x5609a841fb20 bp 0x7ffe400e6210 sp 0x7ffe400e6208\n+READ of size 4 at 0x7ffe400e6250 thread T0\n+    #0 0x5609a841fb1f in example::main::h628ffc6626ed85b2 /.../src/main.rs:3:23\n+    ...\n+\n+Address 0x7ffe400e6250 is located in stack of thread T0 at offset 48 in frame\n+    #0 0x5609a841f8af in example::main::h628ffc6626ed85b2 /.../src/main.rs:1\n \n   This frame has 1 object(s):\n-    [32, 48) 'xs' <== Memory access at offset 48 overflows this variable\n+    [32, 48) 'xs' (line 2) <== Memory access at offset 48 overflows this variable\n HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n       (longjmp and C++ exceptions *are* supported)\n-SUMMARY: AddressSanitizer: stack-buffer-overflow (/tmp/a+0xa5c4) in a::main::hab3bd2a745c2d0ac\n+SUMMARY: AddressSanitizer: stack-buffer-overflow /.../src/main.rs:3:23 in example::main::h628ffc6626ed85b2\n Shadow bytes around the buggy address:\n-  0x1000182b6820: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6830: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6840: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6850: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6860: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-=>0x1000182b6870: 00 00 00 00 f1 f1 f1 f1 00 00[f3]f3 00 00 00 00\n-  0x1000182b6880: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b6890: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x1000182b68c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014bf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+=>0x100048014c40: 00 00 00 00 f1 f1 f1 f1 00 00[f3]f3 00 00 00 00\n+  0x100048014c50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x100048014c70: f1 f1 f1 f1 00 00 f3 f3 00 00 00 00 00 00 00 00\n+  0x100048014c80: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x100048014c90: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n Shadow byte legend (one shadow byte represents 8 application bytes):\n   Addressable:           00\n-  Partially addressable: 01 02 03 04 05 06 07 \n+  Partially addressable: 01 02 03 04 05 06 07\n   Heap left redzone:       fa\n   Freed heap region:       fd\n   Stack left redzone:      f1\n@@ -90,13 +95,12 @@ Shadow byte legend (one shadow byte represents 8 application bytes):\n   Left alloca redzone:     ca\n   Right alloca redzone:    cb\n   Shadow gap:              cc\n-==10029==ABORTING\n+==37882==ABORTING\n ```\n \n Use of a stack object after its scope has already ended:\n \n-```shell\n-$ cat b.rs\n+```rust\n static mut P: *mut usize = std::ptr::null_mut();\n \n fn main() {\n@@ -108,42 +112,38 @@ fn main() {\n         std::ptr::write_volatile(P, 123);\n     }\n }\n-$ rustc -Zsanitizer=address b.rs\n-$./b\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=address RUSTDOCFLAGS=-Zsanitizer=address\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n =================================================================\n-==424427==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7fff67be6be0 at pc 0x5647a3ea4658 bp 0x7fff67be6b90 sp 0x7fff67be6b88\n-WRITE of size 8 at 0x7fff67be6be0 thread T0\n-    #0 0x5647a3ea4657 in core::ptr::write_volatile::h4b04601757d0376d (/tmp/b+0xb8657)\n-    #1 0x5647a3ea4432 in b::main::h5574a756e615c9cf (/tmp/b+0xb8432)\n-    #2 0x5647a3ea480b in std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::hd57e7ee01866077e (/tmp/b+0xb880b)\n-    #3 0x5647a3eab412 in std::panicking::try::do_call::he0421ca82dd11ba3 (.llvm.8083791802951296215) (/tmp/b+0xbf412)\n-    #4 0x5647a3eacb26 in __rust_maybe_catch_panic (/tmp/b+0xc0b26)\n-    #5 0x5647a3ea5b66 in std::rt::lang_start_internal::h19bc96b28f670a64 (/tmp/b+0xb9b66)\n-    #6 0x5647a3ea4788 in std::rt::lang_start::h642d10b4b6965fb8 (/tmp/b+0xb8788)\n-    #7 0x5647a3ea449a in main (/tmp/b+0xb849a)\n-    #8 0x7fd1d18b3bba in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x26bba)\n-    #9 0x5647a3df7299 in _start (/tmp/b+0xb299)\n-\n-Address 0x7fff67be6be0 is located in stack of thread T0 at offset 32 in frame\n-    #0 0x5647a3ea433f in b::main::h5574a756e615c9cf (/tmp/b+0xb833f)\n+==39249==ERROR: AddressSanitizer: stack-use-after-scope on address 0x7ffc7ed3e1a0 at pc 0x55c98b262a8e bp 0x7ffc7ed3e050 sp 0x7ffc7ed3e048\n+WRITE of size 8 at 0x7ffc7ed3e1a0 thread T0\n+    #0 0x55c98b262a8d in core::ptr::write_volatile::he21f1df5a82f329a /.../src/rust/src/libcore/ptr/mod.rs:1048:5\n+    #1 0x55c98b262cd2 in example::main::h628ffc6626ed85b2 /.../src/main.rs:9:9\n+    ...\n+\n+Address 0x7ffc7ed3e1a0 is located in stack of thread T0 at offset 32 in frame\n+    #0 0x55c98b262bdf in example::main::h628ffc6626ed85b2 /.../src/main.rs:3\n \n   This frame has 1 object(s):\n-    [32, 40) 'x' <== Memory access at offset 32 is inside this variable\n+    [32, 40) 'x' (line 6) <== Memory access at offset 32 is inside this variable\n HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork\n       (longjmp and C++ exceptions *are* supported)\n-SUMMARY: AddressSanitizer: stack-use-after-scope (/tmp/b+0xb8657) in core::ptr::write_volatile::h4b04601757d0376d\n+SUMMARY: AddressSanitizer: stack-use-after-scope /.../src/rust/src/libcore/ptr/mod.rs:1048:5 in core::ptr::write_volatile::he21f1df5a82f329a\n Shadow bytes around the buggy address:\n-  0x10006cf74d20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-=>0x10006cf74d70: 00 00 00 00 00 00 00 00 f1 f1 f1 f1[f8]f3 f3 f3\n-  0x10006cf74d80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74d90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74da0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74db0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n-  0x10006cf74dc0: f1 f1 f1 f1 00 f3 f3 f3 00 00 00 00 00 00 00 00\n+  0x10000fd9fbe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fbf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc00: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x10000fd9fc10: f8 f8 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+=>0x10000fd9fc30: f1 f1 f1 f1[f8]f3 f3 f3 00 00 00 00 00 00 00 00\n+  0x10000fd9fc40: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1\n+  0x10000fd9fc50: 00 00 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc60: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3\n+  0x10000fd9fc70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n+  0x10000fd9fc80: 00 00 00 00 f1 f1 f1 f1 00 00 f3 f3 00 00 00 00\n Shadow byte legend (one shadow byte represents 8 application bytes):\n   Addressable:           00\n   Partially addressable: 01 02 03 04 05 06 07\n@@ -164,17 +164,26 @@ Shadow byte legend (one shadow byte represents 8 application bytes):\n   Left alloca redzone:     ca\n   Right alloca redzone:    cb\n   Shadow gap:              cc\n-==424427==ABORTING\n+==39249==ABORTING\n ```\n \n-## MemorySanitizer\n+# MemorySanitizer\n+\n+MemorySanitizer is detector of uninitialized reads. It is only supported on the\n+`x86_64-unknown-linux-gnu` target.\n+\n+MemorySanitizer requires all program code to be instrumented. C/C++ dependencies\n+need to be recompiled using Clang with `-fsanitize=memory` option. Failing to\n+achieve that will result in false positive reports.\n+\n+## Example\n \n-Use of uninitialized memory. Note that we are using `-Zbuild-std` to instrument\n-the standard library, and passing `-Zsanitizer-track-origins` to track the\n+Detecting the use of uninitialized memory. The `-Zbuild-std` flag rebuilds and\n+instruments the standard library, and is strictly necessary for the correct\n+operation of the tool. The `-Zsanitizer-track-origins` enables tracking of the\n origins of uninitialized memory:\n \n-```shell\n-$ cat src/main.rs\n+```rust\n use std::mem::MaybeUninit;\n \n fn main() {\n@@ -184,7 +193,9 @@ fn main() {\n         println!(\"{}\", a[2]);\n     }\n }\n+```\n \n+```shell\n $ export \\\n   CC=clang \\\n   CXX=clang++ \\\n@@ -193,7 +204,7 @@ $ export \\\n   RUSTFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins' \\\n   RUSTDOCFLAGS='-Zsanitizer=memory -Zsanitizer-memory-track-origins'\n $ cargo clean\n-$ cargo -Zbuild-std run --target x86_64-unknown-linux-gnu\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n ==9416==WARNING: MemorySanitizer: use-of-uninitialized-value\n     #0 0x560c04f7488a in core::fmt::num::imp::fmt_u64::haa293b0b098501ca $RUST/build/x86_64-unknown-linux-gnu/stage1/lib/rustlib/src/rust/src/libcore/fmt/num.rs:202:16\n ...\n@@ -205,6 +216,55 @@ $ cargo -Zbuild-std run --target x86_64-unknown-linux-gnu\n     #0 0x560c04b2bc50 in memory::main::hd2333c1899d997f5 $CWD/src/main.rs:3\n ```\n \n+# ThreadSanitizer\n+\n+ThreadSanitizer is a data race detection tool. It is supported on the following\n+targets:\n+\n+* `x86_64-apple-darwin`\n+* `x86_64-unknown-linux-gnu`\n+\n+To work correctly ThreadSanitizer needs to be \"aware\" of all synchronization\n+operations in a program. It generally achieves that through combination of\n+library interception (for example synchronization performed through\n+`pthread_mutex_lock` / `pthread_mutex_unlock`) and compile time instrumentation\n+(e.g. atomic operations). Using it without instrumenting all the program code\n+can lead to false positive reports.\n+\n+ThreadSanitizer does not support atomic fences `std::sync::atomic::fence`,\n+nor synchronization performed using inline assembly code.\n+\n+## Example\n+\n+```rust\n+static mut A: usize = 0;\n+\n+fn main() {\n+    let t = std::thread::spawn(|| {\n+        unsafe { A += 1 };\n+    });\n+    unsafe { A += 1 };\n+\n+    t.join().unwrap();\n+}\n+```\n+\n+```shell\n+$ export RUSTFLAGS=-Zsanitizer=thread RUSTDOCFLAGS=-Zsanitizer=thread\n+$ cargo run -Zbuild-std --target x86_64-unknown-linux-gnu\n+==================\n+WARNING: ThreadSanitizer: data race (pid=10574)\n+  Read of size 8 at 0x5632dfe3d030 by thread T1:\n+    #0 example::main::_$u7b$$u7b$closure$u7d$$u7d$::h23f64b0b2f8c9484 ../src/main.rs:5:18 (example+0x86cec)\n+    ...\n+\n+  Previous write of size 8 at 0x5632dfe3d030 by main thread:\n+    #0 example::main::h628ffc6626ed85b2 /.../src/main.rs:7:14 (example+0x868c8)\n+    ...\n+    #11 main <null> (example+0x86a1a)\n+\n+  Location is global 'example::A::h43ac149ddf992709' of size 8 at 0x5632dfe3d030 (example+0x000000bd9030)\n+```\n \n # Instrumentation of external dependencies and std\n \n@@ -231,6 +291,10 @@ In more practical terms when using cargo always remember to pass `--target`\n flag, so that rustflags will not be applied to build scripts and procedural\n macros.\n \n+# Symbolizing the Reports\n+\n+Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in `PATH`.\n+\n # Additional Information\n \n * [Sanitizers project page](https://github.com/google/sanitizers/wiki/)"}, {"sha": "94532521a9066150bf3452466625847e5ddcceea", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 153, "deletions": 52, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=a5b09d35473615e7142f5570f5c5fad0caf68bd2", "patch": "@@ -959,6 +959,9 @@ impl<T> VecDeque<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     ///\n+    /// If [`make_contiguous`](#method.make_contiguous) was previously called, all elements\n+    /// of the `VecDeque` will be in the first slice and the second slice will be empty.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -989,6 +992,9 @@ impl<T> VecDeque<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     ///\n+    /// If [`make_contiguous`](#method.make_contiguous) was previously called, all elements\n+    /// of the `VecDeque` will be in the first slice and the second slice will be empty.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2044,6 +2050,148 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Rearranges the internal storage of this deque so it is one contiguous slice, which is then returned.\n+    ///\n+    /// This method does not allocate and does not change the order of the inserted elements.\n+    /// As it returns a mutable slice, this can be used to sort or binary search a deque.\n+    ///\n+    /// Once the internal storage is contiguous, the [`as_slices`](#method.as_slices) and\n+    /// [`as_mut_slices`](#method.as_mut_slices) methods will return the entire contents of the\n+    /// `VecDeque` in a single slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Sorting the content of a deque.\n+    ///\n+    /// ```\n+    /// #![feature(deque_make_contiguous)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::with_capacity(15);\n+    ///\n+    /// buf.push_back(2);\n+    /// buf.push_back(1);\n+    /// buf.push_front(3);\n+    ///\n+    /// // sorting the deque\n+    /// buf.make_contiguous().sort();\n+    /// assert_eq!(buf.as_slices(), (&[1, 2, 3] as &[_], &[] as &[_]));\n+    ///\n+    /// // sorting it in reverse order\n+    /// buf.make_contiguous().sort_by(|a, b| b.cmp(a));\n+    /// assert_eq!(buf.as_slices(), (&[3, 2, 1] as &[_], &[] as &[_]));\n+    /// ```\n+    ///\n+    /// Getting immutable access to the contiguous slice.\n+    ///\n+    /// ```rust\n+    /// #![feature(deque_make_contiguous)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    ///\n+    /// buf.push_back(2);\n+    /// buf.push_back(1);\n+    /// buf.push_front(3);\n+    ///\n+    /// buf.make_contiguous();\n+    /// if let (slice, &[]) = buf.as_slices() {\n+    ///     // we can now be sure that `slice` contains all elements of the deque,\n+    ///     // while still having immutable access to `buf`.\n+    ///     assert_eq!(buf.len(), slice.len());\n+    ///     assert_eq!(slice, &[3, 2, 1] as &[_]);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"deque_make_contiguous\", issue = \"none\")]\n+    pub fn make_contiguous(&mut self) -> &mut [T] {\n+        if self.is_contiguous() {\n+            let tail = self.tail;\n+            let head = self.head;\n+            return unsafe { &mut self.buffer_as_mut_slice()[tail..head] };\n+        }\n+\n+        let buf = self.buf.ptr();\n+        let cap = self.cap();\n+        let len = self.len();\n+\n+        let free = self.tail - self.head;\n+        let tail_len = cap - self.tail;\n+\n+        if free >= tail_len {\n+            // there is enough free space to copy the tail in one go,\n+            // this means that we first shift the head backwards, and then\n+            // copy the tail to the correct position.\n+            //\n+            // from: DEFGH....ABC\n+            // to:   ABCDEFGH....\n+            unsafe {\n+                ptr::copy(buf, buf.add(tail_len), self.head);\n+                // ...DEFGH.ABC\n+                ptr::copy_nonoverlapping(buf.add(self.tail), buf, tail_len);\n+                // ABCDEFGH....\n+\n+                self.tail = 0;\n+                self.head = len;\n+            }\n+        } else if free >= self.head {\n+            // there is enough free space to copy the head in one go,\n+            // this means that we first shift the tail forwards, and then\n+            // copy the head to the correct position.\n+            //\n+            // from: FGH....ABCDE\n+            // to:   ...ABCDEFGH.\n+            unsafe {\n+                ptr::copy(buf.add(self.tail), buf.add(self.head), tail_len);\n+                // FGHABCDE....\n+                ptr::copy_nonoverlapping(buf, buf.add(self.head + tail_len), self.head);\n+                // ...ABCDEFGH.\n+\n+                self.tail = self.head;\n+                self.head = self.tail + len;\n+            }\n+        } else {\n+            // free is smaller than both head and tail,\n+            // this means we have to slowly \"swap\" the tail and the head.\n+            //\n+            // from: EFGHI...ABCD or HIJK.ABCDEFG\n+            // to:   ABCDEFGHI... or ABCDEFGHIJK.\n+            let mut left_edge: usize = 0;\n+            let mut right_edge: usize = self.tail;\n+            unsafe {\n+                // The general problem looks like this\n+                // GHIJKLM...ABCDEF - before any swaps\n+                // ABCDEFM...GHIJKL - after 1 pass of swaps\n+                // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n+                //                  - then restart the algorithm with a new (smaller) store\n+                // Sometimes the temp store is reached when the right edge is at the end\n+                // of the buffer - this means we've hit the right order with fewer swaps!\n+                // E.g\n+                // EF..ABCD\n+                // ABCDEF.. - after four only swaps we've finished\n+                while left_edge < len && right_edge != cap {\n+                    let mut right_offset = 0;\n+                    for i in left_edge..right_edge {\n+                        right_offset = (i - left_edge) % (cap - right_edge);\n+                        let src: isize = (right_edge + right_offset) as isize;\n+                        ptr::swap(buf.add(i), buf.offset(src));\n+                    }\n+                    let n_ops = right_edge - left_edge;\n+                    left_edge += n_ops;\n+                    right_edge += right_offset + 1;\n+                }\n+\n+                self.tail = 0;\n+                self.head = len;\n+            }\n+        }\n+\n+        let tail = self.tail;\n+        let head = self.head;\n+        unsafe { &mut self.buffer_as_mut_slice()[tail..head] }\n+    }\n+\n     /// Rotates the double-ended queue `mid` places to the left.\n     ///\n     /// Equivalently,\n@@ -2803,63 +2951,16 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     /// assert_eq!(vec, [8, 9, 1, 2, 3, 4]);\n     /// assert_eq!(vec.as_ptr(), ptr);\n     /// ```\n-    fn from(other: VecDeque<T>) -> Self {\n+    fn from(mut other: VecDeque<T>) -> Self {\n+        other.make_contiguous();\n+\n         unsafe {\n             let buf = other.buf.ptr();\n             let len = other.len();\n-            let tail = other.tail;\n-            let head = other.head;\n             let cap = other.cap();\n \n-            // Need to move the ring to the front of the buffer, as vec will expect this.\n-            if other.is_contiguous() {\n-                ptr::copy(buf.add(tail), buf, len);\n-            } else {\n-                if (tail - head) >= cmp::min(cap - tail, head) {\n-                    // There is enough free space in the centre for the shortest block so we can\n-                    // do this in at most three copy moves.\n-                    if (cap - tail) > head {\n-                        // right hand block is the long one; move that enough for the left\n-                        ptr::copy(buf.add(tail), buf.add(tail - head), cap - tail);\n-                        // copy left in the end\n-                        ptr::copy(buf, buf.add(cap - head), head);\n-                        // shift the new thing to the start\n-                        ptr::copy(buf.add(tail - head), buf, len);\n-                    } else {\n-                        // left hand block is the long one, we can do it in two!\n-                        ptr::copy(buf, buf.add(cap - tail), head);\n-                        ptr::copy(buf.add(tail), buf, cap - tail);\n-                    }\n-                } else {\n-                    // Need to use N swaps to move the ring\n-                    // We can use the space at the end of the ring as a temp store\n-\n-                    let mut left_edge: usize = 0;\n-                    let mut right_edge: usize = tail;\n-\n-                    // The general problem looks like this\n-                    // GHIJKLM...ABCDEF - before any swaps\n-                    // ABCDEFM...GHIJKL - after 1 pass of swaps\n-                    // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n-                    //                  - then restart the algorithm with a new (smaller) store\n-                    // Sometimes the temp store is reached when the right edge is at the end\n-                    // of the buffer - this means we've hit the right order with fewer swaps!\n-                    // E.g\n-                    // EF..ABCD\n-                    // ABCDEF.. - after four only swaps we've finished\n-\n-                    while left_edge < len && right_edge != cap {\n-                        let mut right_offset = 0;\n-                        for i in left_edge..right_edge {\n-                            right_offset = (i - left_edge) % (cap - right_edge);\n-                            let src: isize = (right_edge + right_offset) as isize;\n-                            ptr::swap(buf.add(i), buf.offset(src));\n-                        }\n-                        let n_ops = right_edge - left_edge;\n-                        left_edge += n_ops;\n-                        right_edge += right_offset + 1;\n-                    }\n-                }\n+            if other.head != 0 {\n+                ptr::copy(buf.add(other.tail), buf, len);\n             }\n             let out = Vec::from_raw_parts(buf, len, cap);\n             mem::forget(other);"}, {"sha": "8ef5ec78e056e8a2d72b3402a4d73503b0e4f3c2", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=a5b09d35473615e7142f5570f5c5fad0caf68bd2", "patch": "@@ -1,6 +1,6 @@\n use super::*;\n \n-use ::test;\n+use test;\n \n #[bench]\n #[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n@@ -130,6 +130,87 @@ fn test_insert() {\n     }\n }\n \n+#[test]\n+fn make_contiguous_big_tail() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 0..3 {\n+        tester.push_back(i);\n+    }\n+\n+    for i in 3..10 {\n+        tester.push_front(i);\n+    }\n+\n+    // 012......9876543\n+    assert_eq!(tester.capacity(), 15);\n+    assert_eq!((&[9, 8, 7, 6, 5, 4, 3] as &[_], &[0, 1, 2] as &[_]), tester.as_slices());\n+\n+    let expected_start = tester.head;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!((&[9, 8, 7, 6, 5, 4, 3, 0, 1, 2] as &[_], &[] as &[_]), tester.as_slices());\n+}\n+\n+#[test]\n+fn make_contiguous_big_head() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 0..8 {\n+        tester.push_back(i);\n+    }\n+\n+    for i in 8..10 {\n+        tester.push_front(i);\n+    }\n+\n+    // 01234567......98\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!((&[9, 8, 0, 1, 2, 3, 4, 5, 6, 7] as &[_], &[] as &[_]), tester.as_slices());\n+}\n+\n+#[test]\n+fn make_contiguous_small_free() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 'A' as u8..'I' as u8 {\n+        tester.push_back(i as char);\n+    }\n+\n+    for i in 'I' as u8..'N' as u8 {\n+        tester.push_front(i as char);\n+    }\n+\n+    // ABCDEFGH...MLKJI\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(\n+        (&['M', 'L', 'K', 'J', 'I', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] as &[_], &[] as &[_]),\n+        tester.as_slices()\n+    );\n+\n+    tester.clear();\n+    for i in 'I' as u8..'N' as u8 {\n+        tester.push_back(i as char);\n+    }\n+\n+    for i in 'A' as u8..'I' as u8 {\n+        tester.push_front(i as char);\n+    }\n+\n+    // IJKLM...HGFEDCBA\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(\n+        (&['H', 'G', 'F', 'E', 'D', 'C', 'B', 'A', 'I', 'J', 'K', 'L', 'M'] as &[_], &[] as &[_]),\n+        tester.as_slices()\n+    );\n+}\n+\n #[test]\n fn test_remove() {\n     // This test checks that every single combination of tail position, length, and"}, {"sha": "7aefedbc0875d7dc7412e3b11c25684beb89c96a", "filename": "src/librustc_error_codes/error_codes/E0466.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Flibrustc_error_codes%2Ferror_codes%2FE0466.md", "raw_url": "https://github.com/rust-lang/rust/raw/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Flibrustc_error_codes%2Ferror_codes%2FE0466.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0466.md?ref=a5b09d35473615e7142f5570f5c5fad0caf68bd2", "patch": "@@ -1,4 +1,4 @@\n-Macro import declarations were malformed.\n+Macro import declaration was malformed.\n \n Erroneous code examples:\n "}, {"sha": "f1ddf3c635f7a4d870fb464342f56894c94c8497", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=a5b09d35473615e7142f5570f5c5fad0caf68bd2", "patch": "@@ -274,19 +274,16 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _memory_extra: &(),\n         _alloc_id: AllocId,\n         allocation: &Allocation<Self::PointerTag, Self::AllocExtra>,\n-        static_def_id: Option<DefId>,\n+        _static_def_id: Option<DefId>,\n         is_write: bool,\n     ) -> InterpResult<'tcx> {\n         if is_write {\n             throw_machine_stop_str!(\"can't write to global\");\n         }\n-        // If the static allocation is mutable or if it has relocations (it may be legal to mutate\n-        // the memory behind that in the future), then we can't const prop it.\n+        // If the static allocation is mutable, then we can't const prop it as its content\n+        // might be different at runtime.\n         if allocation.mutability == Mutability::Mut {\n-            throw_machine_stop_str!(\"can't eval mutable globals in ConstProp\");\n-        }\n-        if static_def_id.is_some() && allocation.relocations().len() > 0 {\n-            throw_machine_stop_str!(\"can't eval statics with pointers in ConstProp\");\n+            throw_machine_stop_str!(\"can't access mutable globals in ConstProp\");\n         }\n \n         Ok(())"}, {"sha": "f9e9a07914d692efc378f74b41ae61f5a73bde8d", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 63, "deletions": 40, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a5b09d35473615e7142f5570f5c5fad0caf68bd2", "patch": "@@ -13,6 +13,7 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, FileName, Pos, Span, DUMMY_SP};\n use rustc_target::spec::TargetTriple;\n+use std::collections::HashMap;\n use std::env;\n use std::io::{self, Write};\n use std::panic;\n@@ -190,10 +191,23 @@ enum TestFailure {\n     UnexpectedRunPass,\n }\n \n+enum DirState {\n+    Temp(tempfile::TempDir),\n+    Perm(PathBuf),\n+}\n+\n+impl DirState {\n+    fn path(&self) -> &std::path::Path {\n+        match self {\n+            DirState::Temp(t) => t.path(),\n+            DirState::Perm(p) => p.as_path(),\n+        }\n+    }\n+}\n+\n fn run_test(\n     test: &str,\n     cratename: &str,\n-    filename: &FileName,\n     line: usize,\n     options: Options,\n     should_panic: bool,\n@@ -206,47 +220,11 @@ fn run_test(\n     mut error_codes: Vec<String>,\n     opts: &TestOptions,\n     edition: Edition,\n+    outdir: DirState,\n+    path: PathBuf,\n ) -> Result<(), TestFailure> {\n     let (test, line_offset) = make_test(test, Some(cratename), as_test_harness, opts, edition);\n \n-    // FIXME(#44940): if doctests ever support path remapping, then this filename\n-    // needs to be the result of `SourceMap::span_to_unmapped_path`.\n-    let path = match filename {\n-        FileName::Real(path) => path.clone(),\n-        _ => PathBuf::from(r\"doctest.rs\"),\n-    };\n-\n-    enum DirState {\n-        Temp(tempfile::TempDir),\n-        Perm(PathBuf),\n-    }\n-\n-    impl DirState {\n-        fn path(&self) -> &std::path::Path {\n-            match self {\n-                DirState::Temp(t) => t.path(),\n-                DirState::Perm(p) => p.as_path(),\n-            }\n-        }\n-    }\n-\n-    let outdir = if let Some(mut path) = options.persist_doctests {\n-        path.push(format!(\n-            \"{}_{}\",\n-            filename.to_string().rsplit('/').next().unwrap().replace(\".\", \"_\"),\n-            line\n-        ));\n-        std::fs::create_dir_all(&path).expect(\"Couldn't create directory for doctest executables\");\n-\n-        DirState::Perm(path)\n-    } else {\n-        DirState::Temp(\n-            TempFileBuilder::new()\n-                .prefix(\"rustdoctest\")\n-                .tempdir()\n-                .expect(\"rustdoc needs a tempdir\"),\n-        )\n-    };\n     let output_file = outdir.path().join(\"rust_out\");\n \n     let rustc_binary = options\n@@ -639,6 +617,7 @@ pub struct Collector {\n     position: Span,\n     source_map: Option<Lrc<SourceMap>>,\n     filename: Option<PathBuf>,\n+    visited_tests: HashMap<(String, usize), usize>,\n }\n \n impl Collector {\n@@ -662,6 +641,7 @@ impl Collector {\n             position: DUMMY_SP,\n             source_map,\n             filename,\n+            visited_tests: HashMap::new(),\n         }\n     }\n \n@@ -705,6 +685,48 @@ impl Tester for Collector {\n         let target = self.options.target.clone();\n         let target_str = target.to_string();\n \n+        // FIXME(#44940): if doctests ever support path remapping, then this filename\n+        // needs to be the result of `SourceMap::span_to_unmapped_path`.\n+        let path = match &filename {\n+            FileName::Real(path) => path.clone(),\n+            _ => PathBuf::from(r\"doctest.rs\"),\n+        };\n+\n+        let outdir = if let Some(mut path) = options.persist_doctests.clone() {\n+            // For example `module/file.rs` would become `module_file_rs`\n+            let folder_name = filename\n+                .to_string()\n+                .chars()\n+                .map(|c| if c == '/' || c == '.' { '_' } else { c })\n+                .collect::<String>();\n+\n+            path.push(format!(\n+                \"{name}_{line}_{number}\",\n+                name = folder_name,\n+                number = {\n+                    // Increases the current test number, if this file already\n+                    // exists or it creates a new entry with a test number of 0.\n+                    self.visited_tests\n+                        .entry((folder_name.clone(), line))\n+                        .and_modify(|v| *v += 1)\n+                        .or_insert(0)\n+                },\n+                line = line,\n+            ));\n+\n+            std::fs::create_dir_all(&path)\n+                .expect(\"Couldn't create directory for doctest executables\");\n+\n+            DirState::Perm(path)\n+        } else {\n+            DirState::Temp(\n+                TempFileBuilder::new()\n+                    .prefix(\"rustdoctest\")\n+                    .tempdir()\n+                    .expect(\"rustdoc needs a tempdir\"),\n+            )\n+        };\n+\n         debug!(\"creating test {}: {}\", name, test);\n         self.tests.push(testing::TestDescAndFn {\n             desc: testing::TestDesc {\n@@ -723,7 +745,6 @@ impl Tester for Collector {\n                 let res = run_test(\n                     &test,\n                     &cratename,\n-                    &filename,\n                     line,\n                     options,\n                     config.should_panic,\n@@ -736,6 +757,8 @@ impl Tester for Collector {\n                     config.error_codes,\n                     &opts,\n                     edition,\n+                    outdir,\n+                    path,\n                 );\n \n                 if let Err(err) = res {"}, {"sha": "896651361be2ae3533c607694a4ba240fe1087fa", "filename": "src/test/ui/intrinsics/intrinsic-alignment.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-alignment.rs?ref=a5b09d35473615e7142f5570f5c5fad0caf68bd2", "patch": "@@ -56,16 +56,6 @@ mod m {\n #[cfg(target_os = \"windows\")]\n mod m {\n     #[main]\n-    #[cfg(target_arch = \"x86\")]\n-    pub fn main() {\n-        unsafe {\n-            assert_eq!(::rusti::pref_align_of::<u64>(), 8);\n-            assert_eq!(::rusti::min_align_of::<u64>(), 8);\n-        }\n-    }\n-\n-    #[main]\n-    #[cfg(target_arch = \"x86_64\")]\n     pub fn main() {\n         unsafe {\n             assert_eq!(::rusti::pref_align_of::<u64>(), 8);"}, {"sha": "b06e204d31bf036627761b8235956bea9329b76a", "filename": "src/test/ui/structs-enums/rec-align-u64.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Ftest%2Fui%2Fstructs-enums%2Frec-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5b09d35473615e7142f5570f5c5fad0caf68bd2/src%2Ftest%2Fui%2Fstructs-enums%2Frec-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Frec-align-u64.rs?ref=a5b09d35473615e7142f5570f5c5fad0caf68bd2", "patch": "@@ -67,13 +67,6 @@ mod m {\n \n #[cfg(target_os = \"windows\")]\n mod m {\n-    #[cfg(target_arch = \"x86\")]\n-    pub mod m {\n-        pub fn align() -> usize { 8 }\n-        pub fn size() -> usize { 16 }\n-    }\n-\n-    #[cfg(target_arch = \"x86_64\")]\n     pub mod m {\n         pub fn align() -> usize { 8 }\n         pub fn size() -> usize { 16 }"}]}