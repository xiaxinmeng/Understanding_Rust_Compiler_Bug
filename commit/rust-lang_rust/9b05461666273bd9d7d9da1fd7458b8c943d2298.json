{"sha": "9b05461666273bd9d7d9da1fd7458b8c943d2298", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMDU0NjE2NjYyNzNiZDlkN2Q5ZGExZmQ3NDU4YjhjOTQzZDIyOTg=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-05-15T09:41:05Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2016-05-15T09:41:05Z"}, "message": "Write each file as it is formatted (#991)\n\nThe old behaviour stored everything in memory until we were finished. Now we write as soon as we can.\r\n\r\nThis gives better behaviour when formatting large programs, since there is some progress indication. It also opens the door to optimising memory use by not storing everything in memory unless it is required (which it still might be). That is left as future work though.", "tree": {"sha": "5276bec3d6100b928fc5bbef0cf83bb85029fc84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5276bec3d6100b928fc5bbef0cf83bb85029fc84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b05461666273bd9d7d9da1fd7458b8c943d2298", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b05461666273bd9d7d9da1fd7458b8c943d2298", "html_url": "https://github.com/rust-lang/rust/commit/9b05461666273bd9d7d9da1fd7458b8c943d2298", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b05461666273bd9d7d9da1fd7458b8c943d2298/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67edc325c6c35475593ac54d3704f474c09d059e", "url": "https://api.github.com/repos/rust-lang/rust/commits/67edc325c6c35475593ac54d3704f474c09d059e", "html_url": "https://github.com/rust-lang/rust/commit/67edc325c6c35475593ac54d3704f474c09d059e"}], "stats": {"total": 254, "additions": 143, "deletions": 111}, "files": [{"sha": "162e9160f85c9b5506919ef9ac34ef8204c65127", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b05461666273bd9d7d9da1fd7458b8c943d2298/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9b05461666273bd9d7d9da1fd7458b8c943d2298/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9b05461666273bd9d7d9da1fd7458b8c943d2298", "patch": "@@ -1,6 +1,6 @@\n [root]\n name = \"rustfmt\"\n-version = \"0.4.0\"\n+version = \"0.5.0\"\n dependencies = [\n  \"diff 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "17abc6f76e74f09f9702756806acf360495b651b", "filename": "src/filemap.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9b05461666273bd9d7d9da1fd7458b8c943d2298/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b05461666273bd9d7d9da1fd7458b8c943d2298/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=9b05461666273bd9d7d9da1fd7458b8c943d2298", "patch": "@@ -13,7 +13,6 @@\n \n use strings::string_buffer::StringBuffer;\n \n-use std::collections::HashMap;\n use std::fs::{self, File};\n use std::io::{self, Write, Read, stdout, BufWriter};\n \n@@ -22,28 +21,27 @@ use rustfmt_diff::{make_diff, print_diff, Mismatch};\n use checkstyle::{output_header, output_footer, output_checkstyle_file};\n \n // A map of the files of a crate, with their new content\n-pub type FileMap = HashMap<String, StringBuffer>;\n+pub type FileMap = Vec<FileRecord>;\n+\n+pub type FileRecord = (String, StringBuffer);\n \n // Append a newline to the end of each file.\n-pub fn append_newlines(file_map: &mut FileMap) {\n-    for (_, s) in file_map.iter_mut() {\n-        s.push_str(\"\\n\");\n-    }\n+pub fn append_newline(s: &mut StringBuffer) {\n+    s.push_str(\"\\n\");\n }\n \n pub fn write_all_files<T>(file_map: &FileMap, out: &mut T, config: &Config) -> Result<(), io::Error>\n     where T: Write\n {\n     output_header(out, config.write_mode).ok();\n-    for filename in file_map.keys() {\n-        try!(write_file(&file_map[filename], filename, out, config));\n+    for &(ref filename, ref text) in file_map {\n+        try!(write_file(text, filename, out, config));\n     }\n     output_footer(out, config.write_mode).ok();\n \n     Ok(())\n }\n \n-\n // Prints all newlines either as `\\n` or as `\\r\\n`.\n pub fn write_system_newlines<T>(writer: T,\n                                 text: &StringBuffer,"}, {"sha": "12258ada15c8d1733d35eb8da6840564bb91636c", "filename": "src/lib.rs", "status": "modified", "additions": 120, "deletions": 96, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/9b05461666273bd9d7d9da1fd7458b8c943d2298/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b05461666273bd9d7d9da1fd7458b8c943d2298/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=9b05461666273bd9d7d9da1fd7458b8c943d2298", "patch": "@@ -31,7 +31,9 @@ use syntax::errors::{Handler, DiagnosticBuilder};\n use syntax::errors::emitter::{ColorConfig, EmitterWriter};\n use syntax::parse::{self, ParseSess};\n \n-use std::io::{stdout, Write};\n+use strings::string_buffer::StringBuffer;\n+\n+use std::io::{self, stdout, Write};\n use std::ops::{Add, Sub};\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n@@ -42,6 +44,7 @@ use issues::{BadIssueSeeker, Issue};\n use filemap::FileMap;\n use visitor::FmtVisitor;\n use config::Config;\n+use checkstyle::{output_header, output_footer};\n \n pub use self::summary::Summary;\n \n@@ -274,12 +277,16 @@ impl fmt::Display for FormatReport {\n }\n \n // Formatting which depends on the AST.\n-fn format_ast(krate: &ast::Crate,\n-              parse_session: &ParseSess,\n-              main_file: &Path,\n-              config: &Config)\n-              -> FileMap {\n-    let mut file_map = FileMap::new();\n+fn format_ast<F>(krate: &ast::Crate,\n+                 parse_session: &ParseSess,\n+                 main_file: &Path,\n+                 config: &Config,\n+                 mut after_file: F)\n+                 -> Result<FileMap, io::Error>\n+    where F: FnMut(&str, &mut StringBuffer) -> Result<(), io::Error>\n+{\n+    let mut result = FileMap::new();\n+\n     // We always skip children for the \"Plain\" write mode, since there is\n     // nothing to distinguish the nested module contents.\n     let skip_children = config.skip_children || config.write_mode == config::WriteMode::Plain;\n@@ -293,92 +300,86 @@ fn format_ast(krate: &ast::Crate,\n         }\n         let mut visitor = FmtVisitor::from_codemap(parse_session, config);\n         visitor.format_separate_mod(module);\n-        file_map.insert(path.to_owned(), visitor.buffer);\n+\n+        try!(after_file(path, &mut visitor.buffer));\n+\n+        result.push((path.to_owned(), visitor.buffer));\n     }\n-    file_map\n+\n+    Ok(result)\n }\n \n // Formatting done on a char by char or line by line basis.\n-// TODO(#209) warn on bad license\n-// TODO(#20) other stuff for parity with make tidy\n-fn format_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n-    let mut truncate_todo = Vec::new();\n-    let mut report = FormatReport::new();\n-\n+// FIXME(#209) warn on bad license\n+// FIXME(#20) other stuff for parity with make tidy\n+fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &mut FormatReport) {\n     // Iterate over the chars in the file map.\n-    for (f, text) in file_map.iter() {\n-        let mut trims = vec![];\n-        let mut last_wspace: Option<usize> = None;\n-        let mut line_len = 0;\n-        let mut cur_line = 1;\n-        let mut newline_count = 0;\n-        let mut errors = vec![];\n-        let mut issue_seeker = BadIssueSeeker::new(config.report_todo, config.report_fixme);\n-\n-        for (c, b) in text.chars() {\n-            if c == '\\r' {\n-                line_len += c.len_utf8();\n-                continue;\n-            }\n+    let mut trims = vec![];\n+    let mut last_wspace: Option<usize> = None;\n+    let mut line_len = 0;\n+    let mut cur_line = 1;\n+    let mut newline_count = 0;\n+    let mut errors = vec![];\n+    let mut issue_seeker = BadIssueSeeker::new(config.report_todo, config.report_fixme);\n+\n+    for (c, b) in text.chars() {\n+        if c == '\\r' {\n+            line_len += c.len_utf8();\n+            continue;\n+        }\n \n-            // Add warnings for bad todos/ fixmes\n-            if let Some(issue) = issue_seeker.inspect(c) {\n+        // Add warnings for bad todos/ fixmes\n+        if let Some(issue) = issue_seeker.inspect(c) {\n+            errors.push(FormattingError {\n+                line: cur_line,\n+                kind: ErrorKind::BadIssue(issue),\n+            });\n+        }\n+\n+        if c == '\\n' {\n+            // Check for (and record) trailing whitespace.\n+            if let Some(lw) = last_wspace {\n+                trims.push((cur_line, lw, b));\n+                line_len -= b - lw;\n+            }\n+            // Check for any line width errors we couldn't correct.\n+            if line_len > config.max_width {\n                 errors.push(FormattingError {\n                     line: cur_line,\n-                    kind: ErrorKind::BadIssue(issue),\n+                    kind: ErrorKind::LineOverflow,\n                 });\n             }\n-\n-            if c == '\\n' {\n-                // Check for (and record) trailing whitespace.\n-                if let Some(lw) = last_wspace {\n-                    trims.push((cur_line, lw, b));\n-                    line_len -= b - lw;\n-                }\n-                // Check for any line width errors we couldn't correct.\n-                if line_len > config.max_width {\n-                    errors.push(FormattingError {\n-                        line: cur_line,\n-                        kind: ErrorKind::LineOverflow,\n-                    });\n+            line_len = 0;\n+            cur_line += 1;\n+            newline_count += 1;\n+            last_wspace = None;\n+        } else {\n+            newline_count = 0;\n+            line_len += c.len_utf8();\n+            if c.is_whitespace() {\n+                if last_wspace.is_none() {\n+                    last_wspace = Some(b);\n                 }\n-                line_len = 0;\n-                cur_line += 1;\n-                newline_count += 1;\n-                last_wspace = None;\n             } else {\n-                newline_count = 0;\n-                line_len += c.len_utf8();\n-                if c.is_whitespace() {\n-                    if last_wspace.is_none() {\n-                        last_wspace = Some(b);\n-                    }\n-                } else {\n-                    last_wspace = None;\n-                }\n+                last_wspace = None;\n             }\n         }\n+    }\n \n-        if newline_count > 1 {\n-            debug!(\"track truncate: {} {} {}\", f, text.len, newline_count);\n-            truncate_todo.push((f.to_owned(), text.len - newline_count + 1))\n-        }\n-\n-        for &(l, _, _) in &trims {\n-            errors.push(FormattingError {\n-                line: l,\n-                kind: ErrorKind::TrailingWhitespace,\n-            });\n-        }\n-\n-        report.file_error_map.insert(f.to_owned(), errors);\n+    if newline_count > 1 {\n+        debug!(\"track truncate: {} {}\", text.len, newline_count);\n+        let line = text.len - newline_count + 1;\n+        text.truncate(line);\n     }\n \n-    for (f, l) in truncate_todo {\n-        file_map.get_mut(&f).unwrap().truncate(l);\n+    for &(l, _, _) in &trims {\n+        errors.push(FormattingError {\n+            line: l,\n+            kind: ErrorKind::TrailingWhitespace,\n+        });\n     }\n \n-    report\n+    report.file_error_map.insert(name.to_owned(), errors);\n }\n \n fn parse_input(input: Input,\n@@ -399,7 +400,10 @@ fn parse_input(input: Input,\n     result.map_err(|e| Some(e))\n }\n \n-pub fn format_input(input: Input, config: &Config) -> (Summary, FileMap, FormatReport) {\n+pub fn format_input<T: Write>(input: Input,\n+                              config: &Config,\n+                              mut out: Option<&mut T>)\n+                              -> Result<(Summary, FileMap, FormatReport), (io::Error, Summary)> {\n     let mut summary = Summary::new();\n     let codemap = Rc::new(CodeMap::new());\n \n@@ -419,7 +423,7 @@ pub fn format_input(input: Input, config: &Config) -> (Summary, FileMap, FormatR\n                 diagnostic.emit();\n             }\n             summary.add_parsing_error();\n-            return (summary, FileMap::new(), FormatReport::new());\n+            return Ok((summary, FileMap::new(), FormatReport::new()));\n         }\n     };\n \n@@ -431,17 +435,33 @@ pub fn format_input(input: Input, config: &Config) -> (Summary, FileMap, FormatR\n     let silent_emitter = Box::new(EmitterWriter::new(Box::new(Vec::new()), None, codemap.clone()));\n     parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n \n-    let mut file_map = format_ast(&krate, &parse_session, &main_file, config);\n+    let mut report = FormatReport::new();\n+\n+    match format_ast(&krate,\n+                     &parse_session,\n+                     &main_file,\n+                     config,\n+                     |file_name, file| {\n+        // For some reason, the codemap does not include terminating\n+        // newlines so we must add one on for each file. This is sad.\n+        filemap::append_newline(file);\n+\n+        format_lines(file, file_name, config, &mut report);\n \n-    // For some reason, the codemap does not include terminating\n-    // newlines so we must add one on for each file. This is sad.\n-    filemap::append_newlines(&mut file_map);\n+        if let Some(ref mut out) = out {\n+            try!(filemap::write_file(file, file_name, out, config));\n+        }\n+        Ok(())\n+    }) {\n+        Ok(file_map) => {\n+            if report.has_warnings() {\n+                summary.add_formatting_error();\n+            }\n \n-    let report = format_lines(&mut file_map, config);\n-    if report.has_warnings() {\n-        summary.add_formatting_error();\n+            Ok((summary, file_map, report))\n+        }\n+        Err(e) => Err((e, summary)),\n     }\n-    (summary, file_map, report)\n }\n \n pub enum Input {\n@@ -450,18 +470,22 @@ pub enum Input {\n }\n \n pub fn run(input: Input, config: &Config) -> Summary {\n-    let (mut summary, file_map, report) = format_input(input, config);\n-    if report.has_warnings() {\n-        msg!(\"{}\", report);\n-    }\n-\n-    let mut out = stdout();\n-    let write_result = filemap::write_all_files(&file_map, &mut out, config);\n+    let mut out = &mut stdout();\n+    output_header(out, config.write_mode).ok();\n+    match format_input(input, config, Some(out)) {\n+        Ok((summary, _, report)) => {\n+            output_footer(out, config.write_mode).ok();\n+\n+            if report.has_warnings() {\n+                msg!(\"{}\", report);\n+            }\n \n-    if let Err(msg) = write_result {\n-        msg!(\"Error writing files: {}\", msg);\n-        summary.add_operational_error();\n+            summary\n+        }\n+        Err((msg, mut summary)) => {\n+            msg!(\"Error writing files: {}\", msg);\n+            summary.add_operational_error();\n+            summary\n+        }\n     }\n-\n-    summary\n }"}, {"sha": "87d20899a58ea3a467073846d2796e1ad8836254", "filename": "src/summary.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b05461666273bd9d7d9da1fd7458b8c943d2298/src%2Fsummary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b05461666273bd9d7d9da1fd7458b8c943d2298/src%2Fsummary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsummary.rs?ref=9b05461666273bd9d7d9da1fd7458b8c943d2298", "patch": "@@ -1,4 +1,5 @@\n #[must_use]\n+#[derive(Debug, Clone)]\n pub struct Summary {\n     // Encountered e.g. an IO error.\n     has_operational_errors: bool,"}, {"sha": "38d1e8584a560445bc615fa8be2db56f9671147f", "filename": "tests/system.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9b05461666273bd9d7d9da1fd7458b8c943d2298/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b05461666273bd9d7d9da1fd7458b8c943d2298/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=9b05461666273bd9d7d9da1fd7458b8c943d2298", "patch": "@@ -143,17 +143,25 @@ fn self_tests() {\n fn stdin_formatting_smoke_test() {\n     let input = Input::Text(\"fn main () {}\".to_owned());\n     let config = Config::default();\n-    let (error_summary, file_map, _report) = format_input(input, &config);\n+    let (error_summary, file_map, _report) = format_input::<io::Stdout>(input, &config, None)\n+        .unwrap();\n     assert!(error_summary.has_no_errors());\n-    assert_eq!(file_map[\"stdin\"].to_string(), \"fn main() {}\\n\")\n+    for &(ref file_name, ref text) in &file_map {\n+        if file_name == \"stdin\" {\n+            assert!(text.to_string() == \"fn main() {}\\n\");\n+            return;\n+        }\n+    }\n+    panic!(\"no stdin\");\n }\n \n #[test]\n fn format_lines_errors_are_reported() {\n     let long_identifier = String::from_utf8(vec![b'a'; 239]).unwrap();\n     let input = Input::Text(format!(\"fn {}() {{}}\", long_identifier));\n     let config = Config::default();\n-    let (error_summary, _file_map, _report) = format_input(input, &config);\n+    let (error_summary, _file_map, _report) = format_input::<io::Stdout>(input, &config, None)\n+        .unwrap();\n     assert!(error_summary.has_formatting_errors());\n }\n \n@@ -212,7 +220,8 @@ fn read_config(filename: &str) -> Config {\n \n fn format_file<P: Into<PathBuf>>(filename: P, config: &Config) -> (FileMap, FormatReport) {\n     let input = Input::File(filename.into());\n-    let (_error_summary, file_map, report) = format_input(input, &config);\n+    let (_error_summary, file_map, report) = format_input::<io::Stdout>(input, &config, None)\n+        .unwrap();\n     return (file_map, report);\n }\n \n@@ -222,7 +231,7 @@ pub fn idempotent_check(filename: String) -> Result<FormatReport, HashMap<String\n     let (file_map, format_report) = format_file(filename, &config);\n \n     let mut write_result = HashMap::new();\n-    for (filename, text) in file_map.iter() {\n+    for &(ref filename, ref text) in &file_map {\n         let mut v = Vec::new();\n         // Won't panic, as we're not doing any IO.\n         write_system_newlines(&mut v, text, &config).unwrap();"}]}