{"sha": "a5c46e5a88a5f26d96406d43eaaa58acf646a5b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YzQ2ZTVhODhhNWYyNmQ5NjQwNmQ0M2VhYWE1OGFjZjY0NmE1YjY=", "commit": {"author": {"name": "Ryan Levick", "email": "me@ryanlevick.com", "date": "2021-08-12T14:05:32Z"}, "committer": {"name": "Ryan Levick", "email": "me@ryanlevick.com", "date": "2021-08-12T14:05:32Z"}, "message": "Factor out return type handling for both function and method", "tree": {"sha": "4e779a67cc0609d119d5910a2ef0f203aa9bad30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e779a67cc0609d119d5910a2ef0f203aa9bad30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5c46e5a88a5f26d96406d43eaaa58acf646a5b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5c46e5a88a5f26d96406d43eaaa58acf646a5b6", "html_url": "https://github.com/rust-lang/rust/commit/a5c46e5a88a5f26d96406d43eaaa58acf646a5b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5c46e5a88a5f26d96406d43eaaa58acf646a5b6/comments", "author": {"login": "rylev", "id": 1327285, "node_id": "MDQ6VXNlcjEzMjcyODU=", "avatar_url": "https://avatars.githubusercontent.com/u/1327285?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rylev", "html_url": "https://github.com/rylev", "followers_url": "https://api.github.com/users/rylev/followers", "following_url": "https://api.github.com/users/rylev/following{/other_user}", "gists_url": "https://api.github.com/users/rylev/gists{/gist_id}", "starred_url": "https://api.github.com/users/rylev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rylev/subscriptions", "organizations_url": "https://api.github.com/users/rylev/orgs", "repos_url": "https://api.github.com/users/rylev/repos", "events_url": "https://api.github.com/users/rylev/events{/privacy}", "received_events_url": "https://api.github.com/users/rylev/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rylev", "id": 1327285, "node_id": "MDQ6VXNlcjEzMjcyODU=", "avatar_url": "https://avatars.githubusercontent.com/u/1327285?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rylev", "html_url": "https://github.com/rylev", "followers_url": "https://api.github.com/users/rylev/followers", "following_url": "https://api.github.com/users/rylev/following{/other_user}", "gists_url": "https://api.github.com/users/rylev/gists{/gist_id}", "starred_url": "https://api.github.com/users/rylev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rylev/subscriptions", "organizations_url": "https://api.github.com/users/rylev/orgs", "repos_url": "https://api.github.com/users/rylev/repos", "events_url": "https://api.github.com/users/rylev/events{/privacy}", "received_events_url": "https://api.github.com/users/rylev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0834e05045f2d10e059ecb825b6c1d1f68d299ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/0834e05045f2d10e059ecb825b6c1d1f68d299ce", "html_url": "https://github.com/rust-lang/rust/commit/0834e05045f2d10e059ecb825b6c1d1f68d299ce"}], "stats": {"total": 176, "additions": 75, "deletions": 101}, "files": [{"sha": "0a19e49b7880d031e98314217de8a808de0b1115", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 75, "deletions": 101, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/a5c46e5a88a5f26d96406d43eaaa58acf646a5b6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c46e5a88a5f26d96406d43eaaa58acf646a5b6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=a5c46e5a88a5f26d96406d43eaaa58acf646a5b6", "patch": "@@ -171,7 +171,7 @@ struct FunctionTemplate {\n     insert_offset: TextSize,\n     leading_ws: String,\n     fn_def: ast::Fn,\n-    ret_type: ast::RetType,\n+    ret_type: Option<ast::RetType>,\n     should_focus_tail_expr: bool,\n     trailing_ws: String,\n     file: FileId,\n@@ -183,7 +183,11 @@ impl FunctionTemplate {\n         let f = match cap {\n             Some(cap) => {\n                 let cursor = if self.should_focus_tail_expr {\n-                    self.ret_type.syntax()\n+                    if let Some(ref ret_type) = self.ret_type {\n+                        ret_type.syntax()\n+                    } else {\n+                        self.tail_expr.syntax()\n+                    }\n                 } else {\n                     self.tail_expr.syntax()\n                 };\n@@ -201,7 +205,7 @@ struct FunctionBuilder {\n     fn_name: ast::Name,\n     type_params: Option<ast::GenericParamList>,\n     params: ast::ParamList,\n-    ret_type: ast::RetType,\n+    ret_type: Option<ast::RetType>,\n     should_focus_tail_expr: bool,\n     file: FileId,\n     needs_pub: bool,\n@@ -235,33 +239,8 @@ impl FunctionBuilder {\n         let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n         let is_async = await_expr.is_some();\n \n-        // should_focus_tail_expr intends to express a rough level of confidence about\n-        // the correctness of the return type.\n-        //\n-        // If we are able to infer some return type, and that return type is not unit, we\n-        // don't want to render the snippet. The assumption here is in this situation the\n-        // return type is just as likely to be correct as any other part of the generated\n-        // function.\n-        //\n-        // In the case where the return type is inferred as unit it is likely that the\n-        // user does in fact intend for this generated function to return some non unit\n-        // type, but that the current state of their code doesn't allow that return type\n-        // to be accurately inferred.\n-        let (ret_ty, should_focus_tail_expr) = {\n-            match ctx.sema.type_of_expr(&ast::Expr::CallExpr(call.clone())).map(TypeInfo::original)\n-            {\n-                Some(ty) if ty.is_unknown() || ty.is_unit() => (make::ty_unit(), true),\n-                Some(ty) => {\n-                    let rendered = ty.display_source_code(ctx.db(), target_module.into());\n-                    match rendered {\n-                        Ok(rendered) => (make::ty(&rendered), false),\n-                        Err(_) => (make::ty_unit(), true),\n-                    }\n-                }\n-                None => (make::ty_unit(), true),\n-            }\n-        };\n-        let ret_type = make::ret_type(ret_ty);\n+        let (ret_type, should_focus_tail_expr) =\n+            make_return_type(ctx, &ast::Expr::CallExpr(call.clone()), target_module);\n \n         Some(Self {\n             target,\n@@ -305,44 +284,16 @@ impl FunctionBuilder {\n         let await_expr = call.syntax().parent().and_then(ast::AwaitExpr::cast);\n         let is_async = await_expr.is_some();\n \n-        // should_render_snippet intends to express a rough level of confidence about\n-        // the correctness of the return type.\n-        //\n-        // If we are able to infer some return type, and that return type is not unit, we\n-        // don't want to render the snippet. The assumption here is in this situation the\n-        // return type is just as likely to be correct as any other part of the generated\n-        // function.\n-        //\n-        // In the case where the return type is inferred as unit it is likely that the\n-        // user does in fact intend for this generated function to return some non unit\n-        // type, but that the current state of their code doesn't allow that return type\n-        // to be accurately inferred.\n-        let (ret_ty, should_render_snippet) = {\n-            match ctx\n-                .sema\n-                .type_of_expr(&ast::Expr::MethodCallExpr(call.clone()))\n-                .map(TypeInfo::original)\n-            {\n-                Some(ty) if ty.is_unknown() || ty.is_unit() => (make::ty_unit(), true),\n-                Some(ty) => {\n-                    let rendered = ty.display_source_code(ctx.db(), target_module.into());\n-                    match rendered {\n-                        Ok(rendered) => (make::ty(&rendered), false),\n-                        Err(_) => (make::ty_unit(), true),\n-                    }\n-                }\n-                None => (make::ty_unit(), true),\n-            }\n-        };\n-        let ret_type = make::ret_type(ret_ty);\n+        let (ret_type, should_focus_tail_expr) =\n+            make_return_type(ctx, &ast::Expr::MethodCallExpr(call.clone()), target_module);\n \n         Some(Self {\n             target,\n             fn_name,\n             type_params,\n             params,\n             ret_type,\n-            should_focus_tail_expr: should_render_snippet,\n+            should_focus_tail_expr,\n             file,\n             needs_pub,\n             is_async,\n@@ -359,7 +310,7 @@ impl FunctionBuilder {\n             self.type_params,\n             self.params,\n             fn_body,\n-            Some(self.ret_type),\n+            self.ret_type,\n             self.is_async,\n         );\n         let leading_ws;\n@@ -386,7 +337,7 @@ impl FunctionBuilder {\n             insert_offset,\n             leading_ws,\n             // PANIC: we guarantee we always create a function with a return type\n-            ret_type: fn_def.ret_type().unwrap(),\n+            ret_type: fn_def.ret_type(),\n             // PANIC: we guarantee we always create a function body with a tail expr\n             tail_expr: fn_def.body().unwrap().tail_expr().unwrap(),\n             should_focus_tail_expr: self.should_focus_tail_expr,\n@@ -397,6 +348,29 @@ impl FunctionBuilder {\n     }\n }\n \n+fn make_return_type(\n+    ctx: &AssistContext,\n+    call: &ast::Expr,\n+    target_module: Module,\n+) -> (Option<ast::RetType>, bool) {\n+    let (ret_ty, should_focus_tail_expr) = {\n+        match ctx.sema.type_of_expr(call).map(TypeInfo::original) {\n+            Some(ty) if ty.is_unit() => (None, false),\n+            Some(ty) if ty.is_unknown() => (Some(make::ty_unit()), true),\n+            None => (Some(make::ty_unit()), true),\n+            Some(ty) => {\n+                let rendered = ty.display_source_code(ctx.db(), target_module.into());\n+                match rendered {\n+                    Ok(rendered) => (Some(make::ty(&rendered)), false),\n+                    Err(_) => (Some(make::ty_unit()), true),\n+                }\n+            }\n+        }\n+    };\n+    let ret_type = ret_ty.map(|rt| make::ret_type(rt));\n+    (ret_type, should_focus_tail_expr)\n+}\n+\n enum GeneratedFunctionTarget {\n     BehindItem(SyntaxNode),\n     InEmptyItemList(SyntaxNode),\n@@ -825,8 +799,8 @@ fn foo() {\n     bar(\"bar\")\n }\n \n-fn bar(arg: &str) ${0:-> ()} {\n-    todo!()\n+fn bar(arg: &str) {\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -846,8 +820,8 @@ fn foo() {\n     bar('x')\n }\n \n-fn bar(arg: char) ${0:-> ()} {\n-    todo!()\n+fn bar(arg: char) {\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -867,8 +841,8 @@ fn foo() {\n     bar(42)\n }\n \n-fn bar(arg: i32) ${0:-> ()} {\n-    todo!()\n+fn bar(arg: i32) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -888,8 +862,8 @@ fn foo() {\n     bar(42 as u8)\n }\n \n-fn bar(arg: u8) ${0:-> ()} {\n-    todo!()\n+fn bar(arg: u8) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -913,8 +887,8 @@ fn foo() {\n     bar(x as u8)\n }\n \n-fn bar(x: u8) ${0:-> ()} {\n-    todo!()\n+fn bar(x: u8) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -936,8 +910,8 @@ fn foo() {\n     bar(worble)\n }\n \n-fn bar(worble: ()) ${0:-> ()} {\n-    todo!()\n+fn bar(worble: ()) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -965,8 +939,8 @@ fn baz() {\n     bar(foo())\n }\n \n-fn bar(foo: impl Foo) ${0:-> ()} {\n-    todo!()\n+fn bar(foo: impl Foo) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -992,8 +966,8 @@ fn foo() {\n     bar(&baz())\n }\n \n-fn bar(baz: &Baz) ${0:-> ()} {\n-    todo!()\n+fn bar(baz: &Baz) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -1021,8 +995,8 @@ fn foo() {\n     bar(Baz::baz())\n }\n \n-fn bar(baz: Baz::Bof) ${0:-> ()} {\n-    todo!()\n+fn bar(baz: Baz::Bof) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -1043,8 +1017,8 @@ fn foo<T>(t: T) {\n     bar(t)\n }\n \n-fn bar(t: T) ${0:-> ()} {\n-    todo!()\n+fn bar(t: T) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -1097,8 +1071,8 @@ fn foo() {\n     bar(closure)\n }\n \n-fn bar(closure: ()) ${0:-> ()} {\n-    todo!()\n+fn bar(closure: ()) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -1118,8 +1092,8 @@ fn foo() {\n     bar(baz)\n }\n \n-fn bar(baz: ()) ${0:-> ()} {\n-    todo!()\n+fn bar(baz: ()) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -1143,8 +1117,8 @@ fn foo() {\n     bar(baz(), baz())\n }\n \n-fn bar(baz_1: Baz, baz_2: Baz) ${0:-> ()} {\n-    todo!()\n+fn bar(baz_1: Baz, baz_2: Baz) {\n+    ${0:todo!()}\n }\n \",\n         )\n@@ -1168,8 +1142,8 @@ fn foo() {\n     bar(baz(), baz(), \"foo\", \"bar\")\n }\n \n-fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) ${0:-> ()} {\n-    todo!()\n+fn bar(baz_1: Baz, baz_2: Baz, arg_1: &str, arg_2: &str) {\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -1188,8 +1162,8 @@ fn foo() {\n \",\n             r\"\n mod bar {\n-    pub(crate) fn my_fn() ${0:-> ()} {\n-        todo!()\n+    pub(crate) fn my_fn() {\n+        ${0:todo!()}\n     }\n }\n \n@@ -1224,8 +1198,8 @@ fn bar() {\n     baz(foo)\n }\n \n-fn baz(foo: foo::Foo) ${0:-> ()} {\n-    todo!()\n+fn baz(foo: foo::Foo) {\n+    ${0:todo!()}\n }\n \"#,\n         )\n@@ -1248,8 +1222,8 @@ fn foo() {\n mod bar {\n     fn something_else() {}\n \n-    pub(crate) fn my_fn() ${0:-> ()} {\n-        todo!()\n+    pub(crate) fn my_fn() {\n+        ${0:todo!()}\n     }\n }\n \n@@ -1276,8 +1250,8 @@ fn foo() {\n             r\"\n mod bar {\n     mod baz {\n-        pub(crate) fn my_fn() ${0:-> ()} {\n-            todo!()\n+        pub(crate) fn my_fn() {\n+            ${0:todo!()}\n         }\n     }\n }\n@@ -1305,8 +1279,8 @@ fn main() {\n             r\"\n \n \n-pub(crate) fn bar() ${0:-> ()} {\n-    todo!()\n+pub(crate) fn bar() {\n+    ${0:todo!()}\n }\",\n         )\n     }"}]}