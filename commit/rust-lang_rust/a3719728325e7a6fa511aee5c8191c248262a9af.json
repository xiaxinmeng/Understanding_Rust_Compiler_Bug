{"sha": "a3719728325e7a6fa511aee5c8191c248262a9af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNzE5NzI4MzI1ZTdhNmZhNTExYWVlNWM4MTkxYzI0ODI2MmE5YWY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-10-02T19:43:40Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2019-10-02T19:52:15Z"}, "message": "Regression tests for issue 64655.", "tree": {"sha": "a2df1e2574cabc6a9321024e20d2b03c12d4cac6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2df1e2574cabc6a9321024e20d2b03c12d4cac6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3719728325e7a6fa511aee5c8191c248262a9af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3719728325e7a6fa511aee5c8191c248262a9af", "html_url": "https://github.com/rust-lang/rust/commit/a3719728325e7a6fa511aee5c8191c248262a9af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3719728325e7a6fa511aee5c8191c248262a9af/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fbb2a9b347d44074fff8aab27cd161a9cd54c74", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fbb2a9b347d44074fff8aab27cd161a9cd54c74", "html_url": "https://github.com/rust-lang/rust/commit/9fbb2a9b347d44074fff8aab27cd161a9cd54c74"}], "stats": {"total": 145, "additions": 145, "deletions": 0}, "files": [{"sha": "ac715e4328fd7b7261355c6945c8c04175191c8a", "filename": "src/test/ui/extern/issue-64655-allow-unwind-when-calling-panic-directly.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a3719728325e7a6fa511aee5c8191c248262a9af/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3719728325e7a6fa511aee5c8191c248262a9af/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fissue-64655-allow-unwind-when-calling-panic-directly.rs?ref=a3719728325e7a6fa511aee5c8191c248262a9af", "patch": "@@ -0,0 +1,63 @@\n+// run-pass\n+\n+// rust-lang/rust#64655: with panic=unwind, a panic from a subroutine\n+// should still run desstructors as it unwindws the stack. However,\n+// bugs with how the nounwind LLVM attribute was applied led to this\n+// simple case being mishandled *if* you had fat LTO turned on.\n+\n+// Unlike issue-64655-extern-rust-must-allow-unwind.rs, the issue\n+// embodied in this test cropped up regardless of optimization level.\n+// Therefore it seemed worthy of being enshrined as a dedicated unit\n+// test.\n+\n+// LTO settings cannot be combined with -C prefer-dynamic\n+// no-prefer-dynamic\n+\n+// The revisions just enumerate lto settings (the opt-level appeared irrelevant in practice)\n+\n+// revisions: no thin fat\n+//[no]compile-flags: -C lto=no\n+//[thin]compile-flags: -C lto=thin\n+//[fat]compile-flags: -C lto=fat\n+\n+#![feature(core_panic)]\n+\n+// (For some reason, reproducing the LTO issue requires pulling in std\n+// explicitly this way.)\n+#![no_std]\n+extern crate std;\n+\n+fn main() {\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n+    use std::boxed::Box;\n+\n+    static SHARED: AtomicUsize = AtomicUsize::new(0);\n+\n+    assert_eq!(SHARED.fetch_add(0, Ordering::SeqCst), 0);\n+\n+    let old_hook = std::panic::take_hook();\n+\n+    std::panic::set_hook(Box::new(|_| { } )); // no-op on panic.\n+\n+    let handle = std::thread::spawn(|| {\n+        struct Droppable;\n+        impl Drop for Droppable {\n+            fn drop(&mut self) {\n+                SHARED.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        let _guard = Droppable;\n+        let s = \"issue-64655-allow-unwind-when-calling-panic-directly.rs\";\n+        core::panicking::panic(&(\"???\", s, 17, 4));\n+    });\n+\n+    let wait = handle.join();\n+\n+    // reinstate handler to ease observation of assertion failures.\n+    std::panic::set_hook(old_hook);\n+\n+    assert!(wait.is_err());\n+\n+    assert_eq!(SHARED.fetch_add(0, Ordering::SeqCst), 1);\n+}"}, {"sha": "4f7e8e3072f6e1ac4c1a058908ede53586f42fd0", "filename": "src/test/ui/extern/issue-64655-extern-rust-must-allow-unwind.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a3719728325e7a6fa511aee5c8191c248262a9af/src%2Ftest%2Fui%2Fextern%2Fissue-64655-extern-rust-must-allow-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3719728325e7a6fa511aee5c8191c248262a9af/src%2Ftest%2Fui%2Fextern%2Fissue-64655-extern-rust-must-allow-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fissue-64655-extern-rust-must-allow-unwind.rs?ref=a3719728325e7a6fa511aee5c8191c248262a9af", "patch": "@@ -0,0 +1,82 @@\n+// run-pass\n+\n+// rust-lang/rust#64655: with panic=unwind, a panic from a subroutine\n+// should still run desstructors as it unwindws the stack. However,\n+// bugs with how the nounwind LLVM attribute was applied led to this\n+// simple case being mishandled *if* you had optimization *and* fat\n+// LTO turned on.\n+\n+// This test is the closest thing to a \"regression test\" we can do\n+// without actually spawning subprocesses and comparing stderr\n+// results.\n+//\n+// This test takes the code from the above issue and adapts it to\n+// better fit our test infrastructure:\n+//\n+// * Instead of relying on println! to observe whether the destructor\n+//   is run, we instead run the code in a spawned thread and\n+//   communicate the destructor's operation via a synchronous atomic\n+//   in static memory.\n+//\n+// * To keep the output from confusing a casual user, we override the\n+//   panic hook to be a no-op (rather than printing a message to\n+//   stderr).\n+//\n+// (pnkfelix has confirmed by hand that these additions do not mask\n+// the underlying bug.)\n+\n+// LTO settings cannot be combined with -C prefer-dynamic\n+// no-prefer-dynamic\n+\n+// The revisions combine each lto setting with each optimization\n+// setting; pnkfelix observed three differing behaviors at opt-levels\n+// 0/1/2+3 for this test, so it seems prudent to be thorough.\n+\n+// revisions: no0 no1 no2 no3 thin0 thin1 thin2 thin3 fat0 fat1 fat2  fat3\n+\n+//[no0]compile-flags: -C opt-level=0 -C lto=no\n+//[no1]compile-flags: -C opt-level=1 -C lto=no\n+//[no2]compile-flags: -C opt-level=2 -C lto=no\n+//[no3]compile-flags: -C opt-level=3 -C lto=no\n+//[thin0]compile-flags: -C opt-level=0 -C lto=thin\n+//[thin1]compile-flags: -C opt-level=1 -C lto=thin\n+//[thin2]compile-flags: -C opt-level=2 -C lto=thin\n+//[thin3]compile-flags: -C opt-level=3 -C lto=thin\n+//[fat0]compile-flags: -C opt-level=0 -C lto=fat\n+//[fat1]compile-flags: -C opt-level=1 -C lto=fat\n+//[fat2]compile-flags: -C opt-level=2 -C lto=fat\n+//[fat3]compile-flags: -C opt-level=3 -C lto=fat\n+\n+fn main() {\n+    use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+    static SHARED: AtomicUsize = AtomicUsize::new(0);\n+\n+    assert_eq!(SHARED.fetch_add(0, Ordering::SeqCst), 0);\n+\n+    let old_hook = std::panic::take_hook();\n+\n+    std::panic::set_hook(Box::new(|_| { } )); // no-op on panic.\n+\n+    let handle = std::thread::spawn(|| {\n+        struct Droppable;\n+        impl Drop for Droppable {\n+            fn drop(&mut self) {\n+                SHARED.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        let _guard = Droppable;\n+        None::<()>.expect(\"???\");\n+    });\n+\n+    let wait = handle.join();\n+\n+    // reinstate handler to ease observation of assertion failures.\n+    std::panic::set_hook(old_hook);\n+\n+    assert!(wait.is_err());\n+\n+    assert_eq!(SHARED.fetch_add(0, Ordering::SeqCst), 1);\n+}\n+"}]}