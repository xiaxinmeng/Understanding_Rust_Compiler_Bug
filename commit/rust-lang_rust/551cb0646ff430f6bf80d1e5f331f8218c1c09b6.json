{"sha": "551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1MWNiMDY0NmZmNDMwZjZiZjgwZDFlNWYzMzFmODIxOGMxYzA5YjY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-12-20T19:16:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-12-20T19:16:23Z"}, "message": "Rollup merge of #38171 - jseyfried:cleanup, r=nrc\n\nMiscellaneous cleanup/refactoring in `resolve` and `syntax::ext`\n\nr? @nrc", "tree": {"sha": "9c5568385abc1c56544b97bc579544b7e258524b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c5568385abc1c56544b97bc579544b7e258524b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "html_url": "https://github.com/rust-lang/rust/commit/551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58d58c24dc9139004ff7679e84958fbecd05d59a", "url": "https://api.github.com/repos/rust-lang/rust/commits/58d58c24dc9139004ff7679e84958fbecd05d59a", "html_url": "https://github.com/rust-lang/rust/commit/58d58c24dc9139004ff7679e84958fbecd05d59a"}, {"sha": "f705c69bf641b271828f37adb525cafc618237d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f705c69bf641b271828f37adb525cafc618237d8", "html_url": "https://github.com/rust-lang/rust/commit/f705c69bf641b271828f37adb525cafc618237d8"}], "stats": {"total": 1246, "additions": 508, "deletions": 738}, "files": [{"sha": "186d6f626509fd0b0daf5f37ddeefa42d516ab1a", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -365,7 +365,6 @@ pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef) {\n     visitor.visit_id(macro_def.id);\n     visitor.visit_name(macro_def.span, macro_def.name);\n-    walk_opt_name(visitor, macro_def.span, macro_def.imported_from);\n     walk_list!(visitor, visit_attribute, &macro_def.attrs);\n }\n "}, {"sha": "e8c3492705a3f95da1e4886b661479e9748a27c6", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -433,13 +433,19 @@ impl<'a> LoweringContext<'a> {\n                           segment: &PathSegment,\n                           param_mode: ParamMode)\n                           -> hir::PathSegment {\n-        let parameters = match segment.parameters {\n-            PathParameters::AngleBracketed(ref data) => {\n-                let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n-                hir::AngleBracketedParameters(data)\n+        let parameters = if let Some(ref parameters) = segment.parameters {\n+            match **parameters {\n+                PathParameters::AngleBracketed(ref data) => {\n+                    let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n+                    hir::AngleBracketedParameters(data)\n+                }\n+                PathParameters::Parenthesized(ref data) => {\n+                    hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data))\n+                }\n             }\n-            PathParameters::Parenthesized(ref data) =>\n-                hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data)),\n+        } else {\n+            let data = self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode);\n+            hir::AngleBracketedParameters(data)\n         };\n \n         hir::PathSegment {\n@@ -987,8 +993,6 @@ impl<'a> LoweringContext<'a> {\n             attrs: self.lower_attrs(&m.attrs),\n             id: m.id,\n             span: m.span,\n-            imported_from: m.imported_from.map(|x| x.name),\n-            allow_internal_unstable: m.allow_internal_unstable,\n             body: m.body.clone().into(),\n         }\n     }"}, {"sha": "f52ee35e1757306ae0605e1dd774db9d770398b4", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -475,8 +475,6 @@ pub struct MacroDef {\n     pub attrs: HirVec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub imported_from: Option<Name>,\n-    pub allow_internal_unstable: bool,\n     pub body: HirVec<TokenTree>,\n }\n "}, {"sha": "f45e86f2f4b9615d32aae1b8c51fb41adf328ff2", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -302,9 +302,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        if md.imported_from.is_none() {\n-            self.annotate(md.id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n-        }\n+        self.annotate(md.id, &md.attrs, md.span, AnnotationKind::Required, |_| {});\n     }\n }\n \n@@ -373,9 +371,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        if md.imported_from.is_none() {\n-            self.check_missing_stability(md.id, md.span);\n-        }\n+        self.check_missing_stability(md.id, md.span);\n     }\n }\n "}, {"sha": "20405398effd78946b9f4c9b2d3701602932b9af", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -762,11 +762,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n                                   arenas: &'tcx CtxtArenas<'tcx>,\n-                                  trait_map: TraitMap,\n+                                  resolutions: ty::Resolutions,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n                                   map: ast_map::Map<'tcx>,\n-                                  freevars: FreevarMap,\n-                                 maybe_unused_trait_imports: NodeSet,\n                                   region_maps: RegionMaps,\n                                   lang_items: middle::lang_items::LanguageItems,\n                                   stability: stability::Index<'tcx>,\n@@ -790,7 +788,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             item_variance_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             variance_computed: Cell::new(false),\n             sess: s,\n-            trait_map: trait_map,\n+            trait_map: resolutions.trait_map,\n             tables: RefCell::new(Tables::empty()),\n             impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n@@ -802,8 +800,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             fulfilled_predicates: RefCell::new(fulfilled_predicates),\n             map: map,\n             mir_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n-            freevars: RefCell::new(freevars),\n-            maybe_unused_trait_imports: maybe_unused_trait_imports,\n+            freevars: RefCell::new(resolutions.freevars),\n+            maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n             item_types: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rcache: RefCell::new(FxHashMap()),\n             tc_cache: RefCell::new(FxHashMap()),"}, {"sha": "8f478435efd90d15b6fc5d0e2d33475670242f88", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -17,7 +17,7 @@ pub use self::LvaluePreference::*;\n pub use self::fold::TypeFoldable;\n \n use dep_graph::{self, DepNode};\n-use hir::map as ast_map;\n+use hir::{map as ast_map, FreevarMap, TraitMap};\n use middle;\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -112,6 +112,13 @@ pub struct CrateAnalysis<'tcx> {\n     pub hir_ty_to_ty: NodeMap<Ty<'tcx>>,\n }\n \n+#[derive(Clone)]\n+pub struct Resolutions {\n+    pub freevars: FreevarMap,\n+    pub trait_map: TraitMap,\n+    pub maybe_unused_trait_imports: NodeSet,\n+}\n+\n #[derive(Copy, Clone)]\n pub enum DtorKind {\n     NoDtor,"}, {"sha": "360933c6b669532457f61cf647dccf7a96813bee", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir;\n-use rustc::hir::{map as hir_map, FreevarMap, TraitMap};\n+use rustc::hir::{self, map as hir_map};\n use rustc::hir::lowering::lower_crate;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_mir as mir;\n@@ -20,7 +19,7 @@ use rustc::session::search_paths::PathKind;\n use rustc::lint;\n use rustc::middle::{self, dependency_format, stability, reachable};\n use rustc::middle::privacy::AccessLevels;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Resolutions};\n use rustc::util::common::time;\n use rustc::util::nodemap::{NodeSet, NodeMap};\n use rustc_borrowck as borrowck;\n@@ -59,13 +58,6 @@ use syntax_ext;\n \n use derive_registrar;\n \n-#[derive(Clone)]\n-pub struct Resolutions {\n-    pub freevars: FreevarMap,\n-    pub trait_map: TraitMap,\n-    pub maybe_unused_trait_imports: NodeSet,\n-}\n-\n pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n                      input: &Input,\n@@ -864,11 +856,9 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     TyCtxt::create_and_enter(sess,\n                              arenas,\n-                             resolutions.trait_map,\n+                             resolutions,\n                              named_region_map,\n                              hir_map,\n-                             resolutions.freevars,\n-                             resolutions.maybe_unused_trait_imports,\n                              region_map,\n                              lang_items,\n                              index,"}, {"sha": "74df1e52bde43143a7dab39a42aee28611022fc9", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -15,10 +15,9 @@ pub use self::PpSourceMode::*;\n pub use self::PpMode::*;\n use self::NodesMatchingUII::*;\n \n-use abort_on_err;\n-use driver::{self, Resolutions};\n+use {abort_on_err, driver};\n \n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Resolutions};\n use rustc::cfg;\n use rustc::cfg::graphviz::LabelledCFG;\n use rustc::dep_graph::DepGraph;"}, {"sha": "cbab39c390829422419cbacd3e6bd51320dee7fc", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -138,11 +138,9 @@ fn test_env<F>(source_string: &str,\n     let index = stability::Index::new(&ast_map);\n     TyCtxt::create_and_enter(&sess,\n                              &arenas,\n-                             resolutions.trait_map,\n+                             resolutions,\n                              named_region_map.unwrap(),\n                              ast_map,\n-                             resolutions.freevars,\n-                             resolutions.maybe_unused_trait_imports,\n                              region_map,\n                              lang_items,\n                              index,"}, {"sha": "ac830318ce9a39b851f8247954f873311a160bc1", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -418,8 +418,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n             ident: ast::Ident::with_empty_ctxt(name),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n-            imported_from: None, // FIXME\n-            allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n             attrs: attrs,\n             body: body,\n         })"}, {"sha": "bc150b847786f2c08531e847d08061b2f9600d3d", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -171,7 +171,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         match item.node {\n             ItemKind::Use(ref view_path) => {\n                 let path = view_path.node.path();\n-                if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {\n+                if path.segments.iter().any(|segment| segment.parameters.is_some()) {\n                     self.err_handler()\n                         .span_err(path.span, \"type or lifetime parameters in import path\");\n                 }\n@@ -275,7 +275,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_vis(&mut self, vis: &'a Visibility) {\n         match *vis {\n             Visibility::Restricted { ref path, .. } => {\n-                if !path.segments.iter().all(|segment| segment.parameters.is_empty()) {\n+                if !path.segments.iter().all(|segment| segment.parameters.is_none()) {\n                     self.err_handler()\n                         .span_err(path.span, \"type or lifetime parameters in visibility path\");\n                 }"}, {"sha": "cd2a2767979144fdcb3272a5205ef71128f8d196", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 84, "deletions": 78, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -16,7 +16,8 @@\n use macros::{InvocationData, LegacyScope};\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n-use {Resolver, Module, ModuleS, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n+use {Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n+use {Resolver, ResolverArenas};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n@@ -28,7 +29,7 @@ use rustc::ty;\n use std::cell::Cell;\n use std::rc::Rc;\n \n-use syntax::ast::Name;\n+use syntax::ast::{Name, Ident};\n use syntax::attr;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n@@ -45,24 +46,24 @@ use syntax::visit::{self, Visitor};\n use syntax_pos::{Span, DUMMY_SP};\n \n impl<'a> ToNameBinding<'a> for (Module<'a>, ty::Visibility, Span, Mark) {\n-    fn to_name_binding(self) -> NameBinding<'a> {\n-        NameBinding {\n+    fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n+        arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Module(self.0),\n             vis: self.1,\n             span: self.2,\n             expansion: self.3,\n-        }\n+        })\n     }\n }\n \n impl<'a> ToNameBinding<'a> for (Def, ty::Visibility, Span, Mark) {\n-    fn to_name_binding(self) -> NameBinding<'a> {\n-        NameBinding {\n+    fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n+        arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Def(self.0),\n             vis: self.1,\n             span: self.2,\n             expansion: self.3,\n-        }\n+        })\n     }\n }\n \n@@ -73,15 +74,15 @@ struct LegacyMacroImports {\n     reexports: Vec<(Name, Span)>,\n }\n \n-impl<'b> Resolver<'b> {\n+impl<'a> Resolver<'a> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n-    fn define<T>(&mut self, parent: Module<'b>, name: Name, ns: Namespace, def: T)\n-        where T: ToNameBinding<'b>,\n+    fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n+        where T: ToNameBinding<'a>,\n     {\n-        let binding = def.to_name_binding();\n-        if let Err(old_binding) = self.try_define(parent, name, ns, binding.clone()) {\n-            self.report_conflict(parent, name, ns, old_binding, &binding);\n+        let binding = def.to_name_binding(self.arenas);\n+        if let Err(old_binding) = self.try_define(parent, ident, ns, binding) {\n+            self.report_conflict(parent, ident, ns, old_binding, &binding);\n         }\n     }\n \n@@ -102,7 +103,7 @@ impl<'b> Resolver<'b> {\n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &Item, expansion: Mark) {\n         let parent = self.current_module;\n-        let name = item.ident.name;\n+        let ident = item.ident;\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n \n@@ -157,8 +158,8 @@ impl<'b> Resolver<'b> {\n                         }\n \n                         let subclass = SingleImport {\n-                            target: binding.name,\n-                            source: source.name,\n+                            target: binding,\n+                            source: source,\n                             result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n                         };\n                         self.add_import_directive(\n@@ -187,13 +188,13 @@ impl<'b> Resolver<'b> {\n \n                         for source_item in source_items {\n                             let node = source_item.node;\n-                            let (module_path, name, rename) = {\n+                            let (module_path, ident, rename) = {\n                                 if node.name.name != keywords::SelfValue.name() {\n-                                    let rename = node.rename.unwrap_or(node.name).name;\n-                                    (module_path.clone(), node.name.name, rename)\n+                                    let rename = node.rename.unwrap_or(node.name);\n+                                    (module_path.clone(), node.name, rename)\n                                 } else {\n-                                    let name = match module_path.last() {\n-                                        Some(ident) => ident.name,\n+                                    let ident = match module_path.last() {\n+                                        Some(&ident) => ident,\n                                         None => {\n                                             resolve_error(\n                                                 self,\n@@ -205,13 +206,13 @@ impl<'b> Resolver<'b> {\n                                         }\n                                     };\n                                     let module_path = module_path.split_last().unwrap().1;\n-                                    let rename = node.rename.map(|i| i.name).unwrap_or(name);\n-                                    (module_path.to_vec(), name, rename)\n+                                    let rename = node.rename.unwrap_or(ident);\n+                                    (module_path.to_vec(), ident, rename)\n                                 }\n                             };\n                             let subclass = SingleImport {\n                                 target: rename,\n-                                source: name,\n+                                source: ident,\n                                 result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n                             };\n                             let id = source_item.node.id;\n@@ -238,8 +239,8 @@ impl<'b> Resolver<'b> {\n                 // n.b. we don't need to look at the path option here, because cstore already did\n                 let crate_id = self.session.cstore.extern_mod_stmt_cnum(item.id).unwrap();\n                 let module = self.get_extern_crate_root(crate_id);\n-                let binding = (module, ty::Visibility::Public, sp, expansion).to_name_binding();\n-                let binding = self.arenas.alloc_name_binding(binding);\n+                let binding =\n+                    (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.arenas);\n                 let directive = self.arenas.alloc_import_directive(ImportDirective {\n                     id: item.id,\n                     parent: parent,\n@@ -251,7 +252,7 @@ impl<'b> Resolver<'b> {\n                     expansion: expansion,\n                 });\n                 let imported_binding = self.import(binding, directive);\n-                self.define(parent, name, TypeNS, imported_binding);\n+                self.define(parent, ident, TypeNS, imported_binding);\n                 self.populate_module_if_necessary(module);\n                 self.process_legacy_macro_imports(item, module, expansion);\n             }\n@@ -260,14 +261,14 @@ impl<'b> Resolver<'b> {\n \n             ItemKind::Mod(..) => {\n                 let def = Def::Mod(self.definitions.local_def_id(item.id));\n-                let module = self.arenas.alloc_module(ModuleS {\n+                let module = self.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n                     },\n                     normal_ancestor_id: Some(item.id),\n-                    ..ModuleS::new(Some(parent), ModuleKind::Def(def, name))\n+                    ..ModuleData::new(Some(parent), ModuleKind::Def(def, ident.name))\n                 });\n-                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.module_map.insert(item.id, module);\n \n                 // Descend into the module.\n@@ -280,27 +281,27 @@ impl<'b> Resolver<'b> {\n             ItemKind::Static(_, m, _) => {\n                 let mutbl = m == Mutability::Mutable;\n                 let def = Def::Static(self.definitions.local_def_id(item.id), mutbl);\n-                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n                 let def = Def::Const(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n             }\n             ItemKind::Fn(..) => {\n                 let def = Def::Fn(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, ValueNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n             }\n \n             // These items live in the type namespace.\n             ItemKind::Ty(..) => {\n                 let def = Def::TyAlias(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n             }\n \n             ItemKind::Enum(ref enum_definition, _) => {\n                 let def = Def::Enum(self.definitions.local_def_id(item.id));\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), true);\n-                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n+                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), true);\n+                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n                 for variant in &(*enum_definition).variants {\n                     self.build_reduced_graph_for_variant(variant, module, vis, expansion);\n@@ -311,14 +312,14 @@ impl<'b> Resolver<'b> {\n             ItemKind::Struct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n                 let def = Def::Struct(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n \n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n                 if !struct_def.is_struct() {\n                     let ctor_def = Def::StructCtor(self.definitions.local_def_id(struct_def.id()),\n                                                    CtorKind::from_ast(struct_def));\n-                    self.define(parent, name, ValueNS, (ctor_def, vis, sp, expansion));\n+                    self.define(parent, ident, ValueNS, (ctor_def, vis, sp, expansion));\n                 }\n \n                 // Record field names for error reporting.\n@@ -332,7 +333,7 @@ impl<'b> Resolver<'b> {\n \n             ItemKind::Union(ref vdata, _) => {\n                 let def = Def::Union(self.definitions.local_def_id(item.id));\n-                self.define(parent, name, TypeNS, (def, vis, sp, expansion));\n+                self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n                 let field_names = vdata.fields().iter().filter_map(|field| {\n@@ -350,8 +351,8 @@ impl<'b> Resolver<'b> {\n \n                 // Add all the items within to a new module.\n                 let module =\n-                    self.new_module(parent, ModuleKind::Def(Def::Trait(def_id), name), true);\n-                self.define(parent, name, TypeNS, (module, vis, sp, expansion));\n+                    self.new_module(parent, ModuleKind::Def(Def::Trait(def_id), ident.name), true);\n+                self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.current_module = module;\n             }\n             ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n@@ -362,29 +363,26 @@ impl<'b> Resolver<'b> {\n     // type and value namespaces.\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n-                                       parent: Module<'b>,\n+                                       parent: Module<'a>,\n                                        vis: ty::Visibility,\n                                        expansion: Mark) {\n-        let name = variant.node.name.name;\n+        let ident = variant.node.name;\n         let def_id = self.definitions.local_def_id(variant.node.data.id());\n \n         // Define a name in the type namespace.\n         let def = Def::Variant(def_id);\n-        self.define(parent, name, TypeNS, (def, vis, variant.span, expansion));\n+        self.define(parent, ident, TypeNS, (def, vis, variant.span, expansion));\n \n         // Define a constructor name in the value namespace.\n         // Braced variants, unlike structs, generate unusable names in\n         // value namespace, they are reserved for possible future use.\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n         let ctor_def = Def::VariantCtor(def_id, ctor_kind);\n-        self.define(parent, name, ValueNS, (ctor_def, vis, variant.span, expansion));\n+        self.define(parent, ident, ValueNS, (ctor_def, vis, variant.span, expansion));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expansion: Mark) {\n-        let parent = self.current_module;\n-        let name = item.ident.name;\n-\n         let def = match item.node {\n             ForeignItemKind::Fn(..) => {\n                 Def::Fn(self.definitions.local_def_id(item.id))\n@@ -393,8 +391,9 @@ impl<'b> Resolver<'b> {\n                 Def::Static(self.definitions.local_def_id(item.id), m)\n             }\n         };\n+        let parent = self.current_module;\n         let vis = self.resolve_visibility(&item.vis);\n-        self.define(parent, name, ValueNS, (def, vis, item.span, expansion));\n+        self.define(parent, item.ident, ValueNS, (def, vis, item.span, expansion));\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block) {\n@@ -413,8 +412,8 @@ impl<'b> Resolver<'b> {\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n-    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'b>, child: Export) {\n-        let name = child.name;\n+    fn build_reduced_graph_for_external_crate_def(&mut self, parent: Module<'a>, child: Export) {\n+        let ident = Ident::with_empty_ctxt(child.name);\n         let def = child.def;\n         let def_id = def.def_id();\n         let vis = match def {\n@@ -425,25 +424,25 @@ impl<'b> Resolver<'b> {\n \n         match def {\n             Def::Mod(..) | Def::Enum(..) => {\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                self.define(parent, name, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n+                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), false);\n+                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Variant(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::VariantCtor(..) => {\n-                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Fn(..) |\n             Def::Static(..) |\n             Def::Const(..) |\n             Def::AssociatedConst(..) |\n             Def::Method(..) => {\n-                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Trait(..) => {\n-                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n-                self.define(parent, name, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n+                let module = self.new_module(parent, ModuleKind::Def(def, ident.name), false);\n+                self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, Mark::root()));\n \n                 // If this is a trait, add all the trait item names to the trait info.\n                 let trait_item_def_ids = self.session.cstore.associated_item_def_ids(def_id);\n@@ -455,27 +454,27 @@ impl<'b> Resolver<'b> {\n                 }\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Struct(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n \n                 // Record field names for error reporting.\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::StructCtor(..) => {\n-                self.define(parent, name, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Union(..) => {\n-                self.define(parent, name, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, Mark::root()));\n \n                 // Record field names for error reporting.\n                 let field_names = self.session.cstore.struct_field_names(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n             Def::Macro(..) => {\n-                self.define(parent, name, MacroNS, (def, vis, DUMMY_SP, Mark::root()));\n+                self.define(parent, ident, MacroNS, (def, vis, DUMMY_SP, Mark::root()));\n             }\n             Def::Local(..) |\n             Def::PrimTy(..) |\n@@ -489,14 +488,15 @@ impl<'b> Resolver<'b> {\n         }\n     }\n \n-    fn get_extern_crate_root(&mut self, cnum: CrateNum) -> Module<'b> {\n+    fn get_extern_crate_root(&mut self, cnum: CrateNum) -> Module<'a> {\n         let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+        let name = self.session.cstore.crate_name(cnum);\n         let macros_only = self.session.cstore.dep_kind(cnum).macros_only();\n         let arenas = self.arenas;\n         *self.extern_crate_roots.entry((cnum, macros_only)).or_insert_with(|| {\n-            arenas.alloc_module(ModuleS {\n+            arenas.alloc_module(ModuleData {\n                 populated: Cell::new(false),\n-                ..ModuleS::new(None, ModuleKind::Def(Def::Mod(def_id), keywords::Invalid.name()))\n+                ..ModuleData::new(None, ModuleKind::Def(Def::Mod(def_id), name))\n             })\n         })\n     }\n@@ -532,7 +532,7 @@ impl<'b> Resolver<'b> {\n \n     /// Ensures that the reduced graph rooted at the given external module\n     /// is built, building it if it is not.\n-    pub fn populate_module_if_necessary(&mut self, module: Module<'b>) {\n+    pub fn populate_module_if_necessary(&mut self, module: Module<'a>) {\n         if module.populated.get() { return }\n         for child in self.session.cstore.item_children(module.def_id().unwrap()) {\n             self.build_reduced_graph_for_external_crate_def(module, child);\n@@ -542,7 +542,7 @@ impl<'b> Resolver<'b> {\n \n     fn legacy_import_macro(&mut self,\n                            name: Name,\n-                           binding: &'b NameBinding<'b>,\n+                           binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n         self.used_crates.insert(binding.def().def_id().krate);\n@@ -555,7 +555,7 @@ impl<'b> Resolver<'b> {\n         }\n     }\n \n-    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'b>, expansion: Mark) {\n+    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>, expansion: Mark) {\n         let allow_shadowing = expansion == Mark::root();\n         let legacy_imports = self.legacy_macro_imports(&item.attrs);\n         let cnum = module.def_id().unwrap().krate;\n@@ -574,12 +574,13 @@ impl<'b> Resolver<'b> {\n         }\n \n         if let Some(span) = legacy_imports.import_all {\n-            module.for_each_child(|name, ns, binding| if ns == MacroNS {\n-                self.legacy_import_macro(name, binding, span, allow_shadowing);\n+            module.for_each_child(|ident, ns, binding| if ns == MacroNS {\n+                self.legacy_import_macro(ident.name, binding, span, allow_shadowing);\n             });\n         } else {\n             for (name, span) in legacy_imports.imports {\n-                let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+                let ident = Ident::with_empty_ctxt(name);\n+                let result = self.resolve_ident_in_module(module, ident, MacroNS, false, None);\n                 if let Ok(binding) = result {\n                     self.legacy_import_macro(name, binding, span, allow_shadowing);\n                 } else {\n@@ -591,7 +592,8 @@ impl<'b> Resolver<'b> {\n             let krate = module.def_id().unwrap().krate;\n             self.used_crates.insert(krate);\n             self.session.cstore.export_macros(krate);\n-            let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n+            let ident = Ident::with_empty_ctxt(name);\n+            let result = self.resolve_ident_in_module(module, ident, MacroNS, false, None);\n             if let Ok(binding) = result {\n                 self.macro_exports.push(Export { name: name, def: binding.def() });\n             } else {\n@@ -696,9 +698,13 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_item(&mut self, item: &'a Item) {\n         let macro_use = match item.node {\n-            ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => return, // Scope placeholder\n-            ItemKind::Mac(..) => {\n-                return self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+            ItemKind::Mac(ref mac) => {\n+                if mac.node.path.segments.is_empty() {\n+                    self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n+                } else {\n+                    self.resolver.define_macro(item, &mut self.legacy_scope);\n+                }\n+                return\n             }\n             ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),\n             _ => false,\n@@ -759,7 +765,7 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         self.resolver.trait_item_map.insert((item.ident.name, def_id), is_static_method);\n \n         let vis = ty::Visibility::Public;\n-        self.resolver.define(parent, item.ident.name, ns, (def, vis, item.span, self.expansion));\n+        self.resolver.define(parent, item.ident, ns, (def, vis, item.span, self.expansion));\n \n         self.resolver.current_module = parent.parent.unwrap(); // nearest normal ancestor\n         visit::walk_trait_item(self, item);"}, {"sha": "fb28b45d20e5a59b719f300555e9746f2b915146", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 92, "deletions": 132, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -62,7 +62,7 @@ use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Local, Mutability, Pat, PatKind, Path};\n-use syntax::ast::{PathSegment, PathParameters, QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n+use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n \n use syntax_pos::{Span, DUMMY_SP};\n use errors::DiagnosticBuilder;\n@@ -774,15 +774,15 @@ enum ModuleKind {\n }\n \n /// One node in the tree of modules.\n-pub struct ModuleS<'a> {\n+pub struct ModuleData<'a> {\n     parent: Option<Module<'a>>,\n     kind: ModuleKind,\n \n     // The node id of the closest normal module (`mod`) ancestor (including this module).\n     normal_ancestor_id: Option<NodeId>,\n \n-    resolutions: RefCell<FxHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    legacy_macro_resolutions: RefCell<Vec<(Mark, Name, Span)>>,\n+    resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n+    legacy_macro_resolutions: RefCell<Vec<(Mark, Ident, Span)>>,\n     macro_resolutions: RefCell<Vec<(Box<[Ident]>, PathScope, Span)>>,\n \n     // Macro invocations that can expand into items in this module.\n@@ -794,19 +794,19 @@ pub struct ModuleS<'a> {\n     globs: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n     // Used to memoize the traits in this module for faster searches through all traits in scope.\n-    traits: RefCell<Option<Box<[(Name, &'a NameBinding<'a>)]>>>,\n+    traits: RefCell<Option<Box<[(Ident, &'a NameBinding<'a>)]>>>,\n \n     // Whether this module is populated. If not populated, any attempt to\n     // access the children must be preceded with a\n     // `populate_module_if_necessary` call.\n     populated: Cell<bool>,\n }\n \n-pub type Module<'a> = &'a ModuleS<'a>;\n+pub type Module<'a> = &'a ModuleData<'a>;\n \n-impl<'a> ModuleS<'a> {\n+impl<'a> ModuleData<'a> {\n     fn new(parent: Option<Module<'a>>, kind: ModuleKind) -> Self {\n-        ModuleS {\n+        ModuleData {\n             parent: parent,\n             kind: kind,\n             normal_ancestor_id: None,\n@@ -822,9 +822,9 @@ impl<'a> ModuleS<'a> {\n         }\n     }\n \n-    fn for_each_child<F: FnMut(Name, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n-        for (&(name, ns), name_resolution) in self.resolutions.borrow().iter() {\n-            name_resolution.borrow().binding.map(|binding| f(name, ns, binding));\n+    fn for_each_child<F: FnMut(Ident, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n+        for (&(ident, ns), name_resolution) in self.resolutions.borrow().iter() {\n+            name_resolution.borrow().binding.map(|binding| f(ident, ns, binding));\n         }\n     }\n \n@@ -859,7 +859,7 @@ impl<'a> ModuleS<'a> {\n     }\n }\n \n-impl<'a> fmt::Debug for ModuleS<'a> {\n+impl<'a> fmt::Debug for ModuleData<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{:?}\", self.def())\n     }\n@@ -875,11 +875,11 @@ pub struct NameBinding<'a> {\n }\n \n pub trait ToNameBinding<'a> {\n-    fn to_name_binding(self) -> NameBinding<'a>;\n+    fn to_name_binding(self, arenas: &'a ResolverArenas<'a>) -> &'a NameBinding<'a>;\n }\n \n-impl<'a> ToNameBinding<'a> for NameBinding<'a> {\n-    fn to_name_binding(self) -> NameBinding<'a> {\n+impl<'a> ToNameBinding<'a> for &'a NameBinding<'a> {\n+    fn to_name_binding(self, _: &'a ResolverArenas<'a>) -> &'a NameBinding<'a> {\n         self\n     }\n }\n@@ -1116,7 +1116,7 @@ pub struct Resolver<'a> {\n }\n \n pub struct ResolverArenas<'a> {\n-    modules: arena::TypedArena<ModuleS<'a>>,\n+    modules: arena::TypedArena<ModuleData<'a>>,\n     local_modules: RefCell<Vec<Module<'a>>>,\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     import_directives: arena::TypedArena<ImportDirective<'a>>,\n@@ -1126,7 +1126,7 @@ pub struct ResolverArenas<'a> {\n }\n \n impl<'a> ResolverArenas<'a> {\n-    fn alloc_module(&'a self, module: ModuleS<'a>) -> Module<'a> {\n+    fn alloc_module(&'a self, module: ModuleData<'a>) -> Module<'a> {\n         let module = self.modules.alloc(module);\n         if module.def_id().map(|def_id| def_id.is_local()).unwrap_or(true) {\n             self.local_modules.borrow_mut().push(module);\n@@ -1206,10 +1206,10 @@ impl<'a> Resolver<'a> {\n                arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n         let root_def = Def::Mod(DefId::local(CRATE_DEF_INDEX));\n-        let graph_root = arenas.alloc_module(ModuleS {\n+        let graph_root = arenas.alloc_module(ModuleData {\n             normal_ancestor_id: Some(CRATE_NODE_ID),\n             no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n-            ..ModuleS::new(None, ModuleKind::Def(root_def, keywords::Invalid.name()))\n+            ..ModuleData::new(None, ModuleKind::Def(root_def, keywords::Invalid.name()))\n         });\n         let mut module_map = NodeMap();\n         module_map.insert(CRATE_NODE_ID, graph_root);\n@@ -1327,41 +1327,41 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn new_module(&self, parent: Module<'a>, kind: ModuleKind, local: bool) -> Module<'a> {\n-        self.arenas.alloc_module(ModuleS {\n+        self.arenas.alloc_module(ModuleData {\n             normal_ancestor_id: if local { self.current_module.normal_ancestor_id } else { None },\n             populated: Cell::new(local),\n-            ..ModuleS::new(Some(parent), kind)\n+            ..ModuleData::new(Some(parent), kind)\n         })\n     }\n \n-    fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n+    fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n                   -> bool /* true if an error was reported */ {\n         // track extern crates for unused_extern_crate lint\n-        if let Some(DefId { krate, .. }) = binding.module().and_then(ModuleS::def_id) {\n+        if let Some(DefId { krate, .. }) = binding.module().and_then(ModuleData::def_id) {\n             self.used_crates.insert(krate);\n         }\n \n         match binding.kind {\n             NameBindingKind::Import { directive, binding, ref used } if !used.get() => {\n                 used.set(true);\n                 self.used_imports.insert((directive.id, ns));\n-                self.add_to_glob_map(directive.id, name);\n-                self.record_use(name, ns, binding, span)\n+                self.add_to_glob_map(directive.id, ident);\n+                self.record_use(ident, ns, binding, span)\n             }\n             NameBindingKind::Import { .. } => false,\n             NameBindingKind::Ambiguity { b1, b2 } => {\n                 self.ambiguity_errors.push(AmbiguityError {\n-                    span: span, name: name, lexical: false, b1: b1, b2: b2,\n+                    span: span, name: ident.name, lexical: false, b1: b1, b2: b2,\n                 });\n                 true\n             }\n             _ => false\n         }\n     }\n \n-    fn add_to_glob_map(&mut self, id: NodeId, name: Name) {\n+    fn add_to_glob_map(&mut self, id: NodeId, ident: Ident) {\n         if self.make_glob_map {\n-            self.glob_map.entry(id).or_insert_with(FxHashSet).insert(name);\n+            self.glob_map.entry(id).or_insert_with(FxHashSet).insert(ident.name);\n         }\n     }\n \n@@ -1388,7 +1388,7 @@ impl<'a> Resolver<'a> {\n                                       record_used: Option<Span>)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         if ns == TypeNS {\n-            ident = Ident::with_empty_ctxt(ident.name);\n+            ident = ident.unhygienize();\n         }\n \n         // Walk backwards up the ribs in scope.\n@@ -1403,8 +1403,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n-                let name = ident.name;\n-                let item = self.resolve_name_in_module(module, name, ns, false, record_used);\n+                let item = self.resolve_ident_in_module(module, ident, ns, false, record_used);\n                 if let Ok(binding) = item {\n                     // The ident resolves to an item.\n                     return Some(LexicalScopeBinding::Item(binding));\n@@ -1413,7 +1412,7 @@ impl<'a> Resolver<'a> {\n                 if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n                 } else if !module.no_implicit_prelude {\n                     return self.prelude.and_then(|prelude| {\n-                        self.resolve_name_in_module(prelude, name, ns, false, None).ok()\n+                        self.resolve_ident_in_module(prelude, ident, ns, false, None).ok()\n                     }).map(LexicalScopeBinding::Item)\n                 } else {\n                     return None;\n@@ -2183,8 +2182,7 @@ impl<'a> Resolver<'a> {\n                             Def::VariantCtor(_, CtorKind::Const) |\n                             Def::Const(..) if !always_binding => {\n                                 // A unit struct/variant or constant pattern.\n-                                let name = ident.node.name;\n-                                self.record_use(name, ValueNS, binding.unwrap(), ident.span);\n+                                self.record_use(ident.node, ValueNS, binding.unwrap(), ident.span);\n                                 Some(PathResolution::new(def))\n                             }\n                             Def::StructCtor(..) | Def::VariantCtor(..) |\n@@ -2363,9 +2361,9 @@ impl<'a> Resolver<'a> {\n             allow_super = false;\n \n             let binding = if let Some(module) = module {\n-                self.resolve_name_in_module(module, ident.name, ns, false, record_used)\n+                self.resolve_ident_in_module(module, ident, ns, false, record_used)\n             } else if opt_ns == Some(MacroNS) {\n-                self.resolve_lexical_macro_path_segment(ident.name, ns, record_used)\n+                self.resolve_lexical_macro_path_segment(ident, ns, record_used)\n             } else {\n                 match self.resolve_ident_in_lexical_scope(ident, ns, record_used) {\n                     Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n@@ -2405,7 +2403,7 @@ impl<'a> Resolver<'a> {\n                             });\n                         }\n                     }\n-                    let msg = if module.and_then(ModuleS::def) == self.graph_root.def() {\n+                    let msg = if module.and_then(ModuleData::def) == self.graph_root.def() {\n                         let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n                         let mut candidates =\n                             self.lookup_candidates(ident.name, TypeNS, is_mod).candidates;\n@@ -2865,72 +2863,64 @@ impl<'a> Resolver<'a> {\n     fn get_traits_containing_item(&mut self, name: Name) -> Vec<TraitCandidate> {\n         debug!(\"(getting traits containing item) looking for '{}'\", name);\n \n-        fn add_trait_info(found_traits: &mut Vec<TraitCandidate>,\n-                          trait_def_id: DefId,\n-                          import_id: Option<NodeId>,\n-                          name: Name) {\n-            debug!(\"(adding trait info) found trait {:?} for method '{}'\",\n-                   trait_def_id,\n-                   name);\n-            found_traits.push(TraitCandidate {\n-                def_id: trait_def_id,\n-                import_id: import_id,\n-            });\n-        }\n-\n         let mut found_traits = Vec::new();\n         // Look for the current trait.\n         if let Some((trait_def_id, _)) = self.current_trait_ref {\n             if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n-                add_trait_info(&mut found_traits, trait_def_id, None, name);\n+                found_traits.push(TraitCandidate { def_id: trait_def_id, import_id: None });\n             }\n         }\n \n         let mut search_module = self.current_module;\n         loop {\n-            // Look for trait children.\n-            let mut search_in_module = |this: &mut Self, module: Module<'a>| {\n-                let mut traits = module.traits.borrow_mut();\n-                if traits.is_none() {\n-                    let mut collected_traits = Vec::new();\n-                    module.for_each_child(|name, ns, binding| {\n-                        if ns != TypeNS { return }\n-                        if let Def::Trait(_) = binding.def() {\n-                            collected_traits.push((name, binding));\n-                        }\n-                    });\n-                    *traits = Some(collected_traits.into_boxed_slice());\n-                }\n-\n-                for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-                    let trait_def_id = binding.def().def_id();\n-                    if this.trait_item_map.contains_key(&(name, trait_def_id)) {\n-                        let mut import_id = None;\n-                        if let NameBindingKind::Import { directive, .. } = binding.kind {\n-                            let id = directive.id;\n-                            this.maybe_unused_trait_imports.insert(id);\n-                            this.add_to_glob_map(id, trait_name);\n-                            import_id = Some(id);\n-                        }\n-                        add_trait_info(&mut found_traits, trait_def_id, import_id, name);\n-                    }\n-                }\n-            };\n-            search_in_module(self, search_module);\n+            self.get_traits_in_module_containing_item(name, search_module, &mut found_traits);\n+            match search_module.kind {\n+                ModuleKind::Block(..) => search_module = search_module.parent.unwrap(),\n+                _ => break,\n+            }\n+        }\n \n-            if let ModuleKind::Block(..) = search_module.kind {\n-                search_module = search_module.parent.unwrap();\n-            } else {\n-                if !search_module.no_implicit_prelude {\n-                    self.prelude.map(|prelude| search_in_module(self, prelude));\n-                }\n-                break;\n+        if let Some(prelude) = self.prelude {\n+            if !search_module.no_implicit_prelude {\n+                self.get_traits_in_module_containing_item(name, prelude, &mut found_traits);\n             }\n         }\n \n         found_traits\n     }\n \n+    fn get_traits_in_module_containing_item(&mut self,\n+                                            name: Name,\n+                                            module: Module,\n+                                            found_traits: &mut Vec<TraitCandidate>) {\n+        let mut traits = module.traits.borrow_mut();\n+        if traits.is_none() {\n+            let mut collected_traits = Vec::new();\n+            module.for_each_child(|name, ns, binding| {\n+                if ns != TypeNS { return }\n+                if let Def::Trait(_) = binding.def() {\n+                    collected_traits.push((name, binding));\n+                }\n+            });\n+            *traits = Some(collected_traits.into_boxed_slice());\n+        }\n+\n+        for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n+            let trait_def_id = binding.def().def_id();\n+            if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n+                let import_id = match binding.kind {\n+                    NameBindingKind::Import { directive, .. } => {\n+                        self.maybe_unused_trait_imports.insert(directive.id);\n+                        self.add_to_glob_map(directive.id, trait_name);\n+                        Some(directive.id)\n+                    }\n+                    _ => None,\n+                };\n+                found_traits.push(TraitCandidate { def_id: trait_def_id, import_id: import_id });\n+            }\n+        }\n+    }\n+\n     /// When name resolution fails, this method can be used to look up candidate\n     /// entities with the expected name. It allows filtering them using the\n     /// supplied predicate (which should be used to only accept the types of\n@@ -2953,24 +2943,18 @@ impl<'a> Resolver<'a> {\n                         in_module_is_extern)) = worklist.pop() {\n             self.populate_module_if_necessary(in_module);\n \n-            in_module.for_each_child(|name, ns, name_binding| {\n+            in_module.for_each_child(|ident, ns, name_binding| {\n \n                 // avoid imports entirely\n                 if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n \n                 // collect results based on the filter function\n-                if name == lookup_name && ns == namespace {\n+                if ident.name == lookup_name && ns == namespace {\n                     if filter_fn(name_binding.def()) {\n                         // create the path\n-                        let ident = Ident::with_empty_ctxt(name);\n-                        let params = PathParameters::none();\n-                        let segment = PathSegment {\n-                            identifier: ident,\n-                            parameters: params,\n-                        };\n                         let span = name_binding.span;\n                         let mut segms = path_segments.clone();\n-                        segms.push(segment);\n+                        segms.push(ident.into());\n                         let path = Path {\n                             span: span,\n                             global: false,\n@@ -2993,10 +2977,7 @@ impl<'a> Resolver<'a> {\n                 if let Some(module) = name_binding.module() {\n                     // form the path\n                     let mut path_segments = path_segments.clone();\n-                    path_segments.push(PathSegment {\n-                        identifier: Ident::with_empty_ctxt(name),\n-                        parameters: PathParameters::none(),\n-                    });\n+                    path_segments.push(ident.into());\n \n                     if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup\n@@ -3124,13 +3105,13 @@ impl<'a> Resolver<'a> {\n \n     fn report_conflict(&mut self,\n                        parent: Module,\n-                       name: Name,\n+                       ident: Ident,\n                        ns: Namespace,\n                        binding: &NameBinding,\n                        old_binding: &NameBinding) {\n         // Error on the second of two conflicting names\n         if old_binding.span.lo > binding.span.lo {\n-            return self.report_conflict(parent, name, ns, old_binding, binding);\n+            return self.report_conflict(parent, ident, ns, old_binding, binding);\n         }\n \n         let container = match parent.kind {\n@@ -3145,7 +3126,7 @@ impl<'a> Resolver<'a> {\n             false => (\"defined\", \"definition\"),\n         };\n \n-        let span = binding.span;\n+        let (name, span) = (ident.name, binding.span);\n \n         if let Some(s) = self.name_already_seen.get(&name) {\n             if s == &span {\n@@ -3167,40 +3148,19 @@ impl<'a> Resolver<'a> {\n         };\n \n         let mut err = match (old_binding.is_extern_crate(), binding.is_extern_crate()) {\n-            (true, true) => {\n-                let mut e = struct_span_err!(self.session, span, E0259, \"{}\", msg);\n-                e.span_label(span, &format!(\"`{}` was already imported\", name));\n-                e\n-            },\n-            (true, _) | (_, true) if binding.is_import() && old_binding.is_import() => {\n-                let mut e = struct_span_err!(self.session, span, E0254, \"{}\", msg);\n-                e.span_label(span, &\"already imported\");\n-                e\n-            },\n-            (true, _) | (_, true) => {\n-                let mut e = struct_span_err!(self.session, span, E0260, \"{}\", msg);\n-                e.span_label(span, &format!(\"`{}` already imported\", name));\n-                e\n+            (true, true) => struct_span_err!(self.session, span, E0259, \"{}\", msg),\n+            (true, _) | (_, true) => match binding.is_import() && old_binding.is_import() {\n+                true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n+                false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n             },\n             _ => match (old_binding.is_import(), binding.is_import()) {\n-                (false, false) => {\n-                    let mut e = struct_span_err!(self.session, span, E0428, \"{}\", msg);\n-                    e.span_label(span, &format!(\"already defined\"));\n-                    e\n-                },\n-                (true, true) => {\n-                    let mut e = struct_span_err!(self.session, span, E0252, \"{}\", msg);\n-                    e.span_label(span, &format!(\"already imported\"));\n-                    e\n-                },\n-                _ => {\n-                    let mut e = struct_span_err!(self.session, span, E0255, \"{}\", msg);\n-                    e.span_label(span, &format!(\"`{}` was already imported\", name));\n-                    e\n-                }\n+                (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n+                (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n+                _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n             },\n         };\n \n+        err.span_label(span, &format!(\"`{}` already {}\", name, participle));\n         if old_binding.span != syntax_pos::DUMMY_SP {\n             err.span_label(old_binding.span, &format!(\"previous {} of `{}` here\", noun, name));\n         }"}, {"sha": "dfeb66e1d8c7698d8c2baf26bb140a9f63867870", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 64, "deletions": 44, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -19,11 +19,12 @@ use rustc::hir::map::{self, DefCollector};\n use rustc::ty;\n use std::cell::Cell;\n use std::rc::Rc;\n-use syntax::ast::{self, Name};\n+use syntax::ast::{self, Name, Ident};\n+use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n-use syntax::ext::base::{NormalTT, SyntaxExtension};\n-use syntax::ext::expand::Expansion;\n+use syntax::ext::base::{NormalTT, Resolver as SyntaxResolver, SyntaxExtension};\n+use syntax::ext::expand::{Expansion, mark_tts};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{emit_feature_err, GateIssue};\n@@ -138,34 +139,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         invocation.expansion.set(visitor.legacy_scope);\n     }\n \n-    fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef, export: bool) {\n-        if def.ident.name == \"macro_rules\" {\n-            self.session.span_err(def.span, \"user-defined macros may not be named `macro_rules`\");\n-        }\n-\n-        let invocation = self.invocations[&scope];\n-        let binding = self.arenas.alloc_legacy_binding(LegacyBinding {\n-            parent: Cell::new(invocation.legacy_scope.get()),\n-            name: def.ident.name,\n-            ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n-            span: def.span,\n-        });\n-        invocation.legacy_scope.set(LegacyScope::Binding(binding));\n-        self.macro_names.insert(def.ident.name);\n-\n-        if export {\n-            def.id = self.next_node_id();\n-            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n-                collector.visit_macro_def(&def)\n-            });\n-            self.macro_exports.push(Export {\n-                name: def.ident.name,\n-                def: Def::Macro(self.definitions.local_def_id(def.id)),\n-            });\n-            self.exported_macros.push(def);\n-        }\n-    }\n-\n     fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n         if let NormalTT(..) = *ext {\n             self.macro_names.insert(ident.name);\n@@ -210,9 +183,9 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, force: bool)\n                      -> Result<Rc<SyntaxExtension>, Determinacy> {\n         let ast::Path { ref segments, global, span } = *path;\n-        if segments.iter().any(|segment| !segment.parameters.is_empty()) {\n+        if segments.iter().any(|segment| segment.parameters.is_some()) {\n             let kind =\n-                if segments.last().unwrap().parameters.is_empty() { \"module\" } else { \"macro\" };\n+                if segments.last().unwrap().parameters.is_some() { \"macro\" } else { \"module\" };\n             let msg = format!(\"type parameters are not allowed on {}s\", kind);\n             self.session.span_err(path.span, &msg);\n             return Err(Determinacy::Determined);\n@@ -232,7 +205,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n             }\n \n             let ext = match self.resolve_path(&path, path_scope, Some(MacroNS), None) {\n-                PathResult::NonModule(path_res) => Ok(self.get_macro(path_res.base_def)),\n+                PathResult::NonModule(path_res) => match path_res.base_def {\n+                    Def::Err => Err(Determinacy::Determined),\n+                    def @ _ => Ok(self.get_macro(def)),\n+                },\n                 PathResult::Module(..) => unreachable!(),\n                 PathResult::Indeterminate if !force => return Err(Determinacy::Undetermined),\n                 _ => Err(Determinacy::Determined),\n@@ -246,7 +222,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let result = match self.resolve_legacy_scope(&invocation.legacy_scope, name, false) {\n             Some(MacroBinding::Legacy(binding)) => Ok(binding.ext.clone()),\n             Some(MacroBinding::Modern(binding)) => Ok(binding.get_macro(self)),\n-            None => match self.resolve_lexical_macro_path_segment(name, MacroNS, None) {\n+            None => match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n                 Ok(binding) => Ok(binding.get_macro(self)),\n                 Err(Determinacy::Undetermined) if !force => return Err(Determinacy::Undetermined),\n                 _ => {\n@@ -260,7 +236,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         };\n \n         if self.use_extern_macros {\n-            self.current_module.legacy_macro_resolutions.borrow_mut().push((scope, name, span));\n+            self.current_module.legacy_macro_resolutions.borrow_mut().push((scope, path[0], span));\n         }\n         result\n     }\n@@ -269,7 +245,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n impl<'a> Resolver<'a> {\n     // Resolve the initial segment of a non-global macro path (e.g. `foo` in `foo::bar!();`)\n     pub fn resolve_lexical_macro_path_segment(&mut self,\n-                                              name: Name,\n+                                              ident: Ident,\n                                               ns: Namespace,\n                                               record_used: Option<Span>)\n                                               -> Result<&'a NameBinding<'a>, Determinacy> {\n@@ -278,14 +254,15 @@ impl<'a> Resolver<'a> {\n         loop {\n             // Since expanded macros may not shadow the lexical scope (enforced below),\n             // we can ignore unresolved invocations (indicated by the penultimate argument).\n-            match self.resolve_name_in_module(module, name, ns, true, record_used) {\n+            match self.resolve_ident_in_module(module, ident, ns, true, record_used) {\n                 Ok(binding) => {\n                     let span = match record_used {\n                         Some(span) => span,\n                         None => return Ok(binding),\n                     };\n                     match potential_expanded_shadower {\n                         Some(shadower) if shadower.def() != binding.def() => {\n+                            let name = ident.name;\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 span: span, name: name, b1: shadower, b2: binding, lexical: true,\n                             });\n@@ -383,10 +360,10 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        for &(mark, name, span) in module.legacy_macro_resolutions.borrow().iter() {\n+        for &(mark, ident, span) in module.legacy_macro_resolutions.borrow().iter() {\n             let legacy_scope = &self.invocations[&mark].legacy_scope;\n-            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, name, true);\n-            let resolution = self.resolve_lexical_macro_path_segment(name, MacroNS, Some(span));\n+            let legacy_resolution = self.resolve_legacy_scope(legacy_scope, ident.name, true);\n+            let resolution = self.resolve_lexical_macro_path_segment(ident, MacroNS, Some(span));\n             let (legacy_resolution, resolution) = match (legacy_resolution, resolution) {\n                 (Some(legacy_resolution), Ok(resolution)) => (legacy_resolution, resolution),\n                 _ => continue,\n@@ -396,9 +373,9 @@ impl<'a> Resolver<'a> {\n                 MacroBinding::Modern(binding) => (binding.span, \"imported\"),\n                 MacroBinding::Legacy(binding) => (binding.span, \"defined\"),\n             };\n-            let msg1 = format!(\"`{}` could resolve to the macro {} here\", name, participle);\n-            let msg2 = format!(\"`{}` could also resolve to the macro imported here\", name);\n-            self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", name))\n+            let msg1 = format!(\"`{}` could resolve to the macro {} here\", ident, participle);\n+            let msg2 = format!(\"`{}` could also resolve to the macro imported here\", ident);\n+            self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n                 .span_note(legacy_span, &msg1)\n                 .span_note(resolution.span, &msg2)\n                 .emit();\n@@ -442,4 +419,47 @@ impl<'a> Resolver<'a> {\n             expansion.visit_with(def_collector)\n         });\n     }\n+\n+    pub fn define_macro(&mut self, item: &ast::Item, legacy_scope: &mut LegacyScope<'a>) {\n+        let tts = match item.node {\n+            ast::ItemKind::Mac(ref mac) => &mac.node.tts,\n+            _ => unreachable!(),\n+        };\n+\n+        if item.ident.name == \"macro_rules\" {\n+            self.session.span_err(item.span, \"user-defined macros may not be named `macro_rules`\");\n+        }\n+\n+        let mark = Mark::from_placeholder_id(item.id);\n+        let invocation = self.invocations[&mark];\n+        invocation.module.set(self.current_module);\n+\n+        let mut def = ast::MacroDef {\n+            ident: item.ident,\n+            attrs: item.attrs.clone(),\n+            id: ast::DUMMY_NODE_ID,\n+            span: item.span,\n+            body: mark_tts(tts, mark),\n+        };\n+\n+        *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n+            parent: Cell::new(*legacy_scope),\n+            name: def.ident.name,\n+            ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n+            span: def.span,\n+        }));\n+        self.macro_names.insert(def.ident.name);\n+\n+        if attr::contains_name(&def.attrs, \"macro_export\") {\n+            def.id = self.next_node_id();\n+            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n+                collector.visit_macro_def(&def)\n+            });\n+            self.macro_exports.push(Export {\n+                name: def.ident.name,\n+                def: Def::Macro(self.definitions.local_def_id(def.id)),\n+            });\n+            self.exported_macros.push(def);\n+        }\n+    }\n }"}, {"sha": "2c35d7ec4423fcab73e9347094dce7a0bc0277f0", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 73, "deletions": 71, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -12,7 +12,7 @@ use self::ImportDirectiveSubclass::*;\n \n use {AmbiguityError, Module, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n-use {NameBinding, NameBindingKind, PathResult, PathScope, PrivacyError, ToNameBinding};\n+use {NameBinding, NameBindingKind, PathResult, PathScope, PrivacyError};\n use Resolver;\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n@@ -21,7 +21,7 @@ use rustc::ty;\n use rustc::lint::builtin::PRIVATE_IN_PUBLIC;\n use rustc::hir::def::*;\n \n-use syntax::ast::{Ident, NodeId, Name};\n+use syntax::ast::{Ident, NodeId};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n use syntax::symbol::keywords;\n@@ -35,8 +35,8 @@ use std::mem;\n #[derive(Clone, Debug)]\n pub enum ImportDirectiveSubclass<'a> {\n     SingleImport {\n-        target: Name,\n-        source: Name,\n+        target: Ident,\n+        source: Ident,\n         result: PerNS<Cell<Result<&'a NameBinding<'a>, Determinacy>>>,\n     },\n     GlobImport {\n@@ -126,31 +126,32 @@ impl<'a> NameResolution<'a> {\n }\n \n impl<'a> Resolver<'a> {\n-    fn resolution(&self, module: Module<'a>, name: Name, ns: Namespace)\n+    fn resolution(&self, module: Module<'a>, ident: Ident, ns: Namespace)\n                   -> &'a RefCell<NameResolution<'a>> {\n-        *module.resolutions.borrow_mut().entry((name, ns))\n+        *module.resolutions.borrow_mut().entry((ident, ns))\n                .or_insert_with(|| self.arenas.alloc_name_resolution())\n     }\n \n-    /// Attempts to resolve the supplied name in the given module for the given namespace.\n-    /// If successful, returns the binding corresponding to the name.\n+    /// Attempts to resolve `ident` in namespaces `ns` of `module`.\n     /// Invariant: if `record_used` is `Some`, import resolution must be complete.\n-    pub fn resolve_name_in_module(&mut self,\n-                                  module: Module<'a>,\n-                                  name: Name,\n-                                  ns: Namespace,\n-                                  ignore_unresolved_invocations: bool,\n-                                  record_used: Option<Span>)\n-                                  -> Result<&'a NameBinding<'a>, Determinacy> {\n+    pub fn resolve_ident_in_module(&mut self,\n+                                   module: Module<'a>,\n+                                   ident: Ident,\n+                                   ns: Namespace,\n+                                   ignore_unresolved_invocations: bool,\n+                                   record_used: Option<Span>)\n+                                   -> Result<&'a NameBinding<'a>, Determinacy> {\n+        let ident = ident.unhygienize();\n         self.populate_module_if_necessary(module);\n \n-        let resolution = self.resolution(module, name, ns)\n+        let resolution = self.resolution(module, ident, ns)\n             .try_borrow_mut()\n             .map_err(|_| Determined)?; // This happens when there is a cycle of imports\n \n         if let Some(span) = record_used {\n             if let Some(binding) = resolution.binding {\n                 if let Some(shadowed_glob) = resolution.shadows_glob {\n+                    let name = ident.name;\n                     // If we ignore unresolved invocations, we must forbid\n                     // expanded shadowing to avoid time travel.\n                     if ignore_unresolved_invocations &&\n@@ -162,11 +163,11 @@ impl<'a> Resolver<'a> {\n                         });\n                     }\n                 }\n-                if self.record_use(name, ns, binding, span) {\n+                if self.record_use(ident, ns, binding, span) {\n                     return Ok(self.dummy_binding);\n                 }\n                 if !self.is_accessible(binding.vis) {\n-                    self.privacy_errors.push(PrivacyError(span, name, binding));\n+                    self.privacy_errors.push(PrivacyError(span, ident.name, binding));\n                 }\n             }\n \n@@ -194,11 +195,11 @@ impl<'a> Resolver<'a> {\n                     Some(module) => module,\n                     None => return Err(Undetermined),\n                 };\n-                let name = match directive.subclass {\n+                let ident = match directive.subclass {\n                     SingleImport { source, .. } => source,\n                     _ => unreachable!(),\n                 };\n-                match self.resolve_name_in_module(module, name, ns, false, None) {\n+                match self.resolve_ident_in_module(module, ident, ns, false, None) {\n                     Err(Determined) => {}\n                     _ => return Err(Undetermined),\n                 }\n@@ -220,7 +221,7 @@ impl<'a> Resolver<'a> {\n         for directive in module.globs.borrow().iter() {\n             if self.is_accessible(directive.vis.get()) {\n                 if let Some(module) = directive.imported_module.get() {\n-                    let result = self.resolve_name_in_module(module, name, ns, false, None);\n+                    let result = self.resolve_ident_in_module(module, ident, ns, false, None);\n                     if let Err(Undetermined) = result {\n                         return Err(Undetermined);\n                     }\n@@ -272,7 +273,7 @@ impl<'a> Resolver<'a> {\n     // Given a binding and an import directive that resolves to it,\n     // return the corresponding binding defined by the import directive.\n     pub fn import(&mut self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n-                  -> NameBinding<'a> {\n+                  -> &'a NameBinding<'a> {\n         let vis = if binding.pseudo_vis().is_at_least(directive.vis.get(), self) ||\n                      !directive.is_glob() && binding.is_extern_crate() { // c.f. `PRIVATE_IN_PUBLIC`\n             directive.vis.get()\n@@ -286,7 +287,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        NameBinding {\n+        self.arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Import {\n                 binding: binding,\n                 directive: directive,\n@@ -295,16 +296,18 @@ impl<'a> Resolver<'a> {\n             span: directive.span,\n             vis: vis,\n             expansion: directive.expansion,\n-        }\n+        })\n     }\n \n     // Define the name or return the existing binding if there is a collision.\n-    pub fn try_define<T>(&mut self, module: Module<'a>, name: Name, ns: Namespace, binding: T)\n-                         -> Result<(), &'a NameBinding<'a>>\n-        where T: ToNameBinding<'a>\n-    {\n-        let binding = self.arenas.alloc_name_binding(binding.to_name_binding());\n-        self.update_resolution(module, name, ns, |this, resolution| {\n+    pub fn try_define(&mut self,\n+                      module: Module<'a>,\n+                      ident: Ident,\n+                      ns: Namespace,\n+                      binding: &'a NameBinding<'a>)\n+                      -> Result<(), &'a NameBinding<'a>> {\n+        let ident = ident.unhygienize();\n+        self.update_resolution(module, ident, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n                 if binding.is_glob_import() {\n                     if !old_binding.is_glob_import() &&\n@@ -347,13 +350,14 @@ impl<'a> Resolver<'a> {\n \n     // Use `f` to mutate the resolution of the name in the module.\n     // If the resolution becomes a success, define it in the module's glob importers.\n-    fn update_resolution<T, F>(&mut self, module: Module<'a>, name: Name, ns: Namespace, f: F) -> T\n+    fn update_resolution<T, F>(&mut self, module: Module<'a>, ident: Ident, ns: Namespace, f: F)\n+                               -> T\n         where F: FnOnce(&mut Resolver<'a>, &mut NameResolution<'a>) -> T\n     {\n         // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n         // during which the resolution might end up getting re-defined via a glob cycle.\n         let (binding, t) = {\n-            let mut resolution = &mut *self.resolution(module, name, ns).borrow_mut();\n+            let mut resolution = &mut *self.resolution(module, ident, ns).borrow_mut();\n             let old_binding = resolution.binding();\n \n             let t = f(self, resolution);\n@@ -372,7 +376,7 @@ impl<'a> Resolver<'a> {\n         for directive in module.glob_importers.borrow_mut().iter() {\n             if self.is_accessible_from(binding.vis, directive.parent) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent, name, ns, imported_binding);\n+                let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n             }\n         }\n \n@@ -386,7 +390,7 @@ impl<'a> Resolver<'a> {\n             let dummy_binding = self.dummy_binding;\n             let dummy_binding = self.import(dummy_binding, directive);\n             self.per_ns(|this, ns| {\n-                let _ = this.try_define(directive.parent, target, ns, dummy_binding.clone());\n+                let _ = this.try_define(directive.parent, target, ns, dummy_binding);\n             });\n         }\n     }\n@@ -508,15 +512,16 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let mut indeterminate = false;\n         self.per_ns(|this, ns| {\n             if let Err(Undetermined) = result[ns].get() {\n-                result[ns].set(this.resolve_name_in_module(module, source, ns, false, None));\n+                result[ns].set(this.resolve_ident_in_module(module, source, ns, false, None));\n             } else {\n                 return\n             };\n \n+            let parent = directive.parent;\n             match result[ns].get() {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n-                    this.update_resolution(directive.parent, target, ns, |_, resolution| {\n+                    this.update_resolution(parent, target, ns, |_, resolution| {\n                         resolution.single_imports.directive_failed()\n                     });\n                 }\n@@ -531,10 +536,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 }\n                 Ok(binding) => {\n                     let imported_binding = this.import(binding, directive);\n-                    let conflict = this.try_define(directive.parent, target, ns, imported_binding);\n+                    let conflict = this.try_define(parent, target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n-                        let binding = &this.import(binding, directive);\n-                        this.report_conflict(directive.parent, target, ns, binding, old_binding);\n+                        this.report_conflict(parent, target, ns, imported_binding, old_binding);\n                     }\n                 }\n             }\n@@ -564,7 +568,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             _ => return None,\n         };\n \n-        let (name, result) = match directive.subclass {\n+        let (ident, result) = match directive.subclass {\n             SingleImport { source, ref result, .. } => (source, result),\n             GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n                 // Importing a module into itself is not allowed.\n@@ -586,8 +590,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         self.per_ns(|this, ns| {\n             if let Ok(binding) = result[ns].get() {\n                 all_ns_err = false;\n-                if this.record_use(name, ns, binding, directive.span) {\n-                    this.resolution(module, name, ns).borrow_mut().binding =\n+                if this.record_use(ident, ns, binding, directive.span) {\n+                    this.resolution(module, ident, ns).borrow_mut().binding =\n                         Some(this.dummy_binding);\n                 }\n             }\n@@ -596,35 +600,36 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| {\n-                match this.resolve_name_in_module(module, name, ns, false, Some(span)) {\n+                match this.resolve_ident_in_module(module, ident, ns, false, Some(span)) {\n                     Ok(_) => all_ns_failed = false,\n                     _ => {}\n                 }\n             });\n \n             return if all_ns_failed {\n                 let resolutions = module.resolutions.borrow();\n-                let names = resolutions.iter().filter_map(|(&(ref n, _), resolution)| {\n-                    if *n == name { return None; } // Never suggest the same name\n+                let names = resolutions.iter().filter_map(|(&(ref i, _), resolution)| {\n+                    if *i == ident { return None; } // Never suggest the same name\n                     match *resolution.borrow() {\n-                        NameResolution { binding: Some(_), .. } => Some(n),\n+                        NameResolution { binding: Some(_), .. } => Some(&i.name),\n                         NameResolution { single_imports: SingleImports::None, .. } => None,\n-                        _ => Some(n),\n+                        _ => Some(&i.name),\n                     }\n                 });\n-                let lev_suggestion = match find_best_match_for_name(names, &name.as_str(), None) {\n-                    Some(name) => format!(\". Did you mean to use `{}`?\", name),\n-                    None => \"\".to_owned(),\n-                };\n+                let lev_suggestion =\n+                    match find_best_match_for_name(names, &ident.name.as_str(), None) {\n+                        Some(name) => format!(\". Did you mean to use `{}`?\", name),\n+                        None => \"\".to_owned(),\n+                    };\n                 let module_str = module_to_string(module);\n                 let msg = if &module_str == \"???\" {\n-                    format!(\"no `{}` in the root{}\", name, lev_suggestion)\n+                    format!(\"no `{}` in the root{}\", ident, lev_suggestion)\n                 } else {\n-                    format!(\"no `{}` in `{}`{}\", name, module_str, lev_suggestion)\n+                    format!(\"no `{}` in `{}`{}\", ident, module_str, lev_suggestion)\n                 };\n                 Some(msg)\n             } else {\n-                // `resolve_name_in_module` reported a privacy error.\n+                // `resolve_ident_in_module` reported a privacy error.\n                 self.import_dummy_binding(directive);\n                 None\n             }\n@@ -649,18 +654,18 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             if ns == TypeNS && binding.is_extern_crate() {\n                 let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n                                    (error E0364), consider declaring with `pub`\",\n-                                   name);\n+                                   ident);\n                 self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n             } else if ns == TypeNS {\n                 struct_span_err!(self.session, directive.span, E0365,\n-                                 \"`{}` is private, and cannot be reexported\", name)\n-                    .span_label(directive.span, &format!(\"reexport of private `{}`\", name))\n-                    .note(&format!(\"consider declaring type or module `{}` with `pub`\", name))\n+                                 \"`{}` is private, and cannot be reexported\", ident)\n+                    .span_label(directive.span, &format!(\"reexport of private `{}`\", ident))\n+                    .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                     .emit();\n             } else {\n-                let msg = format!(\"`{}` is private, and cannot be reexported\", name);\n+                let msg = format!(\"`{}` is private, and cannot be reexported\", ident);\n                 let note_msg =\n-                    format!(\"consider marking `{}` as `pub` in the imported module\", name);\n+                    format!(\"consider marking `{}` as `pub` in the imported module\", ident);\n                 struct_span_err!(self.session, directive.span, E0364, \"{}\", &msg)\n                     .span_note(directive.span, &note_msg)\n                     .emit();\n@@ -697,21 +702,18 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n-        let bindings = module.resolutions.borrow().iter().filter_map(|(name, resolution)| {\n-            resolution.borrow().binding().map(|binding| (*name, binding))\n+        let bindings = module.resolutions.borrow().iter().filter_map(|(&ident, resolution)| {\n+            resolution.borrow().binding().map(|binding| (ident, binding))\n         }).collect::<Vec<_>>();\n-        for ((name, ns), binding) in bindings {\n+        for ((ident, ns), binding) in bindings {\n             if binding.pseudo_vis() == ty::Visibility::Public || self.is_accessible(binding.vis) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent, name, ns, imported_binding);\n+                let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n             }\n         }\n \n         // Record the destination of this import\n-        if let Some(did) = module.def_id() {\n-            let resolution = PathResolution::new(Def::Mod(did));\n-            self.def_map.insert(directive.id, resolution);\n-        }\n+        self.def_map.insert(directive.id, PathResolution::new(module.def().unwrap()));\n     }\n \n     // Miscellaneous post-processing, including recording reexports, reporting conflicts,\n@@ -725,7 +727,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             reexports = mem::replace(&mut self.macro_exports, Vec::new());\n         }\n \n-        for (&(name, ns), resolution) in module.resolutions.borrow().iter() {\n+        for (&(ident, ns), resolution) in module.resolutions.borrow().iter() {\n             let resolution = resolution.borrow();\n             let binding = match resolution.binding {\n                 Some(binding) => binding,\n@@ -739,7 +741,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     if !def.def_id().is_local() {\n                         self.session.cstore.export_macros(def.def_id().krate);\n                     }\n-                    reexports.push(Export { name: name, def: def });\n+                    reexports.push(Export { name: ident.name, def: def });\n                 }\n             }\n \n@@ -748,7 +750,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                    !orig_binding.vis.is_at_least(binding.vis, self) {\n                     let msg = format!(\"variant `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring its enum as `pub`\",\n-                                      name);\n+                                      ident);\n                     self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, binding.span, msg);\n                 }\n             }"}, {"sha": "e5410c6341f84d2bb0cf40440d241f9aaa199a92", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -201,6 +201,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     if def_id.krate == LOCAL_CRATE {\n                         continue // These are `krate.exported_macros`, handled in `self.visit()`.\n                     }\n+                    let imported_from = self.cx.sess().cstore.original_crate_name(def_id.krate);\n                     let def = match self.cx.sess().cstore.load_macro(def_id, self.cx.sess()) {\n                         LoadedMacro::MacroRules(macro_rules) => macro_rules,\n                         // FIXME(jseyfried): document proc macro reexports\n@@ -217,7 +218,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                         matchers: matchers,\n                         stab: self.stability(def.id),\n                         depr: self.deprecation(def.id),\n-                        imported_from: def.imported_from.map(|ident| ident.name),\n+                        imported_from: Some(imported_from),\n                     })\n                 }\n             }\n@@ -525,7 +526,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             matchers: matchers,\n             stab: self.stability(def.id),\n             depr: self.deprecation(def.id),\n-            imported_from: def.imported_from,\n+            imported_from: None,\n         }\n     }\n }"}, {"sha": "fdd82225b974747990adb31c6a9d8067499011d2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 23, "deletions": 88, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -47,10 +47,14 @@ impl Ident {\n         Ident { name: name, ctxt: SyntaxContext::empty() }\n     }\n \n-   /// Maps a string to an identifier with an empty syntax context.\n-   pub fn from_str(s: &str) -> Ident {\n-       Ident::with_empty_ctxt(Symbol::intern(s))\n-   }\n+    /// Maps a string to an identifier with an empty syntax context.\n+    pub fn from_str(s: &str) -> Ident {\n+        Ident::with_empty_ctxt(Symbol::intern(s))\n+    }\n+\n+    pub fn unhygienize(&self) -> Ident {\n+        Ident { name: self.name, ctxt: SyntaxContext::empty() }\n+    }\n }\n \n impl fmt::Debug for Ident {\n@@ -133,12 +137,7 @@ impl Path {\n         Path {\n             span: s,\n             global: false,\n-            segments: vec![\n-                PathSegment {\n-                    identifier: identifier,\n-                    parameters: PathParameters::none()\n-                }\n-            ],\n+            segments: vec![identifier.into()],\n         }\n     }\n }\n@@ -156,7 +155,15 @@ pub struct PathSegment {\n     /// this is more than just simple syntactic sugar; the use of\n     /// parens affects the region binding rules, so we preserve the\n     /// distinction.\n-    pub parameters: PathParameters,\n+    /// The `Option<P<..>>` wrapper is purely a size optimization;\n+    /// `None` is used to represent both `Path` and `Path<>`.\n+    pub parameters: Option<P<PathParameters>>,\n+}\n+\n+impl From<Ident> for PathSegment {\n+    fn from(id: Ident) -> Self {\n+        PathSegment { identifier: id, parameters: None }\n+    }\n }\n \n /// Parameters of a path segment.\n@@ -170,79 +177,8 @@ pub enum PathParameters {\n     Parenthesized(ParenthesizedParameterData),\n }\n \n-impl PathParameters {\n-    pub fn none() -> PathParameters {\n-        PathParameters::AngleBracketed(AngleBracketedParameterData {\n-            lifetimes: Vec::new(),\n-            types: P::new(),\n-            bindings: P::new(),\n-        })\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => data.is_empty(),\n-\n-            // Even if the user supplied no types, something like\n-            // `X()` is equivalent to `X<(),()>`.\n-            PathParameters::Parenthesized(..) => false,\n-        }\n-    }\n-\n-    pub fn has_lifetimes(&self) -> bool {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => !data.lifetimes.is_empty(),\n-            PathParameters::Parenthesized(_) => false,\n-        }\n-    }\n-\n-    pub fn has_types(&self) -> bool {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => !data.types.is_empty(),\n-            PathParameters::Parenthesized(..) => true,\n-        }\n-    }\n-\n-    /// Returns the types that the user wrote. Note that these do not necessarily map to the type\n-    /// parameters in the parenthesized case.\n-    pub fn types(&self) -> Vec<&P<Ty>> {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => {\n-                data.types.iter().collect()\n-            }\n-            PathParameters::Parenthesized(ref data) => {\n-                data.inputs.iter()\n-                    .chain(data.output.iter())\n-                    .collect()\n-            }\n-        }\n-    }\n-\n-    pub fn lifetimes(&self) -> Vec<&Lifetime> {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => {\n-                data.lifetimes.iter().collect()\n-            }\n-            PathParameters::Parenthesized(_) => {\n-                Vec::new()\n-            }\n-        }\n-    }\n-\n-    pub fn bindings(&self) -> Vec<&TypeBinding> {\n-        match *self {\n-            PathParameters::AngleBracketed(ref data) => {\n-                data.bindings.iter().collect()\n-            }\n-            PathParameters::Parenthesized(_) => {\n-                Vec::new()\n-            }\n-        }\n-    }\n-}\n-\n /// A path like `Foo<'a, T>`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Default)]\n pub struct AngleBracketedParameterData {\n     /// The lifetime parameters for this path segment.\n     pub lifetimes: Vec<Lifetime>,\n@@ -254,9 +190,10 @@ pub struct AngleBracketedParameterData {\n     pub bindings: P<[TypeBinding]>,\n }\n \n-impl AngleBracketedParameterData {\n-    fn is_empty(&self) -> bool {\n-        self.lifetimes.is_empty() && self.types.is_empty() && self.bindings.is_empty()\n+impl Into<Option<P<PathParameters>>> for AngleBracketedParameterData {\n+    fn into(self) -> Option<P<PathParameters>> {\n+        let empty = self.lifetimes.is_empty() && self.types.is_empty() && self.bindings.is_empty();\n+        if empty { None } else { Some(P(PathParameters::AngleBracketed(self))) }\n     }\n }\n \n@@ -1968,8 +1905,6 @@ pub struct MacroDef {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n-    pub imported_from: Option<Ident>,\n-    pub allow_internal_unstable: bool,\n     pub body: Vec<TokenTree>,\n }\n "}, {"sha": "c31bcfbd86992ec7dce23a1647d15d6f9ada2559", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -29,7 +29,6 @@ use symbol::Symbol;\n use util::ThinVec;\n \n use std::cell::{RefCell, Cell};\n-use std::collections::HashSet;\n \n thread_local! {\n     static USED_ATTRS: RefCell<Vec<u64>> = RefCell::new(Vec::new());\n@@ -372,16 +371,6 @@ pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute\n     }\n }\n \n-pub fn mk_doc_attr_outer(id: AttrId, item: MetaItem, is_sugared_doc: bool) -> Attribute {\n-    Attribute {\n-        id: id,\n-        style: ast::AttrStyle::Outer,\n-        value: item,\n-        is_sugared_doc: is_sugared_doc,\n-        span: DUMMY_SP,\n-    }\n-}\n-\n pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, lo: BytePos, hi: BytePos)\n                            -> Attribute {\n     let style = doc_comment_style(&text.as_str());\n@@ -421,13 +410,6 @@ pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str) -> Option<S\n         .and_then(|at| at.value_str())\n }\n \n-pub fn last_meta_item_value_str_by_name(items: &[MetaItem], name: &str) -> Option<Symbol> {\n-    items.iter()\n-         .rev()\n-         .find(|mi| mi.check_name(name))\n-         .and_then(|i| i.value_str())\n-}\n-\n /* Higher-level applications */\n \n pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n@@ -856,18 +838,6 @@ pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n     find_deprecation_generic(diagnostic, attrs.iter(), item_sp)\n }\n \n-pub fn require_unique_names(diagnostic: &Handler, metas: &[MetaItem]) {\n-    let mut set = HashSet::new();\n-    for meta in metas {\n-        let name = meta.name();\n-\n-        if !set.insert(name.clone()) {\n-            panic!(diagnostic.span_fatal(meta.span,\n-                                         &format!(\"duplicate meta item `{}`\", name)));\n-        }\n-    }\n-}\n-\n \n /// Parse #[repr(...)] forms.\n ///"}, {"sha": "8e63f73fdaa7a1f7c6df130338a472fdcbbf6fe8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -217,8 +217,7 @@ pub trait IdentMacroExpander {\n                    cx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    ident: ast::Ident,\n-                   token_tree: Vec<tokenstream::TokenTree>,\n-                   attrs: Vec<ast::Attribute>)\n+                   token_tree: Vec<tokenstream::TokenTree>)\n                    -> Box<MacResult+'cx>;\n }\n \n@@ -234,8 +233,7 @@ impl<F> IdentMacroExpander for F\n                    cx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    ident: ast::Ident,\n-                   token_tree: Vec<tokenstream::TokenTree>,\n-                   _attrs: Vec<ast::Attribute>)\n+                   token_tree: Vec<tokenstream::TokenTree>)\n                    -> Box<MacResult+'cx>\n     {\n         (*self)(cx, sp, ident, token_tree)\n@@ -520,7 +518,6 @@ pub trait Resolver {\n     fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item>;\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion);\n-    fn add_macro(&mut self, scope: Mark, def: ast::MacroDef, export: bool);\n     fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n \n@@ -544,7 +541,6 @@ impl Resolver for DummyResolver {\n     fn eliminate_crate_var(&mut self, item: P<ast::Item>) -> P<ast::Item> { item }\n \n     fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion) {}\n-    fn add_macro(&mut self, _scope: Mark, _def: ast::MacroDef, _export: bool) {}\n     fn add_ext(&mut self, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n     fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n "}, {"sha": "c3dc64f91247bed799f59ed813dff72b423217f9", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -322,21 +322,17 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 bindings: Vec<ast::TypeBinding> )\n                 -> ast::Path {\n         let last_identifier = idents.pop().unwrap();\n-        let mut segments: Vec<ast::PathSegment> = idents.into_iter()\n-                                                      .map(|ident| {\n-            ast::PathSegment {\n-                identifier: ident,\n-                parameters: ast::PathParameters::none(),\n-            }\n-        }).collect();\n-        segments.push(ast::PathSegment {\n-            identifier: last_identifier,\n-            parameters: ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n+        let mut segments: Vec<ast::PathSegment> = idents.into_iter().map(Into::into).collect();\n+        let parameters = if lifetimes.is_empty() && types.is_empty() && bindings.is_empty() {\n+            None\n+        } else {\n+            Some(P(ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n                 lifetimes: lifetimes,\n                 types: P::from_vec(types),\n                 bindings: P::from_vec(bindings),\n-            })\n-        });\n+            })))\n+        };\n+        segments.push(ast::PathSegment { identifier: last_identifier, parameters: parameters });\n         ast::Path {\n             span: sp,\n             global: global,\n@@ -367,13 +363,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                  bindings: Vec<ast::TypeBinding>)\n                  -> (ast::QSelf, ast::Path) {\n         let mut path = trait_path;\n+        let parameters = ast::AngleBracketedParameterData {\n+            lifetimes: lifetimes,\n+            types: P::from_vec(types),\n+            bindings: P::from_vec(bindings),\n+        };\n         path.segments.push(ast::PathSegment {\n             identifier: ident,\n-            parameters: ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n-                lifetimes: lifetimes,\n-                types: P::from_vec(types),\n-                bindings: P::from_vec(bindings),\n-            })\n+            parameters: Some(P(ast::PathParameters::AngleBracketed(parameters))),\n         });\n \n         (ast::QSelf {"}, {"sha": "5d62175fbf23a7af4c44dbf9836ebb499102c086", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -158,7 +158,6 @@ pub struct Invocation {\n \n pub enum InvocationKind {\n     Bang {\n-        attrs: Vec<ast::Attribute>,\n         mac: ast::Mac,\n         ident: Option<Ident>,\n         span: Span,\n@@ -276,7 +275,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             if expansions.len() < depth {\n                 expansions.push(Vec::new());\n             }\n-            expansions[depth - 1].push((mark.as_u32(), expansion));\n+            expansions[depth - 1].push((mark, expansion));\n             if !self.cx.ecfg.single_step {\n                 invocations.extend(new_invocations.into_iter().rev());\n             }\n@@ -287,7 +286,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n         while let Some(expansions) = expansions.pop() {\n             for (mark, expansion) in expansions.into_iter().rev() {\n-                placeholder_expander.add(ast::NodeId::from_u32(mark), expansion);\n+                placeholder_expander.add(mark.as_placeholder_id(), expansion);\n             }\n         }\n \n@@ -386,20 +385,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     /// Expand a macro invocation. Returns the result of expansion.\n     fn expand_bang_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         let (mark, kind) = (invoc.expansion_data.mark, invoc.expansion_kind);\n-        let (attrs, mac, ident, span) = match invoc.kind {\n-            InvocationKind::Bang { attrs, mac, ident, span } => (attrs, mac, ident, span),\n+        let (mac, ident, span) = match invoc.kind {\n+            InvocationKind::Bang { mac, ident, span } => (mac, ident, span),\n             _ => unreachable!(),\n         };\n         let Mac_ { path, tts, .. } = mac.node;\n \n-        // Detect use of feature-gated or invalid attributes on macro invoations\n-        // since they will not be detected after macro expansion.\n-        for attr in attrs.iter() {\n-            feature_gate::check_attribute(&attr, &self.cx.parse_sess,\n-                                          &self.cx.parse_sess.codemap(),\n-                                          &self.cx.ecfg.features.unwrap());\n-        }\n-\n         let extname = path.segments.last().unwrap().identifier.name;\n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n         let marked_tts = mark_tts(&tts, mark);\n@@ -440,7 +431,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     }\n                 });\n \n-                kind.make_from(expander.expand(self.cx, span, ident, marked_tts, attrs))\n+                kind.make_from(expander.expand(self.cx, span, ident, marked_tts))\n             }\n \n             MultiDecorator(..) | MultiModifier(..) | SyntaxExtension::AttrProcMacro(..) => {\n@@ -595,13 +586,11 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 ..self.cx.current_expansion.clone()\n             },\n         });\n-        placeholder(expansion_kind, ast::NodeId::from_u32(mark.as_u32()))\n+        placeholder(expansion_kind, mark.as_placeholder_id())\n     }\n \n-    fn collect_bang(\n-        &mut self, mac: ast::Mac, attrs: Vec<ast::Attribute>, span: Span, kind: ExpansionKind,\n-    ) -> Expansion {\n-        self.collect(kind, InvocationKind::Bang { attrs: attrs, mac: mac, ident: None, span: span })\n+    fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: ExpansionKind) -> Expansion {\n+        self.collect(kind, InvocationKind::Bang { mac: mac, ident: None, span: span })\n     }\n \n     fn collect_attr(&mut self, attr: ast::Attribute, item: Annotatable, kind: ExpansionKind)\n@@ -622,6 +611,16 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n+\n+    // Detect use of feature-gated or invalid attributes on macro invocations\n+    // since they will not be detected after macro expansion.\n+    fn check_attributes(&mut self, attrs: &[ast::Attribute]) {\n+        let codemap = &self.cx.parse_sess.codemap();\n+        let features = self.cx.ecfg.features.unwrap();\n+        for attr in attrs.iter() {\n+            feature_gate::check_attribute(&attr, &self.cx.parse_sess, codemap, features);\n+        }\n+    }\n }\n \n // These are pretty nasty. Ideally, we would keep the tokens around, linked from\n@@ -660,7 +659,8 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n         if let ast::ExprKind::Mac(mac) = expr.node {\n-            self.collect_bang(mac, expr.attrs.into(), expr.span, ExpansionKind::Expr).make_expr()\n+            self.check_attributes(&expr.attrs);\n+            self.collect_bang(mac, expr.span, ExpansionKind::Expr).make_expr()\n         } else {\n             P(noop_fold_expr(expr, self))\n         }\n@@ -671,8 +671,8 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n         if let ast::ExprKind::Mac(mac) = expr.node {\n-            self.collect_bang(mac, expr.attrs.into(), expr.span, ExpansionKind::OptExpr)\n-                .make_opt_expr()\n+            self.check_attributes(&expr.attrs);\n+            self.collect_bang(mac, expr.span, ExpansionKind::OptExpr).make_opt_expr()\n         } else {\n             Some(P(noop_fold_expr(expr, self)))\n         }\n@@ -685,8 +685,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         }\n \n         pat.and_then(|pat| match pat.node {\n-            PatKind::Mac(mac) =>\n-                self.collect_bang(mac, Vec::new(), pat.span, ExpansionKind::Pat).make_pat(),\n+            PatKind::Mac(mac) => self.collect_bang(mac, pat.span, ExpansionKind::Pat).make_pat(),\n             _ => unreachable!(),\n         })\n     }\n@@ -707,8 +706,8 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             }).collect()\n         };\n \n-        let mut placeholder =\n-            self.collect_bang(mac, attrs.into(), stmt.span, ExpansionKind::Stmts).make_stmts();\n+        self.check_attributes(&attrs);\n+        let mut placeholder = self.collect_bang(mac, stmt.span, ExpansionKind::Stmts).make_stmts();\n \n         // If this is a macro invocation with a semicolon, then apply that\n         // semicolon to the final statement produced by expansion.\n@@ -740,18 +739,21 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n         match item.node {\n             ast::ItemKind::Mac(..) => {\n-                if match item.node {\n-                    ItemKind::Mac(ref mac) => mac.node.path.segments.is_empty(),\n-                    _ => unreachable!(),\n-                } {\n-                    return SmallVector::one(item);\n-                }\n+                self.check_attributes(&item.attrs);\n+                let is_macro_def = if let ItemKind::Mac(ref mac) = item.node {\n+                    mac.node.path.segments[0].identifier.name == \"macro_rules\"\n+                } else {\n+                    unreachable!()\n+                };\n \n-                item.and_then(|item| match item.node {\n+                item.and_then(|mut item| match item.node {\n+                    ItemKind::Mac(_) if is_macro_def => {\n+                        item.id = Mark::fresh().as_placeholder_id();\n+                        SmallVector::one(P(item))\n+                    }\n                     ItemKind::Mac(mac) => {\n                         self.collect(ExpansionKind::Items, InvocationKind::Bang {\n                             mac: mac,\n-                            attrs: item.attrs,\n                             ident: Some(item.ident),\n                             span: item.span,\n                         }).make_items()\n@@ -823,7 +825,8 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         match item.node {\n             ast::TraitItemKind::Macro(mac) => {\n                 let ast::TraitItem { attrs, span, .. } = item;\n-                self.collect_bang(mac, attrs, span, ExpansionKind::TraitItems).make_trait_items()\n+                self.check_attributes(&attrs);\n+                self.collect_bang(mac, span, ExpansionKind::TraitItems).make_trait_items()\n             }\n             _ => fold::noop_fold_trait_item(item, self),\n         }\n@@ -841,7 +844,8 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         match item.node {\n             ast::ImplItemKind::Macro(mac) => {\n                 let ast::ImplItem { attrs, span, .. } = item;\n-                self.collect_bang(mac, attrs, span, ExpansionKind::ImplItems).make_impl_items()\n+                self.check_attributes(&attrs);\n+                self.collect_bang(mac, span, ExpansionKind::ImplItems).make_impl_items()\n             }\n             _ => fold::noop_fold_impl_item(item, self),\n         }\n@@ -854,8 +858,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         };\n \n         match ty.node {\n-            ast::TyKind::Mac(mac) =>\n-                self.collect_bang(mac, Vec::new(), ty.span, ExpansionKind::Ty).make_ty(),\n+            ast::TyKind::Mac(mac) => self.collect_bang(mac, ty.span, ExpansionKind::Ty).make_ty(),\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "2af5c2ea9995ef61f20ba390f2efffd5bf043065", "filename": "src/libsyntax/ext/hygiene.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fext%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fext%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fhygiene.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -51,7 +51,11 @@ impl Mark {\n         Mark(id.as_u32())\n     }\n \n-    pub fn as_u32(&self) -> u32 {\n+    pub fn as_placeholder_id(self) -> NodeId {\n+        NodeId::from_u32(self.0)\n+    }\n+\n+    pub fn as_u32(self) -> u32 {\n         self.0\n     }\n }\n@@ -115,12 +119,12 @@ impl SyntaxContext {\n         })\n     }\n \n-   /// If `ident` is macro expanded, return the source ident from the macro definition\n-   /// and the mark of the expansion that created the macro definition.\n-   pub fn source(self) -> (Self /* source context */, Mark /* source macro */) {\n-        let macro_def_ctxt = self.data().prev_ctxt.data();\n-        (macro_def_ctxt.prev_ctxt, macro_def_ctxt.outer_mark)\n-   }\n+    /// If `ident` is macro expanded, return the source ident from the macro definition\n+    /// and the mark of the expansion that created the macro definition.\n+    pub fn source(self) -> (Self /* source context */, Mark /* source macro */) {\n+         let macro_def_ctxt = self.data().prev_ctxt.data();\n+         (macro_def_ctxt.prev_ctxt, macro_def_ctxt.outer_mark)\n+    }\n }\n \n impl fmt::Debug for SyntaxContext {"}, {"sha": "eb4b6144c8d28ad989d2044710ed2cda42b3f49f", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -12,9 +12,10 @@ use ast;\n use codemap::{DUMMY_SP, dummy_spanned};\n use ext::base::ExtCtxt;\n use ext::expand::{Expansion, ExpansionKind};\n+use ext::hygiene::Mark;\n use fold::*;\n use ptr::P;\n-use symbol::{Symbol, keywords};\n+use symbol::keywords;\n use util::move_map::MoveMap;\n use util::small_vector::SmallVector;\n \n@@ -68,10 +69,6 @@ pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n     }\n }\n \n-pub fn macro_scope_placeholder() -> Expansion {\n-    placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n-}\n-\n pub struct PlaceholderExpander<'a, 'b: 'a> {\n     expansions: HashMap<ast::NodeId, Expansion>,\n     cx: &'a mut ExtCtxt<'b>,\n@@ -100,11 +97,12 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n         match item.node {\n-            // Scope placeholder\n-            ast::ItemKind::Mac(_) if item.id == ast::DUMMY_NODE_ID => SmallVector::one(item),\n-            ast::ItemKind::Mac(_) => self.remove(item.id).make_items(),\n-            _ => noop_fold_item(item, self),\n+            ast::ItemKind::Mac(ref mac) if !mac.node.path.segments.is_empty() => {}\n+            ast::ItemKind::Mac(_) => return self.remove(item.id).make_items(),\n+            _ => {}\n         }\n+\n+        noop_fold_item(item, self)\n     }\n \n     fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n@@ -172,10 +170,10 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n             block.stmts = block.stmts.move_flat_map(|mut stmt| {\n                 remaining_stmts -= 1;\n \n-                // Scope placeholder\n+                // `macro_rules!` macro definition\n                 if let ast::StmtKind::Item(ref item) = stmt.node {\n-                    if let ast::ItemKind::Mac(..) = item.node {\n-                        macros.push(item.ident.ctxt.data().outer_mark);\n+                    if let ast::ItemKind::Mac(_) = item.node {\n+                        macros.push(Mark::from_placeholder_id(item.id));\n                         return None;\n                     }\n                 }\n@@ -208,33 +206,13 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n     fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod {\n         let mut module = noop_fold_mod(module, self);\n         module.items = module.items.move_flat_map(|item| match item.node {\n-            ast::ItemKind::Mac(_) => None, // remove scope placeholders from modules\n+            ast::ItemKind::Mac(_) if !self.cx.ecfg.keep_macs => None, // remove macro definitions\n             _ => Some(item),\n         });\n         module\n     }\n-}\n \n-pub fn reconstructed_macro_rules(def: &ast::MacroDef) -> Expansion {\n-    Expansion::Items(SmallVector::one(P(ast::Item {\n-        ident: def.ident,\n-        attrs: def.attrs.clone(),\n-        id: ast::DUMMY_NODE_ID,\n-        node: ast::ItemKind::Mac(ast::Mac {\n-            span: def.span,\n-            node: ast::Mac_ {\n-                path: ast::Path {\n-                    span: DUMMY_SP,\n-                    global: false,\n-                    segments: vec![ast::PathSegment {\n-                        identifier: ast::Ident::with_empty_ctxt(Symbol::intern(\"macro_rules\")),\n-                        parameters: ast::PathParameters::none(),\n-                    }],\n-                },\n-                tts: def.body.clone(),\n-            }\n-        }),\n-        vis: ast::Visibility::Inherited,\n-        span: def.span,\n-    })))\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        mac\n+    }\n }"}, {"sha": "3abd24b50ba9a83baf3473b12d1b5cde2d996eb4", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 36, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -10,10 +10,9 @@\n \n use {ast, attr};\n use syntax_pos::{Span, DUMMY_SP};\n-use ext::base::{DummyResult, ExtCtxt, MacEager, MacResult, SyntaxExtension};\n-use ext::base::{IdentMacroExpander, NormalTT, TTMacroExpander};\n+use ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension};\n+use ext::base::{NormalTT, TTMacroExpander};\n use ext::expand::{Expansion, ExpansionKind};\n-use ext::placeholders;\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_failure_msg};\n@@ -151,38 +150,6 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n     cx.span_fatal(best_fail_spot.substitute_dummy(sp), &best_fail_msg);\n }\n \n-pub struct MacroRulesExpander;\n-impl IdentMacroExpander for MacroRulesExpander {\n-    fn expand(&self,\n-              cx: &mut ExtCtxt,\n-              span: Span,\n-              ident: ast::Ident,\n-              tts: Vec<tokenstream::TokenTree>,\n-              attrs: Vec<ast::Attribute>)\n-              -> Box<MacResult> {\n-        let export = attr::contains_name(&attrs, \"macro_export\");\n-        let def = ast::MacroDef {\n-            ident: ident,\n-            id: ast::DUMMY_NODE_ID,\n-            span: span,\n-            imported_from: None,\n-            body: tts,\n-            allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n-            attrs: attrs,\n-        };\n-\n-        // If keep_macs is true, expands to a MacEager::items instead.\n-        let result = if cx.ecfg.keep_macs {\n-            MacEager::items(placeholders::reconstructed_macro_rules(&def).make_items())\n-        } else {\n-            MacEager::items(placeholders::macro_scope_placeholder().make_items())\n-        };\n-\n-        cx.resolver.add_macro(cx.current_expansion.mark, def, export);\n-        result\n-    }\n-}\n-\n // Note that macro-by-example's input is also matched against a token tree:\n //                   $( $lhs:tt => $rhs:tt );+\n //\n@@ -282,7 +249,7 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n         valid: valid,\n     });\n \n-    NormalTT(exp, Some(def.span), def.allow_internal_unstable)\n+    NormalTT(exp, Some(def.span), attr::contains_name(&def.attrs, \"allow_internal_unstable\"))\n }\n \n fn check_lhs_nt_follows(sess: &ParseSess, lhs: &TokenTree) -> bool {"}, {"sha": "b3753e3e977e331cf424d382694f2bcd28ff0c34", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -438,7 +438,7 @@ pub fn noop_fold_path<T: Folder>(Path {global, segments, span}: Path, fld: &mut\n         global: global,\n         segments: segments.move_map(|PathSegment {identifier, parameters}| PathSegment {\n             identifier: fld.fold_ident(identifier),\n-            parameters: fld.fold_path_parameters(parameters),\n+            parameters: parameters.map(|ps| ps.map(|ps| fld.fold_path_parameters(ps))),\n         }),\n         span: fld.new_span(span)\n     }"}, {"sha": "b9e6605639ead2c8ff0f8ee61cd0814c5df31738", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 9, "deletions": 44, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -634,12 +634,7 @@ mod tests {\n                     node: ast::ExprKind::Path(None, ast::Path {\n                         span: sp(0, 1),\n                         global: false,\n-                        segments: vec![\n-                            ast::PathSegment {\n-                                identifier: Ident::from_str(\"a\"),\n-                                parameters: ast::PathParameters::none(),\n-                            }\n-                        ],\n+                        segments: vec![Ident::from_str(\"a\").into()],\n                     }),\n                     span: sp(0, 1),\n                     attrs: ThinVec::new(),\n@@ -651,19 +646,10 @@ mod tests {\n                    P(ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprKind::Path(None, ast::Path {\n-                            span: sp(0, 6),\n-                            global: true,\n-                            segments: vec![\n-                                ast::PathSegment {\n-                                    identifier: Ident::from_str(\"a\"),\n-                                    parameters: ast::PathParameters::none(),\n-                                },\n-                                ast::PathSegment {\n-                                    identifier: Ident::from_str(\"b\"),\n-                                    parameters: ast::PathParameters::none(),\n-                                }\n-                            ]\n-                        }),\n+                        span: sp(0, 6),\n+                        global: true,\n+                        segments: vec![Ident::from_str(\"a\").into(), Ident::from_str(\"b\").into()],\n+                    }),\n                     span: sp(0, 6),\n                     attrs: ThinVec::new(),\n                    }))\n@@ -772,12 +758,7 @@ mod tests {\n                         node:ast::ExprKind::Path(None, ast::Path{\n                             span: sp(7, 8),\n                             global: false,\n-                            segments: vec![\n-                                ast::PathSegment {\n-                                    identifier: Ident::from_str(\"d\"),\n-                                    parameters: ast::PathParameters::none(),\n-                                }\n-                            ],\n+                            segments: vec![Ident::from_str(\"d\").into()],\n                         }),\n                         span:sp(7,8),\n                         attrs: ThinVec::new(),\n@@ -795,12 +776,7 @@ mod tests {\n                            node: ast::ExprKind::Path(None, ast::Path {\n                                span:sp(0,1),\n                                global:false,\n-                               segments: vec![\n-                                ast::PathSegment {\n-                                    identifier: Ident::from_str(\"b\"),\n-                                    parameters: ast::PathParameters::none(),\n-                                }\n-                               ],\n+                               segments: vec![Ident::from_str(\"b\").into()],\n                             }),\n                            span: sp(0,1),\n                            attrs: ThinVec::new()})),\n@@ -842,12 +818,7 @@ mod tests {\n                                                   node: ast::TyKind::Path(None, ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n-                                        segments: vec![\n-                                            ast::PathSegment {\n-                                                identifier: Ident::from_str(\"i32\"),\n-                                                parameters: ast::PathParameters::none(),\n-                                            }\n-                                        ],\n+                                        segments: vec![Ident::from_str(\"i32\").into()],\n                                         }),\n                                         span:sp(10,13)\n                                     }),\n@@ -890,13 +861,7 @@ mod tests {\n                                                       ast::Path{\n                                                         span:sp(17,18),\n                                                         global:false,\n-                                                        segments: vec![\n-                                                            ast::PathSegment {\n-                                                                identifier: Ident::from_str(\"b\"),\n-                                                                parameters:\n-                                                                ast::PathParameters::none(),\n-                                                            }\n-                                                        ],\n+                                                        segments: vec![Ident::from_str(\"b\").into()],\n                                                       }),\n                                                 span: sp(17,18),\n                                                 attrs: ThinVec::new()})),"}, {"sha": "72462b74e686ca60b1f002f220738dd7e55b162f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -1705,12 +1705,11 @@ impl<'a> Parser<'a> {\n             // Parse types, optionally.\n             let parameters = if self.eat_lt() {\n                 let (lifetimes, types, bindings) = self.parse_generic_values_after_lt()?;\n-\n-                ast::PathParameters::AngleBracketed(ast::AngleBracketedParameterData {\n+                ast::AngleBracketedParameterData {\n                     lifetimes: lifetimes,\n                     types: P::from_vec(types),\n                     bindings: P::from_vec(bindings),\n-                })\n+                }.into()\n             } else if self.eat(&token::OpenDelim(token::Paren)) {\n                 let lo = self.prev_span.lo;\n \n@@ -1727,18 +1726,17 @@ impl<'a> Parser<'a> {\n \n                 let hi = self.prev_span.hi;\n \n-                ast::PathParameters::Parenthesized(ast::ParenthesizedParameterData {\n+                Some(P(ast::PathParameters::Parenthesized(ast::ParenthesizedParameterData {\n                     span: mk_sp(lo, hi),\n                     inputs: inputs,\n                     output: output_ty,\n-                })\n+                })))\n             } else {\n-                ast::PathParameters::none()\n+                None\n             };\n \n             // Assemble and push the result.\n-            segments.push(ast::PathSegment { identifier: identifier,\n-                                             parameters: parameters });\n+            segments.push(ast::PathSegment { identifier: identifier, parameters: parameters });\n \n             // Continue only if we see a `::`\n             if !self.eat(&token::ModSep) {\n@@ -1757,25 +1755,21 @@ impl<'a> Parser<'a> {\n \n             // If we do not see a `::`, stop.\n             if !self.eat(&token::ModSep) {\n-                segments.push(ast::PathSegment {\n-                    identifier: identifier,\n-                    parameters: ast::PathParameters::none()\n-                });\n+                segments.push(identifier.into());\n                 return Ok(segments);\n             }\n \n             // Check for a type segment.\n             if self.eat_lt() {\n                 // Consumed `a::b::<`, go look for types\n                 let (lifetimes, types, bindings) = self.parse_generic_values_after_lt()?;\n-                let parameters = ast::AngleBracketedParameterData {\n-                    lifetimes: lifetimes,\n-                    types: P::from_vec(types),\n-                    bindings: P::from_vec(bindings),\n-                };\n                 segments.push(ast::PathSegment {\n                     identifier: identifier,\n-                    parameters: ast::PathParameters::AngleBracketed(parameters),\n+                    parameters: ast::AngleBracketedParameterData {\n+                        lifetimes: lifetimes,\n+                        types: P::from_vec(types),\n+                        bindings: P::from_vec(bindings),\n+                    }.into(),\n                 });\n \n                 // Consumed `a::b::<T,U>`, check for `::` before proceeding\n@@ -1784,10 +1778,7 @@ impl<'a> Parser<'a> {\n                 }\n             } else {\n                 // Consumed `a::`, go look for `b`\n-                segments.push(ast::PathSegment {\n-                    identifier: identifier,\n-                    parameters: ast::PathParameters::none(),\n-                });\n+                segments.push(identifier.into());\n             }\n         }\n     }\n@@ -1802,10 +1793,7 @@ impl<'a> Parser<'a> {\n             let identifier = self.parse_path_segment_ident()?;\n \n             // Assemble and push the result.\n-            segments.push(ast::PathSegment {\n-                identifier: identifier,\n-                parameters: ast::PathParameters::none()\n-            });\n+            segments.push(identifier.into());\n \n             // If we do not see a `::` or see `::{`/`::*`, stop.\n             if !self.check(&token::ModSep) || self.is_import_coupler() {"}, {"sha": "22e8391de93ed4910d9fbf988db6e3093392c844", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -2349,7 +2349,9 @@ impl<'a> State<'a> {\n \n             try!(self.print_ident(segment.identifier));\n \n-            try!(self.print_path_parameters(&segment.parameters, colons_before_params));\n+            if let Some(ref parameters) = segment.parameters {\n+                try!(self.print_path_parameters(parameters, colons_before_params))\n+            }\n         }\n \n         Ok(())\n@@ -2373,18 +2375,17 @@ impl<'a> State<'a> {\n         try!(word(&mut self.s, \"::\"));\n         let item_segment = path.segments.last().unwrap();\n         try!(self.print_ident(item_segment.identifier));\n-        self.print_path_parameters(&item_segment.parameters, colons_before_params)\n+        match item_segment.parameters {\n+            Some(ref parameters) => self.print_path_parameters(parameters, colons_before_params),\n+            None => Ok(()),\n+        }\n     }\n \n     fn print_path_parameters(&mut self,\n                              parameters: &ast::PathParameters,\n                              colons_before_params: bool)\n                              -> io::Result<()>\n     {\n-        if parameters.is_empty() {\n-            return Ok(());\n-        }\n-\n         if colons_before_params {\n             try!(word(&mut self.s, \"::\"))\n         }"}, {"sha": "4ad760a3cafe4194ca60be1ec28fb9e5c5c12168", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -81,9 +81,8 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         vis: ast::Visibility::Inherited,\n         node: ast::ItemKind::Use(P(codemap::dummy_spanned(ast::ViewPathGlob(ast::Path {\n             global: false,\n-            segments: vec![name, \"prelude\", \"v1\"].into_iter().map(|name| ast::PathSegment {\n-                identifier: ast::Ident::from_str(name),\n-                parameters: ast::PathParameters::none(),\n+            segments: vec![name, \"prelude\", \"v1\"].into_iter().map(|name| {\n+                ast::Ident::from_str(name).into()\n             }).collect(),\n             span: span,\n         })))),"}, {"sha": "7709d3bd1cf1ce27e5bcd1492ac54a34a7ad08b8", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -580,10 +580,7 @@ fn path_node(ids: Vec<Ident>) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n         global: false,\n-        segments: ids.into_iter().map(|identifier| ast::PathSegment {\n-            identifier: identifier,\n-            parameters: ast::PathParameters::none(),\n-        }).collect()\n+        segments: ids.into_iter().map(Into::into).collect(),\n     }\n }\n "}, {"sha": "ad29cb50a84c80221e308b2b381ed08bed08406e", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -178,7 +178,6 @@ pub fn walk_crate<'a, V: Visitor<'a>>(visitor: &mut V, krate: &'a Crate) {\n \n pub fn walk_macro_def<'a, V: Visitor<'a>>(visitor: &mut V, macro_def: &'a MacroDef) {\n     visitor.visit_ident(macro_def.span, macro_def.ident);\n-    walk_opt_ident(visitor, macro_def.span, macro_def.imported_from);\n     walk_list!(visitor, visit_attribute, &macro_def.attrs);\n }\n \n@@ -384,7 +383,9 @@ pub fn walk_path_segment<'a, V: Visitor<'a>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'a PathSegment) {\n     visitor.visit_ident(path_span, segment.identifier);\n-    visitor.visit_path_parameters(path_span, &segment.parameters);\n+    if let Some(ref parameters) = segment.parameters {\n+        visitor.visit_path_parameters(path_span, parameters);\n+    }\n }\n \n pub fn walk_path_parameters<'a, V>(visitor: &mut V,"}, {"sha": "1381490efa194b3bd7a1e7850aa35c394bae9a30", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -59,14 +59,10 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n \n     impl Result {\n         fn path(&self) -> ast::Path {\n-            let segment = ast::PathSegment {\n-                identifier: self.ident,\n-                parameters: ast::PathParameters::none(),\n-            };\n             ast::Path {\n                 span: self.span,\n                 global: false,\n-                segments: vec![segment],\n+                segments: vec![self.ident.into()],\n             }\n         }\n     }"}, {"sha": "e31b29d5cc1b435270cc4cf9949b7825e0b639f7", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -50,8 +50,7 @@ pub mod deriving;\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ext::base::{MacroExpanderFn, NormalTT, IdentTT, MultiModifier, NamedSyntaxExtension};\n-use syntax::ext::tt::macro_rules::MacroRulesExpander;\n+use syntax::ext::base::{MacroExpanderFn, NormalTT, MultiModifier, NamedSyntaxExtension};\n use syntax::symbol::Symbol;\n \n pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n@@ -61,8 +60,6 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n         resolver.add_ext(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n     };\n \n-    register(Symbol::intern(\"macro_rules\"), IdentTT(Box::new(MacroRulesExpander), None, false));\n-\n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n             register(Symbol::intern(stringify!($name)),"}, {"sha": "b2129902ef9c3bac73fa7389e3cee6d64784610b", "filename": "src/test/compile-fail/E0259.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Ftest%2Fcompile-fail%2FE0259.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Ftest%2Fcompile-fail%2FE0259.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0259.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -15,6 +15,6 @@ extern crate collections;\n \n extern crate libc as collections;\n //~^ ERROR E0259\n-//~| NOTE `collections` was already imported\n+//~| NOTE `collections` already imported\n \n fn main() {}"}, {"sha": "e9df8868a1ed9d56a371b34802f629fda27d9c2c", "filename": "src/test/compile-fail/blind-item-item-shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Ftest%2Fcompile-fail%2Fblind-item-item-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Ftest%2Fcompile-fail%2Fblind-item-item-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblind-item-item-shadow.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -12,6 +12,6 @@ mod foo { pub mod foo {  } } //~ NOTE previous definition of `foo` here\n \n use foo::foo;\n //~^ ERROR a module named `foo` has already been defined in this module\n-//~| was already imported\n+//~| `foo` already defined\n \n fn main() {}"}, {"sha": "88e804fb8aa0870df57fc4f6e25a2bb07effb47f", "filename": "src/test/compile-fail/issue-19498.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Ftest%2Fcompile-fail%2Fissue-19498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Ftest%2Fcompile-fail%2Fissue-19498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19498.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -11,13 +11,13 @@\n use self::A; //~ NOTE previous import of `A` here\n use self::B; //~ NOTE previous import of `B` here\n mod A {} //~ ERROR a module named `A` has already been imported in this module\n-//~| `A` was already imported\n+//~| `A` already imported\n pub mod B {} //~ ERROR a module named `B` has already been imported in this module\n-//~| `B` was already imported\n+//~| `B` already imported\n mod C {\n     use C::D; //~ NOTE previous import of `D` here\n     mod D {} //~ ERROR a module named `D` has already been imported in this module\n-    //~| `D` was already imported\n+    //~| `D` already imported\n }\n \n fn main() {}"}, {"sha": "26bb72b862f2ce888560f9a8cf28e013beeab465", "filename": "src/test/compile-fail/issue-24081.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Ftest%2Fcompile-fail%2Fissue-24081.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Ftest%2Fcompile-fail%2Fissue-24081.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24081.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -15,14 +15,14 @@ use std::ops::Div; //~ NOTE previous import\n use std::ops::Rem; //~ NOTE previous import\n \n type Add = bool; //~ ERROR a trait named `Add` has already been imported in this module\n-//~| was already imported\n+//~| `Add` already imported\n struct Sub { x: f32 } //~ ERROR a trait named `Sub` has already been imported in this module\n-//~| was already imported\n+//~| `Sub` already imported\n enum Mul { A, B } //~ ERROR a trait named `Mul` has already been imported in this module\n-//~| was already imported\n+//~| `Mul` already imported\n mod Div { } //~ ERROR a trait named `Div` has already been imported in this module\n-//~| was already imported\n+//~| `Div` already imported\n trait Rem {  } //~ ERROR a trait named `Rem` has already been imported in this module\n-//~| was already imported\n+//~| `Rem` already imported\n \n fn main() {}"}, {"sha": "2083d98e09d310a2da3c446d143f63272edf6d48", "filename": "src/test/compile-fail/resolve-conflict-item-vs-import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/551cb0646ff430f6bf80d1e5f331f8218c1c09b6/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-item-vs-import.rs?ref=551cb0646ff430f6bf80d1e5f331f8218c1c09b6", "patch": "@@ -13,6 +13,6 @@ use std::mem::transmute;\n \n fn transmute() {}\n //~^ ERROR a value named `transmute` has already been imported in this module\n-//~| was already imported\n+//~| `transmute` already imported\n fn main() {\n }"}]}