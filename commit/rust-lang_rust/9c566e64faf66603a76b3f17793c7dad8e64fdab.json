{"sha": "9c566e64faf66603a76b3f17793c7dad8e64fdab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNTY2ZTY0ZmFmNjY2MDNhNzZiM2YxNzc5M2M3ZGFkOGU2NGZkYWI=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2018-05-25T18:56:21Z"}, "committer": {"name": "Jonathan Behrens", "email": "fintelia@gmail.com", "date": "2018-09-05T16:10:09Z"}, "message": "progress on raw_entry", "tree": {"sha": "7d69db7dad68b32fb45ba984dc994562886733cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d69db7dad68b32fb45ba984dc994562886733cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c566e64faf66603a76b3f17793c7dad8e64fdab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c566e64faf66603a76b3f17793c7dad8e64fdab", "html_url": "https://github.com/rust-lang/rust/commit/9c566e64faf66603a76b3f17793c7dad8e64fdab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c566e64faf66603a76b3f17793c7dad8e64fdab/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fintelia", "id": 4943209, "node_id": "MDQ6VXNlcjQ5NDMyMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/4943209?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fintelia", "html_url": "https://github.com/fintelia", "followers_url": "https://api.github.com/users/fintelia/followers", "following_url": "https://api.github.com/users/fintelia/following{/other_user}", "gists_url": "https://api.github.com/users/fintelia/gists{/gist_id}", "starred_url": "https://api.github.com/users/fintelia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fintelia/subscriptions", "organizations_url": "https://api.github.com/users/fintelia/orgs", "repos_url": "https://api.github.com/users/fintelia/repos", "events_url": "https://api.github.com/users/fintelia/events{/privacy}", "received_events_url": "https://api.github.com/users/fintelia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6af55a7c61be881bfb56c79dcea9a56b21dad413", "url": "https://api.github.com/repos/rust-lang/rust/commits/6af55a7c61be881bfb56c79dcea9a56b21dad413", "html_url": "https://github.com/rust-lang/rust/commit/6af55a7c61be881bfb56c79dcea9a56b21dad413"}], "stats": {"total": 463, "additions": 233, "deletions": 230}, "files": [{"sha": "328962af33e92a5c171108af53316571775b9c2c", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 231, "deletions": 229, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/9c566e64faf66603a76b3f17793c7dad8e64fdab/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c566e64faf66603a76b3f17793c7dad8e64fdab/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=9c566e64faf66603a76b3f17793c7dad8e64fdab", "patch": "@@ -1558,35 +1558,60 @@ impl<K, V, S> HashMap<K, V, S>\n     /// Creates a raw entry builder for the HashMap.\n     ///\n     /// Raw entries provide the lowest level of control for searching and\n-    /// manipulating a map. They must be manually initialized with hash and\n-    /// then manually searched. After this, insertions into the entry also\n+    /// manipulating a map. They must be manually initialized with a hash and\n+    /// then manually searched. After this, insertions into a vacant entry\n     /// still require an owned key to be provided.\n     ///\n     /// Raw entries are useful for such exotic situations as:\n     ///\n     /// * Hash memoization\n     /// * Deferring the creation of an owned key until it is known to be required\n-    /// * Using a HashMap where the key type can't or shouldn't be hashed and/or compared\n+    /// * Using a search key that doesn't work with the Borrow trait\n+    /// * Using custom comparison logic without newtype wrappers\n+    ///\n+    /// Because raw entries provide much more low-level control, it's much easier\n+    /// to put the HashMap into an inconsistent state which, while memory-safe,\n+    /// will cause the map to produce seemingly random results. Higher-level and\n+    /// more foolproof APIs like `entry` should be preferred when possible.\n+    ///\n+    /// In particular, the hash used to initialized the raw entry must still be\n+    /// consistent with the hash of the key that is ultimately stored in the entry.\n+    /// This is because implementations of HashMap may need to recompute hashes\n+    /// when resizing, at which point only the keys are available.\n+    ///\n+    /// Raw entries give mutable access to the keys. This must not be used\n+    /// to modify how the key would compare or hash, as the map will not re-evaluate\n+    /// where the key should go, meaning the keys may become \"lost\" if their\n+    /// location does not reflect their state. For instance, if you change a key\n+    /// so that the map now contains keys which compare equal, search may start\n+    /// acting eratically, with two keys randomly masking eachother. Implementations\n+    /// are free to assume this doesn't happen (within the limits of memory-safety).\n     ///\n-    /// Unless you are in such a situation, higher-level and more foolproof APIs like\n-    /// `entry` should be preferred.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    /// # Examples\n+    ///\n+    ///\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn raw_entry(&mut self) -> RawEntryBuilder<K, V, S> {\n         self.reserve(1);\n         RawEntryBuilder { map: self }\n     }\n \n     /// Creates a raw immutable entry builder for the HashMap.\n     ///\n+    /// Raw entries provide the lowest level of control for searching and\n+    /// manipulating a map. They must be manually initialized with a hash and\n+    /// then manually searched.\n+    ///\n     /// This is useful for\n     /// * Hash memoization\n-    /// * Querying a HashMap where the key type can't or shouldn't be hashed and/or compared\n+    /// * Using a search key that doesn't work with the Borrow trait\n+    /// * Using custom comparison logic without newtype wrappers\n     ///\n     /// Unless you are in such a situation, higher-level and more foolproof APIs like\n-    /// `entry` should be preferred.\n+    /// `get` should be preferred.\n     ///\n     /// Immutable raw entries have very limited use; you might instead want `raw_entry`.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n     pub fn raw_entry_immut(&self) -> RawImmutableEntryBuilder<K, V, S> {\n         RawImmutableEntryBuilder { map: self }\n     }\n@@ -1831,49 +1856,73 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n     }\n }\n \n-/// WIP\n-#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+/// A builder for computing where in a HashMap a key-value pair would be stored.\n+///\n+/// See the [`HashMap::raw_entry`][] docs for usage examples.\n+#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n pub struct RawEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n     map: &'a mut HashMap<K, V, S>,\n }\n \n-/// WIP\n-#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+/// A builder for computing where in a HashMap a key-value pair would be stored,\n+/// where the hash has already been specified.\n+///\n+/// See the [`HashMap::raw_entry`][] docs for usage examples.\n+#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n pub struct RawEntryBuilderHashed<'a, K: 'a, V: 'a> {\n     map: &'a mut RawTable<K, V>,\n     hash: SafeHash,\n }\n \n-/// WIP\n-#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+/// A view into a single entry in a map, which may either be vacant or occupied.\n+///\n+/// This is a lower-level version of [`Entry`].\n+///\n+/// This `enum` is constructed from the [`raw_entry`] method on [`HashMap`].\n+///\n+/// [`HashMap`]: struct.HashMap.html\n+/// [`Entry`]: struct.Entry.html\n+/// [`raw_entry`]: struct.HashMap.html#method.raw_entry\n+#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n pub enum RawEntry<'a, K: 'a, V: 'a> {\n-    /// WIP\n+    /// An occupied entry.\n     Occupied(RawOccupiedEntry<'a, K, V>),\n-    /// WIP\n+    /// A vacant entry.\n     Vacant(RawVacantEntry<'a, K, V>),\n }\n \n-/// WIP\n-#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+/// A view into an occupied entry in a `HashMap`.\n+/// It is part of the [`RawEntry`] enum.\n+///\n+/// [`RawEntry`]: enum.RawEntry.html\n+#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n pub struct RawOccupiedEntry<'a, K: 'a, V: 'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n \n-/// WIP\n-#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+/// A view into a vacant entry in a `HashMap`.\n+/// It is part of the [`RawEntry`] enum.\n+///\n+/// [`RawEntry`]: enum.RawEntry.html\n+#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n pub struct RawVacantEntry<'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n-/// WIP\n-#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+/// A builder for computing where in a HashMap a key-value pair would be stored.\n+///\n+/// See the [`HashMap::raw_entry_immut`][] docs for usage examples.\n+#[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n pub struct RawImmutableEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n     map: &'a HashMap<K, V, S>,\n }\n \n-/// WIP\n-#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+/// A builder for computing where in a HashMap a key-value pair would be stored,\n+/// where the hash has already been specified.\n+///\n+/// See the [`HashMap::raw_entry_immut`][] docs for usage examples.\n+#[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n pub struct RawImmutableEntryBuilderHashed<'a, K: 'a, V: 'a> {\n     map: &'a RawTable<K, V>,\n     hash: SafeHash,\n@@ -1883,7 +1932,7 @@ impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n     where S: BuildHasher,\n {\n     /// Initializes the raw entry builder with the hash of the given query value.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn hash_by<Q: ?Sized>(self, k: &Q) -> RawEntryBuilderHashed<'a, K, V>\n         where Q: Hash\n     {\n@@ -1894,7 +1943,7 @@ impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n     }\n \n     /// Initializes the raw entry builder with the hash yielded by the given function.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn hash_with<F>(self, func: F) -> RawEntryBuilderHashed<'a, K, V>\n         where F: FnOnce(S::Hasher) -> u64\n     {\n@@ -1905,7 +1954,7 @@ impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n     }\n \n     /// Searches for the location of the raw entry with the given query value.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn search_by<Q: ?Sized>(self, k: &Q) -> RawEntry<'a, K, V>\n         where K: Borrow<Q>,\n               Q: Eq + Hash\n@@ -1920,7 +1969,7 @@ impl<'a, K, V> RawEntryBuilderHashed<'a, K, V>\n     ///\n     /// Note that it isn't required that the query value be hashable, as the\n     /// builder's hash is used.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn search_by<Q: ?Sized>(self, k: &Q) -> RawEntry<'a, K, V>\n         where K: Borrow<Q>,\n               Q: Eq,\n@@ -1933,7 +1982,7 @@ impl<'a, K, V> RawEntryBuilderHashed<'a, K, V>\n     ///\n     /// Note that mutable access is given to each key that is visited, because\n     /// this land is truly godless, and *someone* might have a use for this.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn search_with<F>(self, func: F) -> RawEntry<'a, K, V>\n         where F: FnMut(&mut K) -> bool,\n     {\n@@ -1955,7 +2004,7 @@ impl<'a, K, V, S> RawImmutableEntryBuilder<'a, K, V, S>\n     where S: BuildHasher,\n {\n     /// Initializes the raw entry builder with the hash of the given query value.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n     pub fn hash_by<Q: ?Sized>(self, k: &Q) -> RawImmutableEntryBuilderHashed<'a, K, V>\n         where Q: Hash\n     {\n@@ -1966,7 +2015,7 @@ impl<'a, K, V, S> RawImmutableEntryBuilder<'a, K, V, S>\n     }\n \n     /// Initializes the raw entry builder with the hash yielded by the given function.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n     pub fn hash_with<F>(self, func: F) -> RawImmutableEntryBuilderHashed<'a, K, V>\n         where F: FnOnce(S::Hasher) -> u64\n     {\n@@ -1977,7 +2026,7 @@ impl<'a, K, V, S> RawImmutableEntryBuilder<'a, K, V, S>\n     }\n \n     /// Searches for the location of the raw entry with the given query value.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n     pub fn search_by<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>\n         where K: Borrow<Q>,\n               Q: Eq + Hash\n@@ -1992,7 +2041,7 @@ impl<'a, K, V> RawImmutableEntryBuilderHashed<'a, K, V>\n     ///\n     /// Note that it isn't required that the query value be hashable, as the\n     /// builder's hash is used.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n     pub fn search_by<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>\n         where K: Borrow<Q>,\n               Q: Eq,\n@@ -2004,7 +2053,7 @@ impl<'a, K, V> RawImmutableEntryBuilderHashed<'a, K, V>\n     ///\n     /// Note that mutable access is given to each key that is visited, because\n     /// this land is truly godless, and *someone* might have a use for this.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n     pub fn search_with<F>(self, func: F) -> Option<(&'a K, &'a V)>\n         where F: FnMut(&K) -> bool,\n     {\n@@ -2021,22 +2070,22 @@ impl<'a, K, V> RawImmutableEntryBuilderHashed<'a, K, V>\n \n impl<'a, K, V> RawEntry<'a, K, V> {\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n-    /// a mutable reference to the value in the entry.\n+    /// mutable references to the key and value in the entry.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map: HashMap<&str, u32> = HashMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n+    /// map.raw_entry().search_by(\"poneyland\").or_insert(\"poneyland\", 12);\n     ///\n     /// assert_eq!(map[\"poneyland\"], 12);\n     ///\n-    /// *map.entry(\"poneyland\").or_insert(12) += 10;\n+    /// *map.raw_entry().search_by(\"poneyland\").or_insert(\"poneyland\", 12).1 += 10;\n     /// assert_eq!(map[\"poneyland\"], 22);\n     /// ```\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn or_insert(self, default_key: K, default_val: V) -> (&'a mut K, &'a mut V) {\n         match self {\n             RawEntry::Occupied(entry) => entry.into_kv(),\n@@ -2045,21 +2094,22 @@ impl<'a, K, V> RawEntry<'a, K, V> {\n     }\n \n     /// Ensures a value is in the entry by inserting the result of the default function if empty,\n-    /// and returns a mutable reference to the value in the entry.\n+    /// and returns mutable references to the key and value in the entry.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n     ///\n     /// let mut map: HashMap<&str, String> = HashMap::new();\n-    /// let s = \"hoho\".to_string();\n     ///\n-    /// map.entry(\"poneyland\").or_insert_with(|| s);\n+    /// map.raw_entry().search_by(\"poneyland\").or_insert_with(|| {\n+    ///     (\"poneyland\".to_string(), \"hoho\".to_string())\n+    /// });\n     ///\n     /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n     /// ```\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn or_insert_with<F>(self, default: F) -> (&'a mut K, &'a mut V)\n         where F: FnOnce() -> (K, V),\n     {\n@@ -2082,17 +2132,19 @@ impl<'a, K, V> RawEntry<'a, K, V> {\n     ///\n     /// let mut map: HashMap<&str, u32> = HashMap::new();\n     ///\n-    /// map.entry(\"poneyland\")\n-    ///    .and_modify(|e| { *e += 1 })\n-    ///    .or_insert(42);\n+    /// map.raw_entry()\n+    ///    .search_by(\"poneyland\")\n+    ///    .and_modify(|_k, v| { *v += 1 })\n+    ///    .or_insert(\"poneyland\", 42);\n     /// assert_eq!(map[\"poneyland\"], 42);\n     ///\n-    /// map.entry(\"poneyland\")\n-    ///    .and_modify(|e| { *e += 1 })\n-    ///    .or_insert(42);\n+    /// map.raw_entry()\n+    ///    .search_by(\"poneyland\")\n+    ///    .and_modify(|_k, v| { *v += 1 })\n+    ///    .or_insert(\"poneyland\", 42);\n     /// assert_eq!(map[\"poneyland\"], 43);\n     /// ```\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn and_modify<F>(self, f: F) -> Self\n         where F: FnOnce(&mut K, &mut V)\n     {\n@@ -2111,206 +2163,83 @@ impl<'a, K, V> RawEntry<'a, K, V> {\n \n impl<'a, K, V> RawOccupiedEntry<'a, K, V> {\n     /// Gets a reference to the key in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    ///\n-    /// let mut map: HashMap<&str, u32> = HashMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n-    /// ```\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn key(&self) -> &K {\n         self.elem.read().0\n     }\n \n     /// Gets a mutable reference to the key in the entry.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn key_mut(&mut self) -> &mut K {\n         self.elem.read_mut().0\n     }\n \n     /// Converts the entry into a mutable reference to the key in the entry\n     /// with a lifetime bound to the map itself.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn into_key(self) -> &'a mut K {\n         self.elem.into_mut_refs().0\n     }\n \n     /// Gets a reference to the value in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hash_map::Entry;\n-    ///\n-    /// let mut map: HashMap<&str, u32> = HashMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     assert_eq!(o.get(), &12);\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn get(&self) -> &V {\n         self.elem.read().1\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n     /// with a lifetime bound to the map itself.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hash_map::Entry;\n-    ///\n-    /// let mut map: HashMap<&str, u32> = HashMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 12);\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     *o.into_mut() += 10;\n-    /// }\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 22);\n-    /// ```\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.elem.into_mut_refs().1\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hash_map::Entry;\n-    ///\n-    /// let mut map: HashMap<&str, u32> = HashMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 12);\n-    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n-    ///      *o.get_mut() += 10;\n-    /// }\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 22);\n-    /// ```\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.elem.read_mut().1\n     }\n \n     /// Gets a reference to the key and value in the entry.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn kv(&mut self) -> (&K, &V) {\n         self.elem.read()\n     }\n \n     /// Gets a mutable reference to the key and value in the entry.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn kv_mut(&mut self) -> (&mut K, &mut V) {\n         self.elem.read_mut()\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the key and value in the entry\n     /// with a lifetime bound to the map itself.\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn into_kv(self) -> (&'a mut K, &'a mut V) {\n         self.elem.into_mut_refs()\n     }\n \n     /// Sets the value of the entry, and returns the entry's old value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hash_map::Entry;\n-    ///\n-    /// let mut map: HashMap<&str, u32> = HashMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n-    ///     assert_eq!(o.insert(15), 12);\n-    /// }\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 15);\n-    /// ```\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn insert(&mut self, value: V) -> V {\n         mem::replace(self.get_mut(), value)\n     }\n \n     /// Sets the value of the entry, and returns the entry's old value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hash_map::Entry;\n-    ///\n-    /// let mut map: HashMap<&str, u32> = HashMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n-    ///     assert_eq!(o.insert(15), 12);\n-    /// }\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 15);\n-    /// ```\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn insert_key(&mut self, key: K) -> K {\n         mem::replace(self.key_mut(), key)\n     }\n \n     /// Takes the value out of the entry, and returns it.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hash_map::Entry;\n-    ///\n-    /// let mut map: HashMap<&str, u32> = HashMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     assert_eq!(o.remove(), 12);\n-    /// }\n-    ///\n-    /// assert_eq!(map.contains_key(\"poneyland\"), false);\n-    /// ```\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn remove(self) -> V {\n         pop_internal(self.elem).1\n     }\n \n \n     /// Take the ownership of the key and value from the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hash_map::Entry;\n-    ///\n-    /// let mut map: HashMap<&str, u32> = HashMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     // We delete the entry from the map.\n-    ///     o.remove_entry();\n-    /// }\n-    ///\n-    /// assert_eq!(map.contains_key(\"poneyland\"), false);\n-    /// ```\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn remove_entry(self) -> (K, V) {\n         let (k, v, _) = pop_internal(self.elem);\n         (k, v)\n@@ -2320,21 +2249,7 @@ impl<'a, K, V> RawOccupiedEntry<'a, K, V> {\n impl<'a, K, V> RawVacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hash_map::Entry;\n-    ///\n-    /// let mut map: HashMap<&str, u32> = HashMap::new();\n-    ///\n-    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n-    ///     o.insert(37);\n-    /// }\n-    /// assert_eq!(map[\"poneyland\"], 37);\n-    /// ```\n-    #[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn insert(self, key: K, value: V) -> (&'a mut K, &'a mut V) {\n         let b = match self.elem {\n             NeqElem(mut bucket, disp) => {\n@@ -2354,58 +2269,74 @@ impl<'a, K, V> RawVacantEntry<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n impl<'a, K, V, S> Debug for RawEntryBuilder<'a, K, V, S> {\n-    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n-        unimplemented!()\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RawEntryBuilder\")\n+         .finish()\n     }\n }\n \n-/// WIP\n-#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n impl<'a, K, V> Debug for RawEntryBuilderHashed<'a, K, V> {\n-    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n-        unimplemented!()\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RawEntryBuilderHashed\")\n+         .field(\"hash\", &self.hash.inspect())\n+         .finish()\n     }\n }\n \n-/// WIP\n-#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n impl<'a, K, V> Debug for RawEntry<'a, K, V> {\n-    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n-        unimplemented!()\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            RawEntry::Vacant(ref v) => {\n+                f.debug_tuple(\"RawEntry\")\n+                    .field(v)\n+                    .finish()\n+            }\n+            RawEntry::Occupied(ref o) => {\n+                f.debug_tuple(\"RawEntry\")\n+                    .field(o)\n+                    .finish()\n+            }\n+        }\n     }\n }\n \n-/// WIP\n-#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n impl<'a, K, V> Debug for RawOccupiedEntry<'a, K, V> {\n-    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n-        unimplemented!()\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RawOccupiedEntry\")\n+         .field(\"key\", self.key())\n+         .field(\"value\", self.get())\n+         .finish()\n     }\n }\n \n-/// WIP\n-#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n impl<'a, K, V> Debug for RawVacantEntry<'a, K, V> {\n-    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n-        unimplemented!()\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RawVacantEntry\")\n+         .field(\"hash\", &self.hash.inspect())\n+         .finish()\n     }\n }\n \n-/// WIP\n-#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n impl<'a, K, V, S> Debug for RawImmutableEntryBuilder<'a, K, V, S> {\n-    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n-        unimplemented!()\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RawImmutableEntryBuilder\")\n+         .finish()\n     }\n }\n \n-/// WIP\n-#[unstable(feature = \"raw_entry\", issue = \"42069\")]\n+#[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n impl<'a, K, V> Debug for RawImmutableEntryBuilderHashed<'a, K, V> {\n-    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n-        unimplemented!()\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"RawImmutableEntryBuilderHashed\")\n+         .field(\"hash\", &self.hash.inspect())\n+         .finish()\n     }\n }\n \n@@ -3432,7 +3363,6 @@ fn assert_covariance() {\n #[cfg(test)]\n mod test_map {\n     use super::HashMap;\n-    use super::Entry::{Occupied, Vacant};\n     use super::RandomState;\n     use cell::RefCell;\n     use rand::{thread_rng, Rng};\n@@ -3671,6 +3601,8 @@ mod test_map {\n \n     #[test]\n     fn test_empty_entry() {\n+        use super::Entry::{Occupied, Vacant};\n+\n         let mut m: HashMap<i32, bool> = HashMap::new();\n         match m.entry(0) {\n             Occupied(_) => panic!(),\n@@ -4129,6 +4061,8 @@ mod test_map {\n \n     #[test]\n     fn test_entry() {\n+        use super::Entry::{Occupied, Vacant};\n+\n         let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n         let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n@@ -4182,6 +4116,9 @@ mod test_map {\n     #[test]\n     fn test_entry_take_doesnt_corrupt() {\n         #![allow(deprecated)] //rand\n+\n+        use super::Entry::{Occupied, Vacant};\n+\n         // Test for #19292\n         fn check(m: &HashMap<i32, ()>) {\n             for k in m.keys() {\n@@ -4256,6 +4193,8 @@ mod test_map {\n \n     #[test]\n     fn test_occupied_entry_key() {\n+        use super::Entry::{Occupied, Vacant};\n+\n         let mut a = HashMap::new();\n         let key = \"hello there\";\n         let value = \"value goes here\";\n@@ -4274,6 +4213,8 @@ mod test_map {\n \n     #[test]\n     fn test_vacant_entry_key() {\n+        use super::Entry::{Occupied, Vacant};\n+\n         let mut a = HashMap::new();\n         let key = \"hello there\";\n         let value = \"value goes here\";\n@@ -4349,4 +4290,65 @@ mod test_map {\n         }\n     }\n \n+    #[test]\n+    fn test_raw_entry() {\n+        use super::RawEntry::{Occupied, Vacant};\n+\n+        let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n+\n+        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n+\n+        // Existing key (insert)\n+        match map.raw_entry().search_by(&1) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                assert_eq!(view.get(), &10);\n+                assert_eq!(view.insert(100), 10);\n+            }\n+        }\n+        assert_eq!(map.raw_entry_immut().hash_with(|mut h| {\n+            1.hash(&mut h);\n+            h.finish()\n+        }).search_with(|k| *k == 1)\n+          .unwrap(), (&10, &100));\n+        assert_eq!(map.len(), 6);\n+\n+\n+        // Existing key (update)\n+        match map.raw_entry().hash_by(&2).search_by(&2) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                let v = view.get_mut();\n+                let new_v = (*v) * 10;\n+                *v = new_v;\n+            }\n+        }\n+        assert_eq!(map.raw_entry_immut().search_by(&2).unwrap(), (&2, &200));\n+        assert_eq!(map.len(), 6);\n+\n+        // Existing key (take)\n+        match map.raw_entry().hash_with(|mut h| {\n+            3.hash(&mut h);\n+            h.finish()\n+        }).search_with(|k| *k == 3) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(view) => {\n+                assert_eq!(view.remove_kv(), (3, 30));\n+            }\n+        }\n+        assert_eq!(map.raw_entry_immut().search_by(&3), None);\n+        assert_eq!(map.len(), 5);\n+\n+\n+        // Inexistent key (insert)\n+        match map.raw_entry().search_by(&10) {\n+            Occupied(_) => unreachable!(),\n+            Vacant(view) => {\n+                assert_eq!(view.insert(10, 1000), (&mut 10, &mut 1000));\n+            }\n+        }\n+        assert_eq!(map.raw_entry_immut().hash_by(&10).search_by(&10).unwrap(), (&10, &1000));\n+        assert_eq!(map.len(), 6);\n+    }\n+\n }"}, {"sha": "01f5ef445403cf22b08296cd9b439315f3825fc8", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c566e64faf66603a76b3f17793c7dad8e64fdab/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c566e64faf66603a76b3f17793c7dad8e64fdab/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9c566e64faf66603a76b3f17793c7dad8e64fdab", "patch": "@@ -284,7 +284,8 @@\n #![feature(prelude_import)]\n #![feature(ptr_internals)]\n #![feature(raw)]\n-#![feature(raw_entry)]\n+#![feature(hash_raw_entry)]\n+#![feature(hash_raw_entry_immut)]\n #![feature(rustc_attrs)]\n #![feature(rustc_const_unstable)]\n #![feature(std_internals)]"}]}