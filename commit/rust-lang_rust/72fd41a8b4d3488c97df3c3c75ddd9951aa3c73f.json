{"sha": "72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "node_id": "C_kwDOAAsO6NoAKDcyZmQ0MWE4YjRkMzQ4OGM5N2RmM2MzYzc1ZGRkOTk1MWFhM2M3M2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-21T13:41:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-21T13:41:37Z"}, "message": "Auto merge of #98335 - JohnTitor:rollup-j2zudxv, r=JohnTitor\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #94033 (Improve docs for `is_running` to explain use case)\n - #97269 (adjust transmute const stabilization version)\n - #97805 (Add proper tracing spans to rustc_trait_selection::traits::error_reporting)\n - #98022 (Fix erroneous span for borrowck error)\n - #98124 (Improve loading of crates.js and sidebar-items.js)\n - #98278 (Some token stream cleanups)\n - #98306 (`try_fold_unevaluated` for infallible folders)\n - #98313 (Remove lies in comments.)\n - #98323 (:arrow_up: rust-analyzer)\n - #98329 (Avoid an ICE and instead let the compiler report a useful error)\n - #98330 (update ioslice docs to use shared slices)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "2d58bdad267a557b934a58558900b57ea1fed4b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d58bdad267a557b934a58558900b57ea1fed4b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "html_url": "https://github.com/rust-lang/rust/commit/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a25b1315ee968146a5b206a8f3c670c5b307ebfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a25b1315ee968146a5b206a8f3c670c5b307ebfe", "html_url": "https://github.com/rust-lang/rust/commit/a25b1315ee968146a5b206a8f3c670c5b307ebfe"}, {"sha": "e5092425eb722910b2caeac1148d023fc6e95ba2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5092425eb722910b2caeac1148d023fc6e95ba2", "html_url": "https://github.com/rust-lang/rust/commit/e5092425eb722910b2caeac1148d023fc6e95ba2"}], "stats": {"total": 693, "additions": 359, "deletions": 334}, "files": [{"sha": "37de90d64c774409d4ecdb353fdfb1f7d5e052e3", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 57, "deletions": 95, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -25,7 +25,7 @@ use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n-use std::{fmt, iter, mem};\n+use std::{fmt, iter};\n \n /// When the main Rust parser encounters a syntax-extension invocation, it\n /// parses the arguments to the invocation as a token tree. This is a very\n@@ -399,45 +399,6 @@ impl TokenStream {\n         self.0.len()\n     }\n \n-    pub fn from_streams(mut streams: SmallVec<[TokenStream; 2]>) -> TokenStream {\n-        match streams.len() {\n-            0 => TokenStream::default(),\n-            1 => streams.pop().unwrap(),\n-            _ => {\n-                // We are going to extend the first stream in `streams` with\n-                // the elements from the subsequent streams. This requires\n-                // using `make_mut()` on the first stream, and in practice this\n-                // doesn't cause cloning 99.9% of the time.\n-                //\n-                // One very common use case is when `streams` has two elements,\n-                // where the first stream has any number of elements within\n-                // (often 1, but sometimes many more) and the second stream has\n-                // a single element within.\n-\n-                // Determine how much the first stream will be extended.\n-                // Needed to avoid quadratic blow up from on-the-fly\n-                // reallocations (#57735).\n-                let num_appends = streams.iter().skip(1).map(|ts| ts.len()).sum();\n-\n-                // Get the first stream. If it's `None`, create an empty\n-                // stream.\n-                let mut iter = streams.drain(..);\n-                let mut first_stream_lrc = iter.next().unwrap().0;\n-\n-                // Append the elements to the first stream, after reserving\n-                // space for them.\n-                let first_vec_mut = Lrc::make_mut(&mut first_stream_lrc);\n-                first_vec_mut.reserve(num_appends);\n-                for stream in iter {\n-                    first_vec_mut.extend(stream.0.iter().cloned());\n-                }\n-\n-                // Create the final `TokenStream`.\n-                TokenStream(first_stream_lrc)\n-            }\n-        }\n-    }\n-\n     pub fn trees(&self) -> CursorRef<'_> {\n         CursorRef::new(self)\n     }\n@@ -562,50 +523,65 @@ impl TokenStreamBuilder {\n     }\n \n     pub fn push<T: Into<TokenStream>>(&mut self, stream: T) {\n-        let mut stream = stream.into();\n-\n-        // If `self` is not empty and the last tree within the last stream is a\n-        // token tree marked with `Joint`...\n-        if let Some(TokenStream(ref mut last_stream_lrc)) = self.0.last_mut()\n-            && let Some((TokenTree::Token(last_token), Spacing::Joint)) = last_stream_lrc.last()\n-            // ...and `stream` is not empty and the first tree within it is\n-            // a token tree...\n-            && let TokenStream(ref mut stream_lrc) = stream\n-            && let Some((TokenTree::Token(token), spacing)) = stream_lrc.first()\n-            // ...and the two tokens can be glued together...\n-            && let Some(glued_tok) = last_token.glue(&token)\n-        {\n-            // ...then do so, by overwriting the last token\n-            // tree in `self` and removing the first token tree\n-            // from `stream`. This requires using `make_mut()`\n-            // on the last stream in `self` and on `stream`,\n-            // and in practice this doesn't cause cloning 99.9%\n-            // of the time.\n-\n-            // Overwrite the last token tree with the merged\n-            // token.\n-            let last_vec_mut = Lrc::make_mut(last_stream_lrc);\n-            *last_vec_mut.last_mut().unwrap() = (TokenTree::Token(glued_tok), *spacing);\n-\n-            // Remove the first token tree from `stream`. (This\n-            // is almost always the only tree in `stream`.)\n-            let stream_vec_mut = Lrc::make_mut(stream_lrc);\n-            stream_vec_mut.remove(0);\n-\n-            // Don't push `stream` if it's empty -- that could\n-            // block subsequent token gluing, by getting\n-            // between two token trees that should be glued\n-            // together.\n-            if !stream.is_empty() {\n-                self.0.push(stream);\n-            }\n-            return;\n-        }\n-        self.0.push(stream);\n+        self.0.push(stream.into());\n     }\n \n     pub fn build(self) -> TokenStream {\n-        TokenStream::from_streams(self.0)\n+        let mut streams = self.0;\n+        match streams.len() {\n+            0 => TokenStream::default(),\n+            1 => streams.pop().unwrap(),\n+            _ => {\n+                // We will extend the first stream in `streams` with the\n+                // elements from the subsequent streams. This requires using\n+                // `make_mut()` on the first stream, and in practice this\n+                // doesn't cause cloning 99.9% of the time.\n+                //\n+                // One very common use case is when `streams` has two elements,\n+                // where the first stream has any number of elements within\n+                // (often 1, but sometimes many more) and the second stream has\n+                // a single element within.\n+\n+                // Determine how much the first stream will be extended.\n+                // Needed to avoid quadratic blow up from on-the-fly\n+                // reallocations (#57735).\n+                let num_appends = streams.iter().skip(1).map(|ts| ts.len()).sum();\n+\n+                // Get the first stream, which will become the result stream.\n+                // If it's `None`, create an empty stream.\n+                let mut iter = streams.drain(..);\n+                let mut res_stream_lrc = iter.next().unwrap().0;\n+\n+                // Append the subsequent elements to the result stream, after\n+                // reserving space for them.\n+                let res_vec_mut = Lrc::make_mut(&mut res_stream_lrc);\n+                res_vec_mut.reserve(num_appends);\n+                for stream in iter {\n+                    let stream_iter = stream.0.iter().cloned();\n+\n+                    // If (a) `res_mut_vec` is not empty and the last tree\n+                    // within it is a token tree marked with `Joint`, and (b)\n+                    // `stream` is not empty and the first tree within it is a\n+                    // token tree, and (c) the two tokens can be glued\n+                    // together...\n+                    if let Some((TokenTree::Token(last_tok), Spacing::Joint)) = res_vec_mut.last()\n+                        && let Some((TokenTree::Token(tok), spacing)) = stream.0.first()\n+                        && let Some(glued_tok) = last_tok.glue(&tok)\n+                    {\n+                        // ...then overwrite the last token tree in\n+                        // `res_vec_mut` with the glued token, and skip the\n+                        // first token tree from `stream`.\n+                        *res_vec_mut.last_mut().unwrap() = (TokenTree::Token(glued_tok), *spacing);\n+                        res_vec_mut.extend(stream_iter.skip(1));\n+                    } else {\n+                        // Append all of `stream`.\n+                        res_vec_mut.extend(stream_iter);\n+                    }\n+                }\n+\n+                TokenStream(res_stream_lrc)\n+            }\n+        }\n     }\n }\n \n@@ -679,20 +655,6 @@ impl Cursor {\n         })\n     }\n \n-    pub fn index(&self) -> usize {\n-        self.index\n-    }\n-\n-    pub fn append(&mut self, new_stream: TokenStream) {\n-        if new_stream.is_empty() {\n-            return;\n-        }\n-        let index = self.index;\n-        let stream = mem::take(&mut self.stream);\n-        *self = TokenStream::from_streams(smallvec![stream, new_stream]).into_trees();\n-        self.index = index;\n-    }\n-\n     pub fn look_ahead(&self, n: usize) -> Option<&TokenTree> {\n         self.stream.0[self.index..].get(n).map(|(tree, _)| tree)\n     }"}, {"sha": "355254fe9429b89f773817d5e706966ce82e30b2", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -357,12 +357,20 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                 .add_element(live_region_vid, location);\n         });\n \n+        // HACK(compiler-errors): Constants that are gathered into Body.required_consts\n+        // have their locations erased...\n+        let locations = if location != Location::START {\n+            location.to_locations()\n+        } else {\n+            Locations::All(constant.span)\n+        };\n+\n         if let Some(annotation_index) = constant.user_ty {\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n                 constant.literal.ty(),\n                 ty::Variance::Invariant,\n                 &UserTypeProjection { base: annotation_index, projs: vec![] },\n-                location.to_locations(),\n+                locations,\n                 ConstraintCategory::Boring,\n             ) {\n                 let annotation = &self.cx.user_type_annotations[annotation_index];\n@@ -390,12 +398,9 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                                      promoted: &Body<'tcx>,\n                                      ty,\n                                      san_ty| {\n-                        if let Err(terr) = verifier.cx.eq_types(\n-                            ty,\n-                            san_ty,\n-                            location.to_locations(),\n-                            ConstraintCategory::Boring,\n-                        ) {\n+                        if let Err(terr) =\n+                            verifier.cx.eq_types(ty, san_ty, locations, ConstraintCategory::Boring)\n+                        {\n                             span_mirbug!(\n                                 verifier,\n                                 promoted,\n@@ -416,7 +421,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                     }\n                 } else {\n                     if let Err(terr) = self.cx.fully_perform_op(\n-                        location.to_locations(),\n+                        locations,\n                         ConstraintCategory::Boring,\n                         self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n                             constant.literal.ty(),\n@@ -435,7 +440,6 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                 }\n             } else if let Some(static_def_id) = constant.check_static_ptr(tcx) {\n                 let unnormalized_ty = tcx.type_of(static_def_id);\n-                let locations = location.to_locations();\n                 let normalized_ty = self.cx.normalize(unnormalized_ty, locations);\n                 let literal_ty = constant.literal.ty().builtin_deref(true).unwrap().ty;\n \n@@ -454,7 +458,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                 self.cx.normalize_and_prove_instantiated_predicates(\n                     def_id,\n                     instantiated_predicates,\n-                    location.to_locations(),\n+                    locations,\n                 );\n             }\n         }"}, {"sha": "1e4193a5a16cc6cc7f360cb09ef4a91277e2bbbd", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -329,6 +329,7 @@ impl Ident {\n         sess.symbol_gallery.insert(sym, span);\n         Ident { sym, is_raw, span }\n     }\n+\n     fn dollar_crate(span: Span) -> Ident {\n         // `$crate` is accepted as an ident only if it comes from the compiler.\n         Ident { sym: kw::DollarCrate, is_raw: false, span }\n@@ -403,6 +404,7 @@ impl server::TokenStream for Rustc<'_, '_> {\n     fn is_empty(&mut self, stream: &Self::TokenStream) -> bool {\n         stream.is_empty()\n     }\n+\n     fn from_str(&mut self, src: &str) -> Self::TokenStream {\n         parse_stream_from_source_str(\n             FileName::proc_macro_source_code(src),\n@@ -411,9 +413,11 @@ impl server::TokenStream for Rustc<'_, '_> {\n             Some(self.call_site),\n         )\n     }\n+\n     fn to_string(&mut self, stream: &Self::TokenStream) -> String {\n         pprust::tts_to_string(stream)\n     }\n+\n     fn expand_expr(&mut self, stream: &Self::TokenStream) -> Result<Self::TokenStream, ()> {\n         // Parse the expression from our tokenstream.\n         let expr: PResult<'_, _> = try {\n@@ -464,12 +468,14 @@ impl server::TokenStream for Rustc<'_, '_> {\n             _ => Err(()),\n         }\n     }\n+\n     fn from_token_tree(\n         &mut self,\n         tree: TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>,\n     ) -> Self::TokenStream {\n         tree.to_internal()\n     }\n+\n     fn concat_trees(\n         &mut self,\n         base: Option<Self::TokenStream>,\n@@ -484,6 +490,7 @@ impl server::TokenStream for Rustc<'_, '_> {\n         }\n         builder.build()\n     }\n+\n     fn concat_streams(\n         &mut self,\n         base: Option<Self::TokenStream>,\n@@ -498,6 +505,7 @@ impl server::TokenStream for Rustc<'_, '_> {\n         }\n         builder.build()\n     }\n+\n     fn into_trees(\n         &mut self,\n         stream: Self::TokenStream,\n@@ -522,10 +530,10 @@ impl server::TokenStream for Rustc<'_, '_> {\n                     // FIXME: It needs to be removed, but there are some\n                     // compatibility issues (see #73345).\n                     if group.flatten {\n-                        cursor.append(group.stream);\n-                        continue;\n+                        tts.append(&mut self.into_trees(group.stream));\n+                    } else {\n+                        tts.push(TokenTree::Group(group));\n                     }\n-                    tts.push(TokenTree::Group(group));\n                 }\n                 Some(tt) => tts.push(tt),\n                 None => return tts,\n@@ -543,21 +551,27 @@ impl server::Group for Rustc<'_, '_> {\n             flatten: false,\n         }\n     }\n+\n     fn delimiter(&mut self, group: &Self::Group) -> Delimiter {\n         group.delimiter\n     }\n+\n     fn stream(&mut self, group: &Self::Group) -> Self::TokenStream {\n         group.stream.clone()\n     }\n+\n     fn span(&mut self, group: &Self::Group) -> Self::Span {\n         group.span.entire()\n     }\n+\n     fn span_open(&mut self, group: &Self::Group) -> Self::Span {\n         group.span.open\n     }\n+\n     fn span_close(&mut self, group: &Self::Group) -> Self::Span {\n         group.span.close\n     }\n+\n     fn set_span(&mut self, group: &mut Self::Group, span: Self::Span) {\n         group.span = DelimSpan::from_single(span);\n     }\n@@ -567,15 +581,19 @@ impl server::Punct for Rustc<'_, '_> {\n     fn new(&mut self, ch: char, spacing: Spacing) -> Self::Punct {\n         Punct::new(ch, spacing == Spacing::Joint, server::Span::call_site(self))\n     }\n+\n     fn as_char(&mut self, punct: Self::Punct) -> char {\n         punct.ch\n     }\n+\n     fn spacing(&mut self, punct: Self::Punct) -> Spacing {\n         if punct.joint { Spacing::Joint } else { Spacing::Alone }\n     }\n+\n     fn span(&mut self, punct: Self::Punct) -> Self::Span {\n         punct.span\n     }\n+\n     fn with_span(&mut self, punct: Self::Punct, span: Self::Span) -> Self::Punct {\n         Punct { span, ..punct }\n     }\n@@ -585,9 +603,11 @@ impl server::Ident for Rustc<'_, '_> {\n     fn new(&mut self, string: &str, span: Self::Span, is_raw: bool) -> Self::Ident {\n         Ident::new(self.sess(), Symbol::intern(string), is_raw, span)\n     }\n+\n     fn span(&mut self, ident: Self::Ident) -> Self::Span {\n         ident.span\n     }\n+\n     fn with_span(&mut self, ident: Self::Ident, span: Self::Span) -> Self::Ident {\n         Ident { span, ..ident }\n     }\n@@ -639,45 +659,57 @@ impl server::Literal for Rustc<'_, '_> {\n \n         Ok(Literal { lit, span: self.call_site })\n     }\n+\n     fn to_string(&mut self, literal: &Self::Literal) -> String {\n         literal.lit.to_string()\n     }\n+\n     fn debug_kind(&mut self, literal: &Self::Literal) -> String {\n         format!(\"{:?}\", literal.lit.kind)\n     }\n+\n     fn symbol(&mut self, literal: &Self::Literal) -> String {\n         literal.lit.symbol.to_string()\n     }\n+\n     fn suffix(&mut self, literal: &Self::Literal) -> Option<String> {\n         literal.lit.suffix.as_ref().map(Symbol::to_string)\n     }\n+\n     fn integer(&mut self, n: &str) -> Self::Literal {\n         self.lit(token::Integer, Symbol::intern(n), None)\n     }\n+\n     fn typed_integer(&mut self, n: &str, kind: &str) -> Self::Literal {\n         self.lit(token::Integer, Symbol::intern(n), Some(Symbol::intern(kind)))\n     }\n+\n     fn float(&mut self, n: &str) -> Self::Literal {\n         self.lit(token::Float, Symbol::intern(n), None)\n     }\n+\n     fn f32(&mut self, n: &str) -> Self::Literal {\n         self.lit(token::Float, Symbol::intern(n), Some(sym::f32))\n     }\n+\n     fn f64(&mut self, n: &str) -> Self::Literal {\n         self.lit(token::Float, Symbol::intern(n), Some(sym::f64))\n     }\n+\n     fn string(&mut self, string: &str) -> Self::Literal {\n         let quoted = format!(\"{:?}\", string);\n         assert!(quoted.starts_with('\"') && quoted.ends_with('\"'));\n         let symbol = &quoted[1..quoted.len() - 1];\n         self.lit(token::Str, Symbol::intern(symbol), None)\n     }\n+\n     fn character(&mut self, ch: char) -> Self::Literal {\n         let quoted = format!(\"{:?}\", ch);\n         assert!(quoted.starts_with('\\'') && quoted.ends_with('\\''));\n         let symbol = &quoted[1..quoted.len() - 1];\n         self.lit(token::Char, Symbol::intern(symbol), None)\n     }\n+\n     fn byte_string(&mut self, bytes: &[u8]) -> Self::Literal {\n         let string = bytes\n             .iter()\n@@ -687,12 +719,15 @@ impl server::Literal for Rustc<'_, '_> {\n             .collect::<String>();\n         self.lit(token::ByteStr, Symbol::intern(&string), None)\n     }\n+\n     fn span(&mut self, literal: &Self::Literal) -> Self::Span {\n         literal.span\n     }\n+\n     fn set_span(&mut self, literal: &mut Self::Literal, span: Self::Span) {\n         literal.span = span;\n     }\n+\n     fn subspan(\n         &mut self,\n         literal: &Self::Literal,\n@@ -735,6 +770,7 @@ impl server::SourceFile for Rustc<'_, '_> {\n     fn eq(&mut self, file1: &Self::SourceFile, file2: &Self::SourceFile) -> bool {\n         Lrc::ptr_eq(file1, file2)\n     }\n+\n     fn path(&mut self, file: &Self::SourceFile) -> String {\n         match file.name {\n             FileName::Real(ref name) => name\n@@ -746,6 +782,7 @@ impl server::SourceFile for Rustc<'_, '_> {\n             _ => file.name.prefer_local().to_string(),\n         }\n     }\n+\n     fn is_real(&mut self, file: &Self::SourceFile) -> bool {\n         file.is_real_file()\n     }\n@@ -755,6 +792,7 @@ impl server::MultiSpan for Rustc<'_, '_> {\n     fn new(&mut self) -> Self::MultiSpan {\n         vec![]\n     }\n+\n     fn push(&mut self, spans: &mut Self::MultiSpan, span: Self::Span) {\n         spans.push(span)\n     }\n@@ -766,6 +804,7 @@ impl server::Diagnostic for Rustc<'_, '_> {\n         diag.set_span(MultiSpan::from_spans(spans));\n         diag\n     }\n+\n     fn sub(\n         &mut self,\n         diag: &mut Self::Diagnostic,\n@@ -775,6 +814,7 @@ impl server::Diagnostic for Rustc<'_, '_> {\n     ) {\n         diag.sub(level.to_internal(), msg, MultiSpan::from_spans(spans), None);\n     }\n+\n     fn emit(&mut self, mut diag: Self::Diagnostic) {\n         self.sess().span_diagnostic.emit_diagnostic(&mut diag);\n     }\n@@ -788,38 +828,49 @@ impl server::Span for Rustc<'_, '_> {\n             format!(\"{:?} bytes({}..{})\", span.ctxt(), span.lo().0, span.hi().0)\n         }\n     }\n+\n     fn def_site(&mut self) -> Self::Span {\n         self.def_site\n     }\n+\n     fn call_site(&mut self) -> Self::Span {\n         self.call_site\n     }\n+\n     fn mixed_site(&mut self) -> Self::Span {\n         self.mixed_site\n     }\n+\n     fn source_file(&mut self, span: Self::Span) -> Self::SourceFile {\n         self.sess().source_map().lookup_char_pos(span.lo()).file\n     }\n+\n     fn parent(&mut self, span: Self::Span) -> Option<Self::Span> {\n         span.parent_callsite()\n     }\n+\n     fn source(&mut self, span: Self::Span) -> Self::Span {\n         span.source_callsite()\n     }\n+\n     fn start(&mut self, span: Self::Span) -> LineColumn {\n         let loc = self.sess().source_map().lookup_char_pos(span.lo());\n         LineColumn { line: loc.line, column: loc.col.to_usize() }\n     }\n+\n     fn end(&mut self, span: Self::Span) -> LineColumn {\n         let loc = self.sess().source_map().lookup_char_pos(span.hi());\n         LineColumn { line: loc.line, column: loc.col.to_usize() }\n     }\n+\n     fn before(&mut self, span: Self::Span) -> Self::Span {\n         span.shrink_to_lo()\n     }\n+\n     fn after(&mut self, span: Self::Span) -> Self::Span {\n         span.shrink_to_hi()\n     }\n+\n     fn join(&mut self, first: Self::Span, second: Self::Span) -> Option<Self::Span> {\n         let self_loc = self.sess().source_map().lookup_char_pos(first.lo());\n         let other_loc = self.sess().source_map().lookup_char_pos(second.lo());\n@@ -830,9 +881,11 @@ impl server::Span for Rustc<'_, '_> {\n \n         Some(first.to(second))\n     }\n+\n     fn resolved_at(&mut self, span: Self::Span, at: Self::Span) -> Self::Span {\n         span.with_ctxt(at.ctxt())\n     }\n+\n     fn source_text(&mut self, span: Self::Span) -> Option<String> {\n         self.sess().source_map().span_to_snippet(span).ok()\n     }\n@@ -863,6 +916,7 @@ impl server::Span for Rustc<'_, '_> {\n     fn save_span(&mut self, span: Self::Span) -> usize {\n         self.sess().save_proc_macro_span(span)\n     }\n+\n     fn recover_proc_macro_span(&mut self, id: usize) -> Self::Span {\n         let (resolver, krate, def_site) = (&*self.ecx.resolver, self.krate, self.def_site);\n         *self.rebased_spans.entry(id).or_insert_with(|| {"}, {"sha": "e4a4db204d922e32099c9a0a87f901655935c373", "filename": "compiler/rustc_expand/src/tokenstream/tests.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -4,7 +4,6 @@ use rustc_ast::token;\n use rustc_ast::tokenstream::{Spacing, TokenStream, TokenStreamBuilder, TokenTree};\n use rustc_span::create_default_session_globals_then;\n use rustc_span::{BytePos, Span, Symbol};\n-use smallvec::smallvec;\n \n fn string_to_ts(string: &str) -> TokenStream {\n     string_to_stream(string.to_owned())\n@@ -24,7 +23,10 @@ fn test_concat() {\n         let test_res = string_to_ts(\"foo::bar::baz\");\n         let test_fst = string_to_ts(\"foo::bar\");\n         let test_snd = string_to_ts(\"::baz\");\n-        let eq_res = TokenStream::from_streams(smallvec![test_fst, test_snd]);\n+        let mut builder = TokenStreamBuilder::new();\n+        builder.push(test_fst);\n+        builder.push(test_snd);\n+        let eq_res = builder.build();\n         assert_eq!(test_res.trees().count(), 5);\n         assert_eq!(eq_res.trees().count(), 5);\n         assert_eq!(test_res.eq_unspanned(&eq_res), true);"}, {"sha": "846e7f7b92155f1a3890b8fde375abd42ab53299", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -662,7 +662,11 @@ where\n         match b.kind() {\n             ty::ConstKind::Infer(InferConst::Var(_)) if D::forbid_inference_vars() => {\n                 // Forbid inference variables in the RHS.\n-                bug!(\"unexpected inference var {:?}\", b)\n+                self.infcx.tcx.sess.delay_span_bug(\n+                    self.delegate.span(),\n+                    format!(\"unexpected inference var {:?}\", b,),\n+                );\n+                Ok(a)\n             }\n             // FIXME(invariance): see the related FIXME above.\n             _ => self.infcx.super_combine_consts(self, a, b),"}, {"sha": "31b8fa1ce956fa934a8746a4786240cca94babe3", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -371,6 +371,13 @@ where\n         Ok(self.fold_const(c))\n     }\n \n+    fn try_fold_unevaluated(\n+        &mut self,\n+        c: ty::Unevaluated<'tcx>,\n+    ) -> Result<ty::Unevaluated<'tcx>, Self::Error> {\n+        Ok(self.fold_unevaluated(c))\n+    }\n+\n     fn try_fold_predicate(\n         &mut self,\n         p: ty::Predicate<'tcx>,"}, {"sha": "af0803fbd54148e45279488e96eff7d3c95f4639", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -259,7 +259,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let cycle = self.resolve_vars_if_possible(cycle.to_owned());\n         assert!(!cycle.is_empty());\n \n-        debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n+        debug!(?cycle, \"report_overflow_error_cycle\");\n \n         // The 'deepest' obligation is most likely to have a useful\n         // cause 'backtrace'\n@@ -1513,6 +1513,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip_all)]\n     fn report_projection_error(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n@@ -1551,15 +1552,9 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                     &mut obligations,\n                 );\n \n-                debug!(\n-                    \"report_projection_error obligation.cause={:?} obligation.param_env={:?}\",\n-                    obligation.cause, obligation.param_env\n-                );\n+                debug!(?obligation.cause, ?obligation.param_env);\n \n-                debug!(\n-                    \"report_projection_error normalized_ty={:?} data.ty={:?}\",\n-                    normalized_ty, data.term,\n-                );\n+                debug!(?normalized_ty, data.ty = ?data.term);\n \n                 let is_normalized_ty_expected = !matches!(\n                     obligation.cause.code().peel_derives(),\n@@ -2346,6 +2341,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(level = \"debug\", skip_all)]\n     fn suggest_unsized_bound_if_applicable(\n         &self,\n         err: &mut Diagnostic,\n@@ -2360,10 +2356,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         )  else {\n             return;\n         };\n-        debug!(\n-            \"suggest_unsized_bound_if_applicable: pred={:?} item_def_id={:?} span={:?}\",\n-            pred, item_def_id, span\n-        );\n+        debug!(?pred, ?item_def_id, ?span);\n \n         let (Some(node), true) = (\n             self.tcx.hir().get_if_local(item_def_id),\n@@ -2374,6 +2367,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         self.maybe_suggest_unsized_generics(err, span, node);\n     }\n \n+    #[instrument(level = \"debug\", skip_all)]\n     fn maybe_suggest_unsized_generics<'hir>(\n         &self,\n         err: &mut Diagnostic,\n@@ -2384,8 +2378,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             return;\n         };\n         let sized_trait = self.tcx.lang_items().sized_trait();\n-        debug!(\"maybe_suggest_unsized_generics: generics.params={:?}\", generics.params);\n-        debug!(\"maybe_suggest_unsized_generics: generics.predicates={:?}\", generics.predicates);\n+        debug!(?generics.params);\n+        debug!(?generics.predicates);\n         let Some(param) = generics.params.iter().find(|param| param.span == span) else {\n             return;\n         };\n@@ -2399,7 +2393,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         if explicitly_sized {\n             return;\n         }\n-        debug!(\"maybe_suggest_unsized_generics: param={:?}\", param);\n+        debug!(?param);\n         match node {\n             hir::Node::Item(\n                 item @ hir::Item {\n@@ -2517,7 +2511,7 @@ impl<'v> Visitor<'v> for FindTypeParam {\n                 if path.segments.len() == 1 && path.segments[0].ident.name == self.param =>\n             {\n                 if !self.nested {\n-                    debug!(\"FindTypeParam::visit_ty: ty={:?}\", ty);\n+                    debug!(?ty, \"FindTypeParam::visit_ty\");\n                     self.invalid_spans.push(ty.span);\n                 }\n             }"}, {"sha": "d8003efba872d4ee82b4ed979af6bcb458a2309c", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 25, "deletions": 41, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -1628,16 +1628,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// ```\n     ///\n     /// Returns `true` if an async-await specific note was added to the diagnostic.\n+    #[instrument(level = \"debug\", skip_all, fields(?obligation.predicate, ?obligation.cause.span))]\n     fn maybe_note_obligation_cause_for_async_await(\n         &self,\n         err: &mut Diagnostic,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> bool {\n-        debug!(\n-            \"maybe_note_obligation_cause_for_async_await: obligation.predicate={:?} \\\n-                obligation.cause.span={:?}\",\n-            obligation.predicate, obligation.cause.span\n-        );\n         let hir = self.tcx.hir();\n \n         // Attempt to detect an async-await error by looking at the obligation causes, looking\n@@ -1677,18 +1673,17 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let mut seen_upvar_tys_infer_tuple = false;\n \n         while let Some(code) = next_code {\n-            debug!(\"maybe_note_obligation_cause_for_async_await: code={:?}\", code);\n+            debug!(?code);\n             match code {\n                 ObligationCauseCode::FunctionArgumentObligation { parent_code, .. } => {\n                     next_code = Some(parent_code);\n                 }\n                 ObligationCauseCode::ImplDerivedObligation(cause) => {\n                     let ty = cause.derived.parent_trait_pred.skip_binder().self_ty();\n                     debug!(\n-                        \"maybe_note_obligation_cause_for_async_await: ImplDerived \\\n-                         parent_trait_ref={:?} self_ty.kind={:?}\",\n-                        cause.derived.parent_trait_pred,\n-                        ty.kind()\n+                        parent_trait_ref = ?cause.derived.parent_trait_pred,\n+                        self_ty.kind = ?ty.kind(),\n+                        \"ImplDerived\",\n                     );\n \n                     match *ty.kind() {\n@@ -1717,10 +1712,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 | ObligationCauseCode::BuiltinDerivedObligation(derived_obligation) => {\n                     let ty = derived_obligation.parent_trait_pred.skip_binder().self_ty();\n                     debug!(\n-                        \"maybe_note_obligation_cause_for_async_await: \\\n-                         parent_trait_ref={:?} self_ty.kind={:?}\",\n-                        derived_obligation.parent_trait_pred,\n-                        ty.kind()\n+                        parent_trait_ref = ?derived_obligation.parent_trait_pred,\n+                        self_ty.kind = ?ty.kind(),\n                     );\n \n                     match *ty.kind() {\n@@ -1750,7 +1743,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         // Only continue if a generator was found.\n-        debug!(?generator, ?trait_ref, ?target_ty, \"maybe_note_obligation_cause_for_async_await\");\n+        debug!(?generator, ?trait_ref, ?target_ty);\n         let (Some(generator_did), Some(trait_ref), Some(target_ty)) = (generator, trait_ref, target_ty) else {\n             return false;\n         };\n@@ -1760,12 +1753,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let in_progress_typeck_results = self.in_progress_typeck_results.map(|t| t.borrow());\n         let generator_did_root = self.tcx.typeck_root_def_id(generator_did);\n         debug!(\n-            \"maybe_note_obligation_cause_for_async_await: generator_did={:?} \\\n-             generator_did_root={:?} in_progress_typeck_results.hir_owner={:?} span={:?}\",\n-            generator_did,\n-            generator_did_root,\n-            in_progress_typeck_results.as_ref().map(|t| t.hir_owner),\n-            span\n+            ?generator_did,\n+            ?generator_did_root,\n+            in_progress_typeck_results.hir_owner = ?in_progress_typeck_results.as_ref().map(|t| t.hir_owner),\n+            ?span,\n         );\n \n         let generator_body = generator_did\n@@ -1788,7 +1779,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         if let Some(body) = generator_body {\n             visitor.visit_body(body);\n         }\n-        debug!(\"maybe_note_obligation_cause_for_async_await: awaits = {:?}\", visitor.awaits);\n+        debug!(awaits = ?visitor.awaits);\n \n         // Look for a type inside the generator interior that matches the target type to get\n         // a span.\n@@ -1809,11 +1800,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             let ty_erased = self.tcx.erase_late_bound_regions(ty);\n             let ty_erased = self.tcx.erase_regions(ty_erased);\n             let eq = ty_erased == target_ty_erased;\n-            debug!(\n-                \"maybe_note_obligation_cause_for_async_await: ty_erased={:?} \\\n-                    target_ty_erased={:?} eq={:?}\",\n-                ty_erased, target_ty_erased, eq\n-            );\n+            debug!(?ty_erased, ?target_ty_erased, ?eq);\n             eq\n         };\n \n@@ -1888,6 +1875,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n     /// Unconditionally adds the diagnostic note described in\n     /// `maybe_note_obligation_cause_for_async_await`'s documentation comment.\n+    #[instrument(level = \"debug\", skip_all)]\n     fn note_obligation_cause_for_async_await(\n         &self,\n         err: &mut Diagnostic,\n@@ -2037,8 +2025,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     } else {\n                         // Look at the last interior type to get a span for the `.await`.\n                         debug!(\n-                            \"note_obligation_cause_for_async_await generator_interior_types: {:#?}\",\n-                            typeck_results.as_ref().map(|t| &t.generator_interior_types)\n+                            generator_interior_types = ?format_args!(\n+                                \"{:#?}\", typeck_results.as_ref().map(|t| &t.generator_interior_types)\n+                            ),\n                         );\n                         explain_yield(interior_span, yield_span, scope_span);\n                     }\n@@ -2073,7 +2062,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             // bar(Foo(std::ptr::null())).await;\n                             //     ^^^^^^^^^^^^^^^^^^^^^ raw-ptr `*T` created inside this struct ctor.\n                             // ```\n-                            debug!(\"parent_def_kind: {:?}\", self.tcx.def_kind(parent_did));\n+                            debug!(parent_def_kind = ?self.tcx.def_kind(parent_did));\n                             let is_raw_borrow_inside_fn_like_call =\n                                 match self.tcx.def_kind(parent_did) {\n                                     DefKind::Fn | DefKind::Ctor(..) => target_ty.is_unsafe_ptr(),\n@@ -2131,7 +2120,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         // Add a note for the item obligation that remains - normally a note pointing to the\n         // bound that introduced the obligation (e.g. `T: Send`).\n-        debug!(\"note_obligation_cause_for_async_await: next_code={:?}\", next_code);\n+        debug!(?next_code);\n         self.note_obligation_cause_code(\n             err,\n             &obligation.predicate,\n@@ -2688,20 +2677,16 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         ));\n     }\n \n+    #[instrument(\n+        level = \"debug\", skip(self, err), fields(trait_pred.self_ty = ?trait_pred.self_ty())\n+    )]\n     fn suggest_await_before_try(\n         &self,\n         err: &mut Diagnostic,\n         obligation: &PredicateObligation<'tcx>,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n         span: Span,\n     ) {\n-        debug!(\n-            \"suggest_await_before_try: obligation={:?}, span={:?}, trait_pred={:?}, trait_pred_self_ty={:?}\",\n-            obligation,\n-            span,\n-            trait_pred,\n-            trait_pred.self_ty()\n-        );\n         let body_hir_id = obligation.cause.body_id;\n         let item_id = self.tcx.hir().get_parent_node(body_hir_id);\n \n@@ -2739,14 +2724,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 );\n \n                 debug!(\n-                    \"suggest_await_before_try: normalized_projection_type {:?}\",\n-                    self.resolve_vars_if_possible(projection_ty)\n+                    normalized_projection_type = ?self.resolve_vars_if_possible(projection_ty)\n                 );\n                 let try_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n                     trait_pred.map_bound(|trait_pred| (trait_pred, projection_ty.skip_binder())),\n                 );\n-                debug!(\"suggest_await_before_try: try_trait_obligation {:?}\", try_obligation);\n+                debug!(try_trait_obligation = ?try_obligation);\n                 if self.predicate_may_hold(&try_obligation)\n                     && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n                     && snippet.ends_with('?')"}, {"sha": "2f9afbec91e98686c2b649e6f5fe62f1d7a0af80", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -1144,7 +1144,7 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_stable(feature = \"const_transmute\", since = \"1.46.0\")]\n+    #[rustc_const_stable(feature = \"const_transmute\", since = \"1.56.0\")]\n     #[rustc_diagnostic_item = \"transmute\"]\n     pub fn transmute<T, U>(e: T) -> U;\n "}, {"sha": "f4f2e3f2434574f1fc1faeb461e87d5a9c66f7df", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -1240,8 +1240,8 @@ impl<'a> IoSlice<'a> {\n     /// use std::io::IoSlice;\n     /// use std::ops::Deref;\n     ///\n-    /// let mut data = [1; 8];\n-    /// let mut buf = IoSlice::new(&mut data);\n+    /// let data = [1; 8];\n+    /// let mut buf = IoSlice::new(&data);\n     ///\n     /// // Mark 3 bytes as read.\n     /// buf.advance(3);\n@@ -1435,10 +1435,10 @@ pub trait Write {\n     /// use std::fs::File;\n     ///\n     /// fn main() -> std::io::Result<()> {\n-    ///     let mut data1 = [1; 8];\n-    ///     let mut data2 = [15; 8];\n-    ///     let io_slice1 = IoSlice::new(&mut data1);\n-    ///     let io_slice2 = IoSlice::new(&mut data2);\n+    ///     let data1 = [1; 8];\n+    ///     let data2 = [15; 8];\n+    ///     let io_slice1 = IoSlice::new(&data1);\n+    ///     let io_slice2 = IoSlice::new(&data2);\n     ///\n     ///     let mut buffer = File::create(\"foo.txt\")?;\n     ///"}, {"sha": "7cc901a79445b37c7249a7adddbca865831855fe", "filename": "library/std/src/os/unix/net/ancillary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -583,8 +583,8 @@ impl<'a> SocketAncillary<'a> {\n     ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n     ///     ancillary.add_fds(&[sock.as_raw_fd()][..]);\n     ///\n-    ///     let mut buf = [1; 8];\n-    ///     let mut bufs = &mut [IoSlice::new(&mut buf[..])][..];\n+    ///     let buf = [1; 8];\n+    ///     let mut bufs = &mut [IoSlice::new(&buf[..])][..];\n     ///     sock.send_vectored_with_ancillary(bufs, &mut ancillary)?;\n     ///     Ok(())\n     /// }"}, {"sha": "48479f5bdb3f7084dc3a98f356f0752304b01f82", "filename": "library/std/src/sys_common/mutex.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -46,13 +46,12 @@ impl Drop for StaticMutexGuard {\n \n /// An OS-based mutual exclusion lock.\n ///\n-/// This mutex does *not* have a const constructor, cleans up its resources in\n-/// its `Drop` implementation, may safely be moved (when not borrowed), and\n-/// does not cause UB when used reentrantly.\n+/// This mutex cleans up its resources in its `Drop` implementation, may safely\n+/// be moved (when not borrowed), and does not cause UB when used reentrantly.\n ///\n /// This mutex does not implement poisoning.\n ///\n-/// This is either a wrapper around `Box<imp::Mutex>` or `imp::Mutex`,\n+/// This is either a wrapper around `LazyBox<imp::Mutex>` or `imp::Mutex`,\n /// depending on the platform. It is boxed on platforms where `imp::Mutex` may\n /// not be moved.\n pub struct MovableMutex(imp::MovableMutex);"}, {"sha": "ba56f3a8f1b5263b5a46d84848b27f702b7b3b90", "filename": "library/std/src/sys_common/rwlock.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -62,12 +62,12 @@ impl Drop for StaticRwLockWriteGuard {\n \n /// An OS-based reader-writer lock.\n ///\n-/// This rwlock does *not* have a const constructor, cleans up its resources in\n-/// its `Drop` implementation and may safely be moved (when not borrowed).\n+/// This rwlock cleans up its resources in its `Drop` implementation and may\n+/// safely be moved (when not borrowed).\n ///\n /// This rwlock does not implement poisoning.\n ///\n-/// This is either a wrapper around `Box<imp::RwLock>` or `imp::RwLock`,\n+/// This is either a wrapper around `LazyBox<imp::RwLock>` or `imp::RwLock`,\n /// depending on the platform. It is boxed on platforms where `imp::RwLock` may\n /// not be moved.\n pub struct MovableRwLock(imp::MovableRwLock);"}, {"sha": "0a6a7cfe976cc31b9bb6344793bb42f9f3769f6a", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -1487,13 +1487,14 @@ impl<T> JoinHandle<T> {\n \n     /// Checks if the associated thread has finished running its main function.\n     ///\n+    /// `is_finished` supports implementing a non-blocking join operation, by checking\n+    /// `is_finished`, and calling `join` if it returns `true`. This function does not block. To\n+    /// block while waiting on the thread to finish, use [`join`][Self::join].\n+    ///\n     /// This might return `true` for a brief moment after the thread's main\n     /// function has returned, but before the thread itself has stopped running.\n     /// However, once this returns `true`, [`join`][Self::join] can be expected\n     /// to return quickly, without blocking for any significant amount of time.\n-    ///\n-    /// This function does not block. To block while waiting on the thread to finish,\n-    /// use [`join`][Self::join].\n     #[stable(feature = \"thread_is_running\", since = \"1.61.0\")]\n     pub fn is_finished(&self) -> bool {\n         Arc::strong_count(&self.0.packet) == 1"}, {"sha": "a387a09dc8b156813a956f7bad47272ee533665c", "filename": "library/std/src/thread/scoped.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fscoped.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -308,13 +308,14 @@ impl<'scope, T> ScopedJoinHandle<'scope, T> {\n \n     /// Checks if the associated thread has finished running its main function.\n     ///\n+    /// `is_finished` supports implementing a non-blocking join operation, by checking\n+    /// `is_finished`, and calling `join` if it returns `false`. This function does not block. To\n+    /// block while waiting on the thread to finish, use [`join`][Self::join].\n+    ///\n     /// This might return `true` for a brief moment after the thread's main\n     /// function has returned, but before the thread itself has stopped running.\n     /// However, once this returns `true`, [`join`][Self::join] can be expected\n     /// to return quickly, without blocking for any significant amount of time.\n-    ///\n-    /// This function does not block. To block while waiting on the thread to finish,\n-    /// use [`join`][Self::join].\n     #[stable(feature = \"scoped_threads\", since = \"1.63.0\")]\n     pub fn is_finished(&self) -> bool {\n         Arc::strong_count(&self.0.packet) == 1"}, {"sha": "7d6d4b71e2eaf6d9fa68236ea4e939fa28df2976", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -31,8 +31,6 @@ pub(crate) struct Page<'a> {\n     pub(crate) description: &'a str,\n     pub(crate) keywords: &'a str,\n     pub(crate) resource_suffix: &'a str,\n-    pub(crate) extra_scripts: &'a [&'a str],\n-    pub(crate) static_extra_scripts: &'a [&'a str],\n }\n \n impl<'a> Page<'a> {"}, {"sha": "bfdc44c7e45341ec2672f982b53f3ae9e7104183", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -211,8 +211,6 @@ impl<'tcx> Context<'tcx> {\n                 description: &desc,\n                 keywords: &keywords,\n                 resource_suffix: &clone_shared.resource_suffix,\n-                extra_scripts: &[],\n-                static_extra_scripts: &[],\n             };\n             let mut page_buffer = Buffer::html();\n             print_item(self, it, &mut page_buffer, &page);\n@@ -568,8 +566,6 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             description: \"List of all items in this crate\",\n             keywords: BASIC_KEYWORDS,\n             resource_suffix: &shared.resource_suffix,\n-            extra_scripts: &[],\n-            static_extra_scripts: &[],\n         };\n         let sidebar = if shared.cache.crate_version.is_some() {\n             format!(\"<h2 class=\\\"location\\\">Crate {}</h2>\", crate_name)\n@@ -693,7 +689,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             else { unreachable!() };\n             let items = self.build_sidebar_items(module);\n             let js_dst = self.dst.join(&format!(\"sidebar-items{}.js\", self.shared.resource_suffix));\n-            let v = format!(\"initSidebarItems({});\", serde_json::to_string(&items).unwrap());\n+            let v = format!(\"window.SIDEBAR_ITEMS = {};\", serde_json::to_string(&items).unwrap());\n             self.shared.fs.write(js_dst, v)?;\n         }\n         Ok(())"}, {"sha": "3f426ee93e77e98740c2707c09fe5d8758719d78", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -56,7 +56,7 @@ use rustc_middle::middle::stability;\n use rustc_middle::ty;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::{\n-    symbol::{kw, sym, Symbol},\n+    symbol::{sym, Symbol},\n     BytePos, FileName, RealFileName,\n };\n use serde::ser::SerializeSeq;\n@@ -1738,8 +1738,6 @@ pub(crate) fn render_impl_summary(\n }\n \n fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n-    let parentlen = cx.current.len() - if it.is_mod() { 1 } else { 0 };\n-\n     if it.is_struct()\n         || it.is_trait()\n         || it.is_primitive()\n@@ -1800,21 +1798,6 @@ fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n         write!(buffer, \"<h2 class=\\\"location\\\"><a href=\\\"index.html\\\">In {}</a></h2>\", path);\n     }\n \n-    // Sidebar refers to the enclosing module, not this module.\n-    let relpath = if it.is_mod() && parentlen != 0 { \"./\" } else { \"\" };\n-    write!(\n-        buffer,\n-        \"<div id=\\\"sidebar-vars\\\" data-name=\\\"{name}\\\" data-ty=\\\"{ty}\\\" data-relpath=\\\"{path}\\\">\\\n-        </div>\",\n-        name = it.name.unwrap_or(kw::Empty),\n-        ty = it.type_(),\n-        path = relpath\n-    );\n-    write!(\n-        buffer,\n-        \"<script defer src=\\\"{}sidebar-items{}.js\\\"></script>\",\n-        relpath, cx.shared.resource_suffix\n-    );\n     // Closes sidebar-elems div.\n     buffer.write_str(\"</div>\");\n }"}, {"sha": "27ad91d09e0643c0daedbafaf625c9e5ce00126d", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -475,8 +475,6 @@ if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};\n                 description: \"List of crates\",\n                 keywords: BASIC_KEYWORDS,\n                 resource_suffix: &shared.resource_suffix,\n-                extra_scripts: &[],\n-                static_extra_scripts: &[],\n             };\n \n             let content = format!("}, {"sha": "1971d08e5bef510820dc4c22689331ae3c81e70c", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -203,8 +203,6 @@ impl SourceCollector<'_, '_> {\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n             resource_suffix: &shared.resource_suffix,\n-            extra_scripts: &[&format!(\"source-files{}\", shared.resource_suffix)],\n-            static_extra_scripts: &[&format!(\"source-script{}\", shared.resource_suffix)],\n         };\n         let v = layout::render(\n             &shared.layout,"}, {"sha": "b320db910461258bd5a0784b6cedb10c3b2ea173", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 61, "deletions": 69, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -66,26 +66,18 @@ function showMain() {\n (function() {\n     window.rootPath = getVar(\"root-path\");\n     window.currentCrate = getVar(\"current-crate\");\n-    window.searchJS =  resourcePath(\"search\", \".js\");\n-    window.searchIndexJS = resourcePath(\"search-index\", \".js\");\n-    window.settingsJS = resourcePath(\"settings\", \".js\");\n-    const sidebarVars = document.getElementById(\"sidebar-vars\");\n-    if (sidebarVars) {\n-        window.sidebarCurrent = {\n-            name: sidebarVars.attributes[\"data-name\"].value,\n-            ty: sidebarVars.attributes[\"data-ty\"].value,\n-            relpath: sidebarVars.attributes[\"data-relpath\"].value,\n-        };\n-        // FIXME: It would be nicer to generate this text content directly in HTML,\n-        // but with the current code it's hard to get the right information in the right place.\n-        const mobileLocationTitle = document.querySelector(\".mobile-topbar h2.location\");\n-        const locationTitle = document.querySelector(\".sidebar h2.location\");\n-        if (mobileLocationTitle && locationTitle) {\n-            mobileLocationTitle.innerHTML = locationTitle.innerHTML;\n-        }\n-    }\n }());\n \n+function setMobileTopbar() {\n+    // FIXME: It would be nicer to generate this text content directly in HTML,\n+    // but with the current code it's hard to get the right information in the right place.\n+    const mobileLocationTitle = document.querySelector(\".mobile-topbar h2.location\");\n+    const locationTitle = document.querySelector(\".sidebar h2.location\");\n+    if (mobileLocationTitle && locationTitle) {\n+        mobileLocationTitle.innerHTML = locationTitle.innerHTML;\n+    }\n+}\n+\n // Gets the human-readable string for the virtual-key code of the\n // given KeyboardEvent, ev.\n //\n@@ -227,7 +219,7 @@ function loadCss(cssFileName) {\n         // Sending request for the CSS and the JS files at the same time so it will\n         // hopefully be loaded when the JS will generate the settings content.\n         loadCss(\"settings\");\n-        loadScript(window.settingsJS);\n+        loadScript(resourcePath(\"settings\", \".js\"));\n     };\n \n     window.searchState = {\n@@ -304,8 +296,8 @@ function loadCss(cssFileName) {\n             function loadSearch() {\n                 if (!searchLoaded) {\n                     searchLoaded = true;\n-                    loadScript(window.searchJS);\n-                    loadScript(window.searchIndexJS);\n+                    loadScript(resourcePath(\"search\", \".js\"));\n+                    loadScript(resourcePath(\"search-index\", \".js\"));\n                 }\n             }\n \n@@ -485,40 +477,11 @@ function loadCss(cssFileName) {\n     document.addEventListener(\"keypress\", handleShortcut);\n     document.addEventListener(\"keydown\", handleShortcut);\n \n-    // delayed sidebar rendering.\n-    window.initSidebarItems = items => {\n-        const sidebar = document.getElementsByClassName(\"sidebar-elems\")[0];\n-        let others;\n-        const current = window.sidebarCurrent;\n-\n-        function addSidebarCrates(crates) {\n-            if (!hasClass(document.body, \"crate\")) {\n-                // We only want to list crates on the crate page.\n-                return;\n-            }\n-            // Draw a convenient sidebar of known crates if we have a listing\n-            const div = document.createElement(\"div\");\n-            div.className = \"block crate\";\n-            div.innerHTML = \"<h3>Crates</h3>\";\n-            const ul = document.createElement(\"ul\");\n-            div.appendChild(ul);\n-\n-            for (const crate of crates) {\n-                let klass = \"crate\";\n-                if (window.rootPath !== \"./\" && crate === window.currentCrate) {\n-                    klass += \" current\";\n-                }\n-                const link = document.createElement(\"a\");\n-                link.href = window.rootPath + crate + \"/index.html\";\n-                link.className = klass;\n-                link.textContent = crate;\n-\n-                const li = document.createElement(\"li\");\n-                li.appendChild(link);\n-                ul.appendChild(li);\n-            }\n-            others.appendChild(div);\n+    function addSidebarItems() {\n+        if (!window.SIDEBAR_ITEMS) {\n+            return;\n         }\n+        const sidebar = document.getElementsByClassName(\"sidebar-elems\")[0];\n \n         /**\n          * Append to the sidebar a \"block\" of links - a heading along with a list (`<ul>`) of items.\n@@ -529,7 +492,7 @@ function loadCss(cssFileName) {\n          *                          \"Modules\", or \"Macros\".\n          */\n         function block(shortty, id, longty) {\n-            const filtered = items[shortty];\n+            const filtered = window.SIDEBAR_ITEMS[shortty];\n             if (!filtered) {\n                 return;\n             }\n@@ -546,17 +509,18 @@ function loadCss(cssFileName) {\n                 const desc = item[1]; // can be null\n \n                 let klass = shortty;\n-                if (name === current.name && shortty === current.ty) {\n-                    klass += \" current\";\n-                }\n                 let path;\n                 if (shortty === \"mod\") {\n                     path = name + \"/index.html\";\n                 } else {\n                     path = shortty + \".\" + name + \".html\";\n                 }\n+                const current_page = document.location.href.split(\"/\").pop();\n+                if (path === current_page) {\n+                    klass += \" current\";\n+                }\n                 const link = document.createElement(\"a\");\n-                link.href = current.relpath + path;\n+                link.href = path;\n                 link.title = desc;\n                 link.className = klass;\n                 link.textContent = name;\n@@ -565,14 +529,10 @@ function loadCss(cssFileName) {\n                 ul.appendChild(li);\n             }\n             div.appendChild(ul);\n-            others.appendChild(div);\n+            sidebar.appendChild(div);\n         }\n \n         if (sidebar) {\n-            others = document.createElement(\"div\");\n-            others.className = \"others\";\n-            sidebar.appendChild(others);\n-\n             const isModule = hasClass(document.body, \"mod\");\n             if (!isModule) {\n                 block(\"primitive\", \"primitives\", \"Primitive Types\");\n@@ -590,12 +550,8 @@ function loadCss(cssFileName) {\n                 block(\"keyword\", \"keywords\", \"Keywords\");\n                 block(\"traitalias\", \"trait-aliases\", \"Trait Aliases\");\n             }\n-\n-            // `crates{version}.js` should always be loaded before this script, so we can use\n-            // it safely.\n-            addSidebarCrates(window.ALL_CRATES);\n         }\n-    };\n+    }\n \n     window.register_implementors = imp => {\n         const implementors = document.getElementById(\"implementors-list\");\n@@ -680,6 +636,39 @@ function loadCss(cssFileName) {\n         window.register_implementors(window.pending_implementors);\n     }\n \n+    function addSidebarCrates() {\n+        if (!window.ALL_CRATES) {\n+            return;\n+        }\n+        const sidebarElems = document.getElementsByClassName(\"sidebar-elems\")[0];\n+        if (!sidebarElems) {\n+            return;\n+        }\n+        // Draw a convenient sidebar of known crates if we have a listing\n+        const div = document.createElement(\"div\");\n+        div.className = \"block crate\";\n+        div.innerHTML = \"<h3>Crates</h3>\";\n+        const ul = document.createElement(\"ul\");\n+        div.appendChild(ul);\n+\n+        for (const crate of window.ALL_CRATES) {\n+            let klass = \"crate\";\n+            if (window.rootPath !== \"./\" && crate === window.currentCrate) {\n+                klass += \" current\";\n+            }\n+            const link = document.createElement(\"a\");\n+            link.href = window.rootPath + crate + \"/index.html\";\n+            link.className = klass;\n+            link.textContent = crate;\n+\n+            const li = document.createElement(\"li\");\n+            li.appendChild(link);\n+            ul.appendChild(li);\n+        }\n+        sidebarElems.appendChild(div);\n+    }\n+\n+\n     function labelForToggleButton(sectionIsCollapsed) {\n         if (sectionIsCollapsed) {\n             // button will expand the section\n@@ -924,6 +913,9 @@ function loadCss(cssFileName) {\n         buildHelperPopup = () => {};\n     };\n \n+    setMobileTopbar();\n+    addSidebarItems();\n+    addSidebarCrates();\n     onHashChange(null);\n     window.addEventListener(\"hashchange\", onHashChange);\n     searchState.setup();"}, {"sha": "cb1609d4983402b62b2320c0c479df8033621ca2", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -1719,10 +1719,11 @@ function initSearch(rawSearchIndex) {\n         }\n \n         let crates = \"\";\n-        if (window.ALL_CRATES.length > 1) {\n+        const crates_list = Object.keys(rawSearchIndex);\n+        if (crates_list.length > 1) {\n             crates = \" in <select id=\\\"crate-search\\\"><option value=\\\"All crates\\\">\" +\n                 \"All crates</option>\";\n-            for (const c of window.ALL_CRATES) {\n+            for (const c of crates_list) {\n                 crates += `<option value=\"${c}\" ${c === filterCrates && \"selected\"}>${c}</option>`;\n             }\n             crates += \"</select>\";"}, {"sha": "10f93a1c058dab21ae1f2e53539a36cfb7b93110", "filename": "src/librustdoc/html/static/js/source-script.js", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsource-script.js?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -9,33 +9,19 @@\n \n (function() {\n \n-function getCurrentFilePath() {\n-    const parts = window.location.pathname.split(\"/\");\n-    const rootPathParts = window.rootPath.split(\"/\");\n+const rootPath = document.getElementById(\"rustdoc-vars\").attributes[\"data-root-path\"].value;\n \n-    for (const rootPathPart of rootPathParts) {\n-        if (rootPathPart === \"..\") {\n-            parts.pop();\n-        }\n-    }\n-    let file = window.location.pathname.substring(parts.join(\"/\").length);\n-    if (file.startsWith(\"/\")) {\n-        file = file.substring(1);\n-    }\n-    return file.substring(0, file.length - 5);\n-}\n-\n-function createDirEntry(elem, parent, fullPath, currentFile, hasFoundFile) {\n+function createDirEntry(elem, parent, fullPath, hasFoundFile) {\n     const name = document.createElement(\"div\");\n     name.className = \"name\";\n \n     fullPath += elem[\"name\"] + \"/\";\n \n-    name.onclick = () => {\n-        if (hasClass(name, \"expand\")) {\n-            removeClass(name, \"expand\");\n+    name.onclick = ev => {\n+        if (hasClass(ev.target, \"expand\")) {\n+            removeClass(ev.target, \"expand\");\n         } else {\n-            addClass(name, \"expand\");\n+            addClass(ev.target, \"expand\");\n         }\n     };\n     name.innerText = elem[\"name\"];\n@@ -46,7 +32,7 @@ function createDirEntry(elem, parent, fullPath, currentFile, hasFoundFile) {\n     folders.className = \"folders\";\n     if (elem.dirs) {\n         for (const dir of elem.dirs) {\n-            if (createDirEntry(dir, folders, fullPath, currentFile, hasFoundFile)) {\n+            if (createDirEntry(dir, folders, fullPath, hasFoundFile)) {\n                 addClass(name, \"expand\");\n                 hasFoundFile = true;\n             }\n@@ -60,8 +46,9 @@ function createDirEntry(elem, parent, fullPath, currentFile, hasFoundFile) {\n         for (const file_text of elem.files) {\n             const file = document.createElement(\"a\");\n             file.innerText = file_text;\n-            file.href = window.rootPath + \"src/\" + fullPath + file_text + \".html\";\n-            if (!hasFoundFile && currentFile === fullPath + file_text) {\n+            file.href = rootPath + \"src/\" + fullPath + file_text + \".html\";\n+            const w = window.location.href.split(\"#\")[0];\n+            if (!hasFoundFile && w === file.href) {\n                 file.className = \"selected\";\n                 addClass(name, \"expand\");\n                 hasFoundFile = true;\n@@ -72,7 +59,7 @@ function createDirEntry(elem, parent, fullPath, currentFile, hasFoundFile) {\n     children.appendChild(files);\n     parent.appendChild(name);\n     parent.appendChild(children);\n-    return hasFoundFile && currentFile.startsWith(fullPath);\n+    return hasFoundFile;\n }\n \n function toggleSidebar() {\n@@ -109,9 +96,6 @@ function createSidebarToggle() {\n // This function is called from \"source-files.js\", generated in `html/render/mod.rs`.\n // eslint-disable-next-line no-unused-vars\n function createSourceSidebar() {\n-    if (!window.rootPath.endsWith(\"/\")) {\n-        window.rootPath += \"/\";\n-    }\n     const container = document.querySelector(\"nav.sidebar\");\n \n     const sidebarToggle = createSidebarToggle();\n@@ -125,7 +109,6 @@ function createSourceSidebar() {\n         container.classList.add(\"expanded\");\n     }\n \n-    const currentFile = getCurrentFilePath();\n     let hasFoundFile = false;\n \n     const title = document.createElement(\"div\");\n@@ -135,7 +118,7 @@ function createSourceSidebar() {\n     Object.keys(sourcesIndex).forEach(key => {\n         sourcesIndex[key].name = key;\n         hasFoundFile = createDirEntry(sourcesIndex[key], sidebar, \"\",\n-                                      currentFile, hasFoundFile);\n+            hasFoundFile);\n     });\n \n     container.appendChild(sidebar);"}, {"sha": "c4999e2c74fceafd09eb8d8e0b75f1e26cf197df", "filename": "src/librustdoc/html/templates/page.html", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fpage.html?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -34,17 +34,18 @@\n       {%- endfor -%}\n     ></script> {#- -#}\n     <script src=\"{{static_root_path|safe}}storage{{page.resource_suffix}}.js\"></script> {#- -#}\n-    <script src=\"{{page.root_path|safe}}crates{{page.resource_suffix}}.js\"></script> {#- -#}\n+    {%- if page.css_class.contains(\"crate\") -%}\n+    <script defer src=\"{{page.root_path|safe}}crates{{page.resource_suffix}}.js\"></script> {#- -#}\n+    {%- else if page.css_class == \"source\" -%}\n+    <script defer src=\"{{static_root_path|safe}}source-script{{page.resource_suffix}}.js\"></script> {#- -#}\n+    <script defer src=\"{{page.root_path|safe}}source-files{{page.resource_suffix}}.js\"></script> {#- -#}\n+    {%- else -%}\n+    <script defer src=\"sidebar-items{{page.resource_suffix}}.js\"></script> {#- -#}\n+    {%- endif -%}\n     <script defer src=\"{{static_root_path|safe}}main{{page.resource_suffix}}.js\"></script> {#- -#}\n-    {%- for script in page.static_extra_scripts -%}\n-    <script defer src=\"{{static_root_path|safe}}{{script}}.js\"></script> {#- -#}\n-    {% endfor %}\n     {%- if layout.scrape_examples_extension -%}\n     <script defer src=\"{{page.root_path|safe}}scrape-examples{{page.resource_suffix}}.js\"></script> {#- -#}\n     {%- endif -%}\n-    {%- for script in page.extra_scripts -%}\n-    <script defer src=\"{{page.root_path|safe}}{{script}}.js\"></script> {#- -#}\n-    {% endfor %}\n     <noscript> {#- -#}\n         <link rel=\"stylesheet\" {# -#}\n            href=\"{{static_root_path|safe}}noscript{{page.resource_suffix}}.css\"> {#- -#}"}, {"sha": "9ea5990622a2b4ad53e13e15c89055cb4f5713b9", "filename": "src/test/rustdoc-gui/duplicate-macro-reexport.goml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Ftest%2Frustdoc-gui%2Fduplicate-macro-reexport.goml", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Ftest%2Frustdoc-gui%2Fduplicate-macro-reexport.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fduplicate-macro-reexport.goml?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -1,14 +1,14 @@\n // This test ensures that there is no macro duplicates in the sidebar.\n goto: file://|DOC_PATH|/test_docs/macro.a.html\n // Waiting for the elements in the sidebar to be rendered.\n-wait-for: \".sidebar-elems .others .macro\"\n+wait-for: \".sidebar-elems .macro\"\n // Check there is only one macro named \"a\" listed in the sidebar.\n assert-count: (\n-    \"//*[@class='sidebar-elems']//*[@class='others']/*[@class='block macro']//li/a[text()='a']\",\n+    \"//*[@class='sidebar-elems']//*[@class='block macro']//li/a[text()='a']\",\n     1,\n )\n // Check there is only one macro named \"b\" listed in the sidebar.\n assert-count: (\n-    \"//*[@class='sidebar-elems']//*[@class='others']/*[@class='block macro']//li/a[text()='b']\",\n+    \"//*[@class='sidebar-elems']//*[@class='block macro']//li/a[text()='b']\",\n     1,\n )"}, {"sha": "67e97eb686e11f417a66a0267a5a9036b1b8b265", "filename": "src/test/rustdoc-gui/headings.goml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Ftest%2Frustdoc-gui%2Fheadings.goml", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Ftest%2Frustdoc-gui%2Fheadings.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fheadings.goml?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -106,8 +106,8 @@ assert-css: (\"h6#sub-heading-for-enum-impl-item-doc\", {\"border-bottom-width\": \"0\n assert-css: (\"h6#sub-sub-heading-for-enum-impl-item-doc\", {\"font-size\": \"14px\"})\n assert-css: (\"h6#sub-sub-heading-for-enum-impl-item-doc\", {\"border-bottom-width\": \"0px\"})\n \n-assert-text: (\".sidebar .others h3\", \"Modules\")\n-assert-css: (\".sidebar .others h3\", {\"border-bottom-width\": \"0px\"}, ALL)\n+assert-text: (\".sidebar .mod h3\", \"Modules\")\n+assert-css: (\".sidebar .mod h3\", {\"border-bottom-width\": \"0px\"}, ALL)\n \n goto: file://|DOC_PATH|/test_docs/union.HeavilyDocumentedUnion.html\n "}, {"sha": "b4312091edb279f9a987b73efe3e97634be548aa", "filename": "src/test/ui/hrtb/hrtb-just-for-static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -2,7 +2,7 @@ error: implementation of `Foo` is not general enough\n   --> $DIR/hrtb-just-for-static.rs:24:5\n    |\n LL |     want_hrtb::<StaticInt>()\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n    = note: `StaticInt` must implement `Foo<&'0 isize>`, for any lifetime `'0`...\n    = note: ...but it actually implements `Foo<&'static isize>`"}, {"sha": "63c058f91fc7c9fbf7d5cdd72bc1af8a6db3a2e4", "filename": "src/test/ui/issues/issue-98299.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Ftest%2Fui%2Fissues%2Fissue-98299.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Ftest%2Fui%2Fissues%2Fissue-98299.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-98299.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -0,0 +1,18 @@\n+use std::convert::TryFrom;\n+\n+pub fn test_usage(p: ()) {\n+    SmallCString::try_from(p).map(|cstr| cstr);\n+    //~^ ERROR: type annotations needed\n+}\n+\n+pub struct SmallCString<const N: usize> {}\n+\n+impl<const N: usize> TryFrom<()> for SmallCString<N> {\n+    type Error = ();\n+\n+    fn try_from(path: ()) -> Result<Self, Self::Error> {\n+        unimplemented!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a61bffa91e7840a16df51bc32c39580f04418b93", "filename": "src/test/ui/issues/issue-98299.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Ftest%2Fui%2Fissues%2Fissue-98299.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Ftest%2Fui%2Fissues%2Fissue-98299.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-98299.stderr?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-98299.rs:4:5\n+   |\n+LL |     SmallCString::try_from(p).map(|cstr| cstr);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for enum `Result<SmallCString<{_: usize}>, ()>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "c64e720b12f7f49bab8872566b4bcba5de396656", "filename": "src/test/ui/nll/issue-97997.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Ftest%2Fui%2Fnll%2Fissue-97997.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Ftest%2Fui%2Fnll%2Fissue-97997.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-97997.rs?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -0,0 +1,16 @@\n+trait Foo {\n+    const ASSOC: bool = true;\n+}\n+impl<T> Foo for fn(T) {}\n+\n+fn foo(_x: i32) {}\n+\n+fn impls_foo<T: Foo>(_x: T) {}\n+\n+fn main() {\n+    impls_foo(foo as fn(i32));\n+\n+    <fn(&u8) as Foo>::ASSOC;\n+    //~^ ERROR implementation of `Foo` is not general enough\n+    //~| ERROR implementation of `Foo` is not general enough\n+}"}, {"sha": "78401bbf6540aad7849d0f675487218c131ab152", "filename": "src/test/ui/nll/issue-97997.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Ftest%2Fui%2Fnll%2Fissue-97997.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f/src%2Ftest%2Fui%2Fnll%2Fissue-97997.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-97997.stderr?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -0,0 +1,20 @@\n+error: implementation of `Foo` is not general enough\n+  --> $DIR/issue-97997.rs:13:5\n+   |\n+LL |     <fn(&u8) as Foo>::ASSOC;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+   |\n+   = note: `Foo` would have to be implemented for the type `for<'r> fn(&'r u8)`\n+   = note: ...but `Foo` is actually implemented for the type `fn(&'0 u8)`, for some specific lifetime `'0`\n+\n+error: implementation of `Foo` is not general enough\n+  --> $DIR/issue-97997.rs:13:5\n+   |\n+LL |     <fn(&u8) as Foo>::ASSOC;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+   |\n+   = note: `Foo` would have to be implemented for the type `for<'r> fn(&'r u8)`\n+   = note: ...but `Foo` is actually implemented for the type `fn(&'0 u8)`, for some specific lifetime `'0`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "427061da19723f2206fe4dcb175c9c43b9a6193d", "filename": "src/tools/rust-analyzer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer?ref=72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "patch": "@@ -1 +1 @@\n-Subproject commit 366bd7242ed00c65f293497a26eb81c7510ac682\n+Subproject commit 427061da19723f2206fe4dcb175c9c43b9a6193d"}]}