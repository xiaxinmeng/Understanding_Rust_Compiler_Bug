{"sha": "c0c8ab9cd2728de9789ea76d8520b2be92bc1eb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwYzhhYjljZDI3MjhkZTk3ODllYTc2ZDg1MjBiMmJlOTJiYzFlYjI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-14T22:50:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-17T19:21:45Z"}, "message": "extract two more record calls", "tree": {"sha": "1719919be24ac699ffb184a6fbe96a154d952b18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1719919be24ac699ffb184a6fbe96a154d952b18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0c8ab9cd2728de9789ea76d8520b2be92bc1eb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0c8ab9cd2728de9789ea76d8520b2be92bc1eb2", "html_url": "https://github.com/rust-lang/rust/commit/c0c8ab9cd2728de9789ea76d8520b2be92bc1eb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0c8ab9cd2728de9789ea76d8520b2be92bc1eb2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c4a2245898af11c7e4484370e42ff8d6f9214f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c4a2245898af11c7e4484370e42ff8d6f9214f1", "html_url": "https://github.com/rust-lang/rust/commit/8c4a2245898af11c7e4484370e42ff8d6f9214f1"}], "stats": {"total": 116, "additions": 61, "deletions": 55}, "files": [{"sha": "9855eeeb97070c5af246b9e4a438e246210a43f7", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 61, "deletions": 55, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/c0c8ab9cd2728de9789ea76d8520b2be92bc1eb2/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0c8ab9cd2728de9789ea76d8520b2be92bc1eb2/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=c0c8ab9cd2728de9789ea76d8520b2be92bc1eb2", "patch": "@@ -1258,54 +1258,54 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n             });\n         }\n     }\n+}\n \n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_info_for_foreign_item(&mut self,\n+                                    def_id: DefId,\n                                     nitem: &hir::ForeignItem) {\n         let ecx = self.ecx();\n \n         debug!(\"writing foreign item {}\", ecx.tcx.node_path_str(nitem.id));\n-        let def_id = ecx.tcx.map.local_def_id(nitem.id);\n         let abi = ecx.tcx.map.get_foreign_abi(nitem.id);\n \n-        self.record(def_id, |this| {\n-            encode_def_id_and_key(ecx, this.rbml_w, def_id);\n-            let parent_id = ecx.tcx.map.get_parent(nitem.id);\n-            this.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n-            this.encode_visibility(&nitem.vis);\n-            match nitem.node {\n-                hir::ForeignItemFn(ref fndecl, _) => {\n-                    encode_family(this.rbml_w, FN_FAMILY);\n-                    this.encode_bounds_and_type_for_item(nitem.id);\n-                    encode_name(this.rbml_w, nitem.name);\n-                    if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-                        encode_inlined_item(ecx,\n-                                            this.rbml_w,\n-                                            InlinedItemRef::Foreign(def_id, nitem));\n-                        this.encode_mir(nitem.id);\n-                    }\n-                    encode_attributes(this.rbml_w, &nitem.attrs);\n-                    let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n-                    let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n-                    encode_stability(this.rbml_w, stab);\n-                    encode_deprecation(this.rbml_w, depr);\n-                    this.encode_method_argument_names(&fndecl);\n+        encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+        let parent_id = ecx.tcx.map.get_parent(nitem.id);\n+        self.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n+        self.encode_visibility(&nitem.vis);\n+        match nitem.node {\n+            hir::ForeignItemFn(ref fndecl, _) => {\n+                encode_family(self.rbml_w, FN_FAMILY);\n+                self.encode_bounds_and_type_for_item(nitem.id);\n+                encode_name(self.rbml_w, nitem.name);\n+                if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n+                    encode_inlined_item(ecx,\n+                                        self.rbml_w,\n+                                        InlinedItemRef::Foreign(def_id, nitem));\n+                    self.encode_mir(nitem.id);\n                 }\n-                hir::ForeignItemStatic(_, mutbl) => {\n-                    if mutbl {\n-                        encode_family(this.rbml_w, 'b');\n-                    } else {\n-                        encode_family(this.rbml_w, 'c');\n-                    }\n-                    this.encode_bounds_and_type_for_item(nitem.id);\n-                    encode_attributes(this.rbml_w, &nitem.attrs);\n-                    let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n-                    let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n-                    encode_stability(this.rbml_w, stab);\n-                    encode_deprecation(this.rbml_w, depr);\n-                    encode_name(this.rbml_w, nitem.name);\n+                encode_attributes(self.rbml_w, &nitem.attrs);\n+                let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n+                let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+                self.encode_method_argument_names(&fndecl);\n+            }\n+            hir::ForeignItemStatic(_, mutbl) => {\n+                if mutbl {\n+                    encode_family(self.rbml_w, 'b');\n+                } else {\n+                    encode_family(self.rbml_w, 'c');\n                 }\n+                self.encode_bounds_and_type_for_item(nitem.id);\n+                encode_attributes(self.rbml_w, &nitem.attrs);\n+                let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n+                let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+                encode_name(self.rbml_w, nitem.name);\n             }\n-        });\n+        }\n     }\n }\n \n@@ -1329,7 +1329,8 @@ impl<'a, 'ecx, 'tcx, 'encoder> Visitor<'tcx> for EncodeVisitor<'a, 'ecx, 'tcx, '\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n-        self.index.encode_info_for_foreign_item(ni);\n+        let def_id = self.index.ecx.tcx.map.local_def_id(ni.id);\n+        self.index.record(def_id, |index| index.encode_info_for_foreign_item(def_id, ni));\n     }\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         intravisit::walk_ty(self, ty);\n@@ -1357,29 +1358,34 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n             hir::ExprClosure(..) => {\n                 let def_id = ecx.tcx.map.local_def_id(expr.id);\n \n-                self.record(def_id, |this| {\n-                    encode_def_id_and_key(ecx, this.rbml_w, def_id);\n-                    encode_name(this.rbml_w, syntax::parse::token::intern(\"<closure>\"));\n-\n-                    this.rbml_w.start_tag(tag_items_closure_ty);\n-                    write_closure_type(ecx,\n-                                       this.rbml_w,\n-                                       &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n-                    this.rbml_w.end_tag();\n-\n-                    this.rbml_w.start_tag(tag_items_closure_kind);\n-                    ecx.tcx.closure_kind(def_id).encode(this.rbml_w).unwrap();\n-                    this.rbml_w.end_tag();\n-\n-                    assert!(ecx.mir_map.map.contains_key(&def_id));\n-                    this.encode_mir(expr.id);\n-                });\n+                self.record(def_id, |this| this.encode_info_for_closure(def_id, expr.id));\n             }\n             _ => { }\n         }\n     }\n }\n \n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_info_for_closure(&mut self, def_id: DefId, expr_id: NodeId) {\n+        let ecx = self.ecx;\n+        encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+        encode_name(self.rbml_w, syntax::parse::token::intern(\"<closure>\"));\n+\n+        self.rbml_w.start_tag(tag_items_closure_ty);\n+        write_closure_type(ecx,\n+                           self.rbml_w,\n+                           &ecx.tcx.tables.borrow().closure_tys[&def_id]);\n+        self.rbml_w.end_tag();\n+\n+        self.rbml_w.start_tag(tag_items_closure_kind);\n+        ecx.tcx.closure_kind(def_id).encode(self.rbml_w).unwrap();\n+        self.rbml_w.end_tag();\n+\n+        assert!(ecx.mir_map.map.contains_key(&def_id));\n+        self.encode_mir(expr_id);\n+    }\n+}\n+\n fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                    rbml_w: &mut Encoder)\n                                    -> (IndexData, FnvHashMap<XRef<'tcx>, u32>) {"}]}