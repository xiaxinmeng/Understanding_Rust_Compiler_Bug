{"sha": "339a409bfdb6c1e9b280388b5d8d9e898217840f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzOWE0MDliZmRiNmMxZTliMjgwMzg4YjVkOGQ5ZTg5ODIxNzg0MGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-01T23:30:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-01T23:30:49Z"}, "message": "Auto merge of #31430 - nagisa:mir-dyndrop, r=nikomatsakis\n\nZeroing on-drop seems to work fine. Still thinking about the best way to approach zeroing on-move.\n\n(based on top of the other drop PR; only the last 2 commits are relevant)", "tree": {"sha": "a578361877af6042eb3e4e9f86ea290b97b349b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a578361877af6042eb3e4e9f86ea290b97b349b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/339a409bfdb6c1e9b280388b5d8d9e898217840f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/339a409bfdb6c1e9b280388b5d8d9e898217840f", "html_url": "https://github.com/rust-lang/rust/commit/339a409bfdb6c1e9b280388b5d8d9e898217840f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/339a409bfdb6c1e9b280388b5d8d9e898217840f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84d8fec9b014975145eb0d9d6ec29216593e10f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/84d8fec9b014975145eb0d9d6ec29216593e10f6", "html_url": "https://github.com/rust-lang/rust/commit/84d8fec9b014975145eb0d9d6ec29216593e10f6"}, {"sha": "d1a12392b2bcbb58538cc99a995e962d2f0cdf45", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1a12392b2bcbb58538cc99a995e962d2f0cdf45", "html_url": "https://github.com/rust-lang/rust/commit/d1a12392b2bcbb58538cc99a995e962d2f0cdf45"}], "stats": {"total": 626, "additions": 405, "deletions": 221}, "files": [{"sha": "a4d222d24cac1619c6f1f6efebb88d1b07a8010c", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -198,8 +198,8 @@ pub fn visit_all_items_in_krate<'tcx,V,F>(tcx: &ty::ctxt<'tcx>,\n         fn visit_item(&mut self, i: &'tcx hir::Item) {\n             let item_def_id = self.tcx.map.local_def_id(i.id);\n             let task_id = (self.dep_node_fn)(item_def_id);\n-            debug!(\"About to start task {:?}\", task_id);\n             let _task = self.tcx.dep_graph.in_task(task_id);\n+            debug!(\"Started task {:?}\", task_id);\n             self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n             self.visitor.visit_item(i)\n         }"}, {"sha": "bc54b1ebab79a7a9d1e1479ba707c1ae160cfdd9", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -2165,6 +2165,8 @@ extern {\n                                          NumInputs: c_uint)\n                                          -> OperandBundleDefRef;\n     pub fn LLVMRustFreeOperandBundleDef(Bundle: OperandBundleDefRef);\n+\n+    pub fn LLVMRustPositionBuilderAtStart(B: BuilderRef, BB: BasicBlockRef);\n }\n \n // LLVM requires symbols from this library, but apparently they're not printed"}, {"sha": "4c80eab102fc5f2ff826d3bf00d6c5660b95080b", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -21,14 +21,64 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                      -> BlockAnd<()> {\n         let Block { extent, span, stmts, expr } = self.hir.mirror(ast_block);\n         self.in_scope(extent, block, move |this| {\n-            unpack!(block = this.stmts(block, stmts));\n-            match expr {\n-                Some(expr) => this.into(destination, block, expr),\n-                None => {\n-                    this.cfg.push_assign_unit(block, span, destination);\n-                    block.unit()\n+            // This convoluted structure is to avoid using recursion as we walk down a list\n+            // of statements. Basically, the structure we get back is something like:\n+            //\n+            //    let x = <init> in {\n+            //       expr1;\n+            //       let y = <init> in {\n+            //           expr2;\n+            //           expr3;\n+            //           ...\n+            //       }\n+            //    }\n+            //\n+            // The let bindings are valid till the end of block so all we have to do is to pop all\n+            // the let-scopes at the end.\n+            //\n+            // First we build all the statements in the block.\n+            let mut let_extent_stack = Vec::with_capacity(8);\n+            for stmt in stmts {\n+                let Stmt { span: _, kind } = this.hir.mirror(stmt);\n+                match kind {\n+                    StmtKind::Expr { scope, expr } => {\n+                        unpack!(block = this.in_scope(scope, block, |this| {\n+                            let expr = this.hir.mirror(expr);\n+                            let temp = this.temp(expr.ty.clone());\n+                            unpack!(block = this.into(&temp, block, expr));\n+                            unpack!(block = this.build_drop(block, temp));\n+                            block.unit()\n+                        }));\n+                    }\n+                    StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n+                        this.push_scope(remainder_scope);\n+                        let_extent_stack.push(remainder_scope);\n+                        unpack!(block = this.in_scope(init_scope, block, move |this| {\n+                            // FIXME #30046                              ^~~~\n+                            if let Some(init) = initializer {\n+                                this.expr_into_pattern(block, remainder_scope, pattern, init)\n+                            } else {\n+                                this.declare_bindings(remainder_scope, &pattern);\n+                                block.unit()\n+                            }\n+                        }));\n+                    }\n                 }\n             }\n+            // Then, the block may have an optional trailing expression which is a \u201creturn\u201d value\n+            // of the block.\n+            if let Some(expr) = expr {\n+                unpack!(block = this.into(destination, block, expr));\n+            } else {\n+                // FIXME(#31472)\n+                this.cfg.push_assign_unit(block, span, destination);\n+            }\n+            // Finally, we pop all the let scopes before exiting out from the scope of block\n+            // itself.\n+            for extent in let_extent_stack.into_iter().rev() {\n+                unpack!(block = this.pop_scope(extent, block));\n+            }\n+            block.unit()\n         })\n     }\n }"}, {"sha": "5d9f827984e0e116e45a1039d2fd653412f6c3a6", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -185,4 +185,3 @@ mod into;\n mod matches;\n mod misc;\n mod scope;\n-mod stmt;"}, {"sha": "a738663bf8cc50a8e9f0678eb79b42b54a28877b", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -249,6 +249,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                       extent: CodeExtent,\n                       mut block: BasicBlock,\n                       target: BasicBlock) {\n+        debug!(\"exit_scope(extent={:?}, block={:?}, target={:?})\", extent, block, target);\n         let scope_count = 1 + self.scopes.iter().rev().position(|scope| scope.extent == extent)\n                                                       .unwrap_or_else(||{\n             self.hir.span_bug(span, &format!(\"extent {:?} does not enclose\", extent))"}, {"sha": "6c0f1c7081be8f44c47a7cd3da41483bb11df4d6", "filename": "src/librustc_mir/build/stmt.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/84d8fec9b014975145eb0d9d6ec29216593e10f6/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84d8fec9b014975145eb0d9d6ec29216593e10f6/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs?ref=84d8fec9b014975145eb0d9d6ec29216593e10f6", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use build::{BlockAnd, BlockAndExtension, Builder};\n-use hair::*;\n-use rustc::mir::repr::*;\n-\n-impl<'a,'tcx> Builder<'a,'tcx> {\n-    pub fn stmts(&mut self, mut block: BasicBlock, stmts: Vec<StmtRef<'tcx>>) -> BlockAnd<()> {\n-        // This convoluted structure is to avoid using recursion as we walk down a list\n-        // of statements. Basically, the structure we get back is something like:\n-        //\n-        //    let x = <init> in {\n-        //       let y = <init> in {\n-        //           expr1;\n-        //           expr2;\n-        //       }\n-        //    }\n-        //\n-        // To process this, we keep a stack of (Option<CodeExtent>,\n-        // vec::IntoIter<Stmt>) pairs.  At each point we pull off the\n-        // top most pair and extract one statement from the\n-        // iterator. Once it's complete, we pop the scope from the\n-        // first half the pair.\n-        let this = self;\n-        let mut stmt_lists = vec![(None, stmts.into_iter())];\n-        while !stmt_lists.is_empty() {\n-            let stmt = {\n-                let &mut (_, ref mut stmts) = stmt_lists.last_mut().unwrap();\n-                stmts.next()\n-            };\n-\n-            let stmt = match stmt {\n-                Some(stmt) => stmt,\n-                None => {\n-                    let (extent, _) = stmt_lists.pop().unwrap();\n-                    if let Some(extent) = extent {\n-                        unpack!(block = this.pop_scope(extent, block));\n-                    }\n-                    continue\n-                }\n-            };\n-\n-            let Stmt { span: _, kind } = this.hir.mirror(stmt);\n-            match kind {\n-                StmtKind::Let { remainder_scope, init_scope, pattern, initializer, stmts } => {\n-                    this.push_scope(remainder_scope);\n-                    stmt_lists.push((Some(remainder_scope), stmts.into_iter()));\n-                    unpack!(block = this.in_scope(init_scope, block, move |this| {\n-                        // FIXME #30046                              ^~~~\n-                        match initializer {\n-                            Some(initializer) => {\n-                                this.expr_into_pattern(block, remainder_scope, pattern, initializer)\n-                            }\n-                            None => {\n-                                this.declare_bindings(remainder_scope, &pattern);\n-                                block.unit()\n-                            }\n-                        }\n-                    }));\n-                }\n-\n-                StmtKind::Expr { scope, expr } => {\n-                    unpack!(block = this.in_scope(scope, block, |this| {\n-                        let expr = this.hir.mirror(expr);\n-                        let temp = this.temp(expr.ty.clone());\n-                        unpack!(block = this.into(&temp, block, expr));\n-                        unpack!(block = this.build_drop(block, temp));\n-                        block.unit()\n-                    }));\n-                }\n-            }\n-        }\n-        block.unit()\n-    }\n-}"}, {"sha": "c7af42b776f0c3f93592fe57fcc8f6b1fbba5a7c", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 33, "deletions": 43, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -21,62 +21,52 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Block<'tcx> {\n         // We have to eagerly translate the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n-        let stmts = mirror_stmts(cx, self.id, self.stmts.iter().enumerate());\n+        let stmts = mirror_stmts(cx, self.id, &*self.stmts);\n         Block {\n             extent: cx.tcx.region_maps.node_extent(self.id),\n             span: self.span,\n             stmts: stmts,\n-            expr: self.expr.to_ref(),\n+            expr: self.expr.to_ref()\n         }\n     }\n }\n \n-fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,\n-                                  block_id: ast::NodeId,\n-                                  mut stmts: STMTS)\n-                                  -> Vec<StmtRef<'tcx>>\n-    where STMTS: Iterator<Item=(usize, &'tcx hir::Stmt)>\n+fn mirror_stmts<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n+                            block_id: ast::NodeId,\n+                            stmts: &'tcx [hir::Stmt])\n+                            -> Vec<StmtRef<'tcx>>\n {\n     let mut result = vec![];\n-    while let Some((index, stmt)) = stmts.next() {\n+    for (index, stmt) in stmts.iter().enumerate() {\n         match stmt.node {\n             hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) =>\n-                result.push(\n-                    StmtRef::Mirror(\n-                        Box::new(Stmt { span: stmt.span,\n-                                        kind: StmtKind::Expr {\n-                                            scope: cx.tcx.region_maps.node_extent(id),\n-                                            expr: expr.to_ref() } }))),\n-\n-            hir::StmtDecl(ref decl, id) => {\n-                match decl.node {\n-                    hir::DeclItem(..) => { /* ignore for purposes of the MIR */ }\n-                    hir::DeclLocal(ref local) => {\n-                        let remainder_extent = CodeExtentData::Remainder(BlockRemainder {\n-                            block: block_id,\n-                            first_statement_index: index as u32,\n-                        });\n-                        let remainder_extent =\n-                            cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n-\n-                        // pull in all following statements, since\n-                        // they are within the scope of this let:\n-                        let following_stmts = mirror_stmts(cx, block_id, stmts);\n-\n-                        let pattern = cx.irrefutable_pat(&local.pat);\n-                        result.push(StmtRef::Mirror(Box::new(Stmt {\n-                            span: stmt.span,\n-                            kind: StmtKind::Let {\n-                                remainder_scope: remainder_extent,\n-                                init_scope: cx.tcx.region_maps.node_extent(id),\n-                                pattern: pattern,\n-                                initializer: local.init.to_ref(),\n-                                stmts: following_stmts,\n-                            },\n-                        })));\n-\n-                        return result;\n+                result.push(StmtRef::Mirror(Box::new(Stmt {\n+                    span: stmt.span,\n+                    kind: StmtKind::Expr {\n+                        scope: cx.tcx.region_maps.node_extent(id),\n+                        expr: expr.to_ref()\n                     }\n+                }))),\n+            hir::StmtDecl(ref decl, id) => match decl.node {\n+                hir::DeclItem(..) => { /* ignore for purposes of the MIR */ }\n+                hir::DeclLocal(ref local) => {\n+                    let remainder_extent = CodeExtentData::Remainder(BlockRemainder {\n+                        block: block_id,\n+                        first_statement_index: index as u32,\n+                    });\n+                    let remainder_extent =\n+                        cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n+\n+                    let pattern = cx.irrefutable_pat(&local.pat);\n+                    result.push(StmtRef::Mirror(Box::new(Stmt {\n+                        span: stmt.span,\n+                        kind: StmtKind::Let {\n+                            remainder_scope: remainder_extent,\n+                            init_scope: cx.tcx.region_maps.node_extent(id),\n+                            pattern: pattern,\n+                            initializer: local.init.to_ref(),\n+                        },\n+                    })));\n                 }\n             }\n         }"}, {"sha": "707dd972003ff465859c9ac24d4961162918e3d5", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -78,10 +78,7 @@ pub enum StmtKind<'tcx> {\n         pattern: Pattern<'tcx>,\n \n         /// let pat = <INIT> ...\n-        initializer: Option<ExprRef<'tcx>>,\n-\n-        /// let pat = init; <STMTS>\n-        stmts: Vec<StmtRef<'tcx>>,\n+        initializer: Option<ExprRef<'tcx>>\n     },\n }\n "}, {"sha": "9819f3c0860031cdd2d2eec8e5941bbf0d894a2e", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -1295,22 +1295,29 @@ pub fn init_zero_mem<'blk, 'tcx>(cx: Block<'blk, 'tcx>, llptr: ValueRef, t: Ty<'\n fn memfill<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>, byte: u8) {\n     let _icx = push_ctxt(\"memfill\");\n     let ccx = b.ccx;\n-\n     let llty = type_of::type_of(ccx, ty);\n-    let ptr_width = &ccx.sess().target.target.target_pointer_width[..];\n-    let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n-\n-    let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n     let llptr = b.pointercast(llptr, Type::i8(ccx).ptr_to());\n     let llzeroval = C_u8(ccx, byte);\n     let size = machine::llsize_of(ccx, llty);\n     let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n-    let volatile = C_bool(ccx, false);\n-    b.call(llintrinsicfn,\n-           &[llptr, llzeroval, size, align, volatile],\n-           None, None);\n+    call_memset(b, llptr, llzeroval, size, align, false);\n }\n \n+pub fn call_memset<'bcx, 'tcx>(b: &Builder<'bcx, 'tcx>,\n+                               ptr: ValueRef,\n+                               fill_byte: ValueRef,\n+                               size: ValueRef,\n+                               align: ValueRef,\n+                               volatile: bool) {\n+    let ccx = b.ccx;\n+    let ptr_width = &ccx.sess().target.target.target_pointer_width[..];\n+    let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n+    let llintrinsicfn = ccx.get_intrinsic(&intrinsic_key);\n+    let volatile = C_bool(ccx, volatile);\n+    b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None, None);\n+}\n+\n+\n /// In general, when we create an scratch value in an alloca, the\n /// creator may not know if the block (that initializes the scratch\n /// with the desired value) actually dominates the cleanup associated"}, {"sha": "3b4a67cb08979855d6a27df103e71301c983d4e6", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -104,6 +104,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn position_at_start(&self, llbb: BasicBlockRef) {\n+        unsafe {\n+            llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n+        }\n+    }\n+\n     pub fn ret_void(&self) {\n         self.count_insn(\"retvoid\");\n         unsafe {"}, {"sha": "6997ae5cabb54a3c23b639c89c1f73fb7bcec4ee", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -735,6 +735,15 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n         BlockAndBuilder::new(bcx, owned_builder)\n     }\n \n+    pub fn at_start<F, R>(&self, f: F) -> R\n+        where F: FnOnce(&BlockAndBuilder<'blk, 'tcx>) -> R\n+    {\n+        self.position_at_start(self.bcx.llbb);\n+        let r = f(self);\n+        self.position_at_end(self.bcx.llbb);\n+        r\n+    }\n+\n     // Methods delegated to bcx\n \n     pub fn ccx(&self) -> &'blk CrateContext<'blk, 'tcx> {"}, {"sha": "a9fee18ded8f4782be472ecb29501d3d1e4e6b48", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 29, "deletions": 39, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -20,11 +20,11 @@ use trans::common::{self, Block, BlockAndBuilder};\n use trans::debuginfo::DebugLoc;\n use trans::Disr;\n use trans::foreign;\n-use trans::glue;\n use trans::type_of;\n+use trans::glue;\n use trans::type_::Type;\n \n-use super::MirContext;\n+use super::{MirContext, drop};\n use super::operand::OperandValue::{FatPtr, Immediate, Ref};\n use super::operand::OperandRef;\n \n@@ -188,8 +188,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                unwind.llbb(),\n                                cleanup_bundle.as_ref(),\n                                None);\n+                    self.bcx(target).at_start(|bcx| drop::drop_fill(bcx, lvalue.llval, ty));\n                 } else {\n                     bcx.call(drop_fn, &[llvalue], cleanup_bundle.as_ref(), None);\n+                    drop::drop_fill(&bcx, lvalue.llval, ty);\n                     funclet_br(bcx, self.llblock(target));\n                 }\n             }\n@@ -250,59 +252,41 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                    landingpad.llbb(),\n                                    cleanup_bundle.as_ref(),\n                                    Some(attrs));\n+                        landingpad.at_start(|bcx| for op in args {\n+                            self.set_operand_dropped(bcx, op);\n+                        });\n                     },\n                     (false, &Some(cleanup), &Some((_, success))) => {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n-                        let (target, postinvoke) = if must_copy_dest {\n-                            (self.fcx.new_block(\"\", None).build(), Some(self.bcx(success)))\n-                        } else {\n-                            (self.bcx(success), None)\n-                        };\n                         let invokeret = bcx.invoke(callee.immediate(),\n                                                    &llargs[..],\n-                                                   target.llbb(),\n+                                                   self.llblock(success),\n                                                    landingpad.llbb(),\n                                                    cleanup_bundle.as_ref(),\n                                                    Some(attrs));\n-                        if let Some(postinvoketarget) = postinvoke {\n-                            // We translate the copy into a temporary block. The temporary block is\n-                            // necessary because the current block has already been terminated (by\n-                            // `invoke`) and we cannot really translate into the target block\n-                            // because:\n-                            //  * The target block may have more than a single precedesor;\n-                            //  * Some LLVM insns cannot have a preceeding store insn (phi,\n-                            //    cleanuppad), and adding/prepending the store now may render\n-                            //    those other instructions invalid.\n-                            //\n-                            // NB: This approach still may break some LLVM code. For example if the\n-                            // target block starts with a `phi` (which may only match on immediate\n-                            // precedesors), it cannot know about this temporary block thus\n-                            // resulting in an invalid code:\n-                            //\n-                            // this:\n-                            //     \u2026\n-                            //     %0 = \u2026\n-                            //     %1 = invoke to label %temp \u2026\n-                            // temp:\n-                            //     store ty %1, ty* %dest\n-                            //     br label %actualtargetblock\n-                            // actualtargetblock:            ; preds: %temp, \u2026\n-                            //     phi \u2026 [%this, \u2026], [%0, \u2026] ; ERROR: phi requires to match only on\n-                            //                               ; immediate precedesors\n+                        if must_copy_dest {\n                             let (ret_dest, ret_ty) = ret_dest_ty\n                                 .expect(\"return destination and type not set\");\n-                            target.with_block(|target| {\n-                                base::store_ty(target, invokeret, ret_dest.llval, ret_ty);\n-                            });\n-                            target.br(postinvoketarget.llbb());\n+                            // We translate the copy straight into the beginning of the target\n+                            // block.\n+                            self.bcx(success).at_start(|bcx| bcx.with_block( |bcx| {\n+                                base::store_ty(bcx, invokeret, ret_dest.llval, ret_ty);\n+                            }));\n                         }\n+                        self.bcx(success).at_start(|bcx| for op in args {\n+                            self.set_operand_dropped(bcx, op);\n+                        });\n+                        landingpad.at_start(|bcx| for op in args {\n+                            self.set_operand_dropped(bcx, op);\n+                        });\n                     },\n                     (false, _, &None) => {\n                         bcx.call(callee.immediate(),\n                                  &llargs[..],\n                                  cleanup_bundle.as_ref(),\n                                  Some(attrs));\n+                        // no need to drop args, because the call never returns\n                         bcx.unreachable();\n                     }\n                     (false, _, &Some((_, target))) => {\n@@ -317,6 +301,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 base::store_ty(bcx, llret, ret_dest.llval, ret_ty);\n                             });\n                         }\n+                        for op in args {\n+                            self.set_operand_dropped(&bcx, op);\n+                        }\n                         funclet_br(bcx, self.llblock(target));\n                     }\n                     // Foreign functions\n@@ -333,6 +320,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                                        debugloc)\n                         });\n                         if let Some((_, target)) = *destination {\n+                            for op in args {\n+                                self.set_operand_dropped(&bcx, op);\n+                            }\n                             funclet_br(bcx, self.llblock(target));\n                         }\n                     },\n@@ -388,7 +378,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         let use_funclets = base::wants_msvc_seh(bcx.sess()) && data.is_cleanup;\n         let cleanup_pad = if use_funclets {\n             bcx.set_personality_fn(self.fcx.eh_personality());\n-            Some(bcx.cleanup_pad(None, &[]))\n+            bcx.at_start(|bcx| Some(bcx.cleanup_pad(None, &[])))\n         } else {\n             None\n         };\n@@ -416,7 +406,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         self.blocks[bb.index()].build()\n     }\n \n-    fn llblock(&self, bb: mir::BasicBlock) -> BasicBlockRef {\n+    pub fn llblock(&self, bb: mir::BasicBlock) -> BasicBlockRef {\n         self.blocks[bb.index()].llbb\n     }\n }"}, {"sha": "2e13abec5e36cca11e1705784a14e5b8b2245261", "filename": "src/librustc_trans/trans/mir/drop.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fdrop.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use llvm::ValueRef;\n+use rustc::middle::ty::Ty;\n+use trans::adt;\n+use trans::base;\n+use trans::common::{self, BlockAndBuilder};\n+use trans::machine;\n+use trans::type_of;\n+use trans::type_::Type;\n+\n+pub fn drop_fill<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>, value: ValueRef, ty: Ty<'tcx>) {\n+    let llty = type_of::type_of(bcx.ccx(), ty);\n+    let llptr = bcx.pointercast(value, Type::i8(bcx.ccx()).ptr_to());\n+    let filling = common::C_u8(bcx.ccx(), adt::DTOR_DONE);\n+    let size = machine::llsize_of(bcx.ccx(), llty);\n+    let align = common::C_u32(bcx.ccx(), machine::llalign_of_min(bcx.ccx(), llty));\n+    base::call_memset(&bcx, llptr, filling, size, align, false);\n+}"}, {"sha": "8d97708ca264919434c54069b5c1fc18e91ac5b0", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -17,6 +17,7 @@ use trans::base;\n use trans::common::{self, BlockAndBuilder};\n use trans::machine;\n use trans::type_of;\n+use trans::mir::drop;\n use llvm;\n use trans::Disr;\n \n@@ -48,6 +49,7 @@ impl<'tcx> LvalueRef<'tcx> {\n     {\n         assert!(!ty.has_erasable_regions());\n         let lltemp = bcx.with_block(|bcx| base::alloc_ty(bcx, ty, name));\n+        drop::drop_fill(bcx, lltemp, ty);\n         LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty))\n     }\n }"}, {"sha": "40dc22e31aa6c9a930fc005709156da7ccb5fb0e", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -197,6 +197,7 @@ mod analyze;\n mod block;\n mod constant;\n mod did;\n+mod drop;\n mod lvalue;\n mod operand;\n mod rvalue;"}, {"sha": "5db5fc82c1fa2fa20047798121f7264ca9807d2c", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -16,8 +16,9 @@ use trans::base;\n use trans::common::{self, Block, BlockAndBuilder};\n use trans::datum;\n use trans::Disr;\n+use trans::glue;\n \n-use super::{MirContext, TempRef};\n+use super::{MirContext, TempRef, drop};\n use super::lvalue::LvalueRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n@@ -158,31 +159,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n \n-    pub fn trans_operand_into(&mut self,\n-                              bcx: &BlockAndBuilder<'bcx, 'tcx>,\n-                              lldest: ValueRef,\n-                              operand: &mir::Operand<'tcx>)\n-    {\n-        debug!(\"trans_operand_into(lldest={}, operand={:?})\",\n-               bcx.val_to_string(lldest),\n-               operand);\n-\n-        // FIXME: consider not copying constants through the\n-        // stack.\n-\n-        let o = self.trans_operand(bcx, operand);\n-        self.store_operand(bcx, lldest, o);\n-    }\n-\n     pub fn store_operand(&mut self,\n                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                          lldest: ValueRef,\n                          operand: OperandRef<'tcx>)\n     {\n         debug!(\"store_operand: operand={}\", operand.repr(bcx));\n-        bcx.with_block(|bcx| {\n-            self.store_operand_direct(bcx, lldest, operand)\n-        })\n+        bcx.with_block(|bcx| self.store_operand_direct(bcx, lldest, operand))\n     }\n \n     pub fn store_operand_direct(&mut self,\n@@ -245,4 +228,29 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }), ty)\n         }).collect()\n     }\n+\n+    pub fn set_operand_dropped(&mut self,\n+                               bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                               operand: &mir::Operand<'tcx>) {\n+        match *operand {\n+            mir::Operand::Constant(_) => return,\n+            mir::Operand::Consume(ref lvalue) => {\n+                if let mir::Lvalue::Temp(idx) = *lvalue {\n+                    if let TempRef::Operand(..) = self.temps[idx as usize] {\n+                        // All lvalues which have an associated drop are promoted to an alloca\n+                        // beforehand. If this is an operand, it is safe to say this is never\n+                        // dropped and there\u2019s no reason for us to zero this out at all.\n+                        return\n+                    }\n+                }\n+                let lvalue = self.trans_lvalue(bcx, lvalue);\n+                let ty = lvalue.ty.to_ty(bcx.tcx());\n+                if !glue::type_needs_drop(bcx.tcx(), ty) {\n+                    return\n+                } else {\n+                    drop::drop_fill(bcx, lvalue.llval, ty);\n+                }\n+            }\n+        }\n+    }\n }"}, {"sha": "541df43b49b9a19f32f0e9aeb95799ff75739def", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -42,10 +42,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                rvalue);\n \n         match *rvalue {\n-            mir::Rvalue::Use(ref operand) => {\n-                self.trans_operand_into(&bcx, dest.llval, operand);\n-                bcx\n-            }\n+           mir::Rvalue::Use(ref operand) => {\n+               let tr_operand = self.trans_operand(&bcx, operand);\n+               // FIXME: consider not copying constants through stack. (fixable by translating\n+               // constants into OperandValue::Ref, why don\u2019t we do that yet if we don\u2019t?)\n+               self.store_operand(&bcx, dest.llval, tr_operand);\n+               self.set_operand_dropped(&bcx, operand);\n+               bcx\n+           }\n \n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, cast_ty) => {\n                 if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n@@ -89,15 +93,17 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n-                let elem = self.trans_operand(&bcx, elem);\n+                let tr_elem = self.trans_operand(&bcx, elem);\n                 let size = self.trans_constval(&bcx, &count.value, count.ty).immediate();\n-                bcx.map_block(|block| {\n+                let bcx = bcx.map_block(|block| {\n                     let base = expr::get_dataptr(block, dest.llval);\n-                    tvec::iter_vec_raw(block, base, elem.ty, size, |block, llslot, _| {\n-                        self.store_operand_direct(block, llslot, elem);\n+                    tvec::iter_vec_raw(block, base, tr_elem.ty, size, |block, llslot, _| {\n+                        self.store_operand_direct(block, llslot, tr_elem);\n                         block\n                     })\n-                })\n+                });\n+                self.set_operand_dropped(&bcx, elem);\n+                bcx\n             }\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n@@ -117,6 +123,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                     adt::trans_field_ptr(bcx, &repr, val, disr, i)\n                                 });\n                                 self.store_operand(&bcx, lldest_i, op);\n+                                self.set_operand_dropped(&bcx, operand);\n                             }\n                         }\n                     },\n@@ -130,6 +137,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 // not be structs but arrays.\n                                 let dest = bcx.gepi(dest.llval, &[0, i]);\n                                 self.store_operand(&bcx, dest, op);\n+                                self.set_operand_dropped(&bcx, operand);\n                             }\n                         }\n                     }\n@@ -179,11 +187,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         assert!(rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n \n         match *rvalue {\n-            mir::Rvalue::Use(ref operand) => {\n-                let operand = self.trans_operand(&bcx, operand);\n-                (bcx, operand)\n-            }\n-\n             mir::Rvalue::Cast(ref kind, ref operand, cast_ty) => {\n                 let operand = self.trans_operand(&bcx, operand);\n                 debug!(\"cast operand is {}\", operand.repr(&bcx));\n@@ -426,6 +429,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 (bcx, operand)\n             }\n \n+            mir::Rvalue::Use(..) |\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) |\n             mir::Rvalue::Slice { .. } |\n@@ -543,14 +547,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n     match *rvalue {\n-        mir::Rvalue::Use(..) | // (*)\n         mir::Rvalue::Ref(..) |\n         mir::Rvalue::Len(..) |\n         mir::Rvalue::Cast(..) | // (*)\n         mir::Rvalue::BinaryOp(..) |\n         mir::Rvalue::UnaryOp(..) |\n         mir::Rvalue::Box(..) =>\n             true,\n+        mir::Rvalue::Use(..) | // (**)\n         mir::Rvalue::Repeat(..) |\n         mir::Rvalue::Aggregate(..) |\n         mir::Rvalue::Slice { .. } |\n@@ -559,4 +563,7 @@ pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n     }\n \n     // (*) this is only true if the type is suitable\n+    // (**) we need to zero-out the source operand after moving, so we are restricted to either\n+    // ensuring all users of `Use` zero it out themselves or not allowing to \u201ccreate\u201d operand for\n+    // it.\n }"}, {"sha": "91cf4aa1da9b0fadc25438c723ec26a246908d8b", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -1167,3 +1167,8 @@ LLVMRustBuildInvoke(LLVMBuilderRef B,\n     return LLVMBuildInvoke(B, Fn, Args, NumArgs, Then, Catch, Name);\n }\n #endif\n+\n+extern \"C\" void LLVMRustPositionBuilderAtStart(LLVMBuilderRef B, LLVMBasicBlockRef BB) {\n+    auto point = unwrap(BB)->getFirstInsertionPt();\n+    unwrap(B)->SetInsertPoint(unwrap(BB), point);\n+}"}, {"sha": "590b9fbe43cf5e49130a26c13cc74dcf2cb55d4f", "filename": "src/test/run-fail/mir_dynamic_drops_1.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_1.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(rustc_attrs)]\n+// error-pattern:drop 1\n+// error-pattern:drop 2\n+use std::io::{self, Write};\n+\n+\n+/// Structure which will not allow to be dropped twice.\n+struct Droppable<'a>(&'a mut bool, u32);\n+impl<'a> Drop for Droppable<'a> {\n+    fn drop(&mut self) {\n+        if *self.0 {\n+            writeln!(io::stderr(), \"{} dropped twice\", self.1);\n+            ::std::process::exit(1);\n+        }\n+        writeln!(io::stderr(), \"drop {}\", self.1);\n+        *self.0 = true;\n+    }\n+}\n+\n+#[rustc_mir]\n+fn mir(){\n+    let (mut xv, mut yv) = (false, false);\n+    let x = Droppable(&mut xv, 1);\n+    let y = Droppable(&mut yv, 2);\n+    let mut z = x;\n+    let k = y;\n+    z = k;\n+}\n+\n+fn main() {\n+    mir();\n+    panic!();\n+}"}, {"sha": "eafd3d351fb939030615ba69482c9798a854c3c1", "filename": "src/test/run-fail/mir_dynamic_drops_2.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_2.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(rustc_attrs)]\n+// error-pattern:drop 1\n+use std::io::{self, Write};\n+\n+\n+/// Structure which will not allow to be dropped twice.\n+struct Droppable<'a>(&'a mut bool, u32);\n+impl<'a> Drop for Droppable<'a> {\n+    fn drop(&mut self) {\n+        if *self.0 {\n+            writeln!(io::stderr(), \"{} dropped twice\", self.1);\n+            ::std::process::exit(1);\n+        }\n+        writeln!(io::stderr(), \"drop {}\", self.1);\n+        *self.0 = true;\n+    }\n+}\n+\n+#[rustc_mir]\n+fn mir<'a>(d: Droppable<'a>){\n+    loop {\n+        let x = d;\n+        break;\n+    }\n+}\n+\n+fn main() {\n+    let mut xv = false;\n+    mir(Droppable(&mut xv, 1));\n+    panic!();\n+}"}, {"sha": "730d9c8f22681be8860431e28499f25a5774c506", "filename": "src/test/run-fail/mir_dynamic_drops_3.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmir_dynamic_drops_3.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(rustc_attrs)]\n+// error-pattern:unwind happens\n+// error-pattern:drop 3\n+// error-pattern:drop 2\n+// error-pattern:drop 1\n+use std::io::{self, Write};\n+\n+\n+/// Structure which will not allow to be dropped twice.\n+struct Droppable<'a>(&'a mut bool, u32);\n+impl<'a> Drop for Droppable<'a> {\n+    fn drop(&mut self) {\n+        if *self.0 {\n+            writeln!(io::stderr(), \"{} dropped twice\", self.1);\n+            ::std::process::exit(1);\n+        }\n+        writeln!(io::stderr(), \"drop {}\", self.1);\n+        *self.0 = true;\n+    }\n+}\n+\n+fn may_panic<'a>() -> Droppable<'a> {\n+    panic!(\"unwind happens\");\n+}\n+\n+#[rustc_mir]\n+fn mir<'a>(d: Droppable<'a>){\n+    let (mut a, mut b) = (false, false);\n+    let y = Droppable(&mut a, 2);\n+    let x = [Droppable(&mut b, 1), y, d, may_panic()];\n+}\n+\n+fn main() {\n+    let mut c = false;\n+    mir(Droppable(&mut c, 3));\n+}"}, {"sha": "3f79be0479391a3a0bc435f3cc1a35d474fcc661", "filename": "src/test/run-pass/mir_fat_ptr_drop.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Ftest%2Frun-pass%2Fmir_fat_ptr_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/339a409bfdb6c1e9b280388b5d8d9e898217840f/src%2Ftest%2Frun-pass%2Fmir_fat_ptr_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_fat_ptr_drop.rs?ref=339a409bfdb6c1e9b280388b5d8d9e898217840f", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// test that ordinary fat pointer operations work.\n+\n+#![feature(braced_empty_structs)]\n+#![feature(rustc_attrs)]\n+\n+use std::sync::atomic;\n+use std::sync::atomic::Ordering::SeqCst;\n+\n+static COUNTER: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+\n+struct DropMe {\n+}\n+\n+impl Drop for DropMe {\n+    fn drop(&mut self) {\n+        COUNTER.fetch_add(1, SeqCst);\n+    }\n+}\n+\n+#[rustc_mir]\n+fn fat_ptr_move_then_drop(a: Box<[DropMe]>) {\n+    let b = a;\n+}\n+\n+fn main() {\n+    let a: Box<[DropMe]> = Box::new([DropMe { }]);\n+    fat_ptr_move_then_drop(a);\n+    assert_eq!(COUNTER.load(SeqCst), 1);\n+}"}]}