{"sha": "eca0da59850d4a9eef17c0e6c3795397102d88a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYTBkYTU5ODUwZDRhOWVlZjE3YzBlNmMzNzk1Mzk3MTAyZDg4YTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-15T10:34:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-15T10:34:45Z"}, "message": "Auto merge of #50351 - varkor:vestigial-never-conversion, r=nikomatsakis\n\nRemove vestigial diverging !-coercion\n\nSuch conversions are no longer permitted. Fixes #50350.\n\nr? @nikomatsakis", "tree": {"sha": "441255490b80e0fdc51577d4e4094eba57a0aeb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/441255490b80e0fdc51577d4e4094eba57a0aeb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eca0da59850d4a9eef17c0e6c3795397102d88a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eca0da59850d4a9eef17c0e6c3795397102d88a3", "html_url": "https://github.com/rust-lang/rust/commit/eca0da59850d4a9eef17c0e6c3795397102d88a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eca0da59850d4a9eef17c0e6c3795397102d88a3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b17da2d7b0b0b59f7ac96b1702cfb0d23b05860", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b17da2d7b0b0b59f7ac96b1702cfb0d23b05860", "html_url": "https://github.com/rust-lang/rust/commit/0b17da2d7b0b0b59f7ac96b1702cfb0d23b05860"}, {"sha": "5489969fa18cc74d4b72077940a5c05491ec681f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5489969fa18cc74d4b72077940a5c05491ec681f", "html_url": "https://github.com/rust-lang/rust/commit/5489969fa18cc74d4b72077940a5c05491ec681f"}], "stats": {"total": 63, "additions": 18, "deletions": 45}, "files": [{"sha": "35cc70b08384ccabcc3c20679deafae51b73fa3d", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eca0da59850d4a9eef17c0e6c3795397102d88a3/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca0da59850d4a9eef17c0e6c3795397102d88a3/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=eca0da59850d4a9eef17c0e6c3795397102d88a3", "patch": "@@ -688,7 +688,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                     arm_span: arm.body.span,\n                     source: match_src\n                 });\n-                coercion.coerce(self, &cause, &arm.body, arm_ty, self.diverges.get());\n+                coercion.coerce(self, &cause, &arm.body, arm_ty);\n             }\n         }\n "}, {"sha": "324af7b62704dfabd3c9802ea7b353855dd579b5", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/eca0da59850d4a9eef17c0e6c3795397102d88a3/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca0da59850d4a9eef17c0e6c3795397102d88a3/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=eca0da59850d4a9eef17c0e6c3795397102d88a3", "patch": "@@ -60,7 +60,7 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use check::{Diverges, FnCtxt, Needs};\n+use check::{FnCtxt, Needs};\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -800,22 +800,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 exprs: &[E],\n                                 prev_ty: Ty<'tcx>,\n                                 new: &hir::Expr,\n-                                new_ty: Ty<'tcx>,\n-                                new_diverges: Diverges)\n+                                new_ty: Ty<'tcx>)\n                                 -> RelateResult<'tcx, Ty<'tcx>>\n         where E: AsCoercionSite\n     {\n         let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n         let new_ty = self.resolve_type_vars_with_obligations(new_ty);\n         debug!(\"coercion::try_find_coercion_lub({:?}, {:?})\", prev_ty, new_ty);\n \n-        // Special-ish case: we can coerce any type `T` into the `!`\n-        // type, but only if the source expression diverges.\n-        if prev_ty.is_never() && new_diverges.always() {\n-            debug!(\"permit coercion to `!` because expr diverges\");\n-            return Ok(prev_ty);\n-        }\n-\n         // Special-case that coercion alone cannot handle:\n         // Two function item types of differing IDs or Substs.\n         if let (&ty::TyFnDef(..), &ty::TyFnDef(..)) = (&prev_ty.sty, &new_ty.sty) {\n@@ -1054,14 +1046,12 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                       fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                       cause: &ObligationCause<'tcx>,\n                       expression: &'gcx hir::Expr,\n-                      expression_ty: Ty<'tcx>,\n-                      expression_diverges: Diverges)\n+                      expression_ty: Ty<'tcx>)\n     {\n         self.coerce_inner(fcx,\n                           cause,\n                           Some(expression),\n                           expression_ty,\n-                          expression_diverges,\n                           None, false)\n     }\n \n@@ -1087,7 +1077,6 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                           cause,\n                           None,\n                           fcx.tcx.mk_nil(),\n-                          Diverges::Maybe,\n                           Some(augment_error),\n                           label_unit_as_expected)\n     }\n@@ -1100,7 +1089,6 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         cause: &ObligationCause<'tcx>,\n                         expression: Option<&'gcx hir::Expr>,\n                         mut expression_ty: Ty<'tcx>,\n-                        expression_diverges: Diverges,\n                         augment_error: Option<&mut FnMut(&mut DiagnosticBuilder)>,\n                         label_expression_as_expected: bool)\n     {\n@@ -1134,15 +1122,13 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                                                   exprs,\n                                                   self.merged_ty(),\n                                                   expression,\n-                                                  expression_ty,\n-                                                  expression_diverges),\n+                                                  expression_ty),\n                     Expressions::UpFront(ref coercion_sites) =>\n                         fcx.try_find_coercion_lub(cause,\n                                                   &coercion_sites[0..self.pushed],\n                                                   self.merged_ty(),\n                                                   expression,\n-                                                  expression_ty,\n-                                                  expression_diverges),\n+                                                  expression_ty),\n                 }\n             }\n         } else {"}, {"sha": "b4a7de7b8443c11f96be9122d22cdcc292ac75f9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/eca0da59850d4a9eef17c0e6c3795397102d88a3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca0da59850d4a9eef17c0e6c3795397102d88a3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=eca0da59850d4a9eef17c0e6c3795397102d88a3", "patch": "@@ -542,7 +542,7 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// you get indicates whether any subexpression that was\n     /// evaluating up to and including `X` diverged.\n     ///\n-    /// We use this flag for two purposes:\n+    /// We currently use this flag only for diagnostic purposes:\n     ///\n     /// - To warn about unreachable code: if, after processing a\n     ///   sub-expression but before we have applied the effects of the\n@@ -556,16 +556,8 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ///   foo();}` or `{return; 22}`, where we would warn on the\n     ///   `foo()` or `22`.\n     ///\n-    /// - To permit assignment into a local variable or other place\n-    ///   (including the \"return slot\") of type `!`.  This is allowed\n-    ///   if **either** the type of value being assigned is `!`, which\n-    ///   means the current code is dead, **or** the expression's\n-    ///   diverging flag is true, which means that a diverging value was\n-    ///   wrapped (e.g., `let x: ! = foo(return)`).\n-    ///\n-    /// To repeat the last point: an expression represents dead-code\n-    /// if, after checking it, **either** its type is `!` OR the\n-    /// diverges flag is set to something other than `Maybe`.\n+    /// An expression represents dead-code if, after checking it,\n+    /// the diverges flag is set to something other than `Maybe`.\n     diverges: Cell<Diverges>,\n \n     /// Whether any child nodes have any type errors.\n@@ -3002,8 +2994,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             &self.cause(return_expr.span,\n                                         ObligationCauseCode::ReturnType(return_expr.id)),\n                             return_expr,\n-                            return_expr_ty,\n-                            self.diverges.get());\n+                            return_expr_ty);\n     }\n \n \n@@ -3034,13 +3025,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut coerce: DynamicCoerceMany = CoerceMany::new(coerce_to_ty);\n \n         let if_cause = self.cause(sp, ObligationCauseCode::IfExpression);\n-        coerce.coerce(self, &if_cause, then_expr, then_ty, then_diverges);\n+        coerce.coerce(self, &if_cause, then_expr, then_ty);\n \n         if let Some(else_expr) = opt_else_expr {\n             let else_ty = self.check_expr_with_expectation(else_expr, expected);\n             let else_diverges = self.diverges.get();\n \n-            coerce.coerce(self, &if_cause, else_expr, else_ty, else_diverges);\n+            coerce.coerce(self, &if_cause, else_expr, else_ty);\n \n             // We won't diverge unless both branches do (or the condition does).\n             self.diverges.set(cond_diverges | then_diverges & else_diverges);\n@@ -3733,7 +3724,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           }\n           hir::ExprBreak(destination, ref expr_opt) => {\n               if let Some(target_id) = destination.target_id.opt_id() {\n-                  let (e_ty, e_diverges, cause);\n+                  let (e_ty, cause);\n                   if let Some(ref e) = *expr_opt {\n                       // If this is a break with a value, we need to type-check\n                       // the expression. Get an expected type from the loop context.\n@@ -3752,13 +3743,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                       // Recurse without `enclosing_breakables` borrowed.\n                       e_ty = self.check_expr_with_hint(e, coerce_to);\n-                      e_diverges = self.diverges.get();\n                       cause = self.misc(e.span);\n                   } else {\n                       // Otherwise, this is a break *without* a value. That's\n                       // always legal, and is equivalent to `break ()`.\n                       e_ty = tcx.mk_nil();\n-                      e_diverges = Diverges::Maybe;\n                       cause = self.misc(expr.span);\n                   }\n \n@@ -3769,7 +3758,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   let ctxt = enclosing_breakables.find_breakable(target_id);\n                   if let Some(ref mut coerce) = ctxt.coerce {\n                       if let Some(ref e) = *expr_opt {\n-                          coerce.coerce(self, &cause, e, e_ty, e_diverges);\n+                          coerce.coerce(self, &cause, e, e_ty);\n                       } else {\n                           assert!(e_ty.is_nil());\n                           coerce.coerce_forced_unit(self, &cause, &mut |_| (), true);\n@@ -3975,7 +3964,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   for e in args {\n                       let e_ty = self.check_expr_with_hint(e, coerce_to);\n                       let cause = self.misc(e.span);\n-                      coerce.coerce(self, &cause, e, e_ty, self.diverges.get());\n+                      coerce.coerce(self, &cause, e, e_ty);\n                   }\n                   coerce.complete(self)\n               } else {\n@@ -4386,8 +4375,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 coerce.coerce(self,\n                               &cause,\n                               tail_expr,\n-                              tail_expr_ty,\n-                              self.diverges.get());\n+                              tail_expr_ty);\n             } else {\n                 // Subtle: if there is no explicit tail expression,\n                 // that is typically equivalent to a tail expression"}, {"sha": "8b4e2c3c051e85c618c92d7c6b6a96b59717bd47", "filename": "src/test/compile-fail/coerce-to-bang.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eca0da59850d4a9eef17c0e6c3795397102d88a3/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eca0da59850d4a9eef17c0e6c3795397102d88a3/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-to-bang.rs?ref=eca0da59850d4a9eef17c0e6c3795397102d88a3", "patch": "@@ -56,9 +56,8 @@ fn call_foo_f() {\n }\n \n fn array_a() {\n-    // Accepted: return is coerced to `!` just fine, and then `22` can be\n-    // because we already diverged.\n-    let x: [!; 2] = [return, 22];\n+    // Return is coerced to `!` just fine, but `22` cannot be.\n+    let x: [!; 2] = [return, 22]; //~ ERROR mismatched types\n }\n \n fn array_b() {"}]}