{"sha": "7c20a8ddb8efd3998dc4de049ff69e3161a01788", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMjBhOGRkYjhlZmQzOTk4ZGM0ZGUwNDlmZjY5ZTMxNjFhMDE3ODg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-13T17:17:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-13T17:17:04Z"}, "message": "Rollup merge of #65214 - Amanieu:cfg_atomic, r=alexcrichton\n\nSplit non-CAS atomic support off into target_has_atomic_load_store\n\nThis PR implements my proposed changes in https://github.com/rust-lang/rust/issues/32976#issuecomment-518542029 by removing `target_has_atomic = \"cas\"` and splitting `target_has_atomic` into two separate `cfg`s:\n\n* `target_has_atomic = 8/16/32/64/128`: This indicates the largest width that the target can atomically CAS (which implies support for all atomic operations).\n* ` target_has_atomic_load_store = 8/16/32/64/128`: This indicates the largest width that the target can support loading or storing atomically (but may not support CAS).\n\ncc #32976\n\nr? @alexcrichton", "tree": {"sha": "ca04dbf4f749320ed2a57f7e9a0e97eca43bdd95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca04dbf4f749320ed2a57f7e9a0e97eca43bdd95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c20a8ddb8efd3998dc4de049ff69e3161a01788", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdo1wQCRBK7hj4Ov3rIwAAdHIIAEQSuTiWt8NFsfHHaPqViSkB\n08U0389JIct1Z+P1ilzwb3gwPA67ueh7zBTHdHILQHf2xYsd3Q+IqCwPIosAuL8u\nF+XdKss9md+W2ZHpIrUILLBKGqpixd1++DDgmd/yG/YqIryqpU1ib2Q2kYWKxwjQ\nTttzpXLXxqqXVhW2Ux+fgVxYd3MXvNcfu5OlFY5NDGAQS4pV0sTMHiYxoHl15o8f\n5AiXTIZkdMuJXA4oEkURUcSAoQ9e1DeQ926tZsdsTAw9PELkRX5Ism0NTR2DyEwn\n0+2buznUwl30CNC5XnGzRS9cVki/hR3WKeI0o2cqWKaKUMEupiqIb7cGP32uzGc=\n=WMA/\n-----END PGP SIGNATURE-----\n", "payload": "tree ca04dbf4f749320ed2a57f7e9a0e97eca43bdd95\nparent aa2ae564d391a3da10bca2a79ab529a9925fbe58\nparent dfe76a10935cf93fdc72abc47167691b7aa44a7f\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1570987024 +0200\ncommitter GitHub <noreply@github.com> 1570987024 +0200\n\nRollup merge of #65214 - Amanieu:cfg_atomic, r=alexcrichton\n\nSplit non-CAS atomic support off into target_has_atomic_load_store\n\nThis PR implements my proposed changes in https://github.com/rust-lang/rust/issues/32976#issuecomment-518542029 by removing `target_has_atomic = \"cas\"` and splitting `target_has_atomic` into two separate `cfg`s:\n\n* `target_has_atomic = 8/16/32/64/128`: This indicates the largest width that the target can atomically CAS (which implies support for all atomic operations).\n* ` target_has_atomic_load_store = 8/16/32/64/128`: This indicates the largest width that the target can support loading or storing atomically (but may not support CAS).\n\ncc #32976\n\nr? @alexcrichton\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c20a8ddb8efd3998dc4de049ff69e3161a01788", "html_url": "https://github.com/rust-lang/rust/commit/7c20a8ddb8efd3998dc4de049ff69e3161a01788", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c20a8ddb8efd3998dc4de049ff69e3161a01788/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa2ae564d391a3da10bca2a79ab529a9925fbe58", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa2ae564d391a3da10bca2a79ab529a9925fbe58", "html_url": "https://github.com/rust-lang/rust/commit/aa2ae564d391a3da10bca2a79ab529a9925fbe58"}, {"sha": "dfe76a10935cf93fdc72abc47167691b7aa44a7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfe76a10935cf93fdc72abc47167691b7aa44a7f", "html_url": "https://github.com/rust-lang/rust/commit/dfe76a10935cf93fdc72abc47167691b7aa44a7f"}], "stats": {"total": 225, "additions": 127, "deletions": 98}, "files": [{"sha": "3684162d8b18741782e38e7ede8f13fa6088c417", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c20a8ddb8efd3998dc4de049ff69e3161a01788/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c20a8ddb8efd3998dc4de049ff69e3161a01788/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=7c20a8ddb8efd3998dc4de049ff69e3161a01788", "patch": "@@ -153,7 +153,7 @@ mod boxed {\n #[cfg(test)]\n mod tests;\n pub mod collections;\n-#[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n+#[cfg(target_has_atomic = \"ptr\")]\n pub mod sync;\n pub mod rc;\n pub mod raw_vec;"}, {"sha": "73d5abf1aed2378a27c50a8c56fbc271a9cfb889", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 92, "deletions": 70, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/7c20a8ddb8efd3998dc4de049ff69e3161a01788/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c20a8ddb8efd3998dc4de049ff69e3161a01788/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=7c20a8ddb8efd3998dc4de049ff69e3161a01788", "patch": "@@ -113,8 +113,8 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![cfg_attr(not(target_has_atomic = \"8\"), allow(dead_code))]\n-#![cfg_attr(not(target_has_atomic = \"8\"), allow(unused_imports))]\n+#![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(dead_code))]\n+#![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(unused_imports))]\n \n use self::Ordering::*;\n \n@@ -160,14 +160,14 @@ pub fn spin_loop_hint() {\n /// This type has the same in-memory representation as a [`bool`].\n ///\n /// [`bool`]: ../../../std/primitive.bool.html\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(C, align(1))]\n pub struct AtomicBool {\n     v: UnsafeCell<u8>,\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for AtomicBool {\n     /// Creates an `AtomicBool` initialized to `false`.\n@@ -177,14 +177,14 @@ impl Default for AtomicBool {\n }\n \n // Send is implicitly implemented for AtomicBool.\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl Sync for AtomicBool {}\n \n /// A raw pointer type which can be safely shared between threads.\n ///\n /// This type has the same in-memory representation as a `*mut T`.\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(target_pointer_width = \"16\", repr(C, align(2)))]\n #[cfg_attr(target_pointer_width = \"32\", repr(C, align(4)))]\n@@ -193,7 +193,7 @@ pub struct AtomicPtr<T> {\n     p: UnsafeCell<*mut T>,\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for AtomicPtr<T> {\n     /// Creates a null `AtomicPtr<T>`.\n@@ -202,10 +202,10 @@ impl<T> Default for AtomicPtr<T> {\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Send for AtomicPtr<T> {}\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T> Sync for AtomicPtr<T> {}\n \n@@ -306,7 +306,7 @@ pub enum Ordering {\n /// An [`AtomicBool`] initialized to `false`.\n ///\n /// [`AtomicBool`]: struct.AtomicBool.html\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(\n     since = \"1.34.0\",\n@@ -315,7 +315,7 @@ pub enum Ordering {\n )]\n pub const ATOMIC_BOOL_INIT: AtomicBool = AtomicBool::new(false);\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n impl AtomicBool {\n     /// Creates a new `AtomicBool`.\n     ///\n@@ -464,7 +464,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -502,7 +502,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_and_swap(&self, current: bool, new: bool, order: Ordering) -> bool {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -553,7 +553,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_exchange(&self,\n                             current: bool,\n                             new: bool,\n@@ -609,7 +609,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: bool,\n                                  new: bool,\n@@ -660,7 +660,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -702,7 +702,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n         // We can't use atomic_nand here because it can result in a bool with\n         // an invalid value. This happens because the atomic operation is done\n@@ -755,7 +755,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n     }\n@@ -796,13 +796,13 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n impl<T> AtomicPtr<T> {\n     /// Creates a new `AtomicPtr`.\n     ///\n@@ -953,7 +953,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n         unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n@@ -989,7 +989,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_and_swap(&self, current: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         match self.compare_exchange(current, new, order, strongest_failure_ordering(order)) {\n             Ok(x) => x,\n@@ -1031,7 +1031,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_exchange(&self,\n                             current: *mut T,\n                             new: *mut T,\n@@ -1091,7 +1091,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n-    #[cfg(target_has_atomic = \"cas\")]\n+    #[cfg(target_has_atomic = \"ptr\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: *mut T,\n                                  new: *mut T,\n@@ -1112,7 +1112,7 @@ impl<T> AtomicPtr<T> {\n     }\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\n impl From<bool> for AtomicBool {\n     /// Converts a `bool` into an `AtomicBool`.\n@@ -1128,16 +1128,17 @@ impl From<bool> for AtomicBool {\n     fn from(b: bool) -> Self { Self::new(b) }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_from\", since = \"1.23.0\")]\n impl<T> From<*mut T> for AtomicPtr<T> {\n     #[inline]\n     fn from(p: *mut T) -> Self { Self::new(p) }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n macro_rules! atomic_int {\n-    ($stable:meta,\n+    ($cfg_cas:meta,\n+     $stable:meta,\n      $stable_cxchg:meta,\n      $stable_debug:meta,\n      $stable_access:meta,\n@@ -1358,7 +1359,7 @@ assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_swap(self.v.get(), val, order) }\n                 }\n@@ -1398,7 +1399,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_and_swap(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n@@ -1456,7 +1457,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_exchange(&self,\n                                         current: $int_type,\n                                         new: $int_type,\n@@ -1508,7 +1509,7 @@ loop {\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn compare_exchange_weak(&self,\n                                              current: $int_type,\n                                              new: $int_type,\n@@ -1546,7 +1547,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_add(self.v.get(), val, order) }\n                 }\n@@ -1578,7 +1579,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_sub(self.v.get(), val, order) }\n                 }\n@@ -1613,7 +1614,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_and(self.v.get(), val, order) }\n                 }\n@@ -1649,7 +1650,7 @@ assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n ```\"),\n                 #[inline]\n                 #[$stable_nand]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_nand(self.v.get(), val, order) }\n                 }\n@@ -1684,7 +1685,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_or(self.v.get(), val, order) }\n                 }\n@@ -1719,7 +1720,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n ```\"),\n                 #[inline]\n                 #[$stable]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n@@ -1769,7 +1770,7 @@ assert_eq!(x.load(Ordering::SeqCst), 9);\n                 #[unstable(feature = \"no_more_cas\",\n                        reason = \"no more CAS loops in user code\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_update<F>(&self,\n                                        mut f: F,\n                                        fetch_order: Ordering,\n@@ -1830,7 +1831,7 @@ assert!(max_foo == 42);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $max_fn(self.v.get(), val, order) }\n                 }\n@@ -1882,7 +1883,7 @@ assert_eq!(min_foo, 12);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n-                #[cfg(target_has_atomic = \"cas\")]\n+                #[$cfg_cas]\n                 pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $min_fn(self.v.get(), val, order) }\n                 }\n@@ -1892,8 +1893,9 @@ assert_eq!(min_foo, 12);\n     }\n }\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"8\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1908,8 +1910,9 @@ atomic_int! {\n     \"AtomicI8::new(0)\",\n     i8 AtomicI8 ATOMIC_I8_INIT\n }\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"8\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1924,8 +1927,9 @@ atomic_int! {\n     \"AtomicU8::new(0)\",\n     u8 AtomicU8 ATOMIC_U8_INIT\n }\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"16\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"16\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1940,8 +1944,9 @@ atomic_int! {\n     \"AtomicI16::new(0)\",\n     i16 AtomicI16 ATOMIC_I16_INIT\n }\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"16\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"16\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1956,8 +1961,9 @@ atomic_int! {\n     \"AtomicU16::new(0)\",\n     u16 AtomicU16 ATOMIC_U16_INIT\n }\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"32\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"32\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1972,8 +1978,9 @@ atomic_int! {\n     \"AtomicI32::new(0)\",\n     i32 AtomicI32 ATOMIC_I32_INIT\n }\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"32\"))]\n atomic_int! {\n+    cfg(target_has_atomic = \"32\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -1988,8 +1995,12 @@ atomic_int! {\n     \"AtomicU32::new(0)\",\n     u32 AtomicU32 ATOMIC_U32_INIT\n }\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(any(\n+    all(bootstrap, target_has_atomic = \"64\"),\n+    target_has_atomic_load_store = \"64\"\n+))]\n atomic_int! {\n+    cfg(target_has_atomic = \"64\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -2004,8 +2015,12 @@ atomic_int! {\n     \"AtomicI64::new(0)\",\n     i64 AtomicI64 ATOMIC_I64_INIT\n }\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(any(\n+    all(bootstrap, target_has_atomic = \"64\"),\n+    target_has_atomic_load_store = \"64\"\n+))]\n atomic_int! {\n+    cfg(target_has_atomic = \"64\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n     stable(feature = \"integer_atomics_stable\", since = \"1.34.0\"),\n@@ -2020,8 +2035,9 @@ atomic_int! {\n     \"AtomicU64::new(0)\",\n     u64 AtomicU64 ATOMIC_U64_INIT\n }\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n atomic_int! {\n+    cfg(target_has_atomic = \"128\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -2036,8 +2052,9 @@ atomic_int! {\n     \"AtomicI128::new(0)\",\n     i128 AtomicI128 ATOMIC_I128_INIT\n }\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n atomic_int! {\n+    cfg(target_has_atomic = \"128\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -2052,20 +2069,24 @@ atomic_int! {\n     \"AtomicU128::new(0)\",\n     u128 AtomicU128 ATOMIC_U128_INIT\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"16\")]\n macro_rules! ptr_width {\n     () => { 2 }\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"32\")]\n macro_rules! ptr_width {\n     () => { 4 }\n }\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[cfg(target_pointer_width = \"64\")]\n macro_rules! ptr_width {\n     () => { 8 }\n }\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n atomic_int!{\n+    cfg(target_has_atomic = \"ptr\"),\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n@@ -2080,8 +2101,9 @@ atomic_int!{\n     \"AtomicIsize::new(0)\",\n     isize AtomicIsize ATOMIC_ISIZE_INIT\n }\n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n atomic_int!{\n+    cfg(target_has_atomic = \"ptr\"),\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n@@ -2098,7 +2120,7 @@ atomic_int!{\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n fn strongest_failure_ordering(order: Ordering) -> Ordering {\n     match order {\n         Release => Relaxed,\n@@ -2132,7 +2154,7 @@ unsafe fn atomic_load<T>(dst: *const T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xchg_acq(dst, val),\n@@ -2145,7 +2167,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -2158,7 +2180,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -2170,7 +2192,7 @@ unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n                                      old: T,\n                                      new: T,\n@@ -2195,7 +2217,7 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n                                           old: T,\n                                           new: T,\n@@ -2220,7 +2242,7 @@ unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -2232,7 +2254,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -2244,7 +2266,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -2256,7 +2278,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n@@ -2269,7 +2291,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_max_acq(dst, val),\n@@ -2282,7 +2304,7 @@ unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_min_acq(dst, val),\n@@ -2295,7 +2317,7 @@ unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umax_acq(dst, val),\n@@ -2308,7 +2330,7 @@ unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"cas\")]\n+#[cfg(target_has_atomic = \"8\")]\n unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umin_acq(dst, val),\n@@ -2506,23 +2528,23 @@ pub fn compiler_fence(order: Ordering) {\n }\n \n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"8\"))]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl fmt::Debug for AtomicBool {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_debug\", since = \"1.3.0\")]\n impl<T> fmt::Debug for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&self.load(Ordering::SeqCst), f)\n     }\n }\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(any(bootstrap, target_has_atomic_load_store = \"ptr\"))]\n #[stable(feature = \"atomic_pointer\", since = \"1.24.0\")]\n impl<T> fmt::Pointer for AtomicPtr<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "0facf30b6274bbef1f1b6de99bdb1324894c6365", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7c20a8ddb8efd3998dc4de049ff69e3161a01788/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c20a8ddb8efd3998dc4de049ff69e3161a01788/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=7c20a8ddb8efd3998dc4de049ff69e3161a01788", "patch": "@@ -1513,22 +1513,25 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     }\n     for &i in &[8, 16, 32, 64, 128] {\n         if i >= min_atomic_width && i <= max_atomic_width {\n-            let s = i.to_string();\n-            ret.insert((\n-                sym::target_has_atomic,\n-                Some(Symbol::intern(&s)),\n-            ));\n-            if &s == wordsz {\n+            let mut insert_atomic = |s| {\n                 ret.insert((\n-                    sym::target_has_atomic,\n-                    Some(Symbol::intern(\"ptr\")),\n+                    sym::target_has_atomic_load_store,\n+                    Some(Symbol::intern(s)),\n                 ));\n+                if atomic_cas {\n+                    ret.insert((\n+                        sym::target_has_atomic,\n+                        Some(Symbol::intern(s))\n+                    ));\n+                }\n+            };\n+            let s = i.to_string();\n+            insert_atomic(&s);\n+            if &s == wordsz {\n+              insert_atomic(\"ptr\");\n             }\n         }\n     }\n-    if atomic_cas {\n-        ret.insert((sym::target_has_atomic, Some(Symbol::intern(\"cas\"))));\n-    }\n     if sess.opts.debug_assertions {\n         ret.insert((Symbol::intern(\"debug_assertions\"), None));\n     }"}, {"sha": "24c693790e84bcf239a57e3bff233604b595e36d", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7c20a8ddb8efd3998dc4de049ff69e3161a01788/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c20a8ddb8efd3998dc4de049ff69e3161a01788/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=7c20a8ddb8efd3998dc4de049ff69e3161a01788", "patch": "@@ -12,7 +12,9 @@ use crate::ops::{Deref, DerefMut};\n use crate::panicking;\n use crate::ptr::{Unique, NonNull};\n use crate::rc::Rc;\n-use crate::sync::{Arc, Mutex, RwLock, atomic};\n+use crate::sync::{Arc, Mutex, RwLock};\n+#[cfg(not(bootstrap))]\n+use crate::sync::atomic;\n use crate::task::{Context, Poll};\n use crate::thread::Result;\n \n@@ -240,49 +242,49 @@ impl<T: ?Sized> RefUnwindSafe for Mutex<T> {}\n #[stable(feature = \"unwind_safe_lock_refs\", since = \"1.12.0\")]\n impl<T: ?Sized> RefUnwindSafe for RwLock<T> {}\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl RefUnwindSafe for atomic::AtomicIsize {}\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI8 {}\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(target_has_atomic_load_store = \"16\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI16 {}\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(target_has_atomic_load_store = \"32\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI32 {}\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(target_has_atomic_load_store = \"64\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI64 {}\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicI128 {}\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl RefUnwindSafe for atomic::AtomicUsize {}\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(target_hastarget_has_atomic_load_store_atomic = \"8\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU8 {}\n-#[cfg(target_has_atomic = \"16\")]\n+#[cfg(target_has_atomic_load_store = \"16\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU16 {}\n-#[cfg(target_has_atomic = \"32\")]\n+#[cfg(target_has_atomic_load_store = \"32\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU32 {}\n-#[cfg(target_has_atomic = \"64\")]\n+#[cfg(target_has_atomic_load_store = \"64\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU64 {}\n-#[cfg(target_has_atomic = \"128\")]\n+#[cfg(target_has_atomic_load_store = \"128\")]\n #[unstable(feature = \"integer_atomics\", issue = \"32976\")]\n impl RefUnwindSafe for atomic::AtomicU128 {}\n \n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl RefUnwindSafe for atomic::AtomicBool {}\n \n-#[cfg(target_has_atomic = \"ptr\")]\n+#[cfg(target_has_atomic_load_store = \"ptr\")]\n #[stable(feature = \"unwind_safe_atomic_refs\", since = \"1.14.0\")]\n impl<T> RefUnwindSafe for atomic::AtomicPtr<T> {}\n "}, {"sha": "ab1620b95249151baf50576577b6ea15e8e069bb", "filename": "src/libsyntax/feature_gate/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c20a8ddb8efd3998dc4de049ff69e3161a01788/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c20a8ddb8efd3998dc4de049ff69e3161a01788/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fbuiltin_attrs.rs?ref=7c20a8ddb8efd3998dc4de049ff69e3161a01788", "patch": "@@ -29,6 +29,7 @@ const GATED_CFGS: &[(Symbol, Symbol, GateFn)] = &[\n     // (name in cfg, feature, function to check if the feature is enabled)\n     (sym::target_thread_local, sym::cfg_target_thread_local, cfg_fn!(cfg_target_thread_local)),\n     (sym::target_has_atomic, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n+    (sym::target_has_atomic_load_store, sym::cfg_target_has_atomic, cfg_fn!(cfg_target_has_atomic)),\n     (sym::rustdoc, sym::doc_cfg, cfg_fn!(doc_cfg)),\n     (sym::doctest, sym::cfg_doctest, cfg_fn!(cfg_doctest)),\n ];"}, {"sha": "c37efde9923a73de3b694114c560ceaf877391ca", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c20a8ddb8efd3998dc4de049ff69e3161a01788/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c20a8ddb8efd3998dc4de049ff69e3161a01788/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=7c20a8ddb8efd3998dc4de049ff69e3161a01788", "patch": "@@ -658,6 +658,7 @@ symbols! {\n         suggestion,\n         target_feature,\n         target_has_atomic,\n+        target_has_atomic_load_store,\n         target_thread_local,\n         task,\n         tbm_target_feature,"}, {"sha": "9868fc1d41700ab5b1f66d2b80a5edf2614f4b9c", "filename": "src/test/run-make-fulldeps/target-without-atomic-cas/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c20a8ddb8efd3998dc4de049ff69e3161a01788/src%2Ftest%2Frun-make-fulldeps%2Ftarget-without-atomic-cas%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7c20a8ddb8efd3998dc4de049ff69e3161a01788/src%2Ftest%2Frun-make-fulldeps%2Ftarget-without-atomic-cas%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Ftarget-without-atomic-cas%2FMakefile?ref=7c20a8ddb8efd3998dc4de049ff69e3161a01788", "patch": "@@ -2,4 +2,4 @@\n \n # The target used below doesn't support atomic CAS operations. Verify that's the case\n all:\n-\t$(RUSTC) --print cfg --target thumbv6m-none-eabi | $(CGREP) -v 'target_has_atomic=\"cas\"'\n+\t$(RUSTC) --print cfg --target thumbv6m-none-eabi | $(CGREP) -v 'target_has_atomic=\"ptr\"'"}]}