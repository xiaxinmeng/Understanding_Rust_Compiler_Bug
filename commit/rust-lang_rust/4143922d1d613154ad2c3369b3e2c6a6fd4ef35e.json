{"sha": "4143922d1d613154ad2c3369b3e2c6a6fd4ef35e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNDM5MjJkMWQ2MTMxNTRhZDJjMzM2OWIzZTJjNmE2ZmQ0ZWYzNWU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-05-26T15:07:34Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-06-03T11:08:51Z"}, "message": "Partial rustup", "tree": {"sha": "ba3fb19ca086274c071888b9a6d0ee1d32058ece", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba3fb19ca086274c071888b9a6d0ee1d32058ece"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e", "html_url": "https://github.com/rust-lang/rust/commit/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1437a975d64b0e04f807abfbca78deb4c93f928e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1437a975d64b0e04f807abfbca78deb4c93f928e", "html_url": "https://github.com/rust-lang/rust/commit/1437a975d64b0e04f807abfbca78deb4c93f928e"}], "stats": {"total": 614, "additions": 358, "deletions": 256}, "files": [{"sha": "2bf78b0a71cc16a98b67dd4e39da4f39f5d2fde0", "filename": "benches/helpers/miri_helper.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/benches%2Fhelpers%2Fmiri_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/benches%2Fhelpers%2Fmiri_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/benches%2Fhelpers%2Fmiri_helper.rs?ref=4143922d1d613154ad2c3369b3e2c6a6fd4ef35e", "patch": "@@ -55,16 +55,13 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls<'a> {\n             state.session.abort_if_errors();\n \n             let tcx = state.tcx.unwrap();\n-            let (entry_node_id, _) = state.session.entry_fn.borrow().expect(\n+            let (entry_node_id, _, _) = state.session.entry_fn.borrow().expect(\n                 \"no main or start function found\",\n             );\n-            let entry_def_id = tcx.map.local_def_id(entry_node_id);\n+            let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n \n-            let memory_size = 100 * 1024 * 1024; // 100MB\n-            let step_limit = 1000_000;\n-            let stack_limit = 100;\n             bencher.borrow_mut().iter(|| {\n-                eval_main(tcx, entry_def_id, memory_size, step_limit, stack_limit);\n+                eval_main(tcx, entry_def_id, None);\n             });\n \n             state.session.abort_if_errors();"}, {"sha": "ea0c5eb8b26e993fe3613061a0f42e5129777cf2", "filename": "src/fn_call.rs", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=4143922d1d613154ad2c3369b3e2c6a6fd4ef35e", "patch": "@@ -38,7 +38,7 @@ fn write_discriminant_value<'a, 'mir, 'tcx: 'a + 'mir>(\n                     .val;\n \n                 let (discr_dest, discr) = ecx.place_field(dest, mir::Field::new(0), layout)?;\n-                ecx.write_primval(discr_dest, PrimVal::Bytes(discr_val), discr.ty)?;\n+                ecx.write_scalar(discr_dest, Scalar::from_u128(discr_val), discr.ty)?;\n             }\n             layout::Variants::NicheFilling {\n                 dataful_variant,\n@@ -51,7 +51,7 @@ fn write_discriminant_value<'a, 'mir, 'tcx: 'a + 'mir>(\n                         ecx.place_field(dest, mir::Field::new(0), layout)?;\n                     let niche_value = ((variant_index - niche_variants.start()) as u128)\n                         .wrapping_add(niche_start);\n-                    ecx.write_primval(niche_dest, PrimVal::Bytes(niche_value), niche.ty)?;\n+                    ecx.write_scalar(niche_dest, Scalar::from_u128(niche_value), niche.ty)?;\n                 }\n             }\n         }\n@@ -182,13 +182,13 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n \n         match &link_name[..] {\n             \"malloc\" => {\n-                let size = self.value_to_primval(args[0])?.to_u64()?;\n+                let size = self.value_to_scalar(args[0])?.to_u64()?;\n                 if size == 0 {\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n                     let align = self.tcx.data_layout.pointer_align;\n                     let ptr = self.memory.allocate(Size::from_bytes(size), align, Some(MemoryKind::C.into()))?;\n-                    self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+                    self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n                 }\n             }\n \n@@ -209,7 +209,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 //\n                 // libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)\n                 // is called if a `HashMap` is created the regular way.\n-                match self.value_to_primval(args[0])?.to_u64()? {\n+                match self.value_to_scalar(args[0])?.to_u64()? {\n                     318 | 511 => {\n                         return err!(Unimplemented(\n                             \"miri does not support random number generators\".to_owned(),\n@@ -281,7 +281,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             \"memcmp\" => {\n                 let left = self.into_ptr(args[0].value)?;\n                 let right = self.into_ptr(args[1].value)?;\n-                let n = Size::from_bytes(self.value_to_primval(args[2])?.to_u64()?);\n+                let n = Size::from_bytes(self.value_to_scalar(args[2])?.to_u64()?);\n \n                 let result = {\n                     let left_bytes = self.memory.read_bytes(left, n)?;\n@@ -295,22 +295,22 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     }\n                 };\n \n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes(result as u128),\n+                    Scalar::from_i8(result),\n                     dest_ty,\n                 )?;\n             }\n \n             \"memrchr\" => {\n                 let ptr = self.into_ptr(args[0].value)?;\n-                let val = self.value_to_primval(args[1])?.to_u64()? as u8;\n-                let num = self.value_to_primval(args[2])?.to_u64()?;\n+                let val = self.value_to_scalar(args[1])?.to_u64()? as u8;\n+                let num = self.value_to_scalar(args[2])?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().rev().position(\n                     |&c| c == val,\n                 )\n                 {\n-                    let new_ptr = ptr.offset(Size::from_bytes(num - idx as u64 - 1), &self)?;\n+                    let new_ptr = ptr.ptr_offset(Size::from_bytes(num - idx as u64 - 1), &self)?;\n                     self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n                     self.write_null(dest, dest_ty)?;\n@@ -319,13 +319,13 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n \n             \"memchr\" => {\n                 let ptr = self.into_ptr(args[0].value)?;\n-                let val = self.value_to_primval(args[1])?.to_u64()? as u8;\n-                let num = self.value_to_primval(args[2])?.to_u64()?;\n+                let val = self.value_to_scalar(args[1])?.to_u64()? as u8;\n+                let num = self.value_to_scalar(args[2])?.to_u64()?;\n                 if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().position(\n                     |&c| c == val,\n                 )\n                 {\n-                    let new_ptr = ptr.offset(Size::from_bytes(idx as u64), &self)?;\n+                    let new_ptr = ptr.ptr_offset(Size::from_bytes(idx as u64), &self)?;\n                     self.write_ptr(dest, new_ptr, dest_ty)?;\n                 } else {\n                     self.write_null(dest, dest_ty)?;\n@@ -337,11 +337,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     let name_ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n                     let name = self.memory.read_c_str(name_ptr)?;\n                     match self.machine.env_vars.get(name) {\n-                        Some(&var) => PrimVal::Ptr(var),\n-                        None => PrimVal::Bytes(0),\n+                        Some(&var) => Scalar::Ptr(var),\n+                        None => Scalar::null(),\n                     }\n                 };\n-                self.write_primval(dest, result, dest_ty)?;\n+                self.write_scalar(dest, result, dest_ty)?;\n             }\n \n             \"unsetenv\" => {\n@@ -361,7 +361,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     }\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n-                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n+                    self.write_scalar(dest, Scalar::from_i128(-1), dest_ty)?;\n                 }\n             }\n \n@@ -397,14 +397,14 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     }\n                     self.write_null(dest, dest_ty)?;\n                 } else {\n-                    self.write_primval(dest, PrimVal::from_i128(-1), dest_ty)?;\n+                    self.write_scalar(dest, Scalar::from_i128(-1), dest_ty)?;\n                 }\n             }\n \n             \"write\" => {\n-                let fd = self.value_to_primval(args[0])?.to_u64()?;\n+                let fd = self.value_to_scalar(args[0])?.to_u64()?;\n                 let buf = self.into_ptr(args[1].value)?;\n-                let n = self.value_to_primval(args[2])?.to_u64()?;\n+                let n = self.value_to_scalar(args[2])?.to_u64()?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 {\n                     // stdout/stderr\n@@ -417,39 +417,41 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                         io::stderr().write(buf_cont)\n                     };\n                     match res {\n-                        Ok(n) => n as isize,\n+                        Ok(n) => n as i64,\n                         Err(_) => -1,\n                     }\n                 } else {\n                     warn!(\"Ignored output to FD {}\", fd);\n-                    n as isize // pretend it all went well\n+                    n as i64 // pretend it all went well\n                 }; // now result is the value we return back to the program\n-                self.write_primval(\n+                let ptr_size = self.memory.pointer_size();\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes(result as u128),\n+                    Scalar::from_isize(result, ptr_size),\n                     dest_ty,\n                 )?;\n             }\n \n             \"strlen\" => {\n                 let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n                 let n = self.memory.read_c_str(ptr)?.len();\n-                self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n+                let ptr_size = self.memory.pointer_size();\n+                self.write_scalar(dest, Scalar::from_usize(n as u64, ptr_size), dest_ty)?;\n             }\n \n             // Some things needed for sys::thread initialization to go through\n             \"signal\" | \"sigaction\" | \"sigaltstack\" => {\n-                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n+                self.write_scalar(dest, Scalar::null(), dest_ty)?;\n             }\n \n             \"sysconf\" => {\n-                let name = self.value_to_primval(args[0])?.to_u64()?;\n+                let name = self.value_to_scalar(args[0])?.to_u64()?;\n \n                 trace!(\"sysconf() called with name {}\", name);\n                 // cache the sysconf integers via miri's global cache\n                 let paths = &[\n-                    (&[\"libc\", \"_SC_PAGESIZE\"], PrimVal::Bytes(4096)),\n-                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], PrimVal::from_i128(-1)),\n+                    (&[\"libc\", \"_SC_PAGESIZE\"], Scalar::from_i128(4096)),\n+                    (&[\"libc\", \"_SC_GETPW_R_SIZE_MAX\"], Scalar::from_i128(-1)),\n                 ];\n                 let mut result = None;\n                 for &(path, path_value) in paths {\n@@ -467,7 +469,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     }\n                 }\n                 if let Some(result) = result {\n-                    self.write_primval(dest, result, dest_ty)?;\n+                    self.write_scalar(dest, result, dest_ty)?;\n                 } else {\n                     return err!(Unimplemented(\n                         format!(\"Unimplemented sysconf name: {}\", name),\n@@ -481,11 +483,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 let key_align = self.layout_of(args[0].ty)?.align;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n-                let dtor = match self.into_ptr(args[1].value)?.into_inner_primval() {\n-                    PrimVal::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n-                    PrimVal::Bytes(0) => None,\n-                    PrimVal::Bytes(_) => return err!(ReadBytesAsPointer),\n-                    PrimVal::Undef => return err!(ReadUndefBytes),\n+                let dtor = match self.into_ptr(args[1].value)? {\n+                    Scalar::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n+                    Scalar::Bits { defined: 0, .. } => return err!(ReadUndefBytes),\n+                    Scalar::Bits { bits: 0, .. } => None,\n+                    Scalar::Bits { .. } => return err!(ReadBytesAsPointer),\n                 };\n \n                 // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n@@ -498,10 +500,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 if key_size.bits() < 128 && key >= (1u128 << key_size.bits() as u128) {\n                     return err!(OutOfTls);\n                 }\n-                self.memory.write_primval(\n+                self.memory.write_scalar(\n                     key_ptr,\n                     key_align,\n-                    PrimVal::Bytes(key),\n+                    Scalar::from_u128(key),\n                     key_size,\n                     false,\n                 )?;\n@@ -511,20 +513,20 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             }\n             \"pthread_key_delete\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0])?.to_u64()? as TlsKey;\n+                let key = self.value_to_scalar(args[0])?.to_u64()? as TlsKey;\n                 self.memory.delete_tls_key(key)?;\n                 // Return success (0)\n                 self.write_null(dest, dest_ty)?;\n             }\n             \"pthread_getspecific\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0])?.to_u64()? as TlsKey;\n+                let key = self.value_to_scalar(args[0])?.to_u64()? as TlsKey;\n                 let ptr = self.memory.load_tls(key)?;\n                 self.write_ptr(dest, ptr, dest_ty)?;\n             }\n             \"pthread_setspecific\" => {\n                 // The conversion into TlsKey here is a little fishy, but should work as long as usize >= libc::pthread_key_t\n-                let key = self.value_to_primval(args[0])?.to_u64()? as TlsKey;\n+                let key = self.value_to_scalar(args[0])?.to_u64()? as TlsKey;\n                 let new_ptr = self.into_ptr(args[1].value)?;\n                 self.memory.store_tls(key, new_ptr)?;\n \n@@ -635,8 +637,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n         match &path[..] {\n             // Allocators are magic.  They have no MIR, even when the rest of libstd does.\n             \"alloc::alloc::::__rust_alloc\" => {\n-                let size = self.value_to_primval(args[0])?.to_u64()?;\n-                let align = self.value_to_primval(args[1])?.to_u64()?;\n+                let size = self.value_to_scalar(args[0])?.to_u64()?;\n+                let align = self.value_to_scalar(args[1])?.to_u64()?;\n                 if size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }\n@@ -646,11 +648,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 let ptr = self.memory.allocate(Size::from_bytes(size),\n                                                Align::from_bytes(align, align).unwrap(),\n                                                Some(MemoryKind::Rust.into()))?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+                self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::alloc::::__rust_alloc_zeroed\" => {\n-                let size = self.value_to_primval(args[0])?.to_u64()?;\n-                let align = self.value_to_primval(args[1])?.to_u64()?;\n+                let size = self.value_to_scalar(args[0])?.to_u64()?;\n+                let align = self.value_to_scalar(args[1])?.to_u64()?;\n                 if size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }\n@@ -661,12 +663,12 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                                                Align::from_bytes(align, align).unwrap(),\n                                                Some(MemoryKind::Rust.into()))?;\n                 self.memory.write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n-                self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n+                self.write_scalar(dest, Scalar::Ptr(ptr), dest_ty)?;\n             }\n             \"alloc::alloc::::__rust_dealloc\" => {\n                 let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1])?.to_u64()?;\n-                let align = self.value_to_primval(args[2])?.to_u64()?;\n+                let old_size = self.value_to_scalar(args[1])?.to_u64()?;\n+                let align = self.value_to_scalar(args[2])?.to_u64()?;\n                 if old_size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }\n@@ -681,9 +683,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             }\n             \"alloc::alloc::::__rust_realloc\" => {\n                 let ptr = self.into_ptr(args[0].value)?.to_ptr()?;\n-                let old_size = self.value_to_primval(args[1])?.to_u64()?;\n-                let align = self.value_to_primval(args[2])?.to_u64()?;\n-                let new_size = self.value_to_primval(args[3])?.to_u64()?;\n+                let old_size = self.value_to_scalar(args[1])?.to_u64()?;\n+                let align = self.value_to_scalar(args[2])?.to_u64()?;\n+                let new_size = self.value_to_scalar(args[3])?.to_u64()?;\n                 if old_size == 0 || new_size == 0 {\n                     return err!(HeapAllocZeroBytes);\n                 }\n@@ -698,7 +700,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                     Align::from_bytes(align, align).unwrap(),\n                     MemoryKind::Rust.into(),\n                 )?;\n-                self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n+                self.write_scalar(dest, Scalar::Ptr(new_ptr), dest_ty)?;\n             }\n \n             // A Rust function is missing, which means we are running with MIR missing for libstd (or other dependencies).\n@@ -720,13 +722,13 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             \"std::rt::panicking\" => {\n                 // we abort on panic -> `std::rt::panicking` always returns false\n                 let bool = self.tcx.types.bool;\n-                self.write_primval(dest, PrimVal::from_bool(false), bool)?;\n+                self.write_scalar(dest, Scalar::from_bool(false), bool)?;\n             }\n             \"std::sys::imp::c::::AddVectoredExceptionHandler\" |\n             \"std::sys::imp::c::::SetThreadStackGuarantee\" => {\n                 let usize = self.tcx.types.usize;\n                 // any non zero value works for the stdlib. This is just used for stackoverflows anyway\n-                self.write_primval(dest, PrimVal::Bytes(1), usize)?;\n+                self.write_scalar(dest, Scalar::from_u128(1), usize)?;\n             },\n             _ => return err!(NoMirFor(path)),\n         }\n@@ -740,6 +742,6 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n     }\n \n     fn write_null(&mut self, dest: Place, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {\n-        self.write_primval(dest, PrimVal::Bytes(0), dest_ty)\n+        self.write_scalar(dest, Scalar::null(), dest_ty)\n     }\n }"}, {"sha": "d881d5c271104564894aacf55721a1df36e53eb4", "filename": "src/helpers.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=4143922d1d613154ad2c3369b3e2c6a6fd4ef35e", "patch": "@@ -1,24 +1,24 @@\n use mir;\n use rustc::ty::Ty;\n-use rustc::ty::layout::LayoutOf;\n+use rustc::ty::layout::{LayoutOf, Size};\n \n-use super::{Pointer, EvalResult, PrimVal, EvalContext, ValTy};\n+use super::{Scalar, ScalarExt, EvalResult, EvalContext, ValTy};\n use rustc_mir::interpret::sign_extend;\n \n pub trait EvalContextExt<'tcx> {\n     fn wrapping_pointer_offset(\n         &self,\n-        ptr: Pointer,\n+        ptr: Scalar,\n         pointee_ty: Ty<'tcx>,\n         offset: i64,\n-    ) -> EvalResult<'tcx, Pointer>;\n+    ) -> EvalResult<'tcx, Scalar>;\n \n     fn pointer_offset(\n         &self,\n-        ptr: Pointer,\n+        ptr: Scalar,\n         pointee_ty: Ty<'tcx>,\n         offset: i64,\n-    ) -> EvalResult<'tcx, Pointer>;\n+    ) -> EvalResult<'tcx, Scalar>;\n \n     fn value_to_isize(\n         &self,\n@@ -44,22 +44,22 @@ pub trait EvalContextExt<'tcx> {\n impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n     fn wrapping_pointer_offset(\n         &self,\n-        ptr: Pointer,\n+        ptr: Scalar,\n         pointee_ty: Ty<'tcx>,\n         offset: i64,\n-    ) -> EvalResult<'tcx, Pointer> {\n+    ) -> EvalResult<'tcx, Scalar> {\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n         let offset = offset.overflowing_mul(pointee_size).0;\n-        ptr.wrapping_signed_offset(offset, self)\n+        ptr.ptr_wrapping_signed_offset(offset, self)\n     }\n \n     fn pointer_offset(\n         &self,\n-        ptr: Pointer,\n+        ptr: Scalar,\n         pointee_ty: Ty<'tcx>,\n         offset: i64,\n-    ) -> EvalResult<'tcx, Pointer> {\n+    ) -> EvalResult<'tcx, Scalar> {\n         // This function raises an error if the offset moves the pointer outside of its allocation.  We consider\n         // ZSTs their own huge allocation that doesn't overlap with anything (and nothing moves in there because the size is 0).\n         // We also consider the NULL pointer its own separate allocation, and all the remaining integers pointers their own\n@@ -76,9 +76,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         // FIXME: assuming here that type size is < i64::max_value()\n         let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n         return if let Some(offset) = offset.checked_mul(pointee_size) {\n-            let ptr = ptr.signed_offset(offset, self)?;\n+            let ptr = ptr.ptr_signed_offset(offset, self)?;\n             // Do not do bounds-checking for integers; they can never alias a normal pointer anyway.\n-            if let PrimVal::Ptr(ptr) = ptr.into_inner_primval() {\n+            if let Scalar::Ptr(ptr) = ptr {\n                 self.memory.check_bounds(ptr, false)?;\n             } else if ptr.is_null()? {\n                 // We moved *to* a NULL pointer.  That seems wrong, LLVM considers the NULL pointer its own small allocation.  Reject this, for now.\n@@ -95,7 +95,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         value: ValTy<'tcx>,\n     ) -> EvalResult<'tcx, i64> {\n         assert_eq!(value.ty, self.tcx.types.isize);\n-        let raw = self.value_to_primval(value)?.to_bytes()?;\n+        let raw = self.value_to_scalar(value)?.to_bits(self.memory.pointer_size())?;\n         let raw = sign_extend(self.tcx.tcx, raw, self.tcx.types.isize)?;\n         Ok(raw as i64)\n     }\n@@ -105,15 +105,15 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         value: ValTy<'tcx>,\n     ) -> EvalResult<'tcx, u64> {\n         assert_eq!(value.ty, self.tcx.types.usize);\n-        self.value_to_primval(value)?.to_bytes().map(|v| v as u64)\n+        self.value_to_scalar(value)?.to_bits(self.memory.pointer_size()).map(|v| v as u64)\n     }\n \n     fn value_to_i32(\n         &self,\n         value: ValTy<'tcx>,\n     ) -> EvalResult<'tcx, i32> {\n         assert_eq!(value.ty, self.tcx.types.i32);\n-        let raw = self.value_to_primval(value)?.to_bytes()?;\n+        let raw = self.value_to_scalar(value)?.to_bits(Size::from_bits(32))?;\n         let raw = sign_extend(self.tcx.tcx, raw, self.tcx.types.i32)?;\n         Ok(raw as i32)\n     }\n@@ -123,6 +123,6 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n         value: ValTy<'tcx>,\n     ) -> EvalResult<'tcx, u8> {\n         assert_eq!(value.ty, self.tcx.types.u8);\n-        self.value_to_primval(value)?.to_bytes().map(|v| v as u8)\n+        self.value_to_scalar(value)?.to_bits(Size::from_bits(8)).map(|v| v as u8)\n     }\n }"}, {"sha": "3d537ea629c3b83b77e9db890fc515e364e463cd", "filename": "src/intrinsic.rs", "status": "modified", "additions": 105, "deletions": 101, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=4143922d1d613154ad2c3369b3e2c6a6fd4ef35e", "patch": "@@ -1,12 +1,14 @@\n use rustc::mir;\n-use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n+use rustc::ty::layout::{TyLayout, LayoutOf, Size, Primitive, Integer::*};\n use rustc::ty;\n \n-use rustc::mir::interpret::{EvalResult, PrimVal, PrimValKind, Value, Pointer};\n+use rustc::mir::interpret::{EvalResult, Scalar, Value};\n use rustc_mir::interpret::{Place, PlaceExtra, HasMemory, EvalContext, ValTy};\n \n use helpers::EvalContextExt as HelperEvalContextExt;\n \n+use super::ScalarExt;\n+\n pub trait EvalContextExt<'tcx> {\n     fn call_intrinsic(\n         &mut self,\n@@ -36,7 +38,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 // alignment bigger than the one requested\n                 let n = u128::max_value();\n                 let amt = 128 - self.memory.pointer_size().bytes() * 8;\n-                self.write_primval(dest, PrimVal::Bytes((n << amt) >> amt), dest_layout.ty)?;\n+                self.write_scalar(dest, Scalar::from_u128((n << amt) >> amt), dest_layout.ty)?;\n             },\n \n             \"add_with_overflow\" => {\n@@ -77,7 +79,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             }\n \n             \"assume\" => {\n-                let cond = self.value_to_primval(args[0])?.to_bool()?;\n+                let cond = self.value_to_scalar(args[0])?.to_bool()?;\n                 if !cond {\n                     return err!(AssumptionNotHeld);\n                 }\n@@ -115,16 +117,16 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let ty = substs.type_at(0);\n                 let align = self.layout_of(ty)?.align;\n                 let ptr = self.into_ptr(args[0].value)?;\n-                let change = self.value_to_primval(args[1])?;\n+                let change = self.value_to_scalar(args[1])?;\n                 let old = self.read_value(ptr, align, ty)?;\n                 let old = match old {\n-                    Value::ByVal(val) => val,\n+                    Value::Scalar(val) => val,\n                     Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n-                    Value::ByValPair(..) => bug!(\"atomic_xchg doesn't work with nonprimitives\"),\n+                    Value::ScalarPair(..) => bug!(\"atomic_xchg doesn't work with nonprimitives\"),\n                 };\n-                self.write_primval(dest, old, ty)?;\n-                self.write_primval(\n-                    Place::from_primval_ptr(ptr, align),\n+                self.write_scalar(dest, old, ty)?;\n+                self.write_scalar(\n+                    Place::from_scalar_ptr(ptr, align),\n                     change,\n                     ty,\n                 )?;\n@@ -134,22 +136,22 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let ty = substs.type_at(0);\n                 let align = self.layout_of(ty)?.align;\n                 let ptr = self.into_ptr(args[0].value)?;\n-                let expect_old = self.value_to_primval(args[1])?;\n-                let change = self.value_to_primval(args[2])?;\n+                let expect_old = self.value_to_scalar(args[1])?;\n+                let change = self.value_to_scalar(args[2])?;\n                 let old = self.read_value(ptr, align, ty)?;\n                 let old = match old {\n-                    Value::ByVal(val) => val,\n+                    Value::Scalar(val) => val,\n                     Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n-                    Value::ByValPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n+                    Value::ScalarPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n                 };\n                 let (val, _) = self.binary_op(mir::BinOp::Eq, old, ty, expect_old, ty)?;\n                 let valty = ValTy {\n-                    value: Value::ByValPair(old, val),\n+                    value: Value::ScalarPair(old, val),\n                     ty: dest_layout.ty,\n                 };\n                 self.write_value(valty, dest)?;\n-                self.write_primval(\n-                    Place::from_primval_ptr(ptr, dest_layout.align),\n+                self.write_scalar(\n+                    Place::from_scalar_ptr(ptr, dest_layout.align),\n                     change,\n                     ty,\n                 )?;\n@@ -183,16 +185,16 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let ty = substs.type_at(0);\n                 let align = self.layout_of(ty)?.align;\n                 let ptr = self.into_ptr(args[0].value)?;\n-                let change = self.value_to_primval(args[1])?;\n+                let change = self.value_to_scalar(args[1])?;\n                 let old = self.read_value(ptr, align, ty)?;\n                 let old = match old {\n-                    Value::ByVal(val) => val,\n+                    Value::Scalar(val) => val,\n                     Value::ByRef { .. } => bug!(\"just read the value, can't be byref\"),\n-                    Value::ByValPair(..) => {\n+                    Value::ScalarPair(..) => {\n                         bug!(\"atomic_xadd_relaxed doesn't work with nonprimitives\")\n                     }\n                 };\n-                self.write_primval(dest, old, ty)?;\n+                self.write_scalar(dest, old, ty)?;\n                 let op = match intrinsic_name.split('_').nth(1).unwrap() {\n                     \"or\" => mir::BinOp::BitOr,\n                     \"xor\" => mir::BinOp::BitXor,\n@@ -203,7 +205,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 };\n                 // FIXME: what do atomics do on overflow?\n                 let (val, _) = self.binary_op(op, old, ty, change, ty)?;\n-                self.write_primval(Place::from_primval_ptr(ptr, dest_layout.align), val, ty)?;\n+                self.write_scalar(Place::from_scalar_ptr(ptr, dest_layout.align), val, ty)?;\n             }\n \n             \"breakpoint\" => unimplemented!(), // halt miri\n@@ -233,8 +235,11 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {\n                 let ty = substs.type_at(0);\n-                let num = self.value_to_primval(args[0])?.to_bytes()?;\n-                let kind = self.ty_to_primval_kind(ty)?;\n+                let num = self.value_to_scalar(args[0])?.to_bytes()?;\n+                let kind = match self.layout_of(ty)?.abi {\n+                    ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n+                    _ => Err(::rustc::mir::interpret::EvalErrorKind::TypeNotPrimitive(ty))?,\n+                };\n                 let num = if intrinsic_name.ends_with(\"_nonzero\") {\n                     if num == 0 {\n                         return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n@@ -243,21 +248,21 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 } else {\n                     numeric_intrinsic(intrinsic_name, num, kind)?\n                 };\n-                self.write_primval(dest, num, ty)?;\n+                self.write_scalar(dest, num, ty)?;\n             }\n \n             \"discriminant_value\" => {\n                 let ty = substs.type_at(0);\n                 let adt_ptr = self.into_ptr(args[0].value)?;\n                 let adt_align = self.layout_of(args[0].ty)?.align;\n-                let place = Place::from_primval_ptr(adt_ptr, adt_align);\n+                let place = Place::from_scalar_ptr(adt_ptr, adt_align);\n                 let discr_val = self.read_discriminant_value(place, ty)?;\n-                self.write_primval(dest, PrimVal::Bytes(discr_val), dest_layout.ty)?;\n+                self.write_scalar(dest, Scalar::from_u128(discr_val), dest_layout.ty)?;\n             }\n \n             \"sinf32\" | \"fabsf32\" | \"cosf32\" | \"sqrtf32\" | \"expf32\" | \"exp2f32\" | \"logf32\" |\n             \"log10f32\" | \"log2f32\" | \"floorf32\" | \"ceilf32\" | \"truncf32\" => {\n-                let f = self.value_to_primval(args[0])?.to_bytes()?;\n+                let f = self.value_to_scalar(args[0])?.to_bytes()?;\n                 let f = f32::from_bits(f as u32);\n                 let f = match intrinsic_name {\n                     \"sinf32\" => f.sin(),\n@@ -274,12 +279,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     \"truncf32\" => f.trunc(),\n                     _ => bug!(),\n                 };\n-                self.write_primval(dest, PrimVal::Bytes(f.to_bits() as u128), dest_layout.ty)?;\n+                self.write_scalar(dest, Scalar::from_f32(f), dest_layout.ty)?;\n             }\n \n             \"sinf64\" | \"fabsf64\" | \"cosf64\" | \"sqrtf64\" | \"expf64\" | \"exp2f64\" | \"logf64\" |\n             \"log10f64\" | \"log2f64\" | \"floorf64\" | \"ceilf64\" | \"truncf64\" => {\n-                let f = self.value_to_primval(args[0])?.to_bytes()?;\n+                let f = self.value_to_scalar(args[0])?.to_bytes()?;\n                 let f = f64::from_bits(f as u64);\n                 let f = match intrinsic_name {\n                     \"sinf64\" => f.sin(),\n@@ -296,13 +301,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     \"truncf64\" => f.trunc(),\n                     _ => bug!(),\n                 };\n-                self.write_primval(dest, PrimVal::Bytes(f.to_bits() as u128), dest_layout.ty)?;\n+                self.write_scalar(dest, Scalar::from_f64(f), dest_layout.ty)?;\n             }\n \n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n                 let ty = substs.type_at(0);\n-                let a = self.value_to_primval(args[0])?;\n-                let b = self.value_to_primval(args[1])?;\n+                let a = self.value_to_scalar(args[0])?;\n+                let b = self.value_to_scalar(args[1])?;\n                 let op = match intrinsic_name {\n                     \"fadd_fast\" => mir::BinOp::Add,\n                     \"fsub_fast\" => mir::BinOp::Sub,\n@@ -312,21 +317,21 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                     _ => bug!(),\n                 };\n                 let result = self.binary_op(op, a, ty, b, ty)?;\n-                self.write_primval(dest, result.0, dest_layout.ty)?;\n+                self.write_scalar(dest, result.0, dest_layout.ty)?;\n             }\n \n             \"exact_div\" => {\n                 // Performs an exact division, resulting in undefined behavior where\n                 // `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n                 let ty = substs.type_at(0);\n-                let a = self.value_to_primval(args[0])?;\n-                let b = self.value_to_primval(args[1])?;\n+                let a = self.value_to_scalar(args[0])?;\n+                let b = self.value_to_scalar(args[1])?;\n                 // check x % y != 0\n-                if self.binary_op(mir::BinOp::Rem, a, ty, b, ty)?.0 != PrimVal::Bytes(0) {\n+                if self.binary_op(mir::BinOp::Rem, a, ty, b, ty)?.0 != Scalar::null() {\n                     return err!(ValidationFailure(format!(\"exact_div: {:?} cannot be divided by {:?}\", a, b)));\n                 }\n                 let result = self.binary_op(mir::BinOp::Div, a, ty, b, ty)?;\n-                self.write_primval(dest, result.0, dest_layout.ty)?;\n+                self.write_scalar(dest, result.0, dest_layout.ty)?;\n             },\n \n             \"likely\" | \"unlikely\" | \"forget\" => {}\n@@ -341,21 +346,21 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                             val\n                         }\n                         // TODO(solson): Revisit this, it's fishy to check for Undef here.\n-                        Value::ByVal(PrimVal::Undef) => {\n-                            match this.ty_to_primval_kind(dest_layout.ty) {\n-                                Ok(_) => Value::ByVal(PrimVal::Bytes(0)),\n-                                Err(_) => {\n+                        Value::Scalar(Scalar::Bits { defined: 0, .. }) => {\n+                            match this.layout_of(dest_layout.ty)?.abi {\n+                                ty::layout::Abi::Scalar(_) => Value::Scalar(Scalar::null()),\n+                                _ => {\n                                     // FIXME(oli-obk): pass TyLayout to alloc_ptr instead of Ty\n                                     let ptr = this.alloc_ptr(dest_layout.ty)?;\n-                                    let ptr = Pointer::from(PrimVal::Ptr(ptr));\n+                                    let ptr = Scalar::Ptr(ptr);\n                                     this.memory.write_repeat(ptr, 0, size)?;\n                                     Value::ByRef(ptr, dest_layout.align)\n                                 }\n                             }\n                         }\n-                        Value::ByVal(_) => Value::ByVal(PrimVal::Bytes(0)),\n-                        Value::ByValPair(..) => {\n-                            Value::ByValPair(PrimVal::Bytes(0), PrimVal::Bytes(0))\n+                        Value::Scalar(_) => Value::Scalar(Scalar::null()),\n+                        Value::ScalarPair(..) => {\n+                            Value::ScalarPair(Scalar::null(), Scalar::null())\n                         }\n                     };\n                     Ok(zero_val)\n@@ -376,16 +381,16 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_align = self.layout_of(elem_ty)?.align.abi();\n-                let align_val = PrimVal::from_u128(elem_align as u128);\n-                self.write_primval(dest, align_val, dest_layout.ty)?;\n+                let align_val = Scalar::from_u128(elem_align as u128);\n+                self.write_scalar(dest, align_val, dest_layout.ty)?;\n             }\n \n             \"pref_align_of\" => {\n                 let ty = substs.type_at(0);\n                 let layout = self.layout_of(ty)?;\n                 let align = layout.align.pref();\n-                let align_val = PrimVal::from_u128(align as u128);\n-                self.write_primval(dest, align_val, dest_layout.ty)?;\n+                let align_val = Scalar::from_u128(align as u128);\n+                self.write_scalar(dest, align_val, dest_layout.ty)?;\n             }\n \n             \"move_val_init\" => {\n@@ -399,9 +404,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let ty = substs.type_at(0);\n                 let env = ty::ParamEnv::reveal_all();\n                 let needs_drop = ty.needs_drop(self.tcx.tcx, env);\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::from_bool(needs_drop),\n+                    Scalar::from_bool(needs_drop),\n                     dest_layout.ty,\n                 )?;\n             }\n@@ -444,91 +449,91 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             }\n \n             \"powf32\" => {\n-                let f = self.value_to_primval(args[0])?.to_bytes()?;\n+                let f = self.value_to_scalar(args[0])?.to_bits(Size::from_bits(32))?;\n                 let f = f32::from_bits(f as u32);\n-                let f2 = self.value_to_primval(args[1])?.to_bytes()?;\n+                let f2 = self.value_to_scalar(args[1])?.to_bits(Size::from_bits(32))?;\n                 let f2 = f32::from_bits(f2 as u32);\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes(f.powf(f2).to_bits() as u128),\n+                    Scalar::from_f32(f.powf(f2)),\n                     dest_layout.ty,\n                 )?;\n             }\n \n             \"powf64\" => {\n-                let f = self.value_to_primval(args[0])?.to_bytes()?;\n+                let f = self.value_to_scalar(args[0])?.to_bits(Size::from_bits(64))?;\n                 let f = f64::from_bits(f as u64);\n-                let f2 = self.value_to_primval(args[1])?.to_bytes()?;\n+                let f2 = self.value_to_scalar(args[1])?.to_bits(Size::from_bits(64))?;\n                 let f2 = f64::from_bits(f2 as u64);\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes(f.powf(f2).to_bits() as u128),\n+                    Scalar::from_f64(f.powf(f2)),\n                     dest_layout.ty,\n                 )?;\n             }\n \n             \"fmaf32\" => {\n-                let a = self.value_to_primval(args[0])?.to_bytes()?;\n+                let a = self.value_to_scalar(args[0])?.to_bits(Size::from_bits(32))?;\n                 let a = f32::from_bits(a as u32);\n-                let b = self.value_to_primval(args[1])?.to_bytes()?;\n+                let b = self.value_to_scalar(args[1])?.to_bits(Size::from_bits(32))?;\n                 let b = f32::from_bits(b as u32);\n-                let c = self.value_to_primval(args[2])?.to_bytes()?;\n+                let c = self.value_to_scalar(args[2])?.to_bits(Size::from_bits(32))?;\n                 let c = f32::from_bits(c as u32);\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes((a * b + c).to_bits() as u128),\n+                    Scalar::from_f32(a * b + c),\n                     dest_layout.ty,\n                 )?;\n             }\n \n             \"fmaf64\" => {\n-                let a = self.value_to_primval(args[0])?.to_bytes()?;\n+                let a = self.value_to_scalar(args[0])?.to_bits(Size::from_bits(64))?;\n                 let a = f64::from_bits(a as u64);\n-                let b = self.value_to_primval(args[1])?.to_bytes()?;\n+                let b = self.value_to_scalar(args[1])?.to_bits(Size::from_bits(64))?;\n                 let b = f64::from_bits(b as u64);\n-                let c = self.value_to_primval(args[2])?.to_bytes()?;\n+                let c = self.value_to_scalar(args[2])?.to_bits(Size::from_bits(64))?;\n                 let c = f64::from_bits(c as u64);\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes((a * b + c).to_bits() as u128),\n+                    Scalar::from_f64(a * b + c),\n                     dest_layout.ty,\n                 )?;\n             }\n \n             \"powif32\" => {\n-                let f = self.value_to_primval(args[0])?.to_bytes()?;\n+                let f = self.value_to_scalar(args[0])?.to_bits(Size::from_bits(32))?;\n                 let f = f32::from_bits(f as u32);\n                 let i = self.value_to_i32(args[1])?;\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes(f.powi(i).to_bits() as u128),\n+                    Scalar::from_f32(f.powi(i)),\n                     dest_layout.ty,\n                 )?;\n             }\n \n             \"powif64\" => {\n-                let f = self.value_to_primval(args[0])?.to_bytes()?;\n+                let f = self.value_to_scalar(args[0])?.to_bits(Size::from_bits(64))?;\n                 let f = f64::from_bits(f as u64);\n                 let i = self.value_to_i32(args[1])?;\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::Bytes(f.powi(i).to_bits() as u128),\n+                    Scalar::from_f64(f.powi(i)),\n                     dest_layout.ty,\n                 )?;\n             }\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n                 let size = self.layout_of(ty)?.size.bytes().into();\n-                self.write_primval(dest, PrimVal::from_u128(size), dest_layout.ty)?;\n+                self.write_scalar(dest, Scalar::from_u128(size), dest_layout.ty)?;\n             }\n \n             \"size_of_val\" => {\n                 let ty = substs.type_at(0);\n                 let (size, _) = self.size_and_align_of_dst(ty, args[0].value)?;\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::from_u128(size.bytes() as u128),\n+                    Scalar::from_u128(size.bytes() as u128),\n                     dest_layout.ty,\n                 )?;\n             }\n@@ -537,9 +542,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"align_of_val\" => {\n                 let ty = substs.type_at(0);\n                 let (_, align) = self.size_and_align_of_dst(ty, args[0].value)?;\n-                self.write_primval(\n+                self.write_scalar(\n                     dest,\n-                    PrimVal::from_u128(align.abi() as u128),\n+                    Scalar::from_u128(align.abi() as u128),\n                     dest_layout.ty,\n                 )?;\n             }\n@@ -553,7 +558,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let n = self.tcx.type_id_hash(ty);\n-                self.write_primval(dest, PrimVal::Bytes(n as u128), dest_layout.ty)?;\n+                self.write_scalar(dest, Scalar::Bits { bits: n as u128, defined: 64 }, dest_layout.ty)?;\n             }\n \n             \"transmute\" => {\n@@ -566,7 +571,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             \"unchecked_shl\" => {\n                 let bits = dest_layout.size.bytes() as u128 * 8;\n-                let rhs = self.value_to_primval(args[1])?\n+                let rhs = self.value_to_scalar(args[1])?\n                     .to_bytes()?;\n                 if rhs >= bits {\n                     return err!(Intrinsic(\n@@ -584,7 +589,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n \n             \"unchecked_shr\" => {\n                 let bits = dest_layout.size.bytes() as u128 * 8;\n-                let rhs = self.value_to_primval(args[1])?\n+                let rhs = self.value_to_scalar(args[1])?\n                     .to_bytes()?;\n                 if rhs >= bits {\n                     return err!(Intrinsic(\n@@ -601,7 +606,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             }\n \n             \"unchecked_div\" => {\n-                let rhs = self.value_to_primval(args[1])?\n+                let rhs = self.value_to_scalar(args[1])?\n                     .to_bytes()?;\n                 if rhs == 0 {\n                     return err!(Intrinsic(format!(\"Division by 0 in unchecked_div\")));\n@@ -616,7 +621,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             }\n \n             \"unchecked_rem\" => {\n-                let rhs = self.value_to_primval(args[1])?\n+                let rhs = self.value_to_scalar(args[1])?\n                     .to_bytes()?;\n                 if rhs == 0 {\n                     return err!(Intrinsic(format!(\"Division by 0 in unchecked_rem\")));\n@@ -637,7 +642,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                         this.memory.mark_definedness(ptr, size, false)?;\n                         Ok(val)\n                     }\n-                    _ => Ok(Value::ByVal(PrimVal::Undef)),\n+                    _ => Ok(Value::Scalar(Scalar::undef())),\n                 };\n                 match dest {\n                     Place::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n@@ -681,26 +686,25 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n fn numeric_intrinsic<'tcx>(\n     name: &str,\n     bytes: u128,\n-    kind: PrimValKind,\n-) -> EvalResult<'tcx, PrimVal> {\n+    kind: Primitive,\n+) -> EvalResult<'tcx, Scalar> {\n     macro_rules! integer_intrinsic {\n         ($method:ident) => ({\n-            use rustc::mir::interpret::PrimValKind::*;\n             let result_bytes = match kind {\n-                I8 => (bytes as i8).$method() as u128,\n-                U8 => (bytes as u8).$method() as u128,\n-                I16 => (bytes as i16).$method() as u128,\n-                U16 => (bytes as u16).$method() as u128,\n-                I32 => (bytes as i32).$method() as u128,\n-                U32 => (bytes as u32).$method() as u128,\n-                I64 => (bytes as i64).$method() as u128,\n-                U64 => (bytes as u64).$method() as u128,\n-                I128 => (bytes as i128).$method() as u128,\n-                U128 => bytes.$method() as u128,\n+                Primitive::Int(I8, true) => (bytes as i8).$method() as u128,\n+                Primitive::Int(I8, false) => (bytes as u8).$method() as u128,\n+                Primitive::Int(I16, true) => (bytes as i16).$method() as u128,\n+                Primitive::Int(I16, false) => (bytes as u16).$method() as u128,\n+                Primitive::Int(I32, true) => (bytes as i32).$method() as u128,\n+                Primitive::Int(I32, false) => (bytes as u32).$method() as u128,\n+                Primitive::Int(I64, true) => (bytes as i64).$method() as u128,\n+                Primitive::Int(I64, false) => (bytes as u64).$method() as u128,\n+                Primitive::Int(I128, true) => (bytes as i128).$method() as u128,\n+                Primitive::Int(I128, false) => bytes.$method() as u128,\n                 _ => bug!(\"invalid `{}` argument: {:?}\", name, bytes),\n             };\n \n-            PrimVal::Bytes(result_bytes)\n+            Scalar::from_u128(result_bytes)\n         });\n     }\n "}, {"sha": "e3c83c284db998b668a59f79c7c2fb5f6028206f", "filename": "src/lib.rs", "status": "modified", "additions": 90, "deletions": 14, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4143922d1d613154ad2c3369b3e2c6a6fd4ef35e", "patch": "@@ -53,6 +53,81 @@ use validation::EvalContextExt as ValidationEvalContextExt;\n use range_map::RangeMap;\n use validation::{ValidationQuery, AbsPlace};\n \n+pub trait ScalarExt {\n+    fn null() -> Self;\n+    fn from_i8(i: i8) -> Self;\n+    fn from_u128(i: u128) -> Self;\n+    fn from_i128(i: i128) -> Self;\n+    fn from_usize(i: u64, ptr_size: Size) -> Self;\n+    fn from_isize(i: i64, ptr_size: Size) -> Self;\n+    fn from_f32(f: f32) -> Self;\n+    fn from_f64(f: f64) -> Self;\n+    fn to_u64(self) -> EvalResult<'static, u64>;\n+    fn is_null(self) -> EvalResult<'static, bool>;\n+    fn to_bytes(self) -> EvalResult<'static, u128>;\n+}\n+\n+impl ScalarExt for Scalar {\n+    fn null() -> Self {\n+        Scalar::Bits { bits: 0, defined: 128 }\n+    }\n+\n+    fn from_i8(i: i8) -> Self {\n+        Scalar::Bits { bits: i as i128 as u128, defined: 8 }\n+    }\n+\n+    fn from_u128(i: u128) -> Self {\n+        Scalar::Bits { bits: i, defined: 128 }\n+    }\n+\n+    fn from_i128(i: i128) -> Self {\n+        Scalar::Bits { bits: i as u128, defined: 128 }\n+    }\n+\n+    fn from_usize(i: u64, ptr_size: Size) -> Self {\n+        Scalar::Bits { bits: i as u128, defined: ptr_size.bits() as u8 }\n+    }\n+\n+    fn from_isize(i: i64, ptr_size: Size) -> Self {\n+        Scalar::Bits { bits: i as i128 as u128, defined: ptr_size.bits() as u8 }\n+    }\n+\n+    fn from_f32(f: f32) -> Self {\n+        Scalar::Bits { bits: f.to_bits() as u128, defined: 32 }\n+    }\n+\n+    fn from_f64(f: f64) -> Self {\n+        Scalar::Bits { bits: f.to_bits() as u128, defined: 64 }\n+    }\n+\n+    fn to_u64(self) -> EvalResult<'static, u64> {\n+        let b = self.to_bits(Size::from_bits(64))?;\n+        assert_eq!(b as u64 as u128, b);\n+        Ok(b as u64)\n+    }\n+\n+    fn is_null(self) -> EvalResult<'static, bool> {\n+        match self {\n+            Scalar::Bits { bits, defined } => {\n+                if defined > 0 {\n+                    Ok(bits == 0)\n+                } else {\n+                    err!(ReadUndefBytes)\n+                }\n+            }\n+            Scalar::Ptr(_) => Ok(false)\n+        }\n+    }\n+\n+    fn to_bytes(self) -> EvalResult<'static, u128> {\n+        match self {\n+            Scalar::Bits { defined: 0, .. } => err!(ReadUndefBytes),\n+            Scalar::Bits { bits, .. } => Ok(bits),\n+            Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n+        }\n+    }\n+}\n+\n pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n@@ -65,7 +140,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     ) -> EvalResult<'tcx> {\n         let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n         let main_mir = ecx.load_mir(main_instance.def)?;\n-        let mut cleanup_ptr = None; // Pointer to be deallocated when we are done\n+        let mut cleanup_ptr = None; // Scalar to be deallocated when we are done\n \n         if !main_mir.return_ty().is_nil() || main_mir.arg_count != 0 {\n             return err!(Unimplemented(\n@@ -116,7 +191,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             let main_ptr_ty = ecx.tcx.mk_fn_ptr(main_ty.fn_sig(ecx.tcx.tcx));\n             ecx.write_value(\n                 ValTy {\n-                    value: Value::ByVal(PrimVal::Ptr(main_ptr)),\n+                    value: Value::Scalar(Scalar::Ptr(main_ptr)),\n                     ty: main_ptr_ty,\n                 },\n                 dest,\n@@ -125,7 +200,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             // Second argument (argc): 1\n             let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n             let ty = ecx.tcx.types.isize;\n-            ecx.write_primval(dest, PrimVal::Bytes(1), ty)?;\n+            ecx.write_scalar(dest, Scalar::from_u128(1), ty)?;\n \n             // FIXME: extract main source file path\n             // Third argument (argv): &[b\"foo\"]\n@@ -135,7 +210,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             let ptr_size = ecx.memory.pointer_size();\n             let ptr_align = ecx.tcx.data_layout.pointer_align;\n             let foo_ptr = ecx.memory.allocate(ptr_size, ptr_align, None)?;\n-            ecx.memory.write_primval(foo_ptr.into(), ptr_align, PrimVal::Ptr(foo.into()), ptr_size, false)?;\n+            ecx.memory.write_scalar(foo_ptr.into(), ptr_align, Scalar::Ptr(foo), ptr_size, false)?;\n             ecx.memory.mark_static_initialized(foo_ptr.alloc_id, Mutability::Immutable)?;\n             ecx.write_ptr(dest, foo_ptr.into(), ty)?;\n \n@@ -145,7 +220,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 main_instance,\n                 main_mir.span,\n                 main_mir,\n-                Place::from_primval_ptr(PrimVal::Bytes(1).into(), ty::layout::Align::from_bytes(1, 1).unwrap()),\n+                Place::from_scalar_ptr(Scalar::from_u128(1), ty::layout::Align::from_bytes(1, 1).unwrap()),\n                 StackPopCleanup::None,\n             )?;\n \n@@ -187,6 +262,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                     }\n                 }\n             }\n+            ::std::process::exit(1);\n         }\n     }\n }\n@@ -195,7 +271,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n pub struct Evaluator<'tcx> {\n     /// Environment variables set by `setenv`\n     /// Miri does not expose env vars from the host to the emulated program\n-    pub(crate) env_vars: HashMap<Vec<u8>, MemoryPointer>,\n+    pub(crate) env_vars: HashMap<Vec<u8>, Pointer>,\n \n     /// Places that were suspended by the validation subsystem, and will be recovered later\n     pub(crate) suspended: HashMap<DynamicLifetime, Vec<ValidationQuery<'tcx>>>,\n@@ -205,7 +281,7 @@ pub type TlsKey = usize;\n \n #[derive(Copy, Clone, Debug)]\n pub struct TlsEntry<'tcx> {\n-    data: Pointer, // Will eventually become a map from thread IDs to `Pointer`s, if we ever support more than one thread.\n+    data: Scalar, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n     dtor: Option<ty::Instance<'tcx>>,\n }\n \n@@ -256,11 +332,11 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     fn try_ptr_op<'a>(\n         ecx: &rustc_mir::interpret::EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n-        left: PrimVal,\n+        left: Scalar,\n         left_ty: ty::Ty<'tcx>,\n-        right: PrimVal,\n+        right: Scalar,\n         right_ty: ty::Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n+    ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n         ecx.ptr_op(bin_op, left, left_ty, right, right_ty)\n     }\n \n@@ -372,7 +448,7 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n         ecx.write_value(\n             ValTy {\n-                value: Value::ByVal(PrimVal::Bytes(match layout.size.bytes() {\n+                value: Value::Scalar(Scalar::from_u128(match layout.size.bytes() {\n                     0 => 1 as u128,\n                     size => size as u128,\n                 }.into())),\n@@ -385,7 +461,7 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n         ecx.write_value(\n             ValTy {\n-                value: Value::ByVal(PrimVal::Bytes(layout.align.abi().into())),\n+                value: Value::Scalar(Scalar::from_u128(layout.align.abi().into())),\n                 ty: usize,\n             },\n             dest,\n@@ -406,7 +482,7 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n \n     fn check_locks<'a>(\n         mem: &Memory<'a, 'mir, 'tcx, Self>,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         size: Size,\n         access: AccessKind,\n     ) -> EvalResult<'tcx> {\n@@ -437,7 +513,7 @@ impl<'mir, 'tcx: 'mir> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n             .map_err(|lock| {\n                 EvalErrorKind::DeallocatedLockedMemory {\n                     //ptr, FIXME\n-                    ptr: MemoryPointer {\n+                    ptr: Pointer {\n                         alloc_id: AllocId(0),\n                         offset: Size::from_bytes(0),\n                     },"}, {"sha": "a463f8ba575e829ed02440a0e1cf49dfddd10c79", "filename": "src/locks.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Flocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Flocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flocks.rs?ref=4143922d1d613154ad2c3369b3e2c6a6fd4ef35e", "patch": "@@ -70,27 +70,27 @@ impl<'tcx> LockInfo<'tcx> {\n pub trait MemoryExt<'tcx> {\n     fn check_locks(\n         &self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         access: AccessKind,\n     ) -> EvalResult<'tcx>;\n     fn acquire_lock(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         region: Option<region::Scope>,\n         kind: AccessKind,\n     ) -> EvalResult<'tcx>;\n     fn suspend_write_lock(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         lock_path: &AbsPlace<'tcx>,\n         suspend: Option<region::Scope>,\n     ) -> EvalResult<'tcx>;\n     fn recover_write_lock(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         lock_path: &AbsPlace<'tcx>,\n         lock_region: Option<region::Scope>,\n@@ -103,7 +103,7 @@ pub trait MemoryExt<'tcx> {\n impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evaluator<'tcx>> {\n     fn check_locks(\n         &self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         access: AccessKind,\n     ) -> EvalResult<'tcx> {\n@@ -132,7 +132,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n     /// Acquire the lock for the given lifetime\n     fn acquire_lock(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         region: Option<region::Scope>,\n         kind: AccessKind,\n@@ -191,7 +191,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n     /// When suspending, the same cases are fine; we just register an additional suspension.\n     fn suspend_write_lock(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         lock_path: &AbsPlace<'tcx>,\n         suspend: Option<region::Scope>,\n@@ -264,7 +264,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n     /// Release a suspension from the write lock.  If this is the last suspension or if there is no suspension, acquire the lock.\n     fn recover_write_lock(\n         &mut self,\n-        ptr: MemoryPointer,\n+        ptr: Pointer,\n         len: u64,\n         lock_path: &AbsPlace<'tcx>,\n         lock_region: Option<region::Scope>,"}, {"sha": "721b4f0bfddabfac5b1138ddf5ced28b769870aa", "filename": "src/operator.rs", "status": "modified", "additions": 61, "deletions": 40, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=4143922d1d613154ad2c3369b3e2c6a6fd4ef35e", "patch": "@@ -1,4 +1,5 @@\n use rustc::ty;\n+use rustc::ty::layout::Primitive;\n use rustc::mir;\n \n use super::*;\n@@ -9,74 +10,94 @@ pub trait EvalContextExt<'tcx> {\n     fn ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: PrimVal,\n+        left: Scalar,\n         left_ty: ty::Ty<'tcx>,\n-        right: PrimVal,\n+        right: Scalar,\n         right_ty: ty::Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>>;\n+    ) -> EvalResult<'tcx, Option<(Scalar, bool)>>;\n \n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,\n-        left: MemoryPointer,\n+        left: Pointer,\n         right: i128,\n         signed: bool,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)>;\n+    ) -> EvalResult<'tcx, (Scalar, bool)>;\n }\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super::Evaluator<'tcx>> {\n     fn ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: PrimVal,\n+        left: Scalar,\n         left_ty: ty::Ty<'tcx>,\n-        right: PrimVal,\n+        right: Scalar,\n         right_ty: ty::Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(PrimVal, bool)>> {\n-        use rustc::mir::interpret::PrimValKind::*;\n+    ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n         use rustc::mir::BinOp::*;\n-        let usize = PrimValKind::from_uint_size(self.memory.pointer_size());\n-        let isize = PrimValKind::from_int_size(self.memory.pointer_size());\n-        let left_kind = self.ty_to_primval_kind(left_ty)?;\n-        let right_kind = self.ty_to_primval_kind(right_ty)?;\n+        use rustc::ty::layout::Integer::*;\n+        let usize = Primitive::Int(match self.memory.pointer_size().bytes() {\n+            1 => I8,\n+            2 => I16,\n+            4 => I32,\n+            8 => I64,\n+            16 => I128,\n+            _ => unreachable!(),\n+        }, false);\n+        let isize = Primitive::Int(match self.memory.pointer_size().bytes() {\n+            1 => I8,\n+            2 => I16,\n+            4 => I32,\n+            8 => I64,\n+            16 => I128,\n+            _ => unreachable!(),\n+        }, true);\n+        let left_kind = match self.layout_of(left_ty)?.abi {\n+            ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n+            _ => Err(EvalErrorKind::TypeNotPrimitive(left_ty))?,\n+        };\n+        let right_kind = match self.layout_of(right_ty)?.abi {\n+            ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n+            _ => Err(EvalErrorKind::TypeNotPrimitive(right_ty))?,\n+        };\n         match bin_op {\n-            Offset if left_kind == Ptr && right_kind == usize => {\n+            Offset if left_kind == Primitive::Pointer && right_kind == usize => {\n                 let pointee_ty = left_ty\n                     .builtin_deref(true)\n                     .expect(\"Offset called on non-ptr type\")\n                     .ty;\n                 let ptr = self.pointer_offset(\n                     left.into(),\n                     pointee_ty,\n-                    right.to_bytes()? as i64,\n+                    right.to_bits(self.memory.pointer_size())? as i64,\n                 )?;\n-                Ok(Some((ptr.into_inner_primval(), false)))\n+                Ok(Some((ptr, false)))\n             }\n             // These work on anything\n             Eq if left_kind == right_kind => {\n                 let result = match (left, right) {\n-                    (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left == right,\n-                    (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left == right,\n-                    (PrimVal::Undef, _) |\n-                    (_, PrimVal::Undef) => return err!(ReadUndefBytes),\n+                    (Scalar::Bits { .. }, Scalar::Bits { .. }) => {\n+                        left.to_bits(self.memory.pointer_size())? == right.to_bits(self.memory.pointer_size())?\n+                    },\n+                    (Scalar::Ptr(left), Scalar::Ptr(right)) => left == right,\n                     _ => false,\n                 };\n-                Ok(Some((PrimVal::from_bool(result), false)))\n+                Ok(Some((Scalar::from_bool(result), false)))\n             }\n             Ne if left_kind == right_kind => {\n                 let result = match (left, right) {\n-                    (PrimVal::Bytes(left), PrimVal::Bytes(right)) => left != right,\n-                    (PrimVal::Ptr(left), PrimVal::Ptr(right)) => left != right,\n-                    (PrimVal::Undef, _) |\n-                    (_, PrimVal::Undef) => return err!(ReadUndefBytes),\n+                    (Scalar::Bits { .. }, Scalar::Bits { .. }) => {\n+                        left.to_bits(self.memory.pointer_size())? != right.to_bits(self.memory.pointer_size())?\n+                    },\n+                    (Scalar::Ptr(left), Scalar::Ptr(right)) => left != right,\n                     _ => true,\n                 };\n-                Ok(Some((PrimVal::from_bool(result), false)))\n+                Ok(Some((Scalar::from_bool(result), false)))\n             }\n             // These need both pointers to be in the same allocation\n             Lt | Le | Gt | Ge | Sub\n                 if left_kind == right_kind &&\n-                       (left_kind == Ptr || left_kind == usize || left_kind == isize) &&\n+                       (left_kind == Primitive::Pointer || left_kind == usize || left_kind == isize) &&\n                        left.is_ptr() && right.is_ptr() => {\n                 let left = left.to_ptr()?;\n                 let right = right.to_ptr()?;\n@@ -89,15 +110,15 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                         Sub => {\n                             return self.binary_op(\n                                 Sub,\n-                                PrimVal::Bytes(left.offset.bytes() as u128),\n+                                Scalar::Bits { bits: left.offset.bytes() as u128, defined: self.memory.pointer_size().bits() as u8 },\n                                 self.tcx.types.usize,\n-                                PrimVal::Bytes(right.offset.bytes() as u128),\n+                                Scalar::Bits { bits: right.offset.bytes() as u128, defined: self.memory.pointer_size().bits() as u8 },\n                                 self.tcx.types.usize,\n                             ).map(Some)\n                         }\n                         _ => bug!(\"We already established it has to be one of these operators.\"),\n                     };\n-                    Ok(Some((PrimVal::from_bool(res), false)))\n+                    Ok(Some((Scalar::from_bool(res), false)))\n                 } else {\n                     // Both are pointers, but from different allocations.\n                     err!(InvalidPointerMath)\n@@ -106,23 +127,23 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             // These work if one operand is a pointer, the other an integer\n             Add | BitAnd | Sub\n                 if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n-                       left.is_ptr() && right.is_bytes() => {\n+                       left.is_ptr() && right.is_bits() => {\n                 // Cast to i128 is fine as we checked the kind to be ptr-sized\n                 self.ptr_int_arithmetic(\n                     bin_op,\n                     left.to_ptr()?,\n-                    right.to_bytes()? as i128,\n+                    right.to_bits(self.memory.pointer_size())? as i128,\n                     left_kind == isize,\n                 ).map(Some)\n             }\n             Add | BitAnd\n                 if left_kind == right_kind && (left_kind == usize || left_kind == isize) &&\n-                       left.is_bytes() && right.is_ptr() => {\n+                       left.is_bits() && right.is_ptr() => {\n                 // This is a commutative operation, just swap the operands\n                 self.ptr_int_arithmetic(\n                     bin_op,\n                     right.to_ptr()?,\n-                    left.to_bytes()? as i128,\n+                    left.to_bits(self.memory.pointer_size())? as i128,\n                     left_kind == isize,\n                 ).map(Some)\n             }\n@@ -133,14 +154,14 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,\n-        left: MemoryPointer,\n+        left: Pointer,\n         right: i128,\n         signed: bool,\n-    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n         use rustc::mir::BinOp::*;\n \n-        fn map_to_primval((res, over): (MemoryPointer, bool)) -> (PrimVal, bool) {\n-            (PrimVal::Ptr(res), over)\n+        fn map_to_primval((res, over): (Pointer, bool)) -> (Scalar, bool) {\n+            (Scalar::Ptr(res), over)\n         }\n \n         Ok(match bin_op {\n@@ -157,10 +178,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 let right = right as u64;\n                 if right & base_mask == base_mask {\n                     // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n-                    (PrimVal::Ptr(MemoryPointer::new(left.alloc_id, Size::from_bytes(left.offset.bytes() & right))), false)\n+                    (Scalar::Ptr(Pointer::new(left.alloc_id, Size::from_bytes(left.offset.bytes() & right))), false)\n                 } else if right & base_mask == 0 {\n                     // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n-                    (PrimVal::from_u128((left.offset.bytes() & right) as u128), false)\n+                    (Scalar::Bits { bits: (left.offset.bytes() & right) as u128, defined: 128 }, false)\n                 } else {\n                     return err!(ReadPointerAsBytes);\n                 }"}, {"sha": "7f49509ef42ea1135a631fce5b45beabb843065d", "filename": "src/tls.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=4143922d1d613154ad2c3369b3e2c6a6fd4ef35e", "patch": "@@ -1,17 +1,17 @@\n use rustc::{ty, mir};\n \n-use super::{TlsKey, TlsEntry, EvalResult, EvalErrorKind, Pointer, Memory, Evaluator, Place,\n-            StackPopCleanup, EvalContext};\n+use super::{TlsKey, TlsEntry, EvalResult, EvalErrorKind, Scalar, ScalarExt, Memory, Evaluator,\n+            Place, StackPopCleanup, EvalContext};\n \n pub trait MemoryExt<'tcx> {\n     fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey;\n     fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx>;\n-    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer>;\n-    fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx>;\n+    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar>;\n+    fn store_tls(&mut self, key: TlsKey, new_data: Scalar) -> EvalResult<'tcx>;\n     fn fetch_tls_dtor(\n         &mut self,\n         key: Option<TlsKey>,\n-    ) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>>;\n+    ) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Scalar, TlsKey)>>;\n }\n \n pub trait EvalContextExt<'tcx> {\n@@ -25,7 +25,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n         self.data.thread_local.insert(\n             new_key,\n             TlsEntry {\n-                data: Pointer::null(),\n+                data: Scalar::null(),\n                 dtor,\n             },\n         );\n@@ -43,7 +43,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n         };\n     }\n \n-    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n+    fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar> {\n         return match self.data.thread_local.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n@@ -53,7 +53,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n         };\n     }\n \n-    fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n+    fn store_tls(&mut self, key: TlsKey, new_data: Scalar) -> EvalResult<'tcx> {\n         return match self.data.thread_local.get_mut(&key) {\n             Some(&mut TlsEntry { ref mut data, .. }) => {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n@@ -85,19 +85,21 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> MemoryExt<'tcx> for Memory<'a, 'mir, 'tcx, Evalu\n     fn fetch_tls_dtor(\n         &mut self,\n         key: Option<TlsKey>,\n-    ) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Pointer, TlsKey)>> {\n+    ) -> EvalResult<'tcx, Option<(ty::Instance<'tcx>, Scalar, TlsKey)>> {\n         use std::collections::Bound::*;\n+\n+        let thread_local = &mut self.data.thread_local;\n         let start = match key {\n             Some(key) => Excluded(key),\n             None => Unbounded,\n         };\n         for (&key, &mut TlsEntry { ref mut data, dtor }) in\n-            self.data.thread_local.range_mut((start, Unbounded))\n+            thread_local.range_mut((start, Unbounded))\n         {\n             if !data.is_null()? {\n                 if let Some(dtor) = dtor {\n                     let ret = Some((dtor, *data, key));\n-                    *data = Pointer::null();\n+                    *data = Scalar::null();\n                     return Ok(ret);\n                 }\n             }"}, {"sha": "24ddffee9def612ebf26c00fc43e5ee037ccef1a", "filename": "src/validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4143922d1d613154ad2c3369b3e2c6a6fd4ef35e/src%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalidation.rs?ref=4143922d1d613154ad2c3369b3e2c6a6fd4ef35e", "patch": "@@ -12,7 +12,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_mir::interpret::HasMemory;\n \n-use super::{EvalContext, Place, PlaceExtra, ValTy};\n+use super::{EvalContext, Place, PlaceExtra, ValTy, ScalarExt};\n use rustc::mir::interpret::{DynamicLifetime, AccessKind, EvalErrorKind, Value, EvalError, EvalResult};\n use locks::MemoryExt;\n \n@@ -119,7 +119,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n             Index(v) => {\n                 let value = self.frame().get_local(v)?;\n                 let ty = self.tcx.tcx.types.usize;\n-                let n = self.value_to_primval(ValTy { value, ty })?.to_u64()?;\n+                let n = self.value_to_scalar(ValTy { value, ty })?.to_u64()?;\n                 Index(n)\n             },\n             ConstantIndex { offset, min_length, from_end } =>\n@@ -652,7 +652,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for EvalContext<'a, 'mir, '\n                 TyBool | TyFloat(_) | TyChar => {\n                     if mode.acquiring() {\n                         let val = self.read_place(query.place.1)?;\n-                        let val = self.value_to_primval(ValTy { value: val, ty: query.ty })?;\n+                        let val = self.value_to_scalar(ValTy { value: val, ty: query.ty })?;\n                         val.to_bytes()?;\n                         // TODO: Check if these are valid bool/float/codepoint/UTF-8\n                     }"}]}