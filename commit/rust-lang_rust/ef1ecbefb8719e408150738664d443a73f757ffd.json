{"sha": "ef1ecbefb8719e408150738664d443a73f757ffd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMWVjYmVmYjg3MTllNDA4MTUwNzM4NjY0ZDQ0M2E3M2Y3NTdmZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-18T04:37:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-18T04:37:01Z"}, "message": "Auto merge of #62948 - matklad:failable-file-loading, r=petrochenkov\n\nNormalize newlines when loading files\n\nFixes #62865", "tree": {"sha": "ee8573eb5d0c96c61503f605f1dc5448b333ce9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee8573eb5d0c96c61503f605f1dc5448b333ce9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef1ecbefb8719e408150738664d443a73f757ffd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef1ecbefb8719e408150738664d443a73f757ffd", "html_url": "https://github.com/rust-lang/rust/commit/ef1ecbefb8719e408150738664d443a73f757ffd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef1ecbefb8719e408150738664d443a73f757ffd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc8765d6d8623b2b5b4ca1d526ed1d7beb3fce18", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc8765d6d8623b2b5b4ca1d526ed1d7beb3fce18", "html_url": "https://github.com/rust-lang/rust/commit/fc8765d6d8623b2b5b4ca1d526ed1d7beb3fce18"}, {"sha": "911398b96cc4825798c0887ec6ebce775ff5d2d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/911398b96cc4825798c0887ec6ebce775ff5d2d1", "html_url": "https://github.com/rust-lang/rust/commit/911398b96cc4825798c0887ec6ebce775ff5d2d1"}], "stats": {"total": 206, "additions": 102, "deletions": 104}, "files": [{"sha": "afef307a0ed3702b1355a14cffa16a23c57d4f60", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef1ecbefb8719e408150738664d443a73f757ffd/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1ecbefb8719e408150738664d443a73f757ffd/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=ef1ecbefb8719e408150738664d443a73f757ffd", "patch": "@@ -352,7 +352,6 @@ impl Cursor<'_> {\n         loop {\n             match self.nth_char(0) {\n                 '\\n' => break,\n-                '\\r' if self.nth_char(1) == '\\n' => break,\n                 EOF_CHAR if self.is_eof() => break,\n                 _ => {\n                     self.bump();\n@@ -525,7 +524,6 @@ impl Cursor<'_> {\n             match self.nth_char(0) {\n                 '/' if !first => break,\n                 '\\n' if self.nth_char(1) != '\\'' => break,\n-                '\\r' if self.nth_char(1) == '\\n' => break,\n                 EOF_CHAR if self.is_eof() => break,\n                 '\\'' => {\n                     self.bump();"}, {"sha": "c709b7526082f6a3c18ba057cbed48a0bb4a0e11", "filename": "src/librustc_lexer/src/unescape.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ef1ecbefb8719e408150738664d443a73f757ffd/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1ecbefb8719e408150738664d443a73f757ffd/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs?ref=ef1ecbefb8719e408150738664d443a73f757ffd", "patch": "@@ -128,11 +128,7 @@ fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<ch\n     if first_char != '\\\\' {\n         return match first_char {\n             '\\t' | '\\n' => Err(EscapeError::EscapeOnlyChar),\n-            '\\r' => Err(if chars.clone().next() == Some('\\n') {\n-                EscapeError::EscapeOnlyChar\n-            } else {\n-                EscapeError::BareCarriageReturn\n-            }),\n+            '\\r' => Err(EscapeError::BareCarriageReturn),\n             '\\'' if mode.in_single_quotes() => Err(EscapeError::EscapeOnlyChar),\n             '\"' if mode.in_double_quotes() => Err(EscapeError::EscapeOnlyChar),\n             _ => {\n@@ -244,27 +240,15 @@ where\n \n         let unescaped_char = match first_char {\n             '\\\\' => {\n-                let (second_char, third_char) = {\n-                    let mut chars = chars.clone();\n-                    (chars.next(), chars.next())\n-                };\n-                match (second_char, third_char) {\n-                    (Some('\\n'), _) | (Some('\\r'), Some('\\n')) => {\n+                let second_char = chars.clone().next();\n+                match second_char {\n+                    Some('\\n') => {\n                         skip_ascii_whitespace(&mut chars);\n                         continue;\n                     }\n                     _ => scan_escape(first_char, &mut chars, mode),\n                 }\n             }\n-            '\\r' => {\n-                let second_char = chars.clone().next();\n-                if second_char == Some('\\n') {\n-                    chars.next();\n-                    Ok('\\n')\n-                } else {\n-                    scan_escape(first_char, &mut chars, mode)\n-                }\n-            }\n             '\\n' => Ok('\\n'),\n             '\\t' => Ok('\\t'),\n             _ => scan_escape(first_char, &mut chars, mode),\n@@ -298,15 +282,11 @@ where\n     while let Some(curr) = chars.next() {\n         let start = initial_len - chars.as_str().len() - curr.len_utf8();\n \n-        let result = match (curr, chars.clone().next()) {\n-            ('\\r', Some('\\n')) => {\n-                chars.next();\n-                Ok('\\n')\n-            },\n-            ('\\r', _) => Err(EscapeError::BareCarriageReturnInRawString),\n-            (c, _) if mode.is_bytes() && !c.is_ascii() =>\n+        let result = match curr {\n+            '\\r' => Err(EscapeError::BareCarriageReturnInRawString),\n+            c if mode.is_bytes() && !c.is_ascii() =>\n                 Err(EscapeError::NonAsciiCharInByteString),\n-            (c, _) => Ok(c),\n+            c => Ok(c),\n         };\n         let end = initial_len - chars.as_str().len();\n "}, {"sha": "e7b1ff6479d88dc4f60888bbd8ccf62fe5e9ff94", "filename": "src/librustc_lexer/src/unescape/tests.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef1ecbefb8719e408150738664d443a73f757ffd/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1ecbefb8719e408150738664d443a73f757ffd/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs?ref=ef1ecbefb8719e408150738664d443a73f757ffd", "patch": "@@ -11,7 +11,6 @@ fn test_unescape_char_bad() {\n     check(r\"\\\", EscapeError::LoneSlash);\n \n     check(\"\\n\", EscapeError::EscapeOnlyChar);\n-    check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n     check(\"\\t\", EscapeError::EscapeOnlyChar);\n     check(\"'\", EscapeError::EscapeOnlyChar);\n     check(\"\\r\", EscapeError::BareCarriageReturn);\n@@ -31,6 +30,7 @@ fn test_unescape_char_bad() {\n     check(r\"\\v\", EscapeError::InvalidEscape);\n     check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n     check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n+    check(\"\\\\\\r\", EscapeError::InvalidEscape);\n \n     check(r\"\\x\", EscapeError::TooShortHexEscape);\n     check(r\"\\x0\", EscapeError::TooShortHexEscape);\n@@ -116,10 +116,9 @@ fn test_unescape_str_good() {\n \n     check(\"foo\", \"foo\");\n     check(\"\", \"\");\n-    check(\" \\t\\n\\r\\n\", \" \\t\\n\\n\");\n+    check(\" \\t\\n\", \" \\t\\n\");\n \n     check(\"hello \\\\\\n     world\", \"hello world\");\n-    check(\"hello \\\\\\r\\n     world\", \"hello world\");\n     check(\"thread's\", \"thread's\")\n }\n \n@@ -134,7 +133,6 @@ fn test_unescape_byte_bad() {\n     check(r\"\\\", EscapeError::LoneSlash);\n \n     check(\"\\n\", EscapeError::EscapeOnlyChar);\n-    check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n     check(\"\\t\", EscapeError::EscapeOnlyChar);\n     check(\"'\", EscapeError::EscapeOnlyChar);\n     check(\"\\r\", EscapeError::BareCarriageReturn);\n@@ -238,10 +236,9 @@ fn test_unescape_byte_str_good() {\n \n     check(\"foo\", b\"foo\");\n     check(\"\", b\"\");\n-    check(\" \\t\\n\\r\\n\", b\" \\t\\n\\n\");\n+    check(\" \\t\\n\", b\" \\t\\n\");\n \n     check(\"hello \\\\\\n     world\", b\"hello world\");\n-    check(\"hello \\\\\\r\\n     world\", b\"hello world\");\n     check(\"thread's\", b\"thread's\")\n }\n \n@@ -253,7 +250,6 @@ fn test_unescape_raw_str() {\n         assert_eq!(unescaped, expected);\n     }\n \n-    check(\"\\r\\n\", &[(0..2, Ok('\\n'))]);\n     check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n     check(\"\\rx\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString)), (1..2, Ok('x'))]);\n }\n@@ -266,7 +262,6 @@ fn test_unescape_raw_byte_str() {\n         assert_eq!(unescaped, expected);\n     }\n \n-    check(\"\\r\\n\", &[(0..2, Ok(byte_from_char('\\n')))]);\n     check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n     check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByteString))]);\n     check("}, {"sha": "bdf468a52bb3999d1140cd0aaac5f1c11e6aca00", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 15, "deletions": 66, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ef1ecbefb8719e408150738664d443a73f757ffd/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1ecbefb8719e408150738664d443a73f757ffd/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=ef1ecbefb8719e408150738664d443a73f757ffd", "patch": "@@ -8,9 +8,7 @@ use syntax_pos::{BytePos, Pos, Span};\n use rustc_lexer::Base;\n use rustc_lexer::unescape;\n \n-use std::borrow::Cow;\n use std::char;\n-use std::iter;\n use std::convert::TryInto;\n use rustc_data_structures::sync::Lrc;\n use log::debug;\n@@ -181,18 +179,7 @@ impl<'a> StringReader<'a> {\n                 let string = self.str_from(start);\n                 // comments with only more \"/\"s are not doc comments\n                 let tok = if is_doc_comment(string) {\n-                    let mut idx = 0;\n-                    loop {\n-                        idx = match string[idx..].find('\\r') {\n-                            None => break,\n-                            Some(it) => idx + it + 1\n-                        };\n-                        if string[idx..].chars().next() != Some('\\n') {\n-                            self.err_span_(start + BytePos(idx as u32 - 1),\n-                                            start + BytePos(idx as u32),\n-                                            \"bare CR not allowed in doc-comment\");\n-                        }\n-                    }\n+                    self.forbid_bare_cr(start, string, \"bare CR not allowed in doc-comment\");\n                     token::DocComment(Symbol::intern(string))\n                 } else {\n                     token::Comment\n@@ -217,15 +204,10 @@ impl<'a> StringReader<'a> {\n                 }\n \n                 let tok = if is_doc_comment {\n-                    let has_cr = string.contains('\\r');\n-                    let string = if has_cr {\n-                        self.translate_crlf(start,\n-                                            string,\n-                                            \"bare CR not allowed in block doc-comment\")\n-                    } else {\n-                        string.into()\n-                    };\n-                    token::DocComment(Symbol::intern(&string[..]))\n+                    self.forbid_bare_cr(start,\n+                                        string,\n+                                        \"bare CR not allowed in block doc-comment\");\n+                    token::DocComment(Symbol::intern(string))\n                 } else {\n                     token::Comment\n                 };\n@@ -516,49 +498,16 @@ impl<'a> StringReader<'a> {\n         &self.src[self.src_index(start)..self.src_index(end)]\n     }\n \n-    /// Converts CRLF to LF in the given string, raising an error on bare CR.\n-    fn translate_crlf<'b>(&self, start: BytePos, s: &'b str, errmsg: &'b str) -> Cow<'b, str> {\n-        let mut chars = s.char_indices().peekable();\n-        while let Some((i, ch)) = chars.next() {\n-            if ch == '\\r' {\n-                if let Some((lf_idx, '\\n')) = chars.peek() {\n-                    return translate_crlf_(self, start, s, *lf_idx, chars, errmsg).into();\n-                }\n-                let pos = start + BytePos(i as u32);\n-                let end_pos = start + BytePos((i + ch.len_utf8()) as u32);\n-                self.err_span_(pos, end_pos, errmsg);\n-            }\n-        }\n-        return s.into();\n-\n-        fn translate_crlf_(rdr: &StringReader<'_>,\n-                           start: BytePos,\n-                           s: &str,\n-                           mut j: usize,\n-                           mut chars: iter::Peekable<impl Iterator<Item = (usize, char)>>,\n-                           errmsg: &str)\n-                           -> String {\n-            let mut buf = String::with_capacity(s.len());\n-            // Skip first CR\n-            buf.push_str(&s[.. j - 1]);\n-            while let Some((i, ch)) = chars.next() {\n-                if ch == '\\r' {\n-                    if j < i {\n-                        buf.push_str(&s[j..i]);\n-                    }\n-                    let next = i + ch.len_utf8();\n-                    j = next;\n-                    if chars.peek().map(|(_, ch)| *ch) != Some('\\n') {\n-                        let pos = start + BytePos(i as u32);\n-                        let end_pos = start + BytePos(next as u32);\n-                        rdr.err_span_(pos, end_pos, errmsg);\n-                    }\n-                }\n-            }\n-            if j < s.len() {\n-                buf.push_str(&s[j..]);\n-            }\n-            buf\n+    fn forbid_bare_cr(&self, start: BytePos, s: &str, errmsg: &str) {\n+        let mut idx = 0;\n+        loop {\n+            idx = match s[idx..].find('\\r') {\n+                None => break,\n+                Some(it) => idx + it + 1\n+            };\n+            self.err_span_(start + BytePos(idx as u32 - 1),\n+                           start + BytePos(idx as u32),\n+                           errmsg);\n         }\n     }\n "}, {"sha": "a17cd7625fb1907ec1b398c27c3d696df9679e75", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ef1ecbefb8719e408150738664d443a73f757ffd/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1ecbefb8719e408150738664d443a73f757ffd/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=ef1ecbefb8719e408150738664d443a73f757ffd", "patch": "@@ -1043,6 +1043,7 @@ impl SourceFile {\n                mut src: String,\n                start_pos: BytePos) -> Result<SourceFile, OffsetOverflowError> {\n         remove_bom(&mut src);\n+        normalize_newlines(&mut src);\n \n         let src_hash = {\n             let mut hasher: StableHasher<u128> = StableHasher::new();\n@@ -1210,6 +1211,61 @@ fn remove_bom(src: &mut String) {\n     }\n }\n \n+\n+/// Replaces `\\r\\n` with `\\n` in-place in `src`.\n+///\n+/// Returns error if there's a lone `\\r` in the string\n+fn normalize_newlines(src: &mut String) {\n+    if !src.as_bytes().contains(&b'\\r') {\n+        return;\n+    }\n+\n+    // We replace `\\r\\n` with `\\n` in-place, which doesn't break utf-8 encoding.\n+    // While we *can* call `as_mut_vec` and do surgery on the live string\n+    // directly, let's rather steal the contents of `src`. This makes the code\n+    // safe even if a panic occurs.\n+\n+    let mut buf = std::mem::replace(src, String::new()).into_bytes();\n+    let mut gap_len = 0;\n+    let mut tail = buf.as_mut_slice();\n+    loop {\n+        let idx = match find_crlf(&tail[gap_len..]) {\n+            None => tail.len(),\n+            Some(idx) => idx + gap_len,\n+        };\n+        tail.copy_within(gap_len..idx, 0);\n+        tail = &mut tail[idx - gap_len..];\n+        if tail.len() == gap_len {\n+            break;\n+        }\n+        gap_len += 1;\n+    }\n+\n+    // Account for removed `\\r`.\n+    // After `set_len`, `buf` is guaranteed to contain utf-8 again.\n+    let new_len = buf.len() - gap_len;\n+    unsafe {\n+        buf.set_len(new_len);\n+        *src = String::from_utf8_unchecked(buf);\n+    }\n+\n+    fn find_crlf(src: &[u8]) -> Option<usize> {\n+        let mut search_idx = 0;\n+        while let Some(idx) = find_cr(&src[search_idx..]) {\n+            if src[search_idx..].get(idx + 1) != Some(&b'\\n') {\n+                search_idx += idx + 1;\n+                continue;\n+            }\n+            return Some(search_idx + idx);\n+        }\n+        None\n+    }\n+\n+    fn find_cr(src: &[u8]) -> Option<usize> {\n+        src.iter().position(|&b| b == b'\\r')\n+    }\n+}\n+\n // _____________________________________________________________________________\n // Pos, BytePos, CharPos\n //"}, {"sha": "6bd6016020a27a94ed6d9f75e7022b961389abc9", "filename": "src/libsyntax_pos/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef1ecbefb8719e408150738664d443a73f757ffd/src%2Flibsyntax_pos%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1ecbefb8719e408150738664d443a73f757ffd/src%2Flibsyntax_pos%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Ftests.rs?ref=ef1ecbefb8719e408150738664d443a73f757ffd", "patch": "@@ -16,3 +16,23 @@ fn test_lookup_line() {\n     assert_eq!(lookup_line(lines, BytePos(28)), 2);\n     assert_eq!(lookup_line(lines, BytePos(29)), 2);\n }\n+\n+#[test]\n+fn test_normalize_newlines() {\n+    fn check(before: &str, after: &str) {\n+        let mut actual = before.to_string();\n+        normalize_newlines(&mut actual);\n+        assert_eq!(actual.as_str(), after);\n+    }\n+    check(\"\", \"\");\n+    check(\"\\n\", \"\\n\");\n+    check(\"\\r\", \"\\r\");\n+    check(\"\\r\\r\", \"\\r\\r\");\n+    check(\"\\r\\n\", \"\\n\");\n+    check(\"hello world\", \"hello world\");\n+    check(\"hello\\nworld\", \"hello\\nworld\");\n+    check(\"hello\\r\\nworld\", \"hello\\nworld\");\n+    check(\"\\r\\nhello\\r\\nworld\\r\\n\", \"\\nhello\\nworld\\n\");\n+    check(\"\\r\\r\\n\", \"\\r\\n\");\n+    check(\"hello\\rworld\", \"hello\\rworld\");\n+}"}]}