{"sha": "4c514a3e02b019cdd3a17c9bcd78d93c210ab267", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjNTE0YTNlMDJiMDE5Y2RkM2ExN2M5YmNkNzhkOTNjMjEwYWIyNjc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-24T20:32:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-24T20:32:41Z"}, "message": "move enum variant to the new API", "tree": {"sha": "acd4a571cec5c44d1ccbc705578f47a898da4139", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acd4a571cec5c44d1ccbc705578f47a898da4139"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c514a3e02b019cdd3a17c9bcd78d93c210ab267", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c514a3e02b019cdd3a17c9bcd78d93c210ab267", "html_url": "https://github.com/rust-lang/rust/commit/4c514a3e02b019cdd3a17c9bcd78d93c210ab267", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c514a3e02b019cdd3a17c9bcd78d93c210ab267/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11dda8a0fb905a1b41a64001d564632eb062b9aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/11dda8a0fb905a1b41a64001d564632eb062b9aa", "html_url": "https://github.com/rust-lang/rust/commit/11dda8a0fb905a1b41a64001d564632eb062b9aa"}], "stats": {"total": 239, "additions": 97, "deletions": 142}, "files": [{"sha": "b2631d6a6923beb2e9d9f5bfae7e6ab088d8cc53", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 19, "deletions": 45, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4c514a3e02b019cdd3a17c9bcd78d93c210ab267/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c514a3e02b019cdd3a17c9bcd78d93c210ab267/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=4c514a3e02b019cdd3a17c9bcd78d93c210ab267", "patch": "@@ -4,14 +4,12 @@\n use std::sync::Arc;\n \n use ra_syntax::{\n-    SyntaxNode,\n-    ast::{self, NameOwner, StructFlavor, AstNode}\n+    ast::{self, NameOwner, StructFlavor}\n };\n \n use crate::{\n-    DefId, DefLoc, Name, AsName, Struct, Enum, EnumVariant, Module, HirFileId,\n-    HirDatabase, DefKind,\n-    SourceItemId,\n+    Name, AsName, Struct, Enum, EnumVariant, Module, HirFileId,\n+    HirDatabase,\n     type_ref::TypeRef,\n     ids::ItemLoc,\n };\n@@ -66,26 +64,17 @@ impl StructData {\n     }\n }\n \n-fn get_def_id(\n-    db: &impl HirDatabase,\n-    module: Module,\n-    file_id: HirFileId,\n-    node: &SyntaxNode,\n-    expected_kind: DefKind,\n-) -> DefId {\n-    let file_items = db.file_items(file_id);\n-\n-    let item_id = file_items.id_of(file_id, node);\n-    let source_item_id = SourceItemId {\n-        file_id,\n-        item_id: Some(item_id),\n-    };\n-    let loc = DefLoc {\n-        module,\n-        kind: expected_kind,\n-        source_item_id,\n-    };\n-    loc.id(db)\n+impl EnumVariant {\n+    pub(crate) fn from_ast(\n+        db: &impl HirDatabase,\n+        module: Module,\n+        file_id: HirFileId,\n+        ast: &ast::EnumVariant,\n+    ) -> EnumVariant {\n+        let loc = ItemLoc::from_ast(db, module, file_id, ast);\n+        let id = db.as_ref().enum_variants.loc2id(&loc);\n+        EnumVariant { id }\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -107,17 +96,7 @@ impl EnumData {\n             vl.variants()\n                 .filter_map(|variant_def| {\n                     let name = variant_def.name().map(|n| n.as_name());\n-\n-                    name.map(|n| {\n-                        let def_id = get_def_id(\n-                            db,\n-                            module,\n-                            file_id,\n-                            variant_def.syntax(),\n-                            DefKind::EnumVariant,\n-                        );\n-                        (n, EnumVariant::new(def_id))\n-                    })\n+                    name.map(|n| (n, EnumVariant::from_ast(db, module, file_id, variant_def)))\n                 })\n                 .collect()\n         } else {\n@@ -148,17 +127,12 @@ impl EnumVariantData {\n \n     pub(crate) fn enum_variant_data_query(\n         db: &impl HirDatabase,\n-        def_id: DefId,\n+        var: EnumVariant,\n     ) -> Arc<EnumVariantData> {\n-        let def_loc = def_id.loc(db);\n-        assert!(def_loc.kind == DefKind::EnumVariant);\n-        let syntax = db.file_item(def_loc.source_item_id);\n-        let variant_def = ast::EnumVariant::cast(&syntax)\n-            .expect(\"enum variant def should point to EnumVariant node\");\n+        let (file_id, variant_def) = var.source(db);\n         let enum_def = variant_def.parent_enum();\n-        let e = Enum::from_ast(db, def_loc.module, def_loc.source_item_id.file_id, enum_def);\n-\n-        Arc::new(EnumVariantData::new(variant_def, e))\n+        let e = Enum::from_ast(db, var.module(db), file_id, enum_def);\n+        Arc::new(EnumVariantData::new(&*variant_def, e))\n     }\n }\n "}, {"sha": "5e927e41dcf3051e30db8f7a996b9f5775e236b9", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4c514a3e02b019cdd3a17c9bcd78d93c210ab267/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c514a3e02b019cdd3a17c9bcd78d93c210ab267/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=4c514a3e02b019cdd3a17c9bcd78d93c210ab267", "patch": "@@ -16,7 +16,7 @@ use crate::{\n     code_model_impl::def_id_to_ast,\n     docs::{Documentation, Docs, docs_from_ast},\n     module_tree::ModuleId,\n-    ids::{FunctionId, StructId, EnumId},\n+    ids::{FunctionId, StructId, EnumId, EnumVariantId},\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -68,9 +68,11 @@ pub enum ModuleDef {\n     Function(Function),\n     Struct(Struct),\n     Enum(Enum),\n+    // Can't be directly declared, but can be imported.\n+    EnumVariant(EnumVariant),\n     Def(DefId),\n }\n-impl_froms!(ModuleDef: Module, Function, Struct, Enum);\n+impl_froms!(ModuleDef: Module, Function, Struct, Enum, EnumVariant);\n \n impl From<DefId> for ModuleDef {\n     fn from(it: DefId) -> ModuleDef {\n@@ -264,45 +266,40 @@ impl Docs for Enum {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct EnumVariant {\n-    pub(crate) def_id: DefId,\n+    pub(crate) id: EnumVariantId,\n }\n \n impl EnumVariant {\n-    pub(crate) fn new(def_id: DefId) -> Self {\n-        EnumVariant { def_id }\n-    }\n-\n-    pub fn def_id(&self) -> DefId {\n-        self.def_id\n+    pub fn module(&self, db: &impl HirDatabase) -> Module {\n+        self.id.loc(db).module\n     }\n-\n     pub fn parent_enum(&self, db: &impl HirDatabase) -> Enum {\n-        db.enum_variant_data(self.def_id).parent_enum.clone()\n+        db.enum_variant_data(*self).parent_enum.clone()\n     }\n \n     pub fn name(&self, db: &impl HirDatabase) -> Option<Name> {\n-        db.enum_variant_data(self.def_id).name.clone()\n+        db.enum_variant_data(*self).name.clone()\n     }\n \n     pub fn variant_data(&self, db: &impl HirDatabase) -> Arc<VariantData> {\n-        db.enum_variant_data(self.def_id).variant_data.clone()\n+        db.enum_variant_data(*self).variant_data.clone()\n     }\n \n     pub fn fields(&self, db: &impl HirDatabase) -> Vec<StructField> {\n         self.variant_data(db)\n             .fields()\n             .iter()\n             .map(|it| StructField {\n-                parent: self.def_id.into(),\n+                parent: (*self).into(),\n                 name: it.name.clone(),\n             })\n             .collect()\n     }\n \n     pub fn source(&self, db: &impl HirDatabase) -> (HirFileId, TreeArc<ast::EnumVariant>) {\n-        def_id_to_ast(db, self.def_id)\n+        self.id.loc(db).source(db)\n     }\n }\n "}, {"sha": "aa5e5d68953ee45df240ea7df7e5b93b5f2a7266", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c514a3e02b019cdd3a17c9bcd78d93c210ab267/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c514a3e02b019cdd3a17c9bcd78d93c210ab267/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=4c514a3e02b019cdd3a17c9bcd78d93c210ab267", "patch": "@@ -143,11 +143,11 @@ impl Module {\n                         .find(|(n, _variant)| n == &segment.name);\n \n                     match matching_variant {\n-                        Some((_n, variant)) => PerNs::both(variant.def_id().into(), (*e).into()),\n+                        Some((_n, variant)) => PerNs::both(variant.into(), (*e).into()),\n                         None => PerNs::none(),\n                     }\n                 }\n-                ModuleDef::Function(_) | ModuleDef::Struct(_) => {\n+                ModuleDef::Function(_) | ModuleDef::Struct(_) | ModuleDef::EnumVariant(_) => {\n                     // could be an inherent method call in UFCS form\n                     // (`Struct::method`), or some other kind of associated\n                     // item... Which we currently don't handle (TODO)"}, {"sha": "5304f5d31348ab7415eb9936c780e3de5ca40b30", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4c514a3e02b019cdd3a17c9bcd78d93c210ab267/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c514a3e02b019cdd3a17c9bcd78d93c210ab267/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=4c514a3e02b019cdd3a17c9bcd78d93c210ab267", "patch": "@@ -4,11 +4,11 @@ use ra_syntax::{SyntaxNode, TreeArc, SourceFile};\n use ra_db::{SyntaxDatabase, CrateId, salsa};\n \n use crate::{\n-    DefId, MacroCallId, Name, HirFileId,\n+    MacroCallId, Name, HirFileId,\n     SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n     query_definitions,\n     Function, FnSignature, FnScopes,\n-    Struct, Enum,\n+    Struct, Enum, EnumVariant,\n     macros::MacroExpansion,\n     module_tree::ModuleTree,\n     nameres::{ItemMap, lower::{LoweredModule, ImportSourceMap}},\n@@ -36,7 +36,7 @@ pub trait HirDatabase: SyntaxDatabase + AsRef<HirInterner> {\n     fn enum_data(&self, e: Enum) -> Arc<EnumData>;\n \n     #[salsa::invoke(crate::adt::EnumVariantData::enum_variant_data_query)]\n-    fn enum_variant_data(&self, def_id: DefId) -> Arc<EnumVariantData>;\n+    fn enum_variant_data(&self, var: EnumVariant) -> Arc<EnumVariantData>;\n \n     #[salsa::invoke(crate::ty::infer)]\n     fn infer(&self, func: Function) -> Arc<InferenceResult>;"}, {"sha": "8cdc7ee56b6864e77021580be410e9d5dddc82ce", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4c514a3e02b019cdd3a17c9bcd78d93c210ab267/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c514a3e02b019cdd3a17c9bcd78d93c210ab267/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=4c514a3e02b019cdd3a17c9bcd78d93c210ab267", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{TreeArc, SyntaxNode, SourceFile, AstNode, ast};\n use ra_arena::{Arena, RawId, impl_arena_id};\n \n use crate::{\n-    HirDatabase, Def, EnumVariant, Crate,\n+    HirDatabase, Def, Crate,\n     Module, Trait, Type, Static, Const,\n };\n \n@@ -16,6 +16,7 @@ pub struct HirInterner {\n     pub(crate) fns: LocationIntener<ItemLoc<ast::FnDef>, FunctionId>,\n     pub(crate) structs: LocationIntener<ItemLoc<ast::StructDef>, StructId>,\n     pub(crate) enums: LocationIntener<ItemLoc<ast::EnumDef>, EnumId>,\n+    pub(crate) enum_variants: LocationIntener<ItemLoc<ast::EnumVariant>, EnumVariantId>,\n }\n \n impl HirInterner {\n@@ -208,6 +209,16 @@ impl EnumId {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct EnumVariantId(RawId);\n+impl_arena_id!(EnumVariantId);\n+\n+impl EnumVariantId {\n+    pub(crate) fn loc(self, db: &impl AsRef<HirInterner>) -> ItemLoc<ast::EnumVariant> {\n+        db.as_ref().enum_variants.id2loc(self)\n+    }\n+}\n+\n /// Def's are a core concept of hir. A `Def` is an Item (function, module, etc)\n /// in a specific module.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -223,7 +234,6 @@ pub struct DefLoc {\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub(crate) enum DefKind {\n-    EnumVariant,\n     Const,\n     Static,\n     Trait,\n@@ -249,7 +259,6 @@ impl DefId {\n     pub fn resolve(self, db: &impl HirDatabase) -> Def {\n         let loc = self.loc(db);\n         match loc.kind {\n-            DefKind::EnumVariant => Def::EnumVariant(EnumVariant::new(self)),\n             DefKind::Const => {\n                 let def = Const::new(self);\n                 Def::Const(def)"}, {"sha": "66cf2bd645a70082f4f7f40b096630b6e91a5ee1", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 48, "deletions": 73, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/4c514a3e02b019cdd3a17c9bcd78d93c210ab267/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c514a3e02b019cdd3a17c9bcd78d93c210ab267/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=4c514a3e02b019cdd3a17c9bcd78d93c210ab267", "patch": "@@ -431,25 +431,24 @@ impl Ty {\n             TypableDef::Function(func) => (func.generic_params(db), last),\n             TypableDef::Struct(s) => (s.generic_params(db), last),\n             TypableDef::Enum(e) => (e.generic_params(db), last),\n+            TypableDef::EnumVariant(var) => {\n+                // the generic args for an enum variant may be either specified\n+                // on the segment referring to the enum, or on the segment\n+                // referring to the variant. So `Option::<T>::None` and\n+                // `Option::None::<T>` are both allowed (though the former is\n+                // preferred). See also `def_ids_for_path_segments` in rustc.\n+                let len = path.segments.len();\n+                let segment = if len >= 2 && path.segments[len - 2].args_and_bindings.is_some() {\n+                    // Option::<T>::None\n+                    &path.segments[len - 2]\n+                } else {\n+                    // Option::None::<T>\n+                    last\n+                };\n+                (var.parent_enum(db).generic_params(db), segment)\n+            }\n             TypableDef::Def(def_id) => match def_id.resolve(db) {\n                 Def::Trait(t) => (t.generic_params(db), last),\n-                Def::EnumVariant(ev) => {\n-                    // the generic args for an enum variant may be either specified\n-                    // on the segment referring to the enum, or on the segment\n-                    // referring to the variant. So `Option::<T>::None` and\n-                    // `Option::None::<T>` are both allowed (though the former is\n-                    // preferred). See also `def_ids_for_path_segments` in rustc.\n-                    let len = path.segments.len();\n-                    let segment = if len >= 2 && path.segments[len - 2].args_and_bindings.is_some()\n-                    {\n-                        // Option::<T>::None\n-                        &path.segments[len - 2]\n-                    } else {\n-                        // Option::None::<T>\n-                        last\n-                    };\n-                    (ev.parent_enum(db).generic_params(db), segment)\n-                }\n                 _ => return Substs::empty(),\n             },\n         };\n@@ -688,9 +687,10 @@ pub enum TypableDef {\n     Function(Function),\n     Struct(Struct),\n     Enum(Enum),\n+    EnumVariant(EnumVariant),\n     Def(DefId),\n }\n-impl_froms!(TypableDef: Function, Struct, Enum);\n+impl_froms!(TypableDef: Function, Struct, Enum, EnumVariant);\n \n impl From<DefId> for TypableDef {\n     fn from(func: DefId) -> TypableDef {\n@@ -705,6 +705,7 @@ impl From<ModuleDef> for Option<TypableDef> {\n             ModuleDef::Function(f) => f.into(),\n             ModuleDef::Struct(s) => s.into(),\n             ModuleDef::Enum(e) => e.into(),\n+            ModuleDef::EnumVariant(v) => v.into(),\n             ModuleDef::Module(_) => return None,\n         };\n         Some(res)\n@@ -716,48 +717,33 @@ pub(super) fn type_for_def(db: &impl HirDatabase, def: TypableDef) -> Ty {\n         TypableDef::Function(f) => type_for_fn(db, f),\n         TypableDef::Struct(s) => type_for_struct(db, s),\n         TypableDef::Enum(e) => type_for_enum(db, e),\n-        TypableDef::Def(def_id) => match def_id.resolve(db) {\n-            Def::EnumVariant(ev) => type_for_enum_variant(db, ev),\n-            _ => {\n-                log::debug!(\n-                    \"trying to get type for item of unknown type {:?} {:?}\",\n-                    def_id,\n-                    def\n-                );\n-                Ty::Unknown\n-            }\n-        },\n+        TypableDef::EnumVariant(v) => type_for_enum_variant(db, v),\n+        TypableDef::Def(def_id) => {\n+            log::debug!(\n+                \"trying to get type for item of unknown type {:?} {:?}\",\n+                def_id,\n+                def\n+            );\n+            Ty::Unknown\n+        }\n     }\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum VariantDef {\n     Struct(Struct),\n-    Def(DefId), // EnumVariant\n-}\n-impl_froms!(VariantDef: Struct);\n-\n-impl From<DefId> for VariantDef {\n-    fn from(def_id: DefId) -> VariantDef {\n-        VariantDef::Def(def_id)\n-    }\n+    EnumVariant(EnumVariant),\n }\n+impl_froms!(VariantDef: Struct, EnumVariant);\n \n pub(super) fn type_for_field(db: &impl HirDatabase, def: VariantDef, field: Name) -> Option<Ty> {\n     let (variant_data, generics, module) = match def {\n         VariantDef::Struct(s) => (s.variant_data(db), s.generic_params(db), s.module(db)),\n-        VariantDef::Def(def_id) => match def_id.resolve(db) {\n-            Def::EnumVariant(ev) => (\n-                ev.variant_data(db),\n-                ev.parent_enum(db).generic_params(db),\n-                def_id.module(db),\n-            ),\n-            // TODO: unions\n-            _ => panic!(\n-                \"trying to get type for field {:?} in non-struct/variant {:?}\",\n-                field, def_id\n-            ),\n-        },\n+        VariantDef::EnumVariant(var) => (\n+            var.variant_data(db),\n+            var.parent_enum(db).generic_params(db),\n+            var.module(db),\n+        ),\n     };\n     // We can't have an impl block ere, right?\n     // let impl_block = def_id.impl_block(db);\n@@ -1156,21 +1142,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             def,\n         );\n         match def {\n-            TypableDef::Def(def_id) => match def_id.resolve(self.db) {\n-                Def::EnumVariant(ev) => {\n-                    let ty = type_for_enum_variant(self.db, ev);\n-                    let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                    (ty, Some(def_id.into()))\n-                }\n-                _ => (Ty::Unknown, None),\n-            },\n-            TypableDef::Function(_) => (Ty::Unknown, None),\n             TypableDef::Struct(s) => {\n                 let ty = type_for_struct(self.db, s);\n                 let ty = self.insert_type_vars(ty.apply_substs(substs));\n                 (ty, Some(s.into()))\n             }\n-            TypableDef::Enum(_) => (Ty::Unknown, None),\n+            TypableDef::EnumVariant(var) => {\n+                let ty = type_for_enum_variant(self.db, var);\n+                let ty = self.insert_type_vars(ty.apply_substs(substs));\n+                (ty, Some(var.into()))\n+            }\n+            TypableDef::Def(_) | TypableDef::Enum(_) | TypableDef::Function(_) => {\n+                (Ty::Unknown, None)\n+            }\n         }\n     }\n \n@@ -1181,13 +1165,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let fields = s.fields(self.db);\n                 Some((ty, fields))\n             }\n-            VariantDef::Def(def_id) => match def_id.resolve(self.db) {\n-                Def::EnumVariant(ev) => {\n-                    let fields = ev.fields(self.db);\n-                    Some((ty, fields))\n-                }\n-                _ => None,\n-            },\n+            VariantDef::EnumVariant(var) => {\n+                let fields = var.fields(self.db);\n+                Some((ty, fields))\n+            }\n         }\n     }\n \n@@ -1285,13 +1266,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .module\n                 .resolve_path(self.db, &path)\n                 .take_values()\n-                .and_then(|module_def| match module_def {\n-                    ModuleDef::Def(it) => Some(it.into()),\n-                    ModuleDef::Function(func) => Some(func.into()),\n-                    ModuleDef::Struct(s) => Some(s.into()),\n-                    ModuleDef::Enum(e) => Some(e.into()),\n-                    ModuleDef::Module(_) => None,\n-                })\n+                .and_then(|module_def| module_def.into())\n                 .map_or(Ty::Unknown, |resolved| self.db.type_for_def(resolved)),\n             Pat::Bind {\n                 mode,"}]}