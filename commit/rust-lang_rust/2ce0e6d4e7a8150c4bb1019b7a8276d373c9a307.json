{"sha": "2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjZTBlNmQ0ZTdhODE1MGM0YmIxMDE5YjdhODI3NmQzNzNjOWEzMDc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-01T08:04:21Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:00Z"}, "message": "rustc_trans: use the TypeId hashing mechanism instead of metadata.", "tree": {"sha": "7a22cec92121029b15b0cb428ea344d1c1a898a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a22cec92121029b15b0cb428ea344d1c1a898a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307", "html_url": "https://github.com/rust-lang/rust/commit/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02c4155d2cf0b17f526a126ad1f9dca944d9e85d", "url": "https://api.github.com/repos/rust-lang/rust/commits/02c4155d2cf0b17f526a126ad1f9dca944d9e85d", "html_url": "https://github.com/rust-lang/rust/commit/02c4155d2cf0b17f526a126ad1f9dca944d9e85d"}], "stats": {"total": 112, "additions": 45, "deletions": 67}, "files": [{"sha": "513fa30861adb2cb0b5d4dd5b990e6478ce951ce", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307", "patch": "@@ -258,11 +258,6 @@ pub trait CrateStore<'tcx> {\n     // utility functions\n     fn metadata_filename(&self) -> &str;\n     fn metadata_section_name(&self, target: &Target) -> &str;\n-    fn encode_type<'a>(&self,\n-                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       ty: Ty<'tcx>,\n-                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n-                       -> Vec<u8>;\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>;\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n@@ -469,13 +464,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // utility functions\n     fn metadata_filename(&self) -> &str { bug!(\"metadata_filename\") }\n     fn metadata_section_name(&self, target: &Target) -> &str { bug!(\"metadata_section_name\") }\n-    fn encode_type<'a>(&self,\n-                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       ty: Ty<'tcx>,\n-                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n-                       -> Vec<u8> {\n-        bug!(\"encode_type\")\n-    }\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>\n         { vec![] }\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }"}, {"sha": "5c71f348b9925db8ae6d9534a599175877c40e49", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307", "patch": "@@ -352,12 +352,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n     pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n-        let mut hasher = TypeIdHasher {\n-            tcx: self,\n-            state: SipHasher::new()\n-        };\n+        let mut hasher = TypeIdHasher::new(self, SipHasher::new());\n         hasher.visit_ty(ty);\n-        hasher.state.finish()\n+        hasher.finish()\n     }\n \n     /// Returns true if this ADT is a dtorck type.\n@@ -391,16 +388,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct TypeIdHasher<'a, 'gcx: 'a+'tcx, 'tcx: 'a, H> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    state: SipHasher\n+    state: H\n }\n \n-impl<'a, 'gcx, 'tcx> TypeIdHasher<'a, 'gcx, 'tcx> {\n-    fn hash<T: Hash>(&mut self, x: T) {\n+impl<'a, 'gcx, 'tcx, H: Hasher> TypeIdHasher<'a, 'gcx, 'tcx, H> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, state: H) -> Self {\n+        TypeIdHasher {\n+            tcx: tcx,\n+            state: state\n+        }\n+    }\n+\n+    pub fn hash<T: Hash>(&mut self, x: T) {\n         x.hash(&mut self.state);\n     }\n \n+    pub fn finish(self) -> u64 {\n+        self.state.finish()\n+    }\n+\n     fn hash_discriminant_u8<T>(&mut self, x: &T) {\n         let v = unsafe {\n             intrinsics::discriminant_value(x)\n@@ -419,7 +427,7 @@ impl<'a, 'gcx, 'tcx> TypeIdHasher<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, H> {\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n         // Distinguish between the Ty variants uniformly.\n         self.hash_discriminant_u8(&ty.sty);"}, {"sha": "aae87005bf42e11c333132f9e39d286dd4d6cd02", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307", "patch": "@@ -677,14 +677,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         loader::meta_section_name(target)\n     }\n-    fn encode_type<'a>(&self,\n-                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       ty: Ty<'tcx>,\n-                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n-                       -> Vec<u8>\n-    {\n-        encoder::encoded_ty(tcx, ty, def_id_to_string)\n-    }\n \n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>\n     {"}, {"sha": "409982289d8140c2ab1b995523f6c7c79731c784", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307", "patch": "@@ -36,9 +36,8 @@ use rustc::session::config::{self, PanicStrategy, CrateTypeRustcMacro};\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n \n use rustc_serialize::{Encodable, SpecializedEncoder};\n-use std::cell::RefCell;\n use std::io::prelude::*;\n-use std::io::{Cursor, SeekFrom};\n+use std::io::SeekFrom;\n use std::ops::{Deref, DerefMut};\n use std::rc::Rc;\n use std::u32;\n@@ -1891,17 +1890,3 @@ fn encode_metadata_inner(ecx: &mut EncodeContext, krate: &hir::Crate) {\n         println!(\"           total bytes: {}\", stats.total_bytes);\n     }\n }\n-\n-// Get the encoded string for a type\n-pub fn encoded_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            t: Ty<'tcx>,\n-                            def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n-                            -> Vec<u8> {\n-    let mut wr = Cursor::new(Vec::new());\n-    tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n-        ds: def_id_to_string,\n-        tcx: tcx,\n-        abbrevs: &RefCell::new(FnvHashMap())\n-    }, t);\n-    wr.into_inner()\n-}"}, {"sha": "500e9edebf3fe7fa976d4a9cd2e70cae2cb92056", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=2ce0e6d4e7a8150c4bb1019b7a8276d373c9a307", "patch": "@@ -102,9 +102,10 @@ use monomorphize::Instance;\n use util::sha2::{Digest, Sha256};\n \n use rustc::middle::weak_lang_items;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::hir::map as hir_map;\n-use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::fold::TypeVisitor;\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::ty::subst::Substs;\n use rustc::hir::map::definitions::{DefPath, DefPathData};\n@@ -114,9 +115,18 @@ use syntax::attr;\n use syntax::parse::token::{self, InternedString};\n use serialize::hex::ToHex;\n \n-pub fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> String {\n-    let def_path = tcx.def_path(def_id);\n-    def_path.to_string(tcx)\n+use std::hash::Hasher;\n+\n+struct Sha256Hasher<'a>(&'a mut Sha256);\n+\n+impl<'a> Hasher for Sha256Hasher<'a> {\n+    fn write(&mut self, msg: &[u8]) {\n+        self.0.input(msg)\n+    }\n+\n+    fn finish(&self) -> u64 {\n+        bug!(\"Sha256Hasher::finish should not be called\");\n+    }\n }\n \n fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n@@ -132,48 +142,43 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n                              // values for generic type parameters,\n                              // if any.\n-                             substs: Option<&Substs<'tcx>>)\n+                             substs: Option<&'tcx Substs<'tcx>>)\n                              -> String {\n     debug!(\"get_symbol_hash(def_path={:?}, parameters={:?})\",\n            def_path, substs);\n \n     let tcx = scx.tcx();\n \n-    return record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n-        let mut hash_state = scx.symbol_hasher().borrow_mut();\n-\n+    let mut hash_state = scx.symbol_hasher().borrow_mut();\n+    record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n         hash_state.reset();\n \n+        let mut hasher = ty::util::TypeIdHasher::new(tcx, Sha256Hasher(&mut hash_state));\n         // the main symbol name is not necessarily unique; hash in the\n         // compiler's internal def-path, guaranteeing each symbol has a\n         // truly unique path\n-        hash_state.input_str(&def_path.to_string(tcx));\n+        hasher.hash(def_path.to_string(tcx));\n \n         // Include the main item-type. Note that, in this case, the\n         // assertions about `needs_subst` may not hold, but this item-type\n         // ought to be the same for every reference anyway.\n         assert!(!item_type.has_erasable_regions());\n-        let encoded_item_type = tcx.sess.cstore.encode_type(tcx, item_type, def_id_to_string);\n-        hash_state.input(&encoded_item_type[..]);\n+        hasher.visit_ty(item_type);\n \n         // also include any type parameters (for generic items)\n         if let Some(substs) = substs {\n-            for t in substs.types() {\n-                assert!(!t.has_erasable_regions());\n-                assert!(!t.needs_subst());\n-                let encoded_type = tcx.sess.cstore.encode_type(tcx, t, def_id_to_string);\n-                hash_state.input(&encoded_type[..]);\n-            }\n+            assert!(!substs.has_erasable_regions());\n+            assert!(!substs.needs_subst());\n+            substs.visit_with(&mut hasher);\n         }\n-\n-        format!(\"h{}\", truncated_hash_result(&mut *hash_state))\n     });\n-\n     fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n         let output = symbol_hasher.result_bytes();\n         // 64 bits should be enough to avoid collisions.\n         output[.. 8].to_hex()\n     }\n+\n+    format!(\"h{}\", truncated_hash_result(&mut hash_state))\n }\n \n impl<'a, 'tcx> Instance<'tcx> {"}]}