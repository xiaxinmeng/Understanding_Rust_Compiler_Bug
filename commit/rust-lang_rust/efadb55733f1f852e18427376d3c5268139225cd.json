{"sha": "efadb55733f1f852e18427376d3c5268139225cd", "node_id": "C_kwDOAAsO6NoAKGVmYWRiNTU3MzNmMWY4NTJlMTg0MjczNzZkM2M1MjY4MTM5MjI1Y2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-25T12:55:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-25T12:55:24Z"}, "message": "Auto merge of #9851 - Veykril:unnecessary-safety-comment, r=giraffate\n\nLint unnecessary safety comments\n\nchangelog: [`unnecessary_safety_comment`]: Add unnecessary safety comment lint\n\nAddresses https://github.com/rust-lang/rust-clippy/issues/7954\n\nThis does not necessarily catch all occurences, as doing so would require checking all expressions in the entire source which seems rather expensive. Instead what the lint does is it checks items, statements and the tail expression of blocks for safety comments, then checks if those comments are necessary or not, then linting for the unnecessary ones.\n\nI kept the tests in one file to check that the lints do not clash with each other.", "tree": {"sha": "03d2df5e8ac89351ee510744689f12caa17cfd49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03d2df5e8ac89351ee510744689f12caa17cfd49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efadb55733f1f852e18427376d3c5268139225cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efadb55733f1f852e18427376d3c5268139225cd", "html_url": "https://github.com/rust-lang/rust/commit/efadb55733f1f852e18427376d3c5268139225cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efadb55733f1f852e18427376d3c5268139225cd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a9657139d1beca1d01486ba360fa17c43b9f58f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a9657139d1beca1d01486ba360fa17c43b9f58f", "html_url": "https://github.com/rust-lang/rust/commit/1a9657139d1beca1d01486ba360fa17c43b9f58f"}, {"sha": "f96dd383188e9f24e5b401e664cca97b8bd73825", "url": "https://api.github.com/repos/rust-lang/rust/commits/f96dd383188e9f24e5b401e664cca97b8bd73825", "html_url": "https://github.com/rust-lang/rust/commit/f96dd383188e9f24e5b401e664cca97b8bd73825"}], "stats": {"total": 644, "additions": 539, "deletions": 105}, "files": [{"sha": "23912bb3ed6b16aea9a4ce27ad1cd5a1a2f50661", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efadb55733f1f852e18427376d3c5268139225cd/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/efadb55733f1f852e18427376d3c5268139225cd/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=efadb55733f1f852e18427376d3c5268139225cd", "patch": "@@ -4451,6 +4451,7 @@ Released 2018-09-13\n [`unnecessary_mut_passed`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_mut_passed\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n [`unnecessary_owned_empty_strings`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_owned_empty_strings\n+[`unnecessary_safety_comment`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_safety_comment\n [`unnecessary_safety_doc`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_safety_doc\n [`unnecessary_self_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_self_imports\n [`unnecessary_sort_by`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_sort_by"}, {"sha": "e4d76f07d6b482b13fa7d5fbaf9cb8b6ce9923fd", "filename": "clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efadb55733f1f852e18427376d3c5268139225cd/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efadb55733f1f852e18427376d3c5268139225cd/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=efadb55733f1f852e18427376d3c5268139225cd", "patch": "@@ -584,6 +584,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::types::TYPE_COMPLEXITY_INFO,\n     crate::types::VEC_BOX_INFO,\n     crate::undocumented_unsafe_blocks::UNDOCUMENTED_UNSAFE_BLOCKS_INFO,\n+    crate::undocumented_unsafe_blocks::UNNECESSARY_SAFETY_COMMENT_INFO,\n     crate::unicode::INVISIBLE_CHARACTERS_INFO,\n     crate::unicode::NON_ASCII_LITERAL_INFO,\n     crate::unicode::UNICODE_NOT_NFC_INFO,"}, {"sha": "2e1b6d8d4ea7f743a862d8088ec8554b28ba913d", "filename": "clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 332, "deletions": 97, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/efadb55733f1f852e18427376d3c5268139225cd/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efadb55733f1f852e18427376d3c5268139225cd/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=efadb55733f1f852e18427376d3c5268139225cd", "patch": "@@ -1,6 +1,10 @@\n+use std::ops::ControlFlow;\n+\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::walk_span_to_context;\n+use clippy_utils::visitors::{for_each_expr_with_closures, Descend};\n use clippy_utils::{get_parent_node, is_lint_allowed};\n+use hir::HirId;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::{Block, BlockCheckMode, ItemKind, Node, UnsafeSource};\n@@ -59,11 +63,39 @@ declare_clippy_lint! {\n     restriction,\n     \"creating an unsafe block without explaining why it is safe\"\n }\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `// SAFETY: ` comments on safe code.\n+    ///\n+    /// ### Why is this bad?\n+    /// Safe code has no safety requirements, so there is no need to\n+    /// describe safety invariants.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// use std::ptr::NonNull;\n+    /// let a = &mut 42;\n+    ///\n+    /// // SAFETY: references are guaranteed to be non-null.\n+    /// let ptr = NonNull::new(a).unwrap();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::ptr::NonNull;\n+    /// let a = &mut 42;\n+    ///\n+    /// let ptr = NonNull::new(a).unwrap();\n+    /// ```\n+    #[clippy::version = \"1.67.0\"]\n+    pub UNNECESSARY_SAFETY_COMMENT,\n+    restriction,\n+    \"annotating safe code with a safety comment\"\n+}\n \n-declare_lint_pass!(UndocumentedUnsafeBlocks => [UNDOCUMENTED_UNSAFE_BLOCKS]);\n+declare_lint_pass!(UndocumentedUnsafeBlocks => [UNDOCUMENTED_UNSAFE_BLOCKS, UNNECESSARY_SAFETY_COMMENT]);\n \n-impl LateLintPass<'_> for UndocumentedUnsafeBlocks {\n-    fn check_block(&mut self, cx: &LateContext<'_>, block: &'_ Block<'_>) {\n+impl<'tcx> LateLintPass<'tcx> for UndocumentedUnsafeBlocks {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'tcx>) {\n         if block.rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided)\n             && !in_external_macro(cx.tcx.sess, block.span)\n             && !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, block.hir_id)\n@@ -87,35 +119,175 @@ impl LateLintPass<'_> for UndocumentedUnsafeBlocks {\n                 \"consider adding a safety comment on the preceding line\",\n             );\n         }\n+\n+        if let Some(tail) = block.expr\n+            && !is_lint_allowed(cx, UNNECESSARY_SAFETY_COMMENT, tail.hir_id)\n+            && !in_external_macro(cx.tcx.sess, tail.span)\n+            && let HasSafetyComment::Yes(pos) = stmt_has_safety_comment(cx, tail.span, tail.hir_id)\n+            && let Some(help_span) = expr_has_unnecessary_safety_comment(cx, tail, pos)\n+        {\n+            span_lint_and_help(\n+                cx,\n+                UNNECESSARY_SAFETY_COMMENT,\n+                tail.span,\n+                \"expression has unnecessary safety comment\",\n+                Some(help_span),\n+                \"consider removing the safety comment\",\n+            );\n+        }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if let hir::ItemKind::Impl(imple) = item.kind\n-            && imple.unsafety == hir::Unsafety::Unsafe\n-            && !in_external_macro(cx.tcx.sess, item.span)\n-            && !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, item.hir_id())\n-            && !is_unsafe_from_proc_macro(cx, item.span)\n-            && !item_has_safety_comment(cx, item)\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &hir::Stmt<'tcx>) {\n+        let (\n+            hir::StmtKind::Local(&hir::Local { init: Some(expr), .. })\n+            | hir::StmtKind::Expr(expr)\n+            | hir::StmtKind::Semi(expr)\n+        ) = stmt.kind else { return };\n+        if !is_lint_allowed(cx, UNNECESSARY_SAFETY_COMMENT, stmt.hir_id)\n+            && !in_external_macro(cx.tcx.sess, stmt.span)\n+            && let HasSafetyComment::Yes(pos) = stmt_has_safety_comment(cx, stmt.span, stmt.hir_id)\n+            && let Some(help_span) = expr_has_unnecessary_safety_comment(cx, expr, pos)\n         {\n+            span_lint_and_help(\n+                cx,\n+                UNNECESSARY_SAFETY_COMMENT,\n+                stmt.span,\n+                \"statement has unnecessary safety comment\",\n+                Some(help_span),\n+                \"consider removing the safety comment\",\n+            );\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n+        if in_external_macro(cx.tcx.sess, item.span) {\n+            return;\n+        }\n+\n+        let mk_spans = |pos: BytePos| {\n             let source_map = cx.tcx.sess.source_map();\n+            let span = Span::new(pos, pos, SyntaxContext::root(), None);\n+            let help_span = source_map.span_extend_to_next_char(span, '\\n', true);\n             let span = if source_map.is_multiline(item.span) {\n                 source_map.span_until_char(item.span, '\\n')\n             } else {\n                 item.span\n             };\n+            (span, help_span)\n+        };\n \n-            span_lint_and_help(\n-                cx,\n-                UNDOCUMENTED_UNSAFE_BLOCKS,\n-                span,\n-                \"unsafe impl missing a safety comment\",\n-                None,\n-                \"consider adding a safety comment on the preceding line\",\n-            );\n+        let item_has_safety_comment = item_has_safety_comment(cx, item);\n+        match (&item.kind, item_has_safety_comment) {\n+            // lint unsafe impl without safety comment\n+            (hir::ItemKind::Impl(impl_), HasSafetyComment::No) if impl_.unsafety == hir::Unsafety::Unsafe => {\n+                if !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, item.hir_id())\n+                    && !is_unsafe_from_proc_macro(cx, item.span)\n+                {\n+                    let source_map = cx.tcx.sess.source_map();\n+                    let span = if source_map.is_multiline(item.span) {\n+                        source_map.span_until_char(item.span, '\\n')\n+                    } else {\n+                        item.span\n+                    };\n+\n+                    span_lint_and_help(\n+                        cx,\n+                        UNDOCUMENTED_UNSAFE_BLOCKS,\n+                        span,\n+                        \"unsafe impl missing a safety comment\",\n+                        None,\n+                        \"consider adding a safety comment on the preceding line\",\n+                    );\n+                }\n+            },\n+            // lint safe impl with unnecessary safety comment\n+            (hir::ItemKind::Impl(impl_), HasSafetyComment::Yes(pos)) if impl_.unsafety == hir::Unsafety::Normal => {\n+                if !is_lint_allowed(cx, UNNECESSARY_SAFETY_COMMENT, item.hir_id()) {\n+                    let (span, help_span) = mk_spans(pos);\n+\n+                    span_lint_and_help(\n+                        cx,\n+                        UNNECESSARY_SAFETY_COMMENT,\n+                        span,\n+                        \"impl has unnecessary safety comment\",\n+                        Some(help_span),\n+                        \"consider removing the safety comment\",\n+                    );\n+                }\n+            },\n+            (hir::ItemKind::Impl(_), _) => {},\n+            // const and static items only need a safety comment if their body is an unsafe block, lint otherwise\n+            (&hir::ItemKind::Const(.., body) | &hir::ItemKind::Static(.., body), HasSafetyComment::Yes(pos)) => {\n+                if !is_lint_allowed(cx, UNNECESSARY_SAFETY_COMMENT, body.hir_id) {\n+                    let body = cx.tcx.hir().body(body);\n+                    if !matches!(\n+                        body.value.kind, hir::ExprKind::Block(block, _)\n+                        if block.rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided)\n+                    ) {\n+                        let (span, help_span) = mk_spans(pos);\n+\n+                        span_lint_and_help(\n+                            cx,\n+                            UNNECESSARY_SAFETY_COMMENT,\n+                            span,\n+                            &format!(\"{} has unnecessary safety comment\", item.kind.descr()),\n+                            Some(help_span),\n+                            \"consider removing the safety comment\",\n+                        );\n+                    }\n+                }\n+            },\n+            // Aside from unsafe impls and consts/statics with an unsafe block, items in general\n+            // do not have safety invariants that need to be documented, so lint those.\n+            (_, HasSafetyComment::Yes(pos)) => {\n+                if !is_lint_allowed(cx, UNNECESSARY_SAFETY_COMMENT, item.hir_id()) {\n+                    let (span, help_span) = mk_spans(pos);\n+\n+                    span_lint_and_help(\n+                        cx,\n+                        UNNECESSARY_SAFETY_COMMENT,\n+                        span,\n+                        &format!(\"{} has unnecessary safety comment\", item.kind.descr()),\n+                        Some(help_span),\n+                        \"consider removing the safety comment\",\n+                    );\n+                }\n+            },\n+            _ => (),\n         }\n     }\n }\n \n+fn expr_has_unnecessary_safety_comment<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'tcx>,\n+    comment_pos: BytePos,\n+) -> Option<Span> {\n+    // this should roughly be the reverse of `block_parents_have_safety_comment`\n+    if for_each_expr_with_closures(cx, expr, |expr| match expr.kind {\n+        hir::ExprKind::Block(\n+            Block {\n+                rules: BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n+                ..\n+            },\n+            _,\n+        ) => ControlFlow::Break(()),\n+        // statements will be handled by check_stmt itself again\n+        hir::ExprKind::Block(..) => ControlFlow::Continue(Descend::No),\n+        _ => ControlFlow::Continue(Descend::Yes),\n+    })\n+    .is_some()\n+    {\n+        return None;\n+    }\n+\n+    let source_map = cx.tcx.sess.source_map();\n+    let span = Span::new(comment_pos, comment_pos, SyntaxContext::root(), None);\n+    let help_span = source_map.span_extend_to_next_char(span, '\\n', true);\n+\n+    Some(help_span)\n+}\n+\n fn is_unsafe_from_proc_macro(cx: &LateContext<'_>, span: Span) -> bool {\n     let source_map = cx.sess().source_map();\n     let file_pos = source_map.lookup_byte_offset(span.lo());\n@@ -170,85 +342,134 @@ fn block_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n     // won't work. This is to avoid dealing with where such a comment should be place relative to\n     // attributes and doc comments.\n \n-    span_from_macro_expansion_has_safety_comment(cx, span) || span_in_body_has_safety_comment(cx, span)\n+    matches!(\n+        span_from_macro_expansion_has_safety_comment(cx, span),\n+        HasSafetyComment::Yes(_)\n+    ) || span_in_body_has_safety_comment(cx, span)\n+}\n+\n+enum HasSafetyComment {\n+    Yes(BytePos),\n+    No,\n+    Maybe,\n }\n \n /// Checks if the lines immediately preceding the item contain a safety comment.\n #[allow(clippy::collapsible_match)]\n-fn item_has_safety_comment(cx: &LateContext<'_>, item: &hir::Item<'_>) -> bool {\n-    if span_from_macro_expansion_has_safety_comment(cx, item.span) {\n-        return true;\n+fn item_has_safety_comment(cx: &LateContext<'_>, item: &hir::Item<'_>) -> HasSafetyComment {\n+    match span_from_macro_expansion_has_safety_comment(cx, item.span) {\n+        HasSafetyComment::Maybe => (),\n+        has_safety_comment => return has_safety_comment,\n     }\n \n-    if item.span.ctxt() == SyntaxContext::root() {\n-        if let Some(parent_node) = get_parent_node(cx.tcx, item.hir_id()) {\n-            let comment_start = match parent_node {\n-                Node::Crate(parent_mod) => {\n-                    comment_start_before_impl_in_mod(cx, parent_mod, parent_mod.spans.inner_span, item)\n-                },\n-                Node::Item(parent_item) => {\n-                    if let ItemKind::Mod(parent_mod) = &parent_item.kind {\n-                        comment_start_before_impl_in_mod(cx, parent_mod, parent_item.span, item)\n-                    } else {\n-                        // Doesn't support impls in this position. Pretend a comment was found.\n-                        return true;\n-                    }\n-                },\n-                Node::Stmt(stmt) => {\n-                    if let Some(stmt_parent) = get_parent_node(cx.tcx, stmt.hir_id) {\n-                        match stmt_parent {\n-                            Node::Block(block) => walk_span_to_context(block.span, SyntaxContext::root()).map(Span::lo),\n-                            _ => {\n-                                // Doesn't support impls in this position. Pretend a comment was found.\n-                                return true;\n-                            },\n-                        }\n-                    } else {\n-                        // Problem getting the parent node. Pretend a comment was found.\n-                        return true;\n-                    }\n-                },\n-                _ => {\n+    if item.span.ctxt() != SyntaxContext::root() {\n+        return HasSafetyComment::No;\n+    }\n+    if let Some(parent_node) = get_parent_node(cx.tcx, item.hir_id()) {\n+        let comment_start = match parent_node {\n+            Node::Crate(parent_mod) => {\n+                comment_start_before_item_in_mod(cx, parent_mod, parent_mod.spans.inner_span, item)\n+            },\n+            Node::Item(parent_item) => {\n+                if let ItemKind::Mod(parent_mod) = &parent_item.kind {\n+                    comment_start_before_item_in_mod(cx, parent_mod, parent_item.span, item)\n+                } else {\n                     // Doesn't support impls in this position. Pretend a comment was found.\n-                    return true;\n-                },\n-            };\n+                    return HasSafetyComment::Maybe;\n+                }\n+            },\n+            Node::Stmt(stmt) => {\n+                if let Some(Node::Block(block)) = get_parent_node(cx.tcx, stmt.hir_id) {\n+                    walk_span_to_context(block.span, SyntaxContext::root()).map(Span::lo)\n+                } else {\n+                    // Problem getting the parent node. Pretend a comment was found.\n+                    return HasSafetyComment::Maybe;\n+                }\n+            },\n+            _ => {\n+                // Doesn't support impls in this position. Pretend a comment was found.\n+                return HasSafetyComment::Maybe;\n+            },\n+        };\n \n-            let source_map = cx.sess().source_map();\n-            if let Some(comment_start) = comment_start\n-                && let Ok(unsafe_line) = source_map.lookup_line(item.span.lo())\n-                && let Ok(comment_start_line) = source_map.lookup_line(comment_start)\n-                && Lrc::ptr_eq(&unsafe_line.sf, &comment_start_line.sf)\n-                && let Some(src) = unsafe_line.sf.src.as_deref()\n-            {\n-                unsafe_line.sf.lines(|lines| {\n-                    comment_start_line.line < unsafe_line.line && text_has_safety_comment(\n+        let source_map = cx.sess().source_map();\n+        if let Some(comment_start) = comment_start\n+            && let Ok(unsafe_line) = source_map.lookup_line(item.span.lo())\n+            && let Ok(comment_start_line) = source_map.lookup_line(comment_start)\n+            && Lrc::ptr_eq(&unsafe_line.sf, &comment_start_line.sf)\n+            && let Some(src) = unsafe_line.sf.src.as_deref()\n+        {\n+            return unsafe_line.sf.lines(|lines| {\n+                if comment_start_line.line >= unsafe_line.line {\n+                    HasSafetyComment::No\n+                } else {\n+                    match text_has_safety_comment(\n                         src,\n                         &lines[comment_start_line.line + 1..=unsafe_line.line],\n                         unsafe_line.sf.start_pos.to_usize(),\n-                    )\n-                })\n-            } else {\n-                // Problem getting source text. Pretend a comment was found.\n-                true\n-            }\n-        } else {\n-            // No parent node. Pretend a comment was found.\n-            true\n+                    ) {\n+                        Some(b) => HasSafetyComment::Yes(b),\n+                        None => HasSafetyComment::No,\n+                    }\n+                }\n+            });\n+        }\n+    }\n+    HasSafetyComment::Maybe\n+}\n+\n+/// Checks if the lines immediately preceding the item contain a safety comment.\n+#[allow(clippy::collapsible_match)]\n+fn stmt_has_safety_comment(cx: &LateContext<'_>, span: Span, hir_id: HirId) -> HasSafetyComment {\n+    match span_from_macro_expansion_has_safety_comment(cx, span) {\n+        HasSafetyComment::Maybe => (),\n+        has_safety_comment => return has_safety_comment,\n+    }\n+\n+    if span.ctxt() != SyntaxContext::root() {\n+        return HasSafetyComment::No;\n+    }\n+\n+    if let Some(parent_node) = get_parent_node(cx.tcx, hir_id) {\n+        let comment_start = match parent_node {\n+            Node::Block(block) => walk_span_to_context(block.span, SyntaxContext::root()).map(Span::lo),\n+            _ => return HasSafetyComment::Maybe,\n+        };\n+\n+        let source_map = cx.sess().source_map();\n+        if let Some(comment_start) = comment_start\n+            && let Ok(unsafe_line) = source_map.lookup_line(span.lo())\n+            && let Ok(comment_start_line) = source_map.lookup_line(comment_start)\n+            && Lrc::ptr_eq(&unsafe_line.sf, &comment_start_line.sf)\n+            && let Some(src) = unsafe_line.sf.src.as_deref()\n+        {\n+            return unsafe_line.sf.lines(|lines| {\n+                if comment_start_line.line >= unsafe_line.line {\n+                    HasSafetyComment::No\n+                } else {\n+                    match text_has_safety_comment(\n+                        src,\n+                        &lines[comment_start_line.line + 1..=unsafe_line.line],\n+                        unsafe_line.sf.start_pos.to_usize(),\n+                    ) {\n+                        Some(b) => HasSafetyComment::Yes(b),\n+                        None => HasSafetyComment::No,\n+                    }\n+                }\n+            });\n         }\n-    } else {\n-        false\n     }\n+    HasSafetyComment::Maybe\n }\n \n-fn comment_start_before_impl_in_mod(\n+fn comment_start_before_item_in_mod(\n     cx: &LateContext<'_>,\n     parent_mod: &hir::Mod<'_>,\n     parent_mod_span: Span,\n-    imple: &hir::Item<'_>,\n+    item: &hir::Item<'_>,\n ) -> Option<BytePos> {\n     parent_mod.item_ids.iter().enumerate().find_map(|(idx, item_id)| {\n-        if *item_id == imple.item_id() {\n+        if *item_id == item.item_id() {\n             if idx == 0 {\n                 // mod A { /* comment */ unsafe impl T {} ... }\n                 // ^------------------------------------------^ returns the start of this span\n@@ -270,11 +491,11 @@ fn comment_start_before_impl_in_mod(\n     })\n }\n \n-fn span_from_macro_expansion_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n+fn span_from_macro_expansion_has_safety_comment(cx: &LateContext<'_>, span: Span) -> HasSafetyComment {\n     let source_map = cx.sess().source_map();\n     let ctxt = span.ctxt();\n     if ctxt == SyntaxContext::root() {\n-        false\n+        HasSafetyComment::Maybe\n     } else {\n         // From a macro expansion. Get the text from the start of the macro declaration to start of the\n         // unsafe block.\n@@ -286,15 +507,22 @@ fn span_from_macro_expansion_has_safety_comment(cx: &LateContext<'_>, span: Span\n             && let Some(src) = unsafe_line.sf.src.as_deref()\n         {\n             unsafe_line.sf.lines(|lines| {\n-                macro_line.line < unsafe_line.line && text_has_safety_comment(\n-                    src,\n-                    &lines[macro_line.line + 1..=unsafe_line.line],\n-                    unsafe_line.sf.start_pos.to_usize(),\n-                )\n+                if macro_line.line < unsafe_line.line {\n+                    match text_has_safety_comment(\n+                        src,\n+                        &lines[macro_line.line + 1..=unsafe_line.line],\n+                        unsafe_line.sf.start_pos.to_usize(),\n+                    ) {\n+                        Some(b) => HasSafetyComment::Yes(b),\n+                        None => HasSafetyComment::No,\n+                    }\n+                } else {\n+                    HasSafetyComment::No\n+                }\n             })\n         } else {\n             // Problem getting source text. Pretend a comment was found.\n-            true\n+            HasSafetyComment::Maybe\n         }\n     }\n }\n@@ -333,7 +561,7 @@ fn span_in_body_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n                     src,\n                     &lines[body_line.line + 1..=unsafe_line.line],\n                     unsafe_line.sf.start_pos.to_usize(),\n-                )\n+                ).is_some()\n             })\n         } else {\n             // Problem getting source text. Pretend a comment was found.\n@@ -345,30 +573,34 @@ fn span_in_body_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n }\n \n /// Checks if the given text has a safety comment for the immediately proceeding line.\n-fn text_has_safety_comment(src: &str, line_starts: &[BytePos], offset: usize) -> bool {\n+fn text_has_safety_comment(src: &str, line_starts: &[BytePos], offset: usize) -> Option<BytePos> {\n     let mut lines = line_starts\n         .array_windows::<2>()\n         .rev()\n         .map_while(|[start, end]| {\n             let start = start.to_usize() - offset;\n             let end = end.to_usize() - offset;\n-            src.get(start..end).map(|text| (start, text.trim_start()))\n+            let text = src.get(start..end)?;\n+            let trimmed = text.trim_start();\n+            Some((start + (text.len() - trimmed.len()), trimmed))\n         })\n         .filter(|(_, text)| !text.is_empty());\n \n     let Some((line_start, line)) = lines.next() else {\n-        return false;\n+        return None;\n     };\n     // Check for a sequence of line comments.\n     if line.starts_with(\"//\") {\n-        let mut line = line;\n+        let (mut line, mut line_start) = (line, line_start);\n         loop {\n             if line.to_ascii_uppercase().contains(\"SAFETY:\") {\n-                return true;\n+                return Some(BytePos(\n+                    u32::try_from(line_start).unwrap() + u32::try_from(offset).unwrap(),\n+                ));\n             }\n             match lines.next() {\n-                Some((_, x)) if x.starts_with(\"//\") => line = x,\n-                _ => return false,\n+                Some((s, x)) if x.starts_with(\"//\") => (line, line_start) = (x, s),\n+                _ => return None,\n             }\n         }\n     }\n@@ -377,16 +609,19 @@ fn text_has_safety_comment(src: &str, line_starts: &[BytePos], offset: usize) ->\n     let (mut line_start, mut line) = (line_start, line);\n     loop {\n         if line.starts_with(\"/*\") {\n-            let src = src[line_start..line_starts.last().unwrap().to_usize() - offset].trim_start();\n+            let src = &src[line_start..line_starts.last().unwrap().to_usize() - offset];\n             let mut tokens = tokenize(src);\n-            return src[..tokens.next().unwrap().len as usize]\n+            return (src[..tokens.next().unwrap().len as usize]\n                 .to_ascii_uppercase()\n                 .contains(\"SAFETY:\")\n-                && tokens.all(|t| t.kind == TokenKind::Whitespace);\n+                && tokens.all(|t| t.kind == TokenKind::Whitespace))\n+            .then_some(BytePos(\n+                u32::try_from(line_start).unwrap() + u32::try_from(offset).unwrap(),\n+            ));\n         }\n         match lines.next() {\n             Some(x) => (line_start, line) = x,\n-            None => return false,\n+            None => return None,\n         }\n     }\n }"}, {"sha": "863fb60fcfca1fb09aee2de418dcd9c0743d7855", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/efadb55733f1f852e18427376d3c5268139225cd/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efadb55733f1f852e18427376d3c5268139225cd/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=efadb55733f1f852e18427376d3c5268139225cd", "patch": "@@ -170,36 +170,36 @@ where\n         cb: F,\n     }\n \n-    struct WithStmtGuarg<'a, F> {\n+    struct WithStmtGuard<'a, F> {\n         val: &'a mut RetFinder<F>,\n         prev_in_stmt: bool,\n     }\n \n     impl<F> RetFinder<F> {\n-        fn inside_stmt(&mut self, in_stmt: bool) -> WithStmtGuarg<'_, F> {\n+        fn inside_stmt(&mut self, in_stmt: bool) -> WithStmtGuard<'_, F> {\n             let prev_in_stmt = std::mem::replace(&mut self.in_stmt, in_stmt);\n-            WithStmtGuarg {\n+            WithStmtGuard {\n                 val: self,\n                 prev_in_stmt,\n             }\n         }\n     }\n \n-    impl<F> std::ops::Deref for WithStmtGuarg<'_, F> {\n+    impl<F> std::ops::Deref for WithStmtGuard<'_, F> {\n         type Target = RetFinder<F>;\n \n         fn deref(&self) -> &Self::Target {\n             self.val\n         }\n     }\n \n-    impl<F> std::ops::DerefMut for WithStmtGuarg<'_, F> {\n+    impl<F> std::ops::DerefMut for WithStmtGuard<'_, F> {\n         fn deref_mut(&mut self) -> &mut Self::Target {\n             self.val\n         }\n     }\n \n-    impl<F> Drop for WithStmtGuarg<'_, F> {\n+    impl<F> Drop for WithStmtGuard<'_, F> {\n         fn drop(&mut self) {\n             self.val.in_stmt = self.prev_in_stmt;\n         }"}, {"sha": "c05eb447b2ebd34e50ef3db1197116eab83e7241", "filename": "tests/ui/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efadb55733f1f852e18427376d3c5268139225cd/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efadb55733f1f852e18427376d3c5268139225cd/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.rs?ref=efadb55733f1f852e18427376d3c5268139225cd", "patch": "@@ -1,6 +1,6 @@\n // aux-build:proc_macro_unsafe.rs\n \n-#![warn(clippy::undocumented_unsafe_blocks)]\n+#![warn(clippy::undocumented_unsafe_blocks, clippy::unnecessary_safety_comment)]\n #![allow(clippy::let_unit_value, clippy::missing_safety_doc)]\n \n extern crate proc_macro_unsafe;"}, {"sha": "d1c1bb5ffeac85eec808031e3f97ad96d82b8425", "filename": "tests/ui/undocumented_unsafe_blocks.stderr", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/efadb55733f1f852e18427376d3c5268139225cd/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efadb55733f1f852e18427376d3c5268139225cd/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.stderr?ref=efadb55733f1f852e18427376d3c5268139225cd", "patch": "@@ -239,6 +239,19 @@ LL |     unsafe impl TrailingComment for () {} // SAFETY:\n    |\n    = help: consider adding a safety comment on the preceding line\n \n+error: constant item has unnecessary safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:471:5\n+   |\n+LL |     const BIG_NUMBER: i32 = 1000000;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider removing the safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:470:5\n+   |\n+LL |     // SAFETY:\n+   |     ^^^^^^^^^^\n+   = note: `-D clippy::unnecessary-safety-comment` implied by `-D warnings`\n+\n error: unsafe impl missing a safety comment\n   --> $DIR/undocumented_unsafe_blocks.rs:472:5\n    |\n@@ -271,6 +284,24 @@ LL |         unsafe {};\n    |\n    = help: consider adding a safety comment on the preceding line\n \n+error: statement has unnecessary safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:501:5\n+   |\n+LL | /     let _ = {\n+LL | |         if unsafe { true } {\n+LL | |             todo!();\n+LL | |         } else {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |______^\n+   |\n+help: consider removing the safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:500:5\n+   |\n+LL |     // SAFETY: this is more than one level away, so it should warn\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: unsafe block missing a safety comment\n   --> $DIR/undocumented_unsafe_blocks.rs:502:12\n    |\n@@ -287,5 +318,5 @@ LL |             let bar = unsafe {};\n    |\n    = help: consider adding a safety comment on the preceding line\n \n-error: aborting due to 34 previous errors\n+error: aborting due to 36 previous errors\n "}, {"sha": "7fefea7051d698ce92aab8e5c9dc6b48242e2564", "filename": "tests/ui/unnecessary_safety_comment.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/efadb55733f1f852e18427376d3c5268139225cd/tests%2Fui%2Funnecessary_safety_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efadb55733f1f852e18427376d3c5268139225cd/tests%2Fui%2Funnecessary_safety_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_safety_comment.rs?ref=efadb55733f1f852e18427376d3c5268139225cd", "patch": "@@ -0,0 +1,51 @@\n+#![warn(clippy::undocumented_unsafe_blocks, clippy::unnecessary_safety_comment)]\n+#![allow(clippy::let_unit_value, clippy::missing_safety_doc)]\n+\n+mod unsafe_items_invalid_comment {\n+    // SAFETY:\n+    const CONST: u32 = 0;\n+    // SAFETY:\n+    static STATIC: u32 = 0;\n+    // SAFETY:\n+    struct Struct;\n+    // SAFETY:\n+    enum Enum {}\n+    // SAFETY:\n+    mod module {}\n+}\n+\n+mod unnecessary_from_macro {\n+    trait T {}\n+\n+    macro_rules! no_safety_comment {\n+        ($t:ty) => {\n+            impl T for $t {}\n+        };\n+    }\n+\n+    // FIXME: This is not caught\n+    // Safety: unnecessary\n+    no_safety_comment!(());\n+\n+    macro_rules! with_safety_comment {\n+        ($t:ty) => {\n+            // Safety: unnecessary\n+            impl T for $t {}\n+        };\n+    }\n+\n+    with_safety_comment!(i32);\n+}\n+\n+fn unnecessary_on_stmt_and_expr() -> u32 {\n+    // SAFETY: unnecessary\n+    let num = 42;\n+\n+    // SAFETY: unnecessary\n+    if num > 24 {}\n+\n+    // SAFETY: unnecessary\n+    24\n+}\n+\n+fn main() {}"}, {"sha": "7b2af67d64c7b9a7f1037dda39f4b25fc68a57ae", "filename": "tests/ui/unnecessary_safety_comment.stderr", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/efadb55733f1f852e18427376d3c5268139225cd/tests%2Fui%2Funnecessary_safety_comment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efadb55733f1f852e18427376d3c5268139225cd/tests%2Fui%2Funnecessary_safety_comment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_safety_comment.stderr?ref=efadb55733f1f852e18427376d3c5268139225cd", "patch": "@@ -0,0 +1,115 @@\n+error: constant item has unnecessary safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:6:5\n+   |\n+LL |     const CONST: u32 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider removing the safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:5:5\n+   |\n+LL |     // SAFETY:\n+   |     ^^^^^^^^^^\n+   = note: `-D clippy::unnecessary-safety-comment` implied by `-D warnings`\n+\n+error: static item has unnecessary safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:8:5\n+   |\n+LL |     static STATIC: u32 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider removing the safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:7:5\n+   |\n+LL |     // SAFETY:\n+   |     ^^^^^^^^^^\n+\n+error: struct has unnecessary safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:10:5\n+   |\n+LL |     struct Struct;\n+   |     ^^^^^^^^^^^^^^\n+   |\n+help: consider removing the safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:9:5\n+   |\n+LL |     // SAFETY:\n+   |     ^^^^^^^^^^\n+\n+error: enum has unnecessary safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:12:5\n+   |\n+LL |     enum Enum {}\n+   |     ^^^^^^^^^^^^\n+   |\n+help: consider removing the safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:11:5\n+   |\n+LL |     // SAFETY:\n+   |     ^^^^^^^^^^\n+\n+error: module has unnecessary safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:14:5\n+   |\n+LL |     mod module {}\n+   |     ^^^^^^^^^^^^^\n+   |\n+help: consider removing the safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:13:5\n+   |\n+LL |     // SAFETY:\n+   |     ^^^^^^^^^^\n+\n+error: impl has unnecessary safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:33:13\n+   |\n+LL |             impl T for $t {}\n+   |             ^^^^^^^^^^^^^^^^\n+...\n+LL |     with_safety_comment!(i32);\n+   |     ------------------------- in this macro invocation\n+   |\n+help: consider removing the safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:32:13\n+   |\n+LL |             // Safety: unnecessary\n+   |             ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in the macro `with_safety_comment` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: expression has unnecessary safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:48:5\n+   |\n+LL |     24\n+   |     ^^\n+   |\n+help: consider removing the safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:47:5\n+   |\n+LL |     // SAFETY: unnecessary\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: statement has unnecessary safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:42:5\n+   |\n+LL |     let num = 42;\n+   |     ^^^^^^^^^^^^^\n+   |\n+help: consider removing the safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:41:5\n+   |\n+LL |     // SAFETY: unnecessary\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: statement has unnecessary safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:45:5\n+   |\n+LL |     if num > 24 {}\n+   |     ^^^^^^^^^^^^^^\n+   |\n+help: consider removing the safety comment\n+  --> $DIR/unnecessary_safety_comment.rs:44:5\n+   |\n+LL |     // SAFETY: unnecessary\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 9 previous errors\n+"}]}