{"sha": "5f2486e9a84f0850e6e9f57e590693926f85eb43", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMjQ4NmU5YTg0ZjA4NTBlNmU5ZjU3ZTU5MDY5MzkyNmY4NWViNDM=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-06-15T18:28:37Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-08-04T15:20:10Z"}, "message": "Handle `impl ?Sized`. Fix tests.", "tree": {"sha": "78512d50d565f4134990d02896846b48ca208b8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78512d50d565f4134990d02896846b48ca208b8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f2486e9a84f0850e6e9f57e590693926f85eb43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f2486e9a84f0850e6e9f57e590693926f85eb43", "html_url": "https://github.com/rust-lang/rust/commit/5f2486e9a84f0850e6e9f57e590693926f85eb43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f2486e9a84f0850e6e9f57e590693926f85eb43/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "421979bc686216937b54b5895210576fe5f60dbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/421979bc686216937b54b5895210576fe5f60dbb", "html_url": "https://github.com/rust-lang/rust/commit/421979bc686216937b54b5895210576fe5f60dbb"}], "stats": {"total": 682, "additions": 352, "deletions": 330}, "files": [{"sha": "dff4372738b7f3025e329ccaeed76e23b774803d", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f2486e9a84f0850e6e9f57e590693926f85eb43/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2486e9a84f0850e6e9f57e590693926f85eb43/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=5f2486e9a84f0850e6e9f57e590693926f85eb43", "patch": "@@ -239,7 +239,8 @@ impl HirDisplay for TypeParam {\n         let predicates =\n             bounds.iter().cloned().map(|b| b.substitute(&Interner, &substs)).collect::<Vec<_>>();\n         if !(predicates.is_empty() || f.omit_verbose_types()) {\n-            write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, SizedByDefault::Sized, f)?;\n+            let default_sized = SizedByDefault::Sized { anchor: self.module(f.db).krate().id };\n+            write_bounds_like_dyn_trait_with_prefix(\":\", &predicates, default_sized, f)?;\n         }\n         Ok(())\n     }"}, {"sha": "6a8fd2dd4d9ac41e695687e02e738c3c909b1960", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5f2486e9a84f0850e6e9f57e590693926f85eb43/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2486e9a84f0850e6e9f57e590693926f85eb43/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=5f2486e9a84f0850e6e9f57e590693926f85eb43", "patch": "@@ -4,6 +4,7 @@\n \n use std::fmt::{self, Debug};\n \n+use base_db::CrateId;\n use chalk_ir::BoundVar;\n use hir_def::{\n     body,\n@@ -15,7 +16,7 @@ use hir_def::{\n     path::{Path, PathKind},\n     type_ref::{TraitBoundModifier, TypeBound, TypeRef},\n     visibility::Visibility,\n-    AssocContainerId, Lookup, ModuleId, TraitId,\n+    AssocContainerId, HasModule, Lookup, ModuleId, TraitId,\n };\n use hir_expand::{hygiene::Hygiene, name::Name};\n use itertools::Itertools;\n@@ -582,10 +583,11 @@ impl HirDisplay for Ty {\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n                         let bounds = data.substitute(&Interner, &parameters);\n+                        let krate = func.lookup(f.db.upcast()).module(f.db.upcast()).krate();\n                         write_bounds_like_dyn_trait_with_prefix(\n                             \"impl\",\n                             bounds.skip_binders(),\n-                            SizedByDefault::Sized,\n+                            SizedByDefault::Sized { anchor: krate },\n                             f,\n                         )?;\n                         // FIXME: it would maybe be good to distinguish this from the alias type (when debug printing), and to show the substitution\n@@ -646,10 +648,11 @@ impl HirDisplay for Ty {\n                                     _ => false,\n                                 })\n                                 .collect::<Vec<_>>();\n+                        let krate = id.parent.module(f.db.upcast()).krate();\n                         write_bounds_like_dyn_trait_with_prefix(\n                             \"impl\",\n                             &bounds,\n-                            SizedByDefault::Sized,\n+                            SizedByDefault::Sized { anchor: krate },\n                             f,\n                         )?;\n                     }\n@@ -675,10 +678,11 @@ impl HirDisplay for Ty {\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n                         let bounds = data.substitute(&Interner, &opaque_ty.substitution);\n+                        let krate = func.lookup(f.db.upcast()).module(f.db.upcast()).krate();\n                         write_bounds_like_dyn_trait_with_prefix(\n                             \"impl\",\n                             bounds.skip_binders(),\n-                            SizedByDefault::Sized,\n+                            SizedByDefault::Sized { anchor: krate },\n                             f,\n                         )?;\n                     }\n@@ -729,17 +733,23 @@ fn fn_traits(db: &dyn DefDatabase, trait_: TraitId) -> impl Iterator<Item = Trai\n     utils::fn_traits(db, krate)\n }\n \n-fn is_sized_trait(db: &dyn DefDatabase, trait_: TraitId) -> Option<bool> {\n-    let krate = trait_.lookup(db).container.krate();\n-    let sized_trait =\n-        db.lang_item(krate, \"sized\".into()).and_then(|lang_item| lang_item.as_trait())?;\n-    Some(trait_ == sized_trait)\n-}\n-\n #[derive(Clone, Copy, PartialEq, Eq)]\n pub enum SizedByDefault {\n     NotSized,\n-    Sized,\n+    Sized { anchor: CrateId },\n+}\n+\n+impl SizedByDefault {\n+    fn is_sized_trait(self, trait_: TraitId, db: &dyn DefDatabase) -> bool {\n+        match self {\n+            Self::NotSized => false,\n+            Self::Sized { anchor } => {\n+                let sized_trait =\n+                    db.lang_item(anchor, \"sized\".into()).and_then(|lang_item| lang_item.as_trait());\n+                Some(trait_) == sized_trait\n+            }\n+        }\n+    }\n }\n \n pub fn write_bounds_like_dyn_trait_with_prefix(\n@@ -749,7 +759,9 @@ pub fn write_bounds_like_dyn_trait_with_prefix(\n     f: &mut HirFormatter,\n ) -> Result<(), HirDisplayError> {\n     write!(f, \"{}\", prefix)?;\n-    if !predicates.is_empty() {\n+    if !predicates.is_empty()\n+        || predicates.is_empty() && matches!(default_sized, SizedByDefault::Sized { .. })\n+    {\n         write!(f, \" \")?;\n         write_bounds_like_dyn_trait(predicates, default_sized, f)\n     } else {\n@@ -771,22 +783,18 @@ fn write_bounds_like_dyn_trait(\n     let mut first = true;\n     let mut angle_open = false;\n     let mut is_fn_trait = false;\n-    let mut is_sized = None;\n+    let mut is_sized = false;\n     for p in predicates.iter() {\n         match p.skip_binders() {\n             WhereClause::Implemented(trait_ref) => {\n                 let trait_ = trait_ref.hir_trait_id();\n-                match is_sized_trait(f.db.upcast(), trait_) {\n-                    Some(true) => {\n-                        is_sized = Some(true);\n-                        if default_sized == SizedByDefault::Sized {\n+                if default_sized.is_sized_trait(trait_, f.db.upcast()) {\n+                    is_sized = true;\n+                    if matches!(default_sized, SizedByDefault::Sized { .. }) {\n                             // Don't print +Sized, but rather +?Sized if absent.\n                             continue;\n                         }\n                     }\n-                    Some(false) => is_sized = is_sized.or(Some(false)),\n-                    None => (),\n-                }\n                 if !is_fn_trait {\n                     is_fn_trait = fn_traits(f.db.upcast(), trait_).any(|it| it == trait_);\n                 }\n@@ -851,8 +859,8 @@ fn write_bounds_like_dyn_trait(\n     if angle_open {\n         write!(f, \">\")?;\n     }\n-    if default_sized == SizedByDefault::Sized && is_sized.is_some() {\n-        if is_sized == Some(false) {\n+    if matches!(default_sized, SizedByDefault::Sized { .. }) {\n+        if !is_sized {\n             write!(f, \"{}?Sized\", if first { \"\" } else { \" + \" })?;\n         } else if first {\n             write!(f, \"Sized\")?;"}, {"sha": "a6ece667e10e3bc6d01371406eea7785dc48da34", "filename": "crates/hir_ty/src/tests/display_source_code.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5f2486e9a84f0850e6e9f57e590693926f85eb43/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2486e9a84f0850e6e9f57e590693926f85eb43/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=5f2486e9a84f0850e6e9f57e590693926f85eb43", "patch": "@@ -42,15 +42,16 @@ fn main() {\n \n #[test]\n fn render_raw_ptr_impl_ty() {\n+    // FIXME: remove parens, they apper because there is an implicit Sized bound\n     check_types_source_code(\n         r#\"\n-trait Sized {}\n+#[lang = \"sized\"] trait Sized {}\n trait Unpin {}\n-fn foo() -> *const (impl Unpin + Sized) { loop {} }\n+fn foo() -> *const impl Unpin { loop {} }\n fn main() {\n     let foo = foo();\n     foo;\n-} //^^^ *const (impl Unpin + Sized)\n+} //^^^ *const (impl Unpin)\n \"#,\n     );\n }\n@@ -72,8 +73,7 @@ fn foo(foo: &dyn for<'a> Foo<'a>) {}\n fn sized_bounds_apit() {\n     check_types_source_code(\n         r#\"\n-#[lang = \"sized\"]\n-pub trait Sized {}\n+#[lang = \"sized\"] trait Sized {}\n \n trait Foo {}\n trait Bar<T> {}\n@@ -83,7 +83,7 @@ fn test(\n     b: impl Foo + Sized,\n     c: &(impl Foo + ?Sized),\n     d: S<impl Foo>,\n-    e: impl Bar<impl Foo>,\n+    ref_any: &impl ?Sized,\n     empty: impl,\n ) {\n     a;\n@@ -94,8 +94,8 @@ fn test(\n   //^ &impl Foo + ?Sized\n     d;\n   //^ S<impl Foo>\n-    e;\n-  //^ impl Bar<impl Foo>\n+    ref_any;\n+  //^ &impl ?Sized\n     empty;\n } //^ impl Sized\n \"#,\n@@ -106,8 +106,7 @@ fn test(\n fn sized_bounds_rpit() {\n     check_types_source_code(\n         r#\"\n-#[lang = \"sized\"]\n-pub trait Sized {}\n+#[lang = \"sized\"] trait Sized {}\n \n trait Foo {}\n fn foo() -> impl Foo { loop {} }\n@@ -123,8 +122,7 @@ fn test<T: Foo>() {\n fn sized_bounds_impl_traits_in_fn_signature() {\n     check_types_source_code(\n         r#\"\n-#[lang = \"sized\"]\n-pub trait Sized {}\n+#[lang = \"sized\"] trait Sized {}\n \n trait Foo {}\n fn test("}, {"sha": "1f090ccc44d7c8244f8080fe9dfa8105eb4e1df1", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5f2486e9a84f0850e6e9f57e590693926f85eb43/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2486e9a84f0850e6e9f57e590693926f85eb43/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=5f2486e9a84f0850e6e9f57e590693926f85eb43", "patch": "@@ -922,6 +922,7 @@ fn test() { foo.call(); }\n fn super_trait_impl_return_trait_method_resolution() {\n     check_infer(\n         r#\"\n+        #[lang = \"sized\"] trait Sized {}\n         trait Base {\n             fn foo(self) -> usize;\n         }\n@@ -939,26 +940,26 @@ fn super_trait_impl_return_trait_method_resolution() {\n         }\n         \"#,\n         expect![[r#\"\n-            24..28 'self': Self\n-            90..101 '{ loop {} }': !\n-            92..99 'loop {}': !\n-            97..99 '{}': ()\n-            128..139 '{ loop {} }': !\n-            130..137 'loop {}': !\n-            135..137 '{}': ()\n-            149..154 'base2': impl Base\n-            167..173 'super2': impl Super\n-            187..264 '{     ...o(); }': ()\n-            193..198 'base1': fn base1() -> impl Base\n-            193..200 'base1()': impl Base\n-            193..206 'base1().foo()': usize\n-            212..218 'super1': fn super1() -> impl Super\n-            212..220 'super1()': impl Super\n-            212..226 'super1().foo()': usize\n-            232..237 'base2': impl Base\n-            232..243 'base2.foo()': usize\n-            249..255 'super2': impl Super\n-            249..261 'super2.foo()': usize\n+            57..61 'self': Self\n+            123..134 '{ loop {} }': !\n+            125..132 'loop {}': !\n+            130..132 '{}': ()\n+            161..172 '{ loop {} }': !\n+            163..170 'loop {}': !\n+            168..170 '{}': ()\n+            182..187 'base2': impl Base\n+            200..206 'super2': impl Super\n+            220..297 '{     ...o(); }': ()\n+            226..231 'base1': fn base1() -> impl Base\n+            226..233 'base1()': impl Base\n+            226..239 'base1().foo()': usize\n+            245..251 'super1': fn super1() -> impl Super\n+            245..253 'super1()': impl Super\n+            245..259 'super1().foo()': usize\n+            265..270 'base2': impl Base\n+            265..276 'base2.foo()': usize\n+            282..288 'super2': impl Super\n+            282..294 'super2.foo()': usize\n         \"#]],\n     );\n }"}, {"sha": "37257655ddbd7124b6b5cd79c0570a2b96b19d54", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 288, "deletions": 274, "changes": 562, "blob_url": "https://github.com/rust-lang/rust/blob/5f2486e9a84f0850e6e9f57e590693926f85eb43/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f2486e9a84f0850e6e9f57e590693926f85eb43/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=5f2486e9a84f0850e6e9f57e590693926f85eb43", "patch": "@@ -845,6 +845,7 @@ fn test<T: ApplyL>(t: T) {\n fn argument_impl_trait() {\n     check_infer_with_mismatches(\n         r#\"\n+#[lang = \"sized\"] trait Sized {}\n trait Trait<T> {\n     fn foo(&self) -> T;\n     fn foo2(&self) -> i64;\n@@ -866,34 +867,34 @@ fn test(x: impl Trait<u64>, y: &impl Trait<u32>) {\n     z.foo2();\n }\"#,\n         expect![[r#\"\n-            29..33 'self': &Self\n-            54..58 'self': &Self\n-            77..78 'x': impl Trait<u16>\n-            97..99 '{}': ()\n-            154..155 'x': impl Trait<u64>\n-            174..175 'y': &impl Trait<u32>\n-            195..323 '{     ...2(); }': ()\n-            201..202 'x': impl Trait<u64>\n-            208..209 'y': &impl Trait<u32>\n-            219..220 'z': S<u16>\n-            223..224 'S': S<u16>(u16) -> S<u16>\n-            223..227 'S(1)': S<u16>\n-            225..226 '1': u16\n-            233..236 'bar': fn bar(S<u16>)\n-            233..239 'bar(z)': ()\n-            237..238 'z': S<u16>\n-            245..246 'x': impl Trait<u64>\n-            245..252 'x.foo()': u64\n-            258..259 'y': &impl Trait<u32>\n-            258..265 'y.foo()': u32\n-            271..272 'z': S<u16>\n-            271..278 'z.foo()': u16\n-            284..285 'x': impl Trait<u64>\n-            284..292 'x.foo2()': i64\n-            298..299 'y': &impl Trait<u32>\n-            298..306 'y.foo2()': i64\n-            312..313 'z': S<u16>\n-            312..320 'z.foo2()': i64\n+            62..66 'self': &Self\n+            87..91 'self': &Self\n+            110..111 'x': impl Trait<u16>\n+            130..132 '{}': ()\n+            187..188 'x': impl Trait<u64>\n+            207..208 'y': &impl Trait<u32>\n+            228..356 '{     ...2(); }': ()\n+            234..235 'x': impl Trait<u64>\n+            241..242 'y': &impl Trait<u32>\n+            252..253 'z': S<u16>\n+            256..257 'S': S<u16>(u16) -> S<u16>\n+            256..260 'S(1)': S<u16>\n+            258..259 '1': u16\n+            266..269 'bar': fn bar(S<u16>)\n+            266..272 'bar(z)': ()\n+            270..271 'z': S<u16>\n+            278..279 'x': impl Trait<u64>\n+            278..285 'x.foo()': u64\n+            291..292 'y': &impl Trait<u32>\n+            291..298 'y.foo()': u32\n+            304..305 'z': S<u16>\n+            304..311 'z.foo()': u16\n+            317..318 'x': impl Trait<u64>\n+            317..325 'x.foo2()': i64\n+            331..332 'y': &impl Trait<u32>\n+            331..339 'y.foo2()': i64\n+            345..346 'z': S<u16>\n+            345..353 'z.foo2()': i64\n         \"#]],\n     );\n }\n@@ -902,6 +903,7 @@ fn test(x: impl Trait<u64>, y: &impl Trait<u32>) {\n fn argument_impl_trait_type_args_1() {\n     check_infer_with_mismatches(\n         r#\"\n+#[lang = \"sized\"] trait Sized {}\n trait Trait {}\n trait Foo {\n     // this function has an implicit Self param, an explicit type param,\n@@ -926,39 +928,39 @@ fn test() {\n     foo::<u32, i32>(S); // we should ignore the extraneous i32\n }\"#,\n         expect![[r#\"\n-            155..156 'x': impl Trait\n-            175..186 '{ loop {} }': T\n-            177..184 'loop {}': !\n-            182..184 '{}': ()\n-            199..200 'x': impl Trait\n-            219..230 '{ loop {} }': T\n-            221..228 'loop {}': !\n-            226..228 '{}': ()\n-            300..509 '{     ... i32 }': ()\n-            306..314 'Foo::bar': fn bar<{unknown}, {unknown}>(S) -> {unknown}\n-            306..317 'Foo::bar(S)': {unknown}\n-            315..316 'S': S\n-            323..338 '<F as Foo>::bar': fn bar<F, {unknown}>(S) -> {unknown}\n-            323..341 '<F as ...bar(S)': {unknown}\n-            339..340 'S': S\n-            347..353 'F::bar': fn bar<F, {unknown}>(S) -> {unknown}\n-            347..356 'F::bar(S)': {unknown}\n-            354..355 'S': S\n-            362..377 'Foo::bar::<u32>': fn bar<{unknown}, u32>(S) -> u32\n-            362..380 'Foo::b...32>(S)': u32\n-            378..379 'S': S\n-            386..408 '<F as ...:<u32>': fn bar<F, u32>(S) -> u32\n-            386..411 '<F as ...32>(S)': u32\n-            409..410 'S': S\n-            418..421 'foo': fn foo<{unknown}>(S) -> {unknown}\n-            418..424 'foo(S)': {unknown}\n-            422..423 'S': S\n-            430..440 'foo::<u32>': fn foo<u32>(S) -> u32\n-            430..443 'foo::<u32>(S)': u32\n-            441..442 'S': S\n-            449..464 'foo::<u32, i32>': fn foo<u32>(S) -> u32\n-            449..467 'foo::<...32>(S)': u32\n-            465..466 'S': S\n+            188..189 'x': impl Trait\n+            208..219 '{ loop {} }': T\n+            210..217 'loop {}': !\n+            215..217 '{}': ()\n+            232..233 'x': impl Trait\n+            252..263 '{ loop {} }': T\n+            254..261 'loop {}': !\n+            259..261 '{}': ()\n+            333..542 '{     ... i32 }': ()\n+            339..347 'Foo::bar': fn bar<{unknown}, {unknown}>(S) -> {unknown}\n+            339..350 'Foo::bar(S)': {unknown}\n+            348..349 'S': S\n+            356..371 '<F as Foo>::bar': fn bar<F, {unknown}>(S) -> {unknown}\n+            356..374 '<F as ...bar(S)': {unknown}\n+            372..373 'S': S\n+            380..386 'F::bar': fn bar<F, {unknown}>(S) -> {unknown}\n+            380..389 'F::bar(S)': {unknown}\n+            387..388 'S': S\n+            395..410 'Foo::bar::<u32>': fn bar<{unknown}, u32>(S) -> u32\n+            395..413 'Foo::b...32>(S)': u32\n+            411..412 'S': S\n+            419..441 '<F as ...:<u32>': fn bar<F, u32>(S) -> u32\n+            419..444 '<F as ...32>(S)': u32\n+            442..443 'S': S\n+            451..454 'foo': fn foo<{unknown}>(S) -> {unknown}\n+            451..457 'foo(S)': {unknown}\n+            455..456 'S': S\n+            463..473 'foo::<u32>': fn foo<u32>(S) -> u32\n+            463..476 'foo::<u32>(S)': u32\n+            474..475 'S': S\n+            482..497 'foo::<u32, i32>': fn foo<u32>(S) -> u32\n+            482..500 'foo::<...32>(S)': u32\n+            498..499 'S': S\n         \"#]],\n     );\n }\n@@ -967,6 +969,7 @@ fn test() {\n fn argument_impl_trait_type_args_2() {\n     check_infer_with_mismatches(\n         r#\"\n+#[lang = \"sized\"] trait Sized {}\n trait Trait {}\n struct S;\n impl Trait for S {}\n@@ -982,24 +985,24 @@ fn test() {\n     F::<u32>.foo::<i32, u32>(S); // extraneous argument should be ignored\n }\"#,\n         expect![[r#\"\n-            87..91 'self': F<T>\n-            93..94 'x': impl Trait\n-            118..129 '{ loop {} }': (T, U)\n-            120..127 'loop {}': !\n-            125..127 '{}': ()\n-            143..283 '{     ...ored }': ()\n-            149..150 'F': F<{unknown}>\n-            149..157 'F.foo(S)': ({unknown}, {unknown})\n-            155..156 'S': S\n-            163..171 'F::<u32>': F<u32>\n-            163..178 'F::<u32>.foo(S)': (u32, {unknown})\n-            176..177 'S': S\n-            184..192 'F::<u32>': F<u32>\n-            184..206 'F::<u3...32>(S)': (u32, i32)\n-            204..205 'S': S\n-            212..220 'F::<u32>': F<u32>\n-            212..239 'F::<u3...32>(S)': (u32, i32)\n+            120..124 'self': F<T>\n+            126..127 'x': impl Trait\n+            151..162 '{ loop {} }': (T, U)\n+            153..160 'loop {}': !\n+            158..160 '{}': ()\n+            176..316 '{     ...ored }': ()\n+            182..183 'F': F<{unknown}>\n+            182..190 'F.foo(S)': ({unknown}, {unknown})\n+            188..189 'S': S\n+            196..204 'F::<u32>': F<u32>\n+            196..211 'F::<u32>.foo(S)': (u32, {unknown})\n+            209..210 'S': S\n+            217..225 'F::<u32>': F<u32>\n+            217..239 'F::<u3...32>(S)': (u32, i32)\n             237..238 'S': S\n+            245..253 'F::<u32>': F<u32>\n+            245..272 'F::<u3...32>(S)': (u32, i32)\n+            270..271 'S': S\n         \"#]],\n     );\n }\n@@ -1008,6 +1011,7 @@ fn test() {\n fn argument_impl_trait_to_fn_pointer() {\n     check_infer_with_mismatches(\n         r#\"\n+#[lang = \"sized\"] trait Sized {}\n trait Trait {}\n fn foo(x: impl Trait) { loop {} }\n struct S;\n@@ -1017,13 +1021,13 @@ fn test() {\n     let f: fn(S) -> () = foo;\n }\"#,\n         expect![[r#\"\n-            22..23 'x': impl Trait\n-            37..48 '{ loop {} }': ()\n-            39..46 'loop {}': !\n-            44..46 '{}': ()\n-            90..123 '{     ...foo; }': ()\n-            100..101 'f': fn(S)\n-            117..120 'foo': fn foo(S)\n+            55..56 'x': impl Trait\n+            70..81 '{ loop {} }': ()\n+            72..79 'loop {}': !\n+            77..79 '{}': ()\n+            123..156 '{     ...foo; }': ()\n+            133..134 'f': fn(S)\n+            150..153 'foo': fn foo(S)\n         \"#]],\n     );\n }\n@@ -1032,6 +1036,7 @@ fn test() {\n fn impl_trait() {\n     check_infer(\n         r#\"\n+#[lang = \"sized\"] trait Sized {}\n trait Trait<T> {\n     fn foo(&self) -> T;\n     fn foo2(&self) -> i64;\n@@ -1050,29 +1055,29 @@ fn test(x: impl Trait<u64>, y: &impl Trait<u64>) {\n     z.foo2();\n }\"#,\n         expect![[r#\"\n-            29..33 'self': &Self\n-            54..58 'self': &Self\n-            98..100 '{}': ()\n-            110..111 'x': impl Trait<u64>\n-            130..131 'y': &impl Trait<u64>\n-            151..268 '{     ...2(); }': ()\n-            157..158 'x': impl Trait<u64>\n-            164..165 'y': &impl Trait<u64>\n-            175..176 'z': impl Trait<u64>\n-            179..182 'bar': fn bar() -> impl Trait<u64>\n-            179..184 'bar()': impl Trait<u64>\n+            62..66 'self': &Self\n+            87..91 'self': &Self\n+            131..133 '{}': ()\n+            143..144 'x': impl Trait<u64>\n+            163..164 'y': &impl Trait<u64>\n+            184..301 '{     ...2(); }': ()\n             190..191 'x': impl Trait<u64>\n-            190..197 'x.foo()': u64\n-            203..204 'y': &impl Trait<u64>\n-            203..210 'y.foo()': u64\n-            216..217 'z': impl Trait<u64>\n-            216..223 'z.foo()': u64\n-            229..230 'x': impl Trait<u64>\n-            229..237 'x.foo2()': i64\n-            243..244 'y': &impl Trait<u64>\n-            243..251 'y.foo2()': i64\n-            257..258 'z': impl Trait<u64>\n-            257..265 'z.foo2()': i64\n+            197..198 'y': &impl Trait<u64>\n+            208..209 'z': impl Trait<u64>\n+            212..215 'bar': fn bar() -> impl Trait<u64>\n+            212..217 'bar()': impl Trait<u64>\n+            223..224 'x': impl Trait<u64>\n+            223..230 'x.foo()': u64\n+            236..237 'y': &impl Trait<u64>\n+            236..243 'y.foo()': u64\n+            249..250 'z': impl Trait<u64>\n+            249..256 'z.foo()': u64\n+            262..263 'x': impl Trait<u64>\n+            262..270 'x.foo2()': i64\n+            276..277 'y': &impl Trait<u64>\n+            276..284 'y.foo2()': i64\n+            290..291 'z': impl Trait<u64>\n+            290..298 'z.foo2()': i64\n         \"#]],\n     );\n }\n@@ -1082,6 +1087,7 @@ fn simple_return_pos_impl_trait() {\n     cov_mark::check!(lower_rpit);\n     check_infer(\n         r#\"\n+#[lang = \"sized\"] trait Sized {}\n trait Trait<T> {\n     fn foo(&self) -> T;\n }\n@@ -1092,16 +1098,16 @@ fn test() {\n     a.foo();\n }\"#,\n         expect![[r#\"\n-            29..33 'self': &Self\n-            71..82 '{ loop {} }': !\n-            73..80 'loop {}': !\n-            78..80 '{}': ()\n-            94..129 '{     ...o(); }': ()\n-            104..105 'a': impl Trait<u64>\n-            108..111 'bar': fn bar() -> impl Trait<u64>\n-            108..113 'bar()': impl Trait<u64>\n-            119..120 'a': impl Trait<u64>\n-            119..126 'a.foo()': u64\n+            62..66 'self': &Self\n+            104..115 '{ loop {} }': !\n+            106..113 'loop {}': !\n+            111..113 '{}': ()\n+            127..162 '{     ...o(); }': ()\n+            137..138 'a': impl Trait<u64>\n+            141..144 'bar': fn bar() -> impl Trait<u64>\n+            141..146 'bar()': impl Trait<u64>\n+            152..153 'a': impl Trait<u64>\n+            152..159 'a.foo()': u64\n         \"#]],\n     );\n }\n@@ -1110,6 +1116,7 @@ fn test() {\n fn more_return_pos_impl_trait() {\n     check_infer(\n         r#\"\n+#[lang = \"sized\"] trait Sized {}\n trait Iterator {\n     type Item;\n     fn next(&mut self) -> Self::Item;\n@@ -1129,37 +1136,37 @@ fn test() {\n     d.foo();\n }\"#,\n         expect![[r#\"\n-            49..53 'self': &mut Self\n-            101..105 'self': &Self\n-            184..195 '{ loop {} }': ({unknown}, {unknown})\n-            186..193 'loop {}': !\n-            191..193 '{}': ()\n-            206..207 't': T\n-            268..279 '{ loop {} }': ({unknown}, {unknown})\n-            270..277 'loop {}': !\n-            275..277 '{}': ()\n-            291..413 '{     ...o(); }': ()\n-            301..307 '(a, b)': (impl Iterator<Item = impl Trait<u32>>, impl Trait<u64>)\n-            302..303 'a': impl Iterator<Item = impl Trait<u32>>\n-            305..306 'b': impl Trait<u64>\n-            310..313 'bar': fn bar() -> (impl Iterator<Item = impl Trait<u32>>, impl Trait<u64>)\n-            310..315 'bar()': (impl Iterator<Item = impl Trait<u32>>, impl Trait<u64>)\n-            321..322 'a': impl Iterator<Item = impl Trait<u32>>\n-            321..329 'a.next()': impl Trait<u32>\n-            321..335 'a.next().foo()': u32\n-            341..342 'b': impl Trait<u64>\n-            341..348 'b.foo()': u64\n-            358..364 '(c, d)': (impl Iterator<Item = impl Trait<u128>>, impl Trait<u128>)\n-            359..360 'c': impl Iterator<Item = impl Trait<u128>>\n-            362..363 'd': impl Trait<u128>\n-            367..370 'baz': fn baz<u128>(u128) -> (impl Iterator<Item = impl Trait<u128>>, impl Trait<u128>)\n-            367..377 'baz(1u128)': (impl Iterator<Item = impl Trait<u128>>, impl Trait<u128>)\n-            371..376 '1u128': u128\n-            383..384 'c': impl Iterator<Item = impl Trait<u128>>\n-            383..391 'c.next()': impl Trait<u128>\n-            383..397 'c.next().foo()': u128\n-            403..404 'd': impl Trait<u128>\n-            403..410 'd.foo()': u128\n+            82..86 'self': &mut Self\n+            134..138 'self': &Self\n+            217..228 '{ loop {} }': ({unknown}, {unknown})\n+            219..226 'loop {}': !\n+            224..226 '{}': ()\n+            239..240 't': T\n+            301..312 '{ loop {} }': ({unknown}, {unknown})\n+            303..310 'loop {}': !\n+            308..310 '{}': ()\n+            324..446 '{     ...o(); }': ()\n+            334..340 '(a, b)': (impl Iterator<Item = impl Trait<u32>>, impl Trait<u64>)\n+            335..336 'a': impl Iterator<Item = impl Trait<u32>>\n+            338..339 'b': impl Trait<u64>\n+            343..346 'bar': fn bar() -> (impl Iterator<Item = impl Trait<u32>>, impl Trait<u64>)\n+            343..348 'bar()': (impl Iterator<Item = impl Trait<u32>>, impl Trait<u64>)\n+            354..355 'a': impl Iterator<Item = impl Trait<u32>>\n+            354..362 'a.next()': impl Trait<u32>\n+            354..368 'a.next().foo()': u32\n+            374..375 'b': impl Trait<u64>\n+            374..381 'b.foo()': u64\n+            391..397 '(c, d)': (impl Iterator<Item = impl Trait<u128>>, impl Trait<u128>)\n+            392..393 'c': impl Iterator<Item = impl Trait<u128>>\n+            395..396 'd': impl Trait<u128>\n+            400..403 'baz': fn baz<u128>(u128) -> (impl Iterator<Item = impl Trait<u128>>, impl Trait<u128>)\n+            400..410 'baz(1u128)': (impl Iterator<Item = impl Trait<u128>>, impl Trait<u128>)\n+            404..409 '1u128': u128\n+            416..417 'c': impl Iterator<Item = impl Trait<u128>>\n+            416..424 'c.next()': impl Trait<u128>\n+            416..430 'c.next().foo()': u128\n+            436..437 'd': impl Trait<u128>\n+            436..443 'd.foo()': u128\n         \"#]],\n     );\n }\n@@ -1168,6 +1175,7 @@ fn test() {\n fn dyn_trait() {\n     check_infer(\n         r#\"\n+#[lang = \"sized\"] trait Sized {}\n trait Trait<T> {\n     fn foo(&self) -> T;\n     fn foo2(&self) -> i64;\n@@ -1186,29 +1194,29 @@ fn test(x: dyn Trait<u64>, y: &dyn Trait<u64>) {\n     z.foo2();\n }\"#,\n         expect![[r#\"\n-            29..33 'self': &Self\n-            54..58 'self': &Self\n-            97..99 '{}': ()\n-            109..110 'x': dyn Trait<u64>\n-            128..129 'y': &dyn Trait<u64>\n-            148..265 '{     ...2(); }': ()\n-            154..155 'x': dyn Trait<u64>\n+            62..66 'self': &Self\n+            87..91 'self': &Self\n+            130..132 '{}': ()\n+            142..143 'x': dyn Trait<u64>\n             161..162 'y': &dyn Trait<u64>\n-            172..173 'z': dyn Trait<u64>\n-            176..179 'bar': fn bar() -> dyn Trait<u64>\n-            176..181 'bar()': dyn Trait<u64>\n+            181..298 '{     ...2(); }': ()\n             187..188 'x': dyn Trait<u64>\n-            187..194 'x.foo()': u64\n-            200..201 'y': &dyn Trait<u64>\n-            200..207 'y.foo()': u64\n-            213..214 'z': dyn Trait<u64>\n-            213..220 'z.foo()': u64\n-            226..227 'x': dyn Trait<u64>\n-            226..234 'x.foo2()': i64\n-            240..241 'y': &dyn Trait<u64>\n-            240..248 'y.foo2()': i64\n-            254..255 'z': dyn Trait<u64>\n-            254..262 'z.foo2()': i64\n+            194..195 'y': &dyn Trait<u64>\n+            205..206 'z': dyn Trait<u64>\n+            209..212 'bar': fn bar() -> dyn Trait<u64>\n+            209..214 'bar()': dyn Trait<u64>\n+            220..221 'x': dyn Trait<u64>\n+            220..227 'x.foo()': u64\n+            233..234 'y': &dyn Trait<u64>\n+            233..240 'y.foo()': u64\n+            246..247 'z': dyn Trait<u64>\n+            246..253 'z.foo()': u64\n+            259..260 'x': dyn Trait<u64>\n+            259..267 'x.foo2()': i64\n+            273..274 'y': &dyn Trait<u64>\n+            273..281 'y.foo2()': i64\n+            287..288 'z': dyn Trait<u64>\n+            287..295 'z.foo2()': i64\n         \"#]],\n     );\n }\n@@ -1217,6 +1225,7 @@ fn test(x: dyn Trait<u64>, y: &dyn Trait<u64>) {\n fn dyn_trait_in_impl() {\n     check_infer(\n         r#\"\n+#[lang = \"sized\"] trait Sized {}\n trait Trait<T, U> {\n     fn foo(&self) -> (T, U);\n }\n@@ -1233,17 +1242,17 @@ fn test(s: S<u32, i32>) {\n     s.bar().baz();\n }\"#,\n         expect![[r#\"\n-            32..36 'self': &Self\n-            102..106 'self': &S<T, U>\n-            128..139 '{ loop {} }': &dyn Trait<T, U>\n-            130..137 'loop {}': !\n-            135..137 '{}': ()\n-            175..179 'self': &Self\n-            251..252 's': S<u32, i32>\n-            267..289 '{     ...z(); }': ()\n-            273..274 's': S<u32, i32>\n-            273..280 's.bar()': &dyn Trait<u32, i32>\n-            273..286 's.bar().baz()': (u32, i32)\n+            65..69 'self': &Self\n+            135..139 'self': &S<T, U>\n+            161..172 '{ loop {} }': &dyn Trait<T, U>\n+            163..170 'loop {}': !\n+            168..170 '{}': ()\n+            208..212 'self': &Self\n+            284..285 's': S<u32, i32>\n+            300..322 '{     ...z(); }': ()\n+            306..307 's': S<u32, i32>\n+            306..313 's.bar()': &dyn Trait<u32, i32>\n+            306..319 's.bar().baz()': (u32, i32)\n         \"#]],\n     );\n }\n@@ -1252,6 +1261,7 @@ fn test(s: S<u32, i32>) {\n fn dyn_trait_bare() {\n     check_infer(\n         r#\"\n+#[lang = \"sized\"] trait Sized {}\n trait Trait {\n     fn foo(&self) -> u64;\n }\n@@ -1266,22 +1276,22 @@ fn test(x: Trait, y: &Trait) -> u64 {\n     z.foo();\n }\"#,\n         expect![[r#\"\n-            26..30 'self': &Self\n-            60..62 '{}': ()\n-            72..73 'x': dyn Trait\n-            82..83 'y': &dyn Trait\n-            100..175 '{     ...o(); }': ()\n-            106..107 'x': dyn Trait\n-            113..114 'y': &dyn Trait\n-            124..125 'z': dyn Trait\n-            128..131 'bar': fn bar() -> dyn Trait\n-            128..133 'bar()': dyn Trait\n+            59..63 'self': &Self\n+            93..95 '{}': ()\n+            105..106 'x': dyn Trait\n+            115..116 'y': &dyn Trait\n+            133..208 '{     ...o(); }': ()\n             139..140 'x': dyn Trait\n-            139..146 'x.foo()': u64\n-            152..153 'y': &dyn Trait\n-            152..159 'y.foo()': u64\n-            165..166 'z': dyn Trait\n-            165..172 'z.foo()': u64\n+            146..147 'y': &dyn Trait\n+            157..158 'z': dyn Trait\n+            161..164 'bar': fn bar() -> dyn Trait\n+            161..166 'bar()': dyn Trait\n+            172..173 'x': dyn Trait\n+            172..179 'x.foo()': u64\n+            185..186 'y': &dyn Trait\n+            185..192 'y.foo()': u64\n+            198..199 'z': dyn Trait\n+            198..205 'z.foo()': u64\n         \"#]],\n     );\n }\n@@ -1290,6 +1300,7 @@ fn test(x: Trait, y: &Trait) -> u64 {\n fn weird_bounds() {\n     check_infer(\n         r#\"\n+#[lang = \"sized\"] trait Sized {}\n trait Trait {}\n fn test(\n     a: impl Trait + 'lifetime,\n@@ -1301,13 +1312,13 @@ fn test(\n ) {}\n \"#,\n         expect![[r#\"\n-            28..29 'a': impl Trait\n-            59..60 'b': impl\n-            82..83 'c': impl Trait\n-            103..104 'd': impl\n-            128..129 'e': impl\n-            148..149 'f': impl Trait\n-            173..175 '{}': ()\n+            61..62 'a': impl Trait\n+            92..93 'b': impl Sized\n+            115..116 'c': impl Trait\n+            136..137 'd': impl Sized\n+            161..162 'e': impl ?Sized\n+            181..182 'f': impl Trait + ?Sized\n+            206..208 '{}': ()\n         \"#]],\n     );\n }\n@@ -1331,6 +1342,7 @@ fn test(x: (impl Trait + UnknownTrait)) {\n fn assoc_type_bindings() {\n     check_infer(\n         r#\"\n+#[lang = \"sized\"] trait Sized {}\n trait Trait {\n     type Type;\n }\n@@ -1352,41 +1364,41 @@ fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n     get2(S::<str>);\n }\"#,\n         expect![[r#\"\n-            49..50 't': T\n-            77..79 '{}': ()\n-            111..112 't': T\n-            122..124 '{}': ()\n-            154..155 't': T\n-            165..168 '{t}': T\n-            166..167 't': T\n-            256..257 'x': T\n-            262..263 'y': impl Trait<Type = i64>\n-            289..397 '{     ...r>); }': ()\n-            295..298 'get': fn get<T>(T) -> <T as Trait>::Type\n-            295..301 'get(x)': u32\n-            299..300 'x': T\n-            307..311 'get2': fn get2<u32, T>(T) -> u32\n-            307..314 'get2(x)': u32\n-            312..313 'x': T\n-            320..323 'get': fn get<impl Trait<Type = i64>>(impl Trait<Type = i64>) -> <impl Trait<Type = i64> as Trait>::Type\n-            320..326 'get(y)': i64\n-            324..325 'y': impl Trait<Type = i64>\n-            332..336 'get2': fn get2<i64, impl Trait<Type = i64>>(impl Trait<Type = i64>) -> i64\n-            332..339 'get2(y)': i64\n-            337..338 'y': impl Trait<Type = i64>\n-            345..348 'get': fn get<S<u64>>(S<u64>) -> <S<u64> as Trait>::Type\n-            345..356 'get(set(S))': u64\n-            349..352 'set': fn set<S<u64>>(S<u64>) -> S<u64>\n-            349..355 'set(S)': S<u64>\n-            353..354 'S': S<u64>\n-            362..366 'get2': fn get2<u64, S<u64>>(S<u64>) -> u64\n-            362..374 'get2(set(S))': u64\n-            367..370 'set': fn set<S<u64>>(S<u64>) -> S<u64>\n-            367..373 'set(S)': S<u64>\n-            371..372 'S': S<u64>\n-            380..384 'get2': fn get2<str, S<str>>(S<str>) -> str\n-            380..394 'get2(S::<str>)': str\n-            385..393 'S::<str>': S<str>\n+            82..83 't': T\n+            110..112 '{}': ()\n+            144..145 't': T\n+            155..157 '{}': ()\n+            187..188 't': T\n+            198..201 '{t}': T\n+            199..200 't': T\n+            289..290 'x': T\n+            295..296 'y': impl Trait<Type = i64>\n+            322..430 '{     ...r>); }': ()\n+            328..331 'get': fn get<T>(T) -> <T as Trait>::Type\n+            328..334 'get(x)': u32\n+            332..333 'x': T\n+            340..344 'get2': fn get2<u32, T>(T) -> u32\n+            340..347 'get2(x)': u32\n+            345..346 'x': T\n+            353..356 'get': fn get<impl Trait<Type = i64>>(impl Trait<Type = i64>) -> <impl Trait<Type = i64> as Trait>::Type\n+            353..359 'get(y)': i64\n+            357..358 'y': impl Trait<Type = i64>\n+            365..369 'get2': fn get2<i64, impl Trait<Type = i64>>(impl Trait<Type = i64>) -> i64\n+            365..372 'get2(y)': i64\n+            370..371 'y': impl Trait<Type = i64>\n+            378..381 'get': fn get<S<u64>>(S<u64>) -> <S<u64> as Trait>::Type\n+            378..389 'get(set(S))': u64\n+            382..385 'set': fn set<S<u64>>(S<u64>) -> S<u64>\n+            382..388 'set(S)': S<u64>\n+            386..387 'S': S<u64>\n+            395..399 'get2': fn get2<u64, S<u64>>(S<u64>) -> u64\n+            395..407 'get2(set(S))': u64\n+            400..403 'set': fn set<S<u64>>(S<u64>) -> S<u64>\n+            400..406 'set(S)': S<u64>\n+            404..405 'S': S<u64>\n+            413..417 'get2': fn get2<str, S<str>>(S<str>) -> str\n+            413..427 'get2(S::<str>)': str\n+            418..426 'S::<str>': S<str>\n         \"#]],\n     );\n }\n@@ -1495,6 +1507,7 @@ fn test<T: Trait1, U: Trait2>(x: T, y: U) {\n fn super_trait_impl_trait_method_resolution() {\n     check_infer(\n         r#\"\n+#[lang = \"sized\"] trait Sized {}\n mod foo {\n     trait SuperTrait {\n         fn foo(&self) -> u32 {}\n@@ -1506,12 +1519,12 @@ fn test(x: &impl Trait1) {\n     x.foo();\n }\"#,\n         expect![[r#\"\n-            49..53 'self': &Self\n-            62..64 '{}': ()\n-            115..116 'x': &impl Trait1\n-            132..148 '{     ...o(); }': ()\n-            138..139 'x': &impl Trait1\n-            138..145 'x.foo()': u32\n+            82..86 'self': &Self\n+            95..97 '{}': ()\n+            148..149 'x': &impl Trait1\n+            165..181 '{     ...o(); }': ()\n+            171..172 'x': &impl Trait1\n+            171..178 'x.foo()': u32\n         \"#]],\n     );\n }\n@@ -2299,6 +2312,7 @@ impl TokenStream for Rustc {\n fn unify_impl_trait() {\n     check_infer_with_mismatches(\n         r#\"\n+#[lang = \"sized\"] trait Sized {}\n trait Trait<T> {}\n \n fn foo(x: impl Trait<u32>) { loop {} }\n@@ -2316,37 +2330,37 @@ fn test() -> impl Trait<i32> {\n     S(default())\n }\"#,\n         expect![[r#\"\n-            26..27 'x': impl Trait<u32>\n-            46..57 '{ loop {} }': ()\n-            48..55 'loop {}': !\n-            53..55 '{}': ()\n-            68..69 'x': impl Trait<T>\n-            91..102 '{ loop {} }': T\n-            93..100 'loop {}': !\n-            98..100 '{}': ()\n-            171..182 '{ loop {} }': T\n-            173..180 'loop {}': !\n-            178..180 '{}': ()\n-            213..309 '{     ...t()) }': S<{unknown}>\n-            223..225 's1': S<u32>\n-            228..229 'S': S<u32>(u32) -> S<u32>\n-            228..240 'S(default())': S<u32>\n-            230..237 'default': fn default<u32>() -> u32\n-            230..239 'default()': u32\n-            246..249 'foo': fn foo(S<u32>)\n-            246..253 'foo(s1)': ()\n-            250..252 's1': S<u32>\n-            263..264 'x': i32\n-            272..275 'bar': fn bar<i32>(S<i32>) -> i32\n-            272..289 'bar(S(...lt()))': i32\n-            276..277 'S': S<i32>(i32) -> S<i32>\n-            276..288 'S(default())': S<i32>\n-            278..285 'default': fn default<i32>() -> i32\n-            278..287 'default()': i32\n-            295..296 'S': S<{unknown}>({unknown}) -> S<{unknown}>\n-            295..307 'S(default())': S<{unknown}>\n-            297..304 'default': fn default<{unknown}>() -> {unknown}\n-            297..306 'default()': {unknown}\n+            59..60 'x': impl Trait<u32>\n+            79..90 '{ loop {} }': ()\n+            81..88 'loop {}': !\n+            86..88 '{}': ()\n+            101..102 'x': impl Trait<T>\n+            124..135 '{ loop {} }': T\n+            126..133 'loop {}': !\n+            131..133 '{}': ()\n+            204..215 '{ loop {} }': T\n+            206..213 'loop {}': !\n+            211..213 '{}': ()\n+            246..342 '{     ...t()) }': S<{unknown}>\n+            256..258 's1': S<u32>\n+            261..262 'S': S<u32>(u32) -> S<u32>\n+            261..273 'S(default())': S<u32>\n+            263..270 'default': fn default<u32>() -> u32\n+            263..272 'default()': u32\n+            279..282 'foo': fn foo(S<u32>)\n+            279..286 'foo(s1)': ()\n+            283..285 's1': S<u32>\n+            296..297 'x': i32\n+            305..308 'bar': fn bar<i32>(S<i32>) -> i32\n+            305..322 'bar(S(...lt()))': i32\n+            309..310 'S': S<i32>(i32) -> S<i32>\n+            309..321 'S(default())': S<i32>\n+            311..318 'default': fn default<i32>() -> i32\n+            311..320 'default()': i32\n+            328..329 'S': S<{unknown}>({unknown}) -> S<{unknown}>\n+            328..340 'S(default())': S<{unknown}>\n+            330..337 'default': fn default<{unknown}>() -> {unknown}\n+            330..339 'default()': {unknown}\n         \"#]],\n     );\n }"}]}