{"sha": "cdf9a28006b1216653eac1bdc45a83e436fac9ba", "node_id": "C_kwDOAAsO6NoAKGNkZjlhMjgwMDZiMTIxNjY1M2VhYzFiZGM0NWE4M2U0MzZmYWM5YmE", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2022-02-12T09:23:07Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2022-02-17T17:00:40Z"}, "message": "Improve lint message of await_holding_*\n\nImproves the message of the lints await_holding_lock and\nawait_holding_refcell_ref. Now also actually tests RwLock.", "tree": {"sha": "761b83a7fcb2b39dc2543de8c4e675f87ac4f7ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/761b83a7fcb2b39dc2543de8c4e675f87ac4f7ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdf9a28006b1216653eac1bdc45a83e436fac9ba", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmIOfzgACgkQHKDfKvWd\naKVBeA//StB9fYJPB9jzin+rK9v+wu53Wkyft6objwcx7ij/apBhxaTywiTTdpbG\ntv2elifalANzK8NTUUdIVBLaMKONHBgB6t5cviaQ46QDmzivXrsWyqupHdlNxkwD\nmOszdR0ssG3nkKxOTb7//tVMy4LGPmhGpRsl3viLY8+PomIs0obdiRLt8S/MVzS0\nWeB9x+i89nD2UEUE3WdZYNPFXDb+VuW4KLnKFd3RXKxuFE0uIwDdyDHDJTnnNwBA\n1QUpRGP/ggSdtQ1FRoCoYI5K+Pi/L9YLV8mWUEktYEL7uJmuqcKlMaRLfkDft58O\nN1Q3M+gwqwO95ZakoGlXhV0x5yZHZOQMkdSHra3na3FD7j/e3Cu88SCtcPFuYFQ6\ngfI4K1cx9mpJQn67Z9sMXfaenrW3AwqDFWCy5dB4eYUod7GVjjzvq8W48ggeIzxW\nq9BCZNpc6M3T69IPRY/fXcZeFL7UPc88tcHQd+UD22t+bTCcZimhvsthhxcPoctV\nqkG159ekHAjUAA83sJccC629W5aPjbm2ev/+6KAG8AEhdEj1K00glre6j0TtXljn\n9XiXBThDd2nzb46PDe0kfJAkjDHpkJI+qnmnQ116pvx6mtA+xrwD/9f3j9wtuRvx\nj/ACzPXjMpqCxM0EPRGesG7mSTD4Cr8qFZlbExOQ2MeDHZdc4CA=\n=2UNo\n-----END PGP SIGNATURE-----", "payload": "tree 761b83a7fcb2b39dc2543de8c4e675f87ac4f7ba\nparent 668b3e47f90cf38d9d7cba88d991a165769024a5\nauthor flip1995 <philipp.krones@embecosm.com> 1644657787 +0100\ncommitter flip1995 <philipp.krones@embecosm.com> 1645117240 +0100\n\nImprove lint message of await_holding_*\n\nImproves the message of the lints await_holding_lock and\nawait_holding_refcell_ref. Now also actually tests RwLock.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdf9a28006b1216653eac1bdc45a83e436fac9ba", "html_url": "https://github.com/rust-lang/rust/commit/cdf9a28006b1216653eac1bdc45a83e436fac9ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdf9a28006b1216653eac1bdc45a83e436fac9ba/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "668b3e47f90cf38d9d7cba88d991a165769024a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/668b3e47f90cf38d9d7cba88d991a165769024a5", "html_url": "https://github.com/rust-lang/rust/commit/668b3e47f90cf38d9d7cba88d991a165769024a5"}], "stats": {"total": 151, "additions": 114, "deletions": 37}, "files": [{"sha": "f7bc8395c822d73be47f41847ab9a4accd94a829", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cdf9a28006b1216653eac1bdc45a83e436fac9ba/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf9a28006b1216653eac1bdc45a83e436fac9ba/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=cdf9a28006b1216653eac1bdc45a83e436fac9ba", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint_and_note;\n+use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{match_def_path, paths};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n@@ -118,23 +118,36 @@ fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorType\n     for ty_cause in ty_causes {\n         if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n             if is_mutex_guard(cx, adt.did) {\n-                span_lint_and_note(\n+                span_lint_and_then(\n                     cx,\n                     AWAIT_HOLDING_LOCK,\n                     ty_cause.span,\n-                    \"this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\",\n-                    ty_cause.scope_span.or(Some(span)),\n-                    \"these are all the await points this lock is held through\",\n+                    \"this `MutexGuard` is held across an `await` point\",\n+                    |diag| {\n+                        diag.help(\n+                            \"consider using an async-aware `Mutex` type or ensuring the \\\n+                                `MutexGuard` is dropped before calling await\",\n+                        );\n+                        diag.span_note(\n+                            ty_cause.scope_span.unwrap_or(span),\n+                            \"these are all the `await` points this lock is held through\",\n+                        );\n+                    },\n                 );\n             }\n             if is_refcell_ref(cx, adt.did) {\n-                span_lint_and_note(\n+                span_lint_and_then(\n                     cx,\n                     AWAIT_HOLDING_REFCELL_REF,\n                     ty_cause.span,\n-                    \"this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\",\n-                    ty_cause.scope_span.or(Some(span)),\n-                    \"these are all the await points this ref is held through\",\n+                    \"this `RefCell` reference is held across an `await` point\",\n+                    |diag| {\n+                        diag.help(\"ensure the reference is dropped before calling `await`\");\n+                        diag.span_note(\n+                            ty_cause.scope_span.unwrap_or(span),\n+                            \"these are all the `await` points this reference is held through\",\n+                        );\n+                    },\n                 );\n             }\n         }"}, {"sha": "f03356d83df015841a5a55312c222f7211f6ca29", "filename": "tests/ui/await_holding_lock.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cdf9a28006b1216653eac1bdc45a83e436fac9ba/tests%2Fui%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf9a28006b1216653eac1bdc45a83e436fac9ba/tests%2Fui%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.rs?ref=cdf9a28006b1216653eac1bdc45a83e436fac9ba", "patch": "@@ -1,6 +1,6 @@\n #![warn(clippy::await_holding_lock)]\n \n-use std::sync::Mutex;\n+use std::sync::{Mutex, RwLock};\n \n async fn bad(x: &Mutex<u32>) -> u32 {\n     let guard = x.lock().unwrap();\n@@ -17,6 +17,30 @@ async fn good(x: &Mutex<u32>) -> u32 {\n     47\n }\n \n+pub async fn bad_rw(x: &RwLock<u32>) -> u32 {\n+    let guard = x.read().unwrap();\n+    baz().await\n+}\n+\n+pub async fn bad_rw_write(x: &RwLock<u32>) -> u32 {\n+    let mut guard = x.write().unwrap();\n+    baz().await\n+}\n+\n+pub async fn good_rw(x: &RwLock<u32>) -> u32 {\n+    {\n+        let guard = x.read().unwrap();\n+        let y = *guard + 1;\n+    }\n+    {\n+        let mut guard = x.write().unwrap();\n+        *guard += 1;\n+    }\n+    baz().await;\n+    let guard = x.read().unwrap();\n+    47\n+}\n+\n async fn baz() -> u32 {\n     42\n }"}, {"sha": "3a501acbb67a6f4eb9a4cab81662e3f7d413ac44", "filename": "tests/ui/await_holding_lock.stderr", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cdf9a28006b1216653eac1bdc45a83e436fac9ba/tests%2Fui%2Fawait_holding_lock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdf9a28006b1216653eac1bdc45a83e436fac9ba/tests%2Fui%2Fawait_holding_lock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.stderr?ref=cdf9a28006b1216653eac1bdc45a83e436fac9ba", "patch": "@@ -1,26 +1,58 @@\n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n+error: this `MutexGuard` is held across an `await` point\n   --> $DIR/await_holding_lock.rs:6:9\n    |\n LL |     let guard = x.lock().unwrap();\n    |         ^^^^^\n    |\n    = note: `-D clippy::await-holding-lock` implied by `-D warnings`\n-note: these are all the await points this lock is held through\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n   --> $DIR/await_holding_lock.rs:6:5\n    |\n LL | /     let guard = x.lock().unwrap();\n LL | |     baz().await\n LL | | }\n    | |_^\n \n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n-  --> $DIR/await_holding_lock.rs:27:9\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:21:9\n+   |\n+LL |     let guard = x.read().unwrap();\n+   |         ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:21:5\n+   |\n+LL | /     let guard = x.read().unwrap();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:26:9\n+   |\n+LL |     let mut guard = x.write().unwrap();\n+   |         ^^^^^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:26:5\n+   |\n+LL | /     let mut guard = x.write().unwrap();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:51:9\n    |\n LL |     let guard = x.lock().unwrap();\n    |         ^^^^^\n    |\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_lock.rs:27:5\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:51:5\n    |\n LL | /     let guard = x.lock().unwrap();\n LL | |\n@@ -31,33 +63,35 @@ LL | |     first + second + third\n LL | | }\n    | |_^\n \n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n-  --> $DIR/await_holding_lock.rs:40:13\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:64:13\n    |\n LL |         let guard = x.lock().unwrap();\n    |             ^^^^^\n    |\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_lock.rs:40:9\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:64:9\n    |\n LL | /         let guard = x.lock().unwrap();\n LL | |         baz().await\n LL | |     };\n    | |_____^\n \n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n-  --> $DIR/await_holding_lock.rs:52:13\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:76:13\n    |\n LL |         let guard = x.lock().unwrap();\n    |             ^^^^^\n    |\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_lock.rs:52:9\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:76:9\n    |\n LL | /         let guard = x.lock().unwrap();\n LL | |         baz().await\n LL | |     }\n    | |_____^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "4339fca735dd4554eabcc0d7a9ad6a0963fc2d31", "filename": "tests/ui/await_holding_refcell_ref.stderr", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cdf9a28006b1216653eac1bdc45a83e436fac9ba/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cdf9a28006b1216653eac1bdc45a83e436fac9ba/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_refcell_ref.stderr?ref=cdf9a28006b1216653eac1bdc45a83e436fac9ba", "patch": "@@ -1,39 +1,42 @@\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:6:9\n    |\n LL |     let b = x.borrow();\n    |         ^\n    |\n    = note: `-D clippy::await-holding-refcell-ref` implied by `-D warnings`\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:6:5\n    |\n LL | /     let b = x.borrow();\n LL | |     baz().await\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:11:9\n    |\n LL |     let b = x.borrow_mut();\n    |         ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:11:5\n    |\n LL | /     let b = x.borrow_mut();\n LL | |     baz().await\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:32:9\n    |\n LL |     let b = x.borrow_mut();\n    |         ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:32:5\n    |\n LL | /     let b = x.borrow_mut();\n@@ -45,13 +48,14 @@ LL | |     first + second + third\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:44:9\n    |\n LL |     let b = x.borrow_mut();\n    |         ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:44:5\n    |\n LL | /     let b = x.borrow_mut();\n@@ -63,27 +67,29 @@ LL | |     first + second + third\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:59:13\n    |\n LL |         let b = x.borrow_mut();\n    |             ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:59:9\n    |\n LL | /         let b = x.borrow_mut();\n LL | |         baz().await\n LL | |     };\n    | |_____^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:71:13\n    |\n LL |         let b = x.borrow_mut();\n    |             ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:71:9\n    |\n LL | /         let b = x.borrow_mut();"}]}