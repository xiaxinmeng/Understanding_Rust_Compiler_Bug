{"sha": "e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZWFkNWZjNTg3NWVjMmUzMmYwMDFmMjVlYzAwMDdjZDVkNTI3ZmE=", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2020-12-29T21:24:15Z"}, "committer": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2020-12-30T12:15:40Z"}, "message": "remove unused return types such as empty Results or Options that would always be Some(..)\n\nremove unused return type of dropck::check_drop_obligations()\ndon't wrap return type in Option in get_macro_by_def_id() since we would always return Some(..)\nremove redundant return type of back::write::optimize()\ndon't Option-wrap return type of compute_type_parameters() since we always return Some(..)\ndon't return empty Result in assemble_generator_candidates()\ndon't return empty Result in assemble_closure_candidates()\ndon't return empty result in assemble_fn_pointer_candidates()\ndon't return empty result in assemble_candidates_from_impls()\ndon't return empty result in assemble_candidates_from_auto_impls()\ndon't return emtpy result in assemble_candidates_for_trait_alias()\ndon't return empty result in assemble_builtin_bound_candidates()\ndon't return empty results in assemble_extension_candidates_for_traits_in_scope() and assemble_extension_candidates_for_trait()\nremove redundant wrapping of return type of StripItem::strip() since it always returns Some(..)\nremove unused return type of assemble_extension_candidates_for_all_traits()", "tree": {"sha": "d537eed1b1f2f63fecc65aa82d07ae14d5730372", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d537eed1b1f2f63fecc65aa82d07ae14d5730372"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "html_url": "https://github.com/rust-lang/rust/commit/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9c403be11bef38638b38012be80444ad3f09dde", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9c403be11bef38638b38012be80444ad3f09dde", "html_url": "https://github.com/rust-lang/rust/commit/b9c403be11bef38638b38012be80444ad3f09dde"}], "stats": {"total": 137, "additions": 56, "deletions": 81}, "files": [{"sha": "230e11f274eaebecd52c30dc8ce93231a6a1f1ef", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "patch": "@@ -485,7 +485,7 @@ pub(crate) unsafe fn optimize(\n     diag_handler: &Handler,\n     module: &ModuleCodegen<ModuleLlvm>,\n     config: &ModuleConfig,\n-) -> Result<(), FatalError> {\n+) {\n     let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_optimize\", &module.name[..]);\n \n     let llmod = module.module_llvm.llmod();\n@@ -511,7 +511,7 @@ pub(crate) unsafe fn optimize(\n                 _ => llvm::OptStage::PreLinkNoLTO,\n             };\n             optimize_with_new_llvm_pass_manager(cgcx, module, config, opt_level, opt_stage);\n-            return Ok(());\n+            return;\n         }\n \n         if cgcx.prof.llvm_recording_enabled() {\n@@ -634,7 +634,6 @@ pub(crate) unsafe fn optimize(\n         llvm::LLVMDisposePassManager(fpm);\n         llvm::LLVMDisposePassManager(mpm);\n     }\n-    Ok(())\n }\n \n unsafe fn add_sanitizer_passes(config: &ModuleConfig, passes: &mut Vec<&'static mut llvm::Pass>) {"}, {"sha": "36a21b38c035d27876ebedd8b398d91844c1ea1d", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "patch": "@@ -2322,13 +2322,13 @@ fn set_members_of_composite_type(\n             DIB(cx),\n             composite_type_metadata,\n             Some(type_array),\n-            type_params,\n+            Some(type_params),\n         );\n     }\n }\n \n /// Computes the type parameters for a type, if any, for the given metadata.\n-fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'ll DIArray> {\n+fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> &'ll DIArray {\n     if let ty::Adt(def, substs) = *ty.kind() {\n         if substs.types().next().is_some() {\n             let generics = cx.tcx.generics_of(def.did);\n@@ -2358,10 +2358,10 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'\n                 })\n                 .collect();\n \n-            return Some(create_DIArray(DIB(cx), &template_params[..]));\n+            return create_DIArray(DIB(cx), &template_params[..]);\n         }\n     }\n-    return Some(create_DIArray(DIB(cx), &[]));\n+    return create_DIArray(DIB(cx), &[]);\n \n     fn get_parameter_names(cx: &CodegenCx<'_, '_>, generics: &ty::Generics) -> Vec<Symbol> {\n         let mut names = generics"}, {"sha": "92ac770aca554ed338b9c4b5056933884da0e8b1", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "patch": "@@ -160,7 +160,7 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n         module: &ModuleCodegen<Self::Module>,\n         config: &ModuleConfig,\n     ) -> Result<(), FatalError> {\n-        back::write::optimize(cgcx, diag_handler, module, config)\n+        Ok(back::write::optimize(cgcx, diag_handler, module, config))\n     }\n     unsafe fn optimize_thin(\n         cgcx: &CodegenContext<Self>,"}, {"sha": "907a08cee2a4c326c2d1bcd9067f21d19999d456", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "patch": "@@ -185,15 +185,15 @@ impl<'a> Resolver<'a> {\n \n     crate fn get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n         match res {\n-            Res::Def(DefKind::Macro(..), def_id) => self.get_macro_by_def_id(def_id),\n+            Res::Def(DefKind::Macro(..), def_id) => Some(self.get_macro_by_def_id(def_id)),\n             Res::NonMacroAttr(attr_kind) => Some(self.non_macro_attr(attr_kind.is_used())),\n             _ => None,\n         }\n     }\n \n-    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Option<Lrc<SyntaxExtension>> {\n+    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Lrc<SyntaxExtension> {\n         if let Some(ext) = self.macro_map.get(&def_id) {\n-            return Some(ext.clone());\n+            return ext.clone();\n         }\n \n         let ext = Lrc::new(match self.cstore().load_macro_untracked(def_id, &self.session) {\n@@ -202,7 +202,7 @@ impl<'a> Resolver<'a> {\n         });\n \n         self.macro_map.insert(def_id, ext.clone());\n-        Some(ext)\n+        ext\n     }\n \n     crate fn build_reduced_graph("}, {"sha": "5eb30eacf07848d22912a108de704989a9d4ac17", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "patch": "@@ -1991,14 +1991,13 @@ impl<'a> Resolver<'a> {\n             {\n                 // The macro is a proc macro derive\n                 if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n-                    if let Some(ext) = self.get_macro_by_def_id(def_id) {\n-                        if !ext.is_builtin\n-                            && ext.macro_kind() == MacroKind::Derive\n-                            && parent.expansion.outer_expn_is_descendant_of(span.ctxt())\n-                        {\n-                            *poisoned = Some(node_id);\n-                            return module.parent;\n-                        }\n+                    let ext = self.get_macro_by_def_id(def_id);\n+                    if !ext.is_builtin\n+                        && ext.macro_kind() == MacroKind::Derive\n+                        && parent.expansion.outer_expn_is_descendant_of(span.ctxt())\n+                    {\n+                        *poisoned = Some(node_id);\n+                        return module.parent;\n                     }\n                 }\n             }"}, {"sha": "f09ce8d64ed5e1b5bba37d3d21b8df6d8b508dc1", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "patch": "@@ -247,7 +247,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let mut candidates = SelectionCandidateSet { vec: Vec::new(), ambiguous: false };\n \n-        self.assemble_candidates_for_trait_alias(obligation, &mut candidates)?;\n+        self.assemble_candidates_for_trait_alias(obligation, &mut candidates);\n \n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n@@ -259,19 +259,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             // User-defined copy impls are permitted, but only for\n             // structs and enums.\n-            self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n+            self.assemble_candidates_from_impls(obligation, &mut candidates);\n \n             // For other types, we'll use the builtin rules.\n             let copy_conditions = self.copy_clone_conditions(obligation);\n-            self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n+            self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates);\n         } else if lang_items.discriminant_kind_trait() == Some(def_id) {\n             // `DiscriminantKind` is automatically implemented for every type.\n             candidates.vec.push(DiscriminantKindCandidate);\n         } else if lang_items.sized_trait() == Some(def_id) {\n             // Sized is never implementable by end-users, it is\n             // always automatically computed.\n             let sized_conditions = self.sized_conditions(obligation);\n-            self.assemble_builtin_bound_candidates(sized_conditions, &mut candidates)?;\n+            self.assemble_builtin_bound_candidates(sized_conditions, &mut candidates);\n         } else if lang_items.unsize_trait() == Some(def_id) {\n             self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n         } else {\n@@ -280,13 +280,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // for `Copy` also has builtin support for `Clone`, and tuples/arrays of `Clone`\n                 // types have builtin support for `Clone`.\n                 let clone_conditions = self.copy_clone_conditions(obligation);\n-                self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates)?;\n+                self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates);\n             }\n \n-            self.assemble_generator_candidates(obligation, &mut candidates)?;\n-            self.assemble_closure_candidates(obligation, &mut candidates)?;\n-            self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n-            self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n+            self.assemble_generator_candidates(obligation, &mut candidates);\n+            self.assemble_closure_candidates(obligation, &mut candidates);\n+            self.assemble_fn_pointer_candidates(obligation, &mut candidates);\n+            self.assemble_candidates_from_impls(obligation, &mut candidates);\n             self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n         }\n \n@@ -295,7 +295,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Auto implementations have lower priority, so we only\n         // consider triggering a default if there is no other impl that can apply.\n         if candidates.vec.is_empty() {\n-            self.assemble_candidates_from_auto_impls(obligation, &mut candidates)?;\n+            self.assemble_candidates_from_auto_impls(obligation, &mut candidates);\n         }\n         debug!(\"candidate list size: {}\", candidates.vec.len());\n         Ok(candidates)\n@@ -367,9 +367,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n+    ) {\n         if self.tcx().lang_items().gen_trait() != Some(obligation.predicate.def_id()) {\n-            return Ok(());\n+            return;\n         }\n \n         // Okay to skip binder because the substs on generator types never\n@@ -388,8 +388,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n             _ => {}\n         }\n-\n-        Ok(())\n     }\n \n     /// Checks for the artificial impl that the compiler will create for an obligation like `X :\n@@ -402,11 +400,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n+    ) {\n         let kind = match self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()) {\n             Some(k) => k,\n             None => {\n-                return Ok(());\n+                return;\n             }\n         };\n \n@@ -435,19 +433,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n             _ => {}\n         }\n-\n-        Ok(())\n     }\n \n     /// Implements one of the `Fn()` family for a fn pointer.\n     fn assemble_fn_pointer_candidates(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n+    ) {\n         // We provide impl of all fn traits for fn pointers.\n         if self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()).is_none() {\n-            return Ok(());\n+            return;\n         }\n \n         // Okay to skip binder because what we are inspecting doesn't involve bound regions.\n@@ -485,16 +481,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n             _ => {}\n         }\n-\n-        Ok(())\n     }\n \n     /// Searches for impls that might apply to `obligation`.\n     fn assemble_candidates_from_impls(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n+    ) {\n         debug!(?obligation, \"assemble_candidates_from_impls\");\n \n         // Essentially any user-written impl will match with an error type,\n@@ -504,7 +498,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Since compilation is already guaranteed to fail, this is just\n         // to try to show the 'nicest' possible errors to the user.\n         if obligation.references_error() {\n-            return Ok(());\n+            return;\n         }\n \n         self.tcx().for_each_relevant_impl(\n@@ -518,15 +512,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 });\n             },\n         );\n-\n-        Ok(())\n     }\n \n     fn assemble_candidates_from_auto_impls(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n+    ) {\n         // Okay to skip binder here because the tests we do below do not involve bound regions.\n         let self_ty = obligation.self_ty().skip_binder();\n         debug!(?self_ty, \"assemble_candidates_from_auto_impls\");\n@@ -585,8 +577,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 _ => candidates.vec.push(AutoImplCandidate(def_id)),\n             }\n         }\n-\n-        Ok(())\n     }\n \n     /// Searches for impls that might apply to `obligation`.\n@@ -753,7 +743,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n+    ) {\n         // Okay to skip binder here because the tests we do below do not involve bound regions.\n         let self_ty = obligation.self_ty().skip_binder();\n         debug!(?self_ty, \"assemble_candidates_for_trait_alias\");\n@@ -763,8 +753,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if self.tcx().is_trait_alias(def_id) {\n             candidates.vec.push(TraitAliasCandidate(def_id));\n         }\n-\n-        Ok(())\n     }\n \n     /// Assembles the trait which are built-in to the language itself:\n@@ -773,7 +761,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         conditions: BuiltinImplConditions<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n-    ) -> Result<(), SelectionError<'tcx>> {\n+    ) {\n         match conditions {\n             BuiltinImplConditions::Where(nested) => {\n                 debug!(?nested, \"builtin_bound\");\n@@ -787,7 +775,5 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 candidates.ambiguous = true;\n             }\n         }\n-\n-        Ok(())\n     }\n }"}, {"sha": "be19919c0ea1f6be8cc20aa99cb6405a583b52f6", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "patch": "@@ -267,15 +267,13 @@ crate fn check_drop_obligations<'a, 'tcx>(\n     ty: Ty<'tcx>,\n     span: Span,\n     body_id: hir::HirId,\n-) -> Result<(), ErrorReported> {\n+) {\n     debug!(\"check_drop_obligations typ: {:?}\", ty);\n \n     let cause = &ObligationCause::misc(span, body_id);\n     let infer_ok = rcx.infcx.at(cause, rcx.fcx.param_env).dropck_outlives(ty);\n     debug!(\"dropck_outlives = {:#?}\", infer_ok);\n     rcx.fcx.register_infer_ok_obligations(infer_ok);\n-\n-    Ok(())\n }\n \n // This is an implementation of the TypeRelation trait with the"}, {"sha": "d4631c465a3a7c8c81a0fbb7e906f2e789070502", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "patch": "@@ -423,9 +423,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             probe_cx.assemble_inherent_candidates();\n             match scope {\n                 ProbeScope::TraitsInScope => {\n-                    probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)?\n+                    probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)\n                 }\n-                ProbeScope::AllTraits => probe_cx.assemble_extension_candidates_for_all_traits()?,\n+                ProbeScope::AllTraits => probe_cx.assemble_extension_candidates_for_all_traits(),\n             };\n             op(probe_cx)\n         })\n@@ -866,35 +866,29 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn assemble_extension_candidates_for_traits_in_scope(\n-        &mut self,\n-        expr_hir_id: hir::HirId,\n-    ) -> Result<(), MethodError<'tcx>> {\n+    fn assemble_extension_candidates_for_traits_in_scope(&mut self, expr_hir_id: hir::HirId) {\n         let mut duplicates = FxHashSet::default();\n         let opt_applicable_traits = self.tcx.in_scope_traits(expr_hir_id);\n         if let Some(applicable_traits) = opt_applicable_traits {\n             for trait_candidate in applicable_traits.iter() {\n                 let trait_did = trait_candidate.def_id;\n                 if duplicates.insert(trait_did) {\n-                    let result = self.assemble_extension_candidates_for_trait(\n+                    self.assemble_extension_candidates_for_trait(\n                         &trait_candidate.import_ids,\n                         trait_did,\n                     );\n-                    result?;\n                 }\n             }\n         }\n-        Ok(())\n     }\n \n-    fn assemble_extension_candidates_for_all_traits(&mut self) -> Result<(), MethodError<'tcx>> {\n+    fn assemble_extension_candidates_for_all_traits(&mut self) {\n         let mut duplicates = FxHashSet::default();\n         for trait_info in suggest::all_traits(self.tcx) {\n             if duplicates.insert(trait_info.def_id) {\n-                self.assemble_extension_candidates_for_trait(&smallvec![], trait_info.def_id)?;\n+                self.assemble_extension_candidates_for_trait(&smallvec![], trait_info.def_id);\n             }\n         }\n-        Ok(())\n     }\n \n     pub fn matches_return_type(\n@@ -932,7 +926,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         &mut self,\n         import_ids: &SmallVec<[LocalDefId; 1]>,\n         trait_def_id: DefId,\n-    ) -> Result<(), MethodError<'tcx>> {\n+    ) {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\", trait_def_id);\n         let trait_substs = self.fresh_item_substs(trait_def_id);\n         let trait_ref = ty::TraitRef::new(trait_def_id, trait_substs);\n@@ -980,7 +974,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 );\n             }\n         }\n-        Ok(())\n     }\n \n     fn candidate_method_names(&self) -> Vec<Ident> {\n@@ -1027,7 +1020,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         let span = self.span;\n         let tcx = self.tcx;\n \n-        self.assemble_extension_candidates_for_all_traits()?;\n+        self.assemble_extension_candidates_for_all_traits();\n \n         let out_of_scope_traits = match self.pick_core() {\n             Some(Ok(p)) => vec![p.item.container.id()],"}, {"sha": "88e8dd3cb129aa1ac39358c81274c6e0ab41fbea", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "patch": "@@ -325,7 +325,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         pat.each_binding(|_, hir_id, span, _| {\n             let typ = self.resolve_node_type(hir_id);\n             let body_id = self.body_id;\n-            let _ = dropck::check_drop_obligations(self, typ, span, body_id);\n+            dropck::check_drop_obligations(self, typ, span, body_id);\n         })\n     }\n }\n@@ -488,7 +488,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n             if place_with_id.place.projections.is_empty() {\n                 let typ = self.resolve_type(place_with_id.place.ty());\n                 let body_id = self.body_id;\n-                let _ = dropck::check_drop_obligations(self, typ, span, body_id);\n+                dropck::check_drop_obligations(self, typ, span, body_id);\n             }\n         }\n     }"}, {"sha": "c39cc3ca39771841e8ff6e32a782dfd70b7a2a69", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "patch": "@@ -3,12 +3,12 @@ use crate::clean::*;\n crate struct StripItem(pub Item);\n \n impl StripItem {\n-    crate fn strip(self) -> Option<Item> {\n+    crate fn strip(self) -> Item {\n         match self.0 {\n-            Item { kind: box StrippedItem(..), .. } => Some(self.0),\n+            Item { kind: box StrippedItem(..), .. } => self.0,\n             mut i => {\n                 i.kind = box StrippedItem(i.kind);\n-                Some(i)\n+                i\n             }\n         }\n     }"}, {"sha": "01e3d0acaa8555689e7caafc59b5a290659ecc94", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "patch": "@@ -49,7 +49,7 @@ impl<'a> DocFolder for Stripper<'a> {\n                     let old = mem::replace(&mut self.update_retained, false);\n                     let ret = StripItem(self.fold_item_recur(i)).strip();\n                     self.update_retained = old;\n-                    return ret;\n+                    return Some(ret);\n                 }\n                 _ => return None,\n             }"}, {"sha": "a1924422f0e5ee27e70d6f895d3afa8db090fa92", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5ead5fc5875ec2e32f001f25ec0007cd5d527fa/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=e5ead5fc5875ec2e32f001f25ec0007cd5d527fa", "patch": "@@ -51,7 +51,7 @@ impl<'a> DocFolder for Stripper<'a> {\n \n             clean::StructFieldItem(..) => {\n                 if !i.visibility.is_public() {\n-                    return StripItem(i).strip();\n+                    return Some(StripItem(i).strip());\n                 }\n             }\n \n@@ -61,7 +61,7 @@ impl<'a> DocFolder for Stripper<'a> {\n                     let old = mem::replace(&mut self.update_retained, false);\n                     let ret = StripItem(self.fold_item_recur(i)).strip();\n                     self.update_retained = old;\n-                    return ret;\n+                    return Some(ret);\n                 }\n             }\n "}]}