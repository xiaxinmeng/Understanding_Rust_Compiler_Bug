{"sha": "e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZDJiYzI5MTZiNWI1ODQwNzg5ZDdlN2ZjODllNDY0NzA2M2JmYTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-09T17:00:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-09T17:00:54Z"}, "message": "Auto merge of #35166 - nikomatsakis:incr-comp-ice-34991-2, r=mw\n\nAddress ICEs running w/ incremental compilation and building glium\n\nFixes for various ICEs I encountered trying to build glium with incremental compilation enabled. Building glium now works. Of the 4 ICEs, I have test cases for 3 of them -- I didn't isolate a test for the last commit and kind of want to go do other things -- most notably, figuring out why incremental isn't saving much *effort*.\n\nBut if it seems worthwhile and I can come back and try to narrow down the problem.\n\nr? @michaelwoerister\n\nFixes #34991\nFixes #32015", "tree": {"sha": "e37e05fc527424276fbffc49774014871b254573", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e37e05fc527424276fbffc49774014871b254573"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "html_url": "https://github.com/rust-lang/rust/commit/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0139140f6a2d1207cb21336b0faca69b5a337b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0139140f6a2d1207cb21336b0faca69b5a337b2", "html_url": "https://github.com/rust-lang/rust/commit/f0139140f6a2d1207cb21336b0faca69b5a337b2"}, {"sha": "e0b82d5c3a159fabf0dae4632f294f17eacda1d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0b82d5c3a159fabf0dae4632f294f17eacda1d0", "html_url": "https://github.com/rust-lang/rust/commit/e0b82d5c3a159fabf0dae4632f294f17eacda1d0"}], "stats": {"total": 1696, "additions": 1117, "deletions": 579}, "files": [{"sha": "f16a9b386bb8aeb3c985b6d227cc92a86fc45198", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -134,6 +134,10 @@ to read from it. Similarly, reading from the `tcache` map for item `X`\n (which is a `DepTrackingMap`, described below) automatically invokes\n `dep_graph.read(ItemSignature(X))`.\n \n+**Note:** adding `Hir` nodes requires a bit of caution due to the\n+\"inlining\" that old trans and constant evaluation still use. See the\n+section on inlining below.\n+\n To make this strategy work, a certain amount of indirection is\n required. For example, modules in the HIR do not have direct pointers\n to the items that they contain. Rather, they contain node-ids -- one\n@@ -387,3 +391,24 @@ RUST_DEP_GRAPH_FILTER='Hir&foo -> TypeckItemBody & bar'\n This will dump out all the nodes that lead from `Hir(foo)` to\n `TypeckItemBody(bar)`, from which you can (hopefully) see the source\n of the erroneous edge.\n+\n+### Inlining of HIR nodes\n+\n+For the time being, at least, we still sometimes \"inline\" HIR nodes\n+from other crates into the current HIR map. This creates a weird\n+scenario where the same logical item (let's call it `X`) has two\n+def-ids: the original def-id `X` and a new, inlined one `X'`. `X'` is\n+in the current crate, but it's not like other HIR nodes: in\n+particular, when we restart compilation, it will not be available to\n+hash. Therefore, we do not want `Hir(X')` nodes appearing in our\n+graph.  Instead, we want a \"read\" of `Hir(X')` to be represented as a\n+read of `MetaData(X)`, since the metadata for `X` is where the inlined\n+representation originated in the first place.\n+\n+To achieve this, the HIR map will detect if the def-id originates in\n+an inlined node and add a dependency to a suitable `MetaData` node\n+instead. If you are reading a HIR node and are not sure if it may be\n+inlined or not, you can use `tcx.map.read(node_id)` and it will detect\n+whether the node is inlined or not and do the right thing.  You can\n+also use `tcx.map.is_inlined_def_id()` and\n+`tcx.map.is_inlined_node_id()` to test."}, {"sha": "46787f38320553f0fc4244f137ca2158a7440218", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -20,7 +20,7 @@ macro_rules! try_opt {\n     )\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub enum DepNode<D: Clone + Debug> {\n     // The `D` type is \"how definitions are identified\".\n     // During compilation, it is always `DefId`, but when serializing\n@@ -82,9 +82,11 @@ pub enum DepNode<D: Clone + Debug> {\n     Privacy,\n     IntrinsicCheck(D),\n     MatchCheck(D),\n-    MirMapConstruction(D),\n-    MirPass(D),\n-    MirTypeck(D),\n+\n+    // Represents the MIR for a fn; also used as the task node for\n+    // things read/modify that MIR.\n+    Mir(D),\n+\n     BorrowCheck(D),\n     RvalueCheck(D),\n     Reachability,\n@@ -214,9 +216,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             CheckConst(ref d) => op(d).map(CheckConst),\n             IntrinsicCheck(ref d) => op(d).map(IntrinsicCheck),\n             MatchCheck(ref d) => op(d).map(MatchCheck),\n-            MirMapConstruction(ref d) => op(d).map(MirMapConstruction),\n-            MirPass(ref d) => op(d).map(MirPass),\n-            MirTypeck(ref d) => op(d).map(MirTypeck),\n+            Mir(ref d) => op(d).map(Mir),\n             BorrowCheck(ref d) => op(d).map(BorrowCheck),\n             RvalueCheck(ref d) => op(d).map(RvalueCheck),\n             TransCrateItem(ref d) => op(d).map(TransCrateItem),\n@@ -245,6 +245,6 @@ impl<D: Clone + Debug> DepNode<D> {\n /// some independent path or string that persists between runs without\n /// the need to be mapped or unmapped. (This ensures we can serialize\n /// them even in the absence of a tcx.)\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct WorkProductId(pub String);\n "}, {"sha": "88cd1efd3459ac6f703ea35c57f45ac3a5e4d66d", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -61,6 +61,12 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n         self.map.get(k)\n     }\n \n+    pub fn get_mut(&mut self, k: &M::Key) -> Option<&mut M::Value> {\n+        self.read(k);\n+        self.write(k);\n+        self.map.get_mut(k)\n+    }\n+\n     pub fn insert(&mut self, k: M::Key, v: M::Value) -> Option<M::Value> {\n         self.write(&k);\n         self.map.insert(k, v)\n@@ -70,6 +76,10 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n         self.read(k);\n         self.map.contains_key(k)\n     }\n+\n+    pub fn keys(&self) -> Vec<M::Key> {\n+        self.map.keys().cloned().collect()\n+    }\n }\n \n impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {"}, {"sha": "d085c24036cef88ec83b52e4772ff4a0fdebaecd", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -41,6 +41,7 @@ pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let task_id = (self.dep_node_fn)(item_def_id);\n             let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n+            assert!(!self.tcx.map.is_inlined_def_id(item_def_id));\n             self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n             self.visitor.visit_item(i);\n             debug!(\"Ended task {:?}\", task_id);"}, {"sha": "789b70ccfa412998157b36c220c0715baafc33e3", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -1854,7 +1854,7 @@ impl<'a> LoweringContext<'a> {\n \n         let parent_def = self.parent_def;\n         let def = self.resolver.definitions().map(|defs| {\n-            let def_path_data = DefPathData::Binding(name);\n+            let def_path_data = DefPathData::Binding(name.as_str());\n             let def_index = defs.create_def_with_parent(parent_def, pat.id, def_path_data);\n             Def::Local(DefId::local(def_index), pat.id)\n         }).unwrap_or(Def::Err);"}, {"sha": "58bbd8add26d96e660b1164e9e02675185c210b0", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -135,11 +135,11 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n                 DefPathData::Impl,\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Trait(..) |\n             ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n-                DefPathData::TypeNs(i.ident.name),\n-            ItemKind::Mod(..) => DefPathData::Module(i.ident.name),\n+                DefPathData::TypeNs(i.ident.name.as_str()),\n+            ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_str()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n-                DefPathData::ValueNs(i.ident.name),\n-            ItemKind::Mac(..) => DefPathData::MacroDef(i.ident.name),\n+                DefPathData::ValueNs(i.ident.name.as_str()),\n+            ItemKind::Mac(..) => DefPathData::MacroDef(i.ident.name.as_str()),\n             ItemKind::Use(..) => DefPathData::Misc,\n         };\n         let def = self.create_def(i.id, def_data);\n@@ -150,12 +150,12 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n                     for v in &enum_definition.variants {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name.name));\n+                                            DefPathData::EnumVariant(v.node.name.name.as_str()));\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n                                 let name = field.ident.map(|ident| ident.name)\n                                     .unwrap_or_else(|| token::intern(&index.to_string()));\n-                                this.create_def(field.id, DefPathData::Field(name));\n+                                this.create_def(field.id, DefPathData::Field(name.as_str()));\n                             }\n \n                             if let Some(ref expr) = v.node.disr_expr {\n@@ -172,8 +172,8 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n                     }\n \n                     for (index, field) in struct_def.fields().iter().enumerate() {\n-                        let name = field.ident.map(|ident| ident.name)\n-                            .unwrap_or(token::intern(&index.to_string()));\n+                        let name = field.ident.map(|ident| ident.name.as_str())\n+                            .unwrap_or(token::intern(&index.to_string()).as_str());\n                         this.create_def(field.id, DefPathData::Field(name));\n                     }\n                 }\n@@ -184,7 +184,8 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n-        let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.ident.name));\n+        let def = self.create_def(foreign_item.id,\n+                                  DefPathData::ValueNs(foreign_item.ident.name.as_str()));\n \n         self.with_parent(def, |this| {\n             visit::walk_foreign_item(this, foreign_item);\n@@ -193,7 +194,7 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n \n     fn visit_generics(&mut self, generics: &Generics) {\n         for ty_param in generics.ty_params.iter() {\n-            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.ident.name));\n+            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.ident.name.as_str()));\n         }\n \n         visit::walk_generics(self, generics);\n@@ -202,9 +203,9 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n     fn visit_trait_item(&mut self, ti: &TraitItem) {\n         let def_data = match ti.node {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n-                DefPathData::ValueNs(ti.ident.name),\n-            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name),\n-            TraitItemKind::Macro(..) => DefPathData::MacroDef(ti.ident.name),\n+                DefPathData::ValueNs(ti.ident.name.as_str()),\n+            TraitItemKind::Type(..) => DefPathData::TypeNs(ti.ident.name.as_str()),\n+            TraitItemKind::Macro(..) => DefPathData::MacroDef(ti.ident.name.as_str()),\n         };\n \n         let def = self.create_def(ti.id, def_data);\n@@ -220,9 +221,9 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n     fn visit_impl_item(&mut self, ii: &ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.ident.name),\n-            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name),\n-            ImplItemKind::Macro(..) => DefPathData::MacroDef(ii.ident.name),\n+                DefPathData::ValueNs(ii.ident.name.as_str()),\n+            ImplItemKind::Type(..) => DefPathData::TypeNs(ii.ident.name.as_str()),\n+            ImplItemKind::Macro(..) => DefPathData::MacroDef(ii.ident.name.as_str()),\n         };\n \n         let def = self.create_def(ii.id, def_data);\n@@ -239,7 +240,7 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n         let parent_def = self.parent_def;\n \n         if let PatKind::Ident(_, id, _) = pat.node {\n-            let def = self.create_def(pat.id, DefPathData::Binding(id.node.name));\n+            let def = self.create_def(pat.id, DefPathData::Binding(id.node.name.as_str()));\n             self.parent_def = Some(def);\n         }\n \n@@ -271,11 +272,11 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n     }\n \n     fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n-        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n+        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name.as_str()));\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n-        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name));\n+        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name.as_str()));\n     }\n }\n \n@@ -301,9 +302,9 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n             hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemTrait(..) |\n             hir::ItemExternCrate(..) | hir::ItemMod(..) | hir::ItemForeignMod(..) |\n             hir::ItemTy(..) =>\n-                DefPathData::TypeNs(i.name),\n+                DefPathData::TypeNs(i.name.as_str()),\n             hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) =>\n-                DefPathData::ValueNs(i.name),\n+                DefPathData::ValueNs(i.name.as_str()),\n             hir::ItemUse(..) => DefPathData::Misc,\n         };\n         let def = self.create_def(i.id, def_data);\n@@ -314,12 +315,12 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n                     for v in &enum_definition.variants {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name));\n+                                            DefPathData::EnumVariant(v.node.name.as_str()));\n \n                         this.with_parent(variant_def_index, |this| {\n                             for field in v.node.data.fields() {\n                                 this.create_def(field.id,\n-                                                DefPathData::Field(field.name));\n+                                                DefPathData::Field(field.name.as_str()));\n                             }\n                             if let Some(ref expr) = v.node.disr_expr {\n                                 this.visit_hir_const_integer(expr);\n@@ -335,7 +336,7 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n                     }\n \n                     for field in struct_def.fields() {\n-                        this.create_def(field.id, DefPathData::Field(field.name));\n+                        this.create_def(field.id, DefPathData::Field(field.name.as_str()));\n                     }\n                 }\n                 _ => {}\n@@ -345,7 +346,8 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &'ast hir::ForeignItem) {\n-        let def = self.create_def(foreign_item.id, DefPathData::ValueNs(foreign_item.name));\n+        let def = self.create_def(foreign_item.id,\n+                                  DefPathData::ValueNs(foreign_item.name.as_str()));\n \n         self.with_parent(def, |this| {\n             intravisit::walk_foreign_item(this, foreign_item);\n@@ -354,7 +356,7 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n \n     fn visit_generics(&mut self, generics: &'ast hir::Generics) {\n         for ty_param in generics.ty_params.iter() {\n-            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.name));\n+            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.name.as_str()));\n         }\n \n         intravisit::walk_generics(self, generics);\n@@ -363,8 +365,8 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n     fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n         let def_data = match ti.node {\n             hir::MethodTraitItem(..) | hir::ConstTraitItem(..) =>\n-                DefPathData::ValueNs(ti.name),\n-            hir::TypeTraitItem(..) => DefPathData::TypeNs(ti.name),\n+                DefPathData::ValueNs(ti.name.as_str()),\n+            hir::TypeTraitItem(..) => DefPathData::TypeNs(ti.name.as_str()),\n         };\n \n         let def = self.create_def(ti.id, def_data);\n@@ -380,8 +382,8 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n     fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n         let def_data = match ii.node {\n             hir::ImplItemKind::Method(..) | hir::ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.name),\n-            hir::ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name),\n+                DefPathData::ValueNs(ii.name.as_str()),\n+            hir::ImplItemKind::Type(..) => DefPathData::TypeNs(ii.name.as_str()),\n         };\n \n         let def = self.create_def(ii.id, def_data);\n@@ -398,7 +400,7 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n         let parent_def = self.parent_def;\n \n         if let hir::PatKind::Binding(_, name, _) = pat.node {\n-            let def = self.create_def(pat.id, DefPathData::Binding(name.node));\n+            let def = self.create_def(pat.id, DefPathData::Binding(name.node.as_str()));\n             self.parent_def = Some(def);\n         }\n \n@@ -430,10 +432,10 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n     }\n \n     fn visit_lifetime_def(&mut self, def: &'ast hir::LifetimeDef) {\n-        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name));\n+        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name.as_str()));\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'ast hir::MacroDef) {\n-        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name));\n+        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.name.as_str()));\n     }\n }"}, {"sha": "e3425d7fa61f5f73d9270f4ed5f4163e49efc59c", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 56, "deletions": 19, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -12,8 +12,11 @@ use middle::cstore::LOCAL_CRATE;\n use hir::def_id::{DefId, DefIndex};\n use hir::map::def_collector::DefCollector;\n use rustc_data_structures::fnv::FnvHashMap;\n+use std::fmt::Write;\n+use std::hash::{Hash, Hasher, SipHasher};\n use syntax::{ast, visit};\n use syntax::parse::token::InternedString;\n+use ty::TyCtxt;\n use util::nodemap::NodeMap;\n \n /// The definition table containing node definitions\n@@ -109,6 +112,40 @@ impl DefPath {\n         data.reverse();\n         DefPath { data: data, krate: krate }\n     }\n+\n+    pub fn to_string(&self, tcx: TyCtxt) -> String {\n+        let mut s = String::with_capacity(self.data.len() * 16);\n+\n+        if self.krate == LOCAL_CRATE {\n+            s.push_str(&tcx.crate_name(self.krate));\n+        } else {\n+            s.push_str(&tcx.sess.cstore.original_crate_name(self.krate));\n+        }\n+        s.push_str(\"/\");\n+        s.push_str(&tcx.crate_disambiguator(self.krate));\n+\n+        for component in &self.data {\n+            write!(s,\n+                   \"::{}[{}]\",\n+                   component.data.as_interned_str(),\n+                   component.disambiguator)\n+                .unwrap();\n+        }\n+\n+        s\n+    }\n+\n+    pub fn deterministic_hash(&self, tcx: TyCtxt) -> u64 {\n+        let mut state = SipHasher::new();\n+        self.deterministic_hash_to(tcx, &mut state);\n+        state.finish()\n+    }\n+\n+    pub fn deterministic_hash_to<H: Hasher>(&self, tcx: TyCtxt, state: &mut H) {\n+        tcx.crate_name(self.krate).hash(state);\n+        tcx.crate_disambiguator(self.krate).hash(state);\n+        self.data.hash(state);\n+    }\n }\n \n /// Root of an inlined item. We track the `DefPath` of the item within\n@@ -153,31 +190,31 @@ pub enum DefPathData {\n     /// An impl\n     Impl,\n     /// Something in the type NS\n-    TypeNs(ast::Name),\n+    TypeNs(InternedString),\n     /// Something in the value NS\n-    ValueNs(ast::Name),\n+    ValueNs(InternedString),\n     /// A module declaration\n-    Module(ast::Name),\n+    Module(InternedString),\n     /// A macro rule\n-    MacroDef(ast::Name),\n+    MacroDef(InternedString),\n     /// A closure expression\n     ClosureExpr,\n \n     // Subportions of items\n     /// A type parameter (generic parameter)\n-    TypeParam(ast::Name),\n+    TypeParam(InternedString),\n     /// A lifetime definition\n-    LifetimeDef(ast::Name),\n+    LifetimeDef(InternedString),\n     /// A variant of a enum\n-    EnumVariant(ast::Name),\n+    EnumVariant(InternedString),\n     /// A struct field\n-    Field(ast::Name),\n+    Field(InternedString),\n     /// Implicit ctor for a tuple-like struct\n     StructCtor,\n     /// Initializer for a const\n     Initializer,\n     /// Pattern binding\n-    Binding(ast::Name),\n+    Binding(InternedString),\n }\n \n impl Definitions {\n@@ -291,16 +328,16 @@ impl DefPathData {\n     pub fn as_interned_str(&self) -> InternedString {\n         use self::DefPathData::*;\n         match *self {\n-            TypeNs(name) |\n-            ValueNs(name) |\n-            Module(name) |\n-            MacroDef(name) |\n-            TypeParam(name) |\n-            LifetimeDef(name) |\n-            EnumVariant(name) |\n-            Binding(name) |\n-            Field(name) => {\n-                name.as_str()\n+            TypeNs(ref name) |\n+            ValueNs(ref name) |\n+            Module(ref name) |\n+            MacroDef(ref name) |\n+            TypeParam(ref name) |\n+            LifetimeDef(ref name) |\n+            EnumVariant(ref name) |\n+            Binding(ref name) |\n+            Field(ref name) => {\n+                name.clone()\n             }\n \n             Impl => {"}, {"sha": "86d29a6fc717fea971bcbd5d5b27c653cd188116", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 105, "deletions": 54, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -204,70 +204,121 @@ pub struct Map<'ast> {\n     /// All NodeIds that are numerically greater or equal to this value come\n     /// from inlined items.\n     local_node_id_watermark: NodeId,\n+\n+    /// All def-indices that are numerically greater or equal to this value come\n+    /// from inlined items.\n+    local_def_id_watermark: usize,\n }\n \n impl<'ast> Map<'ast> {\n+    pub fn is_inlined_def_id(&self, id: DefId) -> bool {\n+        id.is_local() && id.index.as_usize() >= self.local_def_id_watermark\n+    }\n+\n+    pub fn is_inlined_node_id(&self, id: NodeId) -> bool {\n+        id >= self.local_node_id_watermark\n+    }\n+\n     /// Registers a read in the dependency graph of the AST node with\n     /// the given `id`. This needs to be called each time a public\n     /// function returns the HIR for a node -- in other words, when it\n     /// \"reveals\" the content of a node to the caller (who might not\n     /// otherwise have had access to those contents, and hence needs a\n     /// read recorded). If the function just returns a DefId or\n     /// NodeId, no actual content was returned, so no read is needed.\n-    fn read(&self, id: NodeId) {\n+    pub fn read(&self, id: NodeId) {\n         self.dep_graph.read(self.dep_node(id));\n     }\n \n     fn dep_node(&self, id0: NodeId) -> DepNode<DefId> {\n         let map = self.map.borrow();\n         let mut id = id0;\n-        loop {\n-            match map[id as usize] {\n-                EntryItem(_, item) => {\n-                    let def_id = self.local_def_id(item.id);\n-                    // NB                          ^~~~~~~\n-                    //\n-                    // You would expect that `item.id == id`, but this\n-                    // is not always the case. In particular, for a\n-                    // ViewPath item like `use self::{mem, foo}`, we\n-                    // map the ids for `mem` and `foo` to the\n-                    // enclosing view path item. This seems mega super\n-                    // ultra wrong, but then who am I to judge?\n-                    // -nmatsakis\n-                    return DepNode::Hir(def_id);\n-                }\n+        if !self.is_inlined_node_id(id) {\n+            loop {\n+                match map[id as usize] {\n+                    EntryItem(_, item) => {\n+                        let def_id = self.local_def_id(item.id);\n+                        // NB                          ^~~~~~~\n+                        //\n+                        // You would expect that `item.id == id`, but this\n+                        // is not always the case. In particular, for a\n+                        // ViewPath item like `use self::{mem, foo}`, we\n+                        // map the ids for `mem` and `foo` to the\n+                        // enclosing view path item. This seems mega super\n+                        // ultra wrong, but then who am I to judge?\n+                        // -nmatsakis\n+                        assert!(!self.is_inlined_def_id(def_id));\n+                        return DepNode::Hir(def_id);\n+                    }\n \n-                EntryForeignItem(p, _) |\n-                EntryTraitItem(p, _) |\n-                EntryImplItem(p, _) |\n-                EntryVariant(p, _) |\n-                EntryExpr(p, _) |\n-                EntryStmt(p, _) |\n-                EntryLocal(p, _) |\n-                EntryPat(p, _) |\n-                EntryBlock(p, _) |\n-                EntryStructCtor(p, _) |\n-                EntryLifetime(p, _) |\n-                EntryTyParam(p, _) =>\n-                    id = p,\n-\n-                RootCrate |\n-                RootInlinedParent(_) =>\n-                    // FIXME(#32015) clarify story about cross-crate dep tracking\n-                    return DepNode::Krate,\n-\n-                NotPresent =>\n-                    // Some nodes, notably struct fields, are not\n-                    // present in the map for whatever reason, but\n-                    // they *do* have def-ids. So if we encounter an\n-                    // empty hole, check for that case.\n-                    return self.opt_local_def_id(id)\n-                               .map(|def_id| DepNode::Hir(def_id))\n-                               .unwrap_or_else(|| {\n-                                   bug!(\"Walking parents from `{}` \\\n-                                         led to `NotPresent` at `{}`\",\n-                                        id0, id)\n-                               }),\n+                    EntryForeignItem(p, _) |\n+                    EntryTraitItem(p, _) |\n+                    EntryImplItem(p, _) |\n+                    EntryVariant(p, _) |\n+                    EntryExpr(p, _) |\n+                    EntryStmt(p, _) |\n+                    EntryLocal(p, _) |\n+                    EntryPat(p, _) |\n+                    EntryBlock(p, _) |\n+                    EntryStructCtor(p, _) |\n+                    EntryLifetime(p, _) |\n+                    EntryTyParam(p, _) =>\n+                        id = p,\n+\n+                    RootCrate =>\n+                        return DepNode::Krate,\n+\n+                    RootInlinedParent(_) =>\n+                        bug!(\"node {} has inlined ancestor but is not inlined\", id0),\n+\n+                    NotPresent =>\n+                        // Some nodes, notably struct fields, are not\n+                        // present in the map for whatever reason, but\n+                        // they *do* have def-ids. So if we encounter an\n+                        // empty hole, check for that case.\n+                        return self.opt_local_def_id(id)\n+                                   .map(|def_id| DepNode::Hir(def_id))\n+                                   .unwrap_or_else(|| {\n+                                       bug!(\"Walking parents from `{}` \\\n+                                             led to `NotPresent` at `{}`\",\n+                                            id0, id)\n+                                   }),\n+                }\n+            }\n+        } else {\n+            // reading from an inlined def-id is really a read out of\n+            // the metadata from which we loaded the item.\n+            loop {\n+                match map[id as usize] {\n+                    EntryItem(p, _) |\n+                    EntryForeignItem(p, _) |\n+                    EntryTraitItem(p, _) |\n+                    EntryImplItem(p, _) |\n+                    EntryVariant(p, _) |\n+                    EntryExpr(p, _) |\n+                    EntryStmt(p, _) |\n+                    EntryLocal(p, _) |\n+                    EntryPat(p, _) |\n+                    EntryBlock(p, _) |\n+                    EntryStructCtor(p, _) |\n+                    EntryLifetime(p, _) |\n+                    EntryTyParam(p, _) =>\n+                        id = p,\n+\n+                    RootInlinedParent(parent) => match *parent {\n+                        InlinedItem::Item(def_id, _) |\n+                        InlinedItem::TraitItem(def_id, _) |\n+                        InlinedItem::ImplItem(def_id, _) |\n+                        InlinedItem::Foreign(def_id, _) =>\n+                            return DepNode::MetaData(def_id)\n+                    },\n+\n+                    RootCrate =>\n+                        bug!(\"node {} has crate ancestor but is inlined\", id0),\n+\n+                    NotPresent =>\n+                        bug!(\"node {} is inlined but not present in map\", id0),\n+                }\n             }\n         }\n     }\n@@ -664,10 +715,6 @@ impl<'ast> Map<'ast> {\n     pub fn node_to_user_string(&self, id: NodeId) -> String {\n         node_id_to_string(self, id, false)\n     }\n-\n-    pub fn is_inlined(&self, id: NodeId) -> bool {\n-        id >= self.local_node_id_watermark\n-    }\n }\n \n pub struct NodesMatchingSuffix<'a, 'ast:'a> {\n@@ -846,13 +893,15 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n     }\n \n     let local_node_id_watermark = map.len() as NodeId;\n+    let local_def_id_watermark = definitions.len();\n \n     Map {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n         map: RefCell::new(map),\n         definitions: RefCell::new(definitions),\n-        local_node_id_watermark: local_node_id_watermark\n+        local_node_id_watermark: local_node_id_watermark,\n+        local_def_id_watermark: local_def_id_watermark,\n     }\n }\n \n@@ -866,7 +915,8 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n                                           -> &'ast InlinedItem {\n     let mut fld = IdAndSpanUpdater::new(fold_ops);\n     let ii = match ii {\n-        II::Item(i) => II::Item(i.map(|i| fld.fold_item(i))),\n+        II::Item(d, i) => II::Item(fld.fold_ops.new_def_id(d),\n+                                   i.map(|i| fld.fold_item(i))),\n         II::TraitItem(d, ti) => {\n             II::TraitItem(fld.fold_ops.new_def_id(d),\n                           ti.map(|ti| fld.fold_trait_item(ti)))\n@@ -875,7 +925,8 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n             II::ImplItem(fld.fold_ops.new_def_id(d),\n                          ii.map(|ii| fld.fold_impl_item(ii)))\n         }\n-        II::Foreign(i) => II::Foreign(i.map(|i| fld.fold_foreign_item(i)))\n+        II::Foreign(d, i) => II::Foreign(fld.fold_ops.new_def_id(d),\n+                                         i.map(|i| fld.fold_foreign_item(i)))\n     };\n \n     let ii = map.forest.inlined_items.alloc(ii);"}, {"sha": "f1bb3a37e3c273c9ebbfbf39850cff2cd8a3b1f6", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -94,19 +94,19 @@ pub enum DefLike {\n /// that we trans.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum InlinedItem {\n-    Item(P<hir::Item>),\n+    Item(DefId /* def-id in source crate */, P<hir::Item>),\n     TraitItem(DefId /* impl id */, P<hir::TraitItem>),\n     ImplItem(DefId /* impl id */, P<hir::ImplItem>),\n-    Foreign(P<hir::ForeignItem>),\n+    Foreign(DefId /* extern item */, P<hir::ForeignItem>),\n }\n \n /// A borrowed version of `hir::InlinedItem`.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InlinedItemRef<'a> {\n-    Item(&'a hir::Item),\n+    Item(DefId, &'a hir::Item),\n     TraitItem(DefId, &'a hir::TraitItem),\n     ImplItem(DefId, &'a hir::ImplItem),\n-    Foreign(&'a hir::ForeignItem)\n+    Foreign(DefId, &'a hir::ForeignItem)\n }\n \n /// Item definitions in the currently-compiled crate would have the CrateNum\n@@ -283,8 +283,8 @@ impl InlinedItem {\n         where V: Visitor<'ast>\n     {\n         match *self {\n-            InlinedItem::Item(ref i) => visitor.visit_item(&i),\n-            InlinedItem::Foreign(ref i) => visitor.visit_foreign_item(&i),\n+            InlinedItem::Item(_, ref i) => visitor.visit_item(&i),\n+            InlinedItem::Foreign(_, ref i) => visitor.visit_foreign_item(&i),\n             InlinedItem::TraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n             InlinedItem::ImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n         }"}, {"sha": "92de65798d3cbb18db8277631034ce72439f3f6d", "filename": "src/librustc/mir/mir_map.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fmir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fmir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmir_map.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -8,9 +8,31 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use util::nodemap::NodeMap;\n+use dep_graph::{DepGraph, DepNode, DepTrackingMap, DepTrackingMapConfig};\n+use hir::def_id::DefId;\n use mir::repr::Mir;\n+use std::marker::PhantomData;\n \n pub struct MirMap<'tcx> {\n-    pub map: NodeMap<Mir<'tcx>>,\n+    pub map: DepTrackingMap<MirMapConfig<'tcx>>,\n+}\n+\n+impl<'tcx> MirMap<'tcx> {\n+    pub fn new(graph: DepGraph) -> Self {\n+        MirMap {\n+            map: DepTrackingMap::new(graph)\n+        }\n+    }\n+}\n+\n+pub struct MirMapConfig<'tcx> {\n+    data: PhantomData<&'tcx ()>\n+}\n+\n+impl<'tcx> DepTrackingMapConfig for MirMapConfig<'tcx> {\n+    type Key = DefId;\n+    type Value = Mir<'tcx>;\n+    fn to_dep_node(key: &DefId) -> DepNode<DefId> {\n+        DepNode::Mir(*key)\n+    }\n }"}, {"sha": "57601e67504328f7f422a631be2c174c61852781", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -11,7 +11,6 @@\n use dep_graph::DepNode;\n use hir;\n use hir::map::DefPathData;\n-use hir::def_id::DefId;\n use mir::mir_map::MirMap;\n use mir::repr::{Mir, Promoted};\n use ty::TyCtxt;\n@@ -73,9 +72,6 @@ impl<'a, 'tcx> MirSource {\n /// Various information about pass.\n pub trait Pass {\n     // fn should_run(Session) to check if pass should run?\n-    fn dep_node(&self, def_id: DefId) -> DepNode<DefId> {\n-        DepNode::MirPass(def_id)\n-    }\n     fn name(&self) -> &str {\n         let name = unsafe { ::std::intrinsics::type_name::<Self>() };\n         if let Some(tail) = name.rfind(\":\") {\n@@ -119,10 +115,11 @@ impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n                     map: &mut MirMap<'tcx>,\n                     hooks: &mut [Box<for<'s> MirPassHook<'s>>])\n     {\n-        for (&id, mir) in &mut map.map {\n-            let def_id = tcx.map.local_def_id(id);\n-            let _task = tcx.dep_graph.in_task(self.dep_node(def_id));\n-\n+        let def_ids = map.map.keys();\n+        for def_id in def_ids {\n+            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n+            let mir = map.map.get_mut(&def_id).unwrap();\n+            let id = tcx.map.as_local_node_id(def_id).unwrap();\n             let src = MirSource::from_node(tcx, id);\n \n             for hook in &mut *hooks {"}, {"sha": "20cf9dc44309fa63080a2eacae08ba46379b8c60", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -745,6 +745,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"attempt to recover from parse errors (experimental)\"),\n     incremental: Option<String> = (None, parse_opt_string,\n           \"enable incremental compilation (experimental)\"),\n+    incremental_info: bool = (false, parse_bool,\n+        \"print high-level information about incremental reuse (or the lack thereof)\"),\n     dump_dep_graph: bool = (false, parse_bool,\n           \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n     query_dep_graph: bool = (false, parse_bool,"}, {"sha": "77cc62060aad939d62513f966435c55b8dd57d96", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -525,7 +525,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn retrace_path(self, path: &DefPath) -> Option<DefId> {\n-        debug!(\"retrace_path(path={:?})\", path);\n+        debug!(\"retrace_path(path={:?}, krate={:?})\", path, self.crate_name(path.krate));\n \n         let root_key = DefKey {\n             parent: None,"}, {"sha": "634599406afb2fc49627a734559fccb5e0c4abc1", "filename": "src/librustc/ty/ivar.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fty%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fty%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fivar.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -52,8 +52,10 @@ impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n         self.untracked_get()\n     }\n \n+    /// Reads the ivar without registered a dep-graph read. Use with\n+    /// caution.\n     #[inline]\n-    fn untracked_get(&self) -> Option<Ty<'tcx>> {\n+    pub fn untracked_get(&self) -> Option<Ty<'tcx>> {\n         match self.0.get() {\n             None => None,\n             // valid because of invariant (A)"}, {"sha": "a7c534198923b7a1183bb7f9b7f0a0d65dcd24bf", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -1757,8 +1757,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer, e.g. issue #31299.\n     pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        let dep_node = DepNode::SizedConstraint(self.did);\n-        match self.sized_constraint.get(dep_node) {\n+        match self.sized_constraint.get(DepNode::SizedConstraint(self.did)) {\n             None => {\n                 let global_tcx = tcx.global_tcx();\n                 let this = global_tcx.lookup_adt_def_master(self.did);\n@@ -1786,12 +1785,18 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n     ///       such.\n     ///     - a TyError, if a type contained itself. The representability\n     ///       check should catch this case.\n-    fn calculate_sized_constraint_inner(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn calculate_sized_constraint_inner(&'tcx self,\n+                                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         stack: &mut Vec<AdtDefMaster<'tcx>>)\n     {\n-\n         let dep_node = || DepNode::SizedConstraint(self.did);\n-        if self.sized_constraint.get(dep_node()).is_some() {\n+\n+        // Follow the memoization pattern: push the computation of\n+        // DepNode::SizedConstraint as our current task.\n+        let _task = tcx.dep_graph.in_task(dep_node());\n+        if self.sized_constraint.untracked_get().is_some() {\n+            //                   ---------------\n+            // can skip the dep-graph read since we just pushed the task\n             return;\n         }\n "}, {"sha": "904cffac6b3cd88e06b21391382e9f198f3a22b1", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -168,8 +168,10 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                attributes: &[ast::Attribute]) {\n     debug!(\"borrowck_fn(id={})\", id);\n \n+    let def_id = this.tcx.map.local_def_id(id);\n+\n     if attributes.iter().any(|item| item.check_name(\"rustc_mir_borrowck\")) {\n-        let mir = this.mir_map.unwrap().map.get(&id).unwrap();\n+        let mir = this.mir_map.unwrap().map.get(&def_id).unwrap();\n         this.with_temp_region_map(id, |this| {\n             mir::borrowck_mir(this, fk, decl, mir, body, sp, id, attributes)\n         });"}, {"sha": "ab0f20136eda0dcb4d018dd76e4f11cd38799627", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -142,7 +142,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         let mut used_substs = false;\n         let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-            Some((&InlinedItem::Item(ref item), _)) => match item.node {\n+            Some((&InlinedItem::Item(_, ref item), _)) => match item.node {\n                 hir::ItemConst(ref ty, ref const_expr) => {\n                     Some((&**const_expr, tcx.ast_ty_to_prim_ty(ty)))\n                 },\n@@ -198,7 +198,7 @@ fn inline_const_fn_from_external_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let fn_id = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-        Some((&InlinedItem::Item(ref item), _)) => Some(item.id),\n+        Some((&InlinedItem::Item(_, ref item), _)) => Some(item.id),\n         Some((&InlinedItem::ImplItem(_, ref item), _)) => Some(item.id),\n         _ => None\n     };"}, {"sha": "0dab230f47a2d036bac2fc9b520417d592c249ef", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 73, "deletions": 16, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -22,6 +22,12 @@ impl BitVector {\n         BitVector { data: vec![0; num_words] }\n     }\n \n+    pub fn clear(&mut self) {\n+        for p in &mut self.data {\n+            *p = 0;\n+        }\n+    }\n+\n     pub fn contains(&self, bit: usize) -> bool {\n         let (word, mask) = word_mask(bit);\n         (self.data[word] & mask) != 0\n@@ -118,32 +124,32 @@ impl FromIterator<bool> for BitVector {\n     }\n }\n \n-/// A \"bit matrix\" is basically a square matrix of booleans\n-/// represented as one gigantic bitvector. In other words, it is as if\n-/// you have N bitvectors, each of length N. Note that `elements` here is `N`/\n+/// A \"bit matrix\" is basically a matrix of booleans represented as\n+/// one gigantic bitvector. In other words, it is as if you have\n+/// `rows` bitvectors, each of length `columns`.\n #[derive(Clone)]\n pub struct BitMatrix {\n-    elements: usize,\n+    columns: usize,\n     vector: Vec<u64>,\n }\n \n impl BitMatrix {\n-    // Create a new `elements x elements` matrix, initially empty.\n-    pub fn new(elements: usize) -> BitMatrix {\n+    // Create a new `rows x columns` matrix, initially empty.\n+    pub fn new(rows: usize, columns: usize) -> BitMatrix {\n         // For every element, we need one bit for every other\n         // element. Round up to an even number of u64s.\n-        let u64s_per_elem = u64s(elements);\n+        let u64s_per_row = u64s(columns);\n         BitMatrix {\n-            elements: elements,\n-            vector: vec![0; elements * u64s_per_elem],\n+            columns: columns,\n+            vector: vec![0; rows * u64s_per_row],\n         }\n     }\n \n-    /// The range of bits for a given element.\n-    fn range(&self, element: usize) -> (usize, usize) {\n-        let u64s_per_elem = u64s(self.elements);\n-        let start = element * u64s_per_elem;\n-        (start, start + u64s_per_elem)\n+    /// The range of bits for a given row.\n+    fn range(&self, row: usize) -> (usize, usize) {\n+        let u64s_per_row = u64s(self.columns);\n+        let start = row * u64s_per_row;\n+        (start, start + u64s_per_row)\n     }\n \n     pub fn add(&mut self, source: usize, target: usize) -> bool {\n@@ -173,7 +179,7 @@ impl BitMatrix {\n     pub fn intersection(&self, a: usize, b: usize) -> Vec<usize> {\n         let (a_start, a_end) = self.range(a);\n         let (b_start, b_end) = self.range(b);\n-        let mut result = Vec::with_capacity(self.elements);\n+        let mut result = Vec::with_capacity(self.columns);\n         for (base, (i, j)) in (a_start..a_end).zip(b_start..b_end).enumerate() {\n             let mut v = self.vector[i] & self.vector[j];\n             for bit in 0..64 {\n@@ -209,6 +215,15 @@ impl BitMatrix {\n         }\n         changed\n     }\n+\n+    pub fn iter<'a>(&'a self, row: usize) -> BitVectorIter<'a> {\n+        let (start, end) = self.range(row);\n+        BitVectorIter {\n+            iter: self.vector[start..end].iter(),\n+            current: 0,\n+            idx: 0,\n+        }\n+    }\n }\n \n fn u64s(elements: usize) -> usize {\n@@ -294,7 +309,7 @@ fn grow() {\n \n #[test]\n fn matrix_intersection() {\n-    let mut vec1 = BitMatrix::new(200);\n+    let mut vec1 = BitMatrix::new(200, 200);\n \n     // (*) Elements reachable from both 2 and 65.\n \n@@ -322,3 +337,45 @@ fn matrix_intersection() {\n     let intersection = vec1.intersection(2, 65);\n     assert_eq!(intersection, &[10, 64, 160]);\n }\n+\n+#[test]\n+fn matrix_iter() {\n+    let mut matrix = BitMatrix::new(64, 100);\n+    matrix.add(3, 22);\n+    matrix.add(3, 75);\n+    matrix.add(2, 99);\n+    matrix.add(4, 0);\n+    matrix.merge(3, 5);\n+\n+    let expected = [99];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(2) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(3) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [0];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(4) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(5) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+}"}, {"sha": "4561a3d084c2064183aac1d611cf1850d514b608", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 44, "deletions": 18, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -296,12 +296,7 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n                               start: NodeIndex,\n                               direction: Direction)\n                               -> DepthFirstTraversal<'a, N, E> {\n-        DepthFirstTraversal {\n-            graph: self,\n-            stack: vec![start],\n-            visited: BitVector::new(self.nodes.len()),\n-            direction: direction,\n-        }\n+        DepthFirstTraversal::with_start_node(self, start, direction)\n     }\n }\n \n@@ -378,26 +373,57 @@ pub struct DepthFirstTraversal<'g, N: 'g, E: 'g> {\n     direction: Direction,\n }\n \n+impl<'g, N: Debug, E: Debug> DepthFirstTraversal<'g, N, E> {\n+    pub fn new(graph: &'g Graph<N, E>, direction: Direction) -> Self {\n+        let visited = BitVector::new(graph.len_nodes());\n+        DepthFirstTraversal {\n+            graph: graph,\n+            stack: vec![],\n+            visited: visited,\n+            direction: direction\n+        }\n+    }\n+\n+    pub fn with_start_node(graph: &'g Graph<N, E>,\n+                           start_node: NodeIndex,\n+                           direction: Direction)\n+                           -> Self {\n+        let mut visited = BitVector::new(graph.len_nodes());\n+        visited.insert(start_node.node_id());\n+        DepthFirstTraversal {\n+            graph: graph,\n+            stack: vec![start_node],\n+            visited: visited,\n+            direction: direction\n+        }\n+    }\n+\n+    pub fn reset(&mut self, start_node: NodeIndex) {\n+        self.stack.truncate(0);\n+        self.stack.push(start_node);\n+        self.visited.clear();\n+        self.visited.insert(start_node.node_id());\n+    }\n+\n+    fn visit(&mut self, node: NodeIndex) {\n+        if self.visited.insert(node.node_id()) {\n+            self.stack.push(node);\n+        }\n+    }\n+}\n+\n impl<'g, N: Debug, E: Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n     type Item = NodeIndex;\n \n     fn next(&mut self) -> Option<NodeIndex> {\n-        while let Some(idx) = self.stack.pop() {\n-            if !self.visited.insert(idx.node_id()) {\n-                continue;\n-            }\n-\n+        let next = self.stack.pop();\n+        if let Some(idx) = next {\n             for (_, edge) in self.graph.adjacent_edges(idx, self.direction) {\n                 let target = edge.source_or_target(self.direction);\n-                if !self.visited.contains(target.node_id()) {\n-                    self.stack.push(target);\n-                }\n+                self.visit(target);\n             }\n-\n-            return Some(idx);\n         }\n-\n-        return None;\n+        next\n     }\n }\n "}, {"sha": "e09e260afc8d99c0e0fddc6d0c3b6a85f26deb49", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -252,7 +252,8 @@ impl<T: Debug + PartialEq> TransitiveRelation<T> {\n     }\n \n     fn compute_closure(&self) -> BitMatrix {\n-        let mut matrix = BitMatrix::new(self.elements.len());\n+        let mut matrix = BitMatrix::new(self.elements.len(),\n+                                        self.elements.len());\n         let mut changed = true;\n         while changed {\n             changed = false;"}, {"sha": "e3e06963ad43bf59f242c1025decbd173fe729ff", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -956,20 +956,24 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n             PpmMir | PpmMirCFG => {\n                 if let Some(mir_map) = mir_map {\n                     if let Some(nodeid) = nodeid {\n-                        let mir = mir_map.map.get(&nodeid).unwrap_or_else(|| {\n-                            sess.fatal(&format!(\"no MIR map entry for node {}\", nodeid))\n-                        });\n+                        let def_id = tcx.map.local_def_id(nodeid);\n                         match ppm {\n-                            PpmMir => write_mir_pretty(tcx, iter::once((&nodeid, mir)), &mut out),\n+                            PpmMir => write_mir_pretty(tcx, iter::once(def_id), &mir_map, &mut out),\n                             PpmMirCFG => {\n-                                write_mir_graphviz(tcx, iter::once((&nodeid, mir)), &mut out)\n+                                write_mir_graphviz(tcx, iter::once(def_id), &mir_map, &mut out)\n                             }\n                             _ => unreachable!(),\n                         }?;\n                     } else {\n                         match ppm {\n-                            PpmMir => write_mir_pretty(tcx, mir_map.map.iter(), &mut out),\n-                            PpmMirCFG => write_mir_graphviz(tcx, mir_map.map.iter(), &mut out),\n+                            PpmMir => write_mir_pretty(tcx,\n+                                                       mir_map.map.keys().into_iter(),\n+                                                       &mir_map,\n+                                                       &mut out),\n+                            PpmMirCFG => write_mir_graphviz(tcx,\n+                                                            mir_map.map.keys().into_iter(),\n+                                                            &mir_map,\n+                                                            &mut out),\n                             _ => unreachable!(),\n                         }?;\n                     }"}, {"sha": "420c88e89be0d0373aff440bc5bbc9173a1543b8", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -71,6 +71,13 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         dump_graph(tcx);\n     }\n \n+    // if the `rustc_attrs` feature is not enabled, then the\n+    // attributes we are interested in cannot be present anyway, so\n+    // skip the walk.\n+    if !tcx.sess.features.borrow().rustc_attrs {\n+        return;\n+    }\n+\n     // Find annotations supplied by user (if any).\n     let (if_this_changed, then_this_would_need) = {\n         let mut visitor = IfThisChanged { tcx: tcx,"}, {"sha": "4b2d42ca8895ce59417ece0865e521cac8e906dd", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -14,6 +14,7 @@\n use syntax::attr::AttributeMethods;\n use std::hash::{Hash, SipHasher, Hasher};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::map::{NodeItem, NodeForeignItem};\n use rustc::hir::svh::Svh;\n use rustc::ty::TyCtxt;\n use rustc::hir::intravisit::{self, Visitor};\n@@ -92,8 +93,12 @@ impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n                 intravisit::walk_crate(&mut visit, krate);\n             } else {\n                 let node_id = self.map.as_local_node_id(def_id).unwrap();\n-                let item = self.map.expect_item(node_id);\n-                visit.visit_item(item);\n+                match self.map.find(node_id) {\n+                    Some(NodeItem(item)) => visit.visit_item(item),\n+                    Some(NodeForeignItem(item)) => visit.visit_foreign_item(item),\n+                    r => bug!(\"calculate_item_hash: expected an item for node {} not {:?}\",\n+                              node_id, r),\n+                }\n             }\n         }\n \n@@ -139,12 +144,7 @@ mod svh_visitor {\n         }\n \n         fn hash_def_path(&mut self, path: &DefPath) {\n-            self.tcx.crate_name(path.krate).hash(self.st);\n-            self.tcx.crate_disambiguator(path.krate).hash(self.st);\n-            for data in &path.data {\n-                data.data.as_interned_str().hash(self.st);\n-                data.disambiguator.hash(self.st);\n-            }\n+            path.deterministic_hash_to(self.tcx, self.st);\n         }\n     }\n "}, {"sha": "12f3ed8ae2bd4caefa6e1e32c3695ebd093e890d", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -19,7 +19,6 @@ use super::directory::DefPathIndex;\n /// Data for use when recompiling the **current crate**.\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedDepGraph {\n-    pub nodes: Vec<DepNode<DefPathIndex>>,\n     pub edges: Vec<SerializedEdge>,\n \n     /// These are hashes of two things:\n@@ -44,15 +43,22 @@ pub struct SerializedDepGraph {\n     pub hashes: Vec<SerializedHash>,\n }\n \n+/// Represents a \"reduced\" dependency edge. Unlike the full dep-graph,\n+/// the dep-graph we serialize contains only edges `S -> T` where the\n+/// source `S` is something hashable (a HIR node or foreign metadata)\n+/// and the target `T` is something significant, like a work-product.\n+/// Normally, significant nodes are only those that have saved data on\n+/// disk, but in unit-testing the set of significant nodes can be\n+/// increased.\n pub type SerializedEdge = (DepNode<DefPathIndex>, DepNode<DefPathIndex>);\n \n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedHash {\n-    /// node being hashed; either a Hir or MetaData variant, in\n-    /// practice\n-    pub node: DepNode<DefPathIndex>,\n+    /// def-id of thing being hashed\n+    pub dep_node: DepNode<DefPathIndex>,\n \n-    /// the hash itself, computed by `calculate_item_hash`\n+    /// the hash as of previous compilation, computed by code in\n+    /// `hash` module\n     pub hash: u64,\n }\n "}, {"sha": "084b6714b67b95544ff0e98fd5b4b70bef1f74f3", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 93, "deletions": 7, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -16,9 +16,12 @@\n use rustc::dep_graph::DepNode;\n use rustc::hir::map::DefPath;\n use rustc::hir::def_id::DefId;\n+use rustc::middle::cstore::LOCAL_CRATE;\n use rustc::ty::TyCtxt;\n use rustc::util::nodemap::DefIdMap;\n use std::fmt::{self, Debug};\n+use std::iter::once;\n+use syntax::ast;\n \n /// Index into the DefIdDirectory\n #[derive(Copy, Clone, Debug, PartialOrd, Ord, Hash, PartialEq, Eq,\n@@ -31,17 +34,79 @@ pub struct DefPathIndex {\n pub struct DefIdDirectory {\n     // N.B. don't use Removable here because these def-ids are loaded\n     // directly without remapping, so loading them should not fail.\n-    paths: Vec<DefPath>\n+    paths: Vec<DefPath>,\n+\n+    // For each crate, saves the crate-name/disambiguator so that\n+    // later we can match crate-numbers up again.\n+    krates: Vec<CrateInfo>,\n+}\n+\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct CrateInfo {\n+    krate: ast::CrateNum,\n+    name: String,\n+    disambiguator: String,\n }\n \n impl DefIdDirectory {\n-    pub fn new() -> DefIdDirectory {\n-        DefIdDirectory { paths: vec![] }\n+    pub fn new(krates: Vec<CrateInfo>) -> DefIdDirectory {\n+        DefIdDirectory { paths: vec![], krates: krates }\n+    }\n+\n+    fn max_current_crate(&self, tcx: TyCtxt) -> ast::CrateNum {\n+        tcx.sess.cstore.crates()\n+                       .into_iter()\n+                       .max()\n+                       .unwrap_or(LOCAL_CRATE)\n+    }\n+\n+    /// Returns a string form for `index`; useful for debugging\n+    pub fn def_path_string(&self, tcx: TyCtxt, index: DefPathIndex) -> String {\n+        let path = &self.paths[index.index as usize];\n+        if self.krate_still_valid(tcx, self.max_current_crate(tcx), path.krate) {\n+            path.to_string(tcx)\n+        } else {\n+            format!(\"<crate {} changed>\", path.krate)\n+        }\n+    }\n+\n+    pub fn krate_still_valid(&self,\n+                             tcx: TyCtxt,\n+                             max_current_crate: ast::CrateNum,\n+                             krate: ast::CrateNum) -> bool {\n+        // Check that the crate-number still matches. For now, if it\n+        // doesn't, just return None. We could do better, such as\n+        // finding the new number.\n+\n+        if krate > max_current_crate {\n+            false\n+        } else {\n+            let old_info = &self.krates[krate as usize];\n+            assert_eq!(old_info.krate, krate);\n+            let old_name: &str = &old_info.name;\n+            let old_disambiguator: &str = &old_info.disambiguator;\n+            let new_name: &str = &tcx.crate_name(krate);\n+            let new_disambiguator: &str = &tcx.crate_disambiguator(krate);\n+            old_name == new_name && old_disambiguator == new_disambiguator\n+        }\n     }\n \n     pub fn retrace(&self, tcx: TyCtxt) -> RetracedDefIdDirectory {\n+        let max_current_crate = self.max_current_crate(tcx);\n+\n         let ids = self.paths.iter()\n-                            .map(|path| tcx.retrace_path(path))\n+                            .map(|path| {\n+                                if self.krate_still_valid(tcx, max_current_crate, path.krate) {\n+                                    tcx.retrace_path(path)\n+                                } else {\n+                                    debug!(\"crate {} changed from {:?} to {:?}/{:?}\",\n+                                           path.krate,\n+                                           self.krates[path.krate as usize],\n+                                           tcx.crate_name(path.krate),\n+                                           tcx.crate_disambiguator(path.krate));\n+                                    None\n+                                }\n+                            })\n                             .collect();\n         RetracedDefIdDirectory { ids: ids }\n     }\n@@ -70,10 +135,26 @@ pub struct DefIdDirectoryBuilder<'a,'tcx:'a> {\n \n impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> DefIdDirectoryBuilder<'a, 'tcx> {\n+        let mut krates: Vec<_> =\n+            once(LOCAL_CRATE)\n+            .chain(tcx.sess.cstore.crates())\n+            .map(|krate| {\n+                CrateInfo {\n+                    krate: krate,\n+                    name: tcx.crate_name(krate).to_string(),\n+                    disambiguator: tcx.crate_disambiguator(krate).to_string()\n+                }\n+            })\n+            .collect();\n+\n+        // the result of crates() is not in order, so sort list of\n+        // crates so that we can just index it later\n+        krates.sort_by_key(|k| k.krate);\n+\n         DefIdDirectoryBuilder {\n             tcx: tcx,\n             hash: DefIdMap(),\n-            directory: DefIdDirectory::new()\n+            directory: DefIdDirectory::new(krates),\n         }\n     }\n \n@@ -91,12 +172,17 @@ impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n                  .clone()\n     }\n \n+    pub fn lookup_def_path(&self, id: DefPathIndex) -> &DefPath {\n+        &self.directory.paths[id.index as usize]\n+    }\n+\n+\n     pub fn map(&mut self, node: &DepNode<DefId>) -> DepNode<DefPathIndex> {\n         node.map_def(|&def_id| Some(self.add(def_id))).unwrap()\n     }\n \n-    pub fn into_directory(self) -> DefIdDirectory {\n-        self.directory\n+    pub fn directory(&self) -> &DefIdDirectory {\n+        &self.directory\n     }\n }\n "}, {"sha": "344b05f095457ec4d5e2c6eccce7bf0b31afab94", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -39,20 +39,27 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn hash(&mut self, dep_node: &DepNode<DefId>) -> Option<u64> {\n+    pub fn is_hashable(dep_node: &DepNode<DefId>) -> bool {\n+        match *dep_node {\n+            DepNode::Hir(_) => true,\n+            DepNode::MetaData(def_id) => !def_id.is_local(),\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn hash(&mut self, dep_node: &DepNode<DefId>) -> Option<(DefId, u64)> {\n         match *dep_node {\n             // HIR nodes (which always come from our crate) are an input:\n             DepNode::Hir(def_id) => {\n-                assert!(def_id.is_local());\n-                Some(self.hir_hash(def_id))\n+                Some((def_id, self.hir_hash(def_id)))\n             }\n \n             // MetaData from other crates is an *input* to us.\n             // MetaData nodes from *our* crates are an *output*; we\n             // don't hash them, but we do compute a hash for them and\n             // save it for others to use.\n             DepNode::MetaData(def_id) if !def_id.is_local() => {\n-                Some(self.metadata_hash(def_id))\n+                Some((def_id, self.metadata_hash(def_id)))\n             }\n \n             _ => {\n@@ -66,7 +73,16 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n     }\n \n     fn hir_hash(&mut self, def_id: DefId) -> u64 {\n-        assert!(def_id.is_local());\n+        assert!(def_id.is_local(),\n+                \"cannot hash HIR for non-local def-id {:?} => {:?}\",\n+                def_id,\n+                self.tcx.item_path_str(def_id));\n+\n+        assert!(!self.tcx.map.is_inlined_def_id(def_id),\n+                \"cannot hash HIR for inlined def-id {:?} => {:?}\",\n+                def_id,\n+                self.tcx.item_path_str(def_id));\n+\n         // FIXME(#32753) -- should we use a distinct hash here\n         self.tcx.calculate_item_hash(def_id)\n     }"}, {"sha": "f012d27eb4be2af11d17ee52816f16f8368d97f0", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 85, "deletions": 116, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -28,7 +28,7 @@ use super::dirty_clean;\n use super::hash::*;\n use super::util::*;\n \n-type DirtyNodes = FnvHashSet<DepNode<DefId>>;\n+type DirtyNodes = FnvHashSet<DepNode<DefPathIndex>>;\n \n type CleanEdges = Vec<(DepNode<DefId>, DepNode<DefId>)>;\n \n@@ -93,7 +93,6 @@ fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n             None\n         }\n     }\n-\n }\n \n /// Decode the dep graph and load the edges/nodes that are still clean\n@@ -108,155 +107,125 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let directory = try!(DefIdDirectory::decode(&mut dep_graph_decoder));\n     let serialized_dep_graph = try!(SerializedDepGraph::decode(&mut dep_graph_decoder));\n \n-    debug!(\"decode_dep_graph: directory = {:#?}\", directory);\n-    debug!(\"decode_dep_graph: serialized_dep_graph = {:#?}\", serialized_dep_graph);\n-\n     // Retrace the paths in the directory to find their current location (if any).\n     let retraced = directory.retrace(tcx);\n \n-    debug!(\"decode_dep_graph: retraced = {:#?}\", retraced);\n-\n-    // Compute the set of Hir nodes whose data has changed.\n-    let mut dirty_nodes =\n-        initial_dirty_nodes(tcx, &serialized_dep_graph.hashes, &retraced);\n-\n-    debug!(\"decode_dep_graph: initial dirty_nodes = {:#?}\", dirty_nodes);\n+    // Compute the set of Hir nodes whose data has changed or which\n+    // have been removed.  These are \"raw\" source nodes, which means\n+    // that they still use the original `DefPathIndex` values from the\n+    // encoding, rather than having been retraced to a `DefId`. The\n+    // reason for this is that this way we can include nodes that have\n+    // been removed (which no longer have a `DefId` in the current\n+    // compilation).\n+    let dirty_raw_source_nodes = dirty_nodes(tcx, &serialized_dep_graph.hashes, &retraced);\n+\n+    // Create a list of (raw-source-node ->\n+    // retracted-target-node) edges. In the process of retracing the\n+    // target nodes, we may discover some of them def-paths no longer exist,\n+    // in which case there is no need to mark the corresopnding nodes as dirty\n+    // (they are just not present). So this list may be smaller than the original.\n+    //\n+    // Note though that in the common case the target nodes are\n+    // `DepNode::WorkProduct` instances, and those don't have a\n+    // def-id, so they will never be considered to not exist. Instead,\n+    // we do a secondary hashing step (later, in trans) when we know\n+    // the set of symbols that go into a work-product: if any symbols\n+    // have been removed (or added) the hash will be different and\n+    // we'll ignore the work-product then.\n+    let retraced_edges: Vec<_> =\n+        serialized_dep_graph.edges.iter()\n+                                  .filter_map(|&(ref raw_source_node, ref raw_target_node)| {\n+                                      retraced.map(raw_target_node)\n+                                              .map(|target_node| (raw_source_node, target_node))\n+                                  })\n+                                  .collect();\n+\n+    // Compute which work-products have an input that has changed or\n+    // been removed. Put the dirty ones into a set.\n+    let mut dirty_target_nodes = FnvHashSet();\n+    for &(raw_source_node, ref target_node) in &retraced_edges {\n+        if dirty_raw_source_nodes.contains(raw_source_node) {\n+            if !dirty_target_nodes.contains(target_node) {\n+                dirty_target_nodes.insert(target_node.clone());\n+\n+                if tcx.sess.opts.debugging_opts.incremental_info {\n+                    // It'd be nice to pretty-print these paths better than just\n+                    // using the `Debug` impls, but wev.\n+                    println!(\"module {:?} is dirty because {:?} changed or was removed\",\n+                             target_node,\n+                             raw_source_node.map_def(|&index| {\n+                                 Some(directory.def_path_string(tcx, index))\n+                             }).unwrap());\n+                }\n+            }\n+        }\n+    }\n \n-    // Find all DepNodes reachable from that core set. This loop\n-    // iterates repeatedly over the list of edges whose source is not\n-    // known to be dirty (`clean_edges`). If it finds an edge whose\n-    // source is dirty, it removes it from that list and adds the\n-    // target to `dirty_nodes`. It stops when it reaches a fixed\n-    // point.\n-    let clean_edges = compute_clean_edges(&serialized_dep_graph.edges,\n-                                          &retraced,\n-                                          &mut dirty_nodes);\n+    // For work-products that are still clean, add their deps into the\n+    // graph. This is needed because later we will have to save this\n+    // back out again!\n+    let dep_graph = tcx.dep_graph.clone();\n+    for (raw_source_node, target_node) in retraced_edges {\n+        if dirty_target_nodes.contains(&target_node) {\n+            continue;\n+        }\n \n-    // Add synthetic `foo->foo` edges for each clean node `foo` that\n-    // we had before. This is sort of a hack to create clean nodes in\n-    // the graph, since the existence of a node is a signal that the\n-    // work it represents need not be repeated.\n-    let clean_nodes =\n-        serialized_dep_graph.nodes\n-                            .iter()\n-                            .filter_map(|node| retraced.map(node))\n-                            .filter(|node| !dirty_nodes.contains(node))\n-                            .map(|node| (node.clone(), node));\n+        let source_node = retraced.map(raw_source_node).unwrap();\n \n-    // Add nodes and edges that are not dirty into our main graph.\n-    let dep_graph = tcx.dep_graph.clone();\n-    for (source, target) in clean_edges.into_iter().chain(clean_nodes) {\n-        debug!(\"decode_dep_graph: clean edge: {:?} -> {:?}\", source, target);\n+        debug!(\"decode_dep_graph: clean edge: {:?} -> {:?}\", source_node, target_node);\n \n-        let _task = dep_graph.in_task(target);\n-        dep_graph.read(source);\n+        let _task = dep_graph.in_task(target_node);\n+        dep_graph.read(source_node);\n     }\n \n     // Add in work-products that are still clean, and delete those that are\n     // dirty.\n     let mut work_product_decoder = Decoder::new(work_products_data, 0);\n     let work_products = try!(<Vec<SerializedWorkProduct>>::decode(&mut work_product_decoder));\n-    reconcile_work_products(tcx, work_products, &dirty_nodes);\n+    reconcile_work_products(tcx, work_products, &dirty_target_nodes);\n \n     Ok(())\n }\n \n-fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 hashes: &[SerializedHash],\n-                                 retraced: &RetracedDefIdDirectory)\n-                                 -> DirtyNodes {\n+/// Computes which of the original set of def-ids are dirty. Stored in\n+/// a bit vector where the index is the DefPathIndex.\n+fn dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         hashes: &[SerializedHash],\n+                         retraced: &RetracedDefIdDirectory)\n+                         -> DirtyNodes {\n     let mut hcx = HashContext::new(tcx);\n-    let mut items_removed = false;\n     let mut dirty_nodes = FnvHashSet();\n-    for hash in hashes {\n-        match hash.node.map_def(|&i| retraced.def_id(i)) {\n-            Some(dep_node) => {\n-                let current_hash = hcx.hash(&dep_node).unwrap();\n-                if current_hash != hash.hash {\n-                    debug!(\"initial_dirty_nodes: {:?} is dirty as hash is {:?}, was {:?}\",\n-                           dep_node, current_hash, hash.hash);\n-                    dirty_nodes.insert(dep_node);\n-                }\n-            }\n-            None => {\n-                items_removed = true;\n-            }\n-        }\n-    }\n-\n-    // If any of the items in the krate have changed, then we consider\n-    // the meta-node `Krate` to be dirty, since that means something\n-    // which (potentially) read the contents of every single item.\n-    if items_removed || !dirty_nodes.is_empty() {\n-        dirty_nodes.insert(DepNode::Krate);\n-    }\n \n-    dirty_nodes\n-}\n-\n-fn compute_clean_edges(serialized_edges: &[(SerializedEdge)],\n-                       retraced: &RetracedDefIdDirectory,\n-                       dirty_nodes: &mut DirtyNodes)\n-                       -> CleanEdges {\n-    // Build up an initial list of edges. Include an edge (source,\n-    // target) if neither node has been removed. If the source has\n-    // been removed, add target to the list of dirty nodes.\n-    let mut clean_edges = Vec::with_capacity(serialized_edges.len());\n-    for &(ref serialized_source, ref serialized_target) in serialized_edges {\n-        if let Some(target) = retraced.map(serialized_target) {\n-            if let Some(source) = retraced.map(serialized_source) {\n-                clean_edges.push((source, target))\n-            } else {\n-                // source removed, target must be dirty\n-                debug!(\"compute_clean_edges: {:?} dirty because {:?} no longer exists\",\n-                       target, serialized_source);\n-                dirty_nodes.insert(target);\n+    for hash in hashes {\n+        if let Some(dep_node) = retraced.map(&hash.dep_node) {\n+            let (_, current_hash) = hcx.hash(&dep_node).unwrap();\n+            if current_hash == hash.hash {\n+                continue;\n             }\n+            debug!(\"initial_dirty_nodes: {:?} is dirty as hash is {:?}, was {:?}\",\n+                   dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n+                   current_hash,\n+                   hash.hash);\n         } else {\n-            // target removed, ignore the edge\n+            debug!(\"initial_dirty_nodes: {:?} is dirty as it was removed\",\n+                   hash.dep_node);\n         }\n-    }\n \n-    debug!(\"compute_clean_edges: dirty_nodes={:#?}\", dirty_nodes);\n-\n-    // Propagate dirty marks by iterating repeatedly over\n-    // `clean_edges`. If we find an edge `(source, target)` where\n-    // `source` is dirty, add `target` to the list of dirty nodes and\n-    // remove it. Keep doing this until we find no more dirty nodes.\n-    let mut previous_size = 0;\n-    while dirty_nodes.len() > previous_size {\n-        debug!(\"compute_clean_edges: previous_size={}\", previous_size);\n-        previous_size = dirty_nodes.len();\n-        let mut i = 0;\n-        while i < clean_edges.len() {\n-            if dirty_nodes.contains(&clean_edges[i].0) {\n-                let (source, target) = clean_edges.swap_remove(i);\n-                debug!(\"compute_clean_edges: dirty source {:?} -> {:?}\",\n-                       source, target);\n-                dirty_nodes.insert(target);\n-            } else if dirty_nodes.contains(&clean_edges[i].1) {\n-                let (source, target) = clean_edges.swap_remove(i);\n-                debug!(\"compute_clean_edges: dirty target {:?} -> {:?}\",\n-                       source, target);\n-            } else {\n-                i += 1;\n-            }\n-        }\n+        dirty_nodes.insert(hash.dep_node.clone());\n     }\n \n-    clean_edges\n+    dirty_nodes\n }\n \n /// Go through the list of work-products produced in the previous run.\n /// Delete any whose nodes have been found to be dirty or which are\n /// otherwise no longer applicable.\n fn reconcile_work_products<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      work_products: Vec<SerializedWorkProduct>,\n-                                     dirty_nodes: &DirtyNodes) {\n+                                     dirty_target_nodes: &FnvHashSet<DepNode<DefId>>) {\n     debug!(\"reconcile_work_products({:?})\", work_products);\n     for swp in work_products {\n-        let dep_node = DepNode::WorkProduct(swp.id.clone());\n-        if dirty_nodes.contains(&dep_node) {\n+        if dirty_target_nodes.contains(&DepNode::WorkProduct(swp.id.clone())) {\n             debug!(\"reconcile_work_products: dep-node for {:?} is dirty\", swp);\n             delete_dirty_work_product(tcx, swp);\n         } else {"}, {"sha": "4a042497e044114c3d3421ff777cfa906826f548", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -17,6 +17,7 @@ mod directory;\n mod dirty_clean;\n mod hash;\n mod load;\n+mod preds;\n mod save;\n mod util;\n mod work_product;"}, {"sha": "a82951afcb1efc8c4858052152acd075b745cb22", "filename": "src/librustc_incremental/persist/preds.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::dep_graph::{DepGraphQuery, DepNode};\n+use rustc::hir::def_id::DefId;\n+use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_data_structures::graph::{DepthFirstTraversal, INCOMING, NodeIndex};\n+\n+use super::hash::*;\n+\n+/// A data-structure that makes it easy to enumerate the hashable\n+/// predecessors of any given dep-node.\n+pub struct Predecessors<'query> {\n+    // - Keys: dep-nodes that may have work-products, output meta-data\n+    //   nodes.\n+    // - Values: transitive predecessors of the key that are hashable\n+    //   (e.g., HIR nodes, input meta-data nodes)\n+    pub inputs: FnvHashMap<&'query DepNode<DefId>, Vec<&'query DepNode<DefId>>>,\n+\n+    // - Keys: some hashable node\n+    // - Values: the hash thereof\n+    pub hashes: FnvHashMap<&'query DepNode<DefId>, u64>,\n+}\n+\n+impl<'q> Predecessors<'q> {\n+    pub fn new(query: &'q DepGraphQuery<DefId>, hcx: &mut HashContext) -> Self {\n+        // Find nodes for which we want to know the full set of preds\n+        let mut dfs = DepthFirstTraversal::new(&query.graph, INCOMING);\n+        let all_nodes = query.graph.all_nodes();\n+        let tcx = hcx.tcx;\n+\n+        let inputs: FnvHashMap<_, _> = all_nodes.iter()\n+            .enumerate()\n+            .filter(|&(_, node)| match node.data {\n+                DepNode::WorkProduct(_) => true,\n+                DepNode::MetaData(ref def_id) => def_id.is_local(),\n+\n+                // if -Z query-dep-graph is passed, save more extended data\n+                // to enable better unit testing\n+                DepNode::TypeckItemBody(_) |\n+                DepNode::TransCrateItem(_) => tcx.sess.opts.debugging_opts.query_dep_graph,\n+\n+                _ => false,\n+            })\n+            .map(|(node_index, node)| {\n+                dfs.reset(NodeIndex(node_index));\n+                let inputs: Vec<_> = dfs.by_ref()\n+                    .map(|i| &all_nodes[i.node_id()].data)\n+                    .filter(|d| HashContext::is_hashable(d))\n+                    .collect();\n+                (&node.data, inputs)\n+            })\n+            .collect();\n+\n+        let mut hashes = FnvHashMap();\n+        for input in inputs.values().flat_map(|v| v.iter().cloned()) {\n+            hashes.entry(input)\n+                  .or_insert_with(|| hcx.hash(input).unwrap().1);\n+        }\n+\n+        Predecessors {\n+            inputs: inputs,\n+            hashes: hashes,\n+        }\n+    }\n+}"}, {"sha": "f296cd3172fb0262ea82d7a877a423d012c9260a", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 133, "deletions": 119, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -10,27 +10,40 @@\n \n use rbml::opaque::Encoder;\n use rustc::dep_graph::DepNode;\n+use rustc::hir::def_id::DefId;\n use rustc::middle::cstore::LOCAL_CRATE;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n-use rustc_serialize::{Encodable as RustcEncodable};\n-use std::hash::{Hasher, SipHasher};\n+use rustc_data_structures::fnv::FnvHashMap;\n+use rustc_serialize::Encodable as RustcEncodable;\n+use std::hash::{Hash, Hasher, SipHasher};\n use std::io::{self, Cursor, Write};\n use std::fs::{self, File};\n use std::path::PathBuf;\n \n use super::data::*;\n use super::directory::*;\n use super::hash::*;\n+use super::preds::*;\n use super::util::*;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     debug!(\"save_dep_graph()\");\n     let _ignore = tcx.dep_graph.in_ignore();\n     let sess = tcx.sess;\n+    if sess.opts.incremental.is_none() {\n+        return;\n+    }\n     let mut hcx = HashContext::new(tcx);\n-    save_in(sess, dep_graph_path(tcx), |e| encode_dep_graph(&mut hcx, e));\n-    save_in(sess, metadata_hash_path(tcx, LOCAL_CRATE), |e| encode_metadata_hashes(&mut hcx, e));\n+    let mut builder = DefIdDirectoryBuilder::new(tcx);\n+    let query = tcx.dep_graph.query();\n+    let preds = Predecessors::new(&query, &mut hcx);\n+    save_in(sess,\n+            dep_graph_path(tcx),\n+            |e| encode_dep_graph(&preds, &mut builder, e));\n+    save_in(sess,\n+            metadata_hash_path(tcx, LOCAL_CRATE),\n+            |e| encode_metadata_hashes(tcx, &preds, &mut builder, e));\n }\n \n pub fn save_work_products(sess: &Session, local_crate_name: &str) {\n@@ -40,26 +53,24 @@ pub fn save_work_products(sess: &Session, local_crate_name: &str) {\n     save_in(sess, path, |e| encode_work_products(sess, e));\n }\n \n-fn save_in<F>(sess: &Session,\n-              opt_path_buf: Option<PathBuf>,\n-              encode: F)\n+fn save_in<F>(sess: &Session, opt_path_buf: Option<PathBuf>, encode: F)\n     where F: FnOnce(&mut Encoder) -> io::Result<()>\n {\n     let path_buf = match opt_path_buf {\n         Some(p) => p,\n-        None => return\n+        None => return,\n     };\n \n     // FIXME(#32754) lock file?\n \n     // delete the old dep-graph, if any\n     if path_buf.exists() {\n         match fs::remove_file(&path_buf) {\n-            Ok(()) => { }\n+            Ok(()) => {}\n             Err(err) => {\n-                sess.err(\n-                    &format!(\"unable to delete old dep-graph at `{}`: {}\",\n-                             path_buf.display(), err));\n+                sess.err(&format!(\"unable to delete old dep-graph at `{}`: {}\",\n+                                  path_buf.display(),\n+                                  err));\n                 return;\n             }\n         }\n@@ -68,154 +79,157 @@ fn save_in<F>(sess: &Session,\n     // generate the data in a memory buffer\n     let mut wr = Cursor::new(Vec::new());\n     match encode(&mut Encoder::new(&mut wr)) {\n-        Ok(()) => { }\n+        Ok(()) => {}\n         Err(err) => {\n-            sess.err(\n-                &format!(\"could not encode dep-graph to `{}`: {}\",\n-                         path_buf.display(), err));\n+            sess.err(&format!(\"could not encode dep-graph to `{}`: {}\",\n+                              path_buf.display(),\n+                              err));\n             return;\n         }\n     }\n \n     // write the data out\n     let data = wr.into_inner();\n-    match\n-        File::create(&path_buf)\n-        .and_then(|mut file| file.write_all(&data))\n-    {\n-        Ok(_) => { }\n+    match File::create(&path_buf).and_then(|mut file| file.write_all(&data)) {\n+        Ok(_) => {}\n         Err(err) => {\n-            sess.err(\n-                &format!(\"failed to write dep-graph to `{}`: {}\",\n-                         path_buf.display(), err));\n+            sess.err(&format!(\"failed to write dep-graph to `{}`: {}\",\n+                              path_buf.display(),\n+                              err));\n             return;\n         }\n     }\n }\n \n-pub fn encode_dep_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n-                                  encoder: &mut Encoder)\n-                                  -> io::Result<()>\n-{\n-    let tcx = hcx.tcx;\n-    let query = tcx.dep_graph.query();\n-\n-    let mut builder = DefIdDirectoryBuilder::new(tcx);\n-\n-    // Create hashes for inputs.\n-    let hashes =\n-        query.nodes()\n-             .into_iter()\n-             .filter_map(|dep_node| {\n-                 hcx.hash(&dep_node)\n-                    .map(|hash| {\n-                        let node = builder.map(dep_node);\n-                        SerializedHash { node: node, hash: hash }\n-                    })\n-             })\n-             .collect();\n+pub fn encode_dep_graph(preds: &Predecessors,\n+                        builder: &mut DefIdDirectoryBuilder,\n+                        encoder: &mut Encoder)\n+                        -> io::Result<()> {\n+    // Create a flat list of (Input, WorkProduct) edges for\n+    // serialization.\n+    let mut edges = vec![];\n+    for (&target, sources) in &preds.inputs {\n+        match *target {\n+            DepNode::MetaData(ref def_id) => {\n+                // Metadata *targets* are always local metadata nodes. We handle\n+                // those in `encode_metadata_hashes`, which comes later.\n+                assert!(def_id.is_local());\n+                continue;\n+            }\n+            _ => (),\n+        }\n+        let target = builder.map(target);\n+        for &source in sources {\n+            let source = builder.map(source);\n+            edges.push((source, target.clone()));\n+        }\n+    }\n \n     // Create the serialized dep-graph.\n     let graph = SerializedDepGraph {\n-        nodes: query.nodes().into_iter()\n-                            .map(|node| builder.map(node))\n-                            .collect(),\n-        edges: query.edges().into_iter()\n-                            .map(|(source_node, target_node)| {\n-                                let source = builder.map(source_node);\n-                                let target = builder.map(target_node);\n-                                (source, target)\n-                            })\n-                            .collect(),\n-        hashes: hashes,\n+        edges: edges,\n+        hashes: preds.hashes\n+            .iter()\n+            .map(|(&dep_node, &hash)| {\n+                SerializedHash {\n+                    dep_node: builder.map(dep_node),\n+                    hash: hash,\n+                }\n+            })\n+            .collect(),\n     };\n \n     debug!(\"graph = {:#?}\", graph);\n \n     // Encode the directory and then the graph data.\n-    let directory = builder.into_directory();\n-    try!(directory.encode(encoder));\n+    try!(builder.directory().encode(encoder));\n     try!(graph.encode(encoder));\n \n     Ok(())\n }\n \n-pub fn encode_metadata_hashes<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n-                                        encoder: &mut Encoder)\n-                                        -> io::Result<()>\n-{\n-    let tcx = hcx.tcx;\n-    let query = tcx.dep_graph.query();\n+pub fn encode_metadata_hashes(tcx: TyCtxt,\n+                              preds: &Predecessors,\n+                              builder: &mut DefIdDirectoryBuilder,\n+                              encoder: &mut Encoder)\n+                              -> io::Result<()> {\n+    let mut def_id_hashes = FnvHashMap();\n+    let mut def_id_hash = |def_id: DefId| -> u64 {\n+        *def_id_hashes.entry(def_id)\n+            .or_insert_with(|| {\n+                let index = builder.add(def_id);\n+                let path = builder.lookup_def_path(index);\n+                path.deterministic_hash(tcx)\n+            })\n+    };\n \n-    let serialized_hashes = {\n-        // Identify the `MetaData(X)` nodes where `X` is local. These are\n-        // the metadata items we export. Downstream crates will want to\n-        // see a hash that tells them whether we might have changed the\n-        // metadata for a given item since they last compiled.\n-        let meta_data_def_ids =\n-            query.nodes()\n-                 .into_iter()\n-                 .filter_map(|dep_node| match *dep_node {\n-                     DepNode::MetaData(def_id) if def_id.is_local() => Some(def_id),\n-                     _ => None,\n-                 });\n+    // For each `MetaData(X)` node where `X` is local, accumulate a\n+    // hash.  These are the metadata items we export. Downstream\n+    // crates will want to see a hash that tells them whether we might\n+    // have changed the metadata for a given item since they last\n+    // compiled.\n+    //\n+    // (I initially wrote this with an iterator, but it seemed harder to read.)\n+    let mut serialized_hashes = SerializedMetadataHashes { hashes: vec![] };\n+    for (&target, sources) in &preds.inputs {\n+        let def_id = match *target {\n+            DepNode::MetaData(def_id) => {\n+                assert!(def_id.is_local());\n+                def_id\n+            }\n+            _ => continue,\n+        };\n \n         // To create the hash for each item `X`, we don't hash the raw\n         // bytes of the metadata (though in principle we\n         // could). Instead, we walk the predecessors of `MetaData(X)`\n         // from the dep-graph. This corresponds to all the inputs that\n         // were read to construct the metadata. To create the hash for\n         // the metadata, we hash (the hash of) all of those inputs.\n-        let hashes =\n-            meta_data_def_ids\n-            .map(|def_id| {\n-                assert!(def_id.is_local());\n-                let dep_node = DepNode::MetaData(def_id);\n-                let mut state = SipHasher::new();\n-                debug!(\"save: computing metadata hash for {:?}\", dep_node);\n-                for node in query.transitive_predecessors(&dep_node) {\n-                    if let Some(hash) = hcx.hash(&node) {\n-                        debug!(\"save: predecessor {:?} has hash {}\", node, hash);\n-                        state.write_u64(hash.to_le());\n-                    } else {\n-                        debug!(\"save: predecessor {:?} cannot be hashed\", node);\n-                    }\n-                }\n-                let hash = state.finish();\n-                debug!(\"save: metadata hash for {:?} is {}\", dep_node, hash);\n-                SerializedMetadataHash {\n-                    def_index: def_id.index,\n-                    hash: hash,\n-                }\n-            });\n-\n-        // Collect these up into a vector.\n-        SerializedMetadataHashes {\n-            hashes: hashes.collect()\n-        }\n-    };\n+        debug!(\"save: computing metadata hash for {:?}\", def_id);\n+\n+        // Create a vector containing a pair of (source-id, hash).\n+        // The source-id is stored as a `DepNode<u64>`, where the u64\n+        // is the det. hash of the def-path. This is convenient\n+        // because we can sort this to get a stable ordering across\n+        // compilations, even if the def-ids themselves have changed.\n+        let mut hashes: Vec<(DepNode<u64>, u64)> = sources.iter()\n+            .map(|dep_node| {\n+                let hash_dep_node = dep_node.map_def(|&def_id| Some(def_id_hash(def_id))).unwrap();\n+                let hash = preds.hashes[dep_node];\n+                (hash_dep_node, hash)\n+            })\n+            .collect();\n+\n+        hashes.sort();\n+        let mut state = SipHasher::new();\n+        hashes.hash(&mut state);\n+        let hash = state.finish();\n+\n+        debug!(\"save: metadata hash for {:?} is {}\", def_id, hash);\n+        serialized_hashes.hashes.push(SerializedMetadataHash {\n+            def_index: def_id.index,\n+            hash: hash,\n+        });\n+    }\n \n     // Encode everything.\n     try!(serialized_hashes.encode(encoder));\n \n     Ok(())\n }\n \n-pub fn encode_work_products(sess: &Session,\n-                            encoder: &mut Encoder)\n-                            -> io::Result<()>\n-{\n-    let work_products: Vec<_> =\n-        sess.dep_graph.work_products()\n-                     .iter()\n-                     .map(|(id, work_product)| {\n-                         SerializedWorkProduct {\n-                             id: id.clone(),\n-                             work_product: work_product.clone(),\n-                         }\n-                     })\n-                     .collect();\n+pub fn encode_work_products(sess: &Session, encoder: &mut Encoder) -> io::Result<()> {\n+    let work_products: Vec<_> = sess.dep_graph\n+        .work_products()\n+        .iter()\n+        .map(|(id, work_product)| {\n+            SerializedWorkProduct {\n+                id: id.clone(),\n+                work_product: work_product.clone(),\n+            }\n+        })\n+        .collect();\n \n     work_products.encode(encoder)\n }\n-"}, {"sha": "f03c432c0917791c4a9ca8531517090785b32787", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -78,8 +78,8 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            rbml_w: &mut Encoder,\n                            ii: InlinedItemRef) {\n     let id = match ii {\n-        InlinedItemRef::Item(i) => i.id,\n-        InlinedItemRef::Foreign(i) => i.id,\n+        InlinedItemRef::Item(_, i) => i.id,\n+        InlinedItemRef::Foreign(_, i) => i.id,\n         InlinedItemRef::TraitItem(_, ti) => ti.id,\n         InlinedItemRef::ImplItem(_, ii) => ii.id,\n     };\n@@ -146,8 +146,8 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n                                        decode_ast(ast_doc),\n                                        dcx);\n     let name = match *ii {\n-        InlinedItem::Item(ref i) => i.name,\n-        InlinedItem::Foreign(ref i) => i.name,\n+        InlinedItem::Item(_, ref i) => i.name,\n+        InlinedItem::Foreign(_, ref i) => i.name,\n         InlinedItem::TraitItem(_, ref ti) => ti.name,\n         InlinedItem::ImplItem(_, ref ii) => ii.name\n     };\n@@ -158,7 +158,7 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::CrateMetadata,\n     region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n     decode_side_tables(dcx, ast_doc);\n     copy_item_types(dcx, ii, orig_did);\n-    if let InlinedItem::Item(ref i) = *ii {\n+    if let InlinedItem::Item(_, ref i) = *ii {\n         debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n                ::rustc::hir::print::item_to_string(&i));\n     }\n@@ -348,17 +348,17 @@ fn simplify_ast(ii: InlinedItemRef) -> (InlinedItem, IdRange) {\n \n     let ii = match ii {\n         // HACK we're not dropping items.\n-        InlinedItemRef::Item(i) => {\n-            InlinedItem::Item(P(fold::noop_fold_item(i.clone(), &mut fld)))\n+        InlinedItemRef::Item(d, i) => {\n+            InlinedItem::Item(d, P(fold::noop_fold_item(i.clone(), &mut fld)))\n         }\n         InlinedItemRef::TraitItem(d, ti) => {\n             InlinedItem::TraitItem(d, P(fold::noop_fold_trait_item(ti.clone(), &mut fld)))\n         }\n         InlinedItemRef::ImplItem(d, ii) => {\n             InlinedItem::ImplItem(d, P(fold::noop_fold_impl_item(ii.clone(), &mut fld)))\n         }\n-        InlinedItemRef::Foreign(i) => {\n-            InlinedItem::Foreign(P(fold::noop_fold_foreign_item(i.clone(), &mut fld)))\n+        InlinedItemRef::Foreign(d, i) => {\n+            InlinedItem::Foreign(d, P(fold::noop_fold_foreign_item(i.clone(), &mut fld)))\n         }\n     };\n \n@@ -1241,15 +1241,15 @@ fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem, orig_did: DefId) {\n     }\n     // copy the entry for the item itself\n     let item_node_id = match ii {\n-        &InlinedItem::Item(ref i) => i.id,\n+        &InlinedItem::Item(_, ref i) => i.id,\n         &InlinedItem::TraitItem(_, ref ti) => ti.id,\n         &InlinedItem::ImplItem(_, ref ii) => ii.id,\n-        &InlinedItem::Foreign(ref fi) => fi.id\n+        &InlinedItem::Foreign(_, ref fi) => fi.id\n     };\n     copy_item_type(dcx, item_node_id, orig_did);\n \n     // copy the entries of inner items\n-    if let &InlinedItem::Item(ref item) = ii {\n+    if let &InlinedItem::Item(_, ref item) = ii {\n         match item.node {\n             hir::ItemEnum(ref def, _) => {\n                 let orig_def = dcx.tcx.lookup_adt_def(orig_did);\n@@ -1383,6 +1383,9 @@ fn test_more() {\n \n #[test]\n fn test_simplification() {\n+    use middle::cstore::LOCAL_CRATE;\n+    use rustc::hir::def_id::CRATE_DEF_INDEX;\n+\n     let cx = mk_ctxt();\n     let item = quote_item!(&cx,\n         fn new_int_alist<B>() -> alist<isize, B> {\n@@ -1393,15 +1396,16 @@ fn test_simplification() {\n     let cx = mk_ctxt();\n     with_testing_context(|lcx| {\n         let hir_item = lcx.lower_item(&item);\n-        let item_in = InlinedItemRef::Item(&hir_item);\n+        let def_id = DefId { krate: LOCAL_CRATE, index: CRATE_DEF_INDEX }; // dummy\n+        let item_in = InlinedItemRef::Item(def_id, &hir_item);\n         let (item_out, _) = simplify_ast(item_in);\n-        let item_exp = InlinedItem::Item(P(lcx.lower_item(&quote_item!(&cx,\n+        let item_exp = InlinedItem::Item(def_id, P(lcx.lower_item(&quote_item!(&cx,\n             fn new_int_alist<B>() -> alist<isize, B> {\n                 return alist {eq_fn: eq_int, data: Vec::new()};\n             }\n         ).unwrap())));\n         match (item_out, item_exp) {\n-            (InlinedItem::Item(item_out), InlinedItem::Item(item_exp)) => {\n+            (InlinedItem::Item(_, item_out), InlinedItem::Item(_, item_exp)) => {\n                  assert!(pprust::item_to_string(&item_out) ==\n                          pprust::item_to_string(&item_exp));\n             }"}, {"sha": "7ee6e54a666d6d524520ee745440e422a50a56c3", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -546,11 +546,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                     .borrow_mut()\n                     .insert(def_id, None);\n             }\n-            decoder::FoundAst::Found(&InlinedItem::Item(ref item)) => {\n+            decoder::FoundAst::Found(&InlinedItem::Item(d, ref item)) => {\n+                assert_eq!(d, def_id);\n                 let inlined_root_node_id = find_inlined_item_root(item.id);\n                 cache_inlined_item(def_id, item.id, inlined_root_node_id);\n             }\n-            decoder::FoundAst::Found(&InlinedItem::Foreign(ref item)) => {\n+            decoder::FoundAst::Found(&InlinedItem::Foreign(d, ref item)) => {\n+                assert_eq!(d, def_id);\n                 let inlined_root_node_id = find_inlined_item_root(item.id);\n                 cache_inlined_item(def_id, item.id, inlined_root_node_id);\n             }"}, {"sha": "64b614b56e12fdffe444b86545fb03c77226adaa", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -797,7 +797,7 @@ pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id:\n                                          grandparent_def_id,\n                                          ast_doc,\n                                          parent_did);\n-            if let &InlinedItem::Item(ref i) = ii {\n+            if let &InlinedItem::Item(_, ref i) = ii {\n                 return FoundAst::FoundParent(parent_did, i);\n             }\n         }\n@@ -1690,7 +1690,7 @@ fn item_def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n             let mut decoder = reader::Decoder::new(def_key_doc);\n             let simple_key = def_key::DefKey::decode(&mut decoder).unwrap();\n             let name = reader::maybe_get_doc(item_doc, tag_paths_data_name).map(|name| {\n-                token::intern(name.as_str_slice())\n+                token::intern(name.as_str_slice()).as_str()\n             });\n             def_key::recover_def_key(simple_key, name)\n         }"}, {"sha": "2444d669f7f32345c8c95ec007130f17123a091f", "filename": "src/librustc_metadata/def_key.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_metadata%2Fdef_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_metadata%2Fdef_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdef_key.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::hir::def_id::DefIndex;\n use rustc::hir::map as hir_map;\n-use syntax::ast::Name;\n+use syntax::parse::token::InternedString;\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct DefKey {\n@@ -75,7 +75,7 @@ fn simplify_def_path_data(data: hir_map::DefPathData) -> DefPathData {\n     }\n }\n \n-pub fn recover_def_key(key: DefKey, name: Option<Name>) -> hir_map::DefKey {\n+pub fn recover_def_key(key: DefKey, name: Option<InternedString>) -> hir_map::DefKey {\n     let data = hir_map::DisambiguatedDefPathData {\n         data: recover_def_path_data(key.disambiguated_data.data, name),\n         disambiguator: key.disambiguated_data.disambiguator,\n@@ -86,7 +86,7 @@ pub fn recover_def_key(key: DefKey, name: Option<Name>) -> hir_map::DefKey {\n     }\n }\n \n-fn recover_def_path_data(data: DefPathData, name: Option<Name>) -> hir_map::DefPathData {\n+fn recover_def_path_data(data: DefPathData, name: Option<InternedString>) -> hir_map::DefPathData {\n     match data {\n         DefPathData::CrateRoot => hir_map::DefPathData::CrateRoot,\n         DefPathData::Misc => hir_map::DefPathData::Misc,"}, {"sha": "4e754abe2aec04b19341c5f564caa482ecc4b115", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -743,7 +743,8 @@ fn encode_repr_attrs(rbml_w: &mut Encoder,\n }\n \n fn encode_mir(ecx: &EncodeContext, rbml_w: &mut Encoder, node_id: NodeId) {\n-    if let Some(mir) = ecx.mir_map.map.get(&node_id) {\n+    let def_id = ecx.tcx.map.local_def_id(node_id);\n+    if let Some(mir) = ecx.mir_map.map.get(&def_id) {\n         rbml_w.start_tag(tag_mir as usize);\n         rbml_w.emit_opaque(|opaque_encoder| {\n             tls::enter_encoding_context(ecx, opaque_encoder, |_, opaque_encoder| {\n@@ -861,7 +862,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n         encode_mir(ecx, rbml_w, item.id);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n@@ -879,7 +880,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &item.attrs);\n         let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n         if needs_inline || constness == hir::Constness::Const {\n-            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n             encode_mir(ecx, rbml_w, item.id);\n         }\n         encode_constness(rbml_w, constness);\n@@ -942,7 +943,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         for v in &enum_definition.variants {\n             encode_variant_id(rbml_w, ecx.tcx.map.local_def_id(v.node.data.id()));\n         }\n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n         encode_mir(ecx, rbml_w, item.id);\n \n         // Encode inherent implementations for this enumeration.\n@@ -989,7 +990,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         needs to know*/\n         encode_struct_fields(rbml_w, variant);\n \n-        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(def_id, item));\n         encode_mir(ecx, rbml_w, item.id);\n \n         // Encode inherent implementations for this structure.\n@@ -1311,7 +1312,7 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n         encode_name(rbml_w, nitem.name);\n         if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n+            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(def_id, nitem));\n             encode_mir(ecx, rbml_w, nitem.id);\n         }\n         encode_attributes(rbml_w, &nitem.attrs);\n@@ -1361,7 +1362,7 @@ fn my_visit_expr(expr: &hir::Expr,\n             ecx.tcx.closure_kind(def_id).encode(rbml_w).unwrap();\n             rbml_w.end_tag();\n \n-            assert!(ecx.mir_map.map.contains_key(&expr.id));\n+            assert!(ecx.mir_map.map.contains_key(&def_id));\n             encode_mir(ecx, rbml_w, expr.id);\n \n             rbml_w.end_tag();"}, {"sha": "d986d88dafc94c8b7c507457e3d74ce6d51fe953", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n use dot;\n+use rustc::hir::def_id::DefId;\n use rustc::mir::repr::*;\n+use rustc::mir::mir_map::MirMap;\n use rustc::ty::{self, TyCtxt};\n use std::fmt::Debug;\n use std::io::{self, Write};\n@@ -19,10 +21,16 @@ use rustc_data_structures::indexed_vec::Idx;\n \n /// Write a graphviz DOT graph of a list of MIRs.\n pub fn write_mir_graphviz<'a, 'b, 'tcx, W, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-                                              iter: I, w: &mut W)\n+                                              iter: I,\n+                                              mir_map: &MirMap<'tcx>,\n+                                              w: &mut W)\n                                               -> io::Result<()>\n-where W: Write, I: Iterator<Item=(&'a NodeId, &'a Mir<'a>)> {\n-    for (&nodeid, mir) in iter {\n+    where W: Write, I: Iterator<Item=DefId>\n+{\n+    for def_id in iter {\n+        let nodeid = tcx.map.as_local_node_id(def_id).unwrap();\n+        let mir = &mir_map.map[&def_id];\n+\n         writeln!(w, \"digraph Mir_{} {{\", nodeid)?;\n \n         // Global graph properties"}, {"sha": "df1fec75939b5097e8d62ec45e6d481007e92253", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -22,6 +22,7 @@ use rustc::mir::transform::MirSource;\n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval as const_eval;\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::FnKind;\n use rustc::hir::map::blocks::FnLikeNode;\n@@ -61,7 +62,17 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             MirSource::Promoted(..) => bug!()\n         };\n \n-        let attrs = infcx.tcx.map.attrs(src.item_id());\n+        let src_node_id = src.item_id();\n+\n+        // We are going to be accessing various tables\n+        // generated by TypeckItemBody; we also assume\n+        // that the body passes type check. These tables\n+        // are not individually tracked, so just register\n+        // a read here.\n+        let src_def_id = infcx.tcx.map.local_def_id(src_node_id);\n+        infcx.tcx.dep_graph.read(DepNode::TypeckItemBody(src_def_id));\n+\n+        let attrs = infcx.tcx.map.attrs(src_node_id);\n \n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on"}, {"sha": "42a643b8af6fa167933e2d7eddb14b77fb7fa029", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -18,6 +18,7 @@\n \n use build;\n use rustc::dep_graph::DepNode;\n+use rustc::hir::def_id::DefId;\n use rustc::mir::repr::Mir;\n use rustc::mir::transform::MirSource;\n use rustc::mir::visit::MutVisitor;\n@@ -29,7 +30,6 @@ use rustc::infer::InferCtxtBuilder;\n use rustc::traits::ProjectionMode;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n-use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n use rustc::hir::intravisit::{self, FnKind, Visitor};\n use syntax::ast;\n@@ -38,15 +38,13 @@ use syntax_pos::Span;\n use std::mem;\n \n pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MirMap<'tcx> {\n-    let mut map = MirMap {\n-        map: NodeMap(),\n-    };\n+    let mut map = MirMap::new(tcx.dep_graph.clone());\n     {\n         let mut dump = BuildMir {\n             tcx: tcx,\n             map: &mut map,\n         };\n-        tcx.visit_all_items_in_krate(DepNode::MirMapConstruction, &mut dump);\n+        tcx.visit_all_items_in_krate(DepNode::Mir, &mut dump);\n     }\n     map\n }\n@@ -94,16 +92,19 @@ struct BuildMir<'a, 'tcx: 'a> {\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(Cx<'b, 'gcx, 'tcx>).\n struct CxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     src: MirSource,\n+    def_id: DefId,\n     infcx: InferCtxtBuilder<'a, 'gcx, 'tcx>,\n     map: &'a mut MirMap<'gcx>,\n }\n \n impl<'a, 'gcx, 'tcx> BuildMir<'a, 'gcx> {\n     fn cx<'b>(&'b mut self, src: MirSource) -> CxBuilder<'b, 'gcx, 'tcx> {\n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, src.item_id());\n+        let def_id = self.tcx.map.local_def_id(src.item_id());\n         CxBuilder {\n             src: src,\n             infcx: self.tcx.infer_ctxt(None, Some(param_env), ProjectionMode::AnyFinal),\n+            def_id: def_id,\n             map: self.map\n         }\n     }\n@@ -133,7 +134,7 @@ impl<'a, 'gcx, 'tcx> CxBuilder<'a, 'gcx, 'tcx> {\n             mir\n         });\n \n-        assert!(self.map.map.insert(src.item_id(), mir).is_none())\n+        assert!(self.map.map.insert(self.def_id, mir).is_none())\n     }\n }\n "}, {"sha": "55e7408b0fd5d4ec881c2387fa94023abc2e938b", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -10,15 +10,16 @@\n \n use build::{Location, ScopeAuxiliaryVec, ScopeId};\n use rustc::hir;\n+use rustc::hir::def_id::DefId;\n use rustc::mir::repr::*;\n+use rustc::mir::mir_map::MirMap;\n use rustc::mir::transform::MirSource;\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::indexed_vec::{Idx};\n use std::fmt::Display;\n use std::fs;\n use std::io::{self, Write};\n-use syntax::ast::NodeId;\n use std::path::{PathBuf, Path};\n \n const INDENT: &'static str = \"    \";\n@@ -89,19 +90,23 @@ pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Write out a human-readable textual representation for the given MIR.\n pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                                          iter: I,\n+                                         mir_map: &MirMap<'tcx>,\n                                          w: &mut Write)\n                                          -> io::Result<()>\n-    where I: Iterator<Item=(&'a NodeId, &'a Mir<'tcx>)>, 'tcx: 'a\n+    where I: Iterator<Item=DefId>, 'tcx: 'a\n {\n     let mut first = true;\n-    for (&id, mir) in iter {\n+    for def_id in iter {\n+        let mir = &mir_map.map[&def_id];\n+\n         if first {\n             first = false;\n         } else {\n             // Put empty lines between all items\n             writeln!(w, \"\")?;\n         }\n \n+        let id = tcx.map.as_local_node_id(def_id).unwrap();\n         let src = MirSource::from_node(tcx, id);\n         write_mir_fn(tcx, src, mir, w, None)?;\n "}, {"sha": "b16ee9577463bc53958219e406fe1c0e45e0c219", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -16,6 +16,7 @@\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::FnKind;\n@@ -883,8 +884,8 @@ fn qualify_const_item_cached<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let extern_mir;\n     let param_env_and_mir = if def_id.is_local() {\n-        let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n-        mir_map.and_then(|map| map.map.get(&node_id)).map(|mir| {\n+        mir_map.and_then(|map| map.map.get(&def_id)).map(|mir| {\n+            let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n             (ty::ParameterEnvironment::for_item(tcx, node_id), mir)\n         })\n     } else if let Some(mir) = tcx.sess.cstore.maybe_get_item_mir(tcx, def_id) {\n@@ -919,9 +920,10 @@ impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n \n         // First, visit `const` items, potentially recursing, to get\n         // accurate MUTABLE_INTERIOR and NEEDS_DROP qualifications.\n-        for &id in map.map.keys() {\n-            let def_id = tcx.map.local_def_id(id);\n-            let _task = tcx.dep_graph.in_task(self.dep_node(def_id));\n+        let keys = map.map.keys();\n+        for &def_id in &keys {\n+            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n+            let id = tcx.map.as_local_node_id(def_id).unwrap();\n             let src = MirSource::from_node(tcx, id);\n             if let MirSource::Const(_) = src {\n                 qualify_const_item_cached(tcx, &mut qualif_map, Some(map), def_id);\n@@ -931,9 +933,9 @@ impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n         // Then, handle everything else, without recursing,\n         // as the MIR map is not shared, since promotion\n         // in functions (including `const fn`) mutates it.\n-        for (&id, mir) in &mut map.map {\n-            let def_id = tcx.map.local_def_id(id);\n-            let _task = tcx.dep_graph.in_task(self.dep_node(def_id));\n+        for &def_id in &keys {\n+            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n+            let id = tcx.map.as_local_node_id(def_id).unwrap();\n             let src = MirSource::from_node(tcx, id);\n             let mode = match src {\n                 MirSource::Fn(_) => {\n@@ -950,6 +952,7 @@ impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n             };\n             let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n \n+            let mir = map.map.get_mut(&def_id).unwrap();\n             for hook in &mut *hooks {\n                 hook.on_mir_pass(tcx, src, mir, self, false);\n             }"}, {"sha": "26a907920e8dbf528389165d8c70a88d4e9f17cf", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -11,8 +11,6 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n-use rustc::dep_graph::DepNode;\n-use rustc::hir::def_id::DefId;\n use rustc::infer::{self, InferCtxt, InferOk};\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::fold::TypeFoldable;\n@@ -714,7 +712,4 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n }\n \n impl Pass for TypeckMir {\n-    fn dep_node(&self, def_id: DefId) -> DepNode<DefId> {\n-        DepNode::MirTypeck(def_id)\n-    }\n }"}, {"sha": "5e2c0805c2ea3a6c4bda553e9d773ffbdd58ff91", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -108,36 +108,13 @@ use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::hir::map::definitions::{DefPath, DefPathData};\n \n-use std::fmt::Write;\n use syntax::attr;\n use syntax::parse::token::{self, InternedString};\n use serialize::hex::ToHex;\n \n pub fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> String {\n     let def_path = tcx.def_path(def_id);\n-    def_path_to_string(tcx, &def_path)\n-}\n-\n-fn def_path_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_path: &DefPath) -> String {\n-    let mut s = String::with_capacity(def_path.data.len() * 16);\n-\n-    if def_path.krate == cstore::LOCAL_CRATE {\n-        s.push_str(&tcx.crate_name(def_path.krate));\n-    } else {\n-        s.push_str(&tcx.sess.cstore.original_crate_name(def_path.krate));\n-    }\n-    s.push_str(\"/\");\n-    s.push_str(&tcx.crate_disambiguator(def_path.krate));\n-\n-    for component in &def_path.data {\n-        write!(s,\n-               \"::{}[{}]\",\n-               component.data.as_interned_str(),\n-               component.disambiguator)\n-            .unwrap();\n-    }\n-\n-    s\n+    def_path.to_string(tcx)\n }\n \n fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n@@ -167,7 +144,7 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     // the main symbol name is not necessarily unique; hash in the\n     // compiler's internal def-path, guaranteeing each symbol has a\n     // truly unique path\n-    hash_state.input_str(&def_path_to_string(tcx, def_path));\n+    hash_state.input_str(&def_path.to_string(tcx));\n \n     // Include the main item-type. Note that, in this case, the\n     // assertions about `needs_subst` may not hold, but this item-type"}, {"sha": "7025de523c378c4a68097bf17b08d64002fcdb12", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -725,6 +725,10 @@ pub fn run_passes(sess: &Session,\n         work_items.push(work);\n     }\n \n+    if sess.opts.debugging_opts.incremental_info {\n+        dump_incremental_data(&trans);\n+    }\n+\n     // Process the work items, optionally using worker threads.\n     // NOTE: This code is not really adapted to incremental compilation where\n     //       the compiler decides the number of codegen units (and will\n@@ -902,6 +906,17 @@ pub fn run_passes(sess: &Session,\n     }\n }\n \n+fn dump_incremental_data(trans: &CrateTranslation) {\n+    let mut reuse = 0;\n+    for mtrans in trans.modules.iter() {\n+        match mtrans.source {\n+            ModuleSource::Preexisting(..) => reuse += 1,\n+            ModuleSource::Translated(..) => (),\n+        }\n+    }\n+    println!(\"incremental: re-using {} out of {} modules\", reuse, trans.modules.len());\n+}\n+\n struct WorkItem {\n     mtrans: ModuleTranslation,\n     config: ModuleConfig,"}, {"sha": "b3729cc23f60fd3582253c9dbec04d102637ce67", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -1244,7 +1244,7 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }), ..}) => ty,\n         _ => ctor_ty\n     }.ty_adt_def().unwrap();\n-    let variant_def_id = if ccx.tcx().map.is_inlined(inlined_vid) {\n+    let variant_def_id = if ccx.tcx().map.is_inlined_node_id(inlined_vid) {\n         ccx.defid_for_inlined_node(inlined_vid).unwrap()\n     } else {\n         ccx.tcx().map.local_def_id(inlined_vid)"}, {"sha": "769dd008af8f495c3602737f04e7b99e2187f7ed", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -1026,7 +1026,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                              .get(TransItem::Static(id))\n                              .expect(\"Local statics should always be in the SymbolMap\");\n                 // Make sure that this is never executed for something inlined.\n-                assert!(!ccx.tcx().map.is_inlined(id));\n+                assert!(!ccx.tcx().map.is_inlined_node_id(id));\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()"}, {"sha": "97b03312d7963a5c27330ddc075213ee4d6fe312", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -81,7 +81,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     check_overflow: bool,\n     check_drop_flag_for_sanity: bool,\n     mir_map: &'a MirMap<'tcx>,\n-    mir_cache: RefCell<DefIdMap<Rc<mir::Mir<'tcx>>>>,\n+    mir_cache: RefCell<DepTrackingMap<MirCache<'tcx>>>,\n \n     use_dll_storage_attrs: bool,\n \n@@ -186,6 +186,19 @@ impl<'tcx> DepTrackingMapConfig for TraitSelectionCache<'tcx> {\n     }\n }\n \n+// Cache for mir loaded from metadata\n+struct MirCache<'tcx> {\n+    data: PhantomData<&'tcx ()>\n+}\n+\n+impl<'tcx> DepTrackingMapConfig for MirCache<'tcx> {\n+    type Key = DefId;\n+    type Value = Rc<mir::Mir<'tcx>>;\n+    fn to_dep_node(key: &DefId) -> DepNode<DefId> {\n+        DepNode::Mir(*key)\n+    }\n+}\n+\n /// This list owns a number of LocalCrateContexts and binds them to their common\n /// SharedCrateContext. This type just exists as a convenience, something to\n /// pass around all LocalCrateContexts with and get an iterator over them.\n@@ -474,7 +487,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n             symbol_hasher: RefCell::new(symbol_hasher),\n             tcx: tcx,\n             mir_map: mir_map,\n-            mir_cache: RefCell::new(DefIdMap()),\n+            mir_cache: RefCell::new(DepTrackingMap::new(tcx.dep_graph.clone())),\n             stats: Stats {\n                 n_glues_created: Cell::new(0),\n                 n_null_glues: Cell::new(0),\n@@ -538,8 +551,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n \n     pub fn get_mir(&self, def_id: DefId) -> Option<CachedMir<'b, 'tcx>> {\n         if def_id.is_local() {\n-            let node_id = self.tcx.map.as_local_node_id(def_id).unwrap();\n-            self.mir_map.map.get(&node_id).map(CachedMir::Ref)\n+            self.mir_map.map.get(&def_id).map(CachedMir::Ref)\n         } else {\n             if let Some(mir) = self.mir_cache.borrow().get(&def_id).cloned() {\n                 return Some(CachedMir::Owned(mir));"}, {"sha": "ee13af80b2ba0aeff7741bb4a5a687305b0bbb50", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -326,7 +326,7 @@ impl<'tcx> TypeMap<'tcx> {\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n             let def_id = if let Some(node_id) = cx.tcx().map.as_local_node_id(def_id) {\n-                if cx.tcx().map.is_inlined(node_id) {\n+                if cx.tcx().map.is_inlined_node_id(node_id) {\n                     // The given def_id identifies the inlined copy of a\n                     // type definition, let's take the source of the copy.\n                     cx.defid_for_inlined_node(node_id).unwrap()\n@@ -1846,7 +1846,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     // crate should already contain debuginfo for it. More importantly, the\n     // global might not even exist in un-inlined form anywhere which would lead\n     // to a linker errors.\n-    if cx.tcx().map.is_inlined(node_id) {\n+    if cx.tcx().map.is_inlined_node_id(node_id) {\n         return;\n     }\n "}, {"sha": "d0e00a6d593a5edf18742ebdae8156e467ac9ea0", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -83,8 +83,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         // that the incoming edges to a particular fn are from a\n         // particular set.\n \n-        self.register_reads(ccx);\n-\n         match *self {\n             TransItem::Static(node_id) => {\n                 let def_id = ccx.tcx().map.local_def_id(node_id);\n@@ -120,46 +118,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                ccx.codegen_unit().name());\n     }\n \n-    /// If necessary, creates a subtask for trans'ing a particular item and registers reads on\n-    /// `TypeckItemBody` and `Hir`.\n-    fn register_reads(&self, ccx: &CrateContext<'a, 'tcx>) {\n-        let tcx = ccx.tcx();\n-        let def_id = match *self {\n-            TransItem::Static(node_id) => {\n-                tcx.map.local_def_id(node_id)\n-            }\n-            TransItem::Fn(instance) => {\n-                if let Some(node) = tcx.map.as_local_node_id(instance.def) {\n-                    if let hir_map::Node::NodeItem(_) = tcx.map.get(node) {\n-                        // This already is a \"real\" item\n-                        instance.def\n-                    } else {\n-                        // Get the enclosing item and register a read on it\n-                        tcx.map.get_parent_did(node)\n-                    }\n-                } else {\n-                    // Translating an inlined item from another crate? Don't track anything.\n-                    return;\n-                }\n-            }\n-            TransItem::DropGlue(_) => {\n-                // Nothing to track for drop glue\n-                return;\n-            }\n-        };\n-\n-        tcx.dep_graph.with_task(DepNode::TransCrateItem(def_id), || {\n-            tcx.dep_graph.read(DepNode::Hir(def_id));\n-\n-            // We are going to be accessing various tables\n-            // generated by TypeckItemBody; we also assume\n-            // that the body passes type check. These tables\n-            // are not individually tracked, so just register\n-            // a read here.\n-            tcx.dep_graph.read(DepNode::TypeckItemBody(def_id));\n-        });\n-    }\n-\n     pub fn predefine(&self,\n                      ccx: &CrateContext<'a, 'tcx>,\n                      linkage: llvm::Linkage) {"}, {"sha": "f0ce4f6d2ec4225f9a022543cb8ca9ff6959cf6d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -1442,6 +1442,7 @@ fn type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         // NB. Since the `memoized` function enters a new task, and we\n         // are giving this task access to the item `item`, we must\n         // register a read.\n+        assert!(!ccx.tcx.map.is_inlined_def_id(item_def_id));\n         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n         compute_type_scheme_of_item(ccx, item)\n     })\n@@ -1569,6 +1570,7 @@ fn type_scheme_of_foreign_item<'a, 'tcx>(\n         // NB. Since the `memoized` function enters a new task, and we\n         // are giving this task access to the item `item`, we must\n         // register a read.\n+        assert!(!ccx.tcx.map.is_inlined_def_id(item_def_id));\n         ccx.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n         compute_type_scheme_of_foreign_item(ccx, item, abi)\n     })"}, {"sha": "e8b187b5454f6dbe88cafef8dac49cc7b8b03d98", "filename": "src/test/incremental/callee_caller_cross_crate/b.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcallee_caller_cross_crate%2Fb.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -10,6 +10,7 @@\n \n // aux-build:a.rs\n // revisions:rpass1 rpass2\n+// compile-flags:-Z query-dep-graph\n \n #![feature(rustc_attrs)]\n "}, {"sha": "64b7f2951d274595005c79abcd047ae80c409d89", "filename": "src/test/incremental/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fdirty_clean.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // revisions: rpass1 cfail2\n+// compile-flags: -Z query-dep-graph\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "dbdebefaf310baa0d2f3bb34d010f1af459d14bc", "filename": "src/test/incremental/foreign.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fforeign.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test what happens we save incremental compilation state that makes\n+// use of foreign items. This used to ICE (#34991).\n+\n+// revisions: rpass1\n+\n+#![feature(libc)]\n+\n+extern crate libc;\n+\n+use std::ffi::CString;\n+\n+mod mlibc {\n+    use libc::{c_char, c_long, c_longlong};\n+\n+    extern {\n+        pub fn atol(x: *const c_char) -> c_long;\n+        pub fn atoll(x: *const c_char) -> c_longlong;\n+    }\n+}\n+\n+fn atol(s: String) -> isize {\n+    let c = CString::new(s).unwrap();\n+    unsafe { mlibc::atol(c.as_ptr()) as isize }\n+}\n+\n+fn atoll(s: String) -> i64 {\n+    let c = CString::new(s).unwrap();\n+    unsafe { mlibc::atoll(c.as_ptr()) as i64 }\n+}\n+\n+pub fn main() {\n+    assert_eq!(atol(\"1024\".to_string()) * 10, atol(\"10240\".to_string()));\n+    assert_eq!((atoll(\"11111111111111111\".to_string()) * 10),\n+             atoll(\"111111111111111110\".to_string()));\n+}"}, {"sha": "a06c25ac055c77b6ce313f8d345c5be8156af290", "filename": "src/test/incremental/hello_world.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fhello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fhello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhello_world.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // revisions: rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "a150a8c4df77c8f588148846ba5d3bdd9c18d545", "filename": "src/test/incremental/inlined_hir_34991/main.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Finlined_hir_34991%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Finlined_hir_34991%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Finlined_hir_34991%2Fmain.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #34991: an ICE occurred here because we inline\n+// some of the vector routines and give them a local def-id `X`. This\n+// got hashed after trans (`Hir(X)`). When we load back up, we get an\n+// error because the `X` is remapped to the original def-id (in\n+// libstd), and we can't hash a HIR node from std.\n+\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+use std::vec::Vec;\n+\n+pub fn foo() -> Vec<i32> {\n+    vec![1, 2, 3]\n+}\n+\n+pub fn bar() {\n+    foo();\n+}\n+\n+pub fn main() {\n+    bar();\n+}"}, {"sha": "865156095a4d45d323733e9554643a661acc4077", "filename": "src/test/incremental/krate_reassign_34991/auxiliary/a.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fkrate_reassign_34991%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fkrate_reassign_34991%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fkrate_reassign_34991%2Fauxiliary%2Fa.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"rlib\"]\n+\n+pub type X = u32;\n+"}, {"sha": "1c807059ddbe6100d09c1e9a361d5289d5a2aab0", "filename": "src/test/incremental/krate_reassign_34991/main.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fkrate_reassign_34991%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fkrate_reassign_34991%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fkrate_reassign_34991%2Fmain.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:a.rs\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+#[cfg(rpass1)]\n+extern crate a;\n+\n+#[cfg(rpass1)]\n+pub fn use_X() -> u32 {\n+    let x: a::X = 22;\n+    x as u32\n+}\n+\n+#[cfg(rpass2)]\n+pub fn use_X() -> u32 {\n+    22\n+}\n+\n+pub fn main() { }"}, {"sha": "21b654bdf584bcda118c948979e413395621a0e7", "filename": "src/test/incremental/rlib_cross_crate/b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -16,7 +16,7 @@\n // aux-build:a.rs\n // revisions:rpass1 rpass2 rpass3\n // no-prefer-dynamic\n-\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n "}, {"sha": "257699cd3fce15b53a2d61ec02271eb1584858d8", "filename": "src/test/incremental/spike.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fspike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fspike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspike.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -35,14 +35,10 @@ mod x {\n         X { x: 11, y: 11 }\n     }\n \n-    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n-    #[rustc_clean(label=\"ItemSignature\", cfg=\"rpass2\")]\n     pub fn new() -> X {\n         make()\n     }\n \n-    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n-    #[rustc_clean(label=\"ItemSignature\", cfg=\"rpass2\")]\n     pub fn sum(x: &X) -> u32 {\n         x.x + x.y\n     }\n@@ -51,7 +47,6 @@ mod x {\n mod y {\n     use x;\n \n-    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n     pub fn assert_sum() -> bool {\n         let x = x::new();\n         x::sum(&x) == 22"}, {"sha": "f40621692561b4a901d455a927048f9a33dfe27e", "filename": "src/test/incremental/string_constant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fstring_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fstring_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstring_constant.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // revisions: rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]"}, {"sha": "da1b32cd73d6ebd2905d98625961c4fae4212b02", "filename": "src/test/incremental/struct_add_field.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fstruct_add_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fstruct_add_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_add_field.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -12,6 +12,7 @@\n // in between revisions (hashing should be stable).\n \n // revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n "}, {"sha": "ba469c62002e4da2f372eee3d77129507cc9fce4", "filename": "src/test/incremental/struct_change_field_name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -12,6 +12,7 @@\n // in between revisions (hashing should be stable).\n \n // revisions:rpass1 cfail2\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n "}, {"sha": "65f3b1b4f368f54cdf32ad748c437d4ab408999e", "filename": "src/test/incremental/struct_change_field_type.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fstruct_change_field_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fstruct_change_field_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -12,6 +12,7 @@\n // in between revisions (hashing should be stable).\n \n // revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n "}, {"sha": "95e15d0b7f9a070f1ea618e766f278dfd678548c", "filename": "src/test/incremental/struct_change_field_type_cross_crate/b.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -10,6 +10,7 @@\n \n // aux-build:a.rs\n // revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n "}, {"sha": "2bc636153f73522a823b38d144cd61eb7b4fe388", "filename": "src/test/incremental/struct_change_nothing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fstruct_change_nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fstruct_change_nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_nothing.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -12,6 +12,7 @@\n // in between revisions (hashing should be stable).\n \n // revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n "}, {"sha": "a7ed79d1a5a35036eef6e822ccd64ede592eb9b2", "filename": "src/test/incremental/struct_remove_field.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fstruct_remove_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Fstruct_remove_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_remove_field.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -12,6 +12,7 @@\n // in between revisions (hashing should be stable).\n \n // revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n "}, {"sha": "09d4db331980dcaadd6961e24fd57b77b24c61e5", "filename": "src/test/incremental/type_alias_cross_crate/b.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -10,6 +10,7 @@\n \n // aux-build:a.rs\n // revisions:rpass1 rpass2 rpass3\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n "}]}