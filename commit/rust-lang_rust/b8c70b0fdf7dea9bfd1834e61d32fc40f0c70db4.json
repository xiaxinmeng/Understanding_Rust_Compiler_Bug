{"sha": "b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4YzcwYjBmZGY3ZGVhOWJmZDE4MzRlNjFkMzJmYzQwZjBjNzBkYjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-15T22:47:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-15T22:47:54Z"}, "message": "Auto merge of #45918 - chrisvittal:impl-trait-pr, r=nikomatsakis\n\nImplement `impl Trait` in argument position (RFC1951, Universal quantification)\n\nImplements the remainder of #44721, part of #34511.\n\n**Note**: This PR currently allows argument position `impl Trait` in trait functions. The machinery is there to prevent this if we want to, but it currently does not.\n\nRename `hir::TyImplTrait` to `hir::TyImplTraitExistential` and add `hir::TyImplTraitUniversal(DefId, TyParamBounds)`. The `DefId` is needed to extract the index of the parameter in `ast_ty_to_ty`.\n\nIntroduce an `ImplTraitContext` enum to lowering to keep track of the kind and allowedness of `impl Trait` in that position. This new argument is passed through many places, all ending up in `lower_ty`.\n\nModify `generics_of` and `explicit_predicates_of` to collect the `impl Trait` args into anonymous synthetic generic parameters and to extend the predicates with the appropriate bounds.\n\nAdd a comparison of the 'syntheticness' of type parameters, that is, prevent the following.\n```rust\ntrait Foo {\n    fn foo(&self, &impl Debug);\n}\nimpl Foo for Bar {\n    fn foo<U: Debug>(&self, x: &U) { ... }\n}\n```\nAnd vice versa.\n\nIncedentally, supress `unused type parameter` errors if the type being compared is already a `TyError`.\n\n**TODO**: I have tried to annotate open questions with **FIXME**s. The most notable ones that haven't been resolved are the names of the `impl Trait` types and the questions surrounding the new `compare_synthetic_generics` method.\n1. For now, the names used for `impl Trait` parameters are `keywords::Invalid.name()`. I would like them to be `impl ...` if possible, but I haven't figured out a way to do that yet.\n2. For `compare_synthetic_generics` I have tried to outline the open questions in the [function itself](https://github.com/chrisvittal/rust/blob/3fc9e3705f7bd01f3cb0ea470cf2892f17a92350/src/librustc_typeck/check/compare_method.rs#L714-L725)\n\nr? @nikomatsakis", "tree": {"sha": "74888938d7fc3c771fceebf683acf2a7c7a1dcf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74888938d7fc3c771fceebf683acf2a7c7a1dcf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "html_url": "https://github.com/rust-lang/rust/commit/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa26421f56e385b1055e65b29a55b36bb2eae23e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa26421f56e385b1055e65b29a55b36bb2eae23e", "html_url": "https://github.com/rust-lang/rust/commit/fa26421f56e385b1055e65b29a55b36bb2eae23e"}, {"sha": "4ce61b73620ade330bbafc3c6d56a0447bac2ca3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ce61b73620ade330bbafc3c6d56a0447bac2ca3", "html_url": "https://github.com/rust-lang/rust/commit/4ce61b73620ade330bbafc3c6d56a0447bac2ca3"}], "stats": {"total": 1471, "additions": 1146, "deletions": 325}, "files": [{"sha": "6b3c5e92720df6e9ef6ee001f4676c96dadadf98", "filename": "src/doc/unstable-book/src/language-features/universal-impl-trait.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,32 @@\n+# `universal_impl_trait`\n+\n+The tracking issue for this feature is: [#34511].\n+\n+[#34511]: https://github.com/rust-lang/rust/issues/34511\n+\n+--------------------\n+\n+The `universal_impl_trait` feature extends the [`conservative_impl_trait`]\n+feature allowing the `impl Trait` syntax in arguments (universal\n+quantification).\n+\n+[`conservative_impl_trait`]: ./language-features/conservative-impl-trait.html\n+\n+## Examples\n+\n+```rust\n+#![feature(universal_impl_trait)]\n+use std::ops::Not;\n+\n+fn any_zero(values: impl IntoIterator<Item = i32>) -> bool {\n+    for val in values { if val == 0 { return true; } }\n+    false\n+}\n+\n+fn main() {\n+    let test1 = -5..;\n+    let test2 = vec![1, 8, 42, -87, 60];\n+    assert!(any_zero(test1));\n+    assert!(bool::not(any_zero(test2)));\n+}\n+```"}, {"sha": "bab3bded77b093b9f014c0cc2bed09e50b8b2517", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -1770,6 +1770,46 @@ If you want to get command-line arguments, use `std::env::args`. To exit with a\n specified exit code, use `std::process::exit`.\n \"##,\n \n+E0562: r##\"\n+Abstract return types (written `impl Trait` for some trait `Trait`) are only\n+allowed as function return types.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0562\n+#![feature(conservative_impl_trait)]\n+\n+fn main() {\n+    let count_to_ten: impl Iterator<Item=usize> = 0..10;\n+    // error: `impl Trait` not allowed outside of function and inherent method\n+    //        return types\n+    for i in count_to_ten {\n+        println!(\"{}\", i);\n+    }\n+}\n+```\n+\n+Make sure `impl Trait` only appears in return-type position.\n+\n+```\n+#![feature(conservative_impl_trait)]\n+\n+fn count_to_n(n: usize) -> impl Iterator<Item=usize> {\n+    0..n\n+}\n+\n+fn main() {\n+    for i in count_to_n(10) {  // ok!\n+        println!(\"{}\", i);\n+    }\n+}\n+```\n+\n+See [RFC 1522] for more details.\n+\n+[RFC 1522]: https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md\n+\"##,\n+\n E0591: r##\"\n Per [RFC 401][rfc401], if you have a function declaration `foo`:\n "}, {"sha": "84be68cb197652a147d7c4568c0b1e46d7b99ca7", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -591,7 +591,10 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             }\n             visitor.visit_lifetime(lifetime);\n         }\n-        TyImplTrait(ref bounds) => {\n+        TyImplTraitExistential(ref bounds) => {\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+        }\n+        TyImplTraitUniversal(_, ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n         TyTypeof(expression) => {"}, {"sha": "8c9d1a38e7088a72dc28b9a877d52351653215e6", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 219, "deletions": 86, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -103,6 +103,7 @@ pub struct LoweringContext<'a> {\n     catch_scopes: Vec<NodeId>,\n     loop_scopes: Vec<NodeId>,\n     is_in_loop_condition: bool,\n+    is_in_trait_impl: bool,\n \n     type_def_lifetime_params: DefIdMap<usize>,\n \n@@ -123,6 +124,24 @@ pub trait Resolver {\n     fn definitions(&mut self) -> &mut Definitions;\n }\n \n+#[derive(Clone, Copy, Debug)]\n+enum ImplTraitContext {\n+    /// Treat `impl Trait` as shorthand for a new universal generic parameter.\n+    /// Example: `fn foo(x: impl Debug)`, where `impl Debug` is conceptually\n+    /// equivalent to a fresh universal parameter like `fn foo<T: Debug>(x: T)`.\n+    ///\n+    /// We store a DefId here so we can look up necessary information later\n+    Universal(DefId),\n+\n+    /// Treat `impl Trait` as shorthand for a new universal existential parameter.\n+    /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n+    /// equivalent to a fresh existential parameter like `abstract type T; fn foo() -> T`.\n+    Existential,\n+\n+    /// `impl Trait` is not accepted in this position.\n+    Disallowed,\n+}\n+\n pub fn lower_crate(sess: &Session,\n                    cstore: &CrateStore,\n                    dep_graph: &DepGraph,\n@@ -156,6 +175,7 @@ pub fn lower_crate(sess: &Session,\n         item_local_id_counters: NodeMap(),\n         node_id_to_hir_id: IndexVec::new(),\n         is_generator: false,\n+        is_in_trait_impl: false,\n     }.lower_crate(krate)\n }\n \n@@ -223,6 +243,21 @@ impl<'a> LoweringContext<'a> {\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n \n+        impl<'lcx, 'interner> ItemLowerer<'lcx, 'interner> {\n+            fn with_trait_impl_ref<F>(&mut self, trait_impl_ref: &Option<TraitRef>, f: F)\n+                where F: FnOnce(&mut Self)\n+            {\n+                let old = self.lctx.is_in_trait_impl;\n+                self.lctx.is_in_trait_impl = if let &None = trait_impl_ref {\n+                    false\n+                } else {\n+                    true\n+                };\n+                f(self);\n+                self.lctx.is_in_trait_impl = old;\n+            }\n+        }\n+\n         impl<'lcx, 'interner> Visitor<'lcx> for ItemLowerer<'lcx, 'interner> {\n             fn visit_item(&mut self, item: &'lcx Item) {\n                 let mut item_lowered = true;\n@@ -235,7 +270,13 @@ impl<'a> LoweringContext<'a> {\n                 });\n \n                 if item_lowered {\n-                    visit::walk_item(self, item);\n+                    if let ItemKind::Impl(_,_,_,_,ref opt_trait_ref,_,_) = item.node {\n+                        self.with_trait_impl_ref(opt_trait_ref, |this| {\n+                            visit::walk_item(this, item)\n+                        });\n+                    } else {\n+                        visit::walk_item(self, item);\n+                    }\n                 }\n             }\n \n@@ -644,48 +685,48 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_ty_binding(&mut self, b: &TypeBinding) -> hir::TypeBinding {\n+    fn lower_ty_binding(&mut self, b: &TypeBinding, itctx: ImplTraitContext) -> hir::TypeBinding {\n         hir::TypeBinding {\n             id: self.lower_node_id(b.id).node_id,\n             name: self.lower_ident(b.ident),\n-            ty: self.lower_ty(&b.ty),\n+            ty: self.lower_ty(&b.ty, itctx),\n             span: b.span,\n         }\n     }\n \n-    fn lower_ty(&mut self, t: &Ty) -> P<hir::Ty> {\n+    fn lower_ty(&mut self, t: &Ty, itctx: ImplTraitContext) -> P<hir::Ty> {\n         let kind = match t.node {\n             TyKind::Infer => hir::TyInfer,\n             TyKind::Err => hir::TyErr,\n-            TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty)),\n-            TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt)),\n+            TyKind::Slice(ref ty) => hir::TySlice(self.lower_ty(ty, itctx)),\n+            TyKind::Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt, itctx)),\n             TyKind::Rptr(ref region, ref mt) => {\n                 let span = t.span.with_hi(t.span.lo());\n                 let lifetime = match *region {\n                     Some(ref lt) => self.lower_lifetime(lt),\n                     None => self.elided_lifetime(span)\n                 };\n-                hir::TyRptr(lifetime, self.lower_mt(mt))\n+                hir::TyRptr(lifetime, self.lower_mt(mt, itctx))\n             }\n             TyKind::BareFn(ref f) => {\n                 hir::TyBareFn(P(hir::BareFnTy {\n                     lifetimes: self.lower_lifetime_defs(&f.lifetimes),\n                     unsafety: self.lower_unsafety(f.unsafety),\n                     abi: f.abi,\n-                    decl: self.lower_fn_decl(&f.decl),\n+                    decl: self.lower_fn_decl(&f.decl, None, false),\n                     arg_names: self.lower_fn_args_to_names(&f.decl),\n                 }))\n             }\n             TyKind::Never => hir::TyNever,\n             TyKind::Tup(ref tys) => {\n-                hir::TyTup(tys.iter().map(|ty| self.lower_ty(ty)).collect())\n+                hir::TyTup(tys.iter().map(|ty| self.lower_ty(ty, itctx)).collect())\n             }\n             TyKind::Paren(ref ty) => {\n-                return self.lower_ty(ty);\n+                return self.lower_ty(ty, itctx);\n             }\n             TyKind::Path(ref qself, ref path) => {\n                 let id = self.lower_node_id(t.id);\n-                let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit);\n+                let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit, itctx);\n                 return self.ty_path(id, t.span, qpath);\n             }\n             TyKind::ImplicitSelf => {\n@@ -699,7 +740,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             TyKind::Array(ref ty, ref length) => {\n                 let length = self.lower_body(None, |this| this.lower_expr(length));\n-                hir::TyArray(self.lower_ty(ty), length)\n+                hir::TyArray(self.lower_ty(ty, itctx), length)\n             }\n             TyKind::Typeof(ref expr) => {\n                 let expr = self.lower_body(None, |this| this.lower_expr(expr));\n@@ -710,7 +751,7 @@ impl<'a> LoweringContext<'a> {\n                 let bounds = bounds.iter().filter_map(|bound| {\n                     match *bound {\n                         TraitTyParamBound(ref ty, TraitBoundModifier::None) => {\n-                            Some(self.lower_poly_trait_ref(ty))\n+                            Some(self.lower_poly_trait_ref(ty, itctx))\n                         }\n                         TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n                         RegionTyParamBound(ref lifetime) => {\n@@ -727,7 +768,33 @@ impl<'a> LoweringContext<'a> {\n                 hir::TyTraitObject(bounds, lifetime_bound)\n             }\n             TyKind::ImplTrait(ref bounds) => {\n-                hir::TyImplTrait(self.lower_bounds(bounds))\n+                use syntax::feature_gate::{emit_feature_err, GateIssue};\n+                match itctx {\n+                    ImplTraitContext::Existential => {\n+                        let has_feature = self.sess.features.borrow().conservative_impl_trait;\n+                        if !t.span.allows_unstable() && !has_feature {\n+                            emit_feature_err(&self.sess.parse_sess, \"conservative_impl_trait\",\n+                                             t.span, GateIssue::Language,\n+                                             \"`impl Trait` in return position is experimental\");\n+                        }\n+                        hir::TyImplTraitExistential(self.lower_bounds(bounds, itctx))\n+                    },\n+                    ImplTraitContext::Universal(def_id) => {\n+                        let has_feature = self.sess.features.borrow().universal_impl_trait;\n+                        if !t.span.allows_unstable() && !has_feature {\n+                            emit_feature_err(&self.sess.parse_sess, \"universal_impl_trait\",\n+                                             t.span, GateIssue::Language,\n+                                             \"`impl Trait` in argument position is experimental\");\n+                        }\n+                        hir::TyImplTraitUniversal(def_id, self.lower_bounds(bounds, itctx))\n+                    },\n+                    ImplTraitContext::Disallowed => {\n+                        span_err!(self.sess, t.span, E0562,\n+                                  \"`impl Trait` not allowed outside of function \\\n+                                  and inherent method return types\");\n+                        hir::TyErr\n+                    }\n+                }\n             }\n             TyKind::Mac(_) => panic!(\"TyMac should have been expanded by now.\"),\n         };\n@@ -773,10 +840,11 @@ impl<'a> LoweringContext<'a> {\n                    id: NodeId,\n                    qself: &Option<QSelf>,\n                    p: &Path,\n-                   param_mode: ParamMode)\n+                   param_mode: ParamMode,\n+                   itctx: ImplTraitContext)\n                    -> hir::QPath {\n         let qself_position = qself.as_ref().map(|q| q.position);\n-        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty));\n+        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty, itctx));\n \n         let resolution = self.resolver.get_resolution(id)\n                                       .unwrap_or(PathResolution::new(Def::Err));\n@@ -846,7 +914,7 @@ impl<'a> LoweringContext<'a> {\n                     n\n                 });\n                 self.lower_path_segment(p.span, segment, param_mode, num_lifetimes,\n-                                        parenthesized_generic_args)\n+                                        parenthesized_generic_args, itctx)\n             }).collect(),\n             span: p.span,\n         });\n@@ -882,7 +950,8 @@ impl<'a> LoweringContext<'a> {\n         // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n         for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n             let segment = P(self.lower_path_segment(p.span, segment, param_mode, 0,\n-                                                    ParenthesizedGenericArgs::Warn));\n+                                                    ParenthesizedGenericArgs::Warn,\n+                                                    itctx));\n             let qpath = hir::QPath::TypeRelative(ty, segment);\n \n             // It's finished, return the extension of the right node type.\n@@ -916,7 +985,8 @@ impl<'a> LoweringContext<'a> {\n             def: self.expect_full_def(id),\n             segments: segments.map(|segment| {\n                 self.lower_path_segment(p.span, segment, param_mode, 0,\n-                                        ParenthesizedGenericArgs::Err)\n+                                        ParenthesizedGenericArgs::Err,\n+                                        ImplTraitContext::Disallowed)\n             }).chain(name.map(|name| hir::PathSegment::from_name(name)))\n               .collect(),\n             span: p.span,\n@@ -937,16 +1007,18 @@ impl<'a> LoweringContext<'a> {\n                           segment: &PathSegment,\n                           param_mode: ParamMode,\n                           expected_lifetimes: usize,\n-                          parenthesized_generic_args: ParenthesizedGenericArgs)\n+                          parenthesized_generic_args: ParenthesizedGenericArgs,\n+                          itctx: ImplTraitContext)\n                           -> hir::PathSegment {\n         let (mut parameters, infer_types) = if let Some(ref parameters) = segment.parameters {\n             let msg = \"parenthesized parameters may only be used with a trait\";\n             match **parameters {\n                 PathParameters::AngleBracketed(ref data) => {\n-                    self.lower_angle_bracketed_parameter_data(data, param_mode)\n+                    self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n                 PathParameters::Parenthesized(ref data) => match parenthesized_generic_args {\n-                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n+                    ParenthesizedGenericArgs::Ok =>\n+                        self.lower_parenthesized_parameter_data(data),\n                     ParenthesizedGenericArgs::Warn => {\n                         self.sess.buffer_lint(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n                                               CRATE_NODE_ID, data.span, msg.into());\n@@ -960,7 +1032,7 @@ impl<'a> LoweringContext<'a> {\n                 }\n             }\n         } else {\n-            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode)\n+            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode, itctx)\n         };\n \n         if !parameters.parenthesized && parameters.lifetimes.is_empty() {\n@@ -978,22 +1050,24 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_angle_bracketed_parameter_data(&mut self,\n                                             data: &AngleBracketedParameterData,\n-                                            param_mode: ParamMode)\n+                                            param_mode: ParamMode,\n+                                            itctx: ImplTraitContext)\n                                             -> (hir::PathParameters, bool) {\n         let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings, .. } = data;\n         (hir::PathParameters {\n             lifetimes: self.lower_lifetimes(lifetimes),\n-            types: types.iter().map(|ty| self.lower_ty(ty)).collect(),\n-            bindings: bindings.iter().map(|b| self.lower_ty_binding(b)).collect(),\n+            types: types.iter().map(|ty| self.lower_ty(ty, itctx)).collect(),\n+            bindings: bindings.iter().map(|b| self.lower_ty_binding(b, itctx)).collect(),\n             parenthesized: false,\n         }, types.is_empty() && param_mode == ParamMode::Optional)\n     }\n \n     fn lower_parenthesized_parameter_data(&mut self,\n                                           data: &ParenthesizedParameterData)\n                                           -> (hir::PathParameters, bool) {\n+        const DISALLOWED: ImplTraitContext = ImplTraitContext::Disallowed;\n         let &ParenthesizedParameterData { ref inputs, ref output, span } = data;\n-        let inputs = inputs.iter().map(|ty| self.lower_ty(ty)).collect();\n+        let inputs = inputs.iter().map(|ty| self.lower_ty(ty, DISALLOWED)).collect();\n         let mk_tup = |this: &mut Self, tys, span| {\n             let LoweredNodeId { node_id, hir_id } = this.next_id();\n             P(hir::Ty { node: hir::TyTup(tys), id: node_id, hir_id, span })\n@@ -1005,7 +1079,7 @@ impl<'a> LoweringContext<'a> {\n             bindings: hir_vec![hir::TypeBinding {\n                 id: self.next_id().node_id,\n                 name: Symbol::intern(FN_OUTPUT_NAME),\n-                ty: output.as_ref().map(|ty| self.lower_ty(&ty))\n+                ty: output.as_ref().map(|ty| self.lower_ty(&ty, DISALLOWED))\n                                    .unwrap_or_else(|| mk_tup(self, hir::HirVec::new(), span)),\n                 span: output.as_ref().map_or(span, |ty| ty.span),\n             }],\n@@ -1018,7 +1092,7 @@ impl<'a> LoweringContext<'a> {\n         P(hir::Local {\n             id: node_id,\n             hir_id,\n-            ty: l.ty.as_ref().map(|t| self.lower_ty(t)),\n+            ty: l.ty.as_ref().map(|t| self.lower_ty(t, ImplTraitContext::Disallowed)),\n             pat: self.lower_pat(&l.pat),\n             init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n             span: l.span,\n@@ -1055,11 +1129,32 @@ impl<'a> LoweringContext<'a> {\n         }).collect()\n     }\n \n-    fn lower_fn_decl(&mut self, decl: &FnDecl) -> P<hir::FnDecl> {\n+\n+    fn lower_fn_decl(&mut self,\n+                     decl: &FnDecl,\n+                     fn_def_id: Option<DefId>,\n+                     impl_trait_return_allow: bool)\n+                     -> P<hir::FnDecl> {\n+        // NOTE: The two last paramters here have to do with impl Trait. If fn_def_id is Some,\n+        //       then impl Trait arguments are lowered into generic paramters on the given\n+        //       fn_def_id, otherwise impl Trait is disallowed. (for now)\n+        //\n+        //       Furthermore, if impl_trait_return_allow is true, then impl Trait may be used in\n+        //       return positions as well. This guards against trait declarations and their impls\n+        //       where impl Trait is disallowed. (again for now)\n         P(hir::FnDecl {\n-            inputs: decl.inputs.iter().map(|arg| self.lower_ty(&arg.ty)).collect(),\n+            inputs: decl.inputs.iter()\n+                .map(|arg| if let Some(def_id) = fn_def_id {\n+                    self.lower_ty(&arg.ty, ImplTraitContext::Universal(def_id))\n+                } else {\n+                    self.lower_ty(&arg.ty, ImplTraitContext::Disallowed)\n+                }).collect(),\n             output: match decl.output {\n-                FunctionRetTy::Ty(ref ty) => hir::Return(self.lower_ty(ty)),\n+                FunctionRetTy::Ty(ref ty) => match fn_def_id {\n+                    Some(_) if impl_trait_return_allow =>\n+                        hir::Return(self.lower_ty(ty, ImplTraitContext::Existential)),\n+                    _ => hir::Return(self.lower_ty(ty, ImplTraitContext::Disallowed)),\n+                },\n                 FunctionRetTy::Default(span) => hir::DefaultReturn(span),\n             },\n             variadic: decl.variadic,\n@@ -1073,10 +1168,11 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_ty_param_bound(&mut self, tpb: &TyParamBound) -> hir::TyParamBound {\n+    fn lower_ty_param_bound(&mut self, tpb: &TyParamBound, itctx: ImplTraitContext)\n+                            -> hir::TyParamBound {\n         match *tpb {\n             TraitTyParamBound(ref ty, modifier) => {\n-                hir::TraitTyParamBound(self.lower_poly_trait_ref(ty),\n+                hir::TraitTyParamBound(self.lower_poly_trait_ref(ty, itctx),\n                                        self.lower_trait_bound_modifier(modifier))\n             }\n             RegionTyParamBound(ref lifetime) => {\n@@ -1095,16 +1191,19 @@ impl<'a> LoweringContext<'a> {\n             name = Symbol::gensym(\"Self\");\n         }\n \n-        let mut bounds = self.lower_bounds(&tp.bounds);\n+        let itctx = ImplTraitContext::Universal(self.resolver.definitions().local_def_id(tp.id));\n+        let mut bounds = self.lower_bounds(&tp.bounds, itctx);\n         if !add_bounds.is_empty() {\n-            bounds = bounds.into_iter().chain(self.lower_bounds(add_bounds).into_iter()).collect();\n+            bounds = bounds.into_iter().chain(\n+                self.lower_bounds(add_bounds, itctx).into_iter()\n+            ).collect();\n         }\n \n         hir::TyParam {\n             id: self.lower_node_id(tp.id).node_id,\n             name,\n             bounds,\n-            default: tp.default.as_ref().map(|x| self.lower_ty(x)),\n+            default: tp.default.as_ref().map(|x| self.lower_ty(x, ImplTraitContext::Disallowed)),\n             span: tp.span,\n             pure_wrt_drop: tp.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n             synthetic: tp.attrs.iter()\n@@ -1215,11 +1314,11 @@ impl<'a> LoweringContext<'a> {\n                                                                 span}) => {\n                 hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                     bound_lifetimes: self.lower_lifetime_defs(bound_lifetimes),\n-                    bounded_ty: self.lower_ty(bounded_ty),\n+                    bounded_ty: self.lower_ty(bounded_ty, ImplTraitContext::Disallowed),\n                     bounds: bounds.iter().filter_map(|bound| match *bound {\n                         // Ignore `?Trait` bounds, they were copied into type parameters already.\n                         TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n-                        _ => Some(self.lower_ty_param_bound(bound))\n+                        _ => Some(self.lower_ty_param_bound(bound, ImplTraitContext::Disallowed))\n                     }).collect(),\n                     span,\n                 })\n@@ -1239,8 +1338,8 @@ impl<'a> LoweringContext<'a> {\n                                                           span}) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     id: self.lower_node_id(id).node_id,\n-                    lhs_ty: self.lower_ty(lhs_ty),\n-                    rhs_ty: self.lower_ty(rhs_ty),\n+                    lhs_ty: self.lower_ty(lhs_ty, ImplTraitContext::Disallowed),\n+                    rhs_ty: self.lower_ty(rhs_ty, ImplTraitContext::Disallowed),\n                     span,\n                 })\n             }\n@@ -1267,8 +1366,8 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_trait_ref(&mut self, p: &TraitRef) -> hir::TraitRef {\n-        let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit) {\n+    fn lower_trait_ref(&mut self, p: &TraitRef, itctx: ImplTraitContext) -> hir::TraitRef {\n+        let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit, itctx) {\n             hir::QPath::Resolved(None, path) => path.and_then(|path| path),\n             qpath => bug!(\"lower_trait_ref: unexpected QPath `{:?}`\", qpath)\n         };\n@@ -1278,10 +1377,13 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_poly_trait_ref(&mut self, p: &PolyTraitRef) -> hir::PolyTraitRef {\n+    fn lower_poly_trait_ref(&mut self,\n+                            p: &PolyTraitRef,\n+                            itctx: ImplTraitContext)\n+                            -> hir::PolyTraitRef {\n         hir::PolyTraitRef {\n             bound_lifetimes: self.lower_lifetime_defs(&p.bound_lifetimes),\n-            trait_ref: self.lower_trait_ref(&p.trait_ref),\n+            trait_ref: self.lower_trait_ref(&p.trait_ref, itctx),\n             span: p.span,\n         }\n     }\n@@ -1296,7 +1398,7 @@ impl<'a> LoweringContext<'a> {\n                 None => Ident { name: Symbol::intern(&index.to_string()), ctxt: f.span.ctxt() },\n             }),\n             vis: self.lower_visibility(&f.vis, None),\n-            ty: self.lower_ty(&f.ty),\n+            ty: self.lower_ty(&f.ty, ImplTraitContext::Disallowed),\n             attrs: self.lower_attrs(&f.attrs),\n         }\n     }\n@@ -1310,15 +1412,16 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_mt(&mut self, mt: &MutTy) -> hir::MutTy {\n+    fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext) -> hir::MutTy {\n         hir::MutTy {\n-            ty: self.lower_ty(&mt.ty),\n+            ty: self.lower_ty(&mt.ty, itctx),\n             mutbl: self.lower_mutability(mt.mutbl),\n         }\n     }\n \n-    fn lower_bounds(&mut self, bounds: &[TyParamBound]) -> hir::TyParamBounds {\n-        bounds.iter().map(|bound| self.lower_ty_param_bound(bound)).collect()\n+    fn lower_bounds(&mut self, bounds: &[TyParamBound], itctx: ImplTraitContext)\n+                    -> hir::TyParamBounds {\n+        bounds.iter().map(|bound| self.lower_ty_param_bound(bound, itctx)).collect()\n     }\n \n     fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n@@ -1437,33 +1540,35 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n-                hir::ItemStatic(self.lower_ty(t),\n+                hir::ItemStatic(self.lower_ty(t, ImplTraitContext::Disallowed),\n                                 self.lower_mutability(m),\n                                 value)\n             }\n             ItemKind::Const(ref t, ref e) => {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n-                hir::ItemConst(self.lower_ty(t), value)\n+                hir::ItemConst(self.lower_ty(t, ImplTraitContext::Disallowed), value)\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n+                let fn_def_id = self.resolver.definitions().opt_local_def_id(id);\n                 self.with_new_scopes(|this| {\n                     let body_id = this.lower_body(Some(decl), |this| {\n                         let body = this.lower_block(body, false);\n                         this.expr_block(body, ThinVec::new())\n                     });\n-                    hir::ItemFn(this.lower_fn_decl(decl),\n-                                              this.lower_unsafety(unsafety),\n-                                              this.lower_constness(constness),\n-                                              abi,\n-                                              this.lower_generics(generics),\n-                                              body_id)\n+                    hir::ItemFn(this.lower_fn_decl(decl, fn_def_id, true),\n+                                this.lower_unsafety(unsafety),\n+                                this.lower_constness(constness),\n+                                abi,\n+                                this.lower_generics(generics),\n+                                body_id)\n                 })\n             }\n             ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n             ItemKind::GlobalAsm(ref ga) => hir::ItemGlobalAsm(self.lower_global_asm(ga)),\n             ItemKind::Ty(ref t, ref generics) => {\n-                hir::ItemTy(self.lower_ty(t), self.lower_generics(generics))\n+                hir::ItemTy(self.lower_ty(t, ImplTraitContext::Disallowed),\n+                            self.lower_generics(generics))\n             }\n             ItemKind::Enum(ref enum_definition, ref generics) => {\n                 hir::ItemEnum(hir::EnumDef {\n@@ -1483,7 +1588,7 @@ impl<'a> LoweringContext<'a> {\n                 hir::ItemUnion(vdata, self.lower_generics(generics))\n             }\n             ItemKind::AutoImpl(unsafety, ref trait_ref) => {\n-                let trait_ref = self.lower_trait_ref(trait_ref);\n+                let trait_ref = self.lower_trait_ref(trait_ref, ImplTraitContext::Disallowed);\n \n                 if let Def::Trait(def_id) = trait_ref.path.def {\n                     self.trait_auto_impl.insert(def_id, id);\n@@ -1502,7 +1607,9 @@ impl<'a> LoweringContext<'a> {\n                 let new_impl_items = impl_items.iter()\n                                                .map(|item| self.lower_impl_item_ref(item))\n                                                .collect();\n-                let ifce = ifce.as_ref().map(|trait_ref| self.lower_trait_ref(trait_ref));\n+                let ifce = ifce.as_ref().map(|trait_ref| {\n+                    self.lower_trait_ref(trait_ref, ImplTraitContext::Disallowed)\n+                });\n \n                 if let Some(ref trait_ref) = ifce {\n                     if let Def::Trait(def_id) = trait_ref.path.def {\n@@ -1515,11 +1622,11 @@ impl<'a> LoweringContext<'a> {\n                               self.lower_defaultness(defaultness, true /* [1] */),\n                               self.lower_generics(generics),\n                               ifce,\n-                              self.lower_ty(ty),\n+                              self.lower_ty(ty, ImplTraitContext::Disallowed),\n                               new_impl_items)\n             }\n             ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref items) => {\n-                let bounds = self.lower_bounds(bounds);\n+                let bounds = self.lower_bounds(bounds, ImplTraitContext::Disallowed);\n                 let items = items.iter().map(|item| self.lower_trait_item_ref(item)).collect();\n                 hir::ItemTrait(self.lower_is_auto(is_auto),\n                                self.lower_unsafety(unsafety),\n@@ -1537,6 +1644,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n         self.with_parent_def(i.id, |this| {\n             let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n+            let fn_def_id = this.resolver.definitions().opt_local_def_id(node_id);\n \n             hir::TraitItem {\n                 id: node_id,\n@@ -1546,27 +1654,30 @@ impl<'a> LoweringContext<'a> {\n                 generics: this.lower_generics(&i.generics),\n                 node: match i.node {\n                     TraitItemKind::Const(ref ty, ref default) => {\n-                        hir::TraitItemKind::Const(this.lower_ty(ty),\n+                        hir::TraitItemKind::Const(this.lower_ty(ty, ImplTraitContext::Disallowed),\n                                                   default.as_ref().map(|x| {\n                             this.lower_body(None, |this| this.lower_expr(x))\n                         }))\n                     }\n                     TraitItemKind::Method(ref sig, None) => {\n                         let names = this.lower_fn_args_to_names(&sig.decl);\n-                        hir::TraitItemKind::Method(this.lower_method_sig(sig),\n+                        hir::TraitItemKind::Method(this.lower_method_sig(sig, fn_def_id, false),\n                                                    hir::TraitMethod::Required(names))\n                     }\n                     TraitItemKind::Method(ref sig, Some(ref body)) => {\n                         let body_id = this.lower_body(Some(&sig.decl), |this| {\n                             let body = this.lower_block(body, false);\n                             this.expr_block(body, ThinVec::new())\n                         });\n-                        hir::TraitItemKind::Method(this.lower_method_sig(sig),\n+                        hir::TraitItemKind::Method(this.lower_method_sig(sig, fn_def_id, false),\n                                                    hir::TraitMethod::Provided(body_id))\n                     }\n                     TraitItemKind::Type(ref bounds, ref default) => {\n-                        hir::TraitItemKind::Type(this.lower_bounds(bounds),\n-                                                 default.as_ref().map(|x| this.lower_ty(x)))\n+                        hir::TraitItemKind::Type(this.lower_bounds(bounds,\n+                                                                   ImplTraitContext::Disallowed),\n+                                                 default.as_ref().map(|x| {\n+                                                     this.lower_ty(x, ImplTraitContext::Disallowed)\n+                                                 }))\n                     }\n                     TraitItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n                 },\n@@ -1602,6 +1713,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n         self.with_parent_def(i.id, |this| {\n             let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n+            let fn_def_id = this.resolver.definitions().opt_local_def_id(node_id);\n \n             hir::ImplItem {\n                 id: node_id,\n@@ -1614,16 +1726,24 @@ impl<'a> LoweringContext<'a> {\n                 node: match i.node {\n                     ImplItemKind::Const(ref ty, ref expr) => {\n                         let body_id = this.lower_body(None, |this| this.lower_expr(expr));\n-                        hir::ImplItemKind::Const(this.lower_ty(ty), body_id)\n+                        hir::ImplItemKind::Const(\n+                            this.lower_ty(ty, ImplTraitContext::Disallowed),\n+                            body_id\n+                        )\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n                         let body_id = this.lower_body(Some(&sig.decl), |this| {\n                             let body = this.lower_block(body, false);\n                             this.expr_block(body, ThinVec::new())\n                         });\n-                        hir::ImplItemKind::Method(this.lower_method_sig(sig), body_id)\n+                        let impl_trait_return_allow = !this.is_in_trait_impl;\n+                        hir::ImplItemKind::Method(this.lower_method_sig(sig,\n+                                                                        fn_def_id,\n+                                                                        impl_trait_return_allow),\n+                                                  body_id)\n                     }\n-                    ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n+                    ImplItemKind::Type(ref ty) =>\n+                        hir::ImplItemKind::Type(this.lower_ty(ty, ImplTraitContext::Disallowed)),\n                     ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n                 },\n                 span: i.span,\n@@ -1643,8 +1763,10 @@ impl<'a> LoweringContext<'a> {\n             kind: match i.node {\n                 ImplItemKind::Const(..) => hir::AssociatedItemKind::Const,\n                 ImplItemKind::Type(..) => hir::AssociatedItemKind::Type,\n-                ImplItemKind::Method(ref sig, _) => hir::AssociatedItemKind::Method {\n-                    has_self: sig.decl.has_self(),\n+                ImplItemKind::Method(ref sig, _) => {\n+                    hir::AssociatedItemKind::Method {\n+                        has_self: sig.decl.has_self(),\n+                    }\n                 },\n                 ImplItemKind::Macro(..) => unimplemented!(),\n             },\n@@ -1719,12 +1841,13 @@ impl<'a> LoweringContext<'a> {\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n                     ForeignItemKind::Fn(ref fdec, ref generics) => {\n-                        hir::ForeignItemFn(this.lower_fn_decl(fdec),\n+                        // Disallow impl Trait in foreign items\n+                        hir::ForeignItemFn(this.lower_fn_decl(fdec, None, false),\n                                            this.lower_fn_args_to_names(fdec),\n                                            this.lower_generics(generics))\n                     }\n                     ForeignItemKind::Static(ref t, m) => {\n-                        hir::ForeignItemStatic(this.lower_ty(t), m)\n+                        hir::ForeignItemStatic(this.lower_ty(t, ImplTraitContext::Disallowed), m)\n                     }\n                     ForeignItemKind::Ty => {\n                         hir::ForeignItemType\n@@ -1736,12 +1859,16 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_method_sig(&mut self, sig: &MethodSig) -> hir::MethodSig {\n+    fn lower_method_sig(&mut self,\n+                        sig: &MethodSig,\n+                        fn_def_id: Option<DefId>,\n+                        impl_trait_return_allow: bool)\n+                        -> hir::MethodSig {\n         hir::MethodSig {\n             abi: sig.abi,\n             unsafety: self.lower_unsafety(sig.unsafety),\n             constness: self.lower_constness(sig.constness),\n-            decl: self.lower_fn_decl(&sig.decl),\n+            decl: self.lower_fn_decl(&sig.decl, fn_def_id, impl_trait_return_allow),\n         }\n     }\n \n@@ -1834,16 +1961,19 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n                 PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n-                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional);\n+                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n+                                                 ImplTraitContext::Disallowed);\n                     hir::PatKind::TupleStruct(qpath,\n                                               pats.iter().map(|x| self.lower_pat(x)).collect(),\n                                               ddpos)\n                 }\n                 PatKind::Path(ref qself, ref path) => {\n-                    hir::PatKind::Path(self.lower_qpath(p.id, qself, path, ParamMode::Optional))\n+                    hir::PatKind::Path(self.lower_qpath(p.id, qself, path, ParamMode::Optional,\n+                                                        ImplTraitContext::Disallowed))\n                 }\n                 PatKind::Struct(ref path, ref fields, etc) => {\n-                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional);\n+                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional,\n+                                                 ImplTraitContext::Disallowed);\n \n                     let fs = fields.iter()\n                                    .map(|f| {\n@@ -2020,7 +2150,8 @@ impl<'a> LoweringContext<'a> {\n             }\n             ExprKind::MethodCall(ref seg, ref args) => {\n                 let hir_seg = self.lower_path_segment(e.span, seg, ParamMode::Optional, 0,\n-                                                      ParenthesizedGenericArgs::Err);\n+                                                      ParenthesizedGenericArgs::Err,\n+                                                      ImplTraitContext::Disallowed);\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n                 hir::ExprMethodCall(hir_seg, seg.span, args)\n             }\n@@ -2038,11 +2169,11 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Lit(ref l) => hir::ExprLit(P((**l).clone())),\n             ExprKind::Cast(ref expr, ref ty) => {\n                 let expr = P(self.lower_expr(expr));\n-                hir::ExprCast(expr, self.lower_ty(ty))\n+                hir::ExprCast(expr, self.lower_ty(ty, ImplTraitContext::Disallowed))\n             }\n             ExprKind::Type(ref expr, ref ty) => {\n                 let expr = P(self.lower_expr(expr));\n-                hir::ExprType(expr, self.lower_ty(ty))\n+                hir::ExprType(expr, self.lower_ty(ty, ImplTraitContext::Disallowed))\n             }\n             ExprKind::AddrOf(m, ref ohs) => {\n                 let m = self.lower_mutability(m);\n@@ -2119,7 +2250,7 @@ impl<'a> LoweringContext<'a> {\n                             this.sess.abort_if_errors();\n                         }\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n-                                         this.lower_fn_decl(decl),\n+                                         this.lower_fn_decl(decl, None, false),\n                                          body_id,\n                                          fn_decl_span,\n                                          is_generator)\n@@ -2193,7 +2324,8 @@ impl<'a> LoweringContext<'a> {\n                 };\n             }\n             ExprKind::Path(ref qself, ref path) => {\n-                hir::ExprPath(self.lower_qpath(e.id, qself, path, ParamMode::Optional))\n+                hir::ExprPath(self.lower_qpath(e.id, qself, path, ParamMode::Optional,\n+                                               ImplTraitContext::Disallowed))\n             }\n             ExprKind::Break(opt_ident, ref opt_expr) => {\n                 let label_result = if self.is_in_loop_condition && opt_ident.is_none() {\n@@ -2246,7 +2378,8 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprInlineAsm(P(hir_asm), outputs, inputs)\n             }\n             ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n-                hir::ExprStruct(self.lower_qpath(e.id, &None, path, ParamMode::Optional),\n+                hir::ExprStruct(self.lower_qpath(e.id, &None, path, ParamMode::Optional,\n+                                                 ImplTraitContext::Disallowed),\n                                 fields.iter().map(|x| self.lower_field(x)).collect(),\n                                 maybe_expr.as_ref().map(|x| P(self.lower_expr(x))))\n             }"}, {"sha": "ee83000c44003a92fb144c5c0da5d9c33260afe7", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -1461,9 +1461,12 @@ pub enum Ty_ {\n     /// A trait object type `Bound1 + Bound2 + Bound3`\n     /// where `Bound` is a trait or a lifetime.\n     TyTraitObject(HirVec<PolyTraitRef>, Lifetime),\n-    /// An `impl Bound1 + Bound2 + Bound3` type\n-    /// where `Bound` is a trait or a lifetime.\n-    TyImplTrait(TyParamBounds),\n+    /// An exsitentially quantified (there exists a type satisfying) `impl\n+    /// Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n+    TyImplTraitExistential(TyParamBounds),\n+    /// An universally quantified (for all types satisfying) `impl\n+    /// Bound1 + Bound2 + Bound3` type where `Bound` is a trait or a lifetime.\n+    TyImplTraitUniversal(DefId, TyParamBounds),\n     /// Unused for now\n     TyTypeof(BodyId),\n     /// TyInfer means the type should be inferred instead of it having been"}, {"sha": "451e870f500ddcad67929e078ad6d50fb9540176", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -421,8 +421,9 @@ impl<'a> State<'a> {\n                     self.print_lifetime(lifetime)?;\n                 }\n             }\n-            hir::TyImplTrait(ref bounds) => {\n-                self.print_bounds(\"impl \", &bounds[..])?;\n+            hir::TyImplTraitExistential(ref bounds) |\n+                hir::TyImplTraitUniversal(_, ref bounds) => {\n+                self.print_bounds(\"impl\", &bounds[..])?;\n             }\n             hir::TyArray(ref ty, v) => {\n                 self.s.word(\"[\")?;"}, {"sha": "a04683e1b22000b779c284ef4e7b46c4229e3586", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -287,7 +287,8 @@ impl_stable_hash_for!(enum hir::Ty_ {\n     TyTup(ts),\n     TyPath(qpath),\n     TyTraitObject(trait_refs, lifetime),\n-    TyImplTrait(bounds),\n+    TyImplTraitExistential(bounds),\n+    TyImplTraitUniversal(def_id, bounds),\n     TyTypeof(body_id),\n     TyErr,\n     TyInfer"}, {"sha": "8c299612064d5a75935508832da11528178307da", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -1604,6 +1604,17 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     walk_list!(&mut appears_in_where_clause,\n                visit_where_predicate,\n                &generics.where_clause.predicates);\n+    // We need to collect argument impl Trait lifetimes as well,\n+    // we do so here.\n+    walk_list!(&mut appears_in_where_clause,\n+               visit_ty,\n+               decl.inputs.iter().filter(|ty| {\n+                   if let hir::TyImplTraitUniversal(..) = ty.node {\n+                       true\n+                   } else {\n+                       false\n+                   }\n+               }));\n     for lifetime_def in &generics.lifetimes {\n         if !lifetime_def.bounds.is_empty() {\n             // `'a: 'b` means both `'a` and `'b` are referenced\n@@ -1698,7 +1709,7 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n         }\n \n         fn visit_ty(&mut self, ty: &hir::Ty) {\n-            if let hir::TyImplTrait(_) = ty.node {\n+            if let hir::TyImplTraitExistential(_) = ty.node {\n                 self.impl_trait = true;\n             }\n             intravisit::walk_ty(self, ty);"}, {"sha": "8c40f303b939a3d047f0311e590c0dd0f84daaf1", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -1487,7 +1487,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         match ty.node {\n-            hir::TyImplTrait(_) => {\n+            hir::TyImplTraitExistential(_) => {\n                 let def_id = self.tcx.hir.local_def_id(ty.id);\n                 self.record(def_id, IsolatedEncoder::encode_info_for_anon_ty, def_id);\n             }"}, {"sha": "74d92ce1c3e621c66dd568229bd27f99c5babb00", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -373,7 +373,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyImplTrait(..) = ty.node {\n+        if let hir::TyImplTraitExistential(..) = ty.node {\n             if self.get(ty.id).is_some() {\n                 // Reach the (potentially private) type and the API being exposed.\n                 self.reach(ty.id).ty().predicates();\n@@ -1557,7 +1557,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyImplTrait(..) = ty.node {\n+        if let hir::TyImplTraitExistential(..) = ty.node {\n             // Check the traits being exposed, as they're separate,\n             // e.g. `impl Iterator<Item=T>` has two predicates,\n             // `X: Iterator` and `<X as Iterator>::Item == T`,"}, {"sha": "7aaf65e1fd07d583e28febabc244132cc064070f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 11, "deletions": 47, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -30,6 +30,7 @@ use util::nodemap::FxHashSet;\n \n use std::iter;\n use syntax::{abi, ast};\n+use syntax::symbol::Symbol;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax_pos::Span;\n \n@@ -1033,53 +1034,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyTraitObject(ref bounds, ref lifetime) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n             }\n-            hir::TyImplTrait(_) => {\n-                // Figure out if we can allow an `impl Trait` here, by walking up\n-                // to a `fn` or inherent `impl` method, going only through `Ty`\n-                // or `TraitRef` nodes (as nothing else should be in types) and\n-                // ensuring that we reach the `fn`/method signature's return type.\n-                let mut node_id = ast_ty.id;\n-                let fn_decl = loop {\n-                    let parent = tcx.hir.get_parent_node(node_id);\n-                    match tcx.hir.get(parent) {\n-                        hir::map::NodeItem(&hir::Item {\n-                            node: hir::ItemFn(ref fn_decl, ..), ..\n-                        }) => break Some(fn_decl),\n-\n-                        hir::map::NodeImplItem(&hir::ImplItem {\n-                            node: hir::ImplItemKind::Method(ref sig, _), ..\n-                        }) => {\n-                            match tcx.hir.expect_item(tcx.hir.get_parent(parent)).node {\n-                                hir::ItemImpl(.., None, _, _) => {\n-                                    break Some(&sig.decl)\n-                                }\n-                                _ => break None\n-                            }\n-                        }\n-\n-                        hir::map::NodeTy(_) | hir::map::NodeTraitRef(_) => {}\n-\n-                        _ => break None\n-                    }\n-                    node_id = parent;\n-                };\n-                let allow = fn_decl.map_or(false, |fd| {\n-                    match fd.output {\n-                        hir::DefaultReturn(_) => false,\n-                        hir::Return(ref ty) => ty.id == node_id\n-                    }\n-                });\n-\n-                // Create the anonymized type.\n-                if allow {\n-                    let def_id = tcx.hir.local_def_id(ast_ty.id);\n-                    tcx.mk_anon(def_id, Substs::identity_for_item(tcx, def_id))\n-                } else {\n-                    span_err!(tcx.sess, ast_ty.span, E0562,\n-                              \"`impl Trait` not allowed outside of function \\\n-                               and inherent method return types\");\n-                    tcx.types.err\n-                }\n+            hir::TyImplTraitExistential(_) => {\n+                let def_id = tcx.hir.local_def_id(ast_ty.id);\n+                tcx.mk_anon(def_id, Substs::identity_for_item(tcx, def_id))\n+            }\n+            hir::TyImplTraitUniversal(fn_def_id, _) => {\n+                let impl_trait_def_id = tcx.hir.local_def_id(ast_ty.id);\n+                let generics = tcx.generics_of(fn_def_id);\n+                let index = generics.type_param_to_index[&impl_trait_def_id.index];\n+                tcx.mk_param(index,\n+                             Symbol::intern(&tcx.hir.node_to_pretty_string(ast_ty.id)))\n             }\n             hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);"}, {"sha": "139449e5ab0aec09711e9ec936168bc4bc64e129", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -67,6 +67,14 @@ pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return;\n     }\n \n+    if let Err(ErrorReported) = compare_synthetic_generics(tcx,\n+                                                           impl_m,\n+                                                           impl_m_span,\n+                                                           trait_m,\n+                                                           trait_item_span) {\n+        return;\n+    }\n+\n     if let Err(ErrorReported) = compare_predicate_entailment(tcx,\n                                                              impl_m,\n                                                              impl_m_span,\n@@ -708,6 +716,45 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Ok(())\n }\n \n+fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        impl_m: &ty::AssociatedItem,\n+                                        _impl_m_span: Span, // FIXME necessary?\n+                                        trait_m: &ty::AssociatedItem,\n+                                        _trait_item_span: Option<Span>) // FIXME necessary?\n+                                        -> Result<(), ErrorReported> {\n+    // FIXME(chrisvittal) Clean up this function, list of FIXME items:\n+    //     1. Better messages for the span lables\n+    //     2. Explanation as to what is going on\n+    //     3. Correct the function signature for what we actually use\n+    // If we get here, we already have the same number of generics, so the zip will\n+    // be okay.\n+    let mut error_found = false;\n+    let impl_m_generics = tcx.generics_of(impl_m.def_id);\n+    let trait_m_generics = tcx.generics_of(trait_m.def_id);\n+    for (impl_ty, trait_ty) in impl_m_generics.types.iter().zip(trait_m_generics.types.iter()) {\n+        if impl_ty.synthetic != trait_ty.synthetic {\n+            let impl_node_id = tcx.hir.as_local_node_id(impl_ty.def_id).unwrap();\n+            let impl_span = tcx.hir.span(impl_node_id);\n+            let trait_node_id = tcx.hir.as_local_node_id(trait_ty.def_id).unwrap();\n+            let trait_span = tcx.hir.span(trait_node_id);\n+            let mut err = struct_span_err!(tcx.sess,\n+                                           impl_span,\n+                                           E0643,\n+                                           \"method `{}` has incompatible signature for trait\",\n+                                           trait_m.name);\n+            err.span_label(trait_span, \"annotation in trait\");\n+            err.span_label(impl_span, \"annotation in impl\");\n+            err.emit();\n+            error_found = true;\n+        }\n+    }\n+    if error_found {\n+        Err(ErrorReported)\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     impl_c: &ty::AssociatedItem,\n                                     impl_c_span: Span,"}, {"sha": "4cc1e83d6e3c9296983e215e1b805bda25711992", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -5035,6 +5035,10 @@ pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if let ty::TyParam(ParamTy {idx, ..}) = leaf_ty.sty {\n             debug!(\"Found use of ty param num {}\", idx);\n             tps_used[idx as usize - generics.lifetimes.len()] = true;\n+        } else if let ty::TyError = leaf_ty.sty {\n+            // If there already another error, do not emit an error for not using a type Parameter\n+            assert!(tcx.sess.err_count() > 0);\n+            return;\n         }\n     }\n "}, {"sha": "b5fbbeb1692e6e14b46472e57896c8d9880014ff", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 131, "deletions": 28, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -43,6 +43,7 @@ use rustc_const_math::ConstInt;\n use std::collections::BTreeMap;\n \n use syntax::{abi, ast};\n+use syntax::ptr::P;\n use syntax::codemap::Spanned;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -130,7 +131,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        if let hir::TyImplTrait(..) = ty.node {\n+        if let hir::TyImplTraitExistential(..) = ty.node {\n             let def_id = self.tcx.hir.local_def_id(ty.id);\n             self.tcx.generics_of(def_id);\n             self.tcx.predicates_of(def_id);\n@@ -854,7 +855,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n             Some(tcx.closure_base_def_id(def_id))\n         }\n-        NodeTy(&hir::Ty { node: hir::TyImplTrait(..), .. }) => {\n+        NodeTy(&hir::Ty { node: hir::TyImplTraitExistential(..), .. }) => {\n             let mut parent_id = node_id;\n             loop {\n                 match tcx.hir.get(parent_id) {\n@@ -873,22 +874,32 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut allow_defaults = false;\n \n     let no_generics = hir::Generics::empty();\n-    let ast_generics = match node {\n-        NodeTraitItem(item) => &item.generics,\n+    let (ast_generics, opt_inputs) = match node {\n+        NodeTraitItem(item) => {\n+            match item.node {\n+                TraitItemKind::Method(ref sig, _) => (&item.generics, Some(&sig.decl.inputs)),\n+                _ => (&item.generics, None)\n+            }\n+        }\n \n-        NodeImplItem(item) => &item.generics,\n+        NodeImplItem(item) => {\n+            match item.node {\n+                ImplItemKind::Method(ref sig, _) => (&item.generics, Some(&sig.decl.inputs)),\n+                _ => (&item.generics, None)\n+            }\n+        }\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemFn(.., ref generics, _) |\n-                ItemImpl(_, _, _, ref generics, ..) => generics,\n+                ItemFn(ref decl, .., ref generics, _) => (generics, Some(&decl.inputs)),\n+                ItemImpl(_, _, _, ref generics, ..) => (generics, None),\n \n                 ItemTy(_, ref generics) |\n                 ItemEnum(_, ref generics) |\n                 ItemStruct(_, ref generics) |\n                 ItemUnion(_, ref generics) => {\n                     allow_defaults = true;\n-                    generics\n+                    (generics, None)\n                 }\n \n                 ItemTrait(_, _, ref generics, ..) => {\n@@ -909,22 +920,22 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     });\n \n                     allow_defaults = true;\n-                    generics\n+                    (generics, None)\n                 }\n \n-                _ => &no_generics\n+                _ => (&no_generics, None)\n             }\n         }\n \n         NodeForeignItem(item) => {\n             match item.node {\n-                ForeignItemStatic(..) => &no_generics,\n-                ForeignItemFn(_, _, ref generics) => generics,\n-                ForeignItemType => &no_generics,\n+                ForeignItemStatic(..) => (&no_generics, None),\n+                ForeignItemFn(ref decl, _, ref generics) => (generics, Some(&decl.inputs)),\n+                ForeignItemType => (&no_generics, None)\n             }\n         }\n \n-        _ => &no_generics\n+        _ => (&no_generics, None)\n     };\n \n     let has_self = opt_self.is_some();\n@@ -981,7 +992,24 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             synthetic: p.synthetic,\n         }\n     });\n-    let mut types: Vec<_> = opt_self.into_iter().chain(types).collect();\n+\n+    let fn_ins = opt_inputs.map(|tys| &tys[..]);\n+    let univ_impl_trait_info = extract_universal_impl_trait_info(tcx, fn_ins);\n+    let other_type_start = type_start + ast_generics.ty_params.len() as u32;\n+    let mut types: Vec<_> = opt_self.into_iter()\n+        .chain(types)\n+        .chain(univ_impl_trait_info.iter().enumerate().map(|(i, info)| {\n+            ty::TypeParameterDef {\n+                index: other_type_start + i as u32,\n+                name: Symbol::intern(&tcx.hir.node_to_pretty_string(info.id)),\n+                def_id: info.def_id,\n+                has_default: false,\n+                object_lifetime_default: rl::Set1::Empty,\n+                pure_wrt_drop: false,\n+                synthetic: Some(SyntheticTyParamKind::ImplTrait),\n+            }\n+        }))\n+        .collect();\n \n     // provide junk type parameter defs - the only place that\n     // cares about anything but the length is instantiation,\n@@ -1155,7 +1183,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             icx.to_ty(ty)\n         }\n \n-        NodeTy(&hir::Ty { node: TyImplTrait(..), .. }) => {\n+        NodeTy(&hir::Ty { node: TyImplTraitExistential(..), .. }) => {\n             let owner = tcx.hir.get_parent_did(node_id);\n             let hir_id = tcx.hir.node_to_hir_id(node_id);\n             tcx.typeck_tables_of(owner).node_id_to_type(hir_id)\n@@ -1337,43 +1365,54 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let icx = ItemCtxt::new(tcx, def_id);\n     let no_generics = hir::Generics::empty();\n-    let ast_generics = match node {\n-        NodeTraitItem(item) => &item.generics,\n+    let (ast_generics, opt_inputs) = match node {\n+        NodeTraitItem(item) => {\n+            match item.node {\n+                TraitItemKind::Method(ref sig, _) => (&item.generics, Some(&sig.decl.inputs)),\n+                _ => (&item.generics, None)\n+            }\n+        }\n \n-        NodeImplItem(item) => &item.generics,\n+        NodeImplItem(item) => {\n+            match item.node {\n+                ImplItemKind::Method(ref sig, _) => (&item.generics, Some(&sig.decl.inputs)),\n+                _ => (&item.generics, None)\n+            }\n+        }\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemFn(.., ref generics, _) |\n+                ItemFn(ref decl, .., ref generics, _) => (generics, Some(&decl.inputs)),\n+\n                 ItemImpl(_, _, _, ref generics, ..) |\n                 ItemTy(_, ref generics) |\n                 ItemEnum(_, ref generics) |\n                 ItemStruct(_, ref generics) |\n                 ItemUnion(_, ref generics) => {\n-                    generics\n+                    (generics, None)\n                 }\n \n                 ItemTrait(_, _, ref generics, .., ref items) => {\n                     is_trait = Some((ty::TraitRef {\n                         def_id,\n                         substs: Substs::identity_for_item(tcx, def_id)\n                     }, items));\n-                    generics\n+                    (generics, None)\n                 }\n \n-                _ => &no_generics\n+                _ => (&no_generics, None)\n             }\n         }\n \n         NodeForeignItem(item) => {\n             match item.node {\n-                ForeignItemStatic(..) => &no_generics,\n-                ForeignItemFn(_, _, ref generics) => generics,\n-                ForeignItemType => &no_generics,\n+                ForeignItemStatic(..) => (&no_generics, None),\n+                ForeignItemFn(ref decl, _, ref generics) => (generics, Some(&decl.inputs)),\n+                ForeignItemType => (&no_generics, None),\n             }\n         }\n \n-        NodeTy(&Ty { node: TyImplTrait(ref bounds), span, .. }) => {\n+        NodeTy(&Ty { node: TyImplTraitExistential(ref bounds), span, .. }) => {\n             let substs = Substs::identity_for_item(tcx, def_id);\n             let anon_ty = tcx.mk_anon(def_id, substs);\n \n@@ -1387,7 +1426,7 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             };\n         }\n \n-        _ => &no_generics\n+        _ => (&no_generics, None)\n     };\n \n     let generics = tcx.generics_of(def_id);\n@@ -1518,6 +1557,19 @@ fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }))\n     }\n \n+    // Add predicates from impl Trait arguments\n+    let fn_ins = opt_inputs.map(|tys| &tys[..]);\n+    let univ_impl_trait_info = extract_universal_impl_trait_info(tcx, fn_ins);\n+    for info in univ_impl_trait_info.iter() {\n+        let name = keywords::Invalid.name();\n+        let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n+        index += 1;\n+        let bounds = compute_bounds(&icx, param_ty, info.bounds,\n+                                    SizedByDefault::Yes,\n+                                    info.span);\n+        predicates.extend(bounds.predicates(tcx, param_ty));\n+    }\n+\n     // Subtle: before we store the predicates into the tcx, we\n     // sort them so that predicates like `T: Foo<Item=U>` come\n     // before uses of `U`.  This avoids false ambiguity errors\n@@ -1678,3 +1730,54 @@ fn is_auto_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _ => bug!(\"is_auto_impl applied to non-local def-id {:?}\", def_id)\n     }\n }\n+\n+struct ImplTraitUniversalInfo<'hir> {\n+    id: ast::NodeId,\n+    def_id: DefId,\n+    span: Span,\n+    bounds: &'hir [hir::TyParamBound],\n+}\n+\n+/// Take some possible list of arguments and return the DefIds of the ImplTraitUniversal\n+/// arguments\n+fn extract_universal_impl_trait_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               opt_inputs: Option<&'tcx [P<hir::Ty>]>)\n+                                               -> Vec<ImplTraitUniversalInfo<'tcx>>\n+{\n+    // A visitor for simply collecting Universally quantified impl Trait arguments\n+    struct ImplTraitUniversalVisitor<'tcx> {\n+        items: Vec<&'tcx hir::Ty>\n+    }\n+\n+    impl<'tcx> Visitor<'tcx> for ImplTraitUniversalVisitor<'tcx> {\n+        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+            if let hir::TyImplTraitUniversal(..) = ty.node {\n+                self.items.push(ty);\n+            }\n+            intravisit::walk_ty(self, ty);\n+        }\n+    }\n+\n+    let mut visitor = ImplTraitUniversalVisitor { items: Vec::new() };\n+\n+    if let Some(inputs) = opt_inputs {\n+        for t in inputs.iter() {\n+            visitor.visit_ty(t);\n+        }\n+    }\n+\n+    visitor.items.into_iter().map(|ty| if let hir::TyImplTraitUniversal(_, ref bounds) = ty.node {\n+        ImplTraitUniversalInfo {\n+            id: ty.id,\n+            def_id: tcx.hir.local_def_id(ty.id),\n+            span: ty.span,\n+            bounds: bounds\n+        }\n+    } else {\n+        span_bug!(ty.span, \"this type should be a universally quantified impl trait. this is a bug\")\n+    }).collect()\n+}"}, {"sha": "328b7f9fdefcae71a99eaf3d16824404c146e371", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -3818,46 +3818,6 @@ let s = Simba { mother: 1, father: 0 }; // ok!\n ```\n \"##,\n \n-E0562: r##\"\n-Abstract return types (written `impl Trait` for some trait `Trait`) are only\n-allowed as function return types.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0562\n-#![feature(conservative_impl_trait)]\n-\n-fn main() {\n-    let count_to_ten: impl Iterator<Item=usize> = 0..10;\n-    // error: `impl Trait` not allowed outside of function and inherent method\n-    //        return types\n-    for i in count_to_ten {\n-        println!(\"{}\", i);\n-    }\n-}\n-```\n-\n-Make sure `impl Trait` only appears in return-type position.\n-\n-```\n-#![feature(conservative_impl_trait)]\n-\n-fn count_to_n(n: usize) -> impl Iterator<Item=usize> {\n-    0..n\n-}\n-\n-fn main() {\n-    for i in count_to_n(10) {  // ok!\n-        println!(\"{}\", i);\n-    }\n-}\n-```\n-\n-See [RFC 1522] for more details.\n-\n-[RFC 1522]: https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md\n-\"##,\n-\n E0569: r##\"\n If an impl has a generic parameter with the `#[may_dangle]` attribute, then\n that impl must be declared as an `unsafe impl.\n@@ -4665,6 +4625,22 @@ It is recommended that you look for a `new` function or equivalent in the\n crate's documentation.\n \"##,\n \n+E0643: r##\"\n+This error indicates that there is a mismatch between generic parameters and\n+impl Trait parameters in a trait declaration versus its impl.\n+\n+```compile_fail,E0643\n+#![feature(universal_impl_trait)]\n+trait Foo {\n+    fn foo(&self, _: &impl Iterator);\n+}\n+impl Foo for () {\n+    fn foo<U: Iterator>(&self, _: &U) { } // error method `foo` has incompatible\n+                                          // signature for trait\n+}\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {"}, {"sha": "1d107c169b04625dfe3e7c75e8866f931e7c7744", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -1960,7 +1960,9 @@ impl Clean<Type> for hir::Ty {\n                 }\n             }\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n-            TyImplTrait(ref bounds) => ImplTrait(bounds.clean(cx)),\n+            TyImplTraitExistential(ref bounds) |\n+                TyImplTraitUniversal(_, ref bounds) =>\n+                    ImplTrait(bounds.clean(cx)),\n             TyInfer | TyErr => Infer,\n             TyTypeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n         }"}, {"sha": "97eec3a21e9d16629d8cb28890761e2fa4da68bc", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -275,6 +275,9 @@ declare_features! (\n     // Allows `impl Trait` in function return types.\n     (active, conservative_impl_trait, \"1.12.0\", Some(34511)),\n \n+    // Allows `impl Trait` in function arguments.\n+    (active, universal_impl_trait, \"1.23.0\", Some(34511)),\n+\n     // The `!` type\n     (active, never_type, \"1.13.0\", Some(35121)),\n \n@@ -1451,10 +1454,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::TyKind::BareFn(ref bare_fn_ty) => {\n                 self.check_abi(bare_fn_ty.abi, ty.span);\n             }\n-            ast::TyKind::ImplTrait(..) => {\n-                gate_feature_post!(&self, conservative_impl_trait, ty.span,\n-                                   \"`impl Trait` is experimental\");\n-            }\n             ast::TyKind::Never => {\n                 gate_feature_post!(&self, never_type, ty.span,\n                                    \"The `!` type is experimental\");"}, {"sha": "0467c49b0311def45249af4a813e3eb2a18493f1", "filename": "src/test/compile-fail/impl-trait/disallowed.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fa26421f56e385b1055e65b29a55b36bb2eae23e/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa26421f56e385b1055e65b29a55b36bb2eae23e/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs?ref=fa26421f56e385b1055e65b29a55b36bb2eae23e", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(conservative_impl_trait)]\n-\n-fn arguments(_: impl Fn(),\n-//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n-             _: Vec<impl Clone>) {}\n-//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n-\n-type Factory<R> = impl Fn() -> R;\n-//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n-\n-type GlobalFactory<R> = fn() -> impl FnOnce() -> R;\n-//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n-\n-trait LazyToString {\n-    fn lazy_to_string<'a>(&'a self) -> impl Fn() -> String;\n-    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n-}\n-\n-impl LazyToString for String {\n-    fn lazy_to_string<'a>(&'a self) -> impl Fn() -> String {\n-    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n-        || self.clone()\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-struct Lazy<T>(T);\n-\n-impl std::ops::Add<Lazy<i32>> for Lazy<i32> {\n-    type Output = impl Fn() -> Lazy<i32>;\n-    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n-\n-    fn add(self, other: Lazy<i32>) -> Self::Output {\n-        move || Lazy(self.0 + other.0)\n-    }\n-}\n-\n-impl<F> std::ops::Add<F>\n-for impl Fn() -> Lazy<i32>\n-//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n-where F: Fn() -> impl FnOnce() -> i32\n-//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n-{\n-    type Output = Self;\n-\n-    fn add(self, other: F) -> Self::Output {\n-        move || Lazy(self().0 + other()())\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "e5bdf3a42eb3e6b0d1ad5a170830d258833125aa", "filename": "src/test/compile-fail/impl-trait/feature-gate-universal.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Ffeature-gate-universal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Ffeature-gate-universal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Ffeature-gate-universal.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// gate-test-universal_impl_trait\n+\n+fn foo(x: impl std::fmt::Debug) { print!(\"{:?}\", x); }\n+//~^ ERROR `impl Trait` in argument position is experimental\n+\n+fn main() {}"}, {"sha": "d46a16450db5228b8667f1c82f026151fc93feea", "filename": "src/test/compile-fail/impl-trait/feature-gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Ffeature-gate.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -11,6 +11,6 @@\n // gate-test-conservative_impl_trait\n \n fn foo() -> impl Fn() { || {} }\n-//~^ ERROR `impl Trait` is experimental\n+//~^ ERROR `impl Trait` in return position is experimental\n \n fn main() {}"}, {"sha": "43b47e9e915f00918a46c294e571c791dce9dc93", "filename": "src/test/compile-fail/impl-trait/impl-generic-mismatch-ab.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fimpl-generic-mismatch-ab.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fimpl-generic-mismatch-ab.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fimpl-generic-mismatch-ab.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(universal_impl_trait)]\n+use std::fmt::Debug;\n+\n+trait Foo {\n+    fn foo<A: Debug>(&self, a: &A, b: &impl Debug);\n+}\n+\n+impl Foo for () {\n+    fn foo<B: Debug>(&self, a: &impl Debug, b: &B) { }\n+    //~^ ERROR method `foo` has an incompatible type for trait\n+}\n+\n+fn main() {}"}, {"sha": "a95da61aa4c0051d68bd4e45a93b887eccc4a77e", "filename": "src/test/compile-fail/impl-trait/impl-generic-mismatch.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fimpl-generic-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fimpl-generic-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fimpl-generic-mismatch.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(universal_impl_trait)]\n+use std::fmt::Debug;\n+\n+trait Foo {\n+    fn foo(&self, _: &impl Debug);\n+}\n+\n+impl Foo for () {\n+    fn foo<U: Debug>(&self, _: &U) { }\n+    //~^ Error method `foo` has incompatible signature for trait\n+}\n+\n+trait Bar {\n+    fn bar<U: Debug>(&self, _: &U);\n+}\n+\n+impl Bar for () {\n+    fn bar(&self, _: &impl Debug) { }\n+    //~^ Error method `bar` has incompatible signature for trait\n+}\n+\n+fn main() {}"}, {"sha": "af83a2d0a2337ff79e7efc8b3a0e253cab29928c", "filename": "src/test/compile-fail/impl-trait/where-allowed.rs", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fwhere-allowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fwhere-allowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fwhere-allowed.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,234 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A simple test for testing many permutations of allowedness of\n+//! impl Trait\n+#![feature(conservative_impl_trait, universal_impl_trait, dyn_trait)]\n+use std::fmt::Debug;\n+\n+// Allowed\n+fn in_parameters(_: impl Debug) { panic!() }\n+\n+// Allowed\n+fn in_return() -> impl Debug { panic!() }\n+\n+// Allowed\n+fn in_adt_in_parameters(_: Vec<impl Debug>) { panic!() }\n+\n+// Allowed\n+fn in_adt_in_return() -> Vec<impl Debug> { panic!() }\n+\n+// Disallowed\n+fn in_fn_parameter_in_parameters(_: fn(impl Debug)) { panic!() }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+fn in_fn_return_in_parameters(_: fn() -> impl Debug) { panic!() }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+fn in_fn_parameter_in_return() -> fn(impl Debug) { panic!() }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+fn in_fn_return_in_return() -> fn() -> impl Debug { panic!() }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+fn in_dyn_Fn_parameter_in_parameters(_: &dyn Fn(impl Debug)) { panic!() }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+fn in_dyn_Fn_return_in_parameters(_: &dyn Fn() -> impl Debug) { panic!() }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+fn in_dyn_Fn_parameter_in_return() -> &'static dyn Fn(impl Debug) { panic!() }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+fn in_dyn_Fn_return_in_return() -> &'static dyn Fn() -> impl Debug { panic!() }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+fn in_impl_Fn_parameter_in_parameters(_: &impl Fn(impl Debug)) { panic!() }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+fn in_impl_Fn_return_in_parameters(_: &impl Fn() -> impl Debug) { panic!() }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+fn in_impl_Fn_parameter_in_return() -> &'static impl Fn(impl Debug) { panic!() }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+fn in_impl_Fn_return_in_return() -> &'static impl Fn() -> impl Debug { panic!() }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+fn in_Fn_parameter_in_generics<F: Fn(impl Debug)> (_: F) { panic!() }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+fn in_Fn_return_in_generics<F: Fn() -> impl Debug> (_: F) { panic!() }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+\n+// Allowed\n+fn in_impl_Trait_in_parameters(_: impl Iterator<Item = impl Iterator>) { panic!() }\n+\n+// Allowed\n+fn in_impl_Trait_in_return() -> impl IntoIterator<Item = impl IntoIterator> {\n+    vec![vec![0; 10], vec![12; 7], vec![8; 3]]\n+}\n+\n+// Disallowed\n+struct InBraceStructField { x: impl Debug }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+struct InAdtInBraceStructField { x: Vec<impl Debug> }\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+struct InTupleStructField(impl Debug);\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed\n+enum InEnum {\n+    InBraceVariant { x: impl Debug },\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+    InTupleVariant(impl Debug),\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+}\n+\n+// Allowed\n+trait InTraitDefnParameters {\n+    fn in_parameters(_: impl Debug);\n+}\n+\n+// Disallowed\n+trait InTraitDefnReturn {\n+    fn in_return() -> impl Debug;\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+}\n+\n+// Allowed and disallowed in trait impls\n+trait DummyTrait {\n+    type Out;\n+    fn in_trait_impl_parameter(impl Debug);\n+    fn in_trait_impl_return() -> Self::Out;\n+}\n+impl DummyTrait for () {\n+    type Out = impl Debug;\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+    fn in_trait_impl_parameter(_: impl Debug) { }\n+    // Allowed\n+\n+    fn in_trait_impl_return() -> impl Debug { () }\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+}\n+\n+// Allowed\n+struct DummyType;\n+impl DummyType {\n+    fn in_inherent_impl_parameters(_: impl Debug) { }\n+    fn in_inherent_impl_return() -> impl Debug { () }\n+}\n+\n+// Disallowed\n+extern \"C\" {\n+    fn in_foreign_parameters(_: impl Debug);\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+    fn in_foreign_return() -> impl Debug;\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+}\n+\n+// Allowed\n+extern \"C\" fn in_extern_fn_parameters(_: impl Debug) {\n+}\n+\n+// Allowed\n+extern \"C\" fn in_extern_fn_return() -> impl Debug {\n+    22\n+}\n+\n+type InTypeAlias<R> = impl Debug;\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+type InReturnInTypeAlias<R> = fn() -> impl Debug;\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+// Disallowed in impl headers\n+impl PartialEq<impl Debug> for () {\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+}\n+\n+// Disallowed in impl headers\n+impl PartialEq<()> for impl Debug {\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+}\n+\n+// Disallowed in inherent impls\n+impl impl Debug {\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+}\n+\n+// Disallowed in inherent impls\n+struct InInherentImplAdt<T> { t: T }\n+impl InInherentImplAdt<impl Debug> {\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+}\n+\n+// Disallowed in where clauses\n+fn in_fn_where_clause()\n+    where impl Debug: Debug\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+{\n+}\n+\n+// Disallowed in where clauses\n+fn in_adt_in_fn_where_clause()\n+    where Vec<impl Debug>: Debug\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+{\n+}\n+\n+// Disallowed\n+fn in_trait_parameter_in_fn_where_clause<T>()\n+    where T: PartialEq<impl Debug>\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+{\n+}\n+\n+// Disallowed\n+fn in_Fn_parameter_in_fn_where_clause<T>()\n+    where T: Fn(impl Debug)\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+{\n+}\n+\n+// Disallowed\n+fn in_Fn_return_in_fn_where_clause<T>()\n+    where T: Fn() -> impl Debug\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+{\n+}\n+\n+fn main() {\n+    let _in_local_variable: impl Fn() = || {};\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+    let _in_return_in_local_variable = || -> impl Fn() { || {} };\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+}\n+"}, {"sha": "e4f525a9826100b4f20c038fd16a0e824d49f7b4", "filename": "src/test/run-pass/impl-trait/auxiliary/xcrate.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -10,9 +10,10 @@\n \n #![feature(conservative_impl_trait)]\n \n-pub fn fourway_add(a: i32) -> impl Fn(i32) -> impl Fn(i32) -> impl Fn(i32) -> i32 {\n-    move |b| move |c| move |d| a + b + c + d\n-}\n+// NOTE commented out due to issue #45994\n+//pub fn fourway_add(a: i32) -> impl Fn(i32) -> impl Fn(i32) -> impl Fn(i32) -> i32 {\n+//    move |b| move |c| move |d| a + b + c + d\n+//}\n \n fn some_internal_fn() -> u32 {\n     1"}, {"sha": "0b612c2d3ff340dc1e4042e28c1e82addd0f75a9", "filename": "src/test/run-pass/impl-trait/example-calendar.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016-2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(conservative_impl_trait, fn_traits, step_trait, unboxed_closures)]\n+#![feature(conservative_impl_trait,\n+           universal_impl_trait,\n+           fn_traits,\n+           step_trait,\n+           unboxed_closures\n+)]\n \n //! Derived from: <https://raw.githubusercontent.com/quickfur/dcal/master/dcal.d>.\n //!\n@@ -457,9 +462,9 @@ fn test_group_by() {\n ///\n /// Groups an iterator of dates by month.\n ///\n-fn by_month<It>(it: It)\n-                ->  impl Iterator<Item=(u32, impl Iterator<Item=NaiveDate> + Clone)> + Clone\n-where It: Iterator<Item=NaiveDate> + Clone {\n+fn by_month(it: impl Iterator<Item=NaiveDate> + Clone)\n+           ->  impl Iterator<Item=(u32, impl Iterator<Item=NaiveDate> + Clone)> + Clone\n+{\n     it.group_by(|d| d.month())\n }\n \n@@ -474,9 +479,9 @@ fn test_by_month() {\n ///\n /// Groups an iterator of dates by week.\n ///\n-fn by_week<It>(it: It)\n-               -> impl Iterator<Item=(u32, impl DateIterator)> + Clone\n-where It: DateIterator {\n+fn by_week(it: impl DateIterator)\n+          -> impl Iterator<Item=(u32, impl DateIterator)> + Clone\n+{\n     // We go forward one day because `isoweekdate` considers the week to start on a Monday.\n     it.group_by(|d| d.succ().isoweekdate().1)\n }\n@@ -548,8 +553,7 @@ const COLS_PER_WEEK: u32 = 7 * COLS_PER_DAY;\n ///\n /// Formats an iterator of weeks into an iterator of strings.\n ///\n-fn format_weeks<It>(it: It) -> impl Iterator<Item=String>\n-where It: Iterator, It::Item: DateIterator {\n+fn format_weeks(it: impl Iterator<Item = impl DateIterator>) -> impl Iterator<Item=String> {\n     it.map(|week| {\n         let mut buf = String::with_capacity((COLS_PER_DAY * COLS_PER_WEEK + 2) as usize);\n \n@@ -627,7 +631,7 @@ fn test_month_title() {\n ///\n /// Formats a month.\n ///\n-fn format_month<It: DateIterator>(it: It) -> impl Iterator<Item=String> {\n+fn format_month(it: impl DateIterator) -> impl Iterator<Item=String> {\n     let mut month_days = it.peekable();\n     let title = month_title(month_days.peek().unwrap().month());\n \n@@ -659,8 +663,9 @@ fn test_format_month() {\n ///\n /// Formats an iterator of months.\n ///\n-fn format_months<It>(it: It) -> impl Iterator<Item=impl Iterator<Item=String>>\n-where It: Iterator, It::Item: DateIterator {\n+fn format_months(it: impl Iterator<Item = impl DateIterator>)\n+                -> impl Iterator<Item=impl Iterator<Item=String>>\n+{\n     it.map(format_month)\n }\n "}, {"sha": "48874ef41de552c6cf3a2b9af7ff254c4924f261", "filename": "src/test/run-pass/impl-trait/universal_hrtb_anon.rs", "status": "renamed", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_hrtb_anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_hrtb_anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_hrtb_anon.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(conservative_impl_trait)]\n+#![feature(universal_impl_trait)]\n+\n+fn hrtb(f: impl Fn(&u32) -> u32) -> u32 {\n+    f(&22) + f(&44)\n+}\n \n fn main() {\n-    let _: impl Fn() = || {};\n-    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n-    let _ = || -> impl Fn() { || {} };\n-    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+    let sum = hrtb(|x| x * 2);\n+    assert_eq!(sum, 22*2 + 44*2);\n }", "previous_filename": "src/test/compile-fail/impl-trait/disallowed-2.rs"}, {"sha": "95147a542005ed42f792c38bbd10fe72d86bce5c", "filename": "src/test/run-pass/impl-trait/universal_hrtb_named.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_hrtb_named.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_hrtb_named.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_hrtb_named.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(universal_impl_trait)]\n+\n+fn hrtb(f: impl for<'a> Fn(&'a u32) -> &'a u32) -> u32 {\n+    f(&22) + f(&44)\n+}\n+\n+fn main() {\n+    let sum = hrtb(|x| x);\n+    assert_eq!(sum, 22 + 44);\n+}"}, {"sha": "d0f18575297b2c6eda91e97244437daa01eb8ee5", "filename": "src/test/run-pass/impl-trait/universal_in_adt_in_parameters.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_in_adt_in_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_in_adt_in_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_in_adt_in_parameters.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(universal_impl_trait)]\n+use std::fmt::Display;\n+\n+fn check_display_eq(iter: &Vec<impl Display>) {\n+    let mut collected = String::new();\n+    for it in iter {\n+        let disp = format!(\"{} \", it);\n+        collected.push_str(&disp);\n+    }\n+    assert_eq!(\"0 3 27 823 4891 1 0\", collected.trim());\n+}\n+\n+fn main() {\n+    let i32_list_vec = vec![0i32, 3, 27, 823, 4891, 1, 0];\n+    let u32_list_vec = vec![0u32, 3, 27, 823, 4891, 1, 0];\n+    let str_list_vec = vec![\"0\", \"3\", \"27\", \"823\", \"4891\", \"1\", \"0\"];\n+\n+    check_display_eq(&i32_list_vec);\n+    check_display_eq(&u32_list_vec);\n+    check_display_eq(&str_list_vec);\n+}"}, {"sha": "ccf24b77a6b77bccc062bc1e39a56dfe6fb9cda9", "filename": "src/test/run-pass/impl-trait/universal_in_impl_trait_in_parameters.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_in_impl_trait_in_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_in_impl_trait_in_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_in_impl_trait_in_parameters.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(universal_impl_trait)]\n+use std::fmt::Display;\n+\n+fn check_display_eq(iter: impl IntoIterator<Item = impl Display>) {\n+    let mut collected = String::new();\n+    for it in iter {\n+        let disp = format!(\"{} \", it);\n+        collected.push_str(&disp);\n+    }\n+    assert_eq!(\"0 3 27 823 4891 1 0\", collected.trim());\n+}\n+\n+fn main() {\n+    let i32_list = [0i32, 3, 27, 823, 4891, 1, 0];\n+    let i32_list_vec = vec![0i32, 3, 27, 823, 4891, 1, 0];\n+    let u32_list = [0u32, 3, 27, 823, 4891, 1, 0];\n+    let u32_list_vec = vec![0u32, 3, 27, 823, 4891, 1, 0];\n+    let u16_list = [0u16, 3, 27, 823, 4891, 1, 0];\n+    let str_list = [\"0\", \"3\", \"27\", \"823\", \"4891\", \"1\", \"0\"];\n+    let str_list_vec = vec![\"0\", \"3\", \"27\", \"823\", \"4891\", \"1\", \"0\"];\n+\n+    check_display_eq(&i32_list);\n+    check_display_eq(i32_list_vec);\n+    check_display_eq(&u32_list);\n+    check_display_eq(u32_list_vec);\n+    check_display_eq(&u16_list);\n+    check_display_eq(&str_list);\n+    check_display_eq(str_list_vec);\n+}"}, {"sha": "af0201b5f871eb1418afb6bf224be0f43d255ab5", "filename": "src/test/run-pass/impl-trait/universal_in_trait_defn_parameters.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_in_trait_defn_parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_in_trait_defn_parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_in_trait_defn_parameters.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(universal_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+trait InTraitDefnParameters {\n+    fn in_parameters(_: impl Debug) -> String;\n+}\n+\n+impl InTraitDefnParameters for () {\n+    fn in_parameters(v: impl Debug) -> String {\n+        format!(\"() + {:?}\", v)\n+    }\n+}\n+\n+fn main() {\n+    let s = <() as InTraitDefnParameters>::in_parameters(22);\n+    assert_eq!(s, \"() + 22\");\n+}"}, {"sha": "bb332c0c96cb54e510717d1c0877d1f965a6c9cc", "filename": "src/test/run-pass/impl-trait/universal_multiple_bounds.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_multiple_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_multiple_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Funiversal_multiple_bounds.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(universal_impl_trait)]\n+\n+use std::fmt::Display;\n+\n+fn foo(f: impl Display + Clone) -> String {\n+    let g = f.clone();\n+    format!(\"{} + {}\", f, g)\n+}\n+\n+fn main() {\n+    let sum = foo(format!(\"22\"));\n+    assert_eq!(sum, r\"22 + 22\");\n+}"}, {"sha": "35ae185b3e1de285f751e32da653d6eaaab9522d", "filename": "src/test/run-pass/impl-trait/xcrate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -13,6 +13,7 @@\n extern crate xcrate;\n \n fn main() {\n-    assert_eq!(xcrate::fourway_add(1)(2)(3)(4), 10);\n+//  NOTE line below commeted out due to issue #45994\n+//  assert_eq!(xcrate::fourway_add(1)(2)(3)(4), 10);\n     xcrate::return_closure_accessing_internal_fn()();\n }"}, {"sha": "554c71500cc8b937af82e9517aba1dd418a4bcc6", "filename": "src/test/rustdoc/issue-43869.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frustdoc%2Fissue-43869.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Frustdoc%2Fissue-43869.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-43869.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -55,13 +55,15 @@ pub fn test_44731_1() -> Result<Box<impl Clone>, ()> {\n     Ok(Box::new(j()))\n }\n \n-pub fn test_44731_2() -> Box<Fn(impl Clone)> {\n-    Box::new(|_: u32| {})\n-}\n-\n-pub fn test_44731_3() -> Box<Fn() -> impl Clone> {\n-    Box::new(|| 0u32)\n-}\n+// NOTE these involve Fn sugar, where impl Trait is disallowed for now, see issue #45994\n+//\n+//pub fn test_44731_2() -> Box<Fn(impl Clone)> {\n+//    Box::new(|_: u32| {})\n+//}\n+//\n+//pub fn test_44731_3() -> Box<Fn() -> impl Clone> {\n+//    Box::new(|| 0u32)\n+//}\n \n pub fn test_44731_4() -> Box<Iterator<Item=impl Clone>> {\n     Box::new(g())\n@@ -78,6 +80,4 @@ pub fn test_44731_4() -> Box<Iterator<Item=impl Clone>> {\n // @has issue_43869/fn.o.html\n // @has issue_43869/fn.test_44731_0.html\n // @has issue_43869/fn.test_44731_1.html\n-// @has issue_43869/fn.test_44731_2.html\n-// @has issue_43869/fn.test_44731_3.html\n // @has issue_43869/fn.test_44731_4.html"}, {"sha": "af7adc4c657d9f2478f6b64360959a8522e5e568", "filename": "src/test/ui/impl-trait/universal-mismatched-type.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal-mismatched-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal-mismatched-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal-mismatched-type.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(universal_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+fn foo(x: impl Debug) -> String {\n+    x\n+}\n+\n+fn main() { }"}, {"sha": "2be245844976804dc7e4d2e18e395a6e1475c9e2", "filename": "src/test/ui/impl-trait/universal-mismatched-type.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal-mismatched-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal-mismatched-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal-mismatched-type.stderr?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,13 @@\n+error[E0308]: mismatched types\n+  --> $DIR/universal-mismatched-type.rs:16:5\n+   |\n+15 | fn foo(x: impl Debug) -> String {\n+   |                          ------ expected `std::string::String` because of return type\n+16 |     x\n+   |     ^ expected struct `std::string::String`, found type parameter\n+   |\n+   = note: expected type `std::string::String`\n+              found type `impl Debug`\n+\n+error: aborting due to previous error\n+"}, {"sha": "f8855a7975550eae8dbcecbb78f73f3c746e64f4", "filename": "src/test/ui/impl-trait/universal-two-impl-traits.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal-two-impl-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal-two-impl-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal-two-impl-traits.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(universal_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+fn foo(x: impl Debug, y: impl Debug) -> String {\n+    let mut a = x;\n+    a = y;\n+    format!(\"{:?}\", a)\n+}\n+\n+fn main() { }"}, {"sha": "c663d38ca8a484d98782380d672f1a818d0badd8", "filename": "src/test/ui/impl-trait/universal-two-impl-traits.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal-two-impl-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal-two-impl-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal-two-impl-traits.stderr?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/universal-two-impl-traits.rs:17:9\n+   |\n+17 |     a = y;\n+   |         ^ expected type parameter, found a different type parameter\n+   |\n+   = note: expected type `impl Debug` (type parameter)\n+              found type `impl Debug` (type parameter)\n+\n+error: aborting due to previous error\n+"}, {"sha": "fd35d04b25861f700c826e135e4fcf48a123b25e", "filename": "src/test/ui/impl-trait/universal_wrong_bounds.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.rs?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(universal_impl_trait)]\n+\n+use std::fmt::Display;\n+\n+fn foo(f: impl Display + Clone) -> String {\n+    wants_debug(f);\n+    wants_display(f);\n+    wants_clone(f);\n+}\n+\n+fn wants_debug(g: impl Debug) { }\n+fn wants_display(g: impl Debug) { }\n+fn wants_cone(g: impl Clone) { }\n+\n+fn main() {\n+}"}, {"sha": "5e7788812e63c50b177f25ec5ba6f3637af2f412", "filename": "src/test/ui/impl-trait/universal_wrong_bounds.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.stderr?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -0,0 +1,30 @@\n+error[E0425]: cannot find function `wants_clone` in this scope\n+  --> $DIR/universal_wrong_bounds.rs:18:5\n+   |\n+18 |     wants_clone(f);\n+   |     ^^^^^^^^^^^ did you mean `wants_cone`?\n+\n+error[E0405]: cannot find trait `Debug` in this scope\n+  --> $DIR/universal_wrong_bounds.rs:21:24\n+   |\n+21 | fn wants_debug(g: impl Debug) { }\n+   |                        ^^^^^ not found in this scope\n+   |\n+help: possible candidate is found in another module, you can import it into scope\n+   |\n+13 | use std::fmt::Debug;\n+   |\n+\n+error[E0405]: cannot find trait `Debug` in this scope\n+  --> $DIR/universal_wrong_bounds.rs:22:26\n+   |\n+22 | fn wants_display(g: impl Debug) { }\n+   |                          ^^^^^ not found in this scope\n+   |\n+help: possible candidate is found in another module, you can import it into scope\n+   |\n+13 | use std::fmt::Debug;\n+   |\n+\n+error: cannot continue compilation due to previous error\n+"}, {"sha": "08640b292eabc4e40b96bf388f55838fc2cdbc13", "filename": "src/test/ui/resolve/use_suggestion_placement.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion_placement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion_placement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion_placement.stderr?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -33,17 +33,5 @@ help: possible candidates are found in other modules, you can import them into s\n 11 | use std::collections::hash_map::HashMap;\n    |\n \n-error[E0091]: type parameter `K` is unused\n-  --> $DIR/use_suggestion_placement.rs:35:15\n-   |\n-35 |     type Dict<K, V> = HashMap<K, V>;\n-   |               ^ unused type parameter\n-\n-error[E0091]: type parameter `V` is unused\n-  --> $DIR/use_suggestion_placement.rs:35:18\n-   |\n-35 |     type Dict<K, V> = HashMap<K, V>;\n-   |                  ^ unused type parameter\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "f1684f4c5acbe42f5f8eb94ba87a3408b9bd5bc9", "filename": "src/tools/toolstate.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftools%2Ftoolstate.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4/src%2Ftools%2Ftoolstate.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftoolstate.toml?ref=b8c70b0fdf7dea9bfd1834e61d32fc40f0c70db4", "patch": "@@ -26,7 +26,7 @@\n miri = \"Broken\"\n \n # ping @Manishearth @llogiq @mcarton @oli-obk\n-clippy = \"Testing\"\n+clippy = \"Broken\"\n \n # ping @nrc\n rls = \"Testing\""}]}