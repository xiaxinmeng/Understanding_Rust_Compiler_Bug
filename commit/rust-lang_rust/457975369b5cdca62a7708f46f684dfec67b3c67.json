{"sha": "457975369b5cdca62a7708f46f684dfec67b3c67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1Nzk3NTM2OWI1Y2RjYTYyYTc3MDhmNDZmNjg0ZGZlYzY3YjNjNjc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-03-08T19:26:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-08T19:26:02Z"}, "message": "Rollup merge of #48808 - Zoxc:reg-diag, r=michaelwoerister\n\nMove REGISTERED_DIAGNOSTICS to a ParseSess field\n\nr? @michaelwoerister", "tree": {"sha": "526c8b74176fe716194e4f5c420ca3b8e08e4fcc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/526c8b74176fe716194e4f5c420ca3b8e08e4fcc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/457975369b5cdca62a7708f46f684dfec67b3c67", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaoY5KCRBK7hj4Ov3rIwAAdHIIAESyKAfQka94Fl9/cdo0h9Zv\ngXZ5ulyUnldzi9q0r1mSV1Ml6PS6gWPactSIVuRZJyXQ5X2iSK9LOHZujZEqFkJp\na4///QUpC40+8wraXFuBdphdc8AHFAmDluokipKRxTfcM7D8dIQ7hNjO6rDETAl1\nTTcjayLFDstEgnMTfHNo+MKpuSpAK8UCmQUYvRGFKnOSlyKGCePKWq1GRvTzCJSm\nlsW0xvf95C6IB3CSYCSJiCGiwdmPCNjb6mWcb0XaxflOdFSHYQXlYiFl6yI0XrfT\nv7Gb15vCBepR/vRy7PQeneTYKjoX2wXt6sZEs/QY0tlEZvKI6H8uWjq3PgMgWyo=\n=BFNh\n-----END PGP SIGNATURE-----\n", "payload": "tree 526c8b74176fe716194e4f5c420ca3b8e08e4fcc\nparent d17eb8f68edd459ddd4cc3a9d92125f9e6e9df46\nparent 728c16c88f8db0c914cecc8b20b7f851d936fd5a\nauthor Manish Goregaokar <manishsmail@gmail.com> 1520537162 -0800\ncommitter GitHub <noreply@github.com> 1520537162 -0800\n\nRollup merge of #48808 - Zoxc:reg-diag, r=michaelwoerister\n\nMove REGISTERED_DIAGNOSTICS to a ParseSess field\n\nr? @michaelwoerister\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/457975369b5cdca62a7708f46f684dfec67b3c67", "html_url": "https://github.com/rust-lang/rust/commit/457975369b5cdca62a7708f46f684dfec67b3c67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/457975369b5cdca62a7708f46f684dfec67b3c67/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d17eb8f68edd459ddd4cc3a9d92125f9e6e9df46", "url": "https://api.github.com/repos/rust-lang/rust/commits/d17eb8f68edd459ddd4cc3a9d92125f9e6e9df46", "html_url": "https://github.com/rust-lang/rust/commit/d17eb8f68edd459ddd4cc3a9d92125f9e6e9df46"}, {"sha": "728c16c88f8db0c914cecc8b20b7f851d936fd5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/728c16c88f8db0c914cecc8b20b7f851d936fd5a", "html_url": "https://github.com/rust-lang/rust/commit/728c16c88f8db0c914cecc8b20b7f851d936fd5a"}], "stats": {"total": 158, "additions": 99, "deletions": 59}, "files": [{"sha": "d7cd459e5771c2fb8df45c0e3c5687234c492496", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 87, "deletions": 39, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/457975369b5cdca62a7708f46f684dfec67b3c67/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457975369b5cdca62a7708f46f684dfec67b3c67/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=457975369b5cdca62a7708f46f684dfec67b3c67", "patch": "@@ -62,7 +62,7 @@ cfg_if! {\n         pub use std::cell::RefMut as WriteGuard;\n         pub use std::cell::RefMut as LockGuard;\n \n-        pub use std::cell::RefCell as RwLock;\n+        use std::cell::RefCell as InnerRwLock;\n         use std::cell::RefCell as InnerLock;\n \n         use std::cell::Cell;\n@@ -159,13 +159,12 @@ cfg_if! {\n \n         pub use parking_lot::MutexGuard as LockGuard;\n \n-        use parking_lot;\n-\n         pub use std::sync::Arc as Lrc;\n \n         pub use self::Lock as MTLock;\n \n         use parking_lot::Mutex as InnerLock;\n+        use parking_lot::RwLock as InnerRwLock;\n \n         pub type MetadataRef = OwningRef<Box<Erased + Send + Sync>, [u8]>;\n \n@@ -222,42 +221,6 @@ cfg_if! {\n                 self.0.lock().take()\n             }\n         }\n-\n-        #[derive(Debug)]\n-        pub struct RwLock<T>(parking_lot::RwLock<T>);\n-\n-        impl<T> RwLock<T> {\n-            #[inline(always)]\n-            pub fn new(inner: T) -> Self {\n-                RwLock(parking_lot::RwLock::new(inner))\n-            }\n-\n-            #[inline(always)]\n-            pub fn borrow(&self) -> ReadGuard<T> {\n-                if ERROR_CHECKING {\n-                    self.0.try_read().expect(\"lock was already held\")\n-                } else {\n-                    self.0.read()\n-                }\n-            }\n-\n-            #[inline(always)]\n-            pub fn borrow_mut(&self) -> WriteGuard<T> {\n-                if ERROR_CHECKING {\n-                    self.0.try_write().expect(\"lock was already held\")\n-                } else {\n-                    self.0.write()\n-                }\n-            }\n-        }\n-\n-        // FIXME: Probably a bad idea\n-        impl<T: Clone> Clone for RwLock<T> {\n-            #[inline]\n-            fn clone(&self) -> Self {\n-                RwLock::new(self.borrow().clone())\n-            }\n-        }\n     }\n }\n \n@@ -384,6 +347,11 @@ impl<T> Lock<T> {\n         self.0.borrow_mut()\n     }\n \n+    #[inline(always)]\n+    pub fn with_lock<F: FnOnce(&mut T) -> R, R>(&self, f: F) -> R {\n+        f(&mut *self.lock())\n+    }\n+\n     #[inline(always)]\n     pub fn borrow(&self) -> LockGuard<T> {\n         self.lock()\n@@ -402,3 +370,83 @@ impl<T: Clone> Clone for Lock<T> {\n         Lock::new(self.borrow().clone())\n     }\n }\n+\n+#[derive(Debug)]\n+pub struct RwLock<T>(InnerRwLock<T>);\n+\n+impl<T> RwLock<T> {\n+    #[inline(always)]\n+    pub fn new(inner: T) -> Self {\n+        RwLock(InnerRwLock::new(inner))\n+    }\n+\n+    #[inline(always)]\n+    pub fn into_inner(self) -> T {\n+        self.0.into_inner()\n+    }\n+\n+    #[inline(always)]\n+    pub fn get_mut(&mut self) -> &mut T {\n+        self.0.get_mut()\n+    }\n+\n+    #[cfg(not(parallel_queries))]\n+    #[inline(always)]\n+    pub fn read(&self) -> ReadGuard<T> {\n+        self.0.borrow()\n+    }\n+\n+    #[cfg(parallel_queries)]\n+    #[inline(always)]\n+    pub fn read(&self) -> ReadGuard<T> {\n+        if ERROR_CHECKING {\n+            self.0.try_read().expect(\"lock was already held\")\n+        } else {\n+            self.0.read()\n+        }\n+    }\n+\n+    #[inline(always)]\n+    pub fn with_read_lock<F: FnOnce(&T) -> R, R>(&self, f: F) -> R {\n+        f(&*self.read())\n+    }\n+\n+    #[cfg(not(parallel_queries))]\n+    #[inline(always)]\n+    pub fn write(&self) -> WriteGuard<T> {\n+        self.0.borrow_mut()\n+    }\n+\n+    #[cfg(parallel_queries)]\n+    #[inline(always)]\n+    pub fn write(&self) -> WriteGuard<T> {\n+        if ERROR_CHECKING {\n+            self.0.try_write().expect(\"lock was already held\")\n+        } else {\n+            self.0.write()\n+        }\n+    }\n+\n+    #[inline(always)]\n+    pub fn with_write_lock<F: FnOnce(&mut T) -> R, R>(&self, f: F) -> R {\n+        f(&mut *self.write())\n+    }\n+\n+    #[inline(always)]\n+    pub fn borrow(&self) -> ReadGuard<T> {\n+        self.read()\n+    }\n+\n+    #[inline(always)]\n+    pub fn borrow_mut(&self) -> WriteGuard<T> {\n+        self.write()\n+    }\n+}\n+\n+// FIXME: Probably a bad idea\n+impl<T: Clone> Clone for RwLock<T> {\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        RwLock::new(self.borrow().clone())\n+    }\n+}"}, {"sha": "e8c2d325bd653d30d1014955d96d345ccf73cd93", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/457975369b5cdca62a7708f46f684dfec67b3c67/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457975369b5cdca62a7708f46f684dfec67b3c67/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=457975369b5cdca62a7708f46f684dfec67b3c67", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::RefCell;\n use std::collections::BTreeMap;\n use std::env;\n \n@@ -31,12 +30,6 @@ pub use errors::*;\n // Maximum width of any line in an extended error description (inclusive).\n const MAX_DESCRIPTION_WIDTH: usize = 80;\n \n-thread_local! {\n-    static REGISTERED_DIAGNOSTICS: RefCell<ErrorMap> = {\n-        RefCell::new(BTreeMap::new())\n-    }\n-}\n-\n /// Error information type.\n pub struct ErrorInfo {\n     pub description: Option<Name>,\n@@ -46,14 +39,6 @@ pub struct ErrorInfo {\n /// Mapping from error codes to metadata.\n pub type ErrorMap = BTreeMap<Name, ErrorInfo>;\n \n-fn with_registered_diagnostics<T, F>(f: F) -> T where\n-    F: FnOnce(&mut ErrorMap) -> T,\n-{\n-    REGISTERED_DIAGNOSTICS.with(move |slot| {\n-        f(&mut *slot.borrow_mut())\n-    })\n-}\n-\n pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n                                    span: Span,\n                                    token_tree: &[TokenTree])\n@@ -63,7 +48,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n         _ => unreachable!()\n     };\n \n-    with_registered_diagnostics(|diagnostics| {\n+    ecx.parse_sess.registered_diagnostics.with_lock(|diagnostics| {\n         match diagnostics.get_mut(&code.name) {\n             // Previously used errors.\n             Some(&mut ErrorInfo { description: _, use_site: Some(previous_span) }) => {\n@@ -132,7 +117,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n         }\n     });\n     // Add the error to the map.\n-    with_registered_diagnostics(|diagnostics| {\n+    ecx.parse_sess.registered_diagnostics.with_lock(|diagnostics| {\n         let info = ErrorInfo {\n             description,\n             use_site: None\n@@ -174,7 +159,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n \n     // Output error metadata to `tmp/extended-errors/<target arch>/<crate name>.json`\n     if let Ok(target_triple) = env::var(\"CFG_COMPILER_HOST_TRIPLE\") {\n-        with_registered_diagnostics(|diagnostics| {\n+        ecx.parse_sess.registered_diagnostics.with_lock(|diagnostics| {\n             if let Err(e) = output_metadata(ecx,\n                                             &target_triple,\n                                             &crate_name.name.as_str(),\n@@ -194,7 +179,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n \n     // Construct the output expression.\n     let (count, expr) =\n-        with_registered_diagnostics(|diagnostics| {\n+        ecx.parse_sess.registered_diagnostics.with_lock(|diagnostics| {\n             let descriptions: Vec<P<ast::Expr>> =\n                 diagnostics.iter().filter_map(|(&code, info)| {\n                     info.description.map(|description| {"}, {"sha": "cdf38453d7ea47e964818f8015d4639c18f000a6", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/457975369b5cdca62a7708f46f684dfec67b3c67/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457975369b5cdca62a7708f46f684dfec67b3c67/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=457975369b5cdca62a7708f46f684dfec67b3c67", "patch": "@@ -1764,6 +1764,8 @@ mod tests {\n     use std::collections::HashSet;\n     use std::io;\n     use std::path::PathBuf;\n+    use diagnostics::plugin::ErrorMap;\n+    use rustc_data_structures::sync::Lock;\n     fn mk_sess(cm: Lrc<CodeMap>) -> ParseSess {\n         let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n                                                           Some(cm.clone()),\n@@ -1776,6 +1778,7 @@ mod tests {\n             included_mod_stack: RefCell::new(Vec::new()),\n             code_map: cm,\n             missing_fragment_specifiers: RefCell::new(HashSet::new()),\n+            registered_diagnostics: Lock::new(ErrorMap::new()),\n             non_modrs_mods: RefCell::new(vec![]),\n         }\n     }"}, {"sha": "3fb0c209f70f4ea339e5bbfabeeffb5e62ddec94", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/457975369b5cdca62a7708f46f684dfec67b3c67/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/457975369b5cdca62a7708f46f684dfec67b3c67/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=457975369b5cdca62a7708f46f684dfec67b3c67", "patch": "@@ -10,7 +10,7 @@\n \n //! The main parser interface\n \n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, Lock};\n use ast::{self, CrateConfig};\n use codemap::{CodeMap, FilePathMapping};\n use syntax_pos::{self, Span, FileMap, NO_EXPANSION, FileName};\n@@ -21,6 +21,7 @@ use ptr::P;\n use str::char_at;\n use symbol::Symbol;\n use tokenstream::{TokenStream, TokenTree};\n+use diagnostics::plugin::ErrorMap;\n \n use std::cell::RefCell;\n use std::collections::HashSet;\n@@ -47,6 +48,8 @@ pub struct ParseSess {\n     pub unstable_features: UnstableFeatures,\n     pub config: CrateConfig,\n     pub missing_fragment_specifiers: RefCell<HashSet<Span>>,\n+    /// The registered diagnostics codes\n+    pub registered_diagnostics: Lock<ErrorMap>,\n     // Spans where a `mod foo;` statement was included in a non-mod.rs file.\n     // These are used to issue errors if the non_modrs_mods feature is not enabled.\n     pub non_modrs_mods: RefCell<Vec<(ast::Ident, Span)>>,\n@@ -71,6 +74,7 @@ impl ParseSess {\n             unstable_features: UnstableFeatures::from_environment(),\n             config: HashSet::new(),\n             missing_fragment_specifiers: RefCell::new(HashSet::new()),\n+            registered_diagnostics: Lock::new(ErrorMap::new()),\n             included_mod_stack: RefCell::new(vec![]),\n             code_map,\n             non_modrs_mods: RefCell::new(vec![]),"}]}