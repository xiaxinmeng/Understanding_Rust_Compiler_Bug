{"sha": "8216f3c0f35aa948fe96d0eed17b0e5855799bd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMTZmM2MwZjM1YWE5NDhmZTk2ZDBlZWQxN2IwZTU4NTU3OTliZDQ=", "commit": {"author": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-16T22:59:54Z"}, "committer": {"name": "David Cook", "email": "divergentdave@gmail.com", "date": "2020-02-18T04:24:33Z"}, "message": "Back out placeholder variants from FileHandle", "tree": {"sha": "9c26a67689d5298c2466aa4d53ccbe7700b356a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c26a67689d5298c2466aa4d53ccbe7700b356a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8216f3c0f35aa948fe96d0eed17b0e5855799bd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8216f3c0f35aa948fe96d0eed17b0e5855799bd4", "html_url": "https://github.com/rust-lang/rust/commit/8216f3c0f35aa948fe96d0eed17b0e5855799bd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8216f3c0f35aa948fe96d0eed17b0e5855799bd4/comments", "author": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "committer": {"login": "divergentdave", "id": 181772, "node_id": "MDQ6VXNlcjE4MTc3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/181772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/divergentdave", "html_url": "https://github.com/divergentdave", "followers_url": "https://api.github.com/users/divergentdave/followers", "following_url": "https://api.github.com/users/divergentdave/following{/other_user}", "gists_url": "https://api.github.com/users/divergentdave/gists{/gist_id}", "starred_url": "https://api.github.com/users/divergentdave/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/divergentdave/subscriptions", "organizations_url": "https://api.github.com/users/divergentdave/orgs", "repos_url": "https://api.github.com/users/divergentdave/repos", "events_url": "https://api.github.com/users/divergentdave/events{/privacy}", "received_events_url": "https://api.github.com/users/divergentdave/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6a8f09f1e411cc1c3edbcabb7801db8d4dadc4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6a8f09f1e411cc1c3edbcabb7801db8d4dadc4f", "html_url": "https://github.com/rust-lang/rust/commit/a6a8f09f1e411cc1c3edbcabb7801db8d4dadc4f"}], "stats": {"total": 49, "additions": 16, "deletions": 33}, "files": [{"sha": "a3c45101a0b705388f4fcf545d7482da668532fb", "filename": "src/shims/fs.rs", "status": "modified", "additions": 16, "deletions": 33, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8216f3c0f35aa948fe96d0eed17b0e5855799bd4/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216f3c0f35aa948fe96d0eed17b0e5855799bd4/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=8216f3c0f35aa948fe96d0eed17b0e5855799bd4", "patch": "@@ -13,15 +13,12 @@ use helpers::immty_from_uint_checked;\n use shims::time::system_time_to_duration;\n \n #[derive(Debug)]\n-pub enum FileHandle {\n-    StdInPlaceholder,\n-    StdOutPlaceholder,\n-    StdErrPlaceholder,\n-    File { file: File, writable: bool },\n-    // In the future, could add support for dirfd() and other functions by\n-    // adding a Directory variant here\n+pub struct FileHandle {\n+    file: File,\n+    writable: bool,\n }\n \n+#[derive(Debug, Default)]\n pub struct FileHandler {\n     handles: BTreeMap<i32, FileHandle>,\n }\n@@ -63,17 +60,6 @@ impl FileHandler {\n     }\n }\n \n-impl Default for FileHandler {\n-    fn default() -> Self {\n-        let mut handles: BTreeMap<i32, FileHandle> = Default::default();\n-        // 0, 1 and 2 are reserved for stdin, stdout and stderr.\n-        handles.insert(0, FileHandle::StdInPlaceholder);\n-        handles.insert(1, FileHandle::StdOutPlaceholder);\n-        handles.insert(2, FileHandle::StdErrPlaceholder);\n-        FileHandler { handles }\n-    }\n-}\n-\n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn open(\n@@ -149,7 +135,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = options.open(&path).map(|file| {\n             let fh = &mut this.machine.file_handler;\n-            fh.insert_fd(FileHandle::File { file, writable })\n+            fh.insert_fd(FileHandle { file, writable })\n         });\n \n         this.try_unwrap_io_result(fd)\n@@ -185,6 +171,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // because exec() isn't supported. The F_DUPFD and F_DUPFD_CLOEXEC commands only\n             // differ in whether the FD_CLOEXEC flag is pre-set on the new file descriptor,\n             // thus they can share the same implementation here.\n+            if fd <= 2 {\n+                throw_unsup_format!(\"Duplicating file descriptors for stdin, stdout, or stderr is not supported\")\n+            }\n             let start_op = start_op.ok_or_else(|| {\n                 err_unsup_format!(\n                     \"fcntl with command F_DUPFD or F_DUPFD_CLOEXEC requires a third argument\"\n@@ -193,12 +182,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             let start = this.read_scalar(start_op)?.to_i32()?;\n             let fh = &mut this.machine.file_handler;\n             let (file_result, writable) = match fh.handles.get(&fd) {\n-                Some(FileHandle::File { file, writable }) => (file.try_clone(), *writable),\n-                Some(_) => throw_unsup_format!(\"Duplicating file descriptors for stdin, stdout, or stderr is not supported\"),\n+                Some(FileHandle { file, writable }) => (file.try_clone(), *writable),\n                 None => return this.handle_not_found(),\n             };\n             let fd_result = file_result.map(|duplicated| {\n-                fh.insert_fd_with_min_fd(FileHandle::File { file: duplicated, writable }, start)\n+                fh.insert_fd_with_min_fd(FileHandle { file: duplicated, writable }, start)\n             });\n             this.try_unwrap_io_result(fd_result)\n         } else {\n@@ -213,12 +201,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n \n-        if fd <= 2 {\n-            // early return to prevent removing StdInPlaceholder, etc., from the handles map\n-            return this.handle_not_found();\n-        }\n-\n-        if let Some(FileHandle::File { file, writable }) = this.machine.file_handler.handles.remove(&fd) {\n+        if let Some(FileHandle { file, writable }) = this.machine.file_handler.handles.remove(&fd) {\n             // We sync the file if it was opened in a mode different than read-only.\n             if writable {\n                 // `File::sync_all` does the checks that are done when closing a file. We do this to\n@@ -267,7 +250,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n         let count = count.min(this.isize_max() as u64).min(isize::max_value() as u64);\n \n-        if let Some(FileHandle::File { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n+        if let Some(FileHandle { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n             // This can never fail because `count` was capped to be smaller than\n             // `isize::max_value()`.\n             let count = isize::try_from(count).unwrap();\n@@ -321,7 +304,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // host's and target's `isize`. This saves us from having to handle overflows later.\n         let count = count.min(this.isize_max() as u64).min(isize::max_value() as u64);\n \n-        if let Some(FileHandle::File { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n+        if let Some(FileHandle { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n             let bytes = this.memory.read_bytes(buf, Size::from_bytes(count))?;\n             let result = file.write(&bytes).map(|c| i64::try_from(c).unwrap());\n             this.try_unwrap_io_result(result)\n@@ -356,7 +339,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return Ok(-1);\n         };\n \n-        if let Some(FileHandle::File { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n+        if let Some(FileHandle { file, writable: _ }) = this.machine.file_handler.handles.get_mut(&fd) {\n             let result = file.seek(seek_from).map(|offset| offset as i64);\n             this.try_unwrap_io_result(result)\n         } else {\n@@ -719,8 +702,8 @@ impl FileMetadata {\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n         let option = ecx.machine.file_handler.handles.get(&fd);\n         let file = match option {\n-            Some(FileHandle::File { file, writable: _ }) => file,\n-            Some(_) | None => return ecx.handle_not_found().map(|_: i32| None),\n+            Some(FileHandle { file, writable: _ }) => file,\n+            None => return ecx.handle_not_found().map(|_: i32| None),\n         };\n         let metadata = file.metadata();\n "}]}