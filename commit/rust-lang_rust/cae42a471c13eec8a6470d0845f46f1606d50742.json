{"sha": "cae42a471c13eec8a6470d0845f46f1606d50742", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZTQyYTQ3MWMxM2VlYzhhNjQ3MGQwODQ1ZjQ2ZjE2MDZkNTA3NDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-08T14:04:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-08T14:04:17Z"}, "message": "Auto merge of #33494 - Manishearth:rollup, r=Manishearth\n\nRollup of 8 pull requests\n\n- Successful merges: #33369, #33373, #33404, #33406, #33420, #33424, #33426, #33473\n- Failed merges:", "tree": {"sha": "faffb306c666f3e4ff851eca16ea5baf85dcdea9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faffb306c666f3e4ff851eca16ea5baf85dcdea9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cae42a471c13eec8a6470d0845f46f1606d50742", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cae42a471c13eec8a6470d0845f46f1606d50742", "html_url": "https://github.com/rust-lang/rust/commit/cae42a471c13eec8a6470d0845f46f1606d50742", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cae42a471c13eec8a6470d0845f46f1606d50742/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e414e0e3f27d1917d11ee80de827698beb53891", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e414e0e3f27d1917d11ee80de827698beb53891", "html_url": "https://github.com/rust-lang/rust/commit/8e414e0e3f27d1917d11ee80de827698beb53891"}, {"sha": "cc98f4cbb09d0165dcca18664d1fe10cb39a5dfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc98f4cbb09d0165dcca18664d1fe10cb39a5dfa", "html_url": "https://github.com/rust-lang/rust/commit/cc98f4cbb09d0165dcca18664d1fe10cb39a5dfa"}], "stats": {"total": 828, "additions": 629, "deletions": 199}, "files": [{"sha": "9491311ea7c129afd1ddd3e69f3e8b63a65ba4c6", "filename": "mk/dist.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -77,6 +77,7 @@ $(PKG_TAR): $(PKG_FILES)\n \t$(Q)mkdir -p tmp/dist/$(PKG_NAME)\n \t$(Q)tar \\\n          -C $(S) \\\n+         -f - \\\n          --exclude-vcs \\\n          --exclude=*~ \\\n          --exclude=*.pyc \\\n@@ -86,7 +87,7 @@ $(PKG_TAR): $(PKG_FILES)\n          --exclude=*/llvm/test/*/*/*.ll \\\n          --exclude=*/llvm/test/*/*/*.td \\\n          --exclude=*/llvm/test/*/*/*.s \\\n-         -c $(UNROOTED_PKG_FILES) | tar -x -C tmp/dist/$(PKG_NAME)\n+         -c $(UNROOTED_PKG_FILES) | tar -x -f - -C tmp/dist/$(PKG_NAME)\n \t@$(call E, making $@)\n \t$(Q)tar -czf $(PKG_TAR) -C tmp/dist $(PKG_NAME)\n \t$(Q)rm -Rf tmp/dist/$(PKG_NAME)"}, {"sha": "e8ea993c6940a33c9caa0ae37c01bf82fa9c0f8d", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -49,6 +49,11 @@ use marker::Sized;\n /// A common trait for cloning an object.\n ///\n /// This trait can be used with `#[derive]`.\n+///\n+/// Types that are `Copy` should have a trivial implementation of `Clone`. More formally:\n+/// if `T: Copy`, `x: T`, and `y: &T`, then `let x = y.clone();` is equivalent to `let x = *y;`.\n+/// Manual implementations should be careful to uphold this invariant; however, unsafe code\n+/// must not rely on it to ensure memory safety.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Clone : Sized {\n     /// Returns a copy of the value."}, {"sha": "48421abc7bbdf7e4a2793debd028a0959a95151b", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -20,18 +20,19 @@\n //! - Impl the `As*` traits for reference-to-reference conversions\n //! - Impl the `Into` trait when you want to consume the value in the conversion\n //! - The `From` trait is the most flexible, useful for value _and_ reference conversions\n+//! - The `TryFrom` and `TryInto` traits behave like `From` and `Into`, but allow for the\n+//!   conversion to fail\n //!\n-//! As a library author, you should prefer implementing `From<T>` rather than\n-//! `Into<U>`, as `From` provides greater flexibility and offers an equivalent `Into`\n-//! implementation for free, thanks to a blanket implementation in the standard library.\n-//!\n-//! **Note: these traits must not fail**. If the conversion can fail, you must use a dedicated\n-//! method which returns an `Option<T>` or a `Result<T, E>`.\n+//! As a library author, you should prefer implementing `From<T>` or `TryFrom<T>` rather than\n+//! `Into<U>` or `TryInto<U>`, as `From` and `TryFrom` provide greater flexibility and offer\n+//! equivalent `Into` or `TryInto` implementations for free, thanks to a blanket implementation\n+//! in the standard library.\n //!\n //! # Generic impl\n //!\n //! - `AsRef` and `AsMut` auto-dereference if the inner type is a reference\n //! - `From<U> for T` implies `Into<T> for U`\n+//! - `TryFrom<U> for T` implies `TryInto<T> for U`\n //! - `From` and `Into` are reflexive, which means that all types can `into()`\n //!   themselves and `from()` themselves\n //!\n@@ -40,6 +41,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use marker::Sized;\n+use result::Result;\n \n /// A cheap, reference-to-reference conversion.\n ///\n@@ -98,8 +100,8 @@ pub trait AsMut<T: ?Sized> {\n \n /// A conversion that consumes `self`, which may or may not be expensive.\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use a dedicated method which\n-/// returns an `Option<T>` or a `Result<T, E>`.\n+/// **Note: this trait must not fail**. If the conversion can fail, use `TryInto` or a dedicated\n+/// method which returns an `Option<T>` or a `Result<T, E>`.\n ///\n /// Library authors should not directly implement this trait, but should prefer implementing\n /// the `From` trait, which offers greater flexibility and provides an equivalent `Into`\n@@ -133,8 +135,8 @@ pub trait Into<T>: Sized {\n \n /// Construct `Self` via a conversion.\n ///\n-/// **Note: this trait must not fail**. If the conversion can fail, use a dedicated method which\n-/// returns an `Option<T>` or a `Result<T, E>`.\n+/// **Note: this trait must not fail**. If the conversion can fail, use `TryFrom` or a dedicated\n+/// method which returns an `Option<T>` or a `Result<T, E>`.\n ///\n /// # Examples\n ///\n@@ -158,6 +160,30 @@ pub trait From<T>: Sized {\n     fn from(T) -> Self;\n }\n \n+/// An attempted conversion that consumes `self`, which may or may not be expensive.\n+///\n+/// Library authors should not directly implement this trait, but should prefer implementing\n+/// the `TryFrom` trait, which offers greater flexibility and provides an equivalent `TryInto`\n+/// implementation for free, thanks to a blanket implementation in the standard library.\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+pub trait TryInto<T>: Sized {\n+    /// The type returned in the event of a conversion error.\n+    type Err;\n+\n+    /// Performs the conversion.\n+    fn try_into(self) -> Result<T, Self::Err>;\n+}\n+\n+/// Attempt to construct `Self` via a conversion.\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+pub trait TryFrom<T>: Sized {\n+    /// The type returned in the event of a conversion error.\n+    type Err;\n+\n+    /// Performs the conversion.\n+    fn try_from(T) -> Result<Self, Self::Err>;\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // GENERIC IMPLS\n ////////////////////////////////////////////////////////////////////////////////\n@@ -216,6 +242,17 @@ impl<T> From<T> for T {\n     fn from(t: T) -> T { t }\n }\n \n+\n+// TryFrom implies TryInto\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl<T, U> TryInto<U> for T where U: TryFrom<T> {\n+    type Err = U::Err;\n+\n+    fn try_into(self) -> Result<U, U::Err> {\n+        U::try_from(self)\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // CONCRETE IMPLS\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "9b6f6698defe4513e636ac4a47c02b750bdd2d09", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 94, "deletions": 1, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -15,7 +15,7 @@\n \n use char::CharExt;\n use cmp::PartialOrd;\n-use convert::From;\n+use convert::{From, TryFrom};\n use fmt;\n use intrinsics;\n use marker::{Copy, Sized};\n@@ -2352,9 +2352,101 @@ macro_rules! from_str_radix_int_impl {\n }\n from_str_radix_int_impl! { isize i8 i16 i32 i64 usize u8 u16 u32 u64 }\n \n+/// The error type returned when a checked integral type conversion fails.\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+#[derive(Debug, Copy, Clone)]\n+pub struct TryFromIntError(());\n+\n+impl TryFromIntError {\n+    #[unstable(feature = \"int_error_internals\",\n+               reason = \"available through Error trait and this method should \\\n+                         not be exposed publicly\",\n+               issue = \"0\")]\n+    #[doc(hidden)]\n+    pub fn __description(&self) -> &str {\n+        \"out of range integral type conversion attempted\"\n+    }\n+}\n+\n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl fmt::Display for TryFromIntError {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        self.__description().fmt(fmt)\n+    }\n+}\n+\n+macro_rules! same_sign_from_int_impl {\n+    ($storage:ty, $target:ty, $($source:ty),*) => {$(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl TryFrom<$source> for $target {\n+            type Err = TryFromIntError;\n+\n+            fn try_from(u: $source) -> Result<$target, TryFromIntError> {\n+                let min = <$target as FromStrRadixHelper>::min_value() as $storage;\n+                let max = <$target as FromStrRadixHelper>::max_value() as $storage;\n+                if u as $storage < min || u as $storage > max {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $target)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+same_sign_from_int_impl!(u64, u8, u8, u16, u32, u64, usize);\n+same_sign_from_int_impl!(i64, i8, i8, i16, i32, i64, isize);\n+same_sign_from_int_impl!(u64, u16, u8, u16, u32, u64, usize);\n+same_sign_from_int_impl!(i64, i16, i8, i16, i32, i64, isize);\n+same_sign_from_int_impl!(u64, u32, u8, u16, u32, u64, usize);\n+same_sign_from_int_impl!(i64, i32, i8, i16, i32, i64, isize);\n+same_sign_from_int_impl!(u64, u64, u8, u16, u32, u64, usize);\n+same_sign_from_int_impl!(i64, i64, i8, i16, i32, i64, isize);\n+same_sign_from_int_impl!(u64, usize, u8, u16, u32, u64, usize);\n+same_sign_from_int_impl!(i64, isize, i8, i16, i32, i64, isize);\n+\n+macro_rules! cross_sign_from_int_impl {\n+    ($unsigned:ty, $($signed:ty),*) => {$(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl TryFrom<$unsigned> for $signed {\n+            type Err = TryFromIntError;\n+\n+            fn try_from(u: $unsigned) -> Result<$signed, TryFromIntError> {\n+                let max = <$signed as FromStrRadixHelper>::max_value() as u64;\n+                if u as u64 > max {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $signed)\n+                }\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl TryFrom<$signed> for $unsigned {\n+            type Err = TryFromIntError;\n+\n+            fn try_from(u: $signed) -> Result<$unsigned, TryFromIntError> {\n+                let max = <$unsigned as FromStrRadixHelper>::max_value() as u64;\n+                if u < 0 || u as u64 > max {\n+                    Err(TryFromIntError(()))\n+                } else {\n+                    Ok(u as $unsigned)\n+                }\n+            }\n+        }\n+    )*}\n+}\n+\n+cross_sign_from_int_impl!(u8, i8, i16, i32, i64, isize);\n+cross_sign_from_int_impl!(u16, i8, i16, i32, i64, isize);\n+cross_sign_from_int_impl!(u32, i8, i16, i32, i64, isize);\n+cross_sign_from_int_impl!(u64, i8, i16, i32, i64, isize);\n+cross_sign_from_int_impl!(usize, i8, i16, i32, i64, isize);\n+\n #[doc(hidden)]\n trait FromStrRadixHelper: PartialOrd + Copy {\n     fn min_value() -> Self;\n+    fn max_value() -> Self;\n     fn from_u32(u: u32) -> Self;\n     fn checked_mul(&self, other: u32) -> Option<Self>;\n     fn checked_sub(&self, other: u32) -> Option<Self>;\n@@ -2364,6 +2456,7 @@ trait FromStrRadixHelper: PartialOrd + Copy {\n macro_rules! doit {\n     ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n         fn min_value() -> Self { Self::min_value() }\n+        fn max_value() -> Self { Self::max_value() }\n         fn from_u32(u: u32) -> Self { u as Self }\n         fn checked_mul(&self, other: u32) -> Option<Self> {\n             Self::checked_mul(*self, other as Self)"}, {"sha": "603dda2c96d2fd1e60a12c3e8b0bc97afedbbfbf", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -33,6 +33,7 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unique)]\n+#![feature(try_from)]\n \n extern crate core;\n extern crate test;"}, {"sha": "4834c0e072c9e412ae0da21751c3b1a73deb4f6d", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 299, "deletions": 146, "changes": 445, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -8,10 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::convert::TryFrom;\n use core::cmp::PartialEq;\n use core::fmt::Debug;\n-use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::marker::Copy;\n+use core::ops::{Add, Sub, Mul, Div, Rem};\n+use core::option::Option;\n+use core::option::Option::{Some, None};\n \n #[macro_use]\n mod int_macros;\n@@ -48,168 +51,318 @@ pub fn test_num<T>(ten: T, two: T) where\n     assert_eq!(ten.rem(two),  ten % two);\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use core::option::Option;\n-    use core::option::Option::{Some, None};\n-\n-    #[test]\n-    fn from_str_issue7588() {\n-        let u : Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n-        assert_eq!(u, None);\n-        let s : Option<i16> = i16::from_str_radix(\"80000\", 10).ok();\n-        assert_eq!(s, None);\n-    }\n+#[test]\n+fn from_str_issue7588() {\n+    let u : Option<u8> = u8::from_str_radix(\"1000\", 10).ok();\n+    assert_eq!(u, None);\n+    let s : Option<i16> = i16::from_str_radix(\"80000\", 10).ok();\n+    assert_eq!(s, None);\n+}\n \n-    #[test]\n-    fn test_int_from_str_overflow() {\n-        let mut i8_val: i8 = 127;\n-        assert_eq!(\"127\".parse::<i8>().ok(), Some(i8_val));\n-        assert_eq!(\"128\".parse::<i8>().ok(), None);\n+#[test]\n+fn test_int_from_str_overflow() {\n+    let mut i8_val: i8 = 127;\n+    assert_eq!(\"127\".parse::<i8>().ok(), Some(i8_val));\n+    assert_eq!(\"128\".parse::<i8>().ok(), None);\n \n-        i8_val = i8_val.wrapping_add(1);\n-        assert_eq!(\"-128\".parse::<i8>().ok(), Some(i8_val));\n-        assert_eq!(\"-129\".parse::<i8>().ok(), None);\n+    i8_val = i8_val.wrapping_add(1);\n+    assert_eq!(\"-128\".parse::<i8>().ok(), Some(i8_val));\n+    assert_eq!(\"-129\".parse::<i8>().ok(), None);\n \n-        let mut i16_val: i16 = 32_767;\n-        assert_eq!(\"32767\".parse::<i16>().ok(), Some(i16_val));\n-        assert_eq!(\"32768\".parse::<i16>().ok(), None);\n+    let mut i16_val: i16 = 32_767;\n+    assert_eq!(\"32767\".parse::<i16>().ok(), Some(i16_val));\n+    assert_eq!(\"32768\".parse::<i16>().ok(), None);\n \n-        i16_val = i16_val.wrapping_add(1);\n-        assert_eq!(\"-32768\".parse::<i16>().ok(), Some(i16_val));\n-        assert_eq!(\"-32769\".parse::<i16>().ok(), None);\n+    i16_val = i16_val.wrapping_add(1);\n+    assert_eq!(\"-32768\".parse::<i16>().ok(), Some(i16_val));\n+    assert_eq!(\"-32769\".parse::<i16>().ok(), None);\n \n-        let mut i32_val: i32 = 2_147_483_647;\n-        assert_eq!(\"2147483647\".parse::<i32>().ok(), Some(i32_val));\n-        assert_eq!(\"2147483648\".parse::<i32>().ok(), None);\n+    let mut i32_val: i32 = 2_147_483_647;\n+    assert_eq!(\"2147483647\".parse::<i32>().ok(), Some(i32_val));\n+    assert_eq!(\"2147483648\".parse::<i32>().ok(), None);\n \n-        i32_val = i32_val.wrapping_add(1);\n-        assert_eq!(\"-2147483648\".parse::<i32>().ok(), Some(i32_val));\n-        assert_eq!(\"-2147483649\".parse::<i32>().ok(), None);\n+    i32_val = i32_val.wrapping_add(1);\n+    assert_eq!(\"-2147483648\".parse::<i32>().ok(), Some(i32_val));\n+    assert_eq!(\"-2147483649\".parse::<i32>().ok(), None);\n \n-        let mut i64_val: i64 = 9_223_372_036_854_775_807;\n-        assert_eq!(\"9223372036854775807\".parse::<i64>().ok(), Some(i64_val));\n-        assert_eq!(\"9223372036854775808\".parse::<i64>().ok(), None);\n+    let mut i64_val: i64 = 9_223_372_036_854_775_807;\n+    assert_eq!(\"9223372036854775807\".parse::<i64>().ok(), Some(i64_val));\n+    assert_eq!(\"9223372036854775808\".parse::<i64>().ok(), None);\n \n-        i64_val = i64_val.wrapping_add(1);\n-        assert_eq!(\"-9223372036854775808\".parse::<i64>().ok(), Some(i64_val));\n-        assert_eq!(\"-9223372036854775809\".parse::<i64>().ok(), None);\n-    }\n+    i64_val = i64_val.wrapping_add(1);\n+    assert_eq!(\"-9223372036854775808\".parse::<i64>().ok(), Some(i64_val));\n+    assert_eq!(\"-9223372036854775809\".parse::<i64>().ok(), None);\n+}\n+\n+#[test]\n+fn test_leading_plus() {\n+    assert_eq!(\"+127\".parse::<u8>().ok(), Some(127));\n+    assert_eq!(\"+9223372036854775807\".parse::<i64>().ok(), Some(9223372036854775807));\n+}\n \n-    #[test]\n-    fn test_leading_plus() {\n-        assert_eq!(\"+127\".parse::<u8>().ok(), Some(127));\n-        assert_eq!(\"+9223372036854775807\".parse::<i64>().ok(), Some(9223372036854775807));\n+#[test]\n+fn test_invalid() {\n+    assert_eq!(\"--129\".parse::<i8>().ok(), None);\n+    assert_eq!(\"++129\".parse::<i8>().ok(), None);\n+    assert_eq!(\"\u0421\u044a\u0435\u0448\u044c\".parse::<u8>().ok(), None);\n+}\n+\n+#[test]\n+fn test_empty() {\n+    assert_eq!(\"-\".parse::<i8>().ok(), None);\n+    assert_eq!(\"+\".parse::<i8>().ok(), None);\n+    assert_eq!(\"\".parse::<u8>().ok(), None);\n+}\n+\n+macro_rules! test_impl_from {\n+    ($fn_name: ident, $Small: ty, $Large: ty) => {\n+        #[test]\n+        fn $fn_name() {\n+            let small_max = <$Small>::max_value();\n+            let small_min = <$Small>::min_value();\n+            let large_max: $Large = small_max.into();\n+            let large_min: $Large = small_min.into();\n+            assert_eq!(large_max as $Small, small_max);\n+            assert_eq!(large_min as $Small, small_min);\n+        }\n     }\n+}\n+\n+// Unsigned -> Unsigned\n+test_impl_from! { test_u8u16, u8, u16 }\n+test_impl_from! { test_u8u32, u8, u32 }\n+test_impl_from! { test_u8u64, u8, u64 }\n+test_impl_from! { test_u8usize, u8, usize }\n+test_impl_from! { test_u16u32, u16, u32 }\n+test_impl_from! { test_u16u64, u16, u64 }\n+test_impl_from! { test_u32u64, u32, u64 }\n+\n+// Signed -> Signed\n+test_impl_from! { test_i8i16, i8, i16 }\n+test_impl_from! { test_i8i32, i8, i32 }\n+test_impl_from! { test_i8i64, i8, i64 }\n+test_impl_from! { test_i8isize, i8, isize }\n+test_impl_from! { test_i16i32, i16, i32 }\n+test_impl_from! { test_i16i64, i16, i64 }\n+test_impl_from! { test_i32i64, i32, i64 }\n+\n+// Unsigned -> Signed\n+test_impl_from! { test_u8i16, u8, i16 }\n+test_impl_from! { test_u8i32, u8, i32 }\n+test_impl_from! { test_u8i64, u8, i64 }\n+test_impl_from! { test_u16i32, u16, i32 }\n+test_impl_from! { test_u16i64, u16, i64 }\n+test_impl_from! { test_u32i64, u32, i64 }\n+\n+// Signed -> Float\n+test_impl_from! { test_i8f32, i8, f32 }\n+test_impl_from! { test_i8f64, i8, f64 }\n+test_impl_from! { test_i16f32, i16, f32 }\n+test_impl_from! { test_i16f64, i16, f64 }\n+test_impl_from! { test_i32f64, i32, f64 }\n+\n+// Unsigned -> Float\n+test_impl_from! { test_u8f32, u8, f32 }\n+test_impl_from! { test_u8f64, u8, f64 }\n+test_impl_from! { test_u16f32, u16, f32 }\n+test_impl_from! { test_u16f64, u16, f64 }\n+test_impl_from! { test_u32f64, u32, f64 }\n+\n+// Float -> Float\n+#[test]\n+fn test_f32f64() {\n+    use core::f32;\n+\n+    let max: f64 = f32::MAX.into();\n+    assert_eq!(max as f32, f32::MAX);\n+    assert!(max.is_normal());\n+\n+    let min: f64 = f32::MIN.into();\n+    assert_eq!(min as f32, f32::MIN);\n+    assert!(min.is_normal());\n+\n+    let min_positive: f64 = f32::MIN_POSITIVE.into();\n+    assert_eq!(min_positive as f32, f32::MIN_POSITIVE);\n+    assert!(min_positive.is_normal());\n+\n+    let epsilon: f64 = f32::EPSILON.into();\n+    assert_eq!(epsilon as f32, f32::EPSILON);\n+    assert!(epsilon.is_normal());\n+\n+    let zero: f64 = (0.0f32).into();\n+    assert_eq!(zero as f32, 0.0f32);\n+    assert!(zero.is_sign_positive());\n+\n+    let neg_zero: f64 = (-0.0f32).into();\n+    assert_eq!(neg_zero as f32, -0.0f32);\n+    assert!(neg_zero.is_sign_negative());\n+\n+    let infinity: f64 = f32::INFINITY.into();\n+    assert_eq!(infinity as f32, f32::INFINITY);\n+    assert!(infinity.is_infinite());\n+    assert!(infinity.is_sign_positive());\n+\n+    let neg_infinity: f64 = f32::NEG_INFINITY.into();\n+    assert_eq!(neg_infinity as f32, f32::NEG_INFINITY);\n+    assert!(neg_infinity.is_infinite());\n+    assert!(neg_infinity.is_sign_negative());\n+\n+    let nan: f64 = f32::NAN.into();\n+    assert!(nan.is_nan());\n+}\n \n-    #[test]\n-    fn test_invalid() {\n-        assert_eq!(\"--129\".parse::<i8>().ok(), None);\n-        assert_eq!(\"++129\".parse::<i8>().ok(), None);\n-        assert_eq!(\"\u0421\u044a\u0435\u0448\u044c\".parse::<u8>().ok(), None);\n+macro_rules! test_impl_try_from_always_ok {\n+    ($fn_name:ident, $source:ty, $target: ty) => {\n+        #[test]\n+        fn $fn_name() {\n+            let max = <$source>::max_value();\n+            let min = <$source>::min_value();\n+            let zero: $source = 0;\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(max).unwrap(),\n+                       max as $target);\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(min).unwrap(),\n+                       min as $target);\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(),\n+                       zero as $target);\n+        }\n     }\n+}\n \n-    #[test]\n-    fn test_empty() {\n-        assert_eq!(\"-\".parse::<i8>().ok(), None);\n-        assert_eq!(\"+\".parse::<i8>().ok(), None);\n-        assert_eq!(\"\".parse::<u8>().ok(), None);\n+test_impl_try_from_always_ok! { test_try_u8u8, u8, u8 }\n+test_impl_try_from_always_ok! { test_try_u8u16, u8, u16 }\n+test_impl_try_from_always_ok! { test_try_u8u32, u8, u32 }\n+test_impl_try_from_always_ok! { test_try_u8u64, u8, u64 }\n+test_impl_try_from_always_ok! { test_try_u8i16, u8, i16 }\n+test_impl_try_from_always_ok! { test_try_u8i32, u8, i32 }\n+test_impl_try_from_always_ok! { test_try_u8i64, u8, i64 }\n+\n+test_impl_try_from_always_ok! { test_try_u16u16, u16, u16 }\n+test_impl_try_from_always_ok! { test_try_u16u32, u16, u32 }\n+test_impl_try_from_always_ok! { test_try_u16u64, u16, u64 }\n+test_impl_try_from_always_ok! { test_try_u16i32, u16, i32 }\n+test_impl_try_from_always_ok! { test_try_u16i64, u16, i64 }\n+\n+test_impl_try_from_always_ok! { test_try_u32u32, u32, u32 }\n+test_impl_try_from_always_ok! { test_try_u32u64, u32, u64 }\n+test_impl_try_from_always_ok! { test_try_u32i64, u32, i64 }\n+\n+test_impl_try_from_always_ok! { test_try_u64u64, u64, u64 }\n+\n+test_impl_try_from_always_ok! { test_try_i8i8, i8, i8 }\n+test_impl_try_from_always_ok! { test_try_i8i16, i8, i16 }\n+test_impl_try_from_always_ok! { test_try_i8i32, i8, i32 }\n+test_impl_try_from_always_ok! { test_try_i8i64, i8, i64 }\n+\n+test_impl_try_from_always_ok! { test_try_i16i16, i16, i16 }\n+test_impl_try_from_always_ok! { test_try_i16i32, i16, i32 }\n+test_impl_try_from_always_ok! { test_try_i16i64, i16, i64 }\n+\n+test_impl_try_from_always_ok! { test_try_i32i32, i32, i32 }\n+test_impl_try_from_always_ok! { test_try_i32i64, i32, i64 }\n+\n+test_impl_try_from_always_ok! { test_try_i64i64, i64, i64 }\n+\n+macro_rules! test_impl_try_from_signed_to_unsigned_upper_ok {\n+    ($fn_name:ident, $source:ty, $target:ty) => {\n+        #[test]\n+        fn $fn_name() {\n+            let max = <$source>::max_value();\n+            let min = <$source>::min_value();\n+            let zero: $source = 0;\n+            let neg_one: $source = -1;\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(max).unwrap(),\n+                       max as $target);\n+            assert!(<$target as TryFrom<$source>>::try_from(min).is_err());\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(),\n+                       zero as $target);\n+            assert!(<$target as TryFrom<$source>>::try_from(neg_one).is_err());\n+        }\n     }\n+}\n \n-    macro_rules! test_impl_from {\n-        ($fn_name: ident, $Small: ty, $Large: ty) => {\n-            #[test]\n-            fn $fn_name() {\n-                let small_max = <$Small>::max_value();\n-                let small_min = <$Small>::min_value();\n-                let large_max: $Large = small_max.into();\n-                let large_min: $Large = small_min.into();\n-                assert_eq!(large_max as $Small, small_max);\n-                assert_eq!(large_min as $Small, small_min);\n-            }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u8, i8, u8 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u16, i8, u16 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u32, i8, u32 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i8u64, i8, u64 }\n+\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u16, i16, u16 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u32, i16, u32 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i16u64, i16, u64 }\n+\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32u32, i32, u32 }\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i32u64, i32, u64 }\n+\n+test_impl_try_from_signed_to_unsigned_upper_ok! { test_try_i64u64, i64, u64 }\n+\n+macro_rules! test_impl_try_from_unsigned_to_signed_upper_err {\n+    ($fn_name:ident, $source:ty, $target:ty) => {\n+        #[test]\n+        fn $fn_name() {\n+            let max = <$source>::max_value();\n+            let min = <$source>::min_value();\n+            let zero: $source = 0;\n+            assert!(<$target as TryFrom<$source>>::try_from(max).is_err());\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(min).unwrap(),\n+                       min as $target);\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(),\n+                       zero as $target);\n         }\n     }\n+}\n \n-    // Unsigned -> Unsigned\n-    test_impl_from! { test_u8u16, u8, u16 }\n-    test_impl_from! { test_u8u32, u8, u32 }\n-    test_impl_from! { test_u8u64, u8, u64 }\n-    test_impl_from! { test_u8usize, u8, usize }\n-    test_impl_from! { test_u16u32, u16, u32 }\n-    test_impl_from! { test_u16u64, u16, u64 }\n-    test_impl_from! { test_u32u64, u32, u64 }\n-\n-    // Signed -> Signed\n-    test_impl_from! { test_i8i16, i8, i16 }\n-    test_impl_from! { test_i8i32, i8, i32 }\n-    test_impl_from! { test_i8i64, i8, i64 }\n-    test_impl_from! { test_i8isize, i8, isize }\n-    test_impl_from! { test_i16i32, i16, i32 }\n-    test_impl_from! { test_i16i64, i16, i64 }\n-    test_impl_from! { test_i32i64, i32, i64 }\n-\n-    // Unsigned -> Signed\n-    test_impl_from! { test_u8i16, u8, i16 }\n-    test_impl_from! { test_u8i32, u8, i32 }\n-    test_impl_from! { test_u8i64, u8, i64 }\n-    test_impl_from! { test_u16i32, u16, i32 }\n-    test_impl_from! { test_u16i64, u16, i64 }\n-    test_impl_from! { test_u32i64, u32, i64 }\n-\n-    // Signed -> Float\n-    test_impl_from! { test_i8f32, i8, f32 }\n-    test_impl_from! { test_i8f64, i8, f64 }\n-    test_impl_from! { test_i16f32, i16, f32 }\n-    test_impl_from! { test_i16f64, i16, f64 }\n-    test_impl_from! { test_i32f64, i32, f64 }\n-\n-    // Unsigned -> Float\n-    test_impl_from! { test_u8f32, u8, f32 }\n-    test_impl_from! { test_u8f64, u8, f64 }\n-    test_impl_from! { test_u16f32, u16, f32 }\n-    test_impl_from! { test_u16f64, u16, f64 }\n-    test_impl_from! { test_u32f64, u32, f64 }\n-\n-    // Float -> Float\n-    #[test]\n-    fn test_f32f64() {\n-        use core::f32;\n-\n-        let max: f64 = f32::MAX.into();\n-        assert_eq!(max as f32, f32::MAX);\n-        assert!(max.is_normal());\n-\n-        let min: f64 = f32::MIN.into();\n-        assert_eq!(min as f32, f32::MIN);\n-        assert!(min.is_normal());\n-\n-        let min_positive: f64 = f32::MIN_POSITIVE.into();\n-        assert_eq!(min_positive as f32, f32::MIN_POSITIVE);\n-        assert!(min_positive.is_normal());\n-\n-        let epsilon: f64 = f32::EPSILON.into();\n-        assert_eq!(epsilon as f32, f32::EPSILON);\n-        assert!(epsilon.is_normal());\n-\n-        let zero: f64 = (0.0f32).into();\n-        assert_eq!(zero as f32, 0.0f32);\n-        assert!(zero.is_sign_positive());\n-\n-        let neg_zero: f64 = (-0.0f32).into();\n-        assert_eq!(neg_zero as f32, -0.0f32);\n-        assert!(neg_zero.is_sign_negative());\n-\n-        let infinity: f64 = f32::INFINITY.into();\n-        assert_eq!(infinity as f32, f32::INFINITY);\n-        assert!(infinity.is_infinite());\n-        assert!(infinity.is_sign_positive());\n-\n-        let neg_infinity: f64 = f32::NEG_INFINITY.into();\n-        assert_eq!(neg_infinity as f32, f32::NEG_INFINITY);\n-        assert!(neg_infinity.is_infinite());\n-        assert!(neg_infinity.is_sign_negative());\n-\n-        let nan: f64 = f32::NAN.into();\n-        assert!(nan.is_nan());\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u8i8, u8, i8 }\n+\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u16i8, u16, i8 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u16i16, u16, i16 }\n+\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32i8, u32, i8 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32i16, u32, i16 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u32i32, u32, i32 }\n+\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i8, u64, i8 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i16, u64, i16 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i32, u64, i32 }\n+test_impl_try_from_unsigned_to_signed_upper_err! { test_try_u64i64, u64, i64 }\n+\n+macro_rules! test_impl_try_from_same_sign_err {\n+    ($fn_name:ident, $source:ty, $target:ty) => {\n+        #[test]\n+        fn $fn_name() {\n+            let max = <$source>::max_value();\n+            let min = <$source>::min_value();\n+            let zero: $source = 0;\n+            let t_max = <$target>::max_value();\n+            let t_min = <$target>::min_value();\n+            assert!(<$target as TryFrom<$source>>::try_from(max).is_err());\n+            if min != 0 {\n+                assert!(<$target as TryFrom<$source>>::try_from(min).is_err());\n+            }\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(zero).unwrap(),\n+                       zero as $target);\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(t_max as $source)\n+                            .unwrap(),\n+                       t_max as $target);\n+            assert_eq!(<$target as TryFrom<$source>>::try_from(t_min as $source)\n+                            .unwrap(),\n+                       t_min as $target);\n+        }\n     }\n }\n+\n+test_impl_try_from_same_sign_err! { test_try_u16u8, u16, u8 }\n+\n+test_impl_try_from_same_sign_err! { test_try_u32u8, u32, u8 }\n+test_impl_try_from_same_sign_err! { test_try_u32u16, u32, u16 }\n+\n+test_impl_try_from_same_sign_err! { test_try_u64u8, u64, u8 }\n+test_impl_try_from_same_sign_err! { test_try_u64u16, u64, u16 }\n+test_impl_try_from_same_sign_err! { test_try_u64u32, u64, u32 }\n+\n+test_impl_try_from_same_sign_err! { test_try_i16i8, i16, i8 }\n+\n+test_impl_try_from_same_sign_err! { test_try_i32i8, i32, i8 }\n+test_impl_try_from_same_sign_err! { test_try_i32i16, i32, i16 }\n+\n+test_impl_try_from_same_sign_err! { test_try_i64i8, i64, i8 }\n+test_impl_try_from_same_sign_err! { test_try_i64i16, i64, i16 }\n+test_impl_try_from_same_sign_err! { test_try_i64i32, i64, i32 }"}, {"sha": "fda7c7aeb33069695bc27aea53e73ec9c88115dc", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -623,6 +623,69 @@ let Foo = 12i32; // ok!\n The goal here is to avoid a conflict of names.\n \"##,\n \n+E0414: r##\"\n+A variable binding in an irrefutable pattern is shadowing the name of a\n+constant. Example of erroneous code:\n+\n+```compile_fail\n+const FOO: u8 = 7;\n+\n+let FOO = 5; // error: variable bindings cannot shadow constants\n+\n+// or\n+\n+fn bar(FOO: u8) { // error: variable bindings cannot shadow constants\n+\n+}\n+\n+// or\n+\n+for FOO in bar {\n+\n+}\n+```\n+\n+Introducing a new variable in Rust is done through a pattern. Thus you can have\n+`let` bindings like `let (a, b) = ...`. However, patterns also allow constants\n+in them, e.g. if you want to match over a constant:\n+\n+```ignore\n+const FOO: u8 = 1;\n+\n+match (x,y) {\n+ (3, 4) => { .. }, // it is (3,4)\n+ (FOO, 1) => { .. }, // it is (1,1)\n+ (foo, 1) => { .. }, // it is (anything, 1)\n+                     // call the value in the first slot \"foo\"\n+ _ => { .. } // it is anything\n+}\n+```\n+\n+Here, the second arm matches the value of `x` against the constant `FOO`,\n+whereas the third arm will accept any value of `x` and call it `foo`.\n+\n+This works for `match`, however in cases where an irrefutable pattern is\n+required, constants can't be used. An irrefutable pattern is one which always\n+matches, whose purpose is only to bind variable names to values. These are\n+required by let, for, and function argument patterns.\n+\n+Refutable patterns in such a situation do not make sense, for example:\n+\n+```ignore\n+let Some(x) = foo; // what if foo is None, instead?\n+\n+let (1, x) = foo; // what if foo.0 is not 1?\n+\n+let (SOME_CONST, x) = foo; // what if foo.0 is not SOME_CONST?\n+\n+let SOME_CONST = foo; // what if foo is not SOME_CONST?\n+```\n+\n+Thus, an irrefutable variable binding can't contain a constant.\n+\n+To fix this error, just give the marked variable a different name.\n+\"##,\n+\n E0415: r##\"\n More than one function parameter have the same name. Example of erroneous code:\n \n@@ -1086,7 +1149,6 @@ register_diagnostics! {\n     E0409, // variable is bound with different mode in pattern # than in\n            // pattern #1\n     E0410, // variable from pattern is not bound in pattern 1\n-    E0414, // only irrefutable patterns allowed here\n     E0418, // is not an enum variant, struct or const\n     E0420, // is not an associated const\n     E0421, // unresolved associated const"}, {"sha": "7c6c76f130efed0dbba78444bd98ee34fdf67f2b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -139,7 +139,7 @@ enum ResolutionError<'a> {\n     /// error E0413: declaration shadows an enum variant or unit-like struct in scope\n     DeclarationShadowsEnumVariantOrUnitLikeStruct(Name),\n     /// error E0414: only irrefutable patterns allowed here\n-    OnlyIrrefutablePatternsAllowedHere(Name),\n+    ConstantForIrrefutableBinding(Name),\n     /// error E0415: identifier is bound more than once in this parameter list\n     IdentifierBoundMoreThanOnceInParameterList(&'a str),\n     /// error E0416: identifier is bound more than once in the same pattern\n@@ -321,11 +321,11 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                               or unit-like struct in scope\",\n                              name)\n         }\n-        ResolutionError::OnlyIrrefutablePatternsAllowedHere(name) => {\n+        ResolutionError::ConstantForIrrefutableBinding(name) => {\n             let mut err = struct_span_err!(resolver.session,\n                                            span,\n                                            E0414,\n-                                           \"only irrefutable patterns allowed here\");\n+                                           \"variable bindings cannot shadow constants\");\n             err.span_note(span,\n                           \"there already is a constant in scope sharing the same \\\n                            name as this pattern\");\n@@ -2248,7 +2248,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             resolve_error(\n                                 self,\n                                 pattern.span,\n-                                ResolutionError::OnlyIrrefutablePatternsAllowedHere(name)\n+                                ResolutionError::ConstantForIrrefutableBinding(name)\n                             );\n                             self.record_def(pattern.id, err_path_resolution());\n                         }"}, {"sha": "c0faa04323e47ddd2435a393f72166920a848757", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -27,7 +27,7 @@\n //! bounds by special casing scenarios such as these. Fun!\n \n use std::mem;\n-use std::collections::HashMap;\n+use std::collections::BTreeMap;\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::subst;\n@@ -39,7 +39,7 @@ use core::DocContext;\n \n pub fn where_clauses(cx: &DocContext, clauses: Vec<WP>) -> Vec<WP> {\n     // First, partition the where clause into its separate components\n-    let mut params = HashMap::new();\n+    let mut params = BTreeMap::new();\n     let mut lifetimes = Vec::new();\n     let mut equalities = Vec::new();\n     let mut tybounds = Vec::new();\n@@ -62,7 +62,7 @@ pub fn where_clauses(cx: &DocContext, clauses: Vec<WP>) -> Vec<WP> {\n     // Simplify the type parameter bounds on all the generics\n     let mut params = params.into_iter().map(|(k, v)| {\n         (k, ty_bounds(v))\n-    }).collect::<HashMap<_, _>>();\n+    }).collect::<BTreeMap<_, _>>();\n \n     // Look for equality predicates on associated types that can be merged into\n     // general bound predicates"}, {"sha": "d49d97649467ae1d61a726350aaf396628d244a3", "filename": "src/libstd/error.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -159,6 +159,13 @@ impl Error for num::ParseIntError {\n     }\n }\n \n+#[unstable(feature = \"try_from\", issue = \"33417\")]\n+impl Error for num::TryFromIntError {\n+    fn description(&self) -> &str {\n+        self.__description()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for num::ParseFloatError {\n     fn description(&self) -> &str {"}, {"sha": "d4b40b844fce5e28d15bafcf66b1a75b3bb217d4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -270,6 +270,7 @@\n #![feature(vec_push_all)]\n #![feature(zero_one)]\n #![feature(question_mark)]\n+#![feature(try_from)]\n \n // Issue# 30592: Systematically use alloc_system during stage0 since jemalloc\n // might be unavailable or disabled"}, {"sha": "d33df05acf2248fcea578cdc2672176aff1089dd", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -19,7 +19,7 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::num::{Zero, One};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::num::{FpCategory, ParseIntError, ParseFloatError};\n+pub use core::num::{FpCategory, ParseIntError, ParseFloatError, TryFromIntError};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::num::Wrapping;\n "}, {"sha": "237e6823e0f8752b6693fd8d90b4887c4479f25b", "filename": "src/libsyntax/errors/snippet/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -376,11 +376,21 @@ impl FileInfo {\n         // Basically, although this loses information, multi-line spans just\n         // never look good.\n \n-        let (line, start_col, end_col) = if lines.len() == 1 {\n+        let (line, start_col, mut end_col) = if lines.len() == 1 {\n             (lines[0].line_index, lines[0].start_col, lines[0].end_col)\n         } else {\n             (lines[0].line_index, lines[0].start_col, CharPos(lines[0].start_col.0 + 1))\n         };\n+\n+        // Watch out for \"empty spans\". If we get a span like 6..6, we\n+        // want to just display a `^` at 6, so convert that to\n+        // 6..7. This is degenerate input, but it's best to degrade\n+        // gracefully -- and the parser likes to suply a span like\n+        // that for EOF, in particular.\n+        if start_col == end_col {\n+            end_col.0 += 1;\n+        }\n+\n         let index = self.ensure_source_line(line);\n         self.lines[index].push_annotation(start_col,\n                                           end_col,"}, {"sha": "5a888b488191ba0ea07b45b8e0f65796b796fc8b", "filename": "src/libsyntax/errors/snippet/test.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -519,3 +519,41 @@ fn span_overlap_label3() {\n   |>            ----- bar\n \"#[1..]);\n }\n+\n+#[test]\n+fn span_empty() {\n+    // In one of the unit tests, we found that the parser sometimes\n+    // gives empty spans, and in particular it supplied an EOF span\n+    // like this one, which points at the very end. We want to\n+    // fallback gracefully in this case.\n+\n+    let file_text = r#\"\n+fn main() {\n+    struct Foo;\n+\n+    impl !Sync for Foo {}\n+\n+    unsafe impl Send for &'static Foo {\n+    // error: cross-crate traits with a default impl, like `core::marker::Send`,\n+    //        can only be implemented for a struct/enum type, not\n+    //        `&'static Foo`\n+}\"#;\n+\n+\n+    let cm = Rc::new(CodeMap::new());\n+    let foo = cm.new_filemap_and_lines(\"foo.rs\", file_text);\n+\n+    let mut rbrace_span = cm.span_substr(&foo, file_text, \"}\", 1);\n+    rbrace_span.lo = rbrace_span.hi;\n+\n+    let mut snippet = SnippetData::new(cm.clone(), Some(rbrace_span));\n+    snippet.push(rbrace_span, false, None);\n+    let lines = snippet.render_lines();\n+    let text: String = make_string(&lines);\n+    println!(\"r#\\\"\\n{}\\\"\", text);\n+    assert_eq!(text, &r#\"\n+  --> foo.rs:11:2\n+11 |> }\n+   |>  -\n+\"#[1..]);\n+}"}, {"sha": "7a63742fba3427c9bff6b21fb306502da7cde221", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -7,15 +7,6 @@ dependencies = [\n  \"rustdoc 0.0.0\",\n ]\n \n-[[package]]\n-name = \"advapi32-sys\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"arena\"\n version = \"0.0.0\"\n@@ -29,7 +20,7 @@ name = \"flate\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -38,12 +29,8 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"gcc\"\n-version = \"0.3.17\"\n+version = \"0.3.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"advapi32-sys 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n \n [[package]]\n name = \"graphviz\"\n@@ -192,7 +179,7 @@ name = \"rustc_llvm\"\n version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_bitflags 0.0.0\",\n ]\n \n@@ -326,7 +313,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n  \"build_helper 0.1.0\",\n- \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.28 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n@@ -365,13 +352,3 @@ dependencies = [\n  \"syntax 0.0.0\",\n ]\n \n-[[package]]\n-name = \"winapi\"\n-version = \"0.2.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"winapi-build\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-"}, {"sha": "0be1e974e7d7d48e7763afac859b999e007067b4", "filename": "src/test/compile-fail/const-pattern-irrefutable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -19,10 +19,10 @@ use foo::d; //~ NOTE constant imported here\n const a: u8 = 2; //~ NOTE constant defined here\n \n fn main() {\n-    let a = 4; //~ ERROR only irrefutable\n+    let a = 4; //~ ERROR variable bindings cannot\n                //~^ NOTE there already is a constant in scope\n-    let c = 4; //~ ERROR only irrefutable\n+    let c = 4; //~ ERROR variable bindings cannot\n                //~^ NOTE there already is a constant in scope\n-    let d = 4; //~ ERROR only irrefutable\n+    let d = 4; //~ ERROR variable bindings cannot\n                //~^ NOTE there already is a constant in scope\n }"}, {"sha": "a729cf95a7bf3a826f1fd5f120fd5a71d9f070a8", "filename": "src/test/compile-fail/issue-27033.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Ftest%2Fcompile-fail%2Fissue-27033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Ftest%2Fcompile-fail%2Fissue-27033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27033.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     };\n     const C: u8 = 1;\n     match 1 {\n-        C @ 2 => { //~ ERROR only irrefutable patterns allowed here\n+        C @ 2 => { //~ ERROR variable bindings cannot shadow constants\n             println!(\"{}\", C);\n         }\n         _ => {}"}, {"sha": "4324db489b7f8b442eab8e72194f3de77b0b6ddf", "filename": "src/tools/tidy/src/cargo_lock.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Ftools%2Ftidy%2Fsrc%2Fcargo_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Ftools%2Ftidy%2Fsrc%2Fcargo_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fcargo_lock.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::path::Path;\n+\n+const CARGO_LOCK: &'static str = \"Cargo.lock\";\n+\n+pub fn check(path: &Path, bad: &mut bool) {\n+    use std::process::Command;\n+\n+    super::walk(path,\n+                &mut |path| super::filter_dirs(path) || path.ends_with(\"src/test\"),\n+                &mut |file| {\n+        let name = file.file_name().unwrap().to_string_lossy();\n+        if name == CARGO_LOCK {\n+            let rel_path = file.strip_prefix(path).unwrap();\n+            let ret_code = Command::new(\"git\")\n+                                        .arg(\"diff-index\")\n+                                        .arg(\"--quiet\")\n+                                        .arg(\"HEAD\")\n+                                        .arg(rel_path)\n+                                        .current_dir(path)\n+                                        .status()\n+                                        .unwrap_or_else(|e| {\n+                                            panic!(\"could not run git diff-index: {}\", e);\n+                                        });\n+            if !ret_code.success() {\n+                let parent_path = file.parent().unwrap().join(\"Cargo.toml\");\n+                print!(\"dirty lock file found at {} \", rel_path.display());\n+                println!(\"please commit your changes or update the lock file by running:\");\n+                println!(\"\\n\\tcargo update --manifest-path {}\", parent_path.display());\n+                *bad = true;\n+            }\n+        }\n+    });\n+}"}, {"sha": "2839bbded1a5f0cb8d171a70ba13cf3b7efadbee", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae42a471c13eec8a6470d0845f46f1606d50742/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=cae42a471c13eec8a6470d0845f46f1606d50742", "patch": "@@ -35,6 +35,7 @@ mod style;\n mod errors;\n mod features;\n mod cargo;\n+mod cargo_lock;\n \n fn main() {\n     let path = env::args_os().skip(1).next().expect(\"need an argument\");\n@@ -46,6 +47,7 @@ fn main() {\n     errors::check(&path, &mut bad);\n     cargo::check(&path, &mut bad);\n     features::check(&path, &mut bad);\n+    cargo_lock::check(&path, &mut bad);\n \n     if bad {\n         panic!(\"some tidy checks failed\");"}]}