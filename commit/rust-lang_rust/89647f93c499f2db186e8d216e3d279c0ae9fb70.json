{"sha": "89647f93c499f2db186e8d216e3d279c0ae9fb70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NjQ3ZjkzYzQ5OWYyZGIxODZlOGQyMTZlM2QyNzljMGFlOWZiNzA=", "commit": {"author": {"name": "Jeremy Kolb", "email": "kjeremy@gmail.com", "date": "2019-11-15T03:48:35Z"}, "committer": {"name": "Jeremy Kolb", "email": "kjeremy@gmail.com", "date": "2019-11-15T03:53:42Z"}, "message": "Cleanup hover\n\nTake advantage of classify_name", "tree": {"sha": "2057207ad39352b536692148f1d0b3aceff89f31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2057207ad39352b536692148f1d0b3aceff89f31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89647f93c499f2db186e8d216e3d279c0ae9fb70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89647f93c499f2db186e8d216e3d279c0ae9fb70", "html_url": "https://github.com/rust-lang/rust/commit/89647f93c499f2db186e8d216e3d279c0ae9fb70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89647f93c499f2db186e8d216e3d279c0ae9fb70/comments", "author": {"login": "kjeremy", "id": 4325700, "node_id": "MDQ6VXNlcjQzMjU3MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4325700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kjeremy", "html_url": "https://github.com/kjeremy", "followers_url": "https://api.github.com/users/kjeremy/followers", "following_url": "https://api.github.com/users/kjeremy/following{/other_user}", "gists_url": "https://api.github.com/users/kjeremy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kjeremy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kjeremy/subscriptions", "organizations_url": "https://api.github.com/users/kjeremy/orgs", "repos_url": "https://api.github.com/users/kjeremy/repos", "events_url": "https://api.github.com/users/kjeremy/events{/privacy}", "received_events_url": "https://api.github.com/users/kjeremy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kjeremy", "id": 4325700, "node_id": "MDQ6VXNlcjQzMjU3MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4325700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kjeremy", "html_url": "https://github.com/kjeremy", "followers_url": "https://api.github.com/users/kjeremy/followers", "following_url": "https://api.github.com/users/kjeremy/following{/other_user}", "gists_url": "https://api.github.com/users/kjeremy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kjeremy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kjeremy/subscriptions", "organizations_url": "https://api.github.com/users/kjeremy/orgs", "repos_url": "https://api.github.com/users/kjeremy/repos", "events_url": "https://api.github.com/users/kjeremy/events{/privacy}", "received_events_url": "https://api.github.com/users/kjeremy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbb022d3999b3038549ec6c309efb065231c896a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb022d3999b3038549ec6c309efb065231c896a", "html_url": "https://github.com/rust-lang/rust/commit/bbb022d3999b3038549ec6c309efb065231c896a"}], "stats": {"total": 204, "additions": 93, "deletions": 111}, "files": [{"sha": "07d511fb316c94d889325147ed1fb7e3590db32f", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 93, "deletions": 111, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/89647f93c499f2db186e8d216e3d279c0ae9fb70/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89647f93c499f2db186e8d216e3d279c0ae9fb70/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=89647f93c499f2db186e8d216e3d279c0ae9fb70", "patch": "@@ -5,7 +5,7 @@ use ra_db::SourceDatabase;\n use ra_syntax::{\n     algo::{ancestors_at_offset, find_covering_element, find_node_at_offset},\n     ast::{self, DocCommentsOwner},\n-    match_ast, AstNode,\n+    AstNode,\n };\n \n use crate::{\n@@ -14,7 +14,7 @@ use crate::{\n         description_from_symbol, docs_from_symbol, macro_label, rust_code_markup,\n         rust_code_markup_with_doc, ShortLabel,\n     },\n-    references::{classify_name_ref, NameKind::*},\n+    references::{classify_name, classify_name_ref, NameKind, NameKind::*},\n     FilePosition, FileRange, RangeInfo,\n };\n \n@@ -92,65 +92,88 @@ fn hover_text(docs: Option<String>, desc: Option<String>) -> Option<String> {\n     }\n }\n \n+fn hover_text_from_name_kind(\n+    db: &RootDatabase,\n+    name_kind: NameKind,\n+    no_fallback: &mut bool,\n+) -> Option<String> {\n+    return match name_kind {\n+        Macro(it) => {\n+            let src = it.source(db);\n+            hover_text(src.ast.doc_comment_text(), Some(macro_label(&src.ast)))\n+        }\n+        Field(it) => {\n+            let src = it.source(db);\n+            match src.ast {\n+                hir::FieldSource::Named(it) => hover_text(it.doc_comment_text(), it.short_label()),\n+                _ => None,\n+            }\n+        }\n+        AssocItem(it) => match it {\n+            hir::AssocItem::Function(it) => from_def_source(db, it),\n+            hir::AssocItem::Const(it) => from_def_source(db, it),\n+            hir::AssocItem::TypeAlias(it) => from_def_source(db, it),\n+        },\n+        Def(it) => match it {\n+            hir::ModuleDef::Module(it) => match it.definition_source(db).ast {\n+                hir::ModuleSource::Module(it) => {\n+                    hover_text(it.doc_comment_text(), it.short_label())\n+                }\n+                _ => None,\n+            },\n+            hir::ModuleDef::Function(it) => from_def_source(db, it),\n+            hir::ModuleDef::Adt(Adt::Struct(it)) => from_def_source(db, it),\n+            hir::ModuleDef::Adt(Adt::Union(it)) => from_def_source(db, it),\n+            hir::ModuleDef::Adt(Adt::Enum(it)) => from_def_source(db, it),\n+            hir::ModuleDef::EnumVariant(it) => from_def_source(db, it),\n+            hir::ModuleDef::Const(it) => from_def_source(db, it),\n+            hir::ModuleDef::Static(it) => from_def_source(db, it),\n+            hir::ModuleDef::Trait(it) => from_def_source(db, it),\n+            hir::ModuleDef::TypeAlias(it) => from_def_source(db, it),\n+            hir::ModuleDef::BuiltinType(it) => Some(it.to_string()),\n+        },\n+        SelfType(ty) => match ty.as_adt() {\n+            Some((adt_def, _)) => match adt_def {\n+                hir::Adt::Struct(it) => from_def_source(db, it),\n+                hir::Adt::Union(it) => from_def_source(db, it),\n+                hir::Adt::Enum(it) => from_def_source(db, it),\n+            },\n+            _ => None,\n+        },\n+        Local(_) => {\n+            // Hover for these shows type names\n+            *no_fallback = true;\n+            None\n+        }\n+        GenericParam(_) => {\n+            // FIXME: Hover for generic param\n+            None\n+        }\n+    };\n+\n+    fn from_def_source<A, D>(db: &RootDatabase, def: D) -> Option<String>\n+    where\n+        D: HasSource<Ast = A>,\n+        A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n+    {\n+        let src = def.source(db);\n+        hover_text(src.ast.doc_comment_text(), src.ast.short_label())\n+    }\n+}\n+\n pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo<HoverResult>> {\n     let parse = db.parse(position.file_id);\n     let file = parse.tree();\n+\n     let mut res = HoverResult::new();\n \n-    let mut range = None;\n-    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n+    let mut range = if let Some(name_ref) =\n+        find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset)\n+    {\n         let mut no_fallback = false;\n-        let name_kind = classify_name_ref(db, position.file_id, &name_ref).map(|d| d.kind);\n-        match name_kind {\n-            Some(Macro(it)) => {\n-                let src = it.source(db);\n-                res.extend(hover_text(src.ast.doc_comment_text(), Some(macro_label(&src.ast))));\n-            }\n-            Some(Field(it)) => {\n-                let src = it.source(db);\n-                if let hir::FieldSource::Named(it) = src.ast {\n-                    res.extend(hover_text(it.doc_comment_text(), it.short_label()));\n-                }\n-            }\n-            Some(AssocItem(it)) => res.extend(match it {\n-                hir::AssocItem::Function(it) => from_def_source(db, it),\n-                hir::AssocItem::Const(it) => from_def_source(db, it),\n-                hir::AssocItem::TypeAlias(it) => from_def_source(db, it),\n-            }),\n-            Some(Def(it)) => match it {\n-                hir::ModuleDef::Module(it) => {\n-                    if let hir::ModuleSource::Module(it) = it.definition_source(db).ast {\n-                        res.extend(hover_text(it.doc_comment_text(), it.short_label()))\n-                    }\n-                }\n-                hir::ModuleDef::Function(it) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::Adt(Adt::Struct(it)) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::Adt(Adt::Union(it)) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::Adt(Adt::Enum(it)) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::EnumVariant(it) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::Const(it) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::Static(it) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::Trait(it) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::TypeAlias(it) => res.extend(from_def_source(db, it)),\n-                hir::ModuleDef::BuiltinType(it) => res.extend(Some(it.to_string())),\n-            },\n-            Some(SelfType(ty)) => {\n-                if let Some((adt_def, _)) = ty.as_adt() {\n-                    res.extend(match adt_def {\n-                        hir::Adt::Struct(it) => from_def_source(db, it),\n-                        hir::Adt::Union(it) => from_def_source(db, it),\n-                        hir::Adt::Enum(it) => from_def_source(db, it),\n-                    })\n-                }\n-            }\n-            Some(Local(_)) => {\n-                // Hover for these shows type names\n-                no_fallback = true;\n-            }\n-            Some(GenericParam(_)) => {\n-                // FIXME: Hover for generic param\n-            }\n-            None => {}\n+        if let Some(name_kind) = classify_name_ref(db, position.file_id, &name_ref).map(|d| d.kind)\n+        {\n+            res.extend(hover_text_from_name_kind(db, name_kind, &mut no_fallback))\n         }\n \n         if res.is_empty() && !no_fallback {\n@@ -164,55 +187,24 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         }\n \n         if !res.is_empty() {\n-            range = Some(name_ref.syntax().text_range())\n+            Some(name_ref.syntax().text_range())\n+        } else {\n+            None\n         }\n     } else if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), position.offset) {\n-        if let Some(parent) = name.syntax().parent() {\n-            let text = match_ast! {\n-                match parent {\n-                    ast::StructDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::EnumDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::EnumVariant(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::FnDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::TypeAliasDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::ConstDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::StaticDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::TraitDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::RecordFieldDef(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::Module(it) => {\n-                        hover_text(it.doc_comment_text(), it.short_label())\n-                    },\n-                    ast::MacroCall(it) => {\n-                        hover_text(it.doc_comment_text(), None)\n-                    },\n-                    _ => None,\n-                }\n-            };\n-            res.extend(text);\n+        if let Some(name_kind) = classify_name(db, position.file_id, &name).map(|d| d.kind) {\n+            let mut _b: bool = true;\n+            res.extend(hover_text_from_name_kind(db, name_kind, &mut _b));\n         }\n \n-        if !res.is_empty() && range.is_none() {\n-            range = Some(name.syntax().text_range());\n+        if !res.is_empty() {\n+            Some(name.syntax().text_range())\n+        } else {\n+            None\n         }\n-    }\n+    } else {\n+        None\n+    };\n \n     if range.is_none() {\n         let node = ancestors_at_offset(file.syntax(), position.offset).find(|n| {\n@@ -221,23 +213,13 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         let frange = FileRange { file_id: position.file_id, range: node.text_range() };\n         res.extend(type_of(db, frange).map(rust_code_markup));\n         range = Some(node.text_range());\n-    }\n+    };\n \n     let range = range?;\n     if res.is_empty() {\n         return None;\n     }\n-    let res = RangeInfo::new(range, res);\n-    return Some(res);\n-\n-    fn from_def_source<A, D>(db: &RootDatabase, def: D) -> Option<String>\n-    where\n-        D: HasSource<Ast = A>,\n-        A: ast::DocCommentsOwner + ast::NameOwner + ShortLabel,\n-    {\n-        let src = def.source(db);\n-        hover_text(src.ast.doc_comment_text(), src.ast.short_label())\n-    }\n+    Some(RangeInfo::new(range, res))\n }\n \n pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Option<String> {"}]}