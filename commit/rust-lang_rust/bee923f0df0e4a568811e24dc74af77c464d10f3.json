{"sha": "bee923f0df0e4a568811e24dc74af77c464d10f3", "node_id": "C_kwDOAAsO6NoAKGJlZTkyM2YwZGYwZTRhNTY4ODExZTI0ZGM3NGFmNzdjNDY0ZDEwZjM", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2022-03-09T20:25:46Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2022-05-06T15:50:51Z"}, "message": "unix: always use 64-bit Timespec", "tree": {"sha": "aeec085973d223ee784a81401294668e9d1556d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aeec085973d223ee784a81401294668e9d1556d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bee923f0df0e4a568811e24dc74af77c464d10f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bee923f0df0e4a568811e24dc74af77c464d10f3", "html_url": "https://github.com/rust-lang/rust/commit/bee923f0df0e4a568811e24dc74af77c464d10f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bee923f0df0e4a568811e24dc74af77c464d10f3/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a251644fa2adde5f46eea8d342b7e60e4716039", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a251644fa2adde5f46eea8d342b7e60e4716039", "html_url": "https://github.com/rust-lang/rust/commit/9a251644fa2adde5f46eea8d342b7e60e4716039"}], "stats": {"total": 132, "additions": 65, "deletions": 67}, "files": [{"sha": "c1966d6707856887f2c7c5c927ddcbaa61a35e0f", "filename": "library/std/src/sys/unix/futex.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bee923f0df0e4a568811e24dc74af77c464d10f3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bee923f0df0e4a568811e24dc74af77c464d10f3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs?ref=bee923f0df0e4a568811e24dc74af77c464d10f3", "patch": "@@ -24,8 +24,9 @@ pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -\n     // Calculate the timeout as an absolute timespec.\n     //\n     // Overflows are rounded up to an infinite timeout (None).\n-    let timespec =\n-        timeout.and_then(|d| Some(Timespec::now(libc::CLOCK_MONOTONIC).checked_add_duration(&d)?));\n+    let timespec = timeout\n+        .and_then(|d| Some(Timespec::now(libc::CLOCK_MONOTONIC).checked_add_duration(&d)?))\n+        .and_then(|t| t.to_timespec());\n \n     loop {\n         // No need to wait if the value already changed.\n@@ -41,7 +42,7 @@ pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -\n                     // identical. It supports absolute timeouts through a flag\n                     // in the _umtx_time struct.\n                     let umtx_timeout = timespec.map(|t| libc::_umtx_time {\n-                        _timeout: t.t,\n+                        _timeout: t,\n                         _flags: libc::UMTX_ABSTIME,\n                         _clockid: libc::CLOCK_MONOTONIC as u32,\n                     });\n@@ -62,7 +63,7 @@ pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -\n                         futex as *const AtomicU32,\n                         libc::FUTEX_WAIT_BITSET | libc::FUTEX_PRIVATE_FLAG,\n                         expected,\n-                        timespec.as_ref().map_or(null(), |t| &t.t as *const libc::timespec),\n+                        timespec.as_ref().map_or(null(), |t| t as *const libc::timespec),\n                         null::<u32>(), // This argument is unused for FUTEX_WAIT_BITSET.\n                         !0u32,         // A full bitmask, to make it behave like a regular FUTEX_WAIT.\n                     )"}, {"sha": "30ed2ec7f5442964b1addc4c2a374ff36a2e721f", "filename": "library/std/src/sys/unix/thread_parker.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bee923f0df0e4a568811e24dc74af77c464d10f3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bee923f0df0e4a568811e24dc74af77c464d10f3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs?ref=bee923f0df0e4a568811e24dc74af77c464d10f3", "patch": "@@ -79,7 +79,8 @@ unsafe fn wait_timeout(\n         (Timespec::now(libc::CLOCK_MONOTONIC), dur)\n     };\n \n-    let timeout = now.checked_add_duration(&dur).map(|t| t.t).unwrap_or(TIMESPEC_MAX);\n+    let timeout =\n+        now.checked_add_duration(&dur).and_then(|t| t.to_timespec()).unwrap_or(TIMESPEC_MAX);\n     let r = libc::pthread_cond_timedwait(cond, lock, &timeout);\n     debug_assert!(r == libc::ETIMEDOUT || r == 0);\n }"}, {"sha": "6cf068483996d41979c2e9ec3e6aebef7881a492", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 58, "deletions": 62, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/bee923f0df0e4a568811e24dc74af77c464d10f3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bee923f0df0e4a568811e24dc74af77c464d10f3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=bee923f0df0e4a568811e24dc74af77c464d10f3", "patch": "@@ -1,44 +1,46 @@\n-use crate::cmp::Ordering;\n use crate::time::Duration;\n \n-use core::hash::{Hash, Hasher};\n-\n pub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\n use crate::convert::TryInto;\n \n const NSEC_PER_SEC: u64 = 1_000_000_000;\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub(in crate::sys::unix) struct Timespec {\n-    pub t: libc::timespec,\n+    tv_sec: i64,\n+    tv_nsec: i64,\n }\n \n impl Timespec {\n     const fn zero() -> Timespec {\n-        Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } }\n+        Timespec { tv_sec: 0, tv_nsec: 0 }\n+    }\n+\n+    fn new(tv_sec: i64, tv_nsec: i64) -> Timespec {\n+        Timespec { tv_sec, tv_nsec }\n     }\n \n     pub fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n         if self >= other {\n             // NOTE(eddyb) two aspects of this `if`-`else` are required for LLVM\n             // to optimize it into a branchless form (see also #75545):\n             //\n-            // 1. `self.t.tv_sec - other.t.tv_sec` shows up as a common expression\n+            // 1. `self.tv_sec - other.tv_sec` shows up as a common expression\n             //    in both branches, i.e. the `else` must have its `- 1`\n             //    subtraction after the common one, not interleaved with it\n-            //    (it used to be `self.t.tv_sec - 1 - other.t.tv_sec`)\n+            //    (it used to be `self.tv_sec - 1 - other.tv_sec`)\n             //\n             // 2. the `Duration::new` call (or any other additional complexity)\n             //    is outside of the `if`-`else`, not duplicated in both branches\n             //\n             // Ideally this code could be rearranged such that it more\n             // directly expresses the lower-cost behavior we want from it.\n-            let (secs, nsec) = if self.t.tv_nsec >= other.t.tv_nsec {\n-                ((self.t.tv_sec - other.t.tv_sec) as u64, (self.t.tv_nsec - other.t.tv_nsec) as u32)\n+            let (secs, nsec) = if self.tv_nsec >= other.tv_nsec {\n+                ((self.tv_sec - other.tv_sec) as u64, (self.tv_nsec - other.tv_nsec) as u32)\n             } else {\n                 (\n-                    (self.t.tv_sec - other.t.tv_sec - 1) as u64,\n-                    self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.t.tv_nsec as u32,\n+                    (self.tv_sec - other.tv_sec - 1) as u64,\n+                    self.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.tv_nsec as u32,\n                 )\n             };\n \n@@ -54,63 +56,34 @@ impl Timespec {\n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n         let mut secs = other\n             .as_secs()\n-            .try_into() // <- target type would be `libc::time_t`\n+            .try_into() // <- target type would be `i64`\n             .ok()\n-            .and_then(|secs| self.t.tv_sec.checked_add(secs))?;\n+            .and_then(|secs| self.tv_sec.checked_add(secs))?;\n \n         // Nano calculations can't overflow because nanos are <1B which fit\n         // in a u32.\n-        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n+        let mut nsec = other.subsec_nanos() + self.tv_nsec as u32;\n         if nsec >= NSEC_PER_SEC as u32 {\n             nsec -= NSEC_PER_SEC as u32;\n             secs = secs.checked_add(1)?;\n         }\n-        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n+        Some(Timespec::new(secs, nsec as i64))\n     }\n \n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n         let mut secs = other\n             .as_secs()\n-            .try_into() // <- target type would be `libc::time_t`\n+            .try_into() // <- target type would be `i64`\n             .ok()\n-            .and_then(|secs| self.t.tv_sec.checked_sub(secs))?;\n+            .and_then(|secs| self.tv_sec.checked_sub(secs))?;\n \n         // Similar to above, nanos can't overflow.\n-        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n+        let mut nsec = self.tv_nsec as i32 - other.subsec_nanos() as i32;\n         if nsec < 0 {\n             nsec += NSEC_PER_SEC as i32;\n             secs = secs.checked_sub(1)?;\n         }\n-        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n-    }\n-}\n-\n-impl PartialEq for Timespec {\n-    fn eq(&self, other: &Timespec) -> bool {\n-        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n-    }\n-}\n-\n-impl Eq for Timespec {}\n-\n-impl PartialOrd for Timespec {\n-    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl Ord for Timespec {\n-    fn cmp(&self, other: &Timespec) -> Ordering {\n-        let me = (self.t.tv_sec, self.t.tv_nsec);\n-        let other = (other.t.tv_sec, other.t.tv_nsec);\n-        me.cmp(&other)\n-    }\n-}\n-\n-impl Hash for Timespec {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.t.tv_sec.hash(state);\n-        self.t.tv_nsec.hash(state);\n+        Some(Timespec::new(secs, nsec as i64))\n     }\n }\n \n@@ -192,26 +165,35 @@ mod inner {\n         }\n     }\n \n+    impl From<libc::timeval> for Timespec {\n+        fn from(t: libc::timeval) -> Timespec {\n+            Timespec::new(t.tv_sec as i64, 1000 * t.tv_usec as i64)\n+        }\n+    }\n+\n     impl From<libc::timeval> for SystemTime {\n         fn from(t: libc::timeval) -> SystemTime {\n-            SystemTime::from(libc::timespec {\n-                tv_sec: t.tv_sec,\n-                tv_nsec: (t.tv_usec * 1000) as libc::c_long,\n-            })\n+            SystemTime { t: Timespec::from(t) }\n+        }\n+    }\n+\n+    impl From<libc::timespec> for Timespec {\n+        fn from(t: libc::timespec) -> Timespec {\n+            Timespec::new(t.tv_sec as i64, t.tv_nsec as i64)\n         }\n     }\n \n     impl From<libc::timespec> for SystemTime {\n         fn from(t: libc::timespec) -> SystemTime {\n-            SystemTime { t: Timespec { t } }\n+            SystemTime { t: Timespec::from(t) }\n         }\n     }\n \n     impl fmt::Debug for SystemTime {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             f.debug_struct(\"SystemTime\")\n-                .field(\"tv_sec\", &self.t.t.tv_sec)\n-                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+                .field(\"tv_sec\", &self.t.tv_sec)\n+                .field(\"tv_nsec\", &self.t.tv_nsec)\n                 .finish()\n         }\n     }\n@@ -305,8 +287,8 @@ mod inner {\n     impl fmt::Debug for Instant {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             f.debug_struct(\"Instant\")\n-                .field(\"tv_sec\", &self.t.t.tv_sec)\n-                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+                .field(\"tv_sec\", &self.t.tv_sec)\n+                .field(\"tv_nsec\", &self.t.tv_nsec)\n                 .finish()\n         }\n     }\n@@ -329,17 +311,23 @@ mod inner {\n         }\n     }\n \n+    impl From<libc::timespec> for Timespec {\n+        fn from(t: libc::timespec) -> Timespec {\n+            Timespec::new(t.tv_sec as i64, t.tv_nsec as i64)\n+        }\n+    }\n+\n     impl From<libc::timespec> for SystemTime {\n         fn from(t: libc::timespec) -> SystemTime {\n-            SystemTime { t: Timespec { t } }\n+            SystemTime { t: Timespec::from(t) }\n         }\n     }\n \n     impl fmt::Debug for SystemTime {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             f.debug_struct(\"SystemTime\")\n-                .field(\"tv_sec\", &self.t.t.tv_sec)\n-                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+                .field(\"tv_sec\", &self.t.tv_sec)\n+                .field(\"tv_nsec\", &self.t.tv_nsec)\n                 .finish()\n         }\n     }\n@@ -353,7 +341,15 @@ mod inner {\n         pub fn now(clock: clock_t) -> Timespec {\n             let mut t = MaybeUninit::uninit();\n             cvt(unsafe { libc::clock_gettime(clock, t.as_mut_ptr()) }).unwrap();\n-            Timespec { t: unsafe { t.assume_init() } }\n+            Timespec::from(unsafe { t.assume_init() })\n+        }\n+\n+        pub fn to_timespec(&self) -> Option<libc::timespec> {\n+            use crate::convert::TryInto;\n+            Some(libc::timespec {\n+                tv_sec: self.tv_sec.try_into().ok()?,\n+                tv_nsec: self.tv_nsec.try_into().ok()?,\n+            })\n         }\n     }\n }"}]}