{"sha": "aa645f30dae329a88e84f9e7ccc417ec9640e55a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNjQ1ZjMwZGFlMzI5YTg4ZTg0ZjllN2NjYzQxN2VjOTY0MGU1NWE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-24T12:40:55Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-27T16:12:49Z"}, "message": "Clean up function calling\n\nStill not as clean as I'd like it, but better", "tree": {"sha": "615b6b53f97cd98f18dc53edf697fd1cf15be00c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/615b6b53f97cd98f18dc53edf697fd1cf15be00c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa645f30dae329a88e84f9e7ccc417ec9640e55a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa645f30dae329a88e84f9e7ccc417ec9640e55a", "html_url": "https://github.com/rust-lang/rust/commit/aa645f30dae329a88e84f9e7ccc417ec9640e55a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa645f30dae329a88e84f9e7ccc417ec9640e55a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66d64babedbe37e94e80e1812f97847def743f4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/66d64babedbe37e94e80e1812f97847def743f4d", "html_url": "https://github.com/rust-lang/rust/commit/66d64babedbe37e94e80e1812f97847def743f4d"}], "stats": {"total": 217, "additions": 99, "deletions": 118}, "files": [{"sha": "e592f1e5d5a3dc02ee4a06765372db8485c49669", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa645f30dae329a88e84f9e7ccc417ec9640e55a/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa645f30dae329a88e84f9e7ccc417ec9640e55a/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=aa645f30dae329a88e84f9e7ccc417ec9640e55a", "patch": "@@ -43,25 +43,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             _ => (instance, place),\n         };\n \n-        let fn_sig = instance.ty(*self.tcx).fn_sig(*self.tcx);\n-        let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n-\n         let arg = OpTy {\n             op: Operand::Immediate(place.to_ref(&self)),\n             layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         };\n \n-        // This should always be (), but getting it from the sig seems\n-        // easier than creating a layout of ().\n-        let dest = PlaceTy::null(&self, self.layout_of(fn_sig.output())?);\n+        let ty = self.tcx.mk_tup((&[] as &[ty::Ty<'tcx>]).iter()); // return type is ()\n+        let dest = PlaceTy::null(&self, self.layout_of(ty)?);\n \n         self.eval_fn_call(\n             instance,\n             &[arg],\n             Some(dest),\n             Some(target),\n             span,\n-            fn_sig,\n+            None,\n         )\n     }\n }"}, {"sha": "5ec7313eb5ff468d5ad98b277a62ae17fa649f70", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 96, "deletions": 111, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/aa645f30dae329a88e84f9e7ccc417ec9640e55a/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa645f30dae329a88e84f9e7ccc417ec9640e55a/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=aa645f30dae329a88e84f9e7ccc417ec9640e55a", "patch": "@@ -15,9 +15,9 @@ use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, Scalar};\n-use super::{EvalContext, Machine, Value, OpTy, Place, PlaceTy, ValTy, Operand, StackPopCleanup};\n-\n-use rustc_data_structures::indexed_vec::Idx;\n+use super::{\n+    EvalContext, Machine, Value, OpTy, Place, PlaceTy, ValTy, Operand, StackPopCleanup\n+};\n \n mod drop;\n \n@@ -96,44 +96,44 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         let instance_ty = instance.ty(*self.tcx);\n                         match instance_ty.sty {\n                             ty::FnDef(..) => {\n-                                let real_sig = instance_ty.fn_sig(*self.tcx);\n                                 let sig = self.tcx.normalize_erasing_late_bound_regions(\n-                                    ty::ParamEnv::reveal_all(),\n+                                    self.param_env,\n                                     &sig,\n                                 );\n+                                let real_sig = instance_ty.fn_sig(*self.tcx);\n                                 let real_sig = self.tcx.normalize_erasing_late_bound_regions(\n-                                    ty::ParamEnv::reveal_all(),\n+                                    self.param_env,\n                                     &real_sig,\n                                 );\n                                 if !self.check_sig_compat(sig, real_sig)? {\n                                     return err!(FunctionPointerTyMismatch(real_sig, sig));\n                                 }\n+                                (instance, sig)\n                             }\n                             ref other => bug!(\"instance def ty: {:?}\", other),\n                         }\n-                        (instance, sig)\n                     }\n-                    ty::FnDef(def_id, substs) => (\n-                        self.resolve(def_id, substs)?,\n-                        func.layout.ty.fn_sig(*self.tcx),\n-                    ),\n+                    ty::FnDef(def_id, substs) => {\n+                        let sig = func.layout.ty.fn_sig(*self.tcx);\n+                        let sig = self.tcx.normalize_erasing_late_bound_regions(\n+                            self.param_env,\n+                            &sig,\n+                        );\n+                        (self.resolve(def_id, substs)?, sig)\n+                    },\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n                         return err!(Unimplemented(msg));\n                     }\n                 };\n                 let args = self.eval_operands(args)?;\n-                let sig = self.tcx.normalize_erasing_late_bound_regions(\n-                    ty::ParamEnv::reveal_all(),\n-                    &sig,\n-                );\n                 self.eval_fn_call(\n                     fn_def,\n                     &args[..],\n                     dest,\n                     ret,\n                     terminator.source_info.span,\n-                    sig,\n+                    Some(sig),\n                 )?;\n             }\n \n@@ -275,19 +275,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         return Ok(false);\n     }\n \n+    /// Call this function -- pushing the stack frame and initializing the arguments.\n+    /// `sig` is ptional in case of FnPtr/FnDef -- but mandatory for closures!\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: Option<PlaceTy<'tcx>>,\n         ret: Option<mir::BasicBlock>,\n         span: Span,\n-        sig: ty::FnSig<'tcx>,\n+        sig: Option<ty::FnSig<'tcx>>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", instance);\n-        if let Some(place) = dest {\n-            assert_eq!(place.layout.ty, sig.output());\n-        }\n+\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n                 // The intrinsic itself cannot diverge, so if we got here without a return\n@@ -303,58 +303,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 self.dump_place(*dest);\n                 Ok(())\n             }\n-            // FIXME: figure out why we can't just go through the shim\n-            ty::InstanceDef::ClosureOnceShim { .. } => {\n-                let mir = match M::find_fn(self, instance, args, dest, ret)? {\n-                    Some(mir) => mir,\n-                    None => return Ok(()),\n-                };\n-\n-                let return_place = match dest {\n-                    Some(place) => *place,\n-                    None => Place::null(&self),\n-                };\n-                self.push_stack_frame(\n-                    instance,\n-                    span,\n-                    mir,\n-                    return_place,\n-                    StackPopCleanup::Goto(ret),\n-                )?;\n-\n-                // Pass the arguments\n-                let mut arg_locals = self.frame().mir.args_iter();\n-                match sig.abi {\n-                    // closure as closure once\n-                    Abi::RustCall => {\n-                        for (arg_local, &op) in arg_locals.zip(args) {\n-                            let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                            self.copy_op(op, dest)?;\n-                        }\n-                    }\n-                    // non capture closure as fn ptr\n-                    // need to inject zst ptr for closure object (aka do nothing)\n-                    // and need to pack arguments\n-                    Abi::Rust => {\n-                        trace!(\n-                            \"args: {:#?}\",\n-                            self.frame().mir.args_iter().zip(args.iter())\n-                                .map(|(local, arg)| (local, **arg, arg.layout.ty))\n-                                .collect::<Vec<_>>()\n-                        );\n-                        let local = arg_locals.nth(1).unwrap();\n-                        for (i, &op) in args.into_iter().enumerate() {\n-                            let dest = self.eval_place(&mir::Place::Local(local).field(\n-                                mir::Field::new(i),\n-                                op.layout.ty,\n-                            ))?;\n-                            self.copy_op(op, dest)?;\n-                        }\n-                    }\n-                    _ => bug!(\"bad ABI for ClosureOnceShim: {:?}\", sig.abi),\n-                }\n-                Ok(())\n-            }\n+            ty::InstanceDef::ClosureOnceShim { .. } |\n             ty::InstanceDef::FnPtrShim(..) |\n             ty::InstanceDef::DropGlue(..) |\n             ty::InstanceDef::CloneShim(..) |\n@@ -376,58 +325,94 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     StackPopCleanup::Goto(ret),\n                 )?;\n \n-                // Pass the arguments\n-                let mut arg_locals = self.frame().mir.args_iter();\n+                // If we didn't get a signture, ask `fn_sig`\n+                let sig = sig.unwrap_or_else(|| {\n+                    let fn_sig = instance.ty(*self.tcx).fn_sig(*self.tcx);\n+                    self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig)\n+                });\n+                assert_eq!(sig.inputs().len(), args.len());\n+                // We can't test the types, as it is fine if the types are ABI-compatible but\n+                // not equal.\n+\n+                // Figure out how to pass which arguments.\n+                // FIXME: Somehow this is horribly full of special cases here, and codegen has\n+                // none of that.  What is going on?\n                 trace!(\"ABI: {:?}\", sig.abi);\n                 trace!(\n                     \"args: {:#?}\",\n-                    self.frame().mir.args_iter().zip(args.iter())\n-                        .map(|(local, arg)| (local, **arg, arg.layout.ty)).collect::<Vec<_>>()\n+                    args.iter()\n+                        .map(|arg| (arg.layout.ty, format!(\"{:?}\", **arg)))\n+                        .collect::<Vec<_>>()\n                 );\n-                match sig.abi {\n-                    Abi::RustCall => {\n-                        assert_eq!(args.len(), 2);\n-\n-                        {\n-                            // write first argument\n-                            let first_local = arg_locals.next().unwrap();\n-                            let dest = self.eval_place(&mir::Place::Local(first_local))?;\n-                            self.copy_op(args[0], dest)?;\n+                trace!(\n+                    \"locals: {:#?}\",\n+                    mir.args_iter()\n+                        .map(|local|\n+                            (local, self.layout_of_local(self.cur_frame(), local).unwrap().ty)\n+                        )\n+                        .collect::<Vec<_>>()\n+                );\n+                match instance.def {\n+                    ty::InstanceDef::ClosureOnceShim { .. } if sig.abi == Abi::Rust => {\n+                        // this has an entirely ridicolous calling convention where it uses the\n+                        // \"Rust\" ABI, but arguments come in untupled and are supposed to be tupled\n+                        // for the callee!  The function's first argument is a ZST, and then\n+                        // there comes a tuple for the rest.\n+                        let mut arg_locals = mir.args_iter();\n+\n+                        {   // the ZST. nothing to write.\n+                            let arg_local = arg_locals.next().unwrap();\n+                            let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n+                            assert!(dest.layout.is_zst());\n                         }\n \n-                        // unpack and write all other args\n-                        let layout = args[1].layout;\n-                        if let ty::Tuple(_) = layout.ty.sty {\n-                            if layout.is_zst() {\n-                                // Nothing to do, no need to unpack zsts\n-                                return Ok(());\n-                            }\n-                            if self.frame().mir.args_iter().count() == layout.fields.count() + 1 {\n-                                for (i, arg_local) in arg_locals.enumerate() {\n-                                    let arg = self.operand_field(args[1], i as u64)?;\n-                                    let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                                    self.copy_op(arg, dest)?;\n-                                }\n-                            } else {\n-                                trace!(\"manual impl of rust-call ABI\");\n-                                // called a manual impl of a rust-call function\n-                                let dest = self.eval_place(\n-                                    &mir::Place::Local(arg_locals.next().unwrap()),\n-                                )?;\n-                                self.copy_op(args[1], dest)?;\n+                        {   // the tuple argument.\n+                            let arg_local = arg_locals.next().unwrap();\n+                            let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n+                            assert_eq!(dest.layout.fields.count(), args.len());\n+                            for (i, &op) in args.iter().enumerate() {\n+                                let dest_field = self.place_field(dest, i as u64)?;\n+                                self.copy_op(op, dest_field)?;\n                             }\n-                        } else {\n-                            bug!(\n-                                \"rust-call ABI tuple argument was {:#?}\",\n-                                layout\n-                            );\n                         }\n+\n+                        // that should be it\n+                        assert!(arg_locals.next().is_none());\n                     }\n                     _ => {\n-                        for (arg_local, &op) in arg_locals.zip(args) {\n+                        // overloaded-calls-simple.rs in miri's test suite demomstrates that there is\n+                        // no way to predict, from the ABI and instance.def, whether the function\n+                        // wants arguments passed with untupling or not.  So we just make it\n+                        // depend on the number of arguments...\n+                        let untuple =\n+                            sig.abi == Abi::RustCall && !args.is_empty() && args.len() != mir.arg_count;\n+                        let (normal_args, untuple_arg) = if untuple {\n+                            let (tup, args) = args.split_last().unwrap();\n+                            trace!(\"eval_fn_call: Will pass last argument by untupling\");\n+                            (args, Some(tup))\n+                        } else {\n+                            (&args[..], None)\n+                        };\n+\n+                        // Pass the arguments.\n+                        let mut arg_locals = mir.args_iter();\n+                        // First the normal ones.\n+                        for &op in normal_args {\n+                            let arg_local = arg_locals.next().unwrap();\n                             let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n                             self.copy_op(op, dest)?;\n                         }\n+                        // The the ones to untuple.\n+                        if let Some(&untuple_arg) = untuple_arg {\n+                            for i in 0..untuple_arg.layout.fields.count() {\n+                                let arg_local = arg_locals.next().unwrap();\n+                                let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n+                                let op = self.operand_field(untuple_arg, i as u64)?;\n+                                self.copy_op(op, dest)?;\n+                            }\n+                        }\n+                        // That should be it.\n+                        assert!(arg_locals.next().is_none());\n                     }\n                 }\n                 Ok(())"}]}