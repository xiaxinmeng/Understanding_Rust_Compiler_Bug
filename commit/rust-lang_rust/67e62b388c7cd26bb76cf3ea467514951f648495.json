{"sha": "67e62b388c7cd26bb76cf3ea467514951f648495", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZTYyYjM4OGM3Y2QyNmJiNzZjZjNlYTQ2NzUxNDk1MWY2NDg0OTU=", "commit": {"author": {"name": "Zack Corr", "email": "zackcorr95@gmail.com", "date": "2012-06-07T10:33:04Z"}, "committer": {"name": "Zack Corr", "email": "zackcorr95@gmail.com", "date": "2012-06-07T10:33:04Z"}, "message": "Cargo: Added experimental dependency support (solves from crate files)", "tree": {"sha": "d7f466d43d1fe32927f185e730f8a8227438eafe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7f466d43d1fe32927f185e730f8a8227438eafe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67e62b388c7cd26bb76cf3ea467514951f648495", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67e62b388c7cd26bb76cf3ea467514951f648495", "html_url": "https://github.com/rust-lang/rust/commit/67e62b388c7cd26bb76cf3ea467514951f648495", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67e62b388c7cd26bb76cf3ea467514951f648495/comments", "author": {"login": "z0w0", "id": 676417, "node_id": "MDQ6VXNlcjY3NjQxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/676417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/z0w0", "html_url": "https://github.com/z0w0", "followers_url": "https://api.github.com/users/z0w0/followers", "following_url": "https://api.github.com/users/z0w0/following{/other_user}", "gists_url": "https://api.github.com/users/z0w0/gists{/gist_id}", "starred_url": "https://api.github.com/users/z0w0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/z0w0/subscriptions", "organizations_url": "https://api.github.com/users/z0w0/orgs", "repos_url": "https://api.github.com/users/z0w0/repos", "events_url": "https://api.github.com/users/z0w0/events{/privacy}", "received_events_url": "https://api.github.com/users/z0w0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "z0w0", "id": 676417, "node_id": "MDQ6VXNlcjY3NjQxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/676417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/z0w0", "html_url": "https://github.com/z0w0", "followers_url": "https://api.github.com/users/z0w0/followers", "following_url": "https://api.github.com/users/z0w0/following{/other_user}", "gists_url": "https://api.github.com/users/z0w0/gists{/gist_id}", "starred_url": "https://api.github.com/users/z0w0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/z0w0/subscriptions", "organizations_url": "https://api.github.com/users/z0w0/orgs", "repos_url": "https://api.github.com/users/z0w0/repos", "events_url": "https://api.github.com/users/z0w0/events{/privacy}", "received_events_url": "https://api.github.com/users/z0w0/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9187406da5ce8a6b4bfca6ee017e56230be0872c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9187406da5ce8a6b4bfca6ee017e56230be0872c", "html_url": "https://github.com/rust-lang/rust/commit/9187406da5ce8a6b4bfca6ee017e56230be0872c"}], "stats": {"total": 386, "additions": 291, "deletions": 95}, "files": [{"sha": "4ce3dc35ad46116423e362426d23f8c551c722fa", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 291, "deletions": 95, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/67e62b388c7cd26bb76cf3ea467514951f648495/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e62b388c7cd26bb76cf3ea467514951f648495/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=67e62b388c7cd26bb76cf3ea467514951f648495", "patch": "@@ -1,7 +1,8 @@\n // cargo.rs - Rust package manager\n \n-import syntax::{ast, codemap};\n-import syntax::parse;\n+import syntax::{ast, codemap, parse, visit, attr};\n+import syntax::diagnostic::span_handler;\n+import codemap::span;\n import rustc::metadata::filesearch::{get_cargo_root, get_cargo_root_nearest,\n                                      get_cargo_sysroot, libdir};\n import syntax::diagnostic;\n@@ -22,7 +23,15 @@ type package = {\n     mut method: str,\n     mut description: str,\n     mut ref: option<str>,\n-    mut tags: [str]\n+    mut tags: [str],\n+    mut versions: [(str, str)]\n+};\n+\n+type local_package = {\n+    mut name: str,\n+    mut metaname: str,\n+    mut version: str,\n+    mut files: [str]\n };\n \n type source = {\n@@ -43,16 +52,19 @@ type cargo = {\n     workdir: str,\n     sourcedir: str,\n     sources: map::hashmap<str, source>,\n+    mut current_install: str,\n+    dep_cache: map::hashmap<str, bool>,\n     opts: options\n };\n \n-type pkg = {\n+type crate = {\n     mut name: str,\n     mut vers: str,\n     mut uuid: str,\n     mut desc: option<str>,\n     mut sigs: option<str>,\n-    mut crate_type: option<str>\n+    mut crate_type: option<str>,\n+    mut deps: [str]\n };\n \n type options = {\n@@ -160,8 +172,17 @@ fn test_is_uuid() {\n fn has_archive_extension(p: str) -> bool {\n     str::ends_with(p, \".tar\") ||\n     str::ends_with(p, \".tar.gz\") ||\n+    str::ends_with(p, \".tar.bz2\") ||\n+    str::ends_with(p, \".tar.Z\") ||\n+    str::ends_with(p, \".tar.lz\") ||\n     str::ends_with(p, \".tar.xz\") ||\n-    str::ends_with(p, \".tar.bz2\")\n+    str::ends_with(p, \".tgz\") ||\n+    str::ends_with(p, \".tbz\") ||\n+    str::ends_with(p, \".tbz2\") ||\n+    str::ends_with(p, \".tb2\") ||\n+    str::ends_with(p, \".taz\") ||\n+    str::ends_with(p, \".tlz\") ||\n+    str::ends_with(p, \".txz\")\n }\n \n fn is_archive_path(u: str) -> bool {\n@@ -186,7 +207,9 @@ fn is_git_url(url: str) -> bool {\n }\n \n fn assume_source_method(url: str) -> str {\n-    if is_git_url(url) { ret \"git\"; }\n+    if is_git_url(url) {\n+        ret \"git\";\n+    }\n     if str::starts_with(url, \"file://\") || os::path_exists(url) {\n         ret \"file\";\n     }\n@@ -216,7 +239,7 @@ fn load_link(mis: [@ast::meta_item]) -> (option<str>,\n     (name, vers, uuid)\n }\n \n-fn load_pkg(filename: str) -> option<pkg> {\n+fn load_crate(filename: str) -> option<crate> {\n     let cm = codemap::new_codemap();\n     let handler = diagnostic::mk_handler(none);\n     let sess = @{\n@@ -253,9 +276,76 @@ fn load_pkg(filename: str) -> option<pkg> {\n                     uuid = u;\n                 }\n             }\n-            _ { fail \"load_pkg: pkg attributes may not contain meta_words\"; }\n+            _ {\n+                fail \"crate attributes may not contain \" +\n+                     \"meta_words\";\n+            }\n+        }\n+    }\n+\n+    type env = @{\n+        mut deps: [str]\n+    };\n+\n+    fn goto_view_item(e: env, i: @ast::view_item) {\n+        alt i.node {\n+            ast::view_item_use(ident, metas, id) {\n+                let name_items = attr::find_meta_items_by_name(metas, \"name\");\n+                let m = if name_items.is_empty() {\n+                    metas + [attr::mk_name_value_item_str(\"name\", ident)]\n+                } else {\n+                    metas\n+                };\n+                let mut attr_name = ident;\n+                let mut attr_vers = \"\";\n+                let mut attr_from = \"\";\n+\n+                for m.each { |item|\n+                    alt attr::get_meta_item_value_str(item) {\n+                        some(value) {\n+                            let name = attr::get_meta_item_name(item);\n+\n+                            alt name {\n+                                \"vers\" { attr_vers = value; }\n+                                \"from\" { attr_from = value; }\n+                                _ {}\n+                            }\n+                        }\n+                        none {}\n+                    }\n+                }\n+\n+                let query = if !str::is_empty(attr_from) {\n+                    attr_from\n+                } else {\n+                    if !str::is_empty(attr_vers) {\n+                        attr_name + \"@\" + attr_vers\n+                    } else { attr_name }\n+                };\n+\n+                alt attr_name {\n+                    \"std\" | \"core\" { }\n+                    _ { e.deps += [query]; }\n+                }\n+            }\n+            _ { }\n         }\n     }\n+    fn goto_item(_e: env, _i: @ast::item) {\n+    }\n+\n+    let e = @{\n+        mut deps: []\n+    };\n+    let v = visit::mk_simple_visitor(@{\n+        visit_view_item: bind goto_view_item(e, _),\n+        visit_item: bind goto_item(e, _),\n+        with *visit::default_simple_visitor()\n+    });\n+\n+    visit::visit_crate(*c, (), v);\n+\n+    let deps = copy e.deps;\n \n     alt (name, vers, uuid) {\n         (some(name0), some(vers0), some(uuid0)) {\n@@ -265,7 +355,8 @@ fn load_pkg(filename: str) -> option<pkg> {\n                 mut uuid: uuid0,\n                 mut desc: desc,\n                 mut sigs: sigs,\n-                mut crate_type: crate_type})\n+                mut crate_type: crate_type,\n+                mut deps: deps })\n         }\n         _ { ret none; }\n     }\n@@ -444,7 +535,8 @@ fn load_one_source_package(&src: source, p: map::hashmap<str, json::json>) {\n         mut method: method,\n         mut description: description,\n         mut ref: ref,\n-        mut tags: tags\n+        mut tags: tags,\n+        mut versions: []\n     };\n \n     for src.packages.each { |pkg|\n@@ -456,6 +548,7 @@ fn load_one_source_package(&src: source, p: map::hashmap<str, json::json>) {\n             pkg.description = newpkg.description;\n             pkg.ref = newpkg.ref;\n             pkg.tags = newpkg.tags;\n+            pkg.versions = newpkg.versions;\n             log(debug, \"  updated package: \" + src.name + \"/\" + name);\n             ret;\n         }\n@@ -565,6 +658,8 @@ fn configure(opts: options) -> cargo {\n     try_parse_sources(path::connect(home, \"sources.json\"), sources);\n     try_parse_sources(path::connect(home, \"local-sources.json\"), sources);\n \n+    let dep_cache = map::str_hash::<bool>();\n+\n     let mut c = {\n         pgp: pgp::supported(),\n         root: home,\n@@ -574,6 +669,8 @@ fn configure(opts: options) -> cargo {\n         workdir: path::connect(home, \"work\"),\n         sourcedir: path::connect(home, \"sources\"),\n         sources: sources,\n+        mut current_install: \"\",\n+        dep_cache: dep_cache,\n         opts: opts\n     };\n \n@@ -701,10 +798,23 @@ fn install_source(&c: cargo, path: str) {\n     }\n \n     for cratefiles.each {|cf|\n-        let p = load_pkg(cf);\n-        alt p {\n+        alt load_crate(cf) {\n             none { cont; }\n-            some(_) {\n+            some(crate) {\n+                for crate.deps.each { |query|\n+                    // TODO: handle cyclic dependencies\n+\n+                    let wd_base = c.workdir + path::path_sep();\n+                    let wd = alt tempfile::mkdtemp(wd_base, \"\") {\n+                        some(_wd) { _wd }\n+                        none { fail #fmt(\"needed temp dir: %s\", wd_base); }\n+                    };\n+\n+                    install_query(c, wd, query);\n+                }\n+\n+                os::change_dir(path);\n+\n                 if c.opts.test {\n                     test_one_crate(c, path, cf);\n                 }\n@@ -916,28 +1026,17 @@ fn cmd_uninstall(&c: cargo) {\n     }\n }\n \n-fn cmd_install(&c: cargo) unsafe {\n-    let wd_base = c.workdir + path::path_sep();\n-    let wd = alt tempfile::mkdtemp(wd_base, \"\") {\n-        some(_wd) { _wd }\n-        none { fail #fmt(\"needed temp dir: %s\", wd_base); }\n-    };\n-\n-    if vec::len(c.opts.free) == 2u {\n-        let cwd = os::getcwd();\n-        let status = run::run_program(\"cp\", [\"-R\", cwd, wd]);\n-\n-        if status != 0 {\n-            fail #fmt(\"could not copy directory: %s\", cwd);\n+fn install_query(&c: cargo, wd: str, target: str) {\n+    alt c.dep_cache.find(target) {\n+        some(_inst) {\n+            if _inst {\n+                ret;\n+            }\n         }\n-\n-        install_source(c, wd);\n-        ret;\n+        none {}\n     }\n \n-    sync(c);\n-\n-    let target = c.opts.free[2];\n+    c.dep_cache.insert(target, true);\n \n     if is_archive_path(target) {\n         install_file(c, wd, target);\n@@ -948,7 +1047,7 @@ fn cmd_install(&c: cargo) unsafe {\n         } else {\n             none\n         };\n-        install_git(c, wd, target, ref)\n+        install_git(c, wd, target, ref);\n     } else if !valid_pkg_name(target) && has_archive_extension(target) {\n         install_curl(c, wd, target);\n         ret;\n@@ -974,14 +1073,50 @@ fn cmd_install(&c: cargo) unsafe {\n             }\n         }\n     }\n+\n+    // FIXME: This whole dep_cache and current_install\n+    // thing is a bit of a hack. It should be cleaned up in the future.\n+\n+    if target == c.current_install {\n+        for c.dep_cache.each { |k, _v|\n+            c.dep_cache.remove(k);\n+        }\n+\n+        c.current_install = \"\";\n+    }\n+}\n+\n+fn cmd_install(&c: cargo) unsafe {\n+    let wd_base = c.workdir + path::path_sep();\n+    let wd = alt tempfile::mkdtemp(wd_base, \"\") {\n+        some(_wd) { _wd }\n+        none { fail #fmt(\"needed temp dir: %s\", wd_base); }\n+    };\n+\n+    if vec::len(c.opts.free) == 2u {\n+        let cwd = os::getcwd();\n+        let status = run::run_program(\"cp\", [\"-R\", cwd, wd]);\n+\n+        if status != 0 {\n+            fail #fmt(\"could not copy directory: %s\", cwd);\n+        }\n+\n+        install_source(c, wd);\n+        ret;\n+    }\n+\n+    sync(c);\n+\n+    let query = c.opts.free[2];\n+    c.current_install = copy query;\n+\n+    install_query(c, wd, copy query);\n }\n \n fn sync(&c: cargo) {\n     for c.sources.each_key { |k|\n         let mut s = c.sources.get(k);\n-\n         sync_one(c, s);\n-        // FIXME: mutability hack\n         c.sources.insert(k, s);\n     }\n }\n@@ -1302,13 +1437,13 @@ fn cmd_init(&c: cargo) {\n \n     let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", srcfile, srcurl]);\n     if p.status != 0 {\n-        warn(#fmt[\"fetch of sources.json failed: %s\", p.out]);\n+        error(#fmt[\"fetch of sources.json failed: %s\", p.out]);\n         ret;\n     }\n \n     let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", sigfile, sigurl]);\n     if p.status != 0 {\n-        warn(#fmt[\"fetch of sources.json.sig failed: %s\", p.out]);\n+        error(#fmt[\"fetch of sources.json.sig failed: %s\", p.out]);\n         ret;\n     }\n \n@@ -1416,17 +1551,21 @@ fn install_to_dir(srcfile: str, destdir: str) {\n     }\n }\n \n-fn dump_cache(c: cargo) {\n+fn dump_cache(&c: cargo) {\n     need_dir(c.root);\n \n     let out = path::connect(c.root, \"cache.json\");\n-    let root = json::dict(map::str_hash());\n+    let _root = json::dict(map::str_hash());\n \n     if os::path_exists(out) {\n         copy_warn(out, path::connect(c.root, \"cache.json.old\"));\n     }\n }\n-fn dump_sources(c: cargo) {\n+fn dump_sources(&c: cargo) {\n+    if c.sources.size() < 1u {\n+        ret;\n+    }\n+\n     need_dir(c.root);\n \n     let out = path::connect(c.root, \"sources.json\");\n@@ -1566,12 +1705,12 @@ fn cmd_sources(&c: cargo) {\n             alt c.sources.find(name) {\n                 some(source) {\n                     let old = copy source.url;\n+                    let method = assume_source_method(url);\n \n-                    source.url = if source.method == \"file\" {\n-                        os::make_absolute(url)\n-                    } else {\n-                        url\n-                    };\n+                    source.url = url;\n+                    source.method = method;\n+\n+                    c.sources.insert(name, source);\n \n                     info(#fmt(\"changed source url: '%s' to '%s'\", old, url));\n                 }\n@@ -1604,6 +1743,8 @@ fn cmd_sources(&c: cargo) {\n                         _ { \"curl\" }\n                     };\n \n+                    c.sources.insert(name, source);\n+\n                     info(#fmt(\"changed source method: '%s' to '%s'\", old,\n                          method));\n                 }\n@@ -1646,61 +1787,116 @@ fn cmd_sources(&c: cargo) {\n }\n \n fn cmd_usage() {\n-    print(\"Usage: cargo <verb> [options] [args..]\\n\" +\n-          \" e.g.: cargo [init | sync]\\n\" +\n-          \" e.g.: cargo install [-g | -G] <package>\n-\n-General:\n-    init                    Reinitialize cargo in ~/.cargo\n-    usage                   Display this message\n-\n-Querying:\n-    list [sources..]                        List the packages in sources\n-    search <name | '*'> [tags...]           Search packages\n-\n-Sources:\n-    sources                                 List sources\n-    sources add <name> <url>                Add a source\n-    sources remove <name>                   Remove a source\n-    sources rename <name> <new>             Rename a source\n-    sources set-url <name> <url>            Change the source URL\n-    sources set-method <name> <method>      Change the method (guesses from\n-                                            the URL by default) can be ;git',\n-                                            'file' or 'curl'\n-    sources clear                           Remove all sources\n-\n-Packages:\n-    install [options]                       Install a package from source\n-                                            code in the current directory\n-    install [options] [source/]<name>       Install a package by name\n-    install [options] [source/]<uuid>       Install a package by uuid\n-    install [options] <url>                 Install a package via curl (HTTP,\n-                                            FTP, etc.) from an\n-                                            .tar[.gz|bz2|xz] file\n-    install [options] <url> [ref]           Install a package via read-only\n-                                            git\n-    install [options] <file>                Install a package directly from an\n-                                            .tar[.gz|bz2|xz] file\n-    uninstall [options] [source/]<name>     Remove a package by [meta]name\n-    uninstall [options] [source/]<uuid>     Remove a package by [meta]uuid\n-\n-Package installation options:\n-    --test         Run crate tests before installing\n-\n-Package [un]installation options:\n-    -g              Work at the user level (~/.cargo/bin/ instead of\n-                    locally in ./.cargo/bin/ by default)\n-    -G              Work at the system level (/usr/local/lib/cargo/bin/)\n-\n-Other:\n-    -h, --help     Display this message\n+    print(\"Usage: cargo <cmd> [options] [args..]\n+e.g. cargo install <name>\n+\n+Where <cmd> is one of:\n+    init, install, list, search, sources,\n+    uninstall, usage\n+\n+Options:\n+\n+    -h, --help                  Display this message\n+    <cmd> -h, <cmd> --help      Display help for <cmd>\n \");\n }\n \n+fn cmd_usage_init() {\n+    print(\"cargo init\n+\n+Re-initialize cargo in ~/.cargo. Clears all sources and then adds the\n+default sources from <www.rust-lang.org/sources.json>.\");\n+}\n+\n+fn cmd_usage_install() {\n+    print(\"cargo install\n+cargo install [source/]<name>[@version]\n+cargo install [source/]<uuid>[@version]\n+cargo install <git url> [ref]\n+cargo install <tarball url>\n+cargo install <tarball file>\n+\n+Options:\n+    --test      Run crate tests before installing\n+    -g          Install to the user level (~/.cargo/bin/ instead of\n+                locally in ./.cargo/bin/ by default)\n+    -G          Install to the system level (/usr/local/lib/cargo/bin/)\n+\n+Install a crate. If no arguments are supplied, it installs from\n+the current working directory. If a source is provided, only install\n+from that source, otherwise it installs from any source.\");\n+}\n+\n+fn cmd_usage_uninstall() {\n+    print(\"cargo uninstall [source/]<name>[@version]\n+cargo uninstall [source/]<uuid>[@version]\n+cargo uninstall <meta-name>[@version]\n+cargo uninstall <meta-uuid>[@version]\n+\n+Options:\n+    -g          Remove from the user level (~/.cargo/bin/ instead of\n+                locally in ./.cargo/bin/ by default)\n+    -G          Remove from the system level (/usr/local/lib/cargo/bin/)\n+\n+Remove a crate. If a source is provided, only remove\n+from that source, otherwise it removes from any source.\n+If a crate was installed directly (git, tarball, etc.), you can remove\n+it by metadata.\");\n+}\n+\n+fn cmd_usage_list() {\n+    print(\"cargo list [sources..]\n+\n+If no arguments are provided, list all sources and their packages.\n+If source names are provided, list those sources and their packages.\n+\");\n+}\n+\n+fn cmd_usage_search() {\n+    print(\"cargo search <query | '*'> [tags..]\n+\n+Search packages.\");\n+}\n+\n+fn cmd_usage_sources() {\n+    print(\"cargo sources\n+cargo sources add <name> <url>\n+cargo sources remove <name>\n+cargo sources rename <name> <new>\n+cargo sources set-url <name> <url>\n+cargo sources set-method <name> <method>\n+\n+If no arguments are supplied, list all sources (but not their packages).\n+\n+Commands:\n+    add             Add a source. The source method will be guessed\n+                    from the URL.\n+    remove          Remove a source.\n+    rename          Rename a source.\n+    set-url         Change the URL for a source.\n+    set-method      Change the method for a source.\");\n+}\n+\n fn main(argv: [str]) {\n     let o = build_cargo_options(argv);\n \n-    if vec::len(o.free) < 2u || o.help {\n+    if vec::len(o.free) < 2u {\n+        cmd_usage();\n+        ret;\n+    }\n+    if o.help {\n+        alt o.free[1] {\n+            \"init\" { cmd_usage_init(); }\n+            \"install\" { cmd_usage_install(); }\n+            \"uninstall\" { cmd_usage_uninstall(); }\n+            \"list\" { cmd_usage_list(); }\n+            \"search\" { cmd_usage_search(); }\n+            \"sources\" { cmd_usage_sources(); }\n+            _ { cmd_usage(); }\n+        }\n+        ret;\n+    }\n+    if o.free[1] == \"usage\" {\n         cmd_usage();\n         ret;\n     }"}]}