{"sha": "13bb22a68b1170a9e75fba0d1ded528fd7fe5139", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzYmIyMmE2OGIxMTcwYTllNzVmYmEwZDFkZWQ1MjhmZDdmZTUxMzk=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-07T15:31:38Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-03-07T15:31:38Z"}, "message": "Remove all ExprRange\n\nRustup to rustc 1.9.0-nightly (998a6720b 2016-03-07)", "tree": {"sha": "154529757a8e77ec2bef7a9c606b3ed4446b5e2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/154529757a8e77ec2bef7a9c606b3ed4446b5e2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13bb22a68b1170a9e75fba0d1ded528fd7fe5139", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13bb22a68b1170a9e75fba0d1ded528fd7fe5139", "html_url": "https://github.com/rust-lang/rust/commit/13bb22a68b1170a9e75fba0d1ded528fd7fe5139", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb0a4934422941385a490ae9273ce8f6f05698e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb0a4934422941385a490ae9273ce8f6f05698e2", "html_url": "https://github.com/rust-lang/rust/commit/eb0a4934422941385a490ae9273ce8f6f05698e2"}], "stats": {"total": 170, "additions": 125, "deletions": 45}, "files": [{"sha": "723236c7ed73d99a321ed404ab619faeef13c04b", "filename": "src/loops.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=13bb22a68b1170a9e75fba0d1ded528fd7fe5139", "patch": "@@ -12,8 +12,10 @@ use std::borrow::Cow;\n use std::collections::HashMap;\n \n use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, in_external_macro,\n-            span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then, walk_ptrs_ty};\n+            span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then,\n+            unsugar_range, walk_ptrs_ty};\n use utils::{BTREEMAP_PATH, HASHMAP_PATH, LL_PATH, OPTION_PATH, RESULT_PATH, VEC_PATH};\n+use utils::UnsugaredRange;\n \n /// **What it does:** This lint checks for looping over the range of `0..len` of some collection just to get the values by index.\n ///\n@@ -323,10 +325,9 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n /// Check for looping over a range and then indexing a sequence with it.\n /// The iteratee must be a range literal.\n fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n-    if let ExprRange(Some(ref l), ref r) = arg.node {\n+    if let Some(UnsugaredRange { start: Some(ref start), ref end, .. }) = unsugar_range(&arg) {\n         // the var must be a single name\n         if let PatKind::Ident(_, ref ident, _) = pat.node {\n-\n             let mut visitor = VarVisitor {\n                 cx: cx,\n                 var: ident.node.name,\n@@ -348,19 +349,19 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n                     return;\n                 }\n \n-                let starts_at_zero = is_integer_literal(l, 0);\n+                let starts_at_zero = is_integer_literal(start, 0);\n \n                 let skip: Cow<_> = if starts_at_zero {\n                     \"\".into()\n                 } else {\n-                    format!(\".skip({})\", snippet(cx, l.span, \"..\")).into()\n+                    format!(\".skip({})\", snippet(cx, start.span, \"..\")).into()\n                 };\n \n-                let take: Cow<_> = if let Some(ref r) = *r {\n-                    if is_len_call(&r, &indexed) {\n+                let take: Cow<_> = if let Some(ref end) = *end {\n+                    if is_len_call(&end, &indexed) {\n                         \"\".into()\n                     } else {\n-                        format!(\".take({})\", snippet(cx, r.span, \"..\")).into()\n+                        format!(\".take({})\", snippet(cx, end.span, \"..\")).into()\n                     }\n                 } else {\n                     \"\".into()\n@@ -416,27 +417,27 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n \n fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n     // if this for loop is iterating over a two-sided range...\n-    if let ExprRange(Some(ref start_expr), Some(ref stop_expr)) = arg.node {\n+    if let Some(UnsugaredRange { start: Some(ref start), end: Some(ref end), .. }) = unsugar_range(&arg) {\n         // ...and both sides are compile-time constant integers...\n-        if let Ok(start_idx) = eval_const_expr_partial(&cx.tcx, start_expr, ExprTypeChecked, None) {\n-            if let Ok(stop_idx) = eval_const_expr_partial(&cx.tcx, stop_expr, ExprTypeChecked, None) {\n-                // ...and the start index is greater than the stop index,\n+        if let Ok(start_idx) = eval_const_expr_partial(&cx.tcx, start, ExprTypeChecked, None) {\n+            if let Ok(end_idx) = eval_const_expr_partial(&cx.tcx, end, ExprTypeChecked, None) {\n+                // ...and the start index is greater than the end index,\n                 // this loop will never run. This is often confusing for developers\n                 // who think that this will iterate from the larger value to the\n                 // smaller value.\n-                let (sup, eq) = match (start_idx, stop_idx) {\n-                    (ConstVal::Int(start_idx), ConstVal::Int(stop_idx)) => {\n-                        (start_idx > stop_idx, start_idx == stop_idx)\n+                let (sup, eq) = match (start_idx, end_idx) {\n+                    (ConstVal::Int(start_idx), ConstVal::Int(end_idx)) => {\n+                        (start_idx > end_idx, start_idx == end_idx)\n                     }\n-                    (ConstVal::Uint(start_idx), ConstVal::Uint(stop_idx)) => {\n-                        (start_idx > stop_idx, start_idx == stop_idx)\n+                    (ConstVal::Uint(start_idx), ConstVal::Uint(end_idx)) => {\n+                        (start_idx > end_idx, start_idx == end_idx)\n                     }\n                     _ => (false, false),\n                 };\n \n                 if sup {\n-                    let start_snippet = snippet(cx, start_expr.span, \"_\");\n-                    let stop_snippet = snippet(cx, stop_expr.span, \"_\");\n+                    let start_snippet = snippet(cx, start.span, \"_\");\n+                    let end_snippet = snippet(cx, end.span, \"_\");\n \n                     span_lint_and_then(cx,\n                                        REVERSE_RANGE_LOOP,\n@@ -447,7 +448,7 @@ fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n                                                               \"consider using the following if \\\n                                                                you are attempting to iterate \\\n                                                                over this range in reverse\",\n-                                                              format!(\"({}..{}).rev()` \", stop_snippet, start_snippet));\n+                                                              format!(\"({}..{}).rev()` \", end_snippet, start_snippet));\n                                        });\n                 } else if eq {\n                     // if they are equal, it's also problematic - this loop"}, {"sha": "59f7be94c2371219ac27ebc6dd9cb43f0c8a482e", "filename": "src/no_effect.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/src%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/src%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fno_effect.rs?ref=13bb22a68b1170a9e75fba0d1ded528fd7fe5139", "patch": "@@ -23,15 +23,11 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n     match expr.node {\n         Expr_::ExprLit(..) |\n         Expr_::ExprClosure(..) |\n-        Expr_::ExprRange(None, None) |\n         Expr_::ExprPath(..) => true,\n         Expr_::ExprIndex(ref a, ref b) |\n-        Expr_::ExprRange(Some(ref a), Some(ref b)) |\n         Expr_::ExprBinary(_, ref a, ref b) => has_no_effect(cx, a) && has_no_effect(cx, b),\n         Expr_::ExprVec(ref v) |\n         Expr_::ExprTup(ref v) => v.iter().all(|val| has_no_effect(cx, val)),\n-        Expr_::ExprRange(Some(ref inner), None) |\n-        Expr_::ExprRange(None, Some(ref inner)) |\n         Expr_::ExprRepeat(ref inner, _) |\n         Expr_::ExprCast(ref inner, _) |\n         Expr_::ExprType(ref inner, _) |\n@@ -55,6 +51,13 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n                 _ => false,\n             }\n         }\n+        Expr_::ExprBlock(ref block) => {\n+            block.stmts.is_empty() && if let Some(ref expr) = block.expr {\n+                has_no_effect(cx, expr)\n+            } else {\n+                false\n+            }\n+        }\n         _ => false,\n     }\n }"}, {"sha": "766d98b4e0b9fd331d07148855ce321e928f4229", "filename": "src/ranges.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=13bb22a68b1170a9e75fba0d1ded528fd7fe5139", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Spanned;\n-use utils::{is_integer_literal, match_type, snippet};\n+use utils::{is_integer_literal, match_type, snippet, unsugar_range, UnsugaredRange};\n \n /// **What it does:** This lint checks for iterating over ranges with a `.step_by(0)`, which never terminates.\n ///\n@@ -47,17 +47,17 @@ impl LateLintPass for StepByZero {\n                               instead\")\n             } else if name.as_str() == \"zip\" && args.len() == 2 {\n                 let iter = &args[0].node;\n-                let zip_arg = &args[1].node;\n+                let zip_arg = &args[1];\n                 if_let_chain! {\n                     [\n                         // .iter() call\n                         let ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = *iter,\n                         iter_name.as_str() == \"iter\",\n                         // range expression in .zip() call: 0..x.len()\n-                        let ExprRange(Some(ref from), Some(ref to)) = *zip_arg,\n-                        is_integer_literal(from, 0),\n+                        let Some(UnsugaredRange { start: Some(ref start), end: Some(ref end), .. }) = unsugar_range(zip_arg),\n+                        is_integer_literal(start, 0),\n                         // .len() call\n-                        let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = to.node,\n+                        let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,\n                         len_name.as_str() == \"len\" && len_args.len() == 1,\n                         // .iter() and .len() called on same Path\n                         let ExprPath(_, Path { segments: ref iter_path, .. }) = iter_args[0].node,"}, {"sha": "0bd054a839a7192ba9ed4cb04cbd97103e0cf917", "filename": "src/utils/hir.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=13bb22a68b1170a9e75fba0d1ded528fd7fe5139", "patch": "@@ -109,9 +109,6 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 !self.ignore_fn && lname.node == rname.node && ltys.is_empty() && rtys.is_empty() &&\n                 self.eq_exprs(largs, rargs)\n             }\n-            (&ExprRange(ref lb, ref le), &ExprRange(ref rb, ref re)) => {\n-                both(lb, rb, |l, r| self.eq_expr(l, r)) && both(le, re, |l, r| self.eq_expr(l, r))\n-            }\n             (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => self.eq_expr(le, re) && self.eq_expr(ll, rl),\n             (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n             (&ExprPath(ref lqself, ref lsubpath), &ExprPath(ref rqself, ref rsubpath)) => {\n@@ -384,16 +381,6 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_name(&name.node);\n                 self.hash_exprs(args);\n             }\n-            ExprRange(ref b, ref e) => {\n-                let c: fn(_, _) -> _ = ExprRange;\n-                c.hash(&mut self.s);\n-                if let Some(ref b) = *b {\n-                    self.hash_expr(b);\n-                }\n-                if let Some(ref e) = *e {\n-                    self.hash_expr(e);\n-                }\n-            }\n             ExprRepeat(ref e, ref l) => {\n                 let c: fn(_, _) -> _ = ExprRepeat;\n                 c.hash(&mut self.s);"}, {"sha": "b001d9530eddf0034995cbd9a129f4623fdcc9e4", "filename": "src/utils/mod.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=13bb22a68b1170a9e75fba0d1ded528fd7fe5139", "patch": "@@ -9,7 +9,7 @@ use std::borrow::Cow;\n use std::mem;\n use std::ops::{Deref, DerefMut};\n use std::str::FromStr;\n-use syntax::ast::{self, LitKind};\n+use syntax::ast::{self, LitKind, RangeLimits};\n use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n@@ -40,6 +40,12 @@ pub const LL_PATH: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedLis\n pub const MUTEX_PATH: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n pub const OPEN_OPTIONS_PATH: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const RANGE_FROM_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeFrom\"];\n+pub const RANGE_FULL_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeFull\"];\n+pub const RANGE_INCLUSIVE_NON_EMPTY_PATH: [&'static str; 4] = [\"std\", \"ops\", \"RangeInclusive\", \"NonEmpty\"];\n+pub const RANGE_PATH: [&'static str; 3] = [\"std\", \"ops\", \"Range\"];\n+pub const RANGE_TO_INCLUSIVE_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeToInclusive\"];\n+pub const RANGE_TO_PATH: [&'static str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n pub const REGEX_NEW_PATH: [&'static str; 3] = [\"regex\", \"Regex\", \"new\"];\n pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n@@ -673,3 +679,55 @@ pub fn camel_case_from(s: &str) -> usize {\n     }\n     last_i\n }\n+\n+/// Represents a range akin to `ast::ExprKind::Range`.\n+pub struct UnsugaredRange<'a> {\n+    pub start: Option<&'a Expr>,\n+    pub end: Option<&'a Expr>,\n+    pub limits: RangeLimits,\n+}\n+\n+/// Unsugar a `hir` range.\n+pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n+    // To be removed when ranges get stable.\n+    fn unwrap_unstable(expr: &Expr) -> &Expr {\n+        if let ExprBlock(ref block) = expr.node {\n+            if block.rules == BlockCheckMode::PushUnstableBlock || block.rules == BlockCheckMode::PopUnstableBlock {\n+                if let Some(ref expr) = block.expr {\n+                    return expr;\n+                }\n+            }\n+        }\n+\n+        expr\n+    }\n+\n+    fn get_field<'a>(name: &str, fields: &'a [Field]) -> Option<&'a Expr> {\n+        let expr = &fields.iter()\n+                          .find(|field| field.name.node.as_str() == name)\n+                          .unwrap_or_else(|| panic!(\"missing {} field for range\", name))\n+                          .expr;\n+\n+        Some(unwrap_unstable(expr))\n+    }\n+\n+    if let ExprStruct(ref path, ref fields, None) = unwrap_unstable(&expr).node {\n+        if match_path(path, &RANGE_FROM_PATH) {\n+            Some(UnsugaredRange { start: get_field(\"start\", fields), end: None, limits: RangeLimits::HalfOpen })\n+        } else if match_path(path, &RANGE_FULL_PATH) {\n+            Some(UnsugaredRange { start: None, end: None, limits: RangeLimits::HalfOpen })\n+        } else if match_path(path, &RANGE_INCLUSIVE_NON_EMPTY_PATH) {\n+            Some(UnsugaredRange { start: get_field(\"start\", fields), end: get_field(\"end\", fields), limits: RangeLimits::Closed })\n+        } else if match_path(path, &RANGE_PATH) {\n+            Some(UnsugaredRange { start: get_field(\"start\", fields), end: get_field(\"end\", fields), limits: RangeLimits::HalfOpen })\n+        } else if match_path(path, &RANGE_TO_INCLUSIVE_PATH) {\n+            Some(UnsugaredRange { start: None, end: get_field(\"end\", fields), limits: RangeLimits::Closed })\n+        } else if match_path(path, &RANGE_TO_PATH) {\n+            Some(UnsugaredRange { start: None, end: get_field(\"end\", fields), limits: RangeLimits::HalfOpen })\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "c1e1ba68b3e71d2659ff670ed8da045f91dd666d", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=13bb22a68b1170a9e75fba0d1ded528fd7fe5139", "patch": "@@ -1,4 +1,4 @@\n-#![feature(plugin)]\n+#![feature(plugin, inclusive_range_syntax)]\n #![plugin(clippy)]\n \n #![allow(dead_code, no_effect)]\n@@ -10,16 +10,46 @@\n fn bar<T>(_: T) {}\n fn foo() -> bool { unimplemented!() }\n \n+struct Foo {\n+    bar: u8,\n+}\n+\n #[deny(if_same_then_else)]\n #[deny(match_same_arms)]\n fn if_same_then_else() -> Result<&'static str, ()> {\n     if true {\n+        Foo { bar: 42 };\n+        0..10;\n+        ..;\n+        0..;\n+        ..10;\n+        0...10;\n         foo();\n     }\n     else { //~ERROR this `if` has identical blocks\n+        Foo { bar: 42 };\n+        0..10;\n+        ..;\n+        0..;\n+        ..10;\n+        0...10;\n         foo();\n     }\n \n+    if true {\n+        Foo { bar: 42 };\n+    }\n+    else {\n+        Foo { bar: 43 };\n+    }\n+\n+    if true {\n+        0..10;\n+    }\n+    else {\n+        0...10;\n+    }\n+\n     if true {\n         foo();\n         foo();"}, {"sha": "344c82f3307568fe2c20572bf37d9551438a134e", "filename": "tests/compile-fail/no_effect.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/tests%2Fcompile-fail%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13bb22a68b1170a9e75fba0d1ded528fd7fe5139/tests%2Fcompile-fail%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fno_effect.rs?ref=13bb22a68b1170a9e75fba0d1ded528fd7fe5139", "patch": "@@ -1,4 +1,4 @@\n-#![feature(plugin, box_syntax)]\n+#![feature(plugin, box_syntax, inclusive_range_syntax)]\n #![plugin(clippy)]\n \n #![deny(no_effect)]\n@@ -39,6 +39,7 @@ fn main() {\n     5..; //~ERROR statement with no effect\n     ..5; //~ERROR statement with no effect\n     5..6; //~ERROR statement with no effect\n+    5...6; //~ERROR statement with no effect\n     [42, 55]; //~ERROR statement with no effect\n     [42, 55][1]; //~ERROR statement with no effect\n     (42, 55).1; //~ERROR statement with no effect"}]}