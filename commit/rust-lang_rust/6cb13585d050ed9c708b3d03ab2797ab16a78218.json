{"sha": "6cb13585d050ed9c708b3d03ab2797ab16a78218", "node_id": "C_kwDOAAsO6NoAKDZjYjEzNTg1ZDA1MGVkOWM3MDhiM2QwM2FiMjc5N2FiMTZhNzgyMTg", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-05-13T05:35:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-13T05:35:32Z"}, "message": "Rollup merge of #110454 - oli-obk:limited_impl_trait_in_assoc_type, r=compiler-errors\n\nRequire impl Trait in associated types to appear in method signatures\n\nThis implements the limited version of TAIT that was proposed in https://github.com/rust-lang/rust/issues/107645#issuecomment-1477899536\n\nSimilar to `impl Trait` in return types, `impl Trait` in associated types may only be used within the impl block which it is a part of. To make everything simpler and forward compatible to getting desugared to a plain type alias impl trait in the future, we're requiring that any associated functions or constants that want to register hidden types must be using the associated type in their signature (type of the constant or argument/return type of the associated method. Where bounds mentioning the associated type are ignored).\n\nWe have preexisting tests checking that this works transitively across multiple associated types in situations like\n\n```rust\nimpl Foo for Bar {\n    type A = impl Trait;\n    type B = impl Iterator<Item = Self::A>;\n    fn foo() -> Self::B { ...... }\n}\n```", "tree": {"sha": "e51a07b45453d0c039cbdf6a7a1ba1f714c84024", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e51a07b45453d0c039cbdf6a7a1ba1f714c84024"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cb13585d050ed9c708b3d03ab2797ab16a78218", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkXyGkCRBK7hj4Ov3rIwAAPPgIAJk7LSDeGTn1h2u4wz8yBYtu\nWLbk1/aIZZf8c+KMB+H6lyj8IaQjgIjElDcBNLZZTHqktW+4CVe9RXJmJV3q1lB8\n0BWQiuB2frtDRI6PalDYxaB9Gd/gN+kiGoY9KkBg9KwJT/EKr4qzkj5/8shCedpA\niSMK6IbpSwo9C/Gt3ySDGi8o8bK/6/c+bftUjPmPxlE7fu0Lxcc9qmck4y9TbnNO\nKzdc5X4IhK8cvQcrtMqSn2Hcu563Qb5HtJddn/TUflQTCyIx3j5bWDViaJrpo5ZO\nl2nJREgjq2EhzR5RMYtgZWfqDFxiy3uKncxknzgnDWMgItUhtiz18aCPk28zWns=\n=kdKq\n-----END PGP SIGNATURE-----\n", "payload": "tree e51a07b45453d0c039cbdf6a7a1ba1f714c84024\nparent 9850584a4e5e4b7e5cebd9d90c27d8b88591f264\nparent 4e92f761fe54fc602ec2bf63819e8c973d1facd5\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1683956132 +0530\ncommitter GitHub <noreply@github.com> 1683956132 +0530\n\nRollup merge of #110454 - oli-obk:limited_impl_trait_in_assoc_type, r=compiler-errors\n\nRequire impl Trait in associated types to appear in method signatures\n\nThis implements the limited version of TAIT that was proposed in https://github.com/rust-lang/rust/issues/107645#issuecomment-1477899536\n\nSimilar to `impl Trait` in return types, `impl Trait` in associated types may only be used within the impl block which it is a part of. To make everything simpler and forward compatible to getting desugared to a plain type alias impl trait in the future, we're requiring that any associated functions or constants that want to register hidden types must be using the associated type in their signature (type of the constant or argument/return type of the associated method. Where bounds mentioning the associated type are ignored).\n\nWe have preexisting tests checking that this works transitively across multiple associated types in situations like\n\n```rust\nimpl Foo for Bar {\n    type A = impl Trait;\n    type B = impl Iterator<Item = Self::A>;\n    fn foo() -> Self::B { ...... }\n}\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cb13585d050ed9c708b3d03ab2797ab16a78218", "html_url": "https://github.com/rust-lang/rust/commit/6cb13585d050ed9c708b3d03ab2797ab16a78218", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cb13585d050ed9c708b3d03ab2797ab16a78218/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9850584a4e5e4b7e5cebd9d90c27d8b88591f264", "url": "https://api.github.com/repos/rust-lang/rust/commits/9850584a4e5e4b7e5cebd9d90c27d8b88591f264", "html_url": "https://github.com/rust-lang/rust/commit/9850584a4e5e4b7e5cebd9d90c27d8b88591f264"}, {"sha": "4e92f761fe54fc602ec2bf63819e8c973d1facd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e92f761fe54fc602ec2bf63819e8c973d1facd5", "html_url": "https://github.com/rust-lang/rust/commit/4e92f761fe54fc602ec2bf63819e8c973d1facd5"}], "stats": {"total": 628, "additions": 560, "deletions": 68}, "files": [{"sha": "08ee3761bac2b33141c1206a89b3ff558919ed23", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -305,7 +305,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             );\n                             this.arena.alloc(this.ty(span, hir::TyKind::Err(guar)))\n                         }\n-                        Some(ty) => this.lower_ty(ty, &ImplTraitContext::TypeAliasesOpaqueTy),\n+                        Some(ty) => this.lower_ty(\n+                            ty,\n+                            &ImplTraitContext::TypeAliasesOpaqueTy { in_assoc_ty: false },\n+                        ),\n                     },\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n@@ -852,7 +855,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             hir::ImplItemKind::Type(ty)\n                         }\n                         Some(ty) => {\n-                            let ty = this.lower_ty(ty, &ImplTraitContext::TypeAliasesOpaqueTy);\n+                            let ty = this.lower_ty(\n+                                ty,\n+                                &ImplTraitContext::TypeAliasesOpaqueTy { in_assoc_ty: true },\n+                            );\n                             hir::ImplItemKind::Type(ty)\n                         }\n                     },"}, {"sha": "cd6614a54a4e9a30e172e19a43c4c5efaff40fa6", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -247,7 +247,7 @@ enum ImplTraitContext {\n         in_trait: bool,\n     },\n     /// Impl trait in type aliases.\n-    TypeAliasesOpaqueTy,\n+    TypeAliasesOpaqueTy { in_assoc_ty: bool },\n     /// `impl Trait` is unstably accepted in this position.\n     FeatureGated(ImplTraitPosition, Symbol),\n     /// `impl Trait` is not accepted in this position.\n@@ -1407,14 +1407,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             *in_trait,\n                             itctx,\n                         ),\n-                    ImplTraitContext::TypeAliasesOpaqueTy => self.lower_opaque_impl_trait(\n-                        span,\n-                        hir::OpaqueTyOrigin::TyAlias,\n-                        *def_node_id,\n-                        bounds,\n-                        false,\n-                        itctx,\n-                    ),\n+                    &ImplTraitContext::TypeAliasesOpaqueTy { in_assoc_ty } => self\n+                        .lower_opaque_impl_trait(\n+                            span,\n+                            hir::OpaqueTyOrigin::TyAlias { in_assoc_ty },\n+                            *def_node_id,\n+                            bounds,\n+                            false,\n+                            itctx,\n+                        ),\n                     ImplTraitContext::Universal => {\n                         let span = t.span;\n                         self.create_def(\n@@ -1534,13 +1535,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // If this came from a TAIT (as opposed to a function that returns an RPIT), we only want\n         // to capture the lifetimes that appear in the bounds. So visit the bounds to find out\n         // exactly which ones those are.\n-        let lifetimes_to_remap = if origin == hir::OpaqueTyOrigin::TyAlias {\n-            // in a TAIT like `type Foo<'a> = impl Foo<'a>`, we don't keep all the lifetime parameters\n-            Vec::new()\n-        } else {\n-            // in fn return position, like the `fn test<'a>() -> impl Debug + 'a` example,\n-            // we only keep the lifetimes that appear in the `impl Debug` itself:\n-            lifetime_collector::lifetimes_in_bounds(&self.resolver, bounds)\n+        let lifetimes_to_remap = match origin {\n+            hir::OpaqueTyOrigin::TyAlias { .. } => {\n+                // in a TAIT like `type Foo<'a> = impl Foo<'a>`, we don't keep all the lifetime parameters\n+                Vec::new()\n+            }\n+            hir::OpaqueTyOrigin::AsyncFn(..) | hir::OpaqueTyOrigin::FnReturn(..) => {\n+                // in fn return position, like the `fn test<'a>() -> impl Debug + 'a` example,\n+                // we only keep the lifetimes that appear in the `impl Debug` itself:\n+                lifetime_collector::lifetimes_in_bounds(&self.resolver, bounds)\n+            }\n         };\n         debug!(?lifetimes_to_remap);\n "}, {"sha": "309f23d92261e28b69a0f46125036e7f9434c840", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -265,7 +265,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n \n         // Only check this for TAIT. RPIT already supports `tests/ui/impl-trait/nested-return-type2.rs`\n         // on stable and we'd break that.\n-        let OpaqueTyOrigin::TyAlias = origin else {\n+        let OpaqueTyOrigin::TyAlias { .. } = origin else {\n             return definition_ty;\n         };\n         let def_id = opaque_type_key.def_id;\n@@ -360,7 +360,7 @@ fn check_opaque_type_parameter_valid(\n         // which would error here on all of the `'static` args.\n         OpaqueTyOrigin::FnReturn(..) | OpaqueTyOrigin::AsyncFn(..) => return Ok(()),\n         // Check these\n-        OpaqueTyOrigin::TyAlias => {}\n+        OpaqueTyOrigin::TyAlias { .. } => {}\n     }\n     let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n     let mut seen_params: FxIndexMap<_, Vec<_>> = FxIndexMap::default();"}, {"sha": "932f0396282fd729e1d52551b851d490703be9c4", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -2662,7 +2662,10 @@ pub enum OpaqueTyOrigin {\n     /// `async fn`\n     AsyncFn(LocalDefId),\n     /// type aliases: `type Foo = impl Trait;`\n-    TyAlias,\n+    TyAlias {\n+        /// associated types in impl blocks for traits.\n+        in_assoc_ty: bool,\n+    },\n }\n \n /// The various kinds of types recognized by the compiler."}, {"sha": "78ffe59679a0359af05096de02e6f31d06da488f", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -397,7 +397,7 @@ fn check_opaque_meets_bounds<'tcx>(\n ) {\n     let defining_use_anchor = match *origin {\n         hir::OpaqueTyOrigin::FnReturn(did) | hir::OpaqueTyOrigin::AsyncFn(did) => did,\n-        hir::OpaqueTyOrigin::TyAlias => def_id,\n+        hir::OpaqueTyOrigin::TyAlias { .. } => tcx.impl_trait_parent(def_id),\n     };\n     let param_env = tcx.param_env(defining_use_anchor);\n \n@@ -455,10 +455,10 @@ fn check_opaque_meets_bounds<'tcx>(\n         // They can only be referenced as `<Opaque<T> as Trait<&'static T>>::AssocTy`.\n         // We don't have to check them here because their well-formedness follows from the WF of\n         // the projection input types in the defining- and use-sites.\n-        hir::OpaqueTyOrigin::TyAlias\n+        hir::OpaqueTyOrigin::TyAlias { .. }\n             if tcx.def_kind(tcx.parent(def_id.to_def_id())) == DefKind::OpaqueTy => {}\n         // Can have different predicates to their defining use\n-        hir::OpaqueTyOrigin::TyAlias => {\n+        hir::OpaqueTyOrigin::TyAlias { .. } => {\n             let wf_tys = ocx.assumed_wf_types(param_env, span, def_id);\n             let implied_bounds = infcx.implied_bounds_tys(param_env, def_id, wf_tys);\n             let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);"}, {"sha": "e0ba255cc069cc2e04d166f588a33478f9951af6", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::{struct_span_err, ErrorGuaranteed};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{RegionResolutionError, TyCtxtInferExt};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::util::IgnoreRegions;\n+use rustc_middle::ty::util::CheckRegions;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_trait_selection::traits::{self, ObligationCtxt};\n \n@@ -81,7 +81,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     self_type_did: DefId,\n     adt_to_impl_substs: SubstsRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n-    let Err(arg) = tcx.uses_unique_generic_params(adt_to_impl_substs, IgnoreRegions::No) else {\n+    let Err(arg) = tcx.uses_unique_generic_params(adt_to_impl_substs, CheckRegions::OnlyEarlyBound) else {\n         return Ok(())\n     };\n "}, {"sha": "23beacd2a8c2cd506af8188577aca2aeee93dc98", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::{struct_span_err, DelayDm};\n use rustc_errors::{Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_middle::ty::subst::InternalSubsts;\n-use rustc_middle::ty::util::IgnoreRegions;\n+use rustc_middle::ty::util::CheckRegions;\n use rustc_middle::ty::{\n     self, AliasKind, ImplPolarity, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n     TypeVisitor,\n@@ -507,7 +507,7 @@ fn lint_auto_trait_impl<'tcx>(\n     // Impls which completely cover a given root type are fine as they\n     // disable auto impls entirely. So only lint if the substs\n     // are not a permutation of the identity substs.\n-    let Err(arg) = tcx.uses_unique_generic_params(substs, IgnoreRegions::Yes) else {\n+    let Err(arg) = tcx.uses_unique_generic_params(substs, CheckRegions::No) else {\n         // ok\n         return;\n     };"}, {"sha": "2f808d4ce738c55ab4321eb3e76a0369ca59b161", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -1483,7 +1483,7 @@ fn generator_kind(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<hir::GeneratorK\n fn is_type_alias_impl_trait<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> bool {\n     match tcx.hir().get_by_def_id(def_id) {\n         Node::Item(hir::Item { kind: hir::ItemKind::OpaqueTy(opaque), .. }) => {\n-            matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias)\n+            matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias { .. })\n         }\n         _ => bug!(\"tried getting opaque_ty_origin for non-opaque: {:?}\", def_id),\n     }"}, {"sha": "ed60998ec8dcfebc238d4cc4d17d494564b63d93", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -159,7 +159,10 @@ pub(super) fn generics_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::Generics {\n                 }\n                 Some(fn_def_id.to_def_id())\n             }\n-            ItemKind::OpaqueTy(hir::OpaqueTy { origin: hir::OpaqueTyOrigin::TyAlias, .. }) => {\n+            ItemKind::OpaqueTy(hir::OpaqueTy {\n+                origin: hir::OpaqueTyOrigin::TyAlias { .. },\n+                ..\n+            }) => {\n                 let parent_id = tcx.hir().get_parent_item(hir_id);\n                 assert_ne!(parent_id, hir::CRATE_OWNER_ID);\n                 debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);"}, {"sha": "a33990813b8206bd8b4b619c290cf8eae30d325f", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -721,7 +721,7 @@ pub(super) fn type_param_predicates(\n                 | ItemKind::TyAlias(_, generics)\n                 | ItemKind::OpaqueTy(OpaqueTy {\n                     generics,\n-                    origin: hir::OpaqueTyOrigin::TyAlias,\n+                    origin: hir::OpaqueTyOrigin::TyAlias { .. },\n                     ..\n                 })\n                 | ItemKind::Enum(_, generics)"}, {"sha": "92ae93cf4cc5db928502269c02359419274a95a3", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -526,7 +526,8 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n                 });\n             }\n             hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                origin: hir::OpaqueTyOrigin::TyAlias, ..\n+                origin: hir::OpaqueTyOrigin::TyAlias { .. },\n+                ..\n             }) => {\n                 // Opaque types are visited when we visit the\n                 // `TyKind::OpaqueDef`, so that they have the lifetimes from\n@@ -707,7 +708,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n                 let opaque_ty = self.tcx.hir().item(item_id);\n                 match &opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                        origin: hir::OpaqueTyOrigin::TyAlias,\n+                        origin: hir::OpaqueTyOrigin::TyAlias { .. },\n                         ..\n                     }) => {\n                         intravisit::walk_ty(self, ty);"}, {"sha": "6c7c2b9eea25877258f49e37ec359c2bbb91ea77", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -426,9 +426,10 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     tcx.mk_adt(def, substs)\n                 }\n-                ItemKind::OpaqueTy(OpaqueTy { origin: hir::OpaqueTyOrigin::TyAlias, .. }) => {\n-                    find_opaque_ty_constraints_for_tait(tcx, def_id)\n-                }\n+                ItemKind::OpaqueTy(OpaqueTy {\n+                    origin: hir::OpaqueTyOrigin::TyAlias { .. },\n+                    ..\n+                }) => find_opaque_ty_constraints_for_tait(tcx, def_id),\n                 // Opaque types desugared from `impl Trait`.\n                 ItemKind::OpaqueTy(OpaqueTy {\n                     origin:"}, {"sha": "421eb807a141f479d82873af941923e49d6b0c81", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -2,6 +2,7 @@ use super::TypeErrCtxt;\n use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n use rustc_errors::{pluralize, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_middle::traits::ObligationCauseCode;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::print::Printer;\n@@ -256,6 +257,15 @@ impl<T> Trait<T> for X {\n                             );\n                         }\n                     }\n+                    (ty::Alias(ty::Opaque, alias), _) | (_, ty::Alias(ty::Opaque, alias)) if alias.def_id.is_local() && matches!(tcx.def_kind(body_owner_def_id), DefKind::AssocFn | DefKind::AssocConst) => {\n+                        if tcx.is_type_alias_impl_trait(alias.def_id) {\n+                            if !tcx.opaque_types_defined_by(body_owner_def_id.expect_local()).contains(&alias.def_id.expect_local()) {\n+                                diag.span_note(tcx.def_span(body_owner_def_id), \"\\\n+                                    this item must have the opaque type in its signature \\\n+                                    in order to be able to register hidden types\");\n+                            }\n+                        }\n+                    }\n                     (ty::FnPtr(_), ty::FnDef(def, _))\n                     if let hir::def::DefKind::Fn = tcx.def_kind(def) => {\n                         diag.note("}, {"sha": "545310ad3516732385e750230be92dbf7e6ed42b", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -149,7 +149,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // no one encounters it in practice.\n                     // It does occur however in `fn fut() -> impl Future<Output = i32> { async { 42 } }`,\n                     // where it is of no concern, so we only check for TAITs.\n-                    if let Some(OpaqueTyOrigin::TyAlias) =\n+                    if let Some(OpaqueTyOrigin::TyAlias { .. }) =\n                         b_def_id.as_local().and_then(|b_def_id| self.opaque_type_origin(b_def_id))\n                     {\n                         self.tcx.sess.emit_err(OpaqueHiddenTypeDiag {\n@@ -381,8 +381,12 @@ impl<'tcx> InferCtxt<'tcx> {\n             // Anonymous `impl Trait`\n             hir::OpaqueTyOrigin::FnReturn(parent) => parent == parent_def_id,\n             // Named `type Foo = impl Bar;`\n-            hir::OpaqueTyOrigin::TyAlias => {\n-                may_define_opaque_type(self.tcx, parent_def_id, opaque_hir_id)\n+            hir::OpaqueTyOrigin::TyAlias { in_assoc_ty } => {\n+                if in_assoc_ty {\n+                    self.tcx.opaque_types_defined_by(parent_def_id).contains(&def_id)\n+                } else {\n+                    may_define_opaque_type(self.tcx, parent_def_id, opaque_hir_id)\n+                }\n             }\n         };\n         in_definition_scope.then_some(origin)"}, {"sha": "043410c47e0b565618a1391783e47207eeee4875", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -1641,9 +1641,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::OpaqueTy(ref opaque) => {\n                 self.encode_explicit_item_bounds(def_id);\n-                self.tables\n-                    .is_type_alias_impl_trait\n-                    .set(def_id.index, matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias));\n+                self.tables.is_type_alias_impl_trait.set(\n+                    def_id.index,\n+                    matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias { .. }),\n+                );\n             }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n                 self.tables.impl_defaultness.set_some(def_id.index, *defaultness);"}, {"sha": "b45f7caaabe08945346173ad5c37d81d77643b0c", "filename": "compiler/rustc_middle/src/query/erase.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -172,6 +172,10 @@ impl EraseType for ty::Binder<'_, ty::FnSig<'_>> {\n     type Result = [u8; size_of::<ty::Binder<'static, ty::FnSig<'static>>>()];\n }\n \n+impl EraseType for ty::Binder<'_, &'_ ty::List<Ty<'_>>> {\n+    type Result = [u8; size_of::<ty::Binder<'static, &'static ty::List<Ty<'static>>>>()];\n+}\n+\n impl<T0, T1> EraseType for (&'_ T0, &'_ T1) {\n     type Result = [u8; size_of::<(&'static (), &'static ())>()];\n }"}, {"sha": "5acdd68e60eac32677005de79ee75124f1efd483", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -236,6 +236,15 @@ rustc_queries! {\n         cache_on_disk_if { key.is_local() }\n     }\n \n+    query opaque_types_defined_by(\n+        key: LocalDefId\n+    ) -> &'tcx [LocalDefId] {\n+        desc {\n+            |tcx| \"computing the opaque types defined by `{}`\",\n+            tcx.def_path_str(key.to_def_id())\n+        }\n+    }\n+\n     /// Returns the list of bounds that can be used for\n     /// `SelectionCandidate::ProjectionCandidate(_)` and\n     /// `ProjectionTyCandidate::TraitDef`."}, {"sha": "b414e1200cdf850f1f858bb170d545851055b776", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -2476,6 +2476,18 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Returns the `DefId` of the item within which the `impl Trait` is declared.\n+    /// For type-alias-impl-trait this is the `type` alias.\n+    /// For impl-trait-in-assoc-type this is the assoc type.\n+    /// For return-position-impl-trait this is the function.\n+    pub fn impl_trait_parent(self, mut def_id: LocalDefId) -> LocalDefId {\n+        // Find the surrounding item (type alias or assoc type)\n+        while let DefKind::OpaqueTy = self.def_kind(def_id) {\n+            def_id = self.local_parent(def_id);\n+        }\n+        def_id\n+    }\n+\n     pub fn impl_method_has_trait_impl_trait_tys(self, def_id: DefId) -> bool {\n         if self.def_kind(def_id) != DefKind::AssocFn {\n             return false;\n@@ -2520,7 +2532,7 @@ pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<LocalDefId>\n                 hir::OpaqueTyOrigin::FnReturn(parent) | hir::OpaqueTyOrigin::AsyncFn(parent) => {\n                     Some(parent)\n                 }\n-                hir::OpaqueTyOrigin::TyAlias => None,\n+                hir::OpaqueTyOrigin::TyAlias { .. } => None,\n             };\n         }\n     }"}, {"sha": "a0c8d299f48ba164c000d9f4c8861f050101add2", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -32,7 +32,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     ///\n     /// This should only be used outside of type inference. For example,\n     /// it assumes that normalization will succeed.\n-    #[tracing::instrument(level = \"debug\", skip(self, param_env))]\n+    #[tracing::instrument(level = \"debug\", skip(self, param_env), ret)]\n     pub fn normalize_erasing_regions<T>(self, param_env: ty::ParamEnv<'tcx>, value: T) -> T\n     where\n         T: TypeFoldable<TyCtxt<'tcx>>,"}, {"sha": "d175cf72d672a9dcf35b51c700f7c16fb50bb033", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -1265,7 +1265,7 @@ impl<'tcx> AliasTy<'tcx> {\n \n     /// Extracts the underlying trait reference and own substs from this projection.\n     /// For example, if this is a projection of `<T as StreamingIterator>::Item<'a>`,\n-    /// then this function would return a `T: Iterator` trait reference and `['a]` as the own substs\n+    /// then this function would return a `T: StreamingIterator` trait reference and `['a]` as the own substs\n     pub fn trait_ref_and_own_substs(\n         self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "9bab693156b3df6bf0b7345d8205b29221915dee", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -34,9 +34,14 @@ pub struct Discr<'tcx> {\n \n /// Used as an input to [`TyCtxt::uses_unique_generic_params`].\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum IgnoreRegions {\n-    Yes,\n+pub enum CheckRegions {\n     No,\n+    /// Only permit early bound regions. This is useful for Adts which\n+    /// can never have late bound regions.\n+    OnlyEarlyBound,\n+    /// Permit both late bound and early bound regions. Use this for functions,\n+    /// which frequently have late bound regions.\n+    Bound,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -468,21 +473,28 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn uses_unique_generic_params(\n         self,\n         substs: SubstsRef<'tcx>,\n-        ignore_regions: IgnoreRegions,\n+        ignore_regions: CheckRegions,\n     ) -> Result<(), NotUniqueParam<'tcx>> {\n         let mut seen = GrowableBitSet::default();\n+        let mut seen_late = FxHashSet::default();\n         for arg in substs {\n             match arg.unpack() {\n-                GenericArgKind::Lifetime(lt) => {\n-                    if ignore_regions == IgnoreRegions::No {\n-                        let ty::ReEarlyBound(p) = lt.kind() else {\n-                            return Err(NotUniqueParam::NotParam(lt.into()))\n-                        };\n+                GenericArgKind::Lifetime(lt) => match (ignore_regions, lt.kind()) {\n+                    (CheckRegions::Bound, ty::ReLateBound(di, reg)) => {\n+                        if !seen_late.insert((di, reg)) {\n+                            return Err(NotUniqueParam::DuplicateParam(lt.into()));\n+                        }\n+                    }\n+                    (CheckRegions::OnlyEarlyBound | CheckRegions::Bound, ty::ReEarlyBound(p)) => {\n                         if !seen.insert(p.index) {\n                             return Err(NotUniqueParam::DuplicateParam(lt.into()));\n                         }\n                     }\n-                }\n+                    (CheckRegions::OnlyEarlyBound | CheckRegions::Bound, _) => {\n+                        return Err(NotUniqueParam::NotParam(lt.into()));\n+                    }\n+                    (CheckRegions::No, _) => {}\n+                },\n                 GenericArgKind::Type(t) => match t.kind() {\n                     ty::Param(p) => {\n                         if !seen.insert(p.index) {"}, {"sha": "5bc3e3c00c9af857ff1a9d8cb64f6993b9fa2b89", "filename": "compiler/rustc_ty_utils/messages.ftl", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_ty_utils%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_ty_utils%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fmessages.ftl?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -55,3 +55,11 @@ ty_utils_multiple_array_fields_simd_type = monomorphising SIMD type `{$ty}` with\n ty_utils_oversized_simd_type = monomorphising SIMD type `{$ty}` of length greater than {$max_lanes}\n \n ty_utils_non_primitive_simd_type = monomorphising SIMD type `{$ty}` with a non-primitive-scalar (integer/float/pointer) element type `{$e_ty}`\n+\n+ty_utils_impl_trait_duplicate_arg = non-defining opaque type use in defining scope\n+    .label = generic argument `{$arg}` used twice\n+    .note = for this opaque type\n+\n+ty_utils_impl_trait_not_param = non-defining opaque type use in defining scope\n+    .label = argument `{$arg}` is not a generic parameter\n+    .note = for this opaque type"}, {"sha": "553bf40ef3a48afb320ba14626dc6a519160c24c", "filename": "compiler/rustc_ty_utils/src/errors.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -1,7 +1,7 @@\n //! Errors emitted by ty_utils\n \n use rustc_macros::{Diagnostic, Subdiagnostic};\n-use rustc_middle::ty::Ty;\n+use rustc_middle::ty::{GenericArg, Ty};\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n@@ -100,3 +100,25 @@ pub struct NonPrimitiveSimdType<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub e_ty: Ty<'tcx>,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(ty_utils_impl_trait_duplicate_arg)]\n+pub struct DuplicateArg<'tcx> {\n+    pub arg: GenericArg<'tcx>,\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[note]\n+    pub opaque_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ty_utils_impl_trait_not_param)]\n+pub struct NotParam<'tcx> {\n+    pub arg: GenericArg<'tcx>,\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[note]\n+    pub opaque_span: Span,\n+}"}, {"sha": "8306c5ae49360c82ea5e0e2a1196ad083652085b", "filename": "compiler/rustc_ty_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flib.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -33,6 +33,7 @@ pub mod instance;\n mod layout;\n mod layout_sanity_check;\n mod needs_drop;\n+mod opaque_types;\n pub mod representability;\n mod structural_match;\n mod ty;\n@@ -47,6 +48,7 @@ pub fn provide(providers: &mut Providers) {\n     implied_bounds::provide(providers);\n     layout::provide(providers);\n     needs_drop::provide(providers);\n+    opaque_types::provide(providers);\n     representability::provide(providers);\n     ty::provide(providers);\n     instance::provide(providers);"}, {"sha": "25ebb333bf74ac6edc9062f6fed2b966c3ef63b4", "filename": "compiler/rustc_ty_utils/src/opaque_types.rs", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_ty_utils%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/compiler%2Frustc_ty_utils%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fopaque_types.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -0,0 +1,197 @@\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_hir::{def::DefKind, def_id::LocalDefId};\n+use rustc_middle::ty::util::{CheckRegions, NotUniqueParam};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n+use rustc_span::Span;\n+use rustc_type_ir::AliasKind;\n+use std::ops::ControlFlow;\n+\n+use crate::errors::{DuplicateArg, NotParam};\n+\n+struct OpaqueTypeCollector<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    opaques: Vec<LocalDefId>,\n+    /// The `DefId` of the item which we are collecting opaque types for.\n+    item: LocalDefId,\n+\n+    /// Avoid infinite recursion due to recursive declarations.\n+    seen: FxHashSet<LocalDefId>,\n+}\n+\n+impl<'tcx> OpaqueTypeCollector<'tcx> {\n+    fn collect(\n+        tcx: TyCtxt<'tcx>,\n+        item: LocalDefId,\n+        val: ty::Binder<'tcx, impl TypeVisitable<TyCtxt<'tcx>>>,\n+    ) -> Vec<LocalDefId> {\n+        let mut collector = Self { tcx, opaques: Vec::new(), item, seen: Default::default() };\n+        val.skip_binder().visit_with(&mut collector);\n+        collector.opaques\n+    }\n+\n+    fn span(&self) -> Span {\n+        self.tcx.def_span(self.item)\n+    }\n+\n+    fn parent(&self) -> Option<LocalDefId> {\n+        match self.tcx.def_kind(self.item) {\n+            DefKind::Fn => None,\n+            DefKind::AssocFn | DefKind::AssocTy | DefKind::AssocConst => {\n+                Some(self.tcx.local_parent(self.item))\n+            }\n+            other => span_bug!(\n+                self.tcx.def_span(self.item),\n+                \"unhandled item with opaque types: {other:?}\"\n+            ),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for OpaqueTypeCollector<'tcx> {\n+    type BreakTy = ErrorGuaranteed;\n+\n+    #[instrument(skip(self), ret, level = \"trace\")]\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<ErrorGuaranteed> {\n+        match t.kind() {\n+            ty::Alias(AliasKind::Opaque, alias_ty) if alias_ty.def_id.is_local() => {\n+                if !self.seen.insert(alias_ty.def_id.expect_local()) {\n+                    return ControlFlow::Continue(());\n+                }\n+                match self.tcx.uses_unique_generic_params(alias_ty.substs, CheckRegions::Bound) {\n+                    Ok(()) => {\n+                        // FIXME: implement higher kinded lifetime bounds on nested opaque types. They are not\n+                        // supported at all, so this is sound to do, but once we want to support them, you'll\n+                        // start seeing the error below.\n+\n+                        self.opaques.push(alias_ty.def_id.expect_local());\n+\n+                        // Collect opaque types nested within the associated type bounds of this opaque type.\n+                        for (pred, _span) in self\n+                            .tcx\n+                            .explicit_item_bounds(alias_ty.def_id)\n+                            .subst_iter_copied(self.tcx, alias_ty.substs)\n+                        {\n+                            trace!(?pred);\n+                            pred.visit_with(self)?;\n+                        }\n+\n+                        ControlFlow::Continue(())\n+                    }\n+                    Err(NotUniqueParam::NotParam(arg)) => {\n+                        let err = self.tcx.sess.emit_err(NotParam {\n+                            arg,\n+                            span: self.span(),\n+                            opaque_span: self.tcx.def_span(alias_ty.def_id),\n+                        });\n+                        ControlFlow::Break(err)\n+                    }\n+                    Err(NotUniqueParam::DuplicateParam(arg)) => {\n+                        let err = self.tcx.sess.emit_err(DuplicateArg {\n+                            arg,\n+                            span: self.span(),\n+                            opaque_span: self.tcx.def_span(alias_ty.def_id),\n+                        });\n+                        ControlFlow::Break(err)\n+                    }\n+                }\n+            }\n+            ty::Alias(AliasKind::Projection, alias_ty) => {\n+                if let Some(parent) = self.parent() {\n+                    trace!(?alias_ty);\n+                    let (trait_ref, own_substs) = alias_ty.trait_ref_and_own_substs(self.tcx);\n+\n+                    trace!(?trait_ref, ?own_substs);\n+                    // This avoids having to do normalization of `Self::AssocTy` by only\n+                    // supporting the case of a method defining opaque types from assoc types\n+                    // in the same impl block.\n+                    if trait_ref.self_ty() == self.tcx.type_of(parent).subst_identity() {\n+                        for assoc in self.tcx.associated_items(parent).in_definition_order() {\n+                            trace!(?assoc);\n+                            if assoc.trait_item_def_id == Some(alias_ty.def_id) {\n+                                // We reconstruct the generic args of the associated type within the impl\n+                                // from the impl's generics and the generic args passed to the type via the\n+                                // projection.\n+                                let substs = ty::InternalSubsts::identity_for_item(\n+                                    self.tcx,\n+                                    parent.to_def_id(),\n+                                );\n+                                trace!(?substs);\n+                                let substs: Vec<_> =\n+                                    substs.iter().chain(own_substs.iter().copied()).collect();\n+                                trace!(?substs);\n+                                // Find opaque types in this associated type.\n+                                return self\n+                                    .tcx\n+                                    .type_of(assoc.def_id)\n+                                    .subst(self.tcx, &substs)\n+                                    .visit_with(self);\n+                            }\n+                        }\n+                    }\n+                }\n+                t.super_visit_with(self)\n+            }\n+            _ => t.super_visit_with(self),\n+        }\n+    }\n+}\n+\n+fn opaque_types_defined_by<'tcx>(tcx: TyCtxt<'tcx>, item: LocalDefId) -> &'tcx [LocalDefId] {\n+    let kind = tcx.def_kind(item);\n+    trace!(?kind);\n+    // FIXME(type_alias_impl_trait): This is definitely still wrong except for RPIT and impl trait in assoc types.\n+    match kind {\n+        // We're also doing this for `AssocTy` for the wf checks in `check_opaque_meets_bounds`\n+        DefKind::Fn | DefKind::AssocFn | DefKind::AssocTy | DefKind::AssocConst => {\n+            let defined_opaques = match kind {\n+                DefKind::Fn => {\n+                    OpaqueTypeCollector::collect(tcx, item, tcx.fn_sig(item).subst_identity())\n+                }\n+                DefKind::AssocFn => {\n+                    OpaqueTypeCollector::collect(tcx, item, tcx.fn_sig(item).subst_identity())\n+                }\n+                DefKind::AssocTy | DefKind::AssocConst => OpaqueTypeCollector::collect(\n+                    tcx,\n+                    item,\n+                    ty::Binder::dummy(tcx.type_of(item).subst_identity()),\n+                ),\n+                _ => unreachable!(),\n+            };\n+            tcx.arena.alloc_from_iter(defined_opaques)\n+        }\n+        DefKind::Mod\n+        | DefKind::Struct\n+        | DefKind::Union\n+        | DefKind::Enum\n+        | DefKind::Variant\n+        | DefKind::Trait\n+        | DefKind::TyAlias\n+        | DefKind::ForeignTy\n+        | DefKind::TraitAlias\n+        | DefKind::TyParam\n+        | DefKind::Const\n+        | DefKind::ConstParam\n+        | DefKind::Static(_)\n+        | DefKind::Ctor(_, _)\n+        | DefKind::Macro(_)\n+        | DefKind::ExternCrate\n+        | DefKind::Use\n+        | DefKind::ForeignMod\n+        | DefKind::AnonConst\n+        | DefKind::InlineConst\n+        | DefKind::OpaqueTy\n+        | DefKind::ImplTraitPlaceholder\n+        | DefKind::Field\n+        | DefKind::LifetimeParam\n+        | DefKind::GlobalAsm\n+        | DefKind::Impl { .. }\n+        | DefKind::Closure\n+        | DefKind::Generator => &[],\n+    }\n+}\n+\n+pub(super) fn provide(providers: &mut ty::query::Providers) {\n+    *providers = ty::query::Providers { opaque_types_defined_by, ..*providers };\n+}"}, {"sha": "ff13daa6db4572eda0008ded02ca9f4b806d51f6", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -455,7 +455,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             | hir::ItemKind::Union(..)\n             | hir::ItemKind::TyAlias(..)\n             | hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                origin: hir::OpaqueTyOrigin::TyAlias, ..\n+                origin: hir::OpaqueTyOrigin::TyAlias { .. },\n+                ..\n             })\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Trait(..)"}, {"sha": "7de906e7ef3f3e663615c94f0eebfd4416ee23d0", "filename": "tests/ui/generic-associated-types/issue-88595.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fissue-88595.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -19,4 +19,5 @@ impl<'a> A<'a> for C {\n     type B<'b> = impl Clone;\n \n     fn a(&'a self) -> Self::B<'a> {} //~ ERROR: non-defining opaque type use in defining scope\n+    //~^ ERROR: mismatched types\n }"}, {"sha": "d6caed854599325d773e546918471bf918e0ee1a", "filename": "tests/ui/generic-associated-types/issue-88595.stderr", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fgeneric-associated-types%2Fissue-88595.stderr?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -1,16 +1,34 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-88595.rs:21:35\n+  --> $DIR/issue-88595.rs:21:5\n    |\n LL |     fn a(&'a self) -> Self::B<'a> {}\n-   |                                   ^^\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ generic argument `'a` used twice\n    |\n-note: lifetime used multiple times\n-  --> $DIR/issue-88595.rs:18:6\n+note: for this opaque type\n+  --> $DIR/issue-88595.rs:19:18\n    |\n-LL | impl<'a> A<'a> for C {\n-   |      ^^\n LL |     type B<'b> = impl Clone;\n-   |            ^^\n+   |                  ^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/issue-88595.rs:21:23\n+   |\n+LL |     type B<'b> = impl Clone;\n+   |                  ---------- the expected opaque type\n+LL |\n+LL |     fn a(&'a self) -> Self::B<'a> {}\n+   |        -              ^^^^^^^^^^^ expected opaque type, found `()`\n+   |        |\n+   |        implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+   = note: expected opaque type `<C as A<'a>>::B<'a>`\n+                found unit type `()`\n+note: this item must have the opaque type in its signature in order to be able to register hidden types\n+  --> $DIR/issue-88595.rs:21:5\n+   |\n+LL |     fn a(&'a self) -> Self::B<'a> {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "c395b4195a05fcbfcac2b2366134239cb42caf6f", "filename": "tests/ui/impl-trait/in-assoc-type-unconstrained.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Fimpl-trait%2Fin-assoc-type-unconstrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Fimpl-trait%2Fin-assoc-type-unconstrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-assoc-type-unconstrained.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -0,0 +1,27 @@\n+#![feature(impl_trait_in_assoc_type)]\n+\n+mod compare_ty {\n+    trait Trait {\n+        type Ty: IntoIterator<Item = ()>;\n+    }\n+    impl Trait for () {\n+        type Ty = Option<impl Sized>;\n+        //~^ ERROR: unconstrained opaque type\n+        //~| ERROR: type mismatch resolving `<Option<<() as Trait>::Ty::{opaque#0}> as IntoIterator>::Item == ()`\n+    }\n+}\n+\n+mod compare_method {\n+    trait Trait {\n+        type Ty;\n+        fn method() -> Self::Ty;\n+    }\n+    impl Trait for () {\n+        type Ty = impl Sized;\n+        //~^ ERROR: unconstrained opaque type\n+        fn method() -> () {}\n+        //~^ ERROR: method `method` has an incompatible type for trait\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "1097cd0f452a870b542c43fbcb91c52708641eaf", "filename": "tests/ui/impl-trait/in-assoc-type-unconstrained.stderr", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Fimpl-trait%2Fin-assoc-type-unconstrained.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Fimpl-trait%2Fin-assoc-type-unconstrained.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-assoc-type-unconstrained.stderr?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -0,0 +1,59 @@\n+error[E0271]: type mismatch resolving `<Option<<() as Trait>::Ty::{opaque#0}> as IntoIterator>::Item == ()`\n+  --> $DIR/in-assoc-type-unconstrained.rs:8:19\n+   |\n+LL |         type Ty = Option<impl Sized>;\n+   |                   ^^^^^^^^^^^^^^^^^^ expected `()`, found opaque type\n+   |\n+   = note: expected unit type `()`\n+            found opaque type `<() as compare_ty::Trait>::Ty::{opaque#0}`\n+note: required by a bound in `compare_ty::Trait::Ty`\n+  --> $DIR/in-assoc-type-unconstrained.rs:5:31\n+   |\n+LL |         type Ty: IntoIterator<Item = ()>;\n+   |                               ^^^^^^^^^ required by this bound in `Trait::Ty`\n+\n+error: unconstrained opaque type\n+  --> $DIR/in-assoc-type-unconstrained.rs:8:26\n+   |\n+LL |         type Ty = Option<impl Sized>;\n+   |                          ^^^^^^^^^^\n+   |\n+   = note: `Ty` must be used in combination with a concrete type within the same impl\n+\n+error[E0053]: method `method` has an incompatible type for trait\n+  --> $DIR/in-assoc-type-unconstrained.rs:22:24\n+   |\n+LL |         type Ty = impl Sized;\n+   |                   ---------- the expected opaque type\n+LL |\n+LL |         fn method() -> () {}\n+   |                        ^^\n+   |                        |\n+   |                        expected opaque type, found `()`\n+   |                        help: change the output type to match the trait: `<() as compare_method::Trait>::Ty`\n+   |\n+note: type in trait\n+  --> $DIR/in-assoc-type-unconstrained.rs:17:24\n+   |\n+LL |         fn method() -> Self::Ty;\n+   |                        ^^^^^^^^\n+   = note: expected signature `fn() -> <() as compare_method::Trait>::Ty`\n+              found signature `fn()`\n+note: this item must have the opaque type in its signature in order to be able to register hidden types\n+  --> $DIR/in-assoc-type-unconstrained.rs:22:9\n+   |\n+LL |         fn method() -> () {}\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: unconstrained opaque type\n+  --> $DIR/in-assoc-type-unconstrained.rs:20:19\n+   |\n+LL |         type Ty = impl Sized;\n+   |                   ^^^^^^^^^^\n+   |\n+   = note: `Ty` must be used in combination with a concrete type within the same impl\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0053, E0271.\n+For more information about an error, try `rustc --explain E0053`."}, {"sha": "36c54bdd6de346f83056f3b7bc2de8134cc587fb", "filename": "tests/ui/impl-trait/in-assoc-type.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Fimpl-trait%2Fin-assoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Fimpl-trait%2Fin-assoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-assoc-type.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -0,0 +1,21 @@\n+#![feature(impl_trait_in_assoc_type)]\n+\n+trait Foo<T> {\n+    type Bar;\n+    fn foo(&self) -> <Self as Foo<()>>::Bar\n+    where\n+        Self: Foo<()>;\n+}\n+\n+impl Foo<()> for () {\n+    type Bar = impl std::fmt::Debug;\n+    fn foo(&self) -> Self::Bar {}\n+}\n+\n+impl Foo<i32> for () {\n+    type Bar = u32;\n+    fn foo(&self) -> <Self as Foo<()>>::Bar {}\n+    //~^ ERROR: mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "f0a272dc2d5d1e267d2e55353aef81148908fb1e", "filename": "tests/ui/impl-trait/in-assoc-type.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Fimpl-trait%2Fin-assoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Fimpl-trait%2Fin-assoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-assoc-type.stderr?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -0,0 +1,22 @@\n+error[E0308]: mismatched types\n+  --> $DIR/in-assoc-type.rs:17:22\n+   |\n+LL |     type Bar = impl std::fmt::Debug;\n+   |                -------------------- the expected opaque type\n+...\n+LL |     fn foo(&self) -> <Self as Foo<()>>::Bar {}\n+   |        ---           ^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found `()`\n+   |        |\n+   |        implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+   = note: expected opaque type `<() as Foo<()>>::Bar`\n+                found unit type `()`\n+note: this item must have the opaque type in its signature in order to be able to register hidden types\n+  --> $DIR/in-assoc-type.rs:17:5\n+   |\n+LL |     fn foo(&self) -> <Self as Foo<()>>::Bar {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "fe62a8f32888b3a5212d7709ede9574ca332c473", "filename": "tests/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -43,6 +43,11 @@ LL |         fn eq(&self, _other: &(Bar, i32)) -> bool {\n    |\n    = note: expected signature `fn(&b::Bar, &(b::Foo, i32)) -> _`\n               found signature `fn(&b::Bar, &(b::Bar, i32)) -> _`\n+note: this item must have the opaque type in its signature in order to be able to register hidden types\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:24:9\n+   |\n+LL |         fn eq(&self, _other: &(Bar, i32)) -> bool {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "58eaa9c2c42635a4227808b3ec1ce6918e928d50", "filename": "tests/ui/type-alias-impl-trait/associated-type-impl-trait-lifetime.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Ftype-alias-impl-trait%2Fassociated-type-impl-trait-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Ftype-alias-impl-trait%2Fassociated-type-impl-trait-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fassociated-type-impl-trait-lifetime.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -5,15 +5,16 @@\n trait Trait {\n     type Opaque1;\n     type Opaque2;\n-    fn constrain(self);\n+    fn constrain(self) -> (Self::Opaque1, Self::Opaque2);\n }\n \n impl<'a> Trait for &'a () {\n     type Opaque1 = impl Sized;\n     type Opaque2 = impl Sized + 'a;\n-    fn constrain(self) {\n-        let _: Self::Opaque1 = ();\n-        let _: Self::Opaque2 = self;\n+    fn constrain(self) -> (Self::Opaque1, Self::Opaque2) {\n+        let a: Self::Opaque1 = ();\n+        let b: Self::Opaque2 = self;\n+        (a, b)\n     }\n }\n "}, {"sha": "93c52126d69b00b0d4d866f405fb99709b97e31b", "filename": "tests/ui/type-alias-impl-trait/invalid_impl_trait_in_assoc_ty.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Ftype-alias-impl-trait%2Finvalid_impl_trait_in_assoc_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Ftype-alias-impl-trait%2Finvalid_impl_trait_in_assoc_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Finvalid_impl_trait_in_assoc_ty.rs?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -0,0 +1,16 @@\n+#![feature(impl_trait_in_assoc_type)]\n+\n+trait Foo {\n+    type Foo;\n+    fn bar();\n+}\n+\n+impl Foo for () {\n+    type Foo = impl std::fmt::Debug;\n+    fn bar() {\n+        let x: Self::Foo = ();\n+        //~^ ERROR: mismatched types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2beed73cb85c3b346246835f5ec4a6100dcb6af6", "filename": "tests/ui/type-alias-impl-trait/invalid_impl_trait_in_assoc_ty.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Ftype-alias-impl-trait%2Finvalid_impl_trait_in_assoc_ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6cb13585d050ed9c708b3d03ab2797ab16a78218/tests%2Fui%2Ftype-alias-impl-trait%2Finvalid_impl_trait_in_assoc_ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Finvalid_impl_trait_in_assoc_ty.stderr?ref=6cb13585d050ed9c708b3d03ab2797ab16a78218", "patch": "@@ -0,0 +1,22 @@\n+error[E0308]: mismatched types\n+  --> $DIR/invalid_impl_trait_in_assoc_ty.rs:11:28\n+   |\n+LL |     type Foo = impl std::fmt::Debug;\n+   |                -------------------- the expected opaque type\n+LL |     fn bar() {\n+LL |         let x: Self::Foo = ();\n+   |                ---------   ^^ expected opaque type, found `()`\n+   |                |\n+   |                expected due to this\n+   |\n+   = note: expected opaque type `<() as Foo>::Foo`\n+                found unit type `()`\n+note: this item must have the opaque type in its signature in order to be able to register hidden types\n+  --> $DIR/invalid_impl_trait_in_assoc_ty.rs:10:5\n+   |\n+LL |     fn bar() {\n+   |     ^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}