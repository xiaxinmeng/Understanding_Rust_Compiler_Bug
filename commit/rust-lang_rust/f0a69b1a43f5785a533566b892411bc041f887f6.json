{"sha": "f0a69b1a43f5785a533566b892411bc041f887f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYTY5YjFhNDNmNTc4NWE1MzM1NjZiODkyNDExYmMwNDFmODg3ZjY=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-15T21:19:36Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-18T20:56:14Z"}, "message": "Refactor some coherence/method trans code, add an impls map to tcx.\n\nRewrite method_with_name_or_default to use the new impls map.\nGet rid of ProvidedMethodsMap.", "tree": {"sha": "ccd0545c5d837edd2056d33e0922db52c6803b5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccd0545c5d837edd2056d33e0922db52c6803b5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0a69b1a43f5785a533566b892411bc041f887f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0a69b1a43f5785a533566b892411bc041f887f6", "html_url": "https://github.com/rust-lang/rust/commit/f0a69b1a43f5785a533566b892411bc041f887f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0a69b1a43f5785a533566b892411bc041f887f6/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37702216ebc5761d2f709583f678c19daddc602f", "url": "https://api.github.com/repos/rust-lang/rust/commits/37702216ebc5761d2f709583f678c19daddc602f", "html_url": "https://github.com/rust-lang/rust/commit/37702216ebc5761d2f709583f678c19daddc602f"}], "stats": {"total": 283, "additions": 70, "deletions": 213}, "files": [{"sha": "1da56767602a679bc50e3e0a874cd11451c28137", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 22, "deletions": 63, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f0a69b1a43f5785a533566b892411bc041f887f6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0a69b1a43f5785a533566b892411bc041f887f6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=f0a69b1a43f5785a533566b892411bc041f887f6", "patch": "@@ -177,9 +177,7 @@ pub fn trans_method_callee(bcx: block,\n             // Now that we know the impl ID, we can look up the method\n             // ID from its name\n             origin = typeck::method_static(\n-                method_with_name_or_default(bcx.ccx(),\n-                                            impl_id,\n-                                            method_name));\n+                method_with_name(bcx.ccx(), impl_id, method_name));\n         }\n         typeck::method_self(*) |\n         typeck::method_static(*) | typeck::method_param(*) |\n@@ -308,12 +306,10 @@ pub fn trans_static_method_callee(bcx: block,\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n             assert!(rcvr_substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n-            let mth_id = method_with_name_or_default(bcx.ccx(),\n-                                                     impl_did,\n-                                                     mname);\n+            let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n             let (callee_substs, callee_origins) =\n                 combine_impl_and_methods_tps(\n-                    bcx, mth_id, impl_did, callee_id,\n+                    bcx, mth_id, callee_id,\n                     *rcvr_substs, rcvr_origins);\n \n             let FnData {llfn: lval} =\n@@ -334,58 +330,22 @@ pub fn trans_static_method_callee(bcx: block,\n     }\n }\n \n-pub fn method_from_methods(ms: &[@ast::method], name: ast::ident)\n-    -> Option<ast::def_id> {\n-    ms.iter().find_(|m| m.ident == name).map(|m| ast_util::local_def(m.id))\n-}\n-\n-pub fn method_with_name_or_default(ccx: &mut CrateContext,\n-                                   impl_id: ast::def_id,\n-                                   name: ast::ident) -> ast::def_id {\n-    let imp = ccx.impl_method_cache.find_copy(&(impl_id, name));\n-    match imp {\n+pub fn method_with_name(ccx: &mut CrateContext,\n+                        impl_id: ast::def_id,\n+                        name: ast::ident) -> ast::def_id {\n+    let meth_id_opt = ccx.impl_method_cache.find_copy(&(impl_id, name));\n+    match meth_id_opt {\n         Some(m) => return m,\n         None => {}\n     }\n \n-    // None of this feels like it should be the best way to do this.\n-    let mut did = if impl_id.crate == ast::local_crate {\n-        match ccx.tcx.items.get_copy(&impl_id.node) {\n-            ast_map::node_item(@ast::item {\n-                node: ast::item_impl(_, _, _, ref ms), _\n-            }, _) => { method_from_methods(*ms, name) },\n-            _ => fail!(\"method_with_name\")\n-        }\n-    } else {\n-        csearch::get_impl_method(ccx.sess.cstore, impl_id, name)\n-    };\n-\n-    if did.is_none() {\n-        // Look for a default method\n-        let pmm = ccx.tcx.provided_methods;\n-        match pmm.find(&impl_id) {\n-            Some(pmis) => {\n-                for pmis.iter().advance |pmi| {\n-                    if pmi.method_info.ident == name {\n-                        debug!(\"pmi.method_info.did = %?\",\n-                               pmi.method_info.did);\n-                        did = Some(pmi.method_info.did);\n-                    }\n-                }\n-            }\n-            None => {}\n-        }\n-    }\n-\n-    let imp = did.expect(\"could not find method while translating\");\n-    ccx.impl_method_cache.insert((impl_id, name), imp);\n-    imp\n-}\n+    let imp = ccx.tcx.impls.find(&impl_id)\n+        .expect(\"could not find impl while translating\");\n+    let meth = imp.methods.iter().find_(|m| m.ident == name)\n+        .expect(\"could not find method while translating\");\n \n-pub fn method_ty_param_count(ccx: &CrateContext, m_id: ast::def_id,\n-                             i_id: ast::def_id) -> uint {\n-    debug!(\"method_ty_param_count: m_id: %?, i_id: %?\", m_id, i_id);\n-    ty::method(ccx.tcx, m_id).generics.type_param_defs.len()\n+    ccx.impl_method_cache.insert((impl_id, name), meth.did);\n+    meth.did\n }\n \n pub fn trans_monomorphized_callee(bcx: block,\n@@ -401,8 +361,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n       typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n           let ccx = bcx.ccx();\n           let mname = ty::trait_method(ccx.tcx, trait_id, n_method).ident;\n-          let mth_id = method_with_name_or_default(\n-              bcx.ccx(), impl_did, mname);\n+          let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n \n           // obtain the `self` value:\n           let mut temp_cleanups = ~[];\n@@ -413,7 +372,7 @@ pub fn trans_monomorphized_callee(bcx: block,\n           // those from the impl and those from the method:\n           let (callee_substs, callee_origins) =\n               combine_impl_and_methods_tps(\n-                  bcx, mth_id, impl_did, callee_id,\n+                  bcx, mth_id, callee_id,\n                   *rcvr_substs, rcvr_origins);\n \n           // translate the function\n@@ -452,7 +411,6 @@ pub fn trans_monomorphized_callee(bcx: block,\n \n pub fn combine_impl_and_methods_tps(bcx: block,\n                                     mth_did: ast::def_id,\n-                                    impl_did: ast::def_id,\n                                     callee_id: ast::node_id,\n                                     rcvr_substs: &[ty::t],\n                                     rcvr_origins: typeck::vtable_res)\n@@ -475,15 +433,16 @@ pub fn combine_impl_and_methods_tps(bcx: block,\n     * mapped to. */\n \n     let ccx = bcx.ccx();\n-    let n_m_tps = method_ty_param_count(ccx, mth_did, impl_did);\n+    let method = ty::method(ccx.tcx, mth_did);\n+    let n_m_tps = method.generics.type_param_defs.len();\n     let node_substs = node_id_type_params(bcx, callee_id);\n-    debug!(\"rcvr_substs=%?\", rcvr_substs.map(|t| bcx.ty_to_str(*t)));\n+    debug!(\"rcvr_substs=%?\", rcvr_substs.repr(ccx.tcx));\n     let ty_substs\n         = vec::append(rcvr_substs.to_owned(),\n                       node_substs.tailn(node_substs.len() - n_m_tps));\n     debug!(\"n_m_tps=%?\", n_m_tps);\n-    debug!(\"node_substs=%?\", node_substs.map(|t| bcx.ty_to_str(*t)));\n-    debug!(\"ty_substs=%?\", ty_substs.map(|t| bcx.ty_to_str(*t)));\n+    debug!(\"node_substs=%?\", node_substs.repr(ccx.tcx));\n+    debug!(\"ty_substs=%?\", ty_substs.repr(ccx.tcx));\n \n \n     // Now, do the same work for the vtables.  The vtables might not\n@@ -744,7 +703,7 @@ pub fn make_impl_vtable(bcx: block,\n         } else {\n             debug!(\"(making impl vtable) adding method to vtable: %s\",\n                    tcx.sess.str_of(im.ident));\n-            let m_id = method_with_name_or_default(ccx, impl_id, im.ident);\n+            let m_id = method_with_name(ccx, impl_id, im.ident);\n \n             trans_fn_ref_with_vtables(bcx, m_id, 0,\n                                       substs, Some(vtables)).llfn"}, {"sha": "cd8160d900edc13f60691f7c1a749249d9cd425d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f0a69b1a43f5785a533566b892411bc041f887f6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0a69b1a43f5785a533566b892411bc041f887f6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f0a69b1a43f5785a533566b892411bc041f887f6", "patch": "@@ -214,21 +214,6 @@ pub enum AutoRef {\n     AutoUnsafe(ast::mutability)\n }\n \n-// Stores information about provided methods (a.k.a. default methods) in\n-// implementations.\n-//\n-// This is a map from ID of each implementation to the method info and trait\n-// method ID of each of the default methods belonging to the trait that\n-// implementation implements.\n-pub type ProvidedMethodsMap = @mut HashMap<def_id,@mut ~[@ProvidedMethodInfo]>;\n-\n-// Stores the method info and definition ID of the associated trait method for\n-// each instantiation of each provided method.\n-pub struct ProvidedMethodInfo {\n-    method_info: @MethodInfo,\n-    trait_method_def_id: def_id\n-}\n-\n pub struct ProvidedMethodSource {\n     method_id: ast::def_id,\n     impl_id: ast::def_id\n@@ -287,10 +272,7 @@ struct ctxt_ {\n     adjustments: @mut HashMap<ast::node_id, @AutoAdjustment>,\n     normalized_cache: @mut HashMap<t, t>,\n     lang_items: middle::lang_items::LanguageItems,\n-    // A mapping from an implementation ID to the method info and trait\n-    // method ID of the provided (a.k.a. default) methods in the traits that\n-    // that implementation implements.\n-    provided_methods: ProvidedMethodsMap,\n+    // A mapping of fake provided method def_ids to the default implementation\n     provided_method_sources: @mut HashMap<ast::def_id, ProvidedMethodSource>,\n     supertraits: @mut HashMap<ast::def_id, @~[@TraitRef]>,\n \n@@ -311,6 +293,12 @@ struct ctxt_ {\n     // Methods in these implementations don't need to be exported.\n     inherent_impls: @mut HashMap<ast::def_id, @mut ~[@Impl]>,\n \n+    // Maps a def_id of an impl to an Impl structure.\n+    // Note that this contains all of the impls that we know about,\n+    // including ones in other crates. It's not clear that this is the best\n+    // way to do it.\n+    impls: @mut HashMap<ast::def_id, @Impl>,\n+\n     // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     // present in this set can be warned about.\n     used_unsafe: @mut HashSet<ast::node_id>,\n@@ -904,13 +892,13 @@ pub fn mk_ctxt(s: session::Session,\n         adjustments: @mut HashMap::new(),\n         normalized_cache: new_ty_hash(),\n         lang_items: lang_items,\n-        provided_methods: @mut HashMap::new(),\n         provided_method_sources: @mut HashMap::new(),\n         supertraits: @mut HashMap::new(),\n         destructor_for_type: @mut HashMap::new(),\n         destructors: @mut HashSet::new(),\n         trait_impls: @mut HashMap::new(),\n         inherent_impls:  @mut HashMap::new(),\n+        impls:  @mut HashMap::new(),\n         used_unsafe: @mut HashSet::new(),\n         used_mut_nodes: @mut HashSet::new(),\n      }"}, {"sha": "a0be0d201f46657e0f75d5186507ba89fd0e057f", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 40, "deletions": 130, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/f0a69b1a43f5785a533566b892411bc041f887f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0a69b1a43f5785a533566b892411bc041f887f6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=f0a69b1a43f5785a533566b892411bc041f887f6", "patch": "@@ -20,7 +20,7 @@ use metadata::csearch;\n use metadata::cstore::{CStore, iter_crate_data};\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n-use middle::ty::{ProvidedMethodSource, ProvidedMethodInfo, get};\n+use middle::ty::{ProvidedMethodSource, get};\n use middle::ty::{lookup_item_type, subst};\n use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n@@ -250,27 +250,16 @@ impl CoherenceChecker {\n             }\n         }\n \n-        // We only want to generate one Impl structure. When we generate one,\n-        // we store it here so that we don't recreate it.\n-        let mut implementation_opt = None;\n+        let implementation = self.create_impl_from_item(item);\n+\n         for associated_traits.iter().advance |associated_trait| {\n-            let trait_ref =\n-                ty::node_id_to_trait_ref(\n-                    self.crate_context.tcx,\n-                    associated_trait.ref_id);\n+            let trait_ref = ty::node_id_to_trait_ref(\n+                self.crate_context.tcx, associated_trait.ref_id);\n             debug!(\"(checking implementation) adding impl for trait '%s', item '%s'\",\n                    trait_ref.repr(self.crate_context.tcx),\n                    self.crate_context.tcx.sess.str_of(item.ident));\n \n-            self.instantiate_default_methods(local_def(item.id), trait_ref);\n-\n-            let implementation;\n-            if implementation_opt.is_none() {\n-                implementation = self.create_impl_from_item(item);\n-                implementation_opt = Some(implementation);\n-            }\n-\n-            self.add_trait_impl(trait_ref.def_id, implementation_opt.get());\n+            self.add_trait_impl(trait_ref.def_id, implementation);\n         }\n \n         // Add the implementation to the mapping from implementation to base\n@@ -285,32 +274,24 @@ impl CoherenceChecker {\n             Some(base_type_def_id) => {\n                 // XXX: Gather up default methods?\n                 if associated_traits.len() == 0 {\n-                    let implementation;\n-                    match implementation_opt {\n-                        None => {\n-                            implementation =\n-                                self.create_impl_from_item(item);\n-                        }\n-                        Some(existing_implementation) => {\n-                            implementation = existing_implementation;\n-                        }\n-                    }\n-\n                     self.add_inherent_impl(base_type_def_id, implementation);\n                 }\n \n                 self.base_type_def_ids.insert(local_def(item.id),\n                                               base_type_def_id);\n             }\n         }\n+\n+        tcx.impls.insert(implementation.did, implementation);\n     }\n \n     // Creates default method IDs and performs type substitutions for an impl\n     // and trait pair. Then, for each provided method in the trait, inserts a\n     // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n     pub fn instantiate_default_methods(&self,\n                                        impl_id: ast::def_id,\n-                                       trait_ref: &ty::TraitRef) {\n+                                       trait_ref: &ty::TraitRef,\n+                                       all_methods: &mut ~[@MethodInfo]) {\n         let tcx = self.crate_context.tcx;\n         debug!(\"instantiate_default_methods(impl_id=%?, trait_ref=%s)\",\n                impl_id, trait_ref.repr(tcx));\n@@ -364,39 +345,13 @@ impl CoherenceChecker {\n             self.crate_context.tcx.provided_method_sources.insert(new_did,\n                                                                   source);\n \n-            let provided_method_info =\n-                @ProvidedMethodInfo {\n-                    method_info: @MethodInfo {\n-                        did: new_did,\n-                        n_tps: trait_method.generics.type_param_defs.len(),\n-                        ident: trait_method.ident,\n-                        explicit_self: trait_method.explicit_self\n-                    },\n-                    trait_method_def_id: trait_method.def_id\n-                };\n-\n-            let pmm = self.crate_context.tcx.provided_methods;\n-            match pmm.find(&impl_id) {\n-                Some(&mis) => {\n-                    // If the trait already has an entry in the\n-                    // provided_methods_map, we just need to add this\n-                    // method to that entry.\n-                    debug!(\"(checking implementation) adding method `%s` \\\n-                            to entry for existing trait\",\n-                            self.crate_context.tcx.sess.str_of(\n-                                provided_method_info.method_info.ident));\n-                    mis.push(provided_method_info);\n-                }\n-                None => {\n-                    // If the trait doesn't have an entry yet, create one.\n-                    debug!(\"(checking implementation) creating new entry \\\n-                            for method `%s`\",\n-                            self.crate_context.tcx.sess.str_of(\n-                                provided_method_info.method_info.ident));\n-                    pmm.insert(impl_id,\n-                               @mut ~[provided_method_info]);\n-                }\n-            }\n+            let method_info = @MethodInfo {\n+                did: new_did,\n+                n_tps: trait_method.generics.type_param_defs.len(),\n+                ident: trait_method.ident,\n+                explicit_self: trait_method.explicit_self\n+            };\n+            all_methods.push(method_info);\n         }\n     }\n \n@@ -606,13 +561,11 @@ impl CoherenceChecker {\n \n     // This check doesn't really have anything to do with coherence. It's\n     // here for historical reasons\n-    pub fn please_check_that_trait_methods_are_implemented(&self,\n-                                                           all_methods:\n-                                                           &mut\n-                                                           ~[@MethodInfo],\n-                                                           trait_did: def_id,\n-                                                           trait_ref_span:\n-                                                           span) {\n+    pub fn check_trait_methods_are_implemented(\n+        &self,\n+        all_methods: &mut ~[@MethodInfo],\n+        trait_did: def_id,\n+        trait_ref_span: span) {\n \n         let tcx = self.crate_context.tcx;\n \n@@ -621,12 +574,6 @@ impl CoherenceChecker {\n         for uint::range(0, all_methods.len()) |i| {\n             provided_names.insert(all_methods[i].ident);\n         }\n-        // Default methods\n-        let r = ty::provided_trait_methods(tcx, trait_did);\n-        for r.iter().advance |method| {\n-            debug!(\"inserting provided method %s\", method.ident.repr(tcx));\n-            provided_names.insert(method.ident);\n-        }\n \n         let r = ty::trait_methods(tcx, trait_did);\n         for r.iter().advance |method| {\n@@ -679,39 +626,6 @@ impl CoherenceChecker {\n         }\n     }\n \n-    fn add_provided_methods_to_impl(\n-        &self,\n-        all_methods: &mut ~[@MethodInfo],\n-        trait_did: &ast::def_id,\n-        impl_id: &ast::def_id) {\n-\n-\n-        match self.crate_context.tcx\n-            .provided_methods\n-            .find(impl_id) {\n-                None => {\n-                    debug!(\"(creating impl) trait with node_id `%d` \\\n-                            has no provided methods\", trait_did.node);\n-                    /* fall through */\n-                }\n-                Some(&all_provided_methods) => {\n-                    debug!(\"(creating impl) trait with node_id `%d` \\\n-                            has provided methods\", trait_did.node);\n-                    // Add all provided methods.\n-                    for all_provided_methods.iter().advance |provided_method| {\n-                        debug!(\n-                            \"(creating impl) adding provided method \\\n-                             `%s` to impl\",\n-                            provided_method.method_info\n-                            .ident.repr(self.crate_context.tcx));\n-                        all_methods.push(provided_method.method_info);\n-                    }\n-                }\n-            }\n-\n-\n-    }\n-\n     // Converts an implementation in the AST to an Impl structure.\n     pub fn create_impl_from_item(&self, item: @item) -> @Impl {\n         match item.node {\n@@ -721,28 +635,23 @@ impl CoherenceChecker {\n                     methods.push(method_to_MethodInfo(*ast_method));\n                 }\n \n-                // Check that we have implementations of every trait method\n                 for trait_refs.iter().advance |trait_ref| {\n-                    let trait_did =\n-                        self.trait_ref_to_trait_def_id(trait_ref);\n-                    self.please_check_that_trait_methods_are_implemented(\n+                    let ty_trait_ref = ty::node_id_to_trait_ref(\n+                        self.crate_context.tcx,\n+                        trait_ref.ref_id);\n+                    let trait_did = ty_trait_ref.def_id;\n+\n+                    self.instantiate_default_methods(local_def(item.id),\n+                                                     ty_trait_ref,\n+                                                     &mut methods);\n+\n+                    // Check that we have implementations of every trait method\n+                    self.check_trait_methods_are_implemented(\n                         &mut methods,\n                         trait_did,\n                         trait_ref.path.span);\n                 }\n \n-                // For each trait that the impl implements, see which\n-                // methods are provided.  For each of those methods,\n-                // if a method of that name is not inherent to the\n-                // impl, use the provided definition in the trait.\n-                for trait_refs.iter().advance |trait_ref| {\n-                    let trait_did = self.trait_ref_to_trait_def_id(trait_ref);\n-                    self.add_provided_methods_to_impl(\n-                        &mut methods,\n-                        &trait_did,\n-                        &local_def(item.id));\n-                }\n-\n                 return @Impl {\n                     did: local_def(item.id),\n                     ident: item.ident,\n@@ -813,15 +722,13 @@ impl CoherenceChecker {\n         // Record all the trait methods.\n         let mut implementation = @implementation;\n         for associated_traits.iter().advance |trait_ref| {\n-            self.instantiate_default_methods(implementation.did,\n-                                             *trait_ref);\n-\n             // XXX(sully): We could probably avoid this copy if there are no\n             // default methods.\n             let mut methods = implementation.methods.clone();\n-            self.add_provided_methods_to_impl(&mut methods,\n-                                              &trait_ref.def_id,\n-                                              &implementation.did);\n+            self.instantiate_default_methods(implementation.did,\n+                                             *trait_ref,\n+                                             &mut methods);\n+\n             implementation = @Impl {\n                 methods: methods,\n                 ..*implementation\n@@ -848,6 +755,9 @@ impl CoherenceChecker {\n                                               base_type_def_id);\n             }\n         }\n+\n+        self.crate_context.tcx.impls.insert(implementation.did,\n+                                            implementation);\n     }\n \n     // Adds implementations and traits from external crates to the coherence"}]}