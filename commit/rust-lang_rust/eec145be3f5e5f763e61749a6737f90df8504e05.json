{"sha": "eec145be3f5e5f763e61749a6737f90df8504e05", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYzE0NWJlM2Y1ZTVmNzYzZTYxNzQ5YTY3MzdmOTBkZjg1MDRlMDU=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-11-06T17:25:16Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-11-06T17:26:08Z"}, "message": "Fallout from collection conventions", "tree": {"sha": "ff30ca7802a92034a30cb57dcf4c89733b2952b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff30ca7802a92034a30cb57dcf4c89733b2952b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eec145be3f5e5f763e61749a6737f90df8504e05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eec145be3f5e5f763e61749a6737f90df8504e05", "html_url": "https://github.com/rust-lang/rust/commit/eec145be3f5e5f763e61749a6737f90df8504e05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eec145be3f5e5f763e61749a6737f90df8504e05/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf3b2e4fe6044cce018b723de9b21c500c6eac41", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf3b2e4fe6044cce018b723de9b21c500c6eac41", "html_url": "https://github.com/rust-lang/rust/commit/cf3b2e4fe6044cce018b723de9b21c500c6eac41"}], "stats": {"total": 835, "additions": 418, "deletions": 417}, "files": [{"sha": "ed394fc0de5f9adf6fbfa4811e2157ee5d2fac45", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -417,7 +417,7 @@ impl SchedPool {\n         }\n \n         // Jettison the task away!\n-        self.handles.get_mut(idx).send(TaskFromFriend(task));\n+        self.handles[idx].send(TaskFromFriend(task));\n     }\n \n     /// Spawns a new scheduler into this M:N pool. A handle is returned to the"}, {"sha": "50b10873faf48c95e454f7b3911e0e0c076dfed7", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -502,7 +502,7 @@ impl Scheduler {\n         let len = work_queues.len();\n         let start_index = self.rng.gen_range(0, len);\n         for index in range(0, len).map(|i| (i + start_index) % len) {\n-            match work_queues.get_mut(index).steal() {\n+            match work_queues[index].steal() {\n                 deque::Data(task) => {\n                     rtdebug!(\"found task by stealing\");\n                     return Some(task)"}, {"sha": "7488cb59830a001889b299a13deb57466d9bcb55", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -220,7 +220,7 @@ fn symbol_hash(tcx: &ty::ctxt,\n }\n \n fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> String {\n-    match ccx.type_hashcodes().borrow().find(&t) {\n+    match ccx.type_hashcodes().borrow().get(&t) {\n         Some(h) => return h.to_string(),\n         None => {}\n     }"}, {"sha": "35ccbb4c7b4103e22eeac6073e4d9c430c774124", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -127,7 +127,7 @@ impl Session {\n                     msg: String) {\n         let lint_id = lint::LintId::of(lint);\n         let mut lints = self.lints.borrow_mut();\n-        match lints.find_mut(&id) {\n+        match lints.get_mut(&id) {\n             Some(arr) => { arr.push((lint_id, sp, msg)); return; }\n             None => {}\n         }"}, {"sha": "d42a9c69dc1251c9f95658505dca01d37b3c9cc7", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -403,7 +403,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                    libc::c_uint or libc::c_ulong should be used\");\n             }\n             def::DefTy(..) => {\n-                let tty = match self.cx.tcx.ast_ty_to_ty_cache.borrow().find(&ty_id) {\n+                let tty = match self.cx.tcx.ast_ty_to_ty_cache.borrow().get(&ty_id) {\n                     Some(&ty::atttce_resolved(t)) => t,\n                     _ => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n                 };\n@@ -994,7 +994,7 @@ impl LintPass for NonSnakeCase {\n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         match &p.node {\n             &ast::PatIdent(_, ref path1, _) => {\n-                match cx.tcx.def_map.borrow().find(&p.id) {\n+                match cx.tcx.def_map.borrow().get(&p.id) {\n                     Some(&def::DefLocal(_)) => {\n                         self.check_snake_case(cx, \"variable\", path1.node, p.span);\n                     }\n@@ -1051,7 +1051,7 @@ impl LintPass for NonUpperCaseGlobals {\n \n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n-        match (&p.node, cx.tcx.def_map.borrow().find(&p.id)) {\n+        match (&p.node, cx.tcx.def_map.borrow().get(&p.id)) {\n             (&ast::PatIdent(_, ref path1, _), Some(&def::DefConst(..))) => {\n                 let s = token::get_ident(path1.node);\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n@@ -1211,7 +1211,7 @@ impl LintPass for NonShorthandFieldPatterns {\n             ast::PatStruct(_, ref v, _) => {\n                 for fieldpat in v.iter()\n                                  .filter(|fieldpat| !fieldpat.node.is_shorthand)\n-                                 .filter(|fieldpat| def_map.find(&fieldpat.node.pat.id)\n+                                 .filter(|fieldpat| def_map.get(&fieldpat.node.pat.id)\n                                     == Some(&def::DefLocal(fieldpat.node.pat.id))) {\n                     match fieldpat.node.pat.node {\n                         ast::PatIdent(_, ident, None) if ident.node.as_str()\n@@ -1368,7 +1368,7 @@ impl LintPass for UnusedAllocation {\n             _ => return\n         }\n \n-        match cx.tcx.adjustments.borrow().find(&e.id) {\n+        match cx.tcx.adjustments.borrow().get(&e.id) {\n             Some(adjustment) => {\n                 match *adjustment {\n                     ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) => {\n@@ -1637,15 +1637,15 @@ impl LintPass for Stability {\n \n         let id = match e.node {\n             ast::ExprPath(..) | ast::ExprStruct(..) => {\n-                match cx.tcx.def_map.borrow().find(&e.id) {\n+                match cx.tcx.def_map.borrow().get(&e.id) {\n                     Some(&def) => def.def_id(),\n                     None => return\n                 }\n             }\n             ast::ExprMethodCall(i, _, _) => {\n                 span = i.span;\n                 let method_call = typeck::MethodCall::expr(e.id);\n-                match cx.tcx.method_map.borrow().find(&method_call) {\n+                match cx.tcx.method_map.borrow().get(&method_call) {\n                     Some(method) => {\n                         match method.origin {\n                             typeck::MethodStatic(def_id) => {"}, {"sha": "76187f192c2b9676dc25b08a7479f738ea7f03ca", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -84,7 +84,7 @@ enum TargetLint {\n \n impl LintStore {\n     fn get_level_source(&self, lint: LintId) -> LevelSource {\n-        match self.levels.find(&lint) {\n+        match self.levels.get(&lint) {\n             Some(&s) => s,\n             None => (Allow, Default),\n         }\n@@ -124,7 +124,7 @@ impl LintStore {\n             self.lints.push((*lint, from_plugin));\n \n             let id = LintId::of(*lint);\n-            if !self.by_name.insert(lint.name_lower(), Id(id)) {\n+            if self.by_name.insert(lint.name_lower(), Id(id)).is_some() {\n                 let msg = format!(\"duplicate specification of lint {}\", lint.name_lower());\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n@@ -147,7 +147,7 @@ impl LintStore {\n     pub fn register_group(&mut self, sess: Option<&Session>,\n                           from_plugin: bool, name: &'static str,\n                           to: Vec<LintId>) {\n-        let new = self.lint_groups.insert(name, (to, from_plugin));\n+        let new = self.lint_groups.insert(name, (to, from_plugin)).is_none();\n \n         if !new {\n             let msg = format!(\"duplicate specification of lint group {}\", name);\n@@ -437,11 +437,11 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n     /// Get the level of `lint` at the current position of the lint\n     /// traversal.\n     pub fn current_level(&self, lint: &'static Lint) -> Level {\n-        self.lints.levels.find(&LintId::of(lint)).map_or(Allow, |&(lvl, _)| lvl)\n+        self.lints.levels.get(&LintId::of(lint)).map_or(Allow, |&(lvl, _)| lvl)\n     }\n \n     fn lookup_and_emit(&self, lint: &'static Lint, span: Option<Span>, msg: &str) {\n-        let (level, src) = match self.lints.levels.find(&LintId::of(lint)) {\n+        let (level, src) = match self.lints.levels.get(&LintId::of(lint)) {\n             None => return,\n             Some(&(Warn, src)) => {\n                 let lint_id = LintId::of(builtin::WARNINGS);\n@@ -750,7 +750,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n // Output any lints that were previously added to the session.\n impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n     fn visit_id(&mut self, id: ast::NodeId) {\n-        match self.tcx.sess.lints.borrow_mut().pop(&id) {\n+        match self.tcx.sess.lints.borrow_mut().remove(&id) {\n             None => {}\n             Some(lints) => {\n                 for (lint_id, span, msg) in lints.into_iter() {"}, {"sha": "36456b3c4a9a00d7de166d893fe5fab2dee4faa3", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -213,7 +213,7 @@ impl CStore {\n \n     pub fn find_extern_mod_stmt_cnum(&self, emod_id: ast::NodeId)\n                                      -> Option<ast::CrateNum> {\n-        self.extern_mod_crate_map.borrow().find(&emod_id).map(|x| *x)\n+        self.extern_mod_crate_map.borrow().get(&emod_id).map(|x| *x)\n     }\n }\n "}, {"sha": "2fd6e2b47870ef0c9b4e765f287bee9108c76364", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -1209,7 +1209,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n         return ast::DefId { krate: cdata.cnum, node: did.node };\n     }\n \n-    match cdata.cnum_map.find(&did.krate) {\n+    match cdata.cnum_map.get(&did.krate) {\n         Some(&n) => {\n             ast::DefId {\n                 krate: n,\n@@ -1321,7 +1321,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n         let cnum = spec.split(':').nth(0).unwrap();\n         let link = spec.split(':').nth(1).unwrap();\n         let cnum = from_str(cnum).unwrap();\n-        let cnum = match cdata.cnum_map.find(&cnum) {\n+        let cnum = match cdata.cnum_map.get(&cnum) {\n             Some(&n) => n,\n             None => panic!(\"didn't find a crate in the cnum_map\")\n         };"}, {"sha": "66b647fabdc8a46a5598793a8ad9647ed1fc4a5c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -253,7 +253,7 @@ fn encode_symbol(ecx: &EncodeContext,\n                  rbml_w: &mut Encoder,\n                  id: NodeId) {\n     rbml_w.start_tag(tag_items_data_item_symbol);\n-    match ecx.item_symbols.borrow().find(&id) {\n+    match ecx.item_symbols.borrow().get(&id) {\n         Some(x) => {\n             debug!(\"encode_symbol(id={}, str={})\", id, *x);\n             rbml_w.writer.write(x.as_bytes());\n@@ -397,7 +397,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          exp: &middle::resolve::Export2)\n                                          -> bool {\n     let impl_items = ecx.tcx.impl_items.borrow();\n-    match ecx.tcx.inherent_impls.borrow().find(&exp.def_id) {\n+    match ecx.tcx.inherent_impls.borrow().get(&exp.def_id) {\n         Some(implementations) => {\n             for base_impl_did in implementations.iter() {\n                 for &method_did in (*impl_items)[*base_impl_did].iter() {\n@@ -426,7 +426,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           rbml_w: &mut Encoder,\n                                           exp: &middle::resolve::Export2)\n                                           -> bool {\n-    match ecx.tcx.trait_items_cache.borrow().find(&exp.def_id) {\n+    match ecx.tcx.trait_items_cache.borrow().get(&exp.def_id) {\n         Some(trait_items) => {\n             for trait_item in trait_items.iter() {\n                 match *trait_item {\n@@ -531,7 +531,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                     id: NodeId,\n                     path: PathElems) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n-    match ecx.reexports2.find(&id) {\n+    match ecx.reexports2.get(&id) {\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for {}\", id);\n             for exp in exports.iter() {\n@@ -978,7 +978,7 @@ fn should_inline(attrs: &[Attribute]) -> bool {\n fn encode_inherent_implementations(ecx: &EncodeContext,\n                                    rbml_w: &mut Encoder,\n                                    def_id: DefId) {\n-    match ecx.tcx.inherent_impls.borrow().find(&def_id) {\n+    match ecx.tcx.inherent_impls.borrow().get(&def_id) {\n         None => {}\n         Some(implementations) => {\n             for &impl_def_id in implementations.iter() {\n@@ -994,7 +994,7 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n fn encode_extension_implementations(ecx: &EncodeContext,\n                                     rbml_w: &mut Encoder,\n                                     trait_def_id: DefId) {\n-    match ecx.tcx.trait_impls.borrow().find(&trait_def_id) {\n+    match ecx.tcx.trait_impls.borrow().get(&trait_def_id) {\n         None => {}\n         Some(implementations) => {\n             for &impl_def_id in implementations.borrow().iter() {\n@@ -1987,7 +1987,7 @@ fn encode_crate_triple(rbml_w: &mut Encoder, triple: &str) {\n \n fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n     rbml_w.start_tag(tag_dylib_dependency_formats);\n-    match ecx.tcx.dependency_formats.borrow().find(&config::CrateTypeDylib) {\n+    match ecx.tcx.dependency_formats.borrow().get(&config::CrateTypeDylib) {\n         Some(arr) => {\n             let s = arr.iter().enumerate().filter_map(|(i, slot)| {\n                 slot.map(|kind| (format!(\"{}:{}\", i + 1, match kind {"}, {"sha": "227a6f71bfda9a9202f7b3955613e60c2ea3b522", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -675,16 +675,16 @@ fn parse_builtin_bounds(st: &mut PState, _conv: conv_did) -> ty::BuiltinBounds {\n     loop {\n         match next(st) {\n             'S' => {\n-                builtin_bounds.add(ty::BoundSend);\n+                builtin_bounds.insert(ty::BoundSend);\n             }\n             'Z' => {\n-                builtin_bounds.add(ty::BoundSized);\n+                builtin_bounds.insert(ty::BoundSized);\n             }\n             'P' => {\n-                builtin_bounds.add(ty::BoundCopy);\n+                builtin_bounds.insert(ty::BoundCopy);\n             }\n             'T' => {\n-                builtin_bounds.add(ty::BoundSync);\n+                builtin_bounds.insert(ty::BoundSync);\n             }\n             '.' => {\n                 return builtin_bounds;"}, {"sha": "027b9980a32b9e4d94a723c57de347a9f9276173", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -50,7 +50,7 @@ pub struct ty_abbrev {\n pub type abbrev_map = RefCell<HashMap<ty::t, ty_abbrev>>;\n \n pub fn enc_ty(w: &mut SeekableMemWriter, cx: &ctxt, t: ty::t) {\n-    match cx.abbrevs.borrow_mut().find(&t) {\n+    match cx.abbrevs.borrow_mut().get(&t) {\n         Some(a) => { w.write(a.s.as_bytes()); return; }\n         None => {}\n     }"}, {"sha": "9268418ef94e9e0e738032267516416c04e3d689", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -1151,14 +1151,14 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     debug!(\"Encoding side tables for id {}\", id);\n \n-    for def in tcx.def_map.borrow().find(&id).iter() {\n+    for def in tcx.def_map.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_def, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| (*def).encode(rbml_w).unwrap());\n         })\n     }\n \n-    for &ty in tcx.node_types.borrow().find(&(id as uint)).iter() {\n+    for &ty in tcx.node_types.borrow().get(&(id as uint)).iter() {\n         rbml_w.tag(c::tag_table_node_type, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1167,7 +1167,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &item_substs in tcx.item_substs.borrow().find(&id).iter() {\n+    for &item_substs in tcx.item_substs.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_item_subst, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1176,7 +1176,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &fv in tcx.freevars.borrow().find(&id).iter() {\n+    for &fv in tcx.freevars.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_freevars, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1209,7 +1209,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    for &cm in tcx.capture_modes.borrow().find(&id).iter() {\n+    for &cm in tcx.capture_modes.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_capture_modes, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1219,7 +1219,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     let lid = ast::DefId { krate: ast::LOCAL_CRATE, node: id };\n-    for &pty in tcx.tcache.borrow().find(&lid).iter() {\n+    for &pty in tcx.tcache.borrow().get(&lid).iter() {\n         rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1228,7 +1228,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &type_param_def in tcx.ty_param_defs.borrow().find(&id).iter() {\n+    for &type_param_def in tcx.ty_param_defs.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_param_defs, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1238,7 +1238,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     }\n \n     let method_call = MethodCall::expr(id);\n-    for &method in tcx.method_map.borrow().find(&method_call).iter() {\n+    for &method in tcx.method_map.borrow().get(&method_call).iter() {\n         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1247,7 +1247,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &trait_ref in tcx.object_cast_map.borrow().find(&id).iter() {\n+    for &trait_ref in tcx.object_cast_map.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1256,11 +1256,11 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    for &adjustment in tcx.adjustments.borrow().find(&id).iter() {\n+    for &adjustment in tcx.adjustments.borrow().get(&id).iter() {\n         match *adjustment {\n             _ if ty::adjust_is_object(adjustment) => {\n                 let method_call = MethodCall::autoobject(id);\n-                for &method in tcx.method_map.borrow().find(&method_call).iter() {\n+                for &method in tcx.method_map.borrow().get(&method_call).iter() {\n                     rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                         rbml_w.id(id);\n                         rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1273,7 +1273,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                 assert!(!ty::adjust_is_object(adjustment));\n                 for autoderef in range(0, adj.autoderefs) {\n                     let method_call = MethodCall::autoderef(id, autoderef);\n-                    for &method in tcx.method_map.borrow().find(&method_call).iter() {\n+                    for &method in tcx.method_map.borrow().get(&method_call).iter() {\n                         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n                             rbml_w.id(id);\n                             rbml_w.tag(c::tag_table_val, |rbml_w| {\n@@ -1299,7 +1299,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n     for unboxed_closure in tcx.unboxed_closures\n                               .borrow()\n-                              .find(&ast_util::local_def(id))\n+                              .get(&ast_util::local_def(id))\n                               .iter() {\n         rbml_w.tag(c::tag_table_unboxed_closures, |rbml_w| {\n             rbml_w.id(id);"}, {"sha": "2a92db3e7d4ec9e14e20aebcdc6ae5f7078a8b3a", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -242,7 +242,7 @@ impl MoveData {\n          * base paths that do not yet have an index.\n          */\n \n-        match self.path_map.borrow().find(&lp) {\n+        match self.path_map.borrow().get(&lp) {\n             Some(&index) => {\n                 return index;\n             }\n@@ -577,7 +577,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n         //! Returns the kind of a move of `loan_path` by `id`, if one exists.\n \n         let mut ret = None;\n-        for loan_path_index in self.move_data.path_map.borrow().find(&*loan_path).iter() {\n+        for loan_path_index in self.move_data.path_map.borrow().get(&*loan_path).iter() {\n             self.dfcx_moves.each_gen_bit(id, |move_index| {\n                 let the_move = self.move_data.moves.borrow();\n                 let the_move = (*the_move)[move_index];"}, {"sha": "1e38250ceb38db8ecb3f87b046d7ab3d542c477f", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -512,7 +512,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             func_or_rcvr: &ast::Expr,\n             args: I) -> CFGIndex {\n         let method_call = typeck::MethodCall::expr(call_expr.id);\n-        let return_ty = ty::ty_fn_ret(match self.tcx.method_map.borrow().find(&method_call) {\n+        let return_ty = ty::ty_fn_ret(match self.tcx.method_map.borrow().get(&method_call) {\n             Some(method) => method.ty,\n             None => ty::expr_ty(self.tcx, func_or_rcvr)\n         });\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             Some(_) => {\n-                match self.tcx.def_map.borrow().find(&expr.id) {\n+                match self.tcx.def_map.borrow().get(&expr.id) {\n                     Some(&def::DefLabel(loop_id)) => {\n                         for l in self.loop_scopes.iter() {\n                             if l.loop_id == loop_id {"}, {"sha": "b03fe0f3f6fb8e72f1d70cf6b11f339d625d9d3d", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -143,7 +143,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n                           \"paths in constants may only refer to items without \\\n                            type parameters\");\n             }\n-            match v.tcx.def_map.borrow().find(&e.id) {\n+            match v.tcx.def_map.borrow().get(&e.id) {\n                 Some(&DefStatic(..)) |\n                 Some(&DefConst(..)) |\n                 Some(&DefFn(..)) |\n@@ -162,7 +162,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &Expr) -> bool {\n             }\n         }\n         ExprCall(ref callee, _) => {\n-            match v.tcx.def_map.borrow().find(&callee.id) {\n+            match v.tcx.def_map.borrow().get(&callee.id) {\n                 Some(&DefStruct(..)) |\n                 Some(&DefVariant(..)) => {}    // OK.\n "}, {"sha": "4dcd5d8873ea467cb4dd25fdced4b26ba5aae6ec", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -639,7 +639,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     let pat = raw_pat(p);\n     match pat.node {\n         PatIdent(..) =>\n-            match cx.tcx.def_map.borrow().find(&pat.id) {\n+            match cx.tcx.def_map.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n@@ -648,15 +648,15 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                 _ => vec!()\n             },\n         PatEnum(..) =>\n-            match cx.tcx.def_map.borrow().find(&pat.id) {\n+            match cx.tcx.def_map.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n         PatStruct(..) =>\n-            match cx.tcx.def_map.borrow().find(&pat.id) {\n+            match cx.tcx.def_map.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),"}, {"sha": "a3738f031a9655329d33d2d8d663896bc5e34843", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n             ast::ExprPath(..) => {\n-                match self.def_map.borrow().find(&e.id) {\n+                match self.def_map.borrow().get(&e.id) {\n                     Some(&DefStatic(def_id, _)) |\n                     Some(&DefConst(def_id)) if\n                             ast_util::is_local(def_id) => {"}, {"sha": "fdda5f1a860e6dce1248bec81427880393582d8a", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -123,7 +123,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n             Some(_) => None\n         }\n     } else {\n-        match tcx.extern_const_variants.borrow().find(&variant_def) {\n+        match tcx.extern_const_variants.borrow().get(&variant_def) {\n             Some(&ast::DUMMY_NODE_ID) => return None,\n             Some(&expr_id) => {\n                 return Some(tcx.map.expect_expr(expr_id));\n@@ -163,7 +163,7 @@ pub fn lookup_const_by_id<'a>(tcx: &'a ty::ctxt, def_id: ast::DefId)\n             Some(_) => None\n         }\n     } else {\n-        match tcx.extern_const_statics.borrow().find(&def_id) {\n+        match tcx.extern_const_statics.borrow().get(&def_id) {\n             Some(&ast::DUMMY_NODE_ID) => return None,\n             Some(&expr_id) => {\n                 return Some(tcx.map.expect_expr(expr_id));\n@@ -192,7 +192,7 @@ struct ConstEvalVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ConstEvalVisitor<'a, 'tcx> {\n     fn classify(&mut self, e: &Expr) -> constness {\n         let did = ast_util::local_def(e.id);\n-        match self.ccache.find(&did) {\n+        match self.ccache.get(&did) {\n             Some(&x) => return x,\n             None => {}\n         }"}, {"sha": "97dfa4ecd361a403f9146226c6531abe162a9217", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -86,7 +86,7 @@ struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O: 'a> {\n }\n \n fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n-    let opt_cfgindex = index.find(&id).map(|&i|i);\n+    let opt_cfgindex = index.get(&id).map(|&i|i);\n     opt_cfgindex.unwrap_or_else(|| {\n         panic!(\"nodeid_to_index does not have entry for NodeId {}\", id);\n     })\n@@ -397,7 +397,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n             let mut changed = false;\n             for &node_id in edge.data.exiting_scopes.iter() {\n-                let opt_cfg_idx = self.nodeid_to_index.find(&node_id).map(|&i|i);\n+                let opt_cfg_idx = self.nodeid_to_index.get(&node_id).map(|&i|i);\n                 match opt_cfg_idx {\n                     Some(cfg_idx) => {\n                         let (start, end) = self.compute_id_range(cfg_idx);"}, {"sha": "2ae2f9bfe7a027fc5f0c0d0dc2cab87e6725b9ea", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn lookup_and_handle_definition(&mut self, id: &ast::NodeId) {\n-        self.tcx.def_map.borrow().find(id).map(|def| {\n+        self.tcx.def_map.borrow().get(id).map(|def| {\n             match def {\n                 &def::DefConst(_) => {\n                     self.check_def_id(def.def_id())\n@@ -95,7 +95,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn lookup_and_handle_method(&mut self, id: ast::NodeId,\n                                 span: codemap::Span) {\n         let method_call = typeck::MethodCall::expr(id);\n-        match self.tcx.method_map.borrow().find(&method_call) {\n+        match self.tcx.method_map.borrow().get(&method_call) {\n             Some(method) => {\n                 match method.origin {\n                     typeck::MethodStatic(def_id) => {\n@@ -493,7 +493,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         // method of a private type is used, but the type itself is never\n         // called directly.\n         let impl_items = self.tcx.impl_items.borrow();\n-        match self.tcx.inherent_impls.borrow().find(&local_def(id)) {\n+        match self.tcx.inherent_impls.borrow().get(&local_def(id)) {\n             None => (),\n             Some(impl_list) => {\n                 for impl_did in impl_list.iter() {"}, {"sha": "bfabcc958d7c113e9df9235fbd6516caabc3835b", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -158,7 +158,7 @@ fn calculate_type(sess: &session::Session,\n \n     // Collect what we've got so far in the return vector.\n     let mut ret = range(1, sess.cstore.next_crate_num()).map(|i| {\n-        match formats.find(&i).map(|v| *v) {\n+        match formats.get(&i).map(|v| *v) {\n             v @ Some(cstore::RequireDynamic) => v,\n             _ => None,\n         }\n@@ -209,7 +209,7 @@ fn add_library(sess: &session::Session,\n                cnum: ast::CrateNum,\n                link: cstore::LinkagePreference,\n                m: &mut HashMap<ast::CrateNum, cstore::LinkagePreference>) {\n-    match m.find(&cnum) {\n+    match m.get(&cnum) {\n         Some(&link2) => {\n             // If the linkages differ, then we'd have two copies of the library\n             // if we continued linking. If the linkages are both static, then we"}, {"sha": "d12b612b03361e331345e3ff104d91ca19e0101b", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -162,7 +162,7 @@ impl OverloadedCallType {\n         let trait_did =\n             tcx.unboxed_closures\n                .borrow()\n-               .find(&closure_did)\n+               .get(&closure_did)\n                .expect(\"OverloadedCallType::from_unboxed_closure: didn't \\\n                         find closure id\")\n                .kind\n@@ -535,7 +535,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                     match self.tcx()\n                               .method_map\n                               .borrow()\n-                              .find(&MethodCall::expr(call.id)) {\n+                              .get(&MethodCall::expr(call.id)) {\n                     Some(ref method_callee) => {\n                         OverloadedCallType::from_method_origin(\n                             self.tcx(),\n@@ -686,7 +686,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n     // process.\n     fn walk_adjustment(&mut self, expr: &ast::Expr) {\n         let typer = self.typer;\n-        match typer.adjustments().borrow().find(&expr.id) {\n+        match typer.adjustments().borrow().get(&expr.id) {\n             None => { }\n             Some(adjustment) => {\n                 match *adjustment {"}, {"sha": "1f3473c159f22c0d13100985fdc36c684e0d5936", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -173,7 +173,7 @@ impl<'a> LanguageItemCollector<'a> {\n         }\n \n         // Matched.\n-        *self.items.items.get_mut(item_index) = Some(item_def_id);\n+        self.items.items[item_index] = Some(item_def_id);\n     }\n \n     pub fn collect_local_language_items(&mut self, krate: &ast::Crate) {"}, {"sha": "dff9c45611aa9f634cf6f736e01068a9717921ed", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -322,7 +322,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     }\n \n     fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n-        match self.variable_map.find(&node_id) {\n+        match self.variable_map.get(&node_id) {\n           Some(&var) => var,\n           None => {\n             self.tcx\n@@ -591,7 +591,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn live_node(&self, node_id: NodeId, span: Span) -> LiveNode {\n-        match self.ir.live_node_map.find(&node_id) {\n+        match self.ir.live_node_map.get(&node_id) {\n           Some(&ln) => ln,\n           None => {\n             // This must be a mismatch between the ir_map construction\n@@ -719,7 +719,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             Some(_) => {\n                 // Refers to a labeled loop. Use the results of resolve\n                 // to find with one\n-                match self.ir.tcx.def_map.borrow().find(&id) {\n+                match self.ir.tcx.def_map.borrow().get(&id) {\n                     Some(&DefLabel(loop_id)) => loop_id,\n                     _ => self.ir.tcx.sess.span_bug(sp, \"label on break/loop \\\n                                                         doesn't refer to a loop\")\n@@ -988,7 +988,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n                  // the construction of a closure itself is not important,\n                  // but we have to consider the closed over variables.\n-                 let caps = match this.ir.capture_info_map.find(&expr.id) {\n+                 let caps = match this.ir.capture_info_map.get(&expr.id) {\n                     Some(caps) => caps.clone(),\n                     None => {\n                         this.ir.tcx.sess.span_bug(expr.span, \"no registered caps\");\n@@ -1096,7 +1096,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n \n-              match self.break_ln.find(&sc) {\n+              match self.break_ln.get(&sc) {\n                   Some(&b) => b,\n                   None => self.ir.tcx.sess.span_bug(expr.span,\n                                                     \"break to unknown label\")\n@@ -1110,7 +1110,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n \n-              match self.cont_ln.find(&sc) {\n+              match self.cont_ln.get(&sc) {\n                   Some(&b) => b,\n                   None => self.ir.tcx.sess.span_bug(expr.span,\n                                                     \"loop to unknown label\")\n@@ -1167,7 +1167,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           ExprMethodCall(_, _, ref args) => {\n             let method_call = typeck::MethodCall::expr(expr.id);\n-            let method_ty = self.ir.tcx.method_map.borrow().find(&method_call).unwrap().ty;\n+            let method_ty = self.ir.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n             let diverges = ty::ty_fn_ret(method_ty) == ty::FnDiverging;\n             let succ = if diverges {\n                 self.s.exit_ln\n@@ -1520,7 +1520,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             ty::ty_unboxed_closure(closure_def_id, _, _) =>\n                 self.ir.tcx.unboxed_closures()\n                     .borrow()\n-                    .find(&closure_def_id)\n+                    .get(&closure_def_id)\n                     .unwrap()\n                     .closure_type\n                     .sig"}, {"sha": "4c396a5a2051030c650b61b0db54f71739900fc4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -389,7 +389,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<ty::t> {\n         let unadjusted_ty = if_ok!(self.expr_ty(expr));\n         Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n-                         self.typer.adjustments().borrow().find(&expr.id),\n+                         self.typer.adjustments().borrow().get(&expr.id),\n                          |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n@@ -402,7 +402,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     }\n \n     pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt> {\n-        match self.typer.adjustments().borrow().find(&expr.id) {\n+        match self.typer.adjustments().borrow().get(&expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)\n@@ -861,7 +861,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                              deref_cnt: uint,\n                              implicit: bool)\n                              -> cmt {\n-        let adjustment = match self.typer.adjustments().borrow().find(&node.id()) {\n+        let adjustment = match self.typer.adjustments().borrow().get(&node.id()) {\n             Some(adj) if ty::adjust_is_object(adj) => typeck::AutoObject,\n             _ if deref_cnt != 0 => typeck::AutoDeref(deref_cnt),\n             _ => typeck::NoAdjustment\n@@ -1170,7 +1170,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             // variant(..)\n           }\n           ast::PatEnum(_, Some(ref subpats)) => {\n-            match self.tcx().def_map.borrow().find(&pat.id) {\n+            match self.tcx().def_map.borrow().get(&pat.id) {\n                 Some(&def::DefVariant(enum_did, _, _)) => {\n                     // variant(x, y, z)\n "}, {"sha": "958f65d7efb25357c94bfa635c255d262f4a22a5", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -34,7 +34,7 @@ pub fn pat_is_refutable(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatLit(_) | PatRange(_, _) => true,\n         PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {\n-            match dm.borrow().find(&pat.id) {\n+            match dm.borrow().get(&pat.id) {\n                 Some(&DefVariant(..)) => true,\n                 _ => false\n             }\n@@ -47,7 +47,7 @@ pub fn pat_is_refutable(dm: &resolve::DefMap, pat: &Pat) -> bool {\n pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {\n-            match dm.borrow().find(&pat.id) {\n+            match dm.borrow().get(&pat.id) {\n                 Some(&DefVariant(..)) | Some(&DefStruct(..)) => true,\n                 _ => false\n             }\n@@ -59,7 +59,7 @@ pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &Pat) -> bool {\n pub fn pat_is_const(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatIdent(_, _, None) | PatEnum(..) => {\n-            match dm.borrow().find(&pat.id) {\n+            match dm.borrow().get(&pat.id) {\n                 Some(&DefConst(..)) => true,\n                 _ => false\n             }"}, {"sha": "24c653e415e57f95227dd3e5990d7ccff64ff4ec", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -399,7 +399,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             }\n             debug!(\"privacy - is {} a public method\", did);\n \n-            return match self.tcx.impl_or_trait_items.borrow().find(&did) {\n+            return match self.tcx.impl_or_trait_items.borrow().get(&did) {\n                 Some(&ty::MethodTraitItem(ref meth)) => {\n                     debug!(\"privacy - well at least it's a method: {}\",\n                            *meth);\n@@ -462,7 +462,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         debug!(\"privacy - local {} not public all the way down\",\n                self.tcx.map.node_to_string(did.node));\n         // return quickly for things in the same module\n-        if self.parents.find(&did.node) == self.parents.find(&self.curitem) {\n+        if self.parents.get(&did.node) == self.parents.get(&self.curitem) {\n             debug!(\"privacy - same parent, we're done here\");\n             return Allowable;\n         }\n@@ -855,7 +855,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             ast::ExprMethodCall(ident, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                match self.tcx.method_map.borrow().find(&method_call) {\n+                match self.tcx.method_map.borrow().get(&method_call) {\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,\n                                                 \"method call not in \\\n@@ -909,7 +909,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                              with private fields\");\n                     }\n                 };\n-                match self.tcx.def_map.borrow().find(&expr.id) {\n+                match self.tcx.def_map.borrow().get(&expr.id) {\n                     Some(&def::DefStruct(did)) => {\n                         guard(if is_local(did) {\n                             local_def(self.tcx.map.get_parent(did.node))\n@@ -986,7 +986,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.borrow().find(&pattern.id) {\n+                        match self.tcx.def_map.borrow().get(&pattern.id) {\n                             Some(&def::DefVariant(_, variant_id, _)) => {\n                                 for field in fields.iter() {\n                                     self.check_field(pattern.span, variant_id,"}, {"sha": "dbeb2e289fb74f4a6a1cf97e8bad8930331bf9b6", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n \n         match expr.node {\n             ast::ExprPath(_) => {\n-                let def = match self.tcx.def_map.borrow().find(&expr.id) {\n+                let def = match self.tcx.def_map.borrow().get(&expr.id) {\n                     Some(&def) => def,\n                     None => {\n                         self.tcx.sess.span_bug(expr.span,"}, {"sha": "d380c35580d181e2f3bacb0f90fdbc9748d6d443", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -103,7 +103,7 @@ struct RegionResolutionVisitor<'a> {\n \n impl RegionMaps {\n     pub fn relate_free_regions(&self, sub: FreeRegion, sup: FreeRegion) {\n-        match self.free_region_map.borrow_mut().find_mut(&sub) {\n+        match self.free_region_map.borrow_mut().get_mut(&sub) {\n             Some(sups) => {\n                 if !sups.iter().any(|x| x == &sup) {\n                     sups.push(sup);\n@@ -149,13 +149,13 @@ impl RegionMaps {\n \n     pub fn opt_encl_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        self.scope_map.borrow().find(&id).map(|x| *x)\n+        self.scope_map.borrow().get(&id).map(|x| *x)\n     }\n \n     #[allow(dead_code)] // used in middle::cfg\n     pub fn encl_scope(&self, id: ast::NodeId) -> ast::NodeId {\n         //! Returns the narrowest scope that encloses `id`, if any.\n-        match self.scope_map.borrow().find(&id) {\n+        match self.scope_map.borrow().get(&id) {\n             Some(&r) => r,\n             None => { panic!(\"no enclosing scope for id {}\", id); }\n         }\n@@ -165,7 +165,7 @@ impl RegionMaps {\n         /*!\n          * Returns the lifetime of the local variable `var_id`\n          */\n-        match self.var_map.borrow().find(&var_id) {\n+        match self.var_map.borrow().get(&var_id) {\n             Some(&r) => r,\n             None => { panic!(\"no enclosing scope for id {}\", var_id); }\n         }\n@@ -175,7 +175,7 @@ impl RegionMaps {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n-        match self.rvalue_scopes.borrow().find(&expr_id) {\n+        match self.rvalue_scopes.borrow().get(&expr_id) {\n             Some(&s) => {\n                 debug!(\"temporary_scope({}) = {} [custom]\", expr_id, s);\n                 return Some(s);\n@@ -232,7 +232,7 @@ impl RegionMaps {\n \n         let mut s = subscope;\n         while superscope != s {\n-            match self.scope_map.borrow().find(&s) {\n+            match self.scope_map.borrow().get(&s) {\n                 None => {\n                     debug!(\"is_subscope_of({}, {}, s={})=false\",\n                            subscope, superscope, s);\n@@ -356,7 +356,7 @@ impl RegionMaps {\n             let mut result = vec!(scope);\n             let mut scope = scope;\n             loop {\n-                match this.scope_map.borrow().find(&scope) {\n+                match this.scope_map.borrow().get(&scope) {\n                     None => return result,\n                     Some(&superscope) => {\n                         result.push(superscope);"}, {"sha": "a8adbbe8fecac4b897ff2e174ae68ef6c2857ac2", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -2234,7 +2234,7 @@ impl<'a> Resolver<'a> {\n \n                 let mut import_resolutions = module_.import_resolutions\n                                                     .borrow_mut();\n-                match import_resolutions.find_mut(&target) {\n+                match import_resolutions.get_mut(&target) {\n                     Some(resolution) => {\n                         debug!(\"(building import directive) bumping \\\n                                 reference\");\n@@ -2552,7 +2552,7 @@ impl<'a> Resolver<'a> {\n         // Search for direct children of the containing module.\n         self.populate_module_if_necessary(&containing_module);\n \n-        match containing_module.children.borrow().find(&source) {\n+        match containing_module.children.borrow().get(&source) {\n             None => {\n                 // Continue.\n             }\n@@ -2588,7 +2588,7 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 // Now search the exported imports within the containing module.\n-                match containing_module.import_resolutions.borrow().find(&source) {\n+                match containing_module.import_resolutions.borrow().get(&source) {\n                     None => {\n                         debug!(\"(resolving single import) no import\");\n                         // The containing module definitely doesn't have an\n@@ -2853,7 +2853,7 @@ impl<'a> Resolver<'a> {\n \n             // Here we merge two import resolutions.\n             let mut import_resolutions = module_.import_resolutions.borrow_mut();\n-            match import_resolutions.find_mut(ident) {\n+            match import_resolutions.get_mut(ident) {\n                 Some(dest_import_resolution) => {\n                     // Merge the two import resolutions at a finer-grained\n                     // level.\n@@ -3046,7 +3046,7 @@ impl<'a> Resolver<'a> {\n \n         // Check for item conflicts.\n         let children = module.children.borrow();\n-        let name_bindings = match children.find(&name) {\n+        let name_bindings = match children.get(&name) {\n             None => {\n                 // There can't be any conflicts.\n                 return\n@@ -3432,7 +3432,7 @@ impl<'a> Resolver<'a> {\n         // its immediate children.\n         self.populate_module_if_necessary(&module_);\n \n-        match module_.children.borrow().find(&name) {\n+        match module_.children.borrow().get(&name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n                 debug!(\"top name bindings succeeded\");\n@@ -3448,7 +3448,7 @@ impl<'a> Resolver<'a> {\n         // all its imports in the usual way; this is because chains of\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n-        match module_.import_resolutions.borrow().find(&name) {\n+        match module_.import_resolutions.borrow().get(&name) {\n             None => {\n                 // Not found; continue.\n             }\n@@ -3705,7 +3705,7 @@ impl<'a> Resolver<'a> {\n         // First, check the direct children of the module.\n         self.populate_module_if_necessary(&module_);\n \n-        match module_.children.borrow().find(&name) {\n+        match module_.children.borrow().get(&name) {\n             Some(name_bindings)\n                     if name_bindings.defined_in_namespace(namespace) => {\n                 debug!(\"(resolving name in module) found node as child\");\n@@ -3728,7 +3728,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Check the list of resolved imports.\n-        match module_.import_resolutions.borrow().find(&name) {\n+        match module_.import_resolutions.borrow().get(&name) {\n             Some(import_resolution) if allow_private_imports ||\n                                        import_resolution.is_public => {\n \n@@ -3967,7 +3967,7 @@ impl<'a> Resolver<'a> {\n             Some(name) => {\n                 self.populate_module_if_necessary(&orig_module);\n \n-                match orig_module.children.borrow().find(&name) {\n+                match orig_module.children.borrow().get(&name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n                                token::get_name(name),\n@@ -4691,7 +4691,7 @@ impl<'a> Resolver<'a> {\n             Some(ref trait_ref) => {\n                 self.resolve_trait_reference(id, trait_ref, TraitImplementation);\n \n-                match self.def_map.borrow().find(&trait_ref.ref_id) {\n+                match self.def_map.borrow().get(&trait_ref.ref_id) {\n                     Some(def) => {\n                         let did = def.def_id();\n                         Some((did, trait_ref.clone()))\n@@ -4767,7 +4767,7 @@ impl<'a> Resolver<'a> {\n                 // a type (shadowing any imported modules or types with this name), leading\n                 // to weird user-visible bugs. So we ward this off here. See #15060.\n                 TyPath(ref path, _, path_id) => {\n-                    match self.def_map.borrow().find(&path_id) {\n+                    match self.def_map.borrow().get(&path_id) {\n                         // FIXME: should we catch other options and give more precise errors?\n                         Some(&DefMod(_)) => {\n                             self.resolve_error(path.span, \"inherent implementations are not \\\n@@ -4785,7 +4785,7 @@ impl<'a> Resolver<'a> {\n     fn check_trait_item(&self, name: Name, span: Span) {\n         // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n         for &(did, ref trait_ref) in self.current_trait_ref.iter() {\n-            if self.trait_item_map.find(&(name, did)).is_none() {\n+            if self.trait_item_map.get(&(name, did)).is_none() {\n                 let path_str = self.path_names_to_string(&trait_ref.path);\n                 self.resolve_error(span,\n                                     format!(\"method `{}` is not a member of trait `{}`\",\n@@ -4849,7 +4849,7 @@ impl<'a> Resolver<'a> {\n             let map_i = self.binding_mode_map(&**p);\n \n             for (&key, &binding_0) in map_0.iter() {\n-                match map_i.find(&key) {\n+                match map_i.get(&key) {\n                   None => {\n                     self.resolve_error(\n                         p.span,\n@@ -4908,7 +4908,7 @@ impl<'a> Resolver<'a> {\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module.clone();\n-        match orig_module.anonymous_children.borrow().find(&block.id) {\n+        match orig_module.anonymous_children.borrow().get(&block.id) {\n             None => { /* Nothing to do. */ }\n             Some(anonymous_module) => {\n                 debug!(\"(resolving block) found anonymous module, moving \\\n@@ -4943,7 +4943,7 @@ impl<'a> Resolver<'a> {\n \n                     match self.primitive_type_table\n                             .primitive_types\n-                            .find(&id.name) {\n+                            .get(&id.name) {\n \n                         Some(&primitive_type) => {\n                             result_def =\n@@ -5181,7 +5181,7 @@ impl<'a> Resolver<'a> {\n                                                            token::get_ident(\n                                                                ident))\n                                                    .as_slice())\n-                            } else if bindings_list.find(&renamed) ==\n+                            } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n                                 // same disjunction, which is an error.\n@@ -5407,7 +5407,7 @@ impl<'a> Resolver<'a> {\n         // First, search children.\n         self.populate_module_if_necessary(&containing_module);\n \n-        match containing_module.children.borrow().find(&name) {\n+        match containing_module.children.borrow().get(&name) {\n             Some(child_name_bindings) => {\n                 match child_name_bindings.def_for_namespace(namespace) {\n                     Some(def) => {\n@@ -5426,7 +5426,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Next, search import resolutions.\n-        match containing_module.import_resolutions.borrow().find(&name) {\n+        match containing_module.import_resolutions.borrow().get(&name) {\n             Some(import_resolution) if import_resolution.is_public => {\n                 match (*import_resolution).target_for_namespace(namespace) {\n                     Some(target) => {\n@@ -5715,10 +5715,10 @@ impl<'a> Resolver<'a> {\n             let last_name = name_path.last().unwrap();\n \n             if name_path.len() == 1 {\n-                match this.primitive_type_table.primitive_types.find(last_name) {\n+                match this.primitive_type_table.primitive_types.get(last_name) {\n                     Some(_) => None,\n                     None => {\n-                        match this.current_module.children.borrow().find(last_name) {\n+                        match this.current_module.children.borrow().get(last_name) {\n                             Some(child) => child.get_module_if_available(),\n                             None => None\n                         }\n@@ -5746,10 +5746,10 @@ impl<'a> Resolver<'a> {\n \n         if allowed == Everything {\n             // Look for a field with the same name in the current self_type.\n-            match self.def_map.borrow().find(&node_id) {\n+            match self.def_map.borrow().get(&node_id) {\n                  Some(&DefTy(did, _))\n                 | Some(&DefStruct(did))\n-                | Some(&DefVariant(_, did, _)) => match self.structs.find(&did) {\n+                | Some(&DefVariant(_, did, _)) => match self.structs.get(&did) {\n                     None => {}\n                     Some(fields) => {\n                         if fields.iter().any(|&field_name| name == field_name) {\n@@ -5765,7 +5765,7 @@ impl<'a> Resolver<'a> {\n \n         // Look for a method in the current self type's impl module.\n         match get_module(self, path.span, name_path.as_slice()) {\n-            Some(module) => match module.children.borrow().find(&name) {\n+            Some(module) => match module.children.borrow().get(&name) {\n                 Some(binding) => {\n                     let p_str = self.path_names_to_string(&path);\n                     match binding.def_for_namespace(ValueNS) {\n@@ -5790,7 +5790,7 @@ impl<'a> Resolver<'a> {\n             Some((did, ref trait_ref)) => {\n                 let path_str = self.path_names_to_string(&trait_ref.path);\n \n-                match self.trait_item_map.find(&(name, did)) {\n+                match self.trait_item_map.get(&(name, did)) {\n                     Some(&StaticMethodTraitItemKind) => {\n                         return TraitMethod(path_str)\n                     }\n@@ -6270,7 +6270,7 @@ impl<'a> Resolver<'a> {\n                                   \"unused import\".to_string());\n         }\n \n-        let (v_priv, t_priv) = match self.last_private.find(&id) {\n+        let (v_priv, t_priv) = match self.last_private.get(&id) {\n             Some(&LastImport {\n                 value_priv: v,\n                 value_used: _,"}, {"sha": "7fcc58d8f4e4b4ff75fc10494669ccf77bdf6b1c", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -906,7 +906,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         let cache = self.pick_candidate_cache(&cache_skol_trait_ref);\n         let hashmap = cache.hashmap.borrow();\n-        hashmap.find(&cache_skol_trait_ref).map(|c| (*c).clone())\n+        hashmap.get(&cache_skol_trait_ref).map(|c| (*c).clone())\n     }\n \n     fn insert_candidate_cache(&mut self,\n@@ -1032,7 +1032,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                self_ty.repr(self.tcx()),\n                obligation.repr(self.tcx()));\n \n-        let closure_kind = match self.typer.unboxed_closures().borrow().find(&closure_def_id) {\n+        let closure_kind = match self.typer.unboxed_closures().borrow().get(&closure_def_id) {\n             Some(closure) => closure.kind,\n             None => {\n                 self.tcx().sess.span_bug(\n@@ -1282,7 +1282,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                             ty::BoundSync |\n                             ty::BoundSend => {\n-                                if c.bounds.builtin_bounds.contains_elem(bound) {\n+                                if c.bounds.builtin_bounds.contains(&bound) {\n                                     Ok(If(Vec::new()))\n                                 } else {\n                                     Err(Unimplemented)\n@@ -1306,7 +1306,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                             ty::BoundSync |\n                             ty::BoundSend => {\n-                                if c.bounds.builtin_bounds.contains_elem(bound) {\n+                                if c.bounds.builtin_bounds.contains(&bound) {\n                                     Ok(If(Vec::new()))\n                                 } else {\n                                     Err(Unimplemented)\n@@ -1323,7 +1323,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         Err(Unimplemented)\n                     }\n                     ty::BoundCopy | ty::BoundSync | ty::BoundSend => {\n-                        if bounds.builtin_bounds.contains_elem(bound) {\n+                        if bounds.builtin_bounds.contains(&bound) {\n                             Ok(If(Vec::new()))\n                         } else {\n                             Err(Unimplemented)\n@@ -1428,7 +1428,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // is reserve judgement and then intertwine this\n                 // analysis with closure inference.\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n-                match self.tcx().freevars.borrow().find(&def_id.node) {\n+                match self.tcx().freevars.borrow().get(&def_id.node) {\n                     None => {\n                         // No upvars.\n                         Ok(If(Vec::new()))\n@@ -1690,7 +1690,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                closure_def_id.repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n-        let closure_type = match self.typer.unboxed_closures().borrow().find(&closure_def_id) {\n+        let closure_type = match self.typer.unboxed_closures().borrow().get(&closure_def_id) {\n             Some(closure) => closure.closure_type.clone(),\n             None => {\n                 self.tcx().sess.span_bug(\n@@ -1973,7 +1973,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n                                                             trait_def_id);\n-        match self.tcx().trait_impls.borrow().find(&trait_def_id) {\n+        match self.tcx().trait_impls.borrow().get(&trait_def_id) {\n             None => Vec::new(),\n             Some(impls) => impls.borrow().clone()\n         }"}, {"sha": "e148261b1bf265c0065cef050fbfae08345306cc", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -696,13 +696,13 @@ fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: uint) -> bool {\n         match pat.node {\n             ast::PatTup(_) => true,\n             ast::PatStruct(..) => {\n-                match tcx.def_map.borrow().find(&pat.id) {\n+                match tcx.def_map.borrow().get(&pat.id) {\n                     Some(&def::DefVariant(..)) => false,\n                     _ => true,\n                 }\n             }\n             ast::PatEnum(..) | ast::PatIdent(_, _, None) => {\n-                match tcx.def_map.borrow().find(&pat.id) {\n+                match tcx.def_map.borrow().get(&pat.id) {\n                     Some(&def::DefStruct(..)) => true,\n                     _ => false\n                 }"}, {"sha": "7ff94c28d93bc73896d0e46efc292130047bcfaa", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -147,7 +147,7 @@ pub fn represent_node(bcx: Block, node: ast::NodeId) -> Rc<Repr> {\n /// Decides how to represent a given type.\n pub fn represent_type(cx: &CrateContext, t: ty::t) -> Rc<Repr> {\n     debug!(\"Representing: {}\", ty_to_string(cx.tcx(), t));\n-    match cx.adt_reprs().borrow().find(&t) {\n+    match cx.adt_reprs().borrow().get(&t) {\n         Some(repr) => return repr.clone(),\n         None => {}\n     }"}, {"sha": "3b3b886c6d06e3d3329fb624500d52d0198e9084", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -316,7 +316,7 @@ pub fn get_extern_const(ccx: &CrateContext, did: ast::DefId,\n                         t: ty::t) -> ValueRef {\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     let ty = type_of(ccx, t);\n-    match ccx.externs().borrow_mut().find(&name) {\n+    match ccx.externs().borrow_mut().get(&name) {\n         Some(n) => return *n,\n         None => ()\n     }\n@@ -409,7 +409,7 @@ pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: ty::t) -> Resu\n // Type descriptor and type glue stuff\n \n pub fn get_tydesc(ccx: &CrateContext, t: ty::t) -> Rc<tydesc_info> {\n-    match ccx.tydescs().borrow().find(&t) {\n+    match ccx.tydescs().borrow().get(&t) {\n         Some(inf) => return inf.clone(),\n         _ => { }\n     }\n@@ -2100,7 +2100,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n \n     let levels = ccx.tcx().node_lint_levels.borrow();\n     let lint_id = lint::LintId::of(lint::builtin::VARIANT_SIZE_DIFFERENCES);\n-    let lvlsrc = match levels.find(&(id, lint_id)) {\n+    let lvlsrc = match levels.get(&(id, lint_id)) {\n         None | Some(&(lint::Allow, _)) => return,\n         Some(&lvlsrc) => lvlsrc,\n     };\n@@ -2645,7 +2645,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n \n fn exported_name(ccx: &CrateContext, id: ast::NodeId,\n                  ty: ty::t, attrs: &[ast::Attribute]) -> String {\n-    match ccx.external_srcs().borrow().find(&id) {\n+    match ccx.external_srcs().borrow().get(&id) {\n         Some(&did) => {\n             let sym = csearch::get_symbol(&ccx.sess().cstore, did);\n             debug!(\"found item {} in other crate...\", sym);\n@@ -3123,7 +3123,7 @@ pub fn trans_crate<'tcx>(analysis: CrateAnalysis<'tcx>)\n         .collect();\n \n     let mut reachable: Vec<String> = shared_ccx.reachable().iter().filter_map(|id| {\n-        shared_ccx.item_symbols().borrow().find(id).map(|s| s.to_string())\n+        shared_ccx.item_symbols().borrow().get(id).map(|s| s.to_string())\n     }).collect();\n \n     // For the purposes of LTO, we add to the reachable set all of the upstream"}, {"sha": "b692b01f765d51f9526b413967158b42cfccac74", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -81,7 +81,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 s.push('/');\n                 s.push_str(category);\n \n-                let n = match h.find(&s) {\n+                let n = match h.get(&s) {\n                     Some(&n) => n,\n                     _ => 0u\n                 };"}, {"sha": "16db4daba46b8ba767aa99ebef481f1f192dfcfc", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -438,7 +438,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'blk, 'tcx>(bcx: Block<'blk,\n         params: params\n     };\n \n-    match ccx.unboxed_closure_vals().borrow().find(&mono_id) {\n+    match ccx.unboxed_closure_vals().borrow().get(&mono_id) {\n         Some(llfn) => {\n             debug!(\"get_or_create_declaration_if_unboxed_closure(): found \\\n                     closure\");\n@@ -564,7 +564,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n         }\n     };\n \n-    match ccx.closure_bare_wrapper_cache().borrow().find(&fn_ptr) {\n+    match ccx.closure_bare_wrapper_cache().borrow().get(&fn_ptr) {\n         Some(&llval) => return llval,\n         None => {}\n     }"}, {"sha": "18501dd9e34cb23c266ef8e4b07a8f7970491361", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -466,7 +466,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     }\n \n     pub fn def(&self, nid: ast::NodeId) -> def::Def {\n-        match self.tcx().def_map.borrow().find(&nid) {\n+        match self.tcx().def_map.borrow().get(&nid) {\n             Some(v) => v.clone(),\n             None => {\n                 self.tcx().sess.bug(format!(\n@@ -505,7 +505,7 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n         self.tcx()\n             .method_map\n             .borrow()\n-            .find(&method_call)\n+            .get(&method_call)\n             .map(|method| monomorphize_type(self, method.ty))\n     }\n \n@@ -647,7 +647,7 @@ pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> ValueRef {\n     unsafe {\n-        match cx.const_cstr_cache().borrow().find(&s) {\n+        match cx.const_cstr_cache().borrow().get(&s) {\n             Some(&llval) => return llval,\n             None => ()\n         }\n@@ -813,7 +813,7 @@ pub fn fulfill_obligation(ccx: &CrateContext,\n     let trait_ref = ty_fold::erase_regions(tcx, trait_ref);\n \n     // First check the cache.\n-    match ccx.trait_cache().borrow().find(&trait_ref) {\n+    match ccx.trait_cache().borrow().get(&trait_ref) {\n         Some(vtable) => {\n             info!(\"Cache hit: {}\", trait_ref.repr(ccx.tcx()));\n             return (*vtable).clone();"}, {"sha": "ced6c2f49492df46442279d74a988718cb30b281", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -90,7 +90,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n pub fn const_ptrcast(cx: &CrateContext, a: ValueRef, t: Type) -> ValueRef {\n     unsafe {\n         let b = llvm::LLVMConstPointerCast(a, t.ptr_to().to_ref());\n-        assert!(cx.const_globals().borrow_mut().insert(b as int, a));\n+        assert!(cx.const_globals().borrow_mut().insert(b as int, a).is_none());\n         b\n     }\n }\n@@ -125,7 +125,7 @@ pub fn const_addr_of(cx: &CrateContext, cv: ValueRef, mutbl: ast::Mutability) ->\n }\n \n fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n-    let v = match cx.const_globals().borrow().find(&(v as int)) {\n+    let v = match cx.const_globals().borrow().get(&(v as int)) {\n         Some(&v) => v,\n         None => v\n     };"}, {"sha": "714d5ab248d5ede123622e48867934f012eeaf90", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -421,7 +421,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let loop_id = match opt_label {\n         None => fcx.top_loop_scope(),\n         Some(_) => {\n-            match bcx.tcx().def_map.borrow().find(&expr_id) {\n+            match bcx.tcx().def_map.borrow().get(&expr_id) {\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n                     bcx.tcx().sess.bug(format!(\"{} in def-map for label\","}, {"sha": "c84543773a4a4060d82c6ec7eb0e24ae0c5b9f1a", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -282,7 +282,7 @@ impl TypeMap {\n                                    cx: &CrateContext,\n                                    type_: ty::t,\n                                    metadata: DIType) {\n-        if !self.type_to_metadata.insert(ty::type_id(type_), metadata) {\n+        if self.type_to_metadata.insert(ty::type_id(type_), metadata).is_some() {\n             cx.sess().bug(format!(\"Type metadata for ty::t '{}' is already in the TypeMap!\",\n                                    ppaux::ty_to_string(cx.tcx(), type_)).as_slice());\n         }\n@@ -294,7 +294,7 @@ impl TypeMap {\n                                         cx: &CrateContext,\n                                         unique_type_id: UniqueTypeId,\n                                         metadata: DIType) {\n-        if !self.unique_id_to_metadata.insert(unique_type_id, metadata) {\n+        if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n             cx.sess().bug(format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n                                   unique_type_id_str.as_slice()).as_slice());\n@@ -468,7 +468,7 @@ impl TypeMap {\n             },\n             ty::ty_unboxed_closure(ref def_id, _, ref substs) => {\n                 let closure_ty = cx.tcx().unboxed_closures.borrow()\n-                                   .find(def_id).unwrap().closure_type.subst(cx.tcx(), substs);\n+                                   .get(def_id).unwrap().closure_type.subst(cx.tcx(), substs);\n                 self.get_unique_type_id_of_closure_type(cx,\n                                                         closure_ty,\n                                                         &mut unique_type_id);\n@@ -2939,7 +2939,7 @@ fn type_metadata(cx: &CrateContext,\n         }\n         ty::ty_unboxed_closure(ref def_id, _, ref substs) => {\n             let sig = cx.tcx().unboxed_closures.borrow()\n-                        .find(def_id).unwrap().closure_type.sig.subst(cx.tcx(), substs);\n+                        .get(def_id).unwrap().closure_type.sig.subst(cx.tcx(), substs);\n             subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)\n         }\n         ty::ty_struct(def_id, ref substs) => {"}, {"sha": "b01d891270b13c29e7fc51fce6976cac045ef32d", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -212,7 +212,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         // Don't skip a conversion from Box<T> to &T, etc.\n                         ty::ty_rptr(..) => {\n                             let method_call = MethodCall::autoderef(expr.id, adj.autoderefs-1);\n-                            let method = bcx.tcx().method_map.borrow().find(&method_call).is_some();\n+                            let method = bcx.tcx().method_map.borrow().get(&method_call).is_some();\n                             if method {\n                                 // Don't skip an overloaded deref.\n                                 (adj.autoderefs, true)\n@@ -601,7 +601,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let method_ty = ccx.tcx()\n                                .method_map\n                                .borrow()\n-                               .find(&method_call)\n+                               .get(&method_call)\n                                .map(|method| method.ty);\n             let base_datum = unpack_datum!(bcx, trans(bcx, &**base));\n \n@@ -736,7 +736,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let method_ty = ccx.tcx()\n                        .method_map\n                        .borrow()\n-                       .find(&method_call)\n+                       .get(&method_call)\n                        .map(|method| method.ty);\n     let elt_datum = match method_ty {\n         Some(method_ty) => {\n@@ -1114,7 +1114,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if ty::type_is_trait(node_id_type(bcx, expr.id)) {\n                 let trait_ref =\n                     bcx.tcx().object_cast_map.borrow()\n-                                             .find(&expr.id)\n+                                             .get(&expr.id)\n                                              .map(|t| (*t).clone())\n                                              .unwrap();\n                 let trait_ref =\n@@ -1232,7 +1232,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         def::DefUpvar(nid, _, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n-            match bcx.fcx.llupvars.borrow().find(&nid) {\n+            match bcx.fcx.llupvars.borrow().get(&nid) {\n                 Some(&val) => Datum::new(val, local_ty, Lvalue),\n                 None => {\n                     bcx.sess().bug(format!(\n@@ -1242,7 +1242,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         def::DefLocal(nid) => {\n-            let datum = match bcx.fcx.lllocals.borrow().find(&nid) {\n+            let datum = match bcx.fcx.lllocals.borrow().get(&nid) {\n                 Some(&v) => v,\n                 None => {\n                     bcx.sess().bug(format!(\n@@ -2089,7 +2089,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Check for overloaded deref.\n     let method_ty = ccx.tcx().method_map.borrow()\n-                       .find(&method_call).map(|method| method.ty);\n+                       .get(&method_call).map(|method| method.ty);\n     let datum = match method_ty {\n         Some(method_ty) => {\n             // Overloaded. Evaluate `trans_overloaded_op`, which will"}, {"sha": "eb6e67efd49a6d598208e81de5e7ccf3f62ce176", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -144,7 +144,7 @@ pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n     debug!(\"make drop glue for {}\", ppaux::ty_to_string(ccx.tcx(), t));\n     let t = get_drop_glue_type(ccx, t);\n     debug!(\"drop glue type {}\", ppaux::ty_to_string(ccx.tcx(), t));\n-    match ccx.drop_glues().borrow().find(&t) {\n+    match ccx.drop_glues().borrow().get(&t) {\n         Some(&glue) => return glue,\n         _ => { }\n     }\n@@ -157,7 +157,7 @@ pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n \n     let llfnty = Type::glue_fn(ccx, llty);\n \n-    let (glue, new_sym) = match ccx.available_drop_glues().borrow().find(&t) {\n+    let (glue, new_sym) = match ccx.available_drop_glues().borrow().get(&t) {\n         Some(old_sym) => {\n             let glue = decl_cdecl_fn(ccx, old_sym.as_slice(), llfnty, ty::mk_nil());\n             (glue, None)"}, {"sha": "65d7749b489272d5304d49f9edd403a294dae0f1", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -21,7 +21,7 @@ use syntax::ast_util::{local_def, PostExpansionMethod};\n fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n     -> Option<ast::DefId> {\n     let _icx = push_ctxt(\"maybe_instantiate_inline\");\n-    match ccx.external().borrow().find(&fn_id) {\n+    match ccx.external().borrow().get(&fn_id) {\n         Some(&Some(node_id)) => {\n             // Already inline\n             debug!(\"maybe_instantiate_inline({}): already inline as node id {}\","}, {"sha": "0ae728c71ee63dcf827c538efd8111d219febffb", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -116,7 +116,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let (origin, method_ty) =\n         bcx.tcx().method_map\n                  .borrow()\n-                 .find(&method_call)\n+                 .get(&method_call)\n                  .map(|method| (method.origin.clone(), method.ty))\n                  .unwrap();\n \n@@ -308,7 +308,7 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n \n     let impl_items = ccx.tcx().impl_items.borrow();\n     let impl_items =\n-        impl_items.find(&impl_id)\n+        impl_items.get(&impl_id)\n                   .expect(\"could not find impl while translating\");\n     let meth_did = impl_items.iter()\n                              .find(|&did| {\n@@ -559,7 +559,7 @@ pub fn get_vtable(bcx: Block,\n \n     // Check the cache.\n     let cache_key = (box_ty, trait_ref.clone());\n-    match ccx.vtables().borrow().find(&cache_key) {\n+    match ccx.vtables().borrow().get(&cache_key) {\n         Some(&val) => { return val }\n         None => { }\n     }\n@@ -599,7 +599,7 @@ pub fn get_vtable(bcx: Block,\n                                               .unboxed_closures\n                                               .borrow();\n                     let closure_info =\n-                        unboxed_closures.find(&closure_def_id)\n+                        unboxed_closures.get(&closure_def_id)\n                                         .expect(\"get_vtable(): didn't find \\\n                                                  unboxed closure\");\n                     if closure_info.kind == ty::FnOnceUnboxedClosureKind {"}, {"sha": "f9d42240f35b7bcb37232982f2c7baf8f961cb7b", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -54,7 +54,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         params: real_substs.types.clone()\n     };\n \n-    match ccx.monomorphized().borrow().find(&hash_id) {\n+    match ccx.monomorphized().borrow().get(&hash_id) {\n         Some(&val) => {\n             debug!(\"leaving monomorphic fn {}\",\n             ty::item_path_str(ccx.tcx(), fn_id));\n@@ -106,7 +106,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n     let depth;\n     {\n         let mut monomorphizing = ccx.monomorphizing().borrow_mut();\n-        depth = match monomorphizing.find(&fn_id) {\n+        depth = match monomorphizing.get(&fn_id) {\n             Some(&d) => d, None => 0\n         };\n "}, {"sha": "175b0d7adde0a5494fa9feb861fd217a895ace0e", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -332,7 +332,7 @@ impl TypeNames {\n \n     pub fn associate_type(&self, s: &str, t: &Type) {\n         assert!(self.named_types.borrow_mut().insert(s.to_string(),\n-                                                     t.to_ref()));\n+                                                     t.to_ref()).is_none());\n     }\n \n     pub fn find_type(&self, s: &str) -> Option<Type> {"}, {"sha": "d1b8f767bc85018e312b2e028b743b7d80f22332", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -272,7 +272,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     }\n \n     // Check the cache.\n-    match cx.lltypes().borrow().find(&t) {\n+    match cx.lltypes().borrow().get(&t) {\n         Some(&llty) => return llty,\n         None => ()\n     }"}, {"sha": "421042a86489ae1d7f6ce250976d139a894b6fb1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -1080,14 +1080,14 @@ pub enum BuiltinBound {\n }\n \n pub fn empty_builtin_bounds() -> BuiltinBounds {\n-    EnumSet::empty()\n+    EnumSet::new()\n }\n \n pub fn all_builtin_bounds() -> BuiltinBounds {\n-    let mut set = EnumSet::empty();\n-    set.add(BoundSend);\n-    set.add(BoundSized);\n-    set.add(BoundSync);\n+    let mut set = EnumSet::new();\n+    set.insert(BoundSend);\n+    set.insert(BoundSized);\n+    set.insert(BoundSync);\n     set\n }\n \n@@ -1584,7 +1584,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n \n     let key = intern_key { sty: &st };\n \n-    match cx.interner.borrow().find(&key) {\n+    match cx.interner.borrow().get(&key) {\n         Some(t) => unsafe { return mem::transmute(&t.sty); },\n         _ => ()\n     }\n@@ -2418,11 +2418,11 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n         // value for the type contents of list.  The correct value is\n         // TC::OwnsOwned.  This manifested as issue #4821.\n         let ty_id = type_id(ty);\n-        match cache.find(&ty_id) {\n+        match cache.get(&ty_id) {\n             Some(tc) => { return *tc; }\n             None => {}\n         }\n-        match cx.tc_cache.borrow().find(&ty_id) {    // Must check both caches!\n+        match cx.tc_cache.borrow().get(&ty_id) {    // Must check both caches!\n             Some(tc) => { return *tc; }\n             None => {}\n         }\n@@ -3192,7 +3192,7 @@ pub fn array_element_ty(t: t) -> Option<t> {\n }\n \n pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> Rc<ty::TraitRef> {\n-    match cx.trait_refs.borrow().find(&id) {\n+    match cx.trait_refs.borrow().get(&id) {\n         Some(t) => t.clone(),\n         None => cx.sess.bug(\n             format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n@@ -3214,14 +3214,14 @@ pub fn node_id_to_type(cx: &ctxt, id: ast::NodeId) -> t {\n }\n \n pub fn node_id_to_type_opt(cx: &ctxt, id: ast::NodeId) -> Option<t> {\n-    match cx.node_types.borrow().find(&(id as uint)) {\n+    match cx.node_types.borrow().get(&(id as uint)) {\n        Some(&t) => Some(t),\n        None => None\n     }\n }\n \n pub fn node_id_item_substs(cx: &ctxt, id: ast::NodeId) -> ItemSubsts {\n-    match cx.item_substs.borrow().find(&id) {\n+    match cx.item_substs.borrow().get(&id) {\n       None => ItemSubsts::empty(),\n       Some(ts) => ts.clone(),\n     }\n@@ -3361,8 +3361,8 @@ pub fn expr_ty_adjusted(cx: &ctxt, expr: &ast::Expr) -> t {\n      */\n \n     adjust_ty(cx, expr.span, expr.id, expr_ty(cx, expr),\n-              cx.adjustments.borrow().find(&expr.id),\n-              |method_call| cx.method_map.borrow().find(&method_call).map(|method| method.ty))\n+              cx.adjustments.borrow().get(&expr.id),\n+              |method_call| cx.method_map.borrow().get(&method_call).map(|method| method.ty))\n }\n \n pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n@@ -3553,7 +3553,7 @@ pub fn unsize_ty(cx: &ctxt,\n }\n \n pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n-    match tcx.def_map.borrow().find(&expr.id) {\n+    match tcx.def_map.borrow().get(&expr.id) {\n         Some(&def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, format!(\n@@ -3690,7 +3690,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         }\n \n         ast::ExprCast(..) => {\n-            match tcx.node_types.borrow().find(&(expr.id as uint)) {\n+            match tcx.node_types.borrow().get(&(expr.id as uint)) {\n                 Some(&t) => {\n                     if type_is_trait(t) {\n                         RvalueDpsExpr\n@@ -3736,7 +3736,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n \n         ast::ExprBox(ref place, _) => {\n             // Special case `Box<T>` for now:\n-            let definition = match tcx.def_map.borrow().find(&place.id) {\n+            let definition = match tcx.def_map.borrow().get(&place.id) {\n                 Some(&def) => def,\n                 None => panic!(\"no def for place\"),\n             };\n@@ -4003,7 +4003,7 @@ pub fn note_and_explain_type_err(cx: &ctxt, err: &type_err) {\n }\n \n pub fn provided_source(cx: &ctxt, id: ast::DefId) -> Option<ast::DefId> {\n-    cx.provided_method_sources.borrow().find(&id).map(|x| *x)\n+    cx.provided_method_sources.borrow().get(&id).map(|x| *x)\n }\n \n pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<Rc<Method>> {\n@@ -4113,7 +4113,7 @@ pub fn impl_or_trait_item(cx: &ctxt, id: ast::DefId) -> ImplOrTraitItem {\n pub fn is_associated_type(cx: &ctxt, id: ast::DefId) -> bool {\n     memoized(&cx.associated_types, id, |id: ast::DefId| {\n         if id.krate == ast::LOCAL_CRATE {\n-            match cx.impl_or_trait_items.borrow().find(&id) {\n+            match cx.impl_or_trait_items.borrow().get(&id) {\n                 Some(ref item) => {\n                     match **item {\n                         TypeTraitItem(_) => true,\n@@ -4198,7 +4198,7 @@ pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<Rc<TraitRef>> {\n \n pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n     let def = *tcx.def_map.borrow()\n-                     .find(&tr.ref_id)\n+                     .get(&tr.ref_id)\n                      .expect(\"no def-map entry for trait\");\n     def.def_id()\n }\n@@ -4215,7 +4215,7 @@ pub fn try_add_builtin_trait(\n     //! is a builtin trait.\n \n     match tcx.lang_items.to_builtin_kind(trait_def_id) {\n-        Some(bound) => { builtin_bounds.add(bound); true }\n+        Some(bound) => { builtin_bounds.insert(bound); true }\n         None => false\n     }\n }\n@@ -4346,7 +4346,7 @@ impl DtorKind {\n /* If struct_id names a struct with a dtor, return Some(the dtor's id).\n    Otherwise return none. */\n pub fn ty_dtor(cx: &ctxt, struct_id: DefId) -> DtorKind {\n-    match cx.destructor_for_type.borrow().find(&struct_id) {\n+    match cx.destructor_for_type.borrow().get(&struct_id) {\n         Some(&method_def_id) => {\n             let flag = !has_attr(cx, struct_id, \"unsafe_no_drop_flag\");\n \n@@ -4569,7 +4569,7 @@ pub fn lookup_field_type(tcx: &ctxt,\n pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n     if did.krate == ast::LOCAL_CRATE {\n         let struct_fields = cx.struct_fields.borrow();\n-        match struct_fields.find(&did) {\n+        match struct_fields.get(&did) {\n             Some(fields) => (**fields).clone(),\n             _ => {\n                 cx.sess.bug(\n@@ -4632,7 +4632,7 @@ pub fn unboxed_closure_upvars(tcx: &ctxt, closure_id: ast::DefId, substs: &Subst\n     // implemented.\n     assert!(closure_id.krate == ast::LOCAL_CRATE);\n     let capture_mode = tcx.capture_modes.borrow().get_copy(&closure_id.node);\n-    match tcx.freevars.borrow().find(&closure_id.node) {\n+    match tcx.freevars.borrow().get(&closure_id.node) {\n         None => vec![],\n         Some(ref freevars) => {\n             freevars.iter().map(|freevar| {\n@@ -4898,7 +4898,7 @@ pub fn required_region_bounds(tcx: &ctxt,\n                           all_bounds: &mut Vec<ty::Region>) {\n         all_bounds.push_all(region_bounds.as_slice());\n \n-        if builtin_bounds.contains_elem(ty::BoundSend) {\n+        if builtin_bounds.contains(&ty::BoundSend) {\n             all_bounds.push(ty::ReStatic);\n         }\n     }\n@@ -4921,7 +4921,7 @@ pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n pub fn record_trait_implementation(tcx: &ctxt,\n                                    trait_def_id: DefId,\n                                    impl_def_id: DefId) {\n-    match tcx.trait_impls.borrow().find(&trait_def_id) {\n+    match tcx.trait_impls.borrow().get(&trait_def_id) {\n         Some(impls_for_trait) => {\n             impls_for_trait.borrow_mut().push(impl_def_id);\n             return;\n@@ -5094,7 +5094,7 @@ pub fn trait_of_item(tcx: &ctxt, def_id: ast::DefId) -> Option<ast::DefId> {\n /// Otherwise, return `None`.\n pub fn trait_item_of_item(tcx: &ctxt, def_id: ast::DefId)\n                           -> Option<ImplOrTraitItemId> {\n-    let impl_item = match tcx.impl_or_trait_items.borrow().find(&def_id) {\n+    let impl_item = match tcx.impl_or_trait_items.borrow().get(&def_id) {\n         Some(m) => m.clone(),\n         None => return None,\n     };\n@@ -5449,7 +5449,7 @@ impl<'tcx> mc::Typer<'tcx> for ty::ctxt<'tcx> {\n     }\n \n     fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t> {\n-        self.method_map.borrow().find(&method_call).map(|method| method.ty)\n+        self.method_map.borrow().get(&method_call).map(|method| method.ty)\n     }\n \n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n@@ -5561,7 +5561,7 @@ pub type FreevarMap = NodeMap<Vec<Freevar>>;\n pub type CaptureModeMap = NodeMap<ast::CaptureClause>;\n \n pub fn with_freevars<T>(tcx: &ty::ctxt, fid: ast::NodeId, f: |&[Freevar]| -> T) -> T {\n-    match tcx.freevars.borrow().find(&fid) {\n+    match tcx.freevars.borrow().get(&fid) {\n         None => f(&[]),\n         Some(d) => f(d.as_slice())\n     }"}, {"sha": "32fd385aa5d023c9477323e35d6bc329ccea4c09", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -99,7 +99,7 @@ pub trait AstConv<'tcx> {\n \n pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n                             -> ty::Region {\n-    let r = match tcx.named_region_map.find(&lifetime.id) {\n+    let r = match tcx.named_region_map.get(&lifetime.id) {\n         None => {\n             // should have been recorded by the `resolve_lifetime` pass\n             tcx.sess.span_bug(lifetime.span, \"unresolved lifetime\");\n@@ -467,7 +467,7 @@ fn check_path_args(tcx: &ty::ctxt,\n pub fn ast_ty_to_prim_ty(tcx: &ty::ctxt, ast_ty: &ast::Ty) -> Option<ty::t> {\n     match ast_ty.node {\n         ast::TyPath(ref path, _, id) => {\n-            let a_def = match tcx.def_map.borrow().find(&id) {\n+            let a_def = match tcx.def_map.borrow().get(&id) {\n                 None => {\n                     tcx.sess.span_bug(ast_ty.span,\n                                       format!(\"unbound path {}\",\n@@ -524,7 +524,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n     match ast_ty.node {\n         ast::TyPath(ref path, _, id) => {\n-            let a_def = match this.tcx().def_map.borrow().find(&id) {\n+            let a_def = match this.tcx().def_map.borrow().get(&id) {\n                 None => {\n                     this.tcx()\n                         .sess\n@@ -675,7 +675,7 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             // Note that the \"bounds must be empty if path is not a trait\"\n             // restriction is enforced in the below case for ty_path, which\n             // will run after this as long as the path isn't a trait.\n-            match tcx.def_map.borrow().find(&id) {\n+            match tcx.def_map.borrow().get(&id) {\n                 Some(&def::DefPrimTy(ast::TyStr)) => {\n                     check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                     match ptr_ty {\n@@ -802,7 +802,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     let tcx = this.tcx();\n \n     let mut ast_ty_to_ty_cache = tcx.ast_ty_to_ty_cache.borrow_mut();\n-    match ast_ty_to_ty_cache.find(&ast_ty.id) {\n+    match ast_ty_to_ty_cache.get(&ast_ty.id) {\n         Some(&ty::atttce_resolved(ty)) => return ty,\n         Some(&ty::atttce_unresolved) => {\n             tcx.sess.span_fatal(ast_ty.span,\n@@ -900,7 +900,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 ty::mk_err()\n             }\n             ast::TyPath(ref path, ref bounds, id) => {\n-                let a_def = match tcx.def_map.borrow().find(&id) {\n+                let a_def = match tcx.def_map.borrow().get(&id) {\n                     None => {\n                         tcx.sess\n                            .span_bug(ast_ty.span,\n@@ -990,7 +990,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 }\n             }\n             ast::TyQPath(ref qpath) => {\n-                match tcx.def_map.borrow().find(&ast_ty.id) {\n+                match tcx.def_map.borrow().get(&ast_ty.id) {\n                     None => {\n                         tcx.sess.span_bug(ast_ty.span,\n                                           \"unbound qualified path\")\n@@ -1549,7 +1549,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n             ast::TraitTyParamBound(ref b) => {\n                 match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n                     def::DefTrait(trait_did) => {\n-                        match trait_def_ids.find(&trait_did) {\n+                        match trait_def_ids.get(&trait_did) {\n                             // Already seen this trait. We forbid\n                             // duplicates in the list (for some\n                             // reason)."}, {"sha": "7070f16da3bfd25e18eee82ff37018050bc30a86", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -324,7 +324,7 @@ pub fn check_pat_struct(pcx: &pat_ctxt, pat: &ast::Pat,\n \n     let item_substs = fcx\n         .item_substs()\n-        .find(&pat.id)\n+        .get(&pat.id)\n         .map(|substs| substs.substs.clone())\n         .unwrap_or_else(|| Substs::empty());\n "}, {"sha": "557b92d439d917a6081da56ae3a559015d490ddc", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -678,7 +678,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         debug!(\"push_extension_candidates(expr_id={})\", expr_id);\n \n         let mut duplicates = HashSet::new();\n-        let opt_applicable_traits = self.fcx.ccx.trait_map.find(&expr_id);\n+        let opt_applicable_traits = self.fcx.ccx.trait_map.get(&expr_id);\n         for applicable_traits in opt_applicable_traits.into_iter() {\n             for &trait_did in applicable_traits.iter() {\n                 if duplicates.insert(trait_did) {\n@@ -912,7 +912,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         // metadata if necessary.\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n \n-        for impl_infos in self.tcx().inherent_impls.borrow().find(&did).iter() {\n+        for impl_infos in self.tcx().inherent_impls.borrow().get(&did).iter() {\n             for impl_did in impl_infos.iter() {\n                 self.push_candidates_from_inherent_impl(*impl_did);\n             }\n@@ -1627,7 +1627,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                                             .inh\n                                             .adjustments\n                                             .borrow()\n-                                            .find(&expr.id) {\n+                                            .get(&expr.id) {\n                 Some(&ty::AdjustDerefRef(ty::AutoDerefRef {\n                     autoderefs: autoderef_count,\n                     autoref: _\n@@ -1658,7 +1658,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 match expr.node {\n                     ast::ExprIndex(ref base_expr, _) => {\n                         let mut base_adjustment =\n-                            match self.fcx.inh.adjustments.borrow().find(&base_expr.id) {\n+                            match self.fcx.inh.adjustments.borrow().get(&base_expr.id) {\n                                 Some(&ty::AdjustDerefRef(ref adr)) => (*adr).clone(),\n                                 None => ty::AutoDerefRef { autoderefs: 0, autoref: None },\n                                 Some(_) => {\n@@ -1839,7 +1839,7 @@ fn impl_method(tcx: &ty::ctxt,\n                -> Option<Rc<ty::Method>>\n {\n     let impl_items = tcx.impl_items.borrow();\n-    let impl_items = impl_items.find(&impl_def_id).unwrap();\n+    let impl_items = impl_items.get(&impl_def_id).unwrap();\n     impl_items\n         .iter()\n         .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))"}, {"sha": "b83c81cd9863068294d145211facef3948576847", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -298,7 +298,7 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n     fn node_method_ty(&self, method_call: typeck::MethodCall)\n                       -> Option<ty::t> {\n-        self.inh.method_map.borrow().find(&method_call).map(|m| m.ty)\n+        self.inh.method_map.borrow().get(&method_call).map(|m| m.ty)\n     }\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n         &self.inh.adjustments\n@@ -1556,7 +1556,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> ty::t {\n-        match self.inh.locals.borrow().find(&nid) {\n+        match self.inh.locals.borrow().get(&nid) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.span_bug(\n@@ -1808,7 +1808,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn expr_ty(&self, ex: &ast::Expr) -> ty::t {\n-        match self.inh.node_types.borrow().find(&ex.id) {\n+        match self.inh.node_types.borrow().get(&ex.id) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(format!(\"no type for expr in fcx {}\",\n@@ -1824,7 +1824,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n          */\n \n         let adjustments = self.inh.adjustments.borrow();\n-        let adjustment = adjustments.find(&expr.id);\n+        let adjustment = adjustments.get(&expr.id);\n         self.adjust_expr_ty(expr, adjustment)\n     }\n \n@@ -1845,12 +1845,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                       raw_ty,\n                       adjustment,\n                       |method_call| self.inh.method_map.borrow()\n-                                                       .find(&method_call)\n+                                                       .get(&method_call)\n                                                        .map(|method| method.ty))\n     }\n \n     pub fn node_ty(&self, id: ast::NodeId) -> ty::t {\n-        match self.inh.node_types.borrow().find(&id) {\n+        match self.inh.node_types.borrow().get(&id) {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(\n@@ -1868,7 +1868,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn opt_node_ty_substs(&self,\n                               id: ast::NodeId,\n                               f: |&ty::ItemSubsts|) {\n-        match self.inh.item_substs.borrow().find(&id) {\n+        match self.inh.item_substs.borrow().get(&id) {\n             Some(s) => { f(s) }\n             None => { }\n         }\n@@ -3554,7 +3554,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                     let (bounds, onceness) = match expr.node {\n                         ast::ExprProc(..) => {\n                             let mut bounds = ty::region_existential_bound(ty::ReStatic);\n-                            bounds.builtin_bounds.add(ty::BoundSend); // FIXME\n+                            bounds.builtin_bounds.insert(ty::BoundSend); // FIXME\n                             (bounds, ast::Once)\n                         }\n                         _ => {\n@@ -3763,7 +3763,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         for field in ast_fields.iter() {\n             let mut expected_field_type = ty::mk_err();\n \n-            let pair = class_field_map.find(&field.ident.node.name).map(|x| *x);\n+            let pair = class_field_map.get(&field.ident.node.name).map(|x| *x);\n             match pair {\n                 None => {\n                     fcx.type_error_message(\n@@ -4422,7 +4422,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       }\n       ast::ExprStruct(ref path, ref fields, ref base_expr) => {\n         // Resolve the path.\n-        let def = tcx.def_map.borrow().find(&id).map(|i| *i);\n+        let def = tcx.def_map.borrow().get(&id).map(|i| *i);\n         let struct_id = match def {\n             Some(def::DefVariant(enum_id, variant_id, true)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n@@ -5603,7 +5603,7 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     (block_query(b, |e| {\n         match e.node {\n             ast::ExprBreak(Some(_)) => {\n-                match cx.def_map.borrow().find(&e.id) {\n+                match cx.def_map.borrow().get(&e.id) {\n                     Some(&def::DefLabel(loop_id)) if id == loop_id => true,\n                     _ => false,\n                 }"}, {"sha": "014180a11553ab93389e684b9854fa3eaf1c09ae", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -327,7 +327,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n     fn resolve_method_type(&self, method_call: MethodCall) -> Option<ty::t> {\n         let method_ty = self.fcx.inh.method_map.borrow()\n-                            .find(&method_call).map(|method| method.ty);\n+                            .get(&method_call).map(|method| method.ty);\n         method_ty.map(|method_ty| self.resolve_type(method_ty))\n     }\n \n@@ -339,7 +339,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         } else {\n             let tcx = self.fcx.tcx();\n             ty::adjust_ty(tcx, expr.span, expr.id, ty_unadjusted,\n-                          self.fcx.inh.adjustments.borrow().find(&expr.id),\n+                          self.fcx.inh.adjustments.borrow().get(&expr.id),\n                           |method_call| self.resolve_method_type(method_call))\n         }\n     }\n@@ -351,7 +351,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         // When we enter a function, we can derive\n \n         let fn_sig_map = self.fcx.inh.fn_sig_map.borrow();\n-        let fn_sig = match fn_sig_map.find(&id) {\n+        let fn_sig = match fn_sig_map.get(&id) {\n             Some(f) => f,\n             None => {\n                 self.tcx().sess.bug(\n@@ -370,7 +370,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     {\n         debug!(\"visit_region_obligations: node_id={}\", node_id);\n         let region_obligations = self.fcx.inh.region_obligations.borrow();\n-        match region_obligations.find(&node_id) {\n+        match region_obligations.get(&node_id) {\n             None => { }\n             Some(vec) => {\n                 for r_o in vec.iter() {\n@@ -594,7 +594,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     let has_method_map = rcx.fcx.inh.method_map.borrow().contains_key(&method_call);\n \n     // Check any autoderefs or autorefs that appear.\n-    for &adjustment in rcx.fcx.inh.adjustments.borrow().find(&expr.id).iter() {\n+    for &adjustment in rcx.fcx.inh.adjustments.borrow().get(&expr.id).iter() {\n         debug!(\"adjustment={}\", adjustment);\n         match *adjustment {\n             ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n@@ -686,7 +686,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         ast::ExprUnary(ast::UnDeref, ref base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let method_call = MethodCall::expr(expr.id);\n-            let base_ty = match rcx.fcx.inh.method_map.borrow().find(&method_call) {\n+            let base_ty = match rcx.fcx.inh.method_map.borrow().get(&method_call) {\n                 Some(method) => {\n                     constrain_call(rcx, expr, Some(&**base),\n                                    None::<ast::Expr>.iter(), true);\n@@ -950,7 +950,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             let raw_var_ty = rcx.resolve_node_type(var_node_id);\n             let upvar_id = ty::UpvarId { var_id: var_node_id,\n                                          closure_expr_id: expr.id };\n-            let var_ty = match rcx.fcx.inh.upvar_borrow_map.borrow().find(&upvar_id) {\n+            let var_ty = match rcx.fcx.inh.upvar_borrow_map.borrow().get(&upvar_id) {\n                 Some(upvar_borrow) => {\n                     ty::mk_rptr(rcx.tcx(),\n                                 upvar_borrow.region,\n@@ -1195,7 +1195,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                i, derefs);\n \n         let method_call = MethodCall::autoderef(deref_expr.id, i);\n-        derefd_ty = match rcx.fcx.inh.method_map.borrow().find(&method_call) {\n+        derefd_ty = match rcx.fcx.inh.method_map.borrow().get(&method_call) {\n             Some(method) => {\n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n@@ -1301,7 +1301,7 @@ fn type_of_node_must_outlive(\n     // report errors later on in the writeback phase.\n     let ty0 = rcx.resolve_node_type(id);\n     let ty = ty::adjust_ty(tcx, origin.span(), id, ty0,\n-                           rcx.fcx.inh.adjustments.borrow().find(&id),\n+                           rcx.fcx.inh.adjustments.borrow().get(&id),\n                            |method_call| rcx.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={})\",\n@@ -1582,7 +1582,7 @@ fn link_reborrowed_region(rcx: &Rcx,\n         mc::NoteUpvarRef(ref upvar_id) => {\n             let mut upvar_borrow_map =\n                 rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n-            match upvar_borrow_map.find_mut(upvar_id) {\n+            match upvar_borrow_map.get_mut(upvar_id) {\n                 Some(upvar_borrow) => {\n                     // Adjust mutability that we infer for the upvar\n                     // so it can accommodate being borrowed with\n@@ -1845,7 +1845,7 @@ fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n \n     let mut upvar_borrow_map = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n     let inner_borrow = upvar_borrow_map.get_copy(&inner_upvar_id);\n-    match upvar_borrow_map.find_mut(&outer_upvar_id) {\n+    match upvar_borrow_map.get_mut(&outer_upvar_id) {\n         Some(outer_borrow) => {\n             adjust_upvar_borrow_kind(rcx, outer_upvar_id, outer_borrow, inner_borrow.kind);\n         }"}, {"sha": "cf78ef1621986de1d57bf55e4d11f1caf581a713", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -263,7 +263,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n \n     fn visit_adjustments(&self, reason: ResolveReason, id: ast::NodeId) {\n-        match self.fcx.inh.adjustments.borrow_mut().pop(&id) {\n+        match self.fcx.inh.adjustments.borrow_mut().remove(&id) {\n             None => {\n                 debug!(\"No adjustments for node {}\", id);\n             }\n@@ -275,7 +275,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                         // FIXME(eddyb) #2190 Allow only statically resolved\n                         // bare functions to coerce to a closure to avoid\n                         // constructing (slower) indirect call wrappers.\n-                        match self.tcx().def_map.borrow().find(&id) {\n+                        match self.tcx().def_map.borrow().get(&id) {\n                             Some(&def::DefFn(..)) |\n                             Some(&def::DefStaticMethod(..)) |\n                             Some(&def::DefVariant(..)) |\n@@ -320,7 +320,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                               reason: ResolveReason,\n                               method_call: MethodCall) {\n         // Resolve any method map entry\n-        match self.fcx.inh.method_map.borrow_mut().pop(&method_call) {\n+        match self.fcx.inh.method_map.borrow_mut().remove(&method_call) {\n             Some(method) => {\n                 debug!(\"writeback::resolve_method_map_entry(call={}, entry={})\",\n                        method_call,"}, {"sha": "19ff82469b5155906df2bdadf2c473fc8e04d681", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -294,7 +294,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        match self.inherent_impls.borrow().find(&base_def_id) {\n+        match self.inherent_impls.borrow().get(&base_def_id) {\n             Some(implementation_list) => {\n                 implementation_list.borrow_mut().push(impl_def_id);\n                 return;"}, {"sha": "933c2c81ac269380b0ad7a04070ad31e00a7fdd2", "filename": "src/librustc/middle/typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Foverlap.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -114,7 +114,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     fn push_impls_of_trait(&self,\n                            trait_def_id: ast::DefId,\n                            out: &mut Vec<ast::DefId>) {\n-        match self.tcx.trait_impls.borrow().find(&trait_def_id) {\n+        match self.tcx.trait_impls.borrow().get(&trait_def_id) {\n             Some(impls) => { out.push_all(impls.borrow().as_slice()); }\n             None => { /* no impls */ }\n         }"}, {"sha": "d137e5536a5ff661529e1fa6d0adb04b96030639", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -1243,7 +1243,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n         let result = convert_field(ccx, &pty.generics, f, local_def(id));\n \n         if result.name != special_idents::unnamed_field.name {\n-            let dup = match seen_fields.find(&result.name) {\n+            let dup = match seen_fields.get(&result.name) {\n                 Some(prev_span) => {\n                     span_err!(tcx.sess, f.span, E0124,\n                               \"field `{}` is already declared\",\n@@ -1386,7 +1386,7 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n-    match tcx.trait_defs.borrow().find(&def_id) {\n+    match tcx.trait_defs.borrow().get(&def_id) {\n         Some(def) => return def.clone(),\n         _ => {}\n     }\n@@ -1486,7 +1486,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                   -> ty::Polytype {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n-    match tcx.tcache.borrow().find(&def_id) {\n+    match tcx.tcache.borrow().get(&def_id) {\n         Some(pty) => return pty.clone(),\n         _ => {}\n     }\n@@ -1528,7 +1528,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             return pty;\n         }\n         ast::ItemTy(ref t, ref generics) => {\n-            match tcx.tcache.borrow_mut().find(&local_def(it.id)) {\n+            match tcx.tcache.borrow_mut().get(&local_def(it.id)) {\n                 Some(pty) => return pty.clone(),\n                 None => { }\n             }\n@@ -1933,7 +1933,7 @@ fn get_or_create_type_parameter_def<'tcx,AC>(this: &AC,\n                                              -> ty::TypeParameterDef\n     where AC: AstConv<'tcx>\n {\n-    match this.tcx().ty_param_defs.borrow().find(&param.id) {\n+    match this.tcx().ty_param_defs.borrow().get(&param.id) {\n         Some(d) => { return (*d).clone(); }\n         None => { }\n     }\n@@ -2027,13 +2027,13 @@ fn check_bounds_compatible(tcx: &ty::ctxt,\n                            span: Span) {\n     // Currently the only bound which is incompatible with other bounds is\n     // Sized/Unsized.\n-    if !param_bounds.builtin_bounds.contains_elem(ty::BoundSized) {\n+    if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n         ty::each_bound_trait_and_supertraits(\n             tcx,\n             param_bounds.trait_bounds.as_slice(),\n             |trait_ref| {\n                 let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id);\n-                if trait_def.bounds.builtin_bounds.contains_elem(ty::BoundSized) {\n+                if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n                     span_err!(tcx.sess, span, E0129,\n                               \"incompatible bounds on type parameter `{}`, \\\n                                bound `{}` does not allow unsized type\",\n@@ -2136,7 +2136,7 @@ fn merge_param_bounds<'a>(tcx: &ty::ctxt,\n         let predicate_param_id =\n             tcx.def_map\n                .borrow()\n-               .find(&predicate.id)\n+               .get(&predicate.id)\n                .expect(\"compute_bounds(): resolve didn't resolve the type \\\n                         parameter identifier in a `where` clause\")\n                .def_id();"}, {"sha": "20c14580b3bee7991001de6dc4adfb8bd2931a85", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -1240,7 +1240,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     ty_queue.push(&*mut_ty.ty);\n                 }\n                 ast::TyPath(ref path, ref bounds, id) => {\n-                    let a_def = match self.tcx.def_map.borrow().find(&id) {\n+                    let a_def = match self.tcx.def_map.borrow().get(&id) {\n                         None => {\n                             self.tcx\n                                 .sess"}, {"sha": "70c4a245b2c269fa1e667d90e69605d90ff9e96f", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -367,7 +367,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         debug!(\"RegionVarBindings: add_constraint({})\",\n                constraint.repr(self.tcx));\n \n-        if self.constraints.borrow_mut().insert(constraint, origin) {\n+        if self.constraints.borrow_mut().insert(constraint, origin).is_none() {\n             if self.in_snapshot() {\n                 self.undo_log.borrow_mut().push(AddConstraint(constraint));\n             }\n@@ -559,7 +559,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                  new_r: Region|)\n                         -> Region {\n         let vars = TwoRegions { a: a, b: b };\n-        match self.combine_map(t).borrow().find(&vars) {\n+        match self.combine_map(t).borrow().get(&vars) {\n             Some(&c) => {\n                 return ReInfer(ReVar(c));\n             }\n@@ -991,7 +991,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             debug!(\"expansion: constraint={} origin={}\",\n                    constraint.repr(self.tcx),\n                    self.constraints.borrow()\n-                                   .find(constraint)\n+                                   .get(constraint)\n                                    .unwrap()\n                                    .repr(self.tcx));\n             match *constraint {\n@@ -1075,7 +1075,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             debug!(\"contraction: constraint={} origin={}\",\n                    constraint.repr(self.tcx),\n                    self.constraints.borrow()\n-                                   .find(constraint)\n+                                   .get(constraint)\n                                    .unwrap()\n                                    .repr(self.tcx));\n             match *constraint {"}, {"sha": "d2f315f2a4b608a13f0aeb5271b0e6db79a1cd8c", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -113,7 +113,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         // e.g., fn:Copy() <: fn(), because the former is a function\n         // that only closes over copyable things, but the latter is\n         // any function at all.\n-        if a.contains(b) {\n+        if a.is_superset(&b) {\n             Ok(a)\n         } else {\n             Err(ty::terr_builtin_bounds(expected_found(self, a, b)))"}, {"sha": "5ca0de47ad500b7dc5910e835ce34ffea590fbee", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -301,7 +301,7 @@ pub fn write_substs_to_tcx(tcx: &ty::ctxt,\n     }\n }\n pub fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def {\n-    match tcx.def_map.borrow().find(&id) {\n+    match tcx.def_map.borrow().get(&id) {\n         Some(x) => x.clone(),\n         _ => {\n             tcx.sess.span_fatal(sp, \"internal error looking up a definition\")"}, {"sha": "4227cc521b48b8d95bb2cba7cd97c7d4691b408e", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -322,7 +322,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                                                 index: index,\n                                                 param_id: param_id,\n                                                 term: term });\n-        let newly_added = self.inferred_map.insert(param_id, inf_index);\n+        let newly_added = self.inferred_map.insert(param_id, inf_index).is_none();\n         assert!(newly_added);\n \n         debug!(\"add_inferred(item_id={}, \\\n@@ -376,7 +376,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n                 if self.num_inferred() == inferreds_on_entry {\n                     let newly_added = self.tcx.item_variance_map.borrow_mut().insert(\n                         ast_util::local_def(item.id),\n-                        self.empty_variances.clone());\n+                        self.empty_variances.clone()).is_none();\n                     assert!(newly_added);\n                 }\n \n@@ -556,7 +556,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     }\n \n     fn inferred_index(&self, param_id: ast::NodeId) -> InferredIndex {\n-        match self.terms_cx.inferred_map.find(&param_id) {\n+        match self.terms_cx.inferred_map.get(&param_id) {\n             Some(&index) => index,\n             None => {\n                 self.tcx().sess.bug(format!(\n@@ -569,7 +569,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n         let tcx = self.terms_cx.tcx;\n         assert!(is_lifetime(&tcx.map, param_id));\n-        match tcx.named_region_map.find(&param_id) {\n+        match tcx.named_region_map.get(&param_id) {\n             Some(&rl::DefEarlyBoundRegion(_, _, lifetime_decl_id))\n                 => lifetime_decl_id,\n             Some(_) => panic!(\"should not encounter non early-bound cases\"),\n@@ -810,7 +810,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::ty_param(ty::ParamTy { ref def_id, .. }) => {\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n-                match self.terms_cx.inferred_map.find(&def_id.node) {\n+                match self.terms_cx.inferred_map.get(&def_id.node) {\n                     Some(&index) => {\n                         self.add_constraint(index, variance);\n                     }\n@@ -1060,7 +1060,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()\n-                                 .insert(item_def_id, Rc::new(item_variances));\n+                                 .insert(item_def_id, Rc::new(item_variances)).is_none();\n             assert!(newly_added);\n         }\n     }"}, {"sha": "577d92744e6dcc7cbbe1c0de9cd2d31d1b24e3cf", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -139,7 +139,7 @@ pub fn can_reach<S,H:Hasher<S>,T:Eq+Clone+Hash<S>>(\n     let mut queue = vec!(source);\n     let mut i = 0;\n     while i < queue.len() {\n-        match edges_map.find(&queue[i]) {\n+        match edges_map.get(&queue[i]) {\n             Some(edges) => {\n                 for target in edges.iter() {\n                     if *target == destination {\n@@ -200,7 +200,7 @@ pub fn memoized_with_key<T, K: Hash<S> + Eq, U: Clone, S, H: Hasher<S>>(\n     k: |&T| -> K\n ) -> U {\n     let key = k(&arg);\n-    let result = cache.borrow().find(&key).map(|result| result.clone());\n+    let result = cache.borrow().get(&key).map(|result| result.clone());\n     match result {\n         Some(result) => result,\n         None => {"}, {"sha": "9080b12c5436abfb0f701ad684a2cddfbfd48b57", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -451,7 +451,7 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n         ty_str => \"str\".to_string(),\n         ty_unboxed_closure(ref did, _, ref substs) => {\n             let unboxed_closures = cx.unboxed_closures.borrow();\n-            unboxed_closures.find(did).map(|cl| {\n+            unboxed_closures.get(did).map(|cl| {\n                 closure_to_string(cx, &cl.closure_type.subst(cx, substs))\n             }).unwrap_or_else(|| \"closure\".to_string())\n         }\n@@ -1108,7 +1108,7 @@ impl UserString for ty::ParamBounds {\n \n impl UserString for ty::ExistentialBounds {\n     fn user_string(&self, tcx: &ctxt) -> String {\n-        if self.builtin_bounds.contains_elem(ty::BoundSend) &&\n+        if self.builtin_bounds.contains(&ty::BoundSend) &&\n             self.region_bound == ty::ReStatic\n         { // Region bound is implied by builtin bounds:\n             return self.builtin_bounds.repr(tcx);\n@@ -1277,7 +1277,7 @@ impl UserString for ParamTy {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         let id = self.idx;\n         let did = self.def_id;\n-        let ident = match tcx.ty_param_defs.borrow().find(&did.node) {\n+        let ident = match tcx.ty_param_defs.borrow().get(&did.node) {\n             Some(def) => token::get_name(def.name).get().to_string(),\n \n             // This can only happen when a type mismatch error happens and"}, {"sha": "545eeaf7406f3ac2be65dedff537312ec77f9f4f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -45,7 +45,7 @@ pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Ident>)\n         Some(tcx) => tcx,\n         None => return None,\n     };\n-    let def = match tcx.def_map.borrow().find(&id) {\n+    let def = match tcx.def_map.borrow().get(&id) {\n         Some(def) => *def,\n         None => return None,\n     };\n@@ -223,7 +223,7 @@ fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n     ty::populate_implementations_for_type_if_necessary(tcx, did);\n     let mut impls = Vec::new();\n \n-    match tcx.inherent_impls.borrow().find(&did) {\n+    match tcx.inherent_impls.borrow().get(&did) {\n         None => {}\n         Some(i) => {\n             impls.extend(i.iter().map(|&did| { build_impl(cx, tcx, did) }));"}, {"sha": "bd6c696ad74606f3e69ec082df94bf1257c80a96", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -1395,7 +1395,7 @@ impl Clean<Item> for ty::field_ty {\n         let (name, attrs) = if self.name == unnamed_field.name {\n             (None, None)\n         } else {\n-            (Some(self.name), Some(attr_map.find(&self.id.node).unwrap()))\n+            (Some(self.name), Some(attr_map.get(&self.id.node).unwrap()))\n         };\n \n         let ty = ty::lookup_item_type(cx.tcx(), self.id);\n@@ -2090,7 +2090,7 @@ fn resolve_type(cx: &DocContext, path: Path,\n         None => return Primitive(Bool),\n     };\n     debug!(\"searching for {} in defmap\", id);\n-    let def = match tcx.def_map.borrow().find(&id) {\n+    let def = match tcx.def_map.borrow().get(&id) {\n         Some(&k) => k,\n         None => panic!(\"unresolved id not in defmap\")\n     };\n@@ -2159,7 +2159,7 @@ fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSou\n \n fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<ast::DefId> {\n     cx.tcx_opt().and_then(|tcx| {\n-        tcx.def_map.borrow().find(&id).map(|&def| register_def(cx, def))\n+        tcx.def_map.borrow().get(&id).map(|&def| register_def(cx, def))\n     })\n }\n "}, {"sha": "320f84adea7a17325041dff293ea94de0376e5f2", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -208,7 +208,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, p: &clean::Path,\n             }\n         },\n         |cache| {\n-            match cache.paths.find(&did) {\n+            match cache.paths.get(&did) {\n                 None => None,\n                 Some(&(ref fqp, shortty)) => Some((fqp.clone(), shortty))\n             }\n@@ -313,7 +313,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n                   name: &str) -> fmt::Result {\n     let m = cache_key.get().unwrap();\n     let mut needs_termination = false;\n-    match m.primitive_locations.find(&prim) {\n+    match m.primitive_locations.get(&prim) {\n         Some(&ast::LOCAL_CRATE) => {\n             let loc = current_location_key.get().unwrap();\n             let len = if loc.len() == 0 {0} else {loc.len() - 1};"}, {"sha": "9dacee1652a4a235f4f4c997d19305dc44a46813", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -242,7 +242,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n         // Make sure our hyphenated ID is unique for this page\n         let map = used_header_map.get().unwrap();\n-        let id = match map.borrow_mut().find_mut(&id) {\n+        let id = match map.borrow_mut().get_mut(&id) {\n             None => id,\n             Some(a) => { *a += 1; format!(\"{}-{}\", id, *a - 1) }\n         };"}, {"sha": "fbd2611acb92d444e8f6c49002917e08e4d2e8d9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -389,7 +389,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n         // has since been learned.\n         for &(pid, ref item) in orphan_methods.iter() {\n             let did = ast_util::local_def(pid);\n-            match paths.find(&did) {\n+            match paths.get(&did) {\n                 Some(&(ref fqp, _)) => {\n                     search_index.push(IndexItem {\n                         ty: shortty(item),\n@@ -443,7 +443,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n                     item.desc.to_json().to_string()));\n         match item.parent {\n             Some(nodeid) => {\n-                let pathid = *nodeid_to_pathid.find(&nodeid).unwrap();\n+                let pathid = *nodeid_to_pathid.get(&nodeid).unwrap();\n                 try!(write!(&mut w, \",{}\", pathid));\n             }\n             None => {}\n@@ -454,7 +454,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n     try!(write!(&mut w, r#\"],\"paths\":[\"#));\n \n     for (i, &did) in pathid_to_nodeid.iter().enumerate() {\n-        let &(ref fqp, short) = cache.paths.find(&did).unwrap();\n+        let &(ref fqp, short) = cache.paths.get(&did).unwrap();\n         if i > 0 {\n             try!(write!(&mut w, \",\"));\n         }\n@@ -543,7 +543,7 @@ fn write_shared(cx: &Context,\n         //\n         // FIXME: this is a vague explanation for why this can't be a `get`, in\n         //        theory it should be...\n-        let &(ref remote_path, remote_item_type) = match cache.paths.find(&did) {\n+        let &(ref remote_path, remote_item_type) = match cache.paths.get(&did) {\n             Some(p) => p,\n             None => continue,\n         };\n@@ -838,7 +838,7 @@ impl DocFolder for Cache {\n                         } else {\n                             let last = self.parent_stack.last().unwrap();\n                             let did = *last;\n-                            let path = match self.paths.find(&did) {\n+                            let path = match self.paths.get(&did) {\n                                 Some(&(_, item_type::Trait)) =>\n                                     Some(self.stack[..self.stack.len() - 1]),\n                                 // The current stack not necessarily has correlation for\n@@ -1170,7 +1170,7 @@ impl Context {\n                                     &Item{ cx: cx, item: it }));\n             } else {\n                 let mut url = \"../\".repeat(cx.current.len());\n-                match cache_key.get().unwrap().paths.find(&it.def_id) {\n+                match cache_key.get().unwrap().paths.get(&it.def_id) {\n                     Some(&(ref names, _)) => {\n                         for name in names[..names.len() - 1].iter() {\n                             url.push_str(name.as_slice());\n@@ -1735,7 +1735,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         <h2 id='implementors'>Implementors</h2>\n         <ul class='item-list' id='implementors-list'>\n     \"));\n-    match cache.implementors.find(&it.def_id) {\n+    match cache.implementors.get(&it.def_id) {\n         Some(implementors) => {\n             for i in implementors.iter() {\n                 try!(writeln!(w, \"<li>{}<code>impl{} {} for {}{}</code></li>\",\n@@ -1992,7 +1992,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n }\n \n fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n-    match cache_key.get().unwrap().impls.find(&it.def_id) {\n+    match cache_key.get().unwrap().impls.get(&it.def_id) {\n         Some(v) => {\n             let (non_trait, traits) = v.partitioned(|i| i.impl_.trait_.is_none());\n             if non_trait.len() > 0 {\n@@ -2080,7 +2080,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n     match i.impl_.trait_ {\n         Some(clean::ResolvedPath { did, .. }) => {\n             try!({\n-                match cache_key.get().unwrap().traits.find(&did) {\n+                match cache_key.get().unwrap().traits.get(&did) {\n                     Some(t) => try!(render_default_methods(w, t, &i.impl_)),\n                     None => {}\n                 }"}, {"sha": "5e2f56e00fc0db828fd0f4b45fc33694004d12a1", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -417,7 +417,7 @@ fn json_input(input: &str) -> Result<Output, String> {\n         Ok(json::Object(obj)) => {\n             let mut obj = obj;\n             // Make sure the schema is what we expect\n-            match obj.pop(&\"schema\".to_string()) {\n+            match obj.remove(&\"schema\".to_string()) {\n                 Some(json::String(version)) => {\n                     if version.as_slice() != SCHEMA_VERSION {\n                         return Err(format!(\n@@ -428,7 +428,7 @@ fn json_input(input: &str) -> Result<Output, String> {\n                 Some(..) => return Err(\"malformed json\".to_string()),\n                 None => return Err(\"expected a schema version\".to_string()),\n             }\n-            let krate = match obj.pop(&\"crate\".to_string()) {\n+            let krate = match obj.remove(&\"crate\".to_string()) {\n                 Some(json) => {\n                     let mut d = json::Decoder::new(json);\n                     Decodable::decode(&mut d).unwrap()"}, {"sha": "4a16bcf939e7b32ebed586f223cacbf0bc4c9bf7", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -186,7 +186,7 @@ impl<T: 'static> KeyValue<T> {\n \n         // The following match takes a mutable borrow on the map. In order to insert\n         // our data if the key isn't present, we need to let the match end first.\n-        let data = match (map.find_mut(&keyval), data) {\n+        let data = match (map.get_mut(&keyval), data) {\n             (None, Some(data)) => {\n                 // The key doesn't exist and we need to insert it. To make borrowck\n                 // happy, return it up a scope and insert it there.\n@@ -266,7 +266,7 @@ impl<T: 'static> KeyValue<T> {\n         };\n         let keyval = key_to_key_value(self);\n \n-        match map.find(&keyval) {\n+        match map.get(&keyval) {\n             Some(slot) => {\n                 let value_box = slot.box_ptr as *mut TLDValueBox<T>;\n                 if unsafe { *(*value_box).refcount.get() } >= 1 {"}, {"sha": "d2d1f5fa8b091e90c74ba82475521c45e1d972b1", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -39,7 +39,7 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for DList<T> {\n         d.read_seq(|d, len| {\n             let mut list = DList::new();\n             for i in range(0u, len) {\n-                list.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+                list.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n             Ok(list)\n         })\n@@ -66,7 +66,7 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for RingBuf<T> {\n         d.read_seq(|d, len| {\n             let mut deque: RingBuf<T> = RingBuf::new();\n             for i in range(0u, len) {\n-                deque.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+                deque.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n             Ok(deque)\n         })\n@@ -165,10 +165,10 @@ impl<\n > Decodable<D, E> for EnumSet<T> {\n     fn decode(d: &mut D) -> Result<EnumSet<T>, E> {\n         let bits = try!(d.read_uint());\n-        let mut set = EnumSet::empty();\n+        let mut set = EnumSet::new();\n         for bit in range(0, uint::BITS) {\n             if bits & (1 << bit) != 0 {\n-                set.add(CLike::from_uint(1 << bit));\n+                set.insert(CLike::from_uint(1 << bit));\n             }\n         }\n         Ok(set)"}, {"sha": "9f40cd2d277e74bd41f6b2be7bae95039c799018", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -2113,7 +2113,7 @@ impl ::Decoder<DecoderError> for Decoder {\n         let name = match self.pop() {\n             String(s) => s,\n             Object(mut o) => {\n-                let n = match o.pop(&\"variant\".to_string()) {\n+                let n = match o.remove(&\"variant\".to_string()) {\n                     Some(String(s)) => s,\n                     Some(val) => {\n                         return Err(ExpectedError(\"String\".to_string(), format!(\"{}\", val)))\n@@ -2122,7 +2122,7 @@ impl ::Decoder<DecoderError> for Decoder {\n                         return Err(MissingFieldError(\"variant\".to_string()))\n                     }\n                 };\n-                match o.pop(&\"fields\".to_string()) {\n+                match o.remove(&\"fields\".to_string()) {\n                     Some(List(l)) => {\n                         for field in l.into_iter().rev() {\n                             self.stack.push(field);\n@@ -2192,7 +2192,7 @@ impl ::Decoder<DecoderError> for Decoder {\n         debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n         let mut obj = try!(expect!(self.pop(), Object));\n \n-        let value = match obj.pop(&name.to_string()) {\n+        let value = match obj.remove(&name.to_string()) {\n             None => {\n                 // Add a Null and try to parse it as an Option<_>\n                 // to get None as a default value.\n@@ -3072,8 +3072,8 @@ mod tests {\n                   \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n         let mut map: TreeMap<string::String, Animal> = super::decode(s).unwrap();\n \n-        assert_eq!(map.pop(&\"a\".to_string()), Some(Dog));\n-        assert_eq!(map.pop(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n+        assert_eq!(map.remove(&\"a\".to_string()), Some(Dog));\n+        assert_eq!(map.remove(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n     }\n \n     #[test]"}, {"sha": "0e75e4610abf98e13b32767062892a4ccf54e52f", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -627,7 +627,7 @@ pub trait Reader {\n     /// as `Err(IoError)`. See `read()` for more details.\n     fn push(&mut self, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n         let start_len = buf.len();\n-        buf.reserve_additional(len);\n+        buf.reserve(len);\n \n         let n = {\n             let s = unsafe { slice_vec_capacity(buf, start_len, start_len + len) };\n@@ -658,7 +658,7 @@ pub trait Reader {\n         }\n \n         let start_len = buf.len();\n-        buf.reserve_additional(len);\n+        buf.reserve(len);\n \n         // we can't just use self.read_at_least(min, slice) because we need to push\n         // successful reads onto the vector before any returned errors."}, {"sha": "698e0a3460f2878946a6b11bc9e59c9b54a53e52", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -1137,7 +1137,7 @@ mod tests {\n         cmd.env(\"path\", \"foo\");\n         cmd.env(\"Path\", \"bar\");\n         let env = &cmd.env.unwrap();\n-        let val = env.find(&EnvKey(\"PATH\".to_c_str()));\n+        let val = env.get(&EnvKey(\"PATH\".to_c_str()));\n         assert!(val.unwrap() == &\"bar\".to_c_str());\n     }\n }"}, {"sha": "d077fbd7bf00f58cdfec3bd8098c9248a723d623", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -63,7 +63,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n         ()\n     });\n     with_used_diagnostics(|diagnostics| {\n-        match diagnostics.swap(code.name, span) {\n+        match diagnostics.insert(code.name, span) {\n             Some(previous_span) => {\n                 ecx.span_warn(span, format!(\n                     \"diagnostic code {} already used\", token::get_ident(code).get()\n@@ -93,7 +93,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n         _ => unreachable!()\n     };\n     with_registered_diagnostics(|diagnostics| {\n-        if !diagnostics.insert(code.name, description) {\n+        if diagnostics.insert(code.name, description).is_some() {\n             ecx.span_err(span, format!(\n                 \"diagnostic code {} already registered\", token::get_ident(*code).get()\n             ).as_slice());"}, {"sha": "5401da8cd053bf7d6e0b424d677f64df3369a421", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -768,7 +768,7 @@ impl SyntaxEnv {\n \n     pub fn find(&self, k: &Name) -> Option<Rc<SyntaxExtension>> {\n         for frame in self.chain.iter().rev() {\n-            match frame.map.find(k) {\n+            match frame.map.get(k) {\n                 Some(v) => return Some(v.clone()),\n                 None => {}\n             }"}, {"sha": "a28f24e76635d283235d3de2f4b30f52fd70b6db", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -252,15 +252,15 @@ impl<'a, 'b> Context<'a, 'b> {\n             }\n \n             Named(name) => {\n-                let span = match self.names.find(&name) {\n+                let span = match self.names.get(&name) {\n                     Some(e) => e.span,\n                     None => {\n                         let msg = format!(\"there is no argument named `{}`\", name);\n                         self.ecx.span_err(self.fmtsp, msg.as_slice());\n                         return;\n                     }\n                 };\n-                self.verify_same(span, &ty, self.name_types.find(&name));\n+                self.verify_same(span, &ty, self.name_types.get(&name));\n                 if !self.name_types.contains_key(&name) {\n                     self.name_types.insert(name.clone(), ty);\n                 }\n@@ -555,11 +555,11 @@ impl<'a, 'b> Context<'a, 'b> {\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n         }\n         for name in self.name_ordering.iter() {\n-            let e = match self.names.pop(name) {\n+            let e = match self.names.remove(name) {\n                 Some(e) => e,\n                 None => continue\n             };\n-            let arg_ty = match self.name_types.find(name) {\n+            let arg_ty = match self.name_types.get(name) {\n                 Some(ty) => ty,\n                 None => continue\n             };"}, {"sha": "15fe7fc42b27507b0d80710dedc100e1b892686f", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -182,7 +182,7 @@ fn resolve_internal(id: Ident,\n                     resolve_table: &mut ResolveTable) -> Name {\n     let key = (id.name, id.ctxt);\n \n-    match resolve_table.find(&key) {\n+    match resolve_table.get(&key) {\n         Some(&name) => return name,\n         None => {}\n     }"}, {"sha": "bc6d6d7a5216d091c1a15741747102590a533d80", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -45,7 +45,7 @@ impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n \n     pub fn intern(&self, val: T) -> Name {\n         let mut map = self.map.borrow_mut();\n-        match (*map).find(&val) {\n+        match (*map).get(&val) {\n             Some(&idx) => return idx,\n             None => (),\n         }"}, {"sha": "4d6aefb2a178d466ae5ac16dbc0f19e12335dc13", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -1209,7 +1209,7 @@ impl MetricMap {\n         let MetricMap(ref selfmap) = *self;\n         let MetricMap(ref old) = *old;\n         for (k, vold) in old.iter() {\n-            let r = match selfmap.find(k) {\n+            let r = match selfmap.get(k) {\n                 None => MetricRemoved,\n                 Some(v) => {\n                     let delta = v.value - vold.value;\n@@ -1678,31 +1678,31 @@ mod tests {\n \n         let diff1 = m2.compare_to_old(&m1, None);\n \n-        assert_eq!(*(diff1.find(&\"in-both-noise\".to_string()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff1.find(&\"in-first-noise\".to_string()).unwrap()), MetricRemoved);\n-        assert_eq!(*(diff1.find(&\"in-second-noise\".to_string()).unwrap()), MetricAdded);\n-        assert_eq!(*(diff1.find(&\"in-both-want-downwards-but-regressed\".to_string()).unwrap()),\n+        assert_eq!(*(diff1.get(&\"in-both-noise\".to_string()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff1.get(&\"in-first-noise\".to_string()).unwrap()), MetricRemoved);\n+        assert_eq!(*(diff1.get(&\"in-second-noise\".to_string()).unwrap()), MetricAdded);\n+        assert_eq!(*(diff1.get(&\"in-both-want-downwards-but-regressed\".to_string()).unwrap()),\n                    Regression(100.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-downwards-and-improved\".to_string()).unwrap()),\n+        assert_eq!(*(diff1.get(&\"in-both-want-downwards-and-improved\".to_string()).unwrap()),\n                    Improvement(50.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-upwards-but-regressed\".to_string()).unwrap()),\n+        assert_eq!(*(diff1.get(&\"in-both-want-upwards-but-regressed\".to_string()).unwrap()),\n                    Regression(50.0));\n-        assert_eq!(*(diff1.find(&\"in-both-want-upwards-and-improved\".to_string()).unwrap()),\n+        assert_eq!(*(diff1.get(&\"in-both-want-upwards-and-improved\".to_string()).unwrap()),\n                    Improvement(100.0));\n         assert_eq!(diff1.len(), 7);\n \n         let diff2 = m2.compare_to_old(&m1, Some(200.0));\n \n-        assert_eq!(*(diff2.find(&\"in-both-noise\".to_string()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-first-noise\".to_string()).unwrap()), MetricRemoved);\n-        assert_eq!(*(diff2.find(&\"in-second-noise\".to_string()).unwrap()), MetricAdded);\n-        assert_eq!(*(diff2.find(&\"in-both-want-downwards-but-regressed\".to_string()).unwrap()),\n+        assert_eq!(*(diff2.get(&\"in-both-noise\".to_string()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.get(&\"in-first-noise\".to_string()).unwrap()), MetricRemoved);\n+        assert_eq!(*(diff2.get(&\"in-second-noise\".to_string()).unwrap()), MetricAdded);\n+        assert_eq!(*(diff2.get(&\"in-both-want-downwards-but-regressed\".to_string()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-downwards-and-improved\".to_string()).unwrap()),\n+        assert_eq!(*(diff2.get(&\"in-both-want-downwards-and-improved\".to_string()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-upwards-but-regressed\".to_string()).unwrap()),\n+        assert_eq!(*(diff2.get(&\"in-both-want-upwards-but-regressed\".to_string()).unwrap()),\n                    LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"in-both-want-upwards-and-improved\".to_string()).unwrap()),\n+        assert_eq!(*(diff2.get(&\"in-both-want-upwards-and-improved\".to_string()).unwrap()),\n                    LikelyNoise);\n         assert_eq!(diff2.len(), 7);\n     }\n@@ -1727,29 +1727,29 @@ mod tests {\n         let (diff1, ok1) = m2.ratchet(&pth, None);\n         assert_eq!(ok1, false);\n         assert_eq!(diff1.len(), 2);\n-        assert_eq!(*(diff1.find(&\"runtime\".to_string()).unwrap()), Regression(10.0));\n-        assert_eq!(*(diff1.find(&\"throughput\".to_string()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff1.get(&\"runtime\".to_string()).unwrap()), Regression(10.0));\n+        assert_eq!(*(diff1.get(&\"throughput\".to_string()).unwrap()), LikelyNoise);\n \n         // Check that it was not rewritten.\n         let m3 = MetricMap::load(&pth);\n         let MetricMap(m3) = m3;\n         assert_eq!(m3.len(), 2);\n-        assert_eq!(*(m3.find(&\"runtime\".to_string()).unwrap()), Metric::new(1000.0, 2.0));\n-        assert_eq!(*(m3.find(&\"throughput\".to_string()).unwrap()), Metric::new(50.0, 2.0));\n+        assert_eq!(*(m3.get(&\"runtime\".to_string()).unwrap()), Metric::new(1000.0, 2.0));\n+        assert_eq!(*(m3.get(&\"throughput\".to_string()).unwrap()), Metric::new(50.0, 2.0));\n \n         // Ask for a ratchet with an explicit noise-percentage override,\n         // that should advance.\n         let (diff2, ok2) = m2.ratchet(&pth, Some(10.0));\n         assert_eq!(ok2, true);\n         assert_eq!(diff2.len(), 2);\n-        assert_eq!(*(diff2.find(&\"runtime\".to_string()).unwrap()), LikelyNoise);\n-        assert_eq!(*(diff2.find(&\"throughput\".to_string()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.get(&\"runtime\".to_string()).unwrap()), LikelyNoise);\n+        assert_eq!(*(diff2.get(&\"throughput\".to_string()).unwrap()), LikelyNoise);\n \n         // Check that it was rewritten.\n         let m4 = MetricMap::load(&pth);\n         let MetricMap(m4) = m4;\n         assert_eq!(m4.len(), 2);\n-        assert_eq!(*(m4.find(&\"runtime\".to_string()).unwrap()), Metric::new(1100.0, 2.0));\n-        assert_eq!(*(m4.find(&\"throughput\".to_string()).unwrap()), Metric::new(50.0, 2.0));\n+        assert_eq!(*(m4.get(&\"runtime\".to_string()).unwrap()), Metric::new(1100.0, 2.0));\n+        assert_eq!(*(m4.get(&\"throughput\".to_string()).unwrap()), Metric::new(50.0, 2.0));\n     }\n }"}, {"sha": "ac6104cc38b0e3ccf3ae9f1a7162785ccf3ee607", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -30,18 +30,18 @@ trait MutableMap {\n \n impl MutableMap for TreeMap<uint, uint> {\n     fn insert(&mut self, k: uint, v: uint) { self.insert(k, v); }\n-    fn remove(&mut self, k: &uint) -> bool { self.remove(k) }\n-    fn find(&self, k: &uint) -> Option<&uint> { self.find(k) }\n+    fn remove(&mut self, k: &uint) -> bool { self.remove(k).is_some() }\n+    fn find(&self, k: &uint) -> Option<&uint> { self.get(k) }\n }\n impl MutableMap for HashMap<uint, uint> {\n     fn insert(&mut self, k: uint, v: uint) { self.insert(k, v); }\n-    fn remove(&mut self, k: &uint) -> bool { self.remove(k) }\n-    fn find(&self, k: &uint) -> Option<&uint> { self.find(k) }\n+    fn remove(&mut self, k: &uint) -> bool { self.remove(k).is_some() }\n+    fn find(&self, k: &uint) -> Option<&uint> { self.get(k) }\n }\n impl MutableMap for TrieMap<uint> {\n     fn insert(&mut self, k: uint, v: uint) { self.insert(k, v); }\n-    fn remove(&mut self, k: &uint) -> bool { self.remove(k) }\n-    fn find(&self, k: &uint) -> Option<&uint> { self.find(k) }\n+    fn remove(&mut self, k: &uint) -> bool { self.remove(k).is_some() }\n+    fn find(&self, k: &uint) -> Option<&uint> { self.get(k) }\n }\n \n fn ascending<M: MutableMap>(map: &mut M, n_keys: uint) {"}, {"sha": "191f70ac492188d186a5590c4de857d4b58ba29f", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -197,8 +197,8 @@ fn rendezvous(nn: uint, set: Vec<Color>) {\n \n         creatures_met += 2;\n \n-        to_creature.get_mut(fst_creature.name).send(snd_creature);\n-        to_creature.get_mut(snd_creature.name).send(fst_creature);\n+        to_creature[fst_creature.name].send(snd_creature);\n+        to_creature[snd_creature.name].send(fst_creature);\n     }\n \n     // tell each creature to stop"}, {"sha": "0a3370fa487e89c6e95daedd20c8d455fd35165a", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -100,7 +100,7 @@ fn sum_and_scale(a: &'static [AminoAcid]) -> Vec<AminoAcid> {\n         result.push(a_i);\n     }\n     let result_len = result.len();\n-    result.get_mut(result_len - 1).p = LOOKUP_SCALE;\n+    result[result_len - 1].p = LOOKUP_SCALE;\n     result\n }\n "}, {"sha": "6ada34a5a584d4e8e518c8095a8bc00004b51564", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -171,13 +171,13 @@ impl Table {\n                     next: None,\n                 };\n                 c.f(&mut *entry);\n-                *self.items.get_mut(index as uint) = Some(entry);\n+                self.items[index as uint] = Some(entry);\n                 return;\n             }\n         }\n \n         {\n-            let entry = self.items.get_mut(index as uint).as_mut().unwrap();\n+            let entry = self.items[index as uint].as_mut().unwrap();\n             if entry.code == key {\n                 c.f(&mut **entry);\n                 return;"}, {"sha": "d8df3eea83b0556b44429c08724e4a00b7495158", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -194,7 +194,7 @@ fn is_board_unfeasible(board: u64, masks: &Vec<Vec<Vec<u64>>>) -> bool {\n fn filter_masks(masks: &mut Vec<Vec<Vec<u64>>>) {\n     for i in range(0, masks.len()) {\n         for j in range(0, (*masks)[i].len()) {\n-            *masks.get_mut(i).get_mut(j) =\n+            masks[i][j] =\n                 (*masks)[i][j].iter().map(|&m| m)\n                 .filter(|&m| !is_board_unfeasible(m, masks))\n                 .collect();\n@@ -217,7 +217,7 @@ fn to_vec(raw_sol: &List<u64>) -> Vec<u8> {\n         let id = '0' as u8 + get_id(m);\n         for i in range(0u, 50) {\n             if m & 1 << i != 0 {\n-                *sol.get_mut(i) = id;\n+                sol[i] = id;\n             }\n         }\n     }"}, {"sha": "81de7a1269067b3d89dfab65ef19ce881532dfd8", "filename": "src/test/bench/shootout-regex-dna.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -114,7 +114,7 @@ fn main() {\n     }\n \n     for (i, variant) in variant_strs.iter().enumerate() {\n-        println!(\"{} {}\", variant, counts.get_mut(i).get());\n+        println!(\"{} {}\", variant, counts[i].get());\n     }\n     println!(\"\");\n     println!(\"{}\", ilen);"}, {"sha": "d7d8e94c8a7dbd5d468db9641fe8aebbe42b5795", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -112,14 +112,15 @@ fn read_to_end<R: Reader>(r: &mut R) -> IoResult<Vec<u8>> {\n     let mut vec = Vec::with_capacity(CHUNK);\n     loop {\n         // workaround: very fast growing\n-        if vec.capacity() - vec.len() < CHUNK {\n+        let len = vec.len();\n+        if vec.capacity() - len < CHUNK {\n             let cap = vec.capacity();\n             let mult = if cap < 256 * 1024 * 1024 {\n                 16\n             } else {\n                 2\n             };\n-            vec.reserve_exact(mult * cap);\n+            vec.reserve_exact(mult * cap - len);\n         }\n         match r.push_at_least(1, CHUNK, &mut vec) {\n             Ok(_) => {}"}, {"sha": "54824d7259fa9b49731a870f5182638676e3832a", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -79,7 +79,7 @@ impl Sudoku {\n             if comps.len() == 3u {\n                 let row     = from_str::<uint>(comps[0]).unwrap() as u8;\n                 let col     = from_str::<uint>(comps[1]).unwrap() as u8;\n-                *g.get_mut(row as uint).get_mut(col as uint) =\n+                g[row as uint][col as uint] =\n                     from_str::<uint>(comps[2]).unwrap() as u8;\n             }\n             else {\n@@ -139,10 +139,10 @@ impl Sudoku {\n \n             // find first remaining color that is available\n             let next = avail.next();\n-            *self.grid.get_mut(row as uint).get_mut(col as uint) = next;\n+            self.grid[row as uint][col as uint] = next;\n             return 0u8 != next;\n         }\n-        *self.grid.get_mut(row as uint).get_mut(col as uint) = 0u8;\n+        self.grid[row as uint][col as uint] = 0u8;\n         return false;\n     }\n "}, {"sha": "e14911d3508da46ddd106a4cb141152f1efe27e1", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -19,7 +19,7 @@ fn a() {\n     // Create an immutable pointer into p's contents:\n     let q: &int = &p[0];\n \n-    *p.get_mut(0) = 5; //~ ERROR cannot borrow\n+    p[0] = 5; //~ ERROR cannot borrow\n \n     println!(\"{}\", *q);\n }\n@@ -34,15 +34,15 @@ fn b() {\n \n     borrow(\n         p.as_slice(),\n-        || *p.get_mut(0) = 5); //~ ERROR cannot borrow `p` as mutable\n+        || p[0] = 5); //~ ERROR cannot borrow `p` as mutable\n }\n \n fn c() {\n     // Legal because the scope of the borrow does not include the\n     // modification:\n     let mut p = vec!(1);\n     borrow(p.as_slice(), ||{});\n-    *p.get_mut(0) = 5;\n+    p[0] = 5;\n }\n \n fn main() {"}, {"sha": "d712810589200bd2e53e02dd2a09e8d646dc0285", "filename": "src/test/compile-fail/borrowck-for-loop-head-linkage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-for-loop-head-linkage.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     for &x in vector.iter() {\n         let cap = vector.capacity();\n         vector.grow(cap, 0u);      //~ ERROR cannot borrow\n-        *vector.get_mut(1u) = 5u;   //~ ERROR cannot borrow\n+        vector[1u] = 5u;   //~ ERROR cannot borrow\n     }\n }\n "}, {"sha": "200d208d140b69a054538222bf1d7d10c8fdf4a0", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -26,7 +26,7 @@ fn has_mut_vec_but_tries_to_change_it() {\n     takes_imm_elt(\n         &v[0],\n         || { //~ ERROR cannot borrow `v` as mutable\n-            *v.get_mut(1) = 4;\n+            v[1] = 4;\n         })\n }\n "}, {"sha": "2a54f22ee665b44f843e7deee0c12805c296c5e1", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -15,7 +15,7 @@ pub fn main() {\n     let mut a: Vec<int> = vec!(-1, -1, -1, -1);\n     let mut p: int = 0;\n     two(|i| {\n-        two(|j| { *a.get_mut(p as uint) = 10 * i + j; p += 1; })\n+        two(|j| { a[p as uint] = 10 * i + j; p += 1; })\n     });\n     assert_eq!(a[0], 0);\n     assert_eq!(a[1], 1);"}, {"sha": "4a6a6782fb3db5191acce2ffd91cb00249fc60ad", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -83,7 +83,7 @@ mod map_reduce {\n               mapper_done => { num_mappers -= 1; }\n               find_reducer(k, cc) => {\n                 let mut c;\n-                match reducers.find(&str::from_utf8(\n+                match reducers.get(&str::from_utf8(\n                         k.as_slice()).unwrap().to_string()) {\n                   Some(&_c) => { c = _c; }\n                   None => { c = 0; }"}, {"sha": "4e330b9a0e7dd98ec2b0e76f49dd001993a7b778", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -86,8 +86,8 @@ impl AsciiArt {\n                 // element is:\n                 // 1) potentially large\n                 // 2) needs to be modified\n-                let row = self.lines.get_mut(v);\n-                *row.get_mut(h) = self.fill;\n+                let row = &mut self.lines[v];\n+                row[h] = self.fill;\n             }\n         }\n     }"}, {"sha": "37144fb9cce771f62332a09f96cf1a00b672f614", "filename": "src/test/run-pass/issue-3991.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Fissue-3991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Fissue-3991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3991.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -15,7 +15,7 @@ struct HasNested {\n \n impl HasNested {\n     fn method_push_local(&mut self) {\n-        self.nest.get_mut(0).push(0);\n+        self.nest[0].push(0);\n     }\n }\n "}, {"sha": "ca820830f023f65a1aada2c29f6b96a857d0abc1", "filename": "src/test/run-pass/overloaded-deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -44,8 +44,8 @@ pub fn main() {\n     assert_eq!(*(*p).borrow(), Point {x: 3, y: 5});\n \n     let v = Rc::new(RefCell::new(vec!(1i, 2, 3)));\n-    *(*(*v).borrow_mut()).get_mut(0) = 3;\n-    *(*(*v).borrow_mut()).get_mut(1) += 3;\n+    (*(*v).borrow_mut())[0] = 3;\n+    (*(*v).borrow_mut())[1] += 3;\n     assert_eq!(((*(*v).borrow())[0],\n                 (*(*v).borrow())[1],\n                 (*(*v).borrow())[2]), (3, 5, 3));"}, {"sha": "55003a07b5bbe1a86eecfbcb7b4a64a5bcc3bc15", "filename": "src/test/run-pass/send_str_hashmap.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -16,37 +16,37 @@ use std::option::Some;\n \n pub fn main() {\n     let mut map: HashMap<SendStr, uint> = HashMap::new();\n-    assert!(map.insert(Slice(\"foo\"), 42));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 42));\n-    assert!(!map.insert(Slice(\"foo\"), 42));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 42));\n+    assert!(map.insert(Slice(\"foo\"), 42).is_none());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 42).is_some());\n+    assert!(map.insert(Slice(\"foo\"), 42).is_some());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 42).is_some());\n \n-    assert!(!map.insert(Slice(\"foo\"), 43));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 44));\n-    assert!(!map.insert(Slice(\"foo\"), 45));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 46));\n+    assert!(map.insert(Slice(\"foo\"), 43).is_some());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 44).is_some());\n+    assert!(map.insert(Slice(\"foo\"), 45).is_some());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 46).is_some());\n \n     let v = 46;\n \n-    assert_eq!(map.find(&Owned(\"foo\".to_string())), Some(&v));\n-    assert_eq!(map.find(&Slice(\"foo\")), Some(&v));\n+    assert_eq!(map.get(&Owned(\"foo\".to_string())), Some(&v));\n+    assert_eq!(map.get(&Slice(\"foo\")), Some(&v));\n \n     let (a, b, c, d) = (50, 51, 52, 53);\n \n-    assert!(map.insert(Slice(\"abc\"), a));\n-    assert!(map.insert(Owned(\"bcd\".to_string()), b));\n-    assert!(map.insert(Slice(\"cde\"), c));\n-    assert!(map.insert(Owned(\"def\".to_string()), d));\n+    assert!(map.insert(Slice(\"abc\"), a).is_none());\n+    assert!(map.insert(Owned(\"bcd\".to_string()), b).is_none());\n+    assert!(map.insert(Slice(\"cde\"), c).is_none());\n+    assert!(map.insert(Owned(\"def\".to_string()), d).is_none());\n \n-    assert!(!map.insert(Slice(\"abc\"), a));\n-    assert!(!map.insert(Owned(\"bcd\".to_string()), b));\n-    assert!(!map.insert(Slice(\"cde\"), c));\n-    assert!(!map.insert(Owned(\"def\".to_string()), d));\n+    assert!(map.insert(Slice(\"abc\"), a).is_some());\n+    assert!(map.insert(Owned(\"bcd\".to_string()), b).is_some());\n+    assert!(map.insert(Slice(\"cde\"), c).is_some());\n+    assert!(map.insert(Owned(\"def\".to_string()), d).is_some());\n \n-    assert!(!map.insert(Owned(\"abc\".to_string()), a));\n-    assert!(!map.insert(Slice(\"bcd\"), b));\n-    assert!(!map.insert(Owned(\"cde\".to_string()), c));\n-    assert!(!map.insert(Slice(\"def\"), d));\n+    assert!(map.insert(Owned(\"abc\".to_string()), a).is_some());\n+    assert!(map.insert(Slice(\"bcd\"), b).is_some());\n+    assert!(map.insert(Owned(\"cde\".to_string()), c).is_some());\n+    assert!(map.insert(Slice(\"def\"), d).is_some());\n \n     assert_eq!(map.find_equiv(\"abc\"), Some(&a));\n     assert_eq!(map.find_equiv(\"bcd\"), Some(&b));"}, {"sha": "c52f9458f99d5fb9ced11707b0b23b4239bfc880", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -17,49 +17,49 @@ use std::option::Some;\n \n pub fn main() {\n     let mut map: TreeMap<SendStr, uint> = TreeMap::new();\n-    assert!(map.insert(Slice(\"foo\"), 42));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 42));\n-    assert!(!map.insert(Slice(\"foo\"), 42));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 42));\n+    assert!(map.insert(Slice(\"foo\"), 42).is_none());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 42).is_some());\n+    assert!(map.insert(Slice(\"foo\"), 42).is_some());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 42).is_some());\n \n-    assert!(!map.insert(Slice(\"foo\"), 43));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 44));\n-    assert!(!map.insert(Slice(\"foo\"), 45));\n-    assert!(!map.insert(Owned(\"foo\".to_string()), 46));\n+    assert!(map.insert(Slice(\"foo\"), 43).is_some());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 44).is_some());\n+    assert!(map.insert(Slice(\"foo\"), 45).is_some());\n+    assert!(map.insert(Owned(\"foo\".to_string()), 46).is_some());\n \n     let v = 46;\n \n-    assert_eq!(map.find(&Owned(\"foo\".to_string())), Some(&v));\n-    assert_eq!(map.find(&Slice(\"foo\")), Some(&v));\n+    assert_eq!(map.get(&Owned(\"foo\".to_string())), Some(&v));\n+    assert_eq!(map.get(&Slice(\"foo\")), Some(&v));\n \n     let (a, b, c, d) = (50, 51, 52, 53);\n \n-    assert!(map.insert(Slice(\"abc\"), a));\n-    assert!(map.insert(Owned(\"bcd\".to_string()), b));\n-    assert!(map.insert(Slice(\"cde\"), c));\n-    assert!(map.insert(Owned(\"def\".to_string()), d));\n+    assert!(map.insert(Slice(\"abc\"), a).is_none());\n+    assert!(map.insert(Owned(\"bcd\".to_string()), b).is_none());\n+    assert!(map.insert(Slice(\"cde\"), c).is_none());\n+    assert!(map.insert(Owned(\"def\".to_string()), d).is_none());\n \n-    assert!(!map.insert(Slice(\"abc\"), a));\n-    assert!(!map.insert(Owned(\"bcd\".to_string()), b));\n-    assert!(!map.insert(Slice(\"cde\"), c));\n-    assert!(!map.insert(Owned(\"def\".to_string()), d));\n+    assert!(map.insert(Slice(\"abc\"), a).is_some());\n+    assert!(map.insert(Owned(\"bcd\".to_string()), b).is_some());\n+    assert!(map.insert(Slice(\"cde\"), c).is_some());\n+    assert!(map.insert(Owned(\"def\".to_string()), d).is_some());\n \n-    assert!(!map.insert(Owned(\"abc\".to_string()), a));\n-    assert!(!map.insert(Slice(\"bcd\"), b));\n-    assert!(!map.insert(Owned(\"cde\".to_string()), c));\n-    assert!(!map.insert(Slice(\"def\"), d));\n+    assert!(map.insert(Owned(\"abc\".to_string()), a).is_some());\n+    assert!(map.insert(Slice(\"bcd\"), b).is_some());\n+    assert!(map.insert(Owned(\"cde\".to_string()), c).is_some());\n+    assert!(map.insert(Slice(\"def\"), d).is_some());\n \n-    assert_eq!(map.find(&Slice(\"abc\")), Some(&a));\n-    assert_eq!(map.find(&Slice(\"bcd\")), Some(&b));\n-    assert_eq!(map.find(&Slice(\"cde\")), Some(&c));\n-    assert_eq!(map.find(&Slice(\"def\")), Some(&d));\n+    assert_eq!(map.get(&Slice(\"abc\")), Some(&a));\n+    assert_eq!(map.get(&Slice(\"bcd\")), Some(&b));\n+    assert_eq!(map.get(&Slice(\"cde\")), Some(&c));\n+    assert_eq!(map.get(&Slice(\"def\")), Some(&d));\n \n-    assert_eq!(map.find(&Owned(\"abc\".to_string())), Some(&a));\n-    assert_eq!(map.find(&Owned(\"bcd\".to_string())), Some(&b));\n-    assert_eq!(map.find(&Owned(\"cde\".to_string())), Some(&c));\n-    assert_eq!(map.find(&Owned(\"def\".to_string())), Some(&d));\n+    assert_eq!(map.get(&Owned(\"abc\".to_string())), Some(&a));\n+    assert_eq!(map.get(&Owned(\"bcd\".to_string())), Some(&b));\n+    assert_eq!(map.get(&Owned(\"cde\".to_string())), Some(&c));\n+    assert_eq!(map.get(&Owned(\"def\".to_string())), Some(&d));\n \n-    assert!(map.pop(&Slice(\"foo\")).is_some());\n+    assert!(map.remove(&Slice(\"foo\")).is_some());\n     assert_eq!(map.into_iter().map(|(k, v)| format!(\"{}{}\", k, v))\n                               .collect::<Vec<String>>()\n                               .concat(),"}, {"sha": "3c0f9505736a962a0bda461dec549b2b121d65f1", "filename": "src/test/run-pass/swap-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-2.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -16,7 +16,7 @@ pub fn main() {\n     assert_eq!(a[2], 4);\n     assert_eq!(a[4], 2);\n     let mut n = 42;\n-    swap(&mut n, a.get_mut(0));\n+    swap(&mut n, &mut a[0]);\n     assert_eq!(a[0], 42);\n     assert_eq!(n, 0);\n }"}, {"sha": "577a8f1430b2f9021d7c1ab5776ad931fb3296b8", "filename": "src/test/run-pass/unique-in-vec-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec145be3f5e5f763e61749a6737f90df8504e05/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs?ref=eec145be3f5e5f763e61749a6737f90df8504e05", "patch": "@@ -17,7 +17,7 @@ pub fn main() {\n     assert_eq!(*b[0], 10);\n \n     // This should only modify the value in a, not b\n-    **a.get_mut(0) = 20;\n+    *a[0] = 20;\n \n     assert_eq!(*a[0], 20);\n     assert_eq!(*b[0], 10);"}]}