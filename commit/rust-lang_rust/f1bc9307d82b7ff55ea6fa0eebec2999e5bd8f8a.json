{"sha": "f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYmM5MzA3ZDgyYjdmZjU1ZWE2ZmEwZWViZWMyOTk5ZTViZDhmOGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-10-25T20:13:55Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-02T21:14:19Z"}, "message": "get things checking on ia32", "tree": {"sha": "c9529c3ab69a125dc9e65cbf4f598f00ac14a025", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9529c3ab69a125dc9e65cbf4f598f00ac14a025"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "html_url": "https://github.com/rust-lang/rust/commit/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0e9c42bd2f81d9694ee4c77b3440a44d38737e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6", "html_url": "https://github.com/rust-lang/rust/commit/c0e9c42bd2f81d9694ee4c77b3440a44d38737e6"}], "stats": {"total": 193, "additions": 96, "deletions": 97}, "files": [{"sha": "cda0dcd7f31a0623f6b3b23685c56dd4a3eb73ab", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "patch": "@@ -48,6 +48,7 @@ fn declare_upcalls(targ_cfg: @session::config,\n     let dv = bind decl(llmod, _, _, T_void());\n \n     let int_t = T_int(targ_cfg);\n+    let float_t = T_float(targ_cfg);\n     let size_t = T_size_t(targ_cfg);\n     let opaque_vec_t = T_opaque_vec(targ_cfg);\n \n@@ -88,16 +89,16 @@ fn declare_upcalls(targ_cfg: @session::config,\n               d(\"dynastack_alloc_2\", [size_t, T_ptr(tydesc_type)],\n                 T_ptr(T_i8())),\n           dynastack_free: dv(\"dynastack_free\", [T_ptr(T_i8())]),\n-          alloc_c_stack: d(\"alloc_c_stack\", [T_size_t()], T_ptr(T_i8())),\n+          alloc_c_stack: d(\"alloc_c_stack\", [size_t], T_ptr(T_i8())),\n           call_c_stack: d(\"call_c_stack\",\n-                              [T_ptr(T_fn([], T_int())), T_ptr(T_i8())],\n+                              [T_ptr(T_fn([], int_t)), T_ptr(T_i8())],\n                               int_t),\n           call_c_stack_i64: d(\"call_c_stack_i64\",\n-                              [T_ptr(T_fn([], T_int())), T_ptr(T_i8())],\n+                              [T_ptr(T_fn([], int_t)), T_ptr(T_i8())],\n                               T_i64()),\n           call_c_stack_float: d(\"call_c_stack_float\",\n-                                [T_ptr(T_fn([], T_int())), T_ptr(T_i8())],\n-                                T_float()),\n+                                [T_ptr(T_fn([], int_t)), T_ptr(T_i8())],\n+                                float_t),\n           rust_personality: d(\"rust_personality\", [], T_i32())\n          };\n }"}, {"sha": "2328c2efa93269e8c74bd6008a86da5321d3baae", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "patch": "@@ -169,7 +169,7 @@ fn find_library_crate_aux(sess: session::session,\n }\n \n fn get_metadata_section(sess: session::session,\n-                        filename: str) -> option::t<@[u8]> {\n+                        filename: str) -> option::t<@[u8]> unsafe {\n     let mb = str::as_buf(filename, {|buf|\n         llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n                                    });"}, {"sha": "cb1254d4729b291f0d45b7d213aa3934d9ed22b5", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "patch": "@@ -226,13 +226,13 @@ fn type_of_tag(cx: @crate_ctxt, sp: span, did: ast::def_id, t: ty::t)\n     let degen = std::vec::len(ty::tag_variants(cx.tcx, did)) == 1u;\n     if check type_has_static_size(cx, t) {\n         let size = static_size_of_tag(cx, sp, t);\n-        if !degen { T_tag(cx.tn, size) }\n-        else if size == 0u { T_struct([T_int()]) }\n+        if !degen { T_tag(cx, size) }\n+        else if size == 0u { T_struct([cx.int_type]) }\n         else { T_array(T_i8(), size) }\n     }\n     else {\n-        if degen { T_struct([T_int()]) }\n-        else { T_opaque_tag(cx.tn) }\n+        if degen { T_struct([cx.int_type]) }\n+        else { T_opaque_tag(cx) }\n     }\n }\n \n@@ -3031,12 +3031,13 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n             let lltagty = type_of_tag(ccx, sp, tid, tag_ty);\n             let bcx = alloc_result.bcx;\n             let lltagptr = PointerCast(bcx, lltagblob, T_ptr(lltagty));\n-            let lldiscrimptr = GEP(bcx, lltagptr, [C_int(0), C_int(0)]);\n+            let lldiscrimptr = GEP(bcx, lltagptr, [C_int(ccx, 0),\n+                                                   C_int(ccx, 0)]);\n             let d = if std::vec::len(ty::tag_variants(ccx.tcx, tid)) != 1u {\n                 let lldiscrim_gv = lookup_discriminant(bcx.fcx.lcx, vid);\n                 let lldiscrim = Load(bcx, lldiscrim_gv);\n                 lldiscrim\n-            } else { C_int(0) };\n+            } else { C_int(ccx, 0) };\n             Store(bcx, d, lldiscrimptr);\n             ret lval_no_env(bcx, lltagptr, temporary);\n           }\n@@ -3914,7 +3915,8 @@ fn trans_c_stack_native_call(bcx: @block_ctxt, f: @ast::expr,\n     let i = 0u, n = vec::len(llargs);\n     while i < n {\n         let llarg = llargs[i].llval;\n-        store_inbounds(bcx, llarg, llargbundle, [C_int(0), C_uint(i)]);\n+        store_inbounds(bcx, llarg, llargbundle, [C_int(ccx, 0),\n+                                                 C_uint(ccx, i)]);\n         i += 1u;\n     }\n \n@@ -4449,8 +4451,8 @@ fn trans_log(lvl: int, cx: @block_ctxt, e: @ast::expr) -> @block_ctxt {\n     let llvalptr = r.val;\n     let llval_i8 = PointerCast(log_bcx, llvalptr, T_ptr(T_i8()));\n \n-    Call(log_bcx, bcx_ccx(log_bcx).upcalls.log_type,\n-         [lltydesc, llval_i8, C_int(lvl)]);\n+    Call(log_bcx, ccx.upcalls.log_type,\n+         [lltydesc, llval_i8, C_int(ccx, lvl)]);\n \n     log_bcx = trans_block_cleanups(log_bcx, log_cx);\n     Br(log_bcx, after_cx.llbb);\n@@ -4514,7 +4516,7 @@ fn trans_fail_value(bcx: @block_ctxt, sp_opt: option::t<span>,\n     }\n     let V_str = PointerCast(bcx, V_fail_str, T_ptr(T_i8()));\n     V_filename = PointerCast(bcx, V_filename, T_ptr(T_i8()));\n-    let args = [V_str, V_filename, C_int(V_line)];\n+    let args = [V_str, V_filename, C_int(ccx, V_line)];\n     let bcx = invoke(bcx, bcx_ccx(bcx).upcalls._fail, args);\n     Unreachable(bcx);\n     ret bcx;\n@@ -5518,16 +5520,16 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         fn main_name() -> str { ret \"main\"; }\n         #[cfg(target_os = \"linux\")]\n         fn main_name() -> str { ret \"main\"; }\n-        let llfty = T_fn([T_int(), T_int()], T_int());\n+        let llfty = T_fn([ccx.int_type, ccx.int_type], ccx.int_type);\n         let llfn = decl_cdecl_fn(ccx.llmod, main_name(), llfty);\n         let llbb = str::as_buf(\"top\", {|buf|\n             llvm::LLVMAppendBasicBlock(llfn, buf)\n         });\n         let bld = *ccx.builder;\n         llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n         let crate_map = ccx.crate_map;\n-        let start_ty = T_fn([val_ty(rust_main), T_int(), T_int(),\n-                             val_ty(crate_map)], T_int());\n+        let start_ty = T_fn([val_ty(rust_main), ccx.int_type, ccx.int_type,\n+                             val_ty(crate_map)], ccx.int_type);\n         let start = str::as_buf(\"rust_start\", {|buf|\n             llvm::LLVMAddGlobal(ccx.llmod, start_ty, buf)\n         });\n@@ -6018,10 +6020,11 @@ fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n     let elts: [ValueRef] = [];\n     ccx.module_data.items {|key, val|\n-        let elt = C_struct([p2i(C_cstr(ccx, key)), p2i(val)]);\n+        let elt = C_struct([p2i(ccx, C_cstr(ccx, key)),\n+                            p2i(ccx, val)]);\n         elts += [elt];\n     };\n-    let term = C_struct([C_int(0), C_int(0)]);\n+    let term = C_struct([C_int(ccx, 0), C_int(ccx, 0)]);\n     elts += [term];\n     llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n     ret map;\n@@ -6030,13 +6033,15 @@ fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n \n fn decl_crate_map(sess: session::session, mapname: str,\n                   llmod: ModuleRef) -> ValueRef {\n+    let targ_cfg = sess.get_targ_cfg();\n+    let int_type = T_int(targ_cfg);\n     let n_subcrates = 1;\n     let cstore = sess.get_cstore();\n     while cstore::have_crate_data(cstore, n_subcrates) { n_subcrates += 1; }\n     if !sess.get_opts().library { mapname = \"toplevel\"; }\n     let sym_name = \"_rust_crate_map_\" + mapname;\n-    let arrtype = T_array(T_int(), n_subcrates as uint);\n-    let maptype = T_struct([T_int(), arrtype]);\n+    let arrtype = T_array(int_type, n_subcrates as uint);\n+    let maptype = T_struct([int_type, arrtype]);\n     let map = str::as_buf(sym_name, {|buf|\n         llvm::LLVMAddGlobal(llmod, maptype, buf)\n     });\n@@ -6053,32 +6058,15 @@ fn fill_crate_map(ccx: @crate_ctxt, map: ValueRef) {\n     while cstore::have_crate_data(cstore, i) {\n         let nm = \"_rust_crate_map_\" + cstore::get_crate_data(cstore, i).name;\n         let cr = str::as_buf(nm, {|buf|\n-            llvm::LLVMAddGlobal(ccx.llmod, T_int(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n         });\n-        subcrates += [p2i(cr)];\n+        subcrates += [p2i(ccx, cr)];\n         i += 1;\n     }\n-    subcrates += [C_int(0)];\n-    llvm::LLVMSetInitializer(map, C_struct([p2i(create_module_map(ccx)),\n-                                            C_array(T_int(), subcrates)]));\n     subcrates += [C_int(ccx, 0)];\n-    let mapname;\n-    if ccx.sess.get_opts().library {\n-        mapname = ccx.link_meta.name;\n-    } else { mapname = \"toplevel\"; }\n-    let sym_name = \"_rust_crate_map_\" + mapname;\n-    let arrtype = T_array(ccx.int_type, std::vec::len::<ValueRef>(subcrates));\n-    let maptype = T_struct([ccx.int_type, arrtype]);\n-    let map =\n-        str::as_buf(sym_name,\n-                    {|buf| llvm::LLVMAddGlobal(ccx.llmod, maptype, buf) });\n-    llvm::LLVMSetLinkage(map,\n-                         lib::llvm::LLVMExternalLinkage as llvm::Linkage);\n-    llvm::LLVMSetInitializer(map,\n-                             C_struct([p2i(ccx, create_module_map(ccx)),\n-                                       C_array(ccx.int_type, subcrates)]));\n-    ret map;\n->>>>>>> work on making the size of ints depend on the target arch\n+    llvm::LLVMSetInitializer(map, C_struct(\n+        [p2i(ccx, create_module_map(ccx)),\n+         C_array(ccx.int_type, subcrates)]));\n }\n \n fn write_metadata(cx: @crate_ctxt, crate: @ast::crate) {\n@@ -6138,7 +6126,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     let task_type = T_task(targ_cfg);\n     let taskptr_type = T_ptr(task_type);\n     tn.associate(\"taskptr\", taskptr_type);\n-    let tydesc_type = T_tydesc(targ_cfg, taskptr_type);\n+    let tydesc_type = T_tydesc(targ_cfg);\n     tn.associate(\"tydesc\", tydesc_type);\n     let hasher = ty::hash_ty;\n     let eqer = ty::eq_ty;"}, {"sha": "c2f5fbedaa2239806f9a8f16482af2b899b59002", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "patch": "@@ -497,15 +497,15 @@ fn _UndefReturn(cx: @block_ctxt, Fn: ValueRef) -> ValueRef {\n }\n \n fn Call(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n-    if cx.unreachable { ret _UndefReturn(Fn); }\n+    if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n         ret llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n                                 vec::len(Args), noname());\n     }\n }\n \n fn FastCall(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n-    if cx.unreachable { ret _UndefReturn(Fn); }\n+    if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n                                     vec::len(Args), noname());\n@@ -516,7 +516,7 @@ fn FastCall(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n \n fn CallWithConv(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef], Conv: uint)\n    -> ValueRef {\n-    if cx.unreachable { ret _UndefReturn(Fn); }\n+    if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n                                     vec::len(Args), noname());"}, {"sha": "4a85d52e90d836247d4a2bc6f7fb01d224361b05", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "patch": "@@ -576,7 +576,7 @@ fn T_task(targ_cfg: @session::config) -> TypeRef {\n     ret t;\n }\n \n-fn T_tydesc_field(cx: @crate_ctxt, field: int) -> TypeRef {\n+fn T_tydesc_field(cx: @crate_ctxt, field: int) -> TypeRef unsafe {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n     let tydesc_elts: [TypeRef] ="}, {"sha": "b892342ee311f06f74c446ea1784b6cd0620b2ac", "filename": "src/rt/arch/i386/_context.S", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Frt%2Farch%2Fi386%2F_context.S", "raw_url": "https://github.com/rust-lang/rust/raw/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Frt%2Farch%2Fi386%2F_context.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Fi386%2F_context.S?ref=f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "patch": "@@ -20,19 +20,19 @@ The registers_t variable is in (%esp)\n swap_registers:\n     // save the old context\n     movl 4(%esp), %eax\n-\t//movl %eax, 0(%eax)\n-\tmovl %ebx, 4(%eax)\n-\t//movl %ecx, 8(%eax)\n-\t//movl %edx, 12(%eax)\n-\tmovl %ebp, 16(%eax)\n-\tmovl %esi, 20(%eax)\n-\tmovl %edi, 24(%eax)\n-\t//movl %cs, 32(%eax)\n-\t//movl %ds, 34(%eax)\n-\t//movl %ss, 36(%eax)\n-\t//movl %es, 38(%eax)\n-\t//movl %fs, 40(%eax)\n-\t//movl %gs, 42(%eax)\n+    //movl %eax, 0(%eax)\n+    movl %ebx, 4(%eax)\n+    //movl %ecx, 8(%eax)\n+    //movl %edx, 12(%eax)\n+    movl %ebp, 16(%eax)\n+    movl %esi, 20(%eax)\n+    movl %edi, 24(%eax)\n+    //movl %cs, 32(%eax)\n+    //movl %ds, 34(%eax)\n+    //movl %ss, 36(%eax)\n+    //movl %es, 38(%eax)\n+    //movl %fs, 40(%eax)\n+    //movl %gs, 42(%eax)\n \n         // save the flags\n         pushf\n@@ -48,20 +48,20 @@ swap_registers:\n     // restore the new context\n     movl 4(%esp), %eax\n \n-\tmovl 4(%eax), %ebx\n-\t// save ecx for later...\n-\t//movl 12(%eax), %edx\n-\tmovl 16(%eax), %ebp\n-\tmovl 20(%eax), %esi\n-\tmovl 24(%eax), %edi\n-\tmovl 28(%eax), %esp\n-\t// We can't actually change this...\n-\t//movl 32(%eax), %cs\n-\t//movl 34(%eax), %ds\n-\t//movl 36(%eax), %ss\n-\t//movl 38(%eax), %es\n-\t//movl 40(%eax), %fs\n-\t//movl 42(%eax), %gs\n+    movl 4(%eax), %ebx\n+    // save ecx for later...\n+    //movl 12(%eax), %edx\n+    movl 16(%eax), %ebp\n+    movl 20(%eax), %esi\n+    movl 24(%eax), %edi\n+    movl 28(%eax), %esp\n+    // We can't actually change this...\n+    //movl 32(%eax), %cs\n+    //movl 34(%eax), %ds\n+    //movl 36(%eax), %ss\n+    //movl 38(%eax), %es\n+    //movl 40(%eax), %fs\n+    //movl 42(%eax), %gs\n \n         // restore the flags\n         movl 44(%eax), %ecx\n@@ -70,7 +70,7 @@ swap_registers:\n \n     // ok, now we can restore ecx\n     //movl 8(%eax), %ecx\n-\t\n+\n     // Return!\n     jmp *48(%eax)\n "}, {"sha": "971314dba560752d65cd2c1d845e8519f6eec9ce", "filename": "src/rt/intrinsics/intrinsics.i386.ll.in", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in?ref=f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "patch": "@@ -53,7 +53,7 @@ target triple = \"@CFG_TARGET_TRIPLE@\"\n %struct.rust_vec = type { i32, i32, [0 x i8] }\n %\"struct.std::_Rb_tree<void *, std::pair<void *const, const type_desc *>, std::_Select1st<std::pair<void *const, const type_desc *> >, std::less<void *>, std::allocator<std::pair<void *const, const type_desc *> > >::_Rb_tree_impl\" = type { %struct.rust_cond, %\"struct.std::_Rb_tree_node_base\", i32 }\n %\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n-%struct.type_desc = type { %struct.type_desc**, i32, i32, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, i32, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*, i8*, i8)*, i8*, %struct.rust_shape_tables*, i32, i32, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n+%struct.type_desc = type { %struct.type_desc**, i32, i32, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i32, void (i8*, i8*, %struct.type_desc**, i8*, i8*, i8)*, i8*, %struct.rust_shape_tables*, i32, i32, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n \n @.str = private unnamed_addr constant [42 x i8] c\"attempt to cast values of differing sizes\\00\"\n @.str1 = private unnamed_addr constant [33 x i8] c\"src/rt/intrinsics/intrinsics.cpp\\00\"\n@@ -78,7 +78,7 @@ define void @rust_intrinsic_ptr_offset(%struct.rust_task* nocapture %task, i8**\n   ret void\n }\n \n-define void @rust_intrinsic_cast(%struct.rust_task* %task, i8* nocapture %retptr, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) {\n+define void @rust_intrinsic_cast(%struct.rust_task* nocapture %task, i8* nocapture %retptr, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) {\n   %1 = getelementptr inbounds %struct.type_desc* %t1, i32 0, i32 1\n   %2 = load i32* %1, align 4\n   %3 = getelementptr inbounds %struct.type_desc* %t2, i32 0, i32 1\n@@ -87,7 +87,7 @@ define void @rust_intrinsic_cast(%struct.rust_task* %task, i8* nocapture %retptr\n   br i1 %5, label %7, label %6\n \n ; <label>:6                                       ; preds = %0\n-  tail call void @upcall_fail(%struct.rust_task* %task, i8* getelementptr inbounds ([42 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8]* @.str1, i32 0, i32 0), i32 32)\n+  tail call void @upcall_fail(i8* getelementptr inbounds ([42 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8]* @.str1, i32 0, i32 0), i32 32)\n   br label %8\n \n ; <label>:7                                       ; preds = %0\n@@ -98,7 +98,7 @@ define void @rust_intrinsic_cast(%struct.rust_task* %task, i8* nocapture %retptr\n   ret void\n }\n \n-declare void @upcall_fail(%struct.rust_task*, i8*, i8*, i32)\n+declare void @upcall_fail(i8*, i8*, i32)\n \n declare void @llvm.memmove.p0i8.p0i8.i32(i8* nocapture, i8* nocapture, i32, i32, i1) nounwind\n \n@@ -107,11 +107,16 @@ define void @rust_intrinsic_addr_of(%struct.rust_task* nocapture %task, i8** noc\n   ret void\n }\n \n-define void @rust_intrinsic_recv(%struct.rust_task* %task, i8** %retptr, %struct.type_desc* nocapture %ty, %class.rust_port* %port) {\n-  %1 = bitcast %struct.rust_task* %task to i8*\n-  %2 = bitcast i8** %retptr to i32*\n-  tail call void @port_recv(i8* %1, i32* %2, %class.rust_port* %port)\n+define void @rust_intrinsic_recv(%struct.rust_task* nocapture %task, i8** %retptr, %struct.type_desc* nocapture %ty, %class.rust_port* %port) {\n+  %1 = bitcast i8** %retptr to i32*\n+  tail call void @port_recv(i32* %1, %class.rust_port* %port)\n   ret void\n }\n \n-declare void @port_recv(i8*, i32*, %class.rust_port*)\n+declare void @port_recv(i32*, %class.rust_port*)\n+\n+define void @rust_intrinsic_get_type_desc(%struct.rust_task* nocapture %task, i8** nocapture %retptr, %struct.type_desc* %ty) nounwind {\n+  %ty.c = bitcast %struct.type_desc* %ty to i8*\n+  store i8* %ty.c, i8** %retptr, align 4\n+  ret void\n+}"}, {"sha": "77c05e1e1e59d48151ab18b722ab2d4a7c5ca8d4", "filename": "src/rt/intrinsics/intrinsics.x86_64.ll.in", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in?ref=f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "patch": "@@ -53,7 +53,7 @@ target triple = \"@CFG_TARGET_TRIPLE@\"\n %\"struct.std::_Rb_tree<void *, std::pair<void *const, const type_desc *>, std::_Select1st<std::pair<void *const, const type_desc *> >, std::less<void *>, std::allocator<std::pair<void *const, const type_desc *> > >::_Rb_tree_impl\" = type { %struct.rust_cond, %\"struct.std::_Rb_tree_node_base\", i64 }\n %\"struct.std::_Rb_tree_node_base\" = type { i32, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"*, %\"struct.std::_Rb_tree_node_base\"* }\n %struct.stk_seg = type { i32, i64, [0 x i8] }\n-%struct.type_desc = type { %struct.type_desc**, i64, i64, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, i64, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*, i8*, i8)*, i8*, %struct.rust_shape_tables*, i64, i64, %struct.UT_hash_handle, i64, [0 x %struct.type_desc*] }\n+%struct.type_desc = type { %struct.type_desc**, i64, i64, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i8*, void (i8*, i8*, %struct.type_desc**, i8*)*, void (i8*, i8*, %struct.type_desc**, i8*)*, i64, void (i8*, i8*, %struct.type_desc**, i8*, i8*, i8)*, i8*, %struct.rust_shape_tables*, i64, i64, %struct.UT_hash_handle, i64, [0 x %struct.type_desc*] }\n \n @.str = private unnamed_addr constant [42 x i8] c\"attempt to cast values of differing sizes\\00\"\n @.str1 = private unnamed_addr constant [33 x i8] c\"src/rt/intrinsics/intrinsics.cpp\\00\"\n@@ -78,7 +78,7 @@ define void @rust_intrinsic_ptr_offset(%struct.rust_task* nocapture %task, i8**\n   ret void\n }\n \n-define void @rust_intrinsic_cast(%struct.rust_task* %task, i8* nocapture %retptr, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) {\n+define void @rust_intrinsic_cast(%struct.rust_task* nocapture %task, i8* nocapture %retptr, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) {\n   %1 = getelementptr inbounds %struct.type_desc* %t1, i64 0, i32 1\n   %2 = load i64* %1, align 8\n   %3 = getelementptr inbounds %struct.type_desc* %t2, i64 0, i32 1\n@@ -87,7 +87,7 @@ define void @rust_intrinsic_cast(%struct.rust_task* %task, i8* nocapture %retptr\n   br i1 %5, label %7, label %6\n \n ; <label>:6                                       ; preds = %0\n-  tail call void @upcall_fail(%struct.rust_task* %task, i8* getelementptr inbounds ([42 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([33 x i8]* @.str1, i64 0, i64 0), i64 32)\n+  tail call void @upcall_fail(i8* getelementptr inbounds ([42 x i8]* @.str, i64 0, i64 0), i8* getelementptr inbounds ([33 x i8]* @.str1, i64 0, i64 0), i64 32)\n   br label %8\n \n ; <label>:7                                       ; preds = %0\n@@ -98,7 +98,7 @@ define void @rust_intrinsic_cast(%struct.rust_task* %task, i8* nocapture %retptr\n   ret void\n }\n \n-declare void @upcall_fail(%struct.rust_task*, i8*, i8*, i64)\n+declare void @upcall_fail(i8*, i8*, i64)\n \n declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) nounwind\n \n@@ -107,11 +107,16 @@ define void @rust_intrinsic_addr_of(%struct.rust_task* nocapture %task, i8** noc\n   ret void\n }\n \n-define void @rust_intrinsic_recv(%struct.rust_task* %task, i8** %retptr, %struct.type_desc* nocapture %ty, %class.rust_port* %port) {\n-  %1 = bitcast %struct.rust_task* %task to i8*\n-  %2 = bitcast i8** %retptr to i64*\n-  tail call void @port_recv(i8* %1, i64* %2, %class.rust_port* %port)\n+define void @rust_intrinsic_recv(%struct.rust_task* nocapture %task, i8** %retptr, %struct.type_desc* nocapture %ty, %class.rust_port* %port) {\n+  %1 = bitcast i8** %retptr to i64*\n+  tail call void @port_recv(i64* %1, %class.rust_port* %port)\n   ret void\n }\n \n-declare void @port_recv(i8*, i64*, %class.rust_port*)\n+declare void @port_recv(i64*, %class.rust_port*)\n+\n+define void @rust_intrinsic_get_type_desc(%struct.rust_task* nocapture %task, i8** nocapture %retptr, %struct.type_desc* %ty) nounwind {\n+  %ty.c = bitcast %struct.type_desc* %ty to i8*\n+  store i8* %ty.c, i8** %retptr, align 8\n+  ret void\n+}"}, {"sha": "270b716679d329272d7c1f13132aa592a7b2174f", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=f1bc9307d82b7ff55ea6fa0eebec2999e5bd8f8a", "patch": "@@ -42,7 +42,7 @@ hash(uintptr_t ptr) {\n     ptr = ptr ^ (ptr >> 14);\n     ptr = (ptr + (ptr << 2)) + (ptr << 4); // ptr * 21\n     ptr = ptr ^ (ptr >> 28);\n-    ptr = ptr + (ptr << 31);    \n+    ptr = ptr + (ptr << 31);\n #   else\n #   error \"hash() not defined for this pointer size\"\n #   endif"}]}