{"sha": "6207ac90da7e607218457bf872fa32df6b78f224", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMDdhYzkwZGE3ZTYwNzIxODQ1N2JmODcyZmEzMmRmNmI3OGYyMjQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-03T19:11:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-03T19:11:40Z"}, "message": "Merge #3840\n\n3840: Add parens for enums r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "222a315a1522e1cd99589233674e259303b56395", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/222a315a1522e1cd99589233674e259303b56395"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6207ac90da7e607218457bf872fa32df6b78f224", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeh4psCRBK7hj4Ov3rIwAAdHIIAJiDJbR1lCNoROUkMfQKYgZK\nmMYGwAhsbjz5lgrX2zOiDCPPjbU52DM3+BCrjib6xJEZgkAgus98dlBNScTDE4r8\nDJ6y2EXXUaC+P4ZTlInM+Pi9sR4hpANiqcgHUyX9NxkIJ3xVG78KjDEmZ8anM/C6\nnTxSIzoWsqIAMmwF+IJZZMdHMAfRwp7i/olyDkJ6fm3EVSX7DdpJIVwN1c4Z3iqz\nkhBxW90VbFeVl3ts71fHYdF79OBeVf1FOPN57q3kWALCi7wBQbsze7c7YkVO+4DA\nVsAV5qPz70M1xw8GExZ0k7rgSoE9mN0CZx2yGDQAC+l9bh1uL0rI2EIfqeVozJY=\n=aBRR\n-----END PGP SIGNATURE-----\n", "payload": "tree 222a315a1522e1cd99589233674e259303b56395\nparent cde92d0fe1ad33706dc0804e3c39e4ef9a5e12b9\nparent a5e8dfd0247648d8108386f4f98b3af0e48181f7\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1585941100 +0000\ncommitter GitHub <noreply@github.com> 1585941100 +0000\n\nMerge #3840\n\n3840: Add parens for enums r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6207ac90da7e607218457bf872fa32df6b78f224", "html_url": "https://github.com/rust-lang/rust/commit/6207ac90da7e607218457bf872fa32df6b78f224", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6207ac90da7e607218457bf872fa32df6b78f224/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cde92d0fe1ad33706dc0804e3c39e4ef9a5e12b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cde92d0fe1ad33706dc0804e3c39e4ef9a5e12b9", "html_url": "https://github.com/rust-lang/rust/commit/cde92d0fe1ad33706dc0804e3c39e4ef9a5e12b9"}, {"sha": "a5e8dfd0247648d8108386f4f98b3af0e48181f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5e8dfd0247648d8108386f4f98b3af0e48181f7", "html_url": "https://github.com/rust-lang/rust/commit/a5e8dfd0247648d8108386f4f98b3af0e48181f7"}], "stats": {"total": 363, "additions": 236, "deletions": 127}, "files": [{"sha": "f433faef36a8ba4a663ee9a96efe0864b10c04bb", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6207ac90da7e607218457bf872fa32df6b78f224/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6207ac90da7e607218457bf872fa32df6b78f224/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=6207ac90da7e607218457bf872fa32df6b78f224", "patch": "@@ -61,7 +61,7 @@ fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: &T\n                 && ctx.scope().module().map_or(true, |m| func.is_visible_from(ctx.db, m))\n                 && seen_methods.insert(func.name(ctx.db))\n             {\n-                acc.add_function(ctx, func);\n+                acc.add_function(ctx, func, None);\n             }\n             None::<()>\n         });"}, {"sha": "3ed2ae2b632be5ed8d3873ae9c417dc4fc9cb15f", "filename": "crates/ra_ide/src/completion/complete_path.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6207ac90da7e607218457bf872fa32df6b78f224/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6207ac90da7e607218457bf872fa32df6b78f224/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=6207ac90da7e607218457bf872fa32df6b78f224", "patch": "@@ -38,7 +38,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n         hir::ModuleDef::Adt(_) | hir::ModuleDef::TypeAlias(_) => {\n             if let hir::ModuleDef::Adt(Adt::Enum(e)) = def {\n                 for variant in e.variants(ctx.db) {\n-                    acc.add_enum_variant(ctx, variant);\n+                    acc.add_enum_variant(ctx, variant, None);\n                 }\n             }\n             let ty = match def {\n@@ -58,7 +58,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                     match item {\n                         hir::AssocItem::Function(func) => {\n                             if !func.has_self_param(ctx.db) {\n-                                acc.add_function(ctx, func);\n+                                acc.add_function(ctx, func, None);\n                             }\n                         }\n                         hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n@@ -87,7 +87,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                 match item {\n                     hir::AssocItem::Function(func) => {\n                         if !func.has_self_param(ctx.db) {\n-                            acc.add_function(ctx, func);\n+                            acc.add_function(ctx, func, None);\n                         }\n                     }\n                     hir::AssocItem::Const(ct) => acc.add_const(ctx, ct),\n@@ -355,15 +355,17 @@ mod tests {\n             @r###\"\n         [\n             CompletionItem {\n-                label: \"Bar\",\n+                label: \"Bar(\u2026)\",\n                 source_range: [116; 116),\n                 delete: [116; 116),\n-                insert: \"Bar\",\n+                insert: \"Bar($0)\",\n                 kind: EnumVariant,\n+                lookup: \"Bar\",\n                 detail: \"(i32)\",\n                 documentation: Documentation(\n                     \"Bar Variant with i32\",\n                 ),\n+                trigger_call_info: true,\n             },\n             CompletionItem {\n                 label: \"Foo\",\n@@ -403,15 +405,17 @@ mod tests {\n             @r###\"\n         [\n             CompletionItem {\n-                label: \"Bar\",\n+                label: \"Bar(\u2026)\",\n                 source_range: [180; 180),\n                 delete: [180; 180),\n-                insert: \"Bar\",\n+                insert: \"Bar($0)\",\n                 kind: EnumVariant,\n+                lookup: \"Bar\",\n                 detail: \"(i32, u32)\",\n                 documentation: Documentation(\n                     \"Bar Variant with i32 and u32\",\n                 ),\n+                trigger_call_info: true,\n             },\n             CompletionItem {\n                 label: \"Foo\",\n@@ -425,15 +429,17 @@ mod tests {\n                 ),\n             },\n             CompletionItem {\n-                label: \"S\",\n+                label: \"S(\u2026)\",\n                 source_range: [180; 180),\n                 delete: [180; 180),\n-                insert: \"S\",\n+                insert: \"S($0)\",\n                 kind: EnumVariant,\n+                lookup: \"S\",\n                 detail: \"(S)\",\n                 documentation: Documentation(\n                     \"\",\n                 ),\n+                trigger_call_info: true,\n             },\n         ]\n         \"###"}, {"sha": "1b7d3122f8e718166f5d009793c9ee1aa7a9bdef", "filename": "crates/ra_ide/src/completion/complete_pattern.rs", "status": "modified", "additions": 13, "deletions": 45, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6207ac90da7e607218457bf872fa32df6b78f224/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6207ac90da7e607218457bf872fa32df6b78f224/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs?ref=6207ac90da7e607218457bf872fa32df6b78f224", "patch": "@@ -4,23 +4,25 @@ use crate::completion::{CompletionContext, Completions};\n \n /// Completes constats and paths in patterns.\n pub(super) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_pat_binding {\n+    if !ctx.is_pat_binding_or_const {\n         return;\n     }\n     // FIXME: ideally, we should look at the type we are matching against and\n     // suggest variants + auto-imports\n     ctx.scope().process_all_names(&mut |name, res| {\n-        let def = match &res {\n-            hir::ScopeDef::ModuleDef(def) => def,\n+        match &res {\n+            hir::ScopeDef::ModuleDef(def) => match def {\n+                hir::ModuleDef::Adt(hir::Adt::Enum(..))\n+                | hir::ModuleDef::Adt(hir::Adt::Struct(..))\n+                | hir::ModuleDef::EnumVariant(..)\n+                | hir::ModuleDef::Const(..)\n+                | hir::ModuleDef::Module(..) => (),\n+                _ => return,\n+            },\n+            hir::ScopeDef::MacroDef(_) => (),\n             _ => return,\n         };\n-        match def {\n-            hir::ModuleDef::Adt(hir::Adt::Enum(..))\n-            | hir::ModuleDef::EnumVariant(..)\n-            | hir::ModuleDef::Const(..)\n-            | hir::ModuleDef::Module(..) => (),\n-            _ => return,\n-        }\n+\n         acc.add_resolution(ctx, name.to_string(), &res)\n     });\n }\n@@ -69,33 +71,13 @@ mod tests {\n                 insert: \"E\",\n                 kind: Enum,\n             },\n-            CompletionItem {\n-                label: \"E\",\n-                source_range: [246; 246),\n-                delete: [246; 246),\n-                insert: \"E\",\n-                kind: Enum,\n-            },\n             CompletionItem {\n                 label: \"X\",\n                 source_range: [246; 246),\n                 delete: [246; 246),\n                 insert: \"X\",\n                 kind: EnumVariant,\n-            },\n-            CompletionItem {\n-                label: \"X\",\n-                source_range: [246; 246),\n-                delete: [246; 246),\n-                insert: \"X\",\n-                kind: EnumVariant,\n-            },\n-            CompletionItem {\n-                label: \"Z\",\n-                source_range: [246; 246),\n-                delete: [246; 246),\n-                insert: \"Z\",\n-                kind: Const,\n+                detail: \"()\",\n             },\n             CompletionItem {\n                 label: \"Z\",\n@@ -111,13 +93,6 @@ mod tests {\n                 insert: \"m\",\n                 kind: Module,\n             },\n-            CompletionItem {\n-                label: \"m\",\n-                source_range: [246; 246),\n-                delete: [246; 246),\n-                insert: \"m\",\n-                kind: Module,\n-            },\n         ]\n         \"###);\n     }\n@@ -138,13 +113,6 @@ mod tests {\n         );\n         assert_debug_snapshot!(completions, @r###\"\n         [\n-            CompletionItem {\n-                label: \"E\",\n-                source_range: [151; 151),\n-                delete: [151; 151),\n-                insert: \"E\",\n-                kind: Enum,\n-            },\n             CompletionItem {\n                 label: \"E\",\n                 source_range: [151; 151),"}, {"sha": "665597e4cbd5f7ad51f673da9856c695246ff062", "filename": "crates/ra_ide/src/completion/complete_scope.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6207ac90da7e607218457bf872fa32df6b78f224/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6207ac90da7e607218457bf872fa32df6b78f224/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=6207ac90da7e607218457bf872fa32df6b78f224", "patch": "@@ -1,19 +1,13 @@\n //! Completion of names from the current scope, e.g. locals and imported items.\n \n use crate::completion::{CompletionContext, Completions};\n-use hir::{ModuleDef, ScopeDef};\n \n pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_trivial_path && !ctx.is_pat_binding_and_path {\n+    if !(ctx.is_trivial_path && !ctx.is_pat_binding_or_const) {\n         return;\n     }\n \n-    ctx.scope().process_all_names(&mut |name, res| match (ctx.is_pat_binding_and_path, &res) {\n-        (true, ScopeDef::ModuleDef(ModuleDef::Function(..))) => (),\n-        (true, ScopeDef::ModuleDef(ModuleDef::Static(..))) => (),\n-        (true, ScopeDef::Local(..)) => (),\n-        _ => acc.add_resolution(ctx, name.to_string(), &res),\n-    });\n+    ctx.scope().process_all_names(&mut |name, res| acc.add_resolution(ctx, name.to_string(), &res));\n }\n \n #[cfg(test)]"}, {"sha": "b8213d62f5d25a73d6bae6344ac70abe3c1e616e", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6207ac90da7e607218457bf872fa32df6b78f224/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6207ac90da7e607218457bf872fa32df6b78f224/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=6207ac90da7e607218457bf872fa32df6b78f224", "patch": "@@ -35,10 +35,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_param: bool,\n     /// If a name-binding or reference to a const in a pattern.\n     /// Irrefutable patterns (like let) are excluded.\n-    pub(super) is_pat_binding: bool,\n-    // A bind battern which may also be part of a path.\n-    // if let Some(En<|>) = Some(Enum::A)\n-    pub(super) is_pat_binding_and_path: bool,\n+    pub(super) is_pat_binding_or_const: bool,\n     /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n     pub(super) is_trivial_path: bool,\n     /// If not a trivial path, the prefix (qualifier).\n@@ -97,8 +94,7 @@ impl<'a> CompletionContext<'a> {\n             record_lit_pat: None,\n             impl_def: None,\n             is_param: false,\n-            is_pat_binding: false,\n-            is_pat_binding_and_path: false,\n+            is_pat_binding_or_const: false,\n             is_trivial_path: false,\n             path_prefix: None,\n             after_if: false,\n@@ -190,18 +186,19 @@ impl<'a> CompletionContext<'a> {\n         // suggest declaration names, see `CompletionKind::Magic`.\n         if let Some(name) = find_node_at_offset::<ast::Name>(&file_with_fake_ident, offset) {\n             if let Some(bind_pat) = name.syntax().ancestors().find_map(ast::BindPat::cast) {\n-                let parent = bind_pat.syntax().parent();\n-                if parent.clone().and_then(ast::MatchArm::cast).is_some()\n-                    || parent.clone().and_then(ast::Condition::cast).is_some()\n-                {\n-                    self.is_pat_binding = true;\n+                self.is_pat_binding_or_const = true;\n+                if bind_pat.has_at() || bind_pat.is_ref() || bind_pat.is_mutable() {\n+                    self.is_pat_binding_or_const = false;\n                 }\n-\n-                if parent.and_then(ast::RecordFieldPatList::cast).is_none()\n-                    && bind_pat.pat().is_none()\n-                    && !bind_pat.is_ref()\n-                {\n-                    self.is_pat_binding_and_path = true;\n+                if bind_pat.syntax().parent().and_then(ast::RecordFieldPatList::cast).is_some() {\n+                    self.is_pat_binding_or_const = false;\n+                }\n+                if let Some(let_stmt) = bind_pat.syntax().ancestors().find_map(ast::LetStmt::cast) {\n+                    if let Some(pat) = let_stmt.pat() {\n+                        if bind_pat.syntax().text_range().is_subrange(&pat.syntax().text_range()) {\n+                            self.is_pat_binding_or_const = false;\n+                        }\n+                    }\n                 }\n             }\n             if is_node::<ast::Param>(name.syntax()) {"}, {"sha": "cdfd7bc3243764dda5a17f4c1bad7a533823bb9c", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 188, "deletions": 47, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/6207ac90da7e607218457bf872fa32df6b78f224/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6207ac90da7e607218457bf872fa32df6b78f224/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=6207ac90da7e607218457bf872fa32df6b78f224", "patch": "@@ -7,7 +7,8 @@ use test_utils::tested_by;\n \n use crate::{\n     completion::{\n-        CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions,\n+        completion_item::Builder, CompletionContext, CompletionItem, CompletionItemKind,\n+        CompletionKind, Completions,\n     },\n     display::{const_label, macro_label, type_label, FunctionSignature},\n     RootDatabase,\n@@ -56,14 +57,16 @@ impl Completions {\n         let kind = match resolution {\n             ScopeDef::ModuleDef(Module(..)) => CompletionItemKind::Module,\n             ScopeDef::ModuleDef(Function(func)) => {\n-                return self.add_function_with_name(ctx, Some(local_name), *func);\n+                return self.add_function(ctx, *func, Some(local_name));\n             }\n             ScopeDef::ModuleDef(Adt(hir::Adt::Struct(_))) => CompletionItemKind::Struct,\n             // FIXME: add CompletionItemKind::Union\n             ScopeDef::ModuleDef(Adt(hir::Adt::Union(_))) => CompletionItemKind::Struct,\n             ScopeDef::ModuleDef(Adt(hir::Adt::Enum(_))) => CompletionItemKind::Enum,\n \n-            ScopeDef::ModuleDef(EnumVariant(..)) => CompletionItemKind::EnumVariant,\n+            ScopeDef::ModuleDef(EnumVariant(var)) => {\n+                return self.add_enum_variant(ctx, *var, Some(local_name));\n+            }\n             ScopeDef::ModuleDef(Const(..)) => CompletionItemKind::Const,\n             ScopeDef::ModuleDef(Static(..)) => CompletionItemKind::Static,\n             ScopeDef::ModuleDef(Trait(..)) => CompletionItemKind::Trait,\n@@ -124,10 +127,6 @@ impl Completions {\n         completion_item.kind(kind).set_documentation(docs).add_to(self)\n     }\n \n-    pub(crate) fn add_function(&mut self, ctx: &CompletionContext, func: hir::Function) {\n-        self.add_function_with_name(ctx, None, func)\n-    }\n-\n     fn guess_macro_braces(&self, macro_name: &str, docs: &str) -> &'static str {\n         let mut votes = [0, 0, 0];\n         for (idx, s) in docs.match_indices(&macro_name) {\n@@ -186,16 +185,15 @@ impl Completions {\n         self.add(builder);\n     }\n \n-    fn add_function_with_name(\n+    pub(crate) fn add_function(\n         &mut self,\n         ctx: &CompletionContext,\n-        name: Option<String>,\n         func: hir::Function,\n+        local_name: Option<String>,\n     ) {\n         let has_self_param = func.has_self_param(ctx.db);\n-        let params = func.params(ctx.db);\n \n-        let name = name.unwrap_or_else(|| func.name(ctx.db).to_string());\n+        let name = local_name.unwrap_or_else(|| func.name(ctx.db).to_string());\n         let ast_node = func.source(ctx.db).value;\n         let function_signature = FunctionSignature::from(&ast_node);\n \n@@ -210,32 +208,14 @@ impl Completions {\n                 .set_deprecated(is_deprecated(func, ctx.db))\n                 .detail(function_signature.to_string());\n \n-        // If not an import, add parenthesis automatically.\n-        if ctx.use_item_syntax.is_none() && !ctx.is_call && ctx.config.add_call_parenthesis {\n-            tested_by!(inserts_parens_for_function_calls);\n-\n-            let (snippet, label) = if params.is_empty() || has_self_param && params.len() == 1 {\n-                (format!(\"{}()$0\", name), format!(\"{}()\", name))\n-            } else {\n-                builder = builder.trigger_call_info();\n-                let snippet = if ctx.config.add_call_argument_snippets {\n-                    let to_skip = if has_self_param { 1 } else { 0 };\n-                    let function_params_snippet = function_signature\n-                        .parameter_names\n-                        .iter()\n-                        .skip(to_skip)\n-                        .enumerate()\n-                        .map(|(index, param_name)| format!(\"${{{}:{}}}\", index + 1, param_name))\n-                        .sep_by(\", \");\n-                    format!(\"{}({})$0\", name, function_params_snippet)\n-                } else {\n-                    format!(\"{}($0)\", name)\n-                };\n+        let params = function_signature\n+            .parameter_names\n+            .iter()\n+            .skip(if function_signature.has_self_param { 1 } else { 0 })\n+            .cloned()\n+            .collect();\n \n-                (snippet, format!(\"{}(\u2026)\", name))\n-            };\n-            builder = builder.lookup_by(name).label(label).insert_snippet(snippet);\n-        }\n+        builder = builder.add_call_parens(ctx, name, Params::Named(params));\n \n         self.add(builder)\n     }\n@@ -272,14 +252,20 @@ impl Completions {\n             .add_to(self);\n     }\n \n-    pub(crate) fn add_enum_variant(&mut self, ctx: &CompletionContext, variant: hir::EnumVariant) {\n+    pub(crate) fn add_enum_variant(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        variant: hir::EnumVariant,\n+        local_name: Option<String>,\n+    ) {\n         let is_deprecated = is_deprecated(variant, ctx.db);\n-        let name = variant.name(ctx.db);\n+        let name = local_name.unwrap_or_else(|| variant.name(ctx.db).to_string());\n         let detail_types = variant\n             .fields(ctx.db)\n             .into_iter()\n             .map(|field| (field.name(ctx.db), field.signature_ty(ctx.db)));\n-        let detail = match variant.kind(ctx.db) {\n+        let variant_kind = variant.kind(ctx.db);\n+        let detail = match variant_kind {\n             StructKind::Tuple | StructKind::Unit => detail_types\n                 .map(|(_, t)| t.display(ctx.db).to_string())\n                 .sep_by(\", \")\n@@ -291,12 +277,70 @@ impl Completions {\n                 .surround_with(\"{ \", \" }\")\n                 .to_string(),\n         };\n-        CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.to_string())\n-            .kind(CompletionItemKind::EnumVariant)\n-            .set_documentation(variant.docs(ctx.db))\n-            .set_deprecated(is_deprecated)\n-            .detail(detail)\n-            .add_to(self);\n+        let mut res =\n+            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.clone())\n+                .kind(CompletionItemKind::EnumVariant)\n+                .set_documentation(variant.docs(ctx.db))\n+                .set_deprecated(is_deprecated)\n+                .detail(detail);\n+\n+        if variant_kind == StructKind::Tuple {\n+            let params = Params::Anonymous(variant.fields(ctx.db).len());\n+            res = res.add_call_parens(ctx, name, params)\n+        }\n+\n+        res.add_to(self);\n+    }\n+}\n+\n+enum Params {\n+    Named(Vec<String>),\n+    Anonymous(usize),\n+}\n+\n+impl Params {\n+    fn len(&self) -> usize {\n+        match self {\n+            Params::Named(xs) => xs.len(),\n+            Params::Anonymous(len) => *len,\n+        }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+}\n+\n+impl Builder {\n+    fn add_call_parens(mut self, ctx: &CompletionContext, name: String, params: Params) -> Builder {\n+        if !ctx.config.add_call_parenthesis {\n+            return self;\n+        }\n+        if ctx.use_item_syntax.is_some() || ctx.is_call {\n+            return self;\n+        }\n+        // If not an import, add parenthesis automatically.\n+        tested_by!(inserts_parens_for_function_calls);\n+\n+        let (snippet, label) = if params.is_empty() {\n+            (format!(\"{}()$0\", name), format!(\"{}()\", name))\n+        } else {\n+            self = self.trigger_call_info();\n+            let snippet = match (ctx.config.add_call_argument_snippets, params) {\n+                (true, Params::Named(params)) => {\n+                    let function_params_snippet = params\n+                        .iter()\n+                        .enumerate()\n+                        .map(|(index, param_name)| format!(\"${{{}:{}}}\", index + 1, param_name))\n+                        .sep_by(\", \");\n+                    format!(\"{}({})$0\", name, function_params_snippet)\n+                }\n+                _ => format!(\"{}($0)\", name),\n+            };\n+\n+            (snippet, format!(\"{}(\u2026)\", name))\n+        };\n+        self.lookup_by(name).label(label).insert_snippet(snippet)\n     }\n }\n \n@@ -366,12 +410,14 @@ mod tests {\n         @r###\"\n         [\n             CompletionItem {\n-                label: \"Foo\",\n+                label: \"Foo(\u2026)\",\n                 source_range: [115; 117),\n                 delete: [115; 117),\n-                insert: \"Foo\",\n+                insert: \"Foo($0)\",\n                 kind: EnumVariant,\n+                lookup: \"Foo\",\n                 detail: \"(i32, i32)\",\n+                trigger_call_info: true,\n             },\n         ]\"###\n         );\n@@ -545,6 +591,101 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn inserts_parens_for_tuple_enums() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                enum Option<T> { Some(T), None }\n+                use Option::*;\n+                fn main() -> Option<i32> {\n+                    Som<|>\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"None\",\n+                source_range: [144; 147),\n+                delete: [144; 147),\n+                insert: \"None\",\n+                kind: EnumVariant,\n+                detail: \"()\",\n+            },\n+            CompletionItem {\n+                label: \"Option\",\n+                source_range: [144; 147),\n+                delete: [144; 147),\n+                insert: \"Option\",\n+                kind: Enum,\n+            },\n+            CompletionItem {\n+                label: \"Some(\u2026)\",\n+                source_range: [144; 147),\n+                delete: [144; 147),\n+                insert: \"Some($0)\",\n+                kind: EnumVariant,\n+                lookup: \"Some\",\n+                detail: \"(T)\",\n+                trigger_call_info: true,\n+            },\n+            CompletionItem {\n+                label: \"main()\",\n+                source_range: [144; 147),\n+                delete: [144; 147),\n+                insert: \"main()$0\",\n+                kind: Function,\n+                lookup: \"main\",\n+                detail: \"fn main() -> Option<i32>\",\n+            },\n+        ]\n+        \"###\n+        );\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                enum Option<T> { Some(T), None }\n+                use Option::*;\n+                fn main(value: Option<i32>) {\n+                    match value {\n+                        Som<|>\n+                    }\n+                }\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"None\",\n+                source_range: [185; 188),\n+                delete: [185; 188),\n+                insert: \"None\",\n+                kind: EnumVariant,\n+                detail: \"()\",\n+            },\n+            CompletionItem {\n+                label: \"Option\",\n+                source_range: [185; 188),\n+                delete: [185; 188),\n+                insert: \"Option\",\n+                kind: Enum,\n+            },\n+            CompletionItem {\n+                label: \"Some(\u2026)\",\n+                source_range: [185; 188),\n+                delete: [185; 188),\n+                insert: \"Some($0)\",\n+                kind: EnumVariant,\n+                lookup: \"Some\",\n+                detail: \"(T)\",\n+                trigger_call_info: true,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn arg_snippets_for_method_call() {\n         assert_debug_snapshot!("}, {"sha": "bf7d137be7de9833da3e8918c3c4dfa28423738f", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6207ac90da7e607218457bf872fa32df6b78f224/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6207ac90da7e607218457bf872fa32df6b78f224/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=6207ac90da7e607218457bf872fa32df6b78f224", "patch": "@@ -325,6 +325,9 @@ impl ast::BindPat {\n     pub fn is_ref(&self) -> bool {\n         self.syntax().children_with_tokens().any(|n| n.kind() == T![ref])\n     }\n+    pub fn has_at(&self) -> bool {\n+        self.syntax().children_with_tokens().any(|it| it.kind() == T![@])\n+    }\n }\n \n pub struct SlicePatComponents {"}]}