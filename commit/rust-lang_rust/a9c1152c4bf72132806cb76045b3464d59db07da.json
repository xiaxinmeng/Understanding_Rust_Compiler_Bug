{"sha": "a9c1152c4bf72132806cb76045b3464d59db07da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YzExNTJjNGJmNzIxMzI4MDZjYjc2MDQ1YjM0NjRkNTlkYjA3ZGE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-14T22:20:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-11-24T07:37:16Z"}, "message": "std: Add a new top-level thread_local module\n\nThis commit removes the `std::local_data` module in favor of a new\n`std::thread_local` module providing thread local storage. The module provides\ntwo variants of TLS: one which owns its contents and one which is based on\nscoped references. Each implementation has pros and cons listed in the\ndocumentation.\n\nBoth flavors have accessors through a function called `with` which yield a\nreference to a closure provided. Both flavors also panic if a reference cannot\nbe yielded and provide a function to test whether an access would panic or not.\nThis is an implementation of [RFC 461][rfc] and full details can be found in\nthat RFC.\n\nThis is a breaking change due to the removal of the `std::local_data` module.\nAll users can migrate to the new thread local system like so:\n\n    thread_local!(static FOO: Rc<RefCell<Option<T>>> = Rc::new(RefCell::new(None)))\n\nThe old `local_data` module inherently contained the `Rc<RefCell<Option<T>>>` as\nan implementation detail which must now be explicitly stated by users.\n\n[rfc]: https://github.com/rust-lang/rfcs/pull/461\n[breaking-change]", "tree": {"sha": "89ba92d5f5788e3323b75ca003bf74661a94e4de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89ba92d5f5788e3323b75ca003bf74661a94e4de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9c1152c4bf72132806cb76045b3464d59db07da", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9c1152c4bf72132806cb76045b3464d59db07da", "html_url": "https://github.com/rust-lang/rust/commit/a9c1152c4bf72132806cb76045b3464d59db07da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9c1152c4bf72132806cb76045b3464d59db07da/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "html_url": "https://github.com/rust-lang/rust/commit/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c"}], "stats": {"total": 2959, "additions": 1809, "deletions": 1150}, "files": [{"sha": "dab033e09729e41d317d95836dac31178069f987", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -171,7 +171,7 @@\n \n extern crate regex;\n \n-use regex::Regex;\n+use std::cell::RefCell;\n use std::fmt;\n use std::io::LineBufferedWriter;\n use std::io;\n@@ -181,6 +181,8 @@ use std::rt;\n use std::slice;\n use std::sync::{Once, ONCE_INIT};\n \n+use regex::Regex;\n+\n use directive::LOG_LEVEL_NAMES;\n \n pub mod macros;\n@@ -213,7 +215,9 @@ pub const WARN: u32 = 2;\n /// Error log level\n pub const ERROR: u32 = 1;\n \n-local_data_key!(local_logger: Box<Logger + Send>)\n+thread_local!(static LOCAL_LOGGER: RefCell<Option<Box<Logger + Send>>> = {\n+    RefCell::new(None)\n+})\n \n /// A trait used to represent an interface to a task-local logger. Each task\n /// can have its own custom logger which can respond to logging messages\n@@ -283,7 +287,9 @@ pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n     // Completely remove the local logger from TLS in case anyone attempts to\n     // frob the slot while we're doing the logging. This will destroy any logger\n     // set during logging.\n-    let mut logger = local_logger.replace(None).unwrap_or_else(|| {\n+    let mut logger = LOCAL_LOGGER.with(|s| {\n+        s.borrow_mut().take()\n+    }).unwrap_or_else(|| {\n         box DefaultLogger { handle: io::stderr() } as Box<Logger + Send>\n     });\n     logger.log(&LogRecord {\n@@ -293,7 +299,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n         module_path: loc.module_path,\n         line: loc.line,\n     });\n-    local_logger.replace(Some(logger));\n+    set_logger(logger);\n }\n \n /// Getter for the global log level. This is a function so that it can be called\n@@ -305,7 +311,10 @@ pub fn log_level() -> u32 { unsafe { LOG_LEVEL } }\n /// Replaces the task-local logger with the specified logger, returning the old\n /// logger.\n pub fn set_logger(logger: Box<Logger + Send>) -> Option<Box<Logger + Send>> {\n-    local_logger.replace(Some(logger))\n+    let mut l = Some(logger);\n+    LOCAL_LOGGER.with(|slot| {\n+        mem::replace(&mut *slot.borrow_mut(), l.take())\n+    })\n }\n \n /// A LogRecord is created by the logging macros, and passed as the only"}, {"sha": "7973004d5151997163e4b710b9abc4e57bac2633", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(non_camel_case_types)]\n \n-use std::cell::RefCell;\n+use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n use std::fmt::Show;\n use std::hash::{Hash, Hasher};\n@@ -26,11 +26,14 @@ use syntax::visit::Visitor;\n pub struct ErrorReported;\n \n pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n-    local_data_key!(depth: uint);\n+    thread_local!(static DEPTH: Cell<uint> = Cell::new(0));\n     if !do_it { return f(u); }\n \n-    let old = depth.get().map(|d| *d).unwrap_or(0);\n-    depth.replace(Some(old + 1));\n+    let old = DEPTH.with(|slot| {\n+        let r = slot.get();\n+        slot.set(r + 1);\n+        r\n+    });\n \n     let mut u = Some(u);\n     let mut rv = None;\n@@ -41,7 +44,7 @@ pub fn time<T, U>(do_it: bool, what: &str, u: U, f: |U| -> T) -> T {\n \n     println!(\"{}time: {}.{:03} \\t{}\", \"  \".repeat(old),\n              dur.num_seconds(), dur.num_milliseconds() % 1000, what);\n-    depth.replace(Some(old));\n+    DEPTH.with(|slot| slot.set(old));\n \n     rv\n }"}, {"sha": "bdf2eca21d6eca514103f0880b5bdacfbe5edb11", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -100,17 +100,20 @@ use syntax::visit::Visitor;\n use syntax::visit;\n use syntax::{ast, ast_util, ast_map};\n \n-local_data_key!(task_local_insn_key: RefCell<Vec<&'static str>>)\n+thread_local!(static TASK_LOCAL_INSN_KEY: RefCell<Option<Vec<&'static str>>> = {\n+    RefCell::new(None)\n+})\n \n pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n-    match task_local_insn_key.get() {\n-        Some(ctx) => blk(ctx.borrow().as_slice()),\n-        None => ()\n-    }\n+    TASK_LOCAL_INSN_KEY.with(|slot| {\n+        slot.borrow().as_ref().map(|s| blk(s.as_slice()));\n+    })\n }\n \n pub fn init_insn_ctxt() {\n-    task_local_insn_key.replace(Some(RefCell::new(Vec::new())));\n+    TASK_LOCAL_INSN_KEY.with(|slot| {\n+        *slot.borrow_mut() = Some(Vec::new());\n+    });\n }\n \n pub struct _InsnCtxt {\n@@ -120,19 +123,23 @@ pub struct _InsnCtxt {\n #[unsafe_destructor]\n impl Drop for _InsnCtxt {\n     fn drop(&mut self) {\n-        match task_local_insn_key.get() {\n-            Some(ctx) => { ctx.borrow_mut().pop(); }\n-            None => {}\n-        }\n+        TASK_LOCAL_INSN_KEY.with(|slot| {\n+            match slot.borrow_mut().as_mut() {\n+                Some(ctx) => { ctx.pop(); }\n+                None => {}\n+            }\n+        })\n     }\n }\n \n pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     debug!(\"new InsnCtxt: {}\", s);\n-    match task_local_insn_key.get() {\n-        Some(ctx) => ctx.borrow_mut().push(s),\n-        None => {}\n-    }\n+    TASK_LOCAL_INSN_KEY.with(|slot| {\n+        match slot.borrow_mut().as_mut() {\n+            Some(ctx) => ctx.push(s),\n+            None => {}\n+        }\n+    });\n     _InsnCtxt { _cannot_construct_outside_of_this_module: () }\n }\n "}, {"sha": "2b521d1da06b3f17c1723beed56fd2f7a93e30d2", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -26,7 +26,7 @@ use stability_summary::ModuleSummary;\n use html::item_type;\n use html::item_type::ItemType;\n use html::render;\n-use html::render::{cache_key, current_location_key};\n+use html::render::{cache, CURRENT_LOCATION_KEY};\n \n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n@@ -236,9 +236,9 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         generics.push_str(\"&gt;\");\n     }\n \n-    let loc = current_location_key.get().unwrap();\n-    let cache = cache_key.get().unwrap();\n-    let abs_root = root(&**cache, loc.as_slice());\n+    let loc = CURRENT_LOCATION_KEY.with(|l| l.borrow().clone());\n+    let cache = cache();\n+    let abs_root = root(&*cache, loc.as_slice());\n     let rel_root = match path.segments[0].name.as_slice() {\n         \"self\" => Some(\"./\".to_string()),\n         _ => None,\n@@ -271,7 +271,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         }\n     }\n \n-    match info(&**cache) {\n+    match info(&*cache) {\n         // This is a documented path, link to it!\n         Some((ref fqp, shortty)) if abs_root.is_some() => {\n             let mut url = String::from_str(abs_root.unwrap().as_slice());\n@@ -308,12 +308,12 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n fn primitive_link(f: &mut fmt::Formatter,\n                   prim: clean::PrimitiveType,\n                   name: &str) -> fmt::Result {\n-    let m = cache_key.get().unwrap();\n+    let m = cache();\n     let mut needs_termination = false;\n     match m.primitive_locations.get(&prim) {\n         Some(&ast::LOCAL_CRATE) => {\n-            let loc = current_location_key.get().unwrap();\n-            let len = if loc.len() == 0 {0} else {loc.len() - 1};\n+            let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n+            let len = if len == 0 {0} else {len - 1};\n             try!(write!(f, \"<a href='{}primitive.{}.html'>\",\n                         \"../\".repeat(len),\n                         prim.to_url_str()));\n@@ -327,8 +327,8 @@ fn primitive_link(f: &mut fmt::Formatter,\n             let loc = match m.extern_locations[cnum] {\n                 render::Remote(ref s) => Some(s.to_string()),\n                 render::Local => {\n-                    let loc = current_location_key.get().unwrap();\n-                    Some(\"../\".repeat(loc.len()))\n+                    let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n+                    Some(\"../\".repeat(len))\n                 }\n                 render::Unknown => None,\n             };\n@@ -371,12 +371,10 @@ impl fmt::Show for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::TyParamBinder(id) => {\n-                let m = cache_key.get().unwrap();\n-                f.write(m.typarams[ast_util::local_def(id)].as_bytes())\n+                f.write(cache().typarams[ast_util::local_def(id)].as_bytes())\n             }\n             clean::Generic(did) => {\n-                let m = cache_key.get().unwrap();\n-                f.write(m.typarams[did].as_bytes())\n+                f.write(cache().typarams[did].as_bytes())\n             }\n             clean::ResolvedPath{ did, ref typarams, ref path } => {\n                 try!(resolved_path(f, did, path, false));"}, {"sha": "11dc8f4f6603701d664d9fd0629f514f83a385b1", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -147,10 +147,14 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     }\n }\n \n-local_data_key!(used_header_map: RefCell<HashMap<String, uint>>)\n-local_data_key!(test_idx: Cell<uint>)\n-// None == render an example, but there's no crate name\n-local_data_key!(pub playground_krate: Option<String>)\n+thread_local!(static USED_HEADER_MAP: RefCell<HashMap<String, uint>> = {\n+    RefCell::new(HashMap::new())\n+})\n+thread_local!(static TEST_IDX: Cell<uint> = Cell::new(0))\n+\n+thread_local!(pub static PLAYGROUND_KRATE: RefCell<Option<Option<String>>> = {\n+    RefCell::new(None)\n+})\n \n pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n     extern fn block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,\n@@ -183,12 +187,15 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                 stripped_filtered_line(*l).is_none()\n             });\n             let text = lines.collect::<Vec<&str>>().connect(\"\\n\");\n-            if !rendered {\n+            if rendered { return }\n+            PLAYGROUND_KRATE.with(|krate| {\n                 let mut s = String::new();\n-                let id = playground_krate.get().map(|krate| {\n-                    let idx = test_idx.get().unwrap();\n-                    let i = idx.get();\n-                    idx.set(i + 1);\n+                let id = krate.borrow().as_ref().map(|krate| {\n+                    let idx = TEST_IDX.with(|slot| {\n+                        let i = slot.get();\n+                        slot.set(i + 1);\n+                        i\n+                    });\n \n                     let test = origtext.lines().map(|l| {\n                         stripped_filtered_line(l).unwrap_or(l)\n@@ -197,15 +204,15 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                     let test = test::maketest(test.as_slice(), krate, false, false);\n                     s.push_str(format!(\"<span id='rust-example-raw-{}' \\\n                                          class='rusttest'>{}</span>\",\n-                                       i, Escape(test.as_slice())).as_slice());\n-                    format!(\"rust-example-rendered-{}\", i)\n+                                       idx, Escape(test.as_slice())).as_slice());\n+                    format!(\"rust-example-rendered-{}\", idx)\n                 });\n                 let id = id.as_ref().map(|a| a.as_slice());\n                 s.push_str(highlight::highlight(text.as_slice(), None, id)\n                                      .as_slice());\n                 let output = s.to_c_str();\n                 hoedown_buffer_puts(ob, output.as_ptr());\n-            }\n+            })\n         }\n     }\n \n@@ -229,18 +236,20 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n \n         // This is a terrible hack working around how hoedown gives us rendered\n         // html for text rather than the raw text.\n-        let id = id.replace(\"<code>\", \"\").replace(\"</code>\", \"\").to_string();\n \n         let opaque = opaque as *mut hoedown_html_renderer_state;\n         let opaque = unsafe { &mut *((*opaque).opaque as *mut MyOpaque) };\n \n         // Make sure our hyphenated ID is unique for this page\n-        let map = used_header_map.get().unwrap();\n-        let id = match map.borrow_mut().get_mut(&id) {\n-            None => id,\n-            Some(a) => { *a += 1; format!(\"{}-{}\", id, *a - 1) }\n-        };\n-        map.borrow_mut().insert(id.clone(), 1);\n+        let id = USED_HEADER_MAP.with(|map| {\n+            let id = id.replace(\"<code>\", \"\").replace(\"</code>\", \"\").to_string();\n+            let id = match map.borrow_mut().get_mut(&id) {\n+                None => id,\n+                Some(a) => { *a += 1; format!(\"{}-{}\", id, *a - 1) }\n+            };\n+            map.borrow_mut().insert(id.clone(), 1);\n+            id\n+        });\n \n         let sec = match opaque.toc_builder {\n             Some(ref mut builder) => {\n@@ -262,9 +271,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         text.with_c_str(|p| unsafe { hoedown_buffer_puts(ob, p) });\n     }\n \n-    if used_header_map.get().is_none() {\n-        reset_headers();\n-    }\n+    reset_headers();\n \n     unsafe {\n         let ob = hoedown_buffer_new(DEF_OUNIT);\n@@ -418,8 +425,8 @@ impl LangString {\n /// used at the beginning of rendering an entire HTML page to reset from the\n /// previous state (if any).\n pub fn reset_headers() {\n-    used_header_map.replace(Some(RefCell::new(HashMap::new())));\n-    test_idx.replace(Some(Cell::new(0)));\n+    USED_HEADER_MAP.with(|s| s.borrow_mut().clear());\n+    TEST_IDX.with(|s| s.set(0));\n }\n \n impl<'a> fmt::Show for Markdown<'a> {"}, {"sha": "466af36898e0a1bd292e50fec1a345eead728b3b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -34,8 +34,10 @@\n //! both occur before the crate is rendered.\n pub use self::ExternalLocation::*;\n \n-use std::collections::{HashMap, HashSet};\n+use std::cell::RefCell;\n use std::collections::hash_map::{Occupied, Vacant};\n+use std::collections::{HashMap, HashSet};\n+use std::default::Default;\n use std::fmt;\n use std::io::fs::PathExtensions;\n use std::io::{fs, File, BufferedWriter, BufferedReader};\n@@ -141,6 +143,7 @@ pub struct Impl {\n /// to be a fairly large and expensive structure to clone. Instead this adheres\n /// to `Send` so it may be stored in a `Arc` instance and shared among the various\n /// rendering tasks.\n+#[deriving(Default)]\n pub struct Cache {\n     /// Mapping of typaram ids to the name of the type parameter. This is used\n     /// when pretty-printing a type (so pretty printing doesn't have to\n@@ -235,8 +238,9 @@ struct IndexItem {\n \n // TLS keys used to carry information around during rendering.\n \n-local_data_key!(pub cache_key: Arc<Cache>)\n-local_data_key!(pub current_location_key: Vec<String> )\n+thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default())\n+thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> =\n+                    RefCell::new(Vec::new()))\n \n /// Generates the documentation for `crate` into the directory `dst`\n pub fn run(mut krate: clean::Crate,\n@@ -280,10 +284,12 @@ pub fn run(mut krate: clean::Crate,\n                     clean::NameValue(ref x, ref s)\n                             if \"html_playground_url\" == x.as_slice() => {\n                         cx.layout.playground_url = s.to_string();\n-                        let name = krate.name.clone();\n-                        if markdown::playground_krate.get().is_none() {\n-                            markdown::playground_krate.replace(Some(Some(name)));\n-                        }\n+                        markdown::PLAYGROUND_KRATE.with(|slot| {\n+                            if slot.borrow().is_none() {\n+                                let name = krate.name.clone();\n+                                *slot.borrow_mut() = Some(Some(name));\n+                            }\n+                        });\n                     }\n                     clean::Word(ref x)\n                             if \"html_no_source\" == x.as_slice() => {\n@@ -297,7 +303,8 @@ pub fn run(mut krate: clean::Crate,\n     }\n \n     // Crawl the crate to build various caches used for the output\n-    let analysis = ::analysiskey.get();\n+    let analysis = ::ANALYSISKEY.with(|a| a.clone());\n+    let analysis = analysis.borrow();\n     let public_items = analysis.as_ref().map(|a| a.public_items.clone());\n     let public_items = public_items.unwrap_or(NodeSet::new());\n     let paths: HashMap<ast::DefId, (Vec<String>, ItemType)> =\n@@ -370,8 +377,8 @@ pub fn run(mut krate: clean::Crate,\n     // Freeze the cache now that the index has been built. Put an Arc into TLS\n     // for future parallelization opportunities\n     let cache = Arc::new(cache);\n-    cache_key.replace(Some(cache.clone()));\n-    current_location_key.replace(Some(Vec::new()));\n+    CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n+    CURRENT_LOCATION_KEY.with(|s| s.borrow_mut().clear());\n \n     try!(write_shared(&cx, &krate, &*cache, index));\n     let krate = try!(render_sources(&mut cx, krate));\n@@ -1134,7 +1141,9 @@ impl Context {\n             info!(\"Rendering an item to {}\", w.path().display());\n             // A little unfortunate that this is done like this, but it sure\n             // does make formatting *a lot* nicer.\n-            current_location_key.replace(Some(cx.current.clone()));\n+            CURRENT_LOCATION_KEY.with(|slot| {\n+                *slot.borrow_mut() = cx.current.clone();\n+            });\n \n             let mut title = cx.current.connect(\"::\");\n             if pushname {\n@@ -1177,7 +1186,7 @@ impl Context {\n                                     &Item{ cx: cx, item: it }));\n             } else {\n                 let mut url = \"../\".repeat(cx.current.len());\n-                match cache_key.get().unwrap().paths.get(&it.def_id) {\n+                match cache().paths.get(&it.def_id) {\n                     Some(&(ref names, _)) => {\n                         for name in names[..names.len() - 1].iter() {\n                             url.push_str(name.as_slice());\n@@ -1324,7 +1333,7 @@ impl<'a> Item<'a> {\n         // If we don't know where the external documentation for this crate is\n         // located, then we return `None`.\n         } else {\n-            let cache = cache_key.get().unwrap();\n+            let cache = cache();\n             let path = &cache.external_paths[self.item.def_id];\n             let root = match cache.extern_locations[self.item.def_id.krate] {\n                 Remote(ref s) => s.to_string(),\n@@ -1751,7 +1760,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         try!(write!(w, \"</div>\"));\n     }\n \n-    let cache = cache_key.get().unwrap();\n+    let cache = cache();\n     try!(write!(w, \"\n         <h2 id='implementors'>Implementors</h2>\n         <ul class='item-list' id='implementors-list'>\n@@ -2013,7 +2022,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n }\n \n fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n-    match cache_key.get().unwrap().impls.get(&it.def_id) {\n+    match cache().impls.get(&it.def_id) {\n         Some(v) => {\n             let (non_trait, traits) = v.partitioned(|i| i.impl_.trait_.is_none());\n             if non_trait.len() > 0 {\n@@ -2101,7 +2110,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n     match i.impl_.trait_ {\n         Some(clean::ResolvedPath { did, .. }) => {\n             try!({\n-                match cache_key.get().unwrap().traits.get(&did) {\n+                match cache().traits.get(&did) {\n                     Some(t) => try!(render_default_methods(w, t, &i.impl_)),\n                     None => {}\n                 }\n@@ -2220,3 +2229,7 @@ fn get_basic_keywords() -> &'static str {\n fn make_item_keywords(it: &clean::Item) -> String {\n     format!(\"{}, {}\", get_basic_keywords(), it.name.as_ref().unwrap())\n }\n+\n+pub fn cache() -> Arc<Cache> {\n+    CACHE_KEY.with(|c| c.borrow().clone())\n+}"}, {"sha": "204f866e82720ea24eb19d0226dd4b9802e20922", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -28,12 +28,14 @@ extern crate syntax;\n extern crate \"test\" as testing;\n #[phase(plugin, link)] extern crate log;\n \n-use std::io;\n-use std::io::File;\n+use std::cell::RefCell;\n use std::collections::HashMap;\n use std::collections::hash_map::{Occupied, Vacant};\n-use serialize::{json, Decodable, Encodable};\n+use std::io::File;\n+use std::io;\n+use std::rc::Rc;\n use externalfiles::ExternalHtml;\n+use serialize::{json, Decodable, Encodable};\n \n // reexported from `clean` so it can be easily updated with the mod itself\n pub use clean::SCHEMA_VERSION;\n@@ -84,7 +86,9 @@ static DEFAULT_PASSES: &'static [&'static str] = &[\n     \"unindent-comments\",\n ];\n \n-local_data_key!(pub analysiskey: core::CrateAnalysis)\n+thread_local!(pub static ANALYSISKEY: Rc<RefCell<Option<core::CrateAnalysis>>> = {\n+    Rc::new(RefCell::new(None))\n+})\n \n struct Output {\n     krate: clean::Crate,\n@@ -338,7 +342,10 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n         core::run_core(libs, cfgs, externs, &cr, triple)\n     }).map_err(|_| \"rustc failed\").unwrap();\n     info!(\"finished with rustc\");\n-    analysiskey.replace(Some(analysis));\n+    let mut analysis = Some(analysis);\n+    ANALYSISKEY.with(|s| {\n+        *s.borrow_mut() = analysis.take();\n+    });\n \n     match matches.opt_str(\"crate-name\") {\n         Some(name) => krate.name = name,"}, {"sha": "881c7a91d81d033b2a144fadab2c5799862ac790", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -55,7 +55,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n     let input_str = load_or_return!(input, 1, 2);\n     let playground = matches.opt_str(\"markdown-playground-url\");\n     if playground.is_some() {\n-        markdown::playground_krate.replace(Some(None));\n+        markdown::PLAYGROUND_KRATE.with(|s| { *s.borrow_mut() = None; });\n     }\n     let playground = playground.unwrap_or(\"\".to_string());\n "}, {"sha": "f55d447f56927b870bad51a6e434e37843487d35", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -101,7 +101,9 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n     // This stripper collects all *retained* nodes.\n     let mut retained = HashSet::new();\n-    let analysis = super::analysiskey.get().unwrap();\n+    let analysis = super::ANALYSISKEY.with(|a| a.clone());\n+    let analysis = analysis.borrow();\n+    let analysis = analysis.as_ref().unwrap();\n     let exported_items = analysis.exported_items.clone();\n \n     // strip all private items"}, {"sha": "42f4c2a0ca63a19dacd2c03c3eac921e893a31c6", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -23,7 +23,7 @@ use clean::{Crate, Item, ModuleItem, Module, EnumItem, Enum};\n use clean::{ImplItem, Impl, Trait, TraitItem, TraitMethod, ProvidedMethod, RequiredMethod};\n use clean::{TypeTraitItem, ViewItemItem, PrimitiveItem, Stability};\n \n-use html::render::cache_key;\n+use html::render::cache;\n \n #[deriving(Zero, Encodable, Decodable, PartialEq, Eq)]\n /// The counts for each stability level.\n@@ -116,7 +116,7 @@ fn count_stability(stab: Option<&Stability>) -> Counts {\n }\n \n fn summarize_methods(item: &Item) -> Counts {\n-    match cache_key.get().unwrap().impls.get(&item.def_id) {\n+    match cache().impls.get(&item.def_id) {\n         Some(v) => {\n             v.iter().map(|i| {\n                 let count = count_stability(i.stability.as_ref());"}, {"sha": "3d172d623501cfe99b2898da2a529b2e241a9688", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -52,7 +52,6 @@ pub mod bookkeeping;\n pub mod c_str;\n pub mod exclusive;\n pub mod local;\n-pub mod local_data;\n pub mod mutex;\n pub mod stack;\n pub mod task;"}, {"sha": "ca0f694676f29fd8df503d3c171c09b456664efd", "filename": "src/librustrt/local_data.rs", "status": "removed", "additions": 0, "deletions": 696, "changes": 696, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -1,696 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Task local data management\n-\n-Allows storing arbitrary types inside task-local-data (TLD), to be accessed\n-anywhere within a task, keyed by a global pointer parameterized over the type of\n-the TLD slot. Useful for dynamic variables, singletons, and interfacing with\n-foreign code with bad callback interfaces.\n-\n-To declare a new key for storing local data of a particular type, use the\n-`local_data_key!` macro. This macro will expand to a `static` item appropriately\n-named and annotated. This name is then passed to the functions in this module to\n-modify/read the slot specified by the key.\n-\n-```rust\n-local_data_key!(key_int: int)\n-local_data_key!(key_vector: Vec<int>)\n-\n-key_int.replace(Some(3));\n-assert_eq!(*key_int.get().unwrap(), 3);\n-\n-key_vector.replace(Some(vec![4]));\n-assert_eq!(*key_vector.get().unwrap(), vec![4]);\n-```\n-\n-*/\n-\n-// Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation\n-// magic.\n-\n-pub use self::KeyValue::*;\n-\n-use core::prelude::*;\n-\n-use alloc::heap;\n-use collections::TreeMap;\n-use core::cmp;\n-use core::kinds::marker;\n-use core::mem;\n-use core::ptr;\n-use core::fmt;\n-use core::cell::UnsafeCell;\n-\n-use local::Local;\n-use task::{Task, LocalStorage};\n-\n-/**\n- * Indexes a task-local data slot. This pointer is used for comparison to\n- * differentiate keys from one another. The actual type `T` is not used anywhere\n- * as a member of this type, except that it is parameterized with it to define\n- * the type of each key's value.\n- *\n- * The value of each Key is of the singleton enum KeyValue. These also have the\n- * same name as `Key` and their purpose is to take up space in the programs data\n- * sections to ensure that each value of the `Key` type points to a unique\n- * location.\n- */\n-pub type Key<T> = &'static KeyValue<T>;\n-\n-#[allow(missing_docs)]\n-pub enum KeyValue<T> { KeyValueKey }\n-\n-// The task-local-map stores all TLD information for the currently running\n-// task. It is stored as an owned pointer into the runtime, and it's only\n-// allocated when TLD is used for the first time.\n-//\n-// TLD values are boxed up, with a loan count stored in the box. The box is\n-// necessary given how TLD maps are constructed, but theoretically in the\n-// future this could be rewritten to statically construct TLD offsets at\n-// compile-time to get O(1) lookup. At that time, the box can be removed.\n-//\n-// A very common usage pattern for TLD is to use replace(None) to extract a\n-// value from TLD, work with it, and then store it (or a derived/new value)\n-// back with replace(v). We take special care to reuse the allocation in this\n-// case for performance reasons.\n-//\n-// However, that does mean that if a value is replaced with None, the\n-// allocation will stay alive and the entry will stay in the TLD map until the\n-// task deallocates. This makes the assumption that every key inserted into a\n-// given task's TLD is going to be present for a majority of the rest of the\n-// task's lifetime, but that's a fairly safe assumption, and there's very\n-// little downside as long as it holds true for most keys.\n-//\n-// The Map type must be public in order to allow rustrt to see it.\n-//\n-// We'd like to use HashMap here, but it uses TLD in its construction (it uses\n-// the task-local rng). We could try to provide our own source of randomness,\n-// except it also lives in libstd (which is a client of us) so we can't even\n-// reference it. Instead, use TreeMap, which provides reasonable performance.\n-#[doc(hidden)]\n-pub type Map = TreeMap<uint, TLDValue>;\n-#[unsafe_no_drop_flag]\n-struct TLDValue {\n-    // box_ptr is a pointer to TLDValueBox<T>. It can never be null.\n-    box_ptr: *mut (),\n-    // drop_fn is the function that knows how to drop the box_ptr.\n-    drop_fn: unsafe fn(p: *mut ())\n-}\n-\n-struct TLDValueBox<T> {\n-    // value is only initialized when refcount >= 1.\n-    value: T,\n-    // refcount of 0 means uninitialized value, 1 means initialized, 2+ means\n-    // borrowed.\n-    // NB: we use UnsafeCell instead of Cell because Ref should be allowed to\n-    // be Sync. The only mutation occurs when a Ref is created or destroyed,\n-    // so there's no issue with &Ref being thread-safe.\n-    refcount: UnsafeCell<uint>\n-}\n-\n-// Gets the map from the runtime. Lazily initialises if not done so already.\n-unsafe fn get_local_map<'a>() -> Option<&'a mut Map> {\n-    if !Local::exists(None::<Task>) { return None }\n-\n-    let task: *mut Task = Local::unsafe_borrow();\n-    match &mut (*task).storage {\n-        // If the at_exit function is already set, then we just need to take\n-        // a loan out on the TLD map stored inside\n-        &LocalStorage(Some(ref mut map_ptr)) => {\n-            return Some(map_ptr);\n-        }\n-        // If this is the first time we've accessed TLD, perform similar\n-        // actions to the oldsched way of doing things.\n-        &LocalStorage(ref mut slot) => {\n-            *slot = Some(TreeMap::new());\n-            match *slot {\n-                Some(ref mut map_ptr) => { return Some(map_ptr) }\n-                None => panic!(\"unreachable code\"),\n-            }\n-        }\n-    }\n-}\n-\n-/// A RAII immutable reference to a task-local value.\n-///\n-/// The task-local data can be accessed through this value, and when this\n-/// structure is dropped it will return the borrow on the data.\n-pub struct Ref<T:'static> {\n-    // FIXME #12808: strange names to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _inner: &'static TLDValueBox<T>,\n-    _marker: marker::NoSend\n-}\n-\n-fn key_to_key_value<T: 'static>(key: Key<T>) -> uint {\n-    key as *const _ as uint\n-}\n-\n-impl<T: 'static> KeyValue<T> {\n-    /// Replaces a value in task local data.\n-    ///\n-    /// If this key is already present in TLD, then the previous value is\n-    /// replaced with the provided data, and then returned.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the key is present in TLD and currently on\n-    /// loan with the `get` method.\n-    ///\n-    /// It will also panic if there is no local task (because the current thread\n-    /// is not owned by the runtime).\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// local_data_key!(foo: int)\n-    ///\n-    /// assert_eq!(foo.replace(Some(10)), None);\n-    /// assert_eq!(foo.replace(Some(4)), Some(10));\n-    /// assert_eq!(foo.replace(None), Some(4));\n-    /// ```\n-    pub fn replace(&'static self, data: Option<T>) -> Option<T> {\n-        let map = match unsafe { get_local_map() } {\n-            Some(map) => map,\n-            None => panic!(\"must have a local task to insert into TLD\"),\n-        };\n-        let keyval = key_to_key_value(self);\n-\n-        // The following match takes a mutable borrow on the map. In order to insert\n-        // our data if the key isn't present, we need to let the match end first.\n-        let data = match (map.get_mut(&keyval), data) {\n-            (None, Some(data)) => {\n-                // The key doesn't exist and we need to insert it. To make borrowck\n-                // happy, return it up a scope and insert it there.\n-                data\n-            }\n-            (None, None) => {\n-                // The key doesn't exist and we're trying to replace it with nothing.\n-                // Do nothing.\n-                return None\n-            }\n-            (Some(slot), data) => {\n-                // We have a slot with a box.\n-                let value_box = slot.box_ptr as *mut TLDValueBox<T>;\n-                let refcount = unsafe { *(*value_box).refcount.get() };\n-                return match (refcount, data) {\n-                    (0, None) => {\n-                        // The current value is uninitialized and we have no new value.\n-                        // Do nothing.\n-                        None\n-                    }\n-                    (0, Some(new_value)) => {\n-                        // The current value is uninitialized and we're storing a new value.\n-                        unsafe {\n-                            ptr::write(&mut (*value_box).value, new_value);\n-                            *(*value_box).refcount.get() = 1;\n-                            None\n-                        }\n-                    }\n-                    (1, None) => {\n-                        // We have an initialized value and we're removing it.\n-                        unsafe {\n-                            let ret = ptr::read(&(*value_box).value);\n-                            *(*value_box).refcount.get() = 0;\n-                            Some(ret)\n-                        }\n-                    }\n-                    (1, Some(new_value)) => {\n-                        // We have an initialized value and we're replacing it.\n-                        let value_ref = unsafe { &mut (*value_box).value };\n-                        let ret = mem::replace(value_ref, new_value);\n-                        // Refcount is already 1, leave it as that.\n-                        Some(ret)\n-                    }\n-                    _ => {\n-                        // Refcount is 2+, which means we have a live borrow.\n-                        panic!(\"TLD value cannot be replaced because it is already borrowed\");\n-                    }\n-                }\n-            }\n-        };\n-        // If we've reached this point, we need to insert into the map.\n-        map.insert(keyval, TLDValue::new(data));\n-        None\n-    }\n-\n-    /// Borrows a value from TLD.\n-    ///\n-    /// If `None` is returned, then this key is not present in TLD. If `Some`\n-    /// is returned, then the returned data is a smart pointer representing a\n-    /// new loan on this TLD key. While on loan, this key cannot be altered via\n-    /// the `replace` method.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// local_data_key!(key: int)\n-    ///\n-    /// assert!(key.get().is_none());\n-    ///\n-    /// key.replace(Some(3));\n-    /// assert_eq!(*key.get().unwrap(), 3);\n-    /// ```\n-    pub fn get(&'static self) -> Option<Ref<T>> {\n-        let map = match unsafe { get_local_map() } {\n-            Some(map) => map,\n-            None => return None,\n-        };\n-        let keyval = key_to_key_value(self);\n-\n-        match map.get(&keyval) {\n-            Some(slot) => {\n-                let value_box = slot.box_ptr as *mut TLDValueBox<T>;\n-                if unsafe { *(*value_box).refcount.get() } >= 1 {\n-                    unsafe {\n-                        *(*value_box).refcount.get() += 1;\n-                        Some(Ref {\n-                            _inner: &*value_box,\n-                            _marker: marker::NoSend\n-                        })\n-                    }\n-                } else {\n-                    None\n-                }\n-            }\n-            None => None\n-        }\n-    }\n-\n-    // it's not clear if this is the right design for a public API, or if\n-    // there's even a need for this as a public API, but our benchmarks need\n-    // this to ensure consistent behavior on each run.\n-    #[cfg(test)]\n-    fn clear(&'static self) {\n-        let map = match unsafe { get_local_map() } {\n-            Some(map) => map,\n-            None => return\n-        };\n-        let keyval = key_to_key_value(self);\n-        self.replace(None); // ensure we have no outstanding borrows\n-        map.remove(&keyval);\n-    }\n-}\n-\n-impl<T: 'static> Deref<T> for Ref<T> {\n-    #[inline(always)]\n-    fn deref<'a>(&'a self) -> &'a T {\n-        &self._inner.value\n-    }\n-}\n-\n-impl<T: 'static + fmt::Show> fmt::Show for Ref<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        (**self).fmt(f)\n-    }\n-}\n-\n-impl<T: cmp::PartialEq + 'static> cmp::PartialEq for Ref<T> {\n-    fn eq(&self, other: &Ref<T>) -> bool {\n-        (**self).eq(&**other)\n-    }\n-    fn ne(&self, other: &Ref<T>) -> bool {\n-        (**self).ne(&**other)\n-    }\n-}\n-\n-impl<T: cmp::Eq + 'static> cmp::Eq for Ref<T> {}\n-\n-impl<T: cmp::PartialOrd + 'static> cmp::PartialOrd for Ref<T> {\n-    fn partial_cmp(&self, other: &Ref<T>) -> Option<cmp::Ordering> {\n-        (**self).partial_cmp(&**other)\n-    }\n-    fn lt(&self, other: &Ref<T>) -> bool { (**self).lt(&**other) }\n-    fn le(&self, other: &Ref<T>) -> bool { (**self).le(&**other) }\n-    fn gt(&self, other: &Ref<T>) -> bool { (**self).gt(&**other) }\n-    fn ge(&self, other: &Ref<T>) -> bool { (**self).ge(&**other) }\n-}\n-\n-impl<T: cmp::Ord + 'static> cmp::Ord for Ref<T> {\n-    fn cmp(&self, other: &Ref<T>) -> cmp::Ordering {\n-        (**self).cmp(&**other)\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T: 'static> Drop for Ref<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            *self._inner.refcount.get() -= 1;\n-        }\n-    }\n-}\n-\n-impl TLDValue {\n-    fn new<T>(value: T) -> TLDValue {\n-        let box_ptr = unsafe {\n-            let allocation = heap::allocate(mem::size_of::<TLDValueBox<T>>(),\n-                                            mem::min_align_of::<TLDValueBox<T>>());\n-            if allocation.is_null() { ::alloc::oom() }\n-            let value_box = allocation as *mut TLDValueBox<T>;\n-            ptr::write(value_box, TLDValueBox {\n-                value: value,\n-                refcount: UnsafeCell::new(1)\n-            });\n-            value_box as *mut ()\n-        };\n-        // Destruction of TLDValue needs to know how to properly deallocate the TLDValueBox,\n-        // so we need our own custom destructor function.\n-        unsafe fn d<T>(p: *mut ()) {\n-            let value_box = p as *mut TLDValueBox<T>;\n-            debug_assert!(*(*value_box).refcount.get() < 2, \"TLDValue destructed while borrowed\");\n-            // use a RAII type here to ensure we always deallocate even if we panic while\n-            // running the destructor for the value.\n-            struct Guard<T> {\n-                p: *mut TLDValueBox<T>\n-            }\n-            #[unsafe_destructor]\n-            impl<T> Drop for Guard<T> {\n-                fn drop(&mut self) {\n-                    let size = mem::size_of::<TLDValueBox<T>>();\n-                    let align = mem::align_of::<TLDValueBox<T>>();\n-                    unsafe { heap::deallocate(self.p as *mut u8, size, align); }\n-                }\n-            }\n-            let _guard = Guard::<T> { p: value_box };\n-            if *(*value_box).refcount.get() != 0 {\n-                // the contained value is valid; drop it\n-                ptr::read(&(*value_box).value);\n-            }\n-            // the box will be deallocated by the guard\n-        }\n-        TLDValue {\n-            box_ptr: box_ptr,\n-            drop_fn: d::<T>\n-        }\n-    }\n-}\n-\n-\n-impl Drop for TLDValue {\n-    fn drop(&mut self) {\n-        // box_ptr should always be non-null. Check it anyway just to be thorough\n-        if !self.box_ptr.is_null() {\n-            unsafe { (self.drop_fn)(self.box_ptr) }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    extern crate test;\n-\n-    use std::prelude::*;\n-    use super::*;\n-    use std::task;\n-\n-    #[test]\n-    fn test_tls_multitask() {\n-        static MY_KEY: Key<String> = &KeyValueKey;\n-        MY_KEY.replace(Some(\"parent data\".to_string()));\n-        task::spawn(proc() {\n-            // TLD shouldn't carry over.\n-            assert!(MY_KEY.get().is_none());\n-            MY_KEY.replace(Some(\"child data\".to_string()));\n-            assert!(MY_KEY.get().as_ref().unwrap().as_slice() == \"child data\");\n-            // should be cleaned up for us\n-        });\n-\n-        // Must work multiple times\n-        assert!(MY_KEY.get().unwrap().as_slice() == \"parent data\");\n-        assert!(MY_KEY.get().unwrap().as_slice() == \"parent data\");\n-        assert!(MY_KEY.get().unwrap().as_slice() == \"parent data\");\n-    }\n-\n-    #[test]\n-    fn test_tls_overwrite() {\n-        static MY_KEY: Key<String> = &KeyValueKey;\n-        MY_KEY.replace(Some(\"first data\".to_string()));\n-        MY_KEY.replace(Some(\"next data\".to_string())); // Shouldn't leak.\n-        assert!(MY_KEY.get().unwrap().as_slice() == \"next data\");\n-    }\n-\n-    #[test]\n-    fn test_tls_pop() {\n-        static MY_KEY: Key<String> = &KeyValueKey;\n-        MY_KEY.replace(Some(\"weasel\".to_string()));\n-        assert!(MY_KEY.replace(None).unwrap() == \"weasel\".to_string());\n-        // Pop must remove the data from the map.\n-        assert!(MY_KEY.replace(None).is_none());\n-    }\n-\n-    #[test]\n-    fn test_tls_crust_automorestack_memorial_bug() {\n-        // This might result in a stack-canary clobber if the runtime fails to\n-        // set sp_limit to 0 when calling the cleanup extern - it might\n-        // automatically jump over to the rust stack, which causes next_c_sp\n-        // to get recorded as something within a rust stack segment. Then a\n-        // subsequent upcall (esp. for logging, think vsnprintf) would run on\n-        // a stack smaller than 1 MB.\n-        static MY_KEY: Key<String> = &KeyValueKey;\n-        task::spawn(proc() {\n-            MY_KEY.replace(Some(\"hax\".to_string()));\n-        });\n-    }\n-\n-    #[test]\n-    fn test_tls_multiple_types() {\n-        static STR_KEY: Key<String> = &KeyValueKey;\n-        static BOX_KEY: Key<Box<int>> = &KeyValueKey;\n-        static INT_KEY: Key<int> = &KeyValueKey;\n-        task::spawn(proc() {\n-            STR_KEY.replace(Some(\"string data\".to_string()));\n-            BOX_KEY.replace(Some(box 0));\n-            INT_KEY.replace(Some(42));\n-        });\n-    }\n-\n-    #[test]\n-    fn test_tls_overwrite_multiple_types() {\n-        static STR_KEY: Key<String> = &KeyValueKey;\n-        static BOX_KEY: Key<Box<int>> = &KeyValueKey;\n-        static INT_KEY: Key<int> = &KeyValueKey;\n-        task::spawn(proc() {\n-            STR_KEY.replace(Some(\"string data\".to_string()));\n-            STR_KEY.replace(Some(\"string data 2\".to_string()));\n-            BOX_KEY.replace(Some(box 0));\n-            BOX_KEY.replace(Some(box 1));\n-            INT_KEY.replace(Some(42));\n-            // This could cause a segfault if overwriting-destruction is done\n-            // with the crazy polymorphic transmute rather than the provided\n-            // finaliser.\n-            INT_KEY.replace(Some(31337));\n-        });\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_tls_cleanup_on_panic() {\n-        static STR_KEY: Key<String> = &KeyValueKey;\n-        static BOX_KEY: Key<Box<int>> = &KeyValueKey;\n-        static INT_KEY: Key<int> = &KeyValueKey;\n-        STR_KEY.replace(Some(\"parent data\".to_string()));\n-        BOX_KEY.replace(Some(box 0));\n-        task::spawn(proc() {\n-            STR_KEY.replace(Some(\"string data\".to_string()));\n-            BOX_KEY.replace(Some(box 2));\n-            INT_KEY.replace(Some(42));\n-            panic!();\n-        });\n-        // Not quite nondeterministic.\n-        INT_KEY.replace(Some(31337));\n-        panic!();\n-    }\n-\n-    #[test]\n-    fn test_cleanup_drops_values() {\n-        let (tx, rx) = channel::<()>();\n-        struct Dropper {\n-            tx: Sender<()>\n-        };\n-        impl Drop for Dropper {\n-            fn drop(&mut self) {\n-                self.tx.send(());\n-            }\n-        }\n-        static KEY: Key<Dropper> = &KeyValueKey;\n-        let _ = task::try(proc() {\n-            KEY.replace(Some(Dropper{ tx: tx }));\n-        });\n-        // At this point the task has been cleaned up and the TLD dropped.\n-        // If the channel doesn't have a value now, then the Sender was leaked.\n-        assert_eq!(rx.try_recv(), Ok(()));\n-    }\n-\n-    #[test]\n-    fn test_static_pointer() {\n-        static KEY: Key<&'static int> = &KeyValueKey;\n-        static VALUE: int = 0;\n-        KEY.replace(Some(&VALUE));\n-    }\n-\n-    #[test]\n-    fn test_owned() {\n-        static KEY: Key<Box<int>> = &KeyValueKey;\n-        KEY.replace(Some(box 1));\n-\n-        {\n-            let k1 = KEY.get().unwrap();\n-            let k2 = KEY.get().unwrap();\n-            let k3 = KEY.get().unwrap();\n-            assert_eq!(**k1, 1);\n-            assert_eq!(**k2, 1);\n-            assert_eq!(**k3, 1);\n-        }\n-        KEY.replace(Some(box 2));\n-        assert_eq!(**KEY.get().unwrap(), 2);\n-    }\n-\n-    #[test]\n-    fn test_same_key_type() {\n-        static KEY1: Key<int> = &KeyValueKey;\n-        static KEY2: Key<int> = &KeyValueKey;\n-        static KEY3: Key<int> = &KeyValueKey;\n-        static KEY4: Key<int> = &KeyValueKey;\n-        static KEY5: Key<int> = &KeyValueKey;\n-        KEY1.replace(Some(1));\n-        KEY2.replace(Some(2));\n-        KEY3.replace(Some(3));\n-        KEY4.replace(Some(4));\n-        KEY5.replace(Some(5));\n-\n-        assert_eq!(*KEY1.get().unwrap(), 1);\n-        assert_eq!(*KEY2.get().unwrap(), 2);\n-        assert_eq!(*KEY3.get().unwrap(), 3);\n-        assert_eq!(*KEY4.get().unwrap(), 4);\n-        assert_eq!(*KEY5.get().unwrap(), 5);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_nested_get_set1() {\n-        static KEY: Key<int> = &KeyValueKey;\n-        assert_eq!(KEY.replace(Some(4)), None);\n-\n-        let _k = KEY.get();\n-        KEY.replace(Some(4));\n-    }\n-\n-    // ClearKey is a RAII class that ensures the keys are cleared from the map.\n-    // This is so repeated runs of a benchmark don't bloat the map with extra\n-    // keys and distort the measurements.\n-    // It's not used on the tests because the tests run in separate tasks.\n-    struct ClearKey<T>(Key<T>);\n-    #[unsafe_destructor]\n-    impl<T: 'static> Drop for ClearKey<T> {\n-        fn drop(&mut self) {\n-            let ClearKey(ref key) = *self;\n-            key.clear();\n-        }\n-    }\n-\n-    #[bench]\n-    fn bench_replace_none(b: &mut test::Bencher) {\n-        static KEY: Key<uint> = &KeyValueKey;\n-        let _clear = ClearKey(KEY);\n-        KEY.replace(None);\n-        b.iter(|| {\n-            KEY.replace(None)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_replace_some(b: &mut test::Bencher) {\n-        static KEY: Key<uint> = &KeyValueKey;\n-        let _clear = ClearKey(KEY);\n-        KEY.replace(Some(1u));\n-        b.iter(|| {\n-            KEY.replace(Some(2))\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_replace_none_some(b: &mut test::Bencher) {\n-        static KEY: Key<uint> = &KeyValueKey;\n-        let _clear = ClearKey(KEY);\n-        KEY.replace(Some(0u));\n-        b.iter(|| {\n-            let old = KEY.replace(None).unwrap();\n-            let new = old + 1;\n-            KEY.replace(Some(new))\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_100_keys_replace_last(b: &mut test::Bencher) {\n-        static KEYS: [KeyValue<uint>, ..100] = [KeyValueKey, ..100];\n-        let _clear = KEYS.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n-        for (i, key) in KEYS.iter().enumerate() {\n-            key.replace(Some(i));\n-        }\n-        b.iter(|| {\n-            let key: Key<uint> = &KEYS[99];\n-            key.replace(Some(42))\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_1000_keys_replace_last(b: &mut test::Bencher) {\n-        static KEYS: [KeyValue<uint>, ..1000] = [KeyValueKey, ..1000];\n-        let _clear = KEYS.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n-        for (i, key) in KEYS.iter().enumerate() {\n-            key.replace(Some(i));\n-        }\n-        b.iter(|| {\n-            let key: Key<uint> = &KEYS[999];\n-            key.replace(Some(42))\n-        });\n-        for key in KEYS.iter() { key.clear(); }\n-    }\n-\n-    #[bench]\n-    fn bench_get(b: &mut test::Bencher) {\n-        static KEY: Key<uint> = &KeyValueKey;\n-        let _clear = ClearKey(KEY);\n-        KEY.replace(Some(42));\n-        b.iter(|| {\n-            KEY.get()\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_100_keys_get_last(b: &mut test::Bencher) {\n-        static KEYS: [KeyValue<uint>, ..100] = [KeyValueKey, ..100];\n-        let _clear = KEYS.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n-        for (i, key) in KEYS.iter().enumerate() {\n-            key.replace(Some(i));\n-        }\n-        b.iter(|| {\n-            let key: Key<uint> = &KEYS[99];\n-            key.get()\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_1000_keys_get_last(b: &mut test::Bencher) {\n-        static KEYS: [KeyValue<uint>, ..1000] = [KeyValueKey, ..1000];\n-        let _clear = KEYS.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n-        for (i, key) in KEYS.iter().enumerate() {\n-            key.replace(Some(i));\n-        }\n-        b.iter(|| {\n-            let key: Key<uint> = &KEYS[999];\n-            key.get()\n-        });\n-    }\n-}"}, {"sha": "63fa3938fc828c549b1e1ad4774b5861123d20a7", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 3, "deletions": 61, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -27,7 +27,6 @@ use core::prelude::{drop};\n \n use bookkeeping;\n use mutex::NativeMutex;\n-use local_data;\n use local::Local;\n use thread::{mod, Thread};\n use stack;\n@@ -40,7 +39,6 @@ use collections::str::SendStr;\n /// This structure is currently undergoing major changes, and is\n /// likely to be move/be merged with a `Thread` structure.\n pub struct Task {\n-    pub storage: LocalStorage,\n     pub unwinder: Unwinder,\n     pub death: Death,\n     pub name: Option<SendStr>,\n@@ -83,8 +81,6 @@ pub struct TaskOpts {\n /// children tasks complete, recommend using a result future.\n pub type Result = ::core::result::Result<(), Box<Any + Send>>;\n \n-pub struct LocalStorage(pub Option<local_data::Map>);\n-\n /// A handle to a blocked task. Usually this means having the Box<Task>\n /// pointer by ownership, but if the task is killable, a killer can steal it\n /// at any time.\n@@ -107,7 +103,6 @@ impl Task {\n     /// Creates a new uninitialized task.\n     pub fn new(stack_bounds: Option<(uint, uint)>, stack_guard: Option<uint>) -> Task {\n         Task {\n-            storage: LocalStorage(None),\n             unwinder: Unwinder::new(),\n             death: Death::new(),\n             state: New,\n@@ -230,54 +225,11 @@ impl Task {\n     /// This function consumes ownership of the task, deallocating it once it's\n     /// done being processed. It is assumed that TLD and the local heap have\n     /// already been destroyed and/or annihilated.\n-    fn cleanup(self: Box<Task>, result: Result) -> Box<Task> {\n-        // The first thing to do when cleaning up is to deallocate our local\n-        // resources, such as TLD.\n-        //\n-        // FIXME: there are a number of problems with this code\n-        //\n-        // 1. If any TLD object fails destruction, then all of TLD will leak.\n-        //    This appears to be a consequence of #14875.\n-        //\n-        // 2. Setting a TLD key while destroying TLD will abort the runtime #14807.\n-        //\n-        // 3. The order of destruction of TLD matters, but either way is\n-        //    susceptible to leaks (see 2) #8302.\n-        //\n-        // That being said, there are a few upshots to this code\n-        //\n-        // 1. If TLD destruction fails, heap destruction will be attempted.\n-        //    There is a test for this at fail-during-tld-destroy.rs.\n-        //\n-        // 2. One failure in destruction is tolerable, so long as the task\n-        //    didn't originally panic while it was running.\n-        //\n-        // And with all that in mind, we attempt to clean things up!\n-        let mut task = self.run(|| {\n-            let mut task = Local::borrow(None::<Task>);\n-            let tld = {\n-                let &LocalStorage(ref mut optmap) = &mut task.storage;\n-                optmap.take()\n-            };\n-            drop(task);\n-\n-            // First, destroy task-local storage. This may run user dtors.\n-            drop(tld);\n-        });\n-\n-        // If the above `run` block panicked, then it must be the case that the\n-        // task had previously succeeded. This also means that the code below\n-        // was recursively run via the `run` method invoking this method. In\n-        // this case, we just make sure the world is as we thought, and return.\n-        if task.is_destroyed() {\n-            rtassert!(result.is_ok())\n-            return task\n-        }\n-\n+    fn cleanup(mut self: Box<Task>, result: Result) -> Box<Task> {\n         // After taking care of the data above, we need to transmit the result\n         // of this task.\n-        let what_to_do = task.death.on_exit.take();\n-        Local::put(task);\n+        let what_to_do = self.death.on_exit.take();\n+        Local::put(self);\n \n         // FIXME: this is running in a seriously constrained context. If this\n         //        allocates TLD then it will likely abort the runtime. Similarly,\n@@ -549,16 +501,6 @@ mod test {\n     use std::task;\n     use unwind;\n \n-    #[test]\n-    fn tls() {\n-        local_data_key!(key: String)\n-        key.replace(Some(\"data\".to_string()));\n-        assert_eq!(key.get().unwrap().as_slice(), \"data\");\n-        local_data_key!(key2: String)\n-        key2.replace(Some(\"data\".to_string()));\n-        assert_eq!(key2.get().unwrap().as_slice(), \"data\");\n-    }\n-\n     #[test]\n     fn unwind() {\n         let result = task::try(proc()());"}, {"sha": "662ae913764f4d6ec482d8a12fc2436708947d3f", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 72, "deletions": 61, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -1471,7 +1471,7 @@ mod test_map {\n         assert_eq!(*m.get(&2).unwrap(), 4);\n     }\n \n-    local_data_key!(drop_vector: RefCell<Vec<int>>)\n+    thread_local!(static DROP_VECTOR: RefCell<Vec<int>> = RefCell::new(Vec::new()))\n \n     #[deriving(Hash, PartialEq, Eq)]\n     struct Dropable {\n@@ -1480,17 +1480,19 @@ mod test_map {\n \n     impl Dropable {\n         fn new(k: uint) -> Dropable {\n-            let v = drop_vector.get().unwrap();\n-            v.borrow_mut().as_mut_slice()[k] += 1;\n+            DROP_VECTOR.with(|slot| {\n+                slot.borrow_mut()[k] += 1;\n+            });\n \n             Dropable { k: k }\n         }\n     }\n \n     impl Drop for Dropable {\n         fn drop(&mut self) {\n-            let v = drop_vector.get().unwrap();\n-            v.borrow_mut().as_mut_slice()[self.k] -= 1;\n+            DROP_VECTOR.with(|slot| {\n+                slot.borrow_mut()[self.k] -= 1;\n+            });\n         }\n     }\n \n@@ -1502,82 +1504,89 @@ mod test_map {\n \n     #[test]\n     fn test_drops() {\n-        drop_vector.replace(Some(RefCell::new(Vec::from_elem(200, 0i))));\n+        DROP_VECTOR.with(|slot| {\n+            *slot.borrow_mut() = Vec::from_elem(200, 0i);\n+        });\n \n         {\n             let mut m = HashMap::new();\n \n-            let v = drop_vector.get().unwrap();\n-            for i in range(0u, 200) {\n-                assert_eq!(v.borrow().as_slice()[i], 0);\n-            }\n-            drop(v);\n+            DROP_VECTOR.with(|v| {\n+                for i in range(0u, 200) {\n+                    assert_eq!(v.borrow().as_slice()[i], 0);\n+                }\n+            });\n \n             for i in range(0u, 100) {\n                 let d1 = Dropable::new(i);\n                 let d2 = Dropable::new(i+100);\n                 m.insert(d1, d2);\n             }\n \n-            let v = drop_vector.get().unwrap();\n-            for i in range(0u, 200) {\n-                assert_eq!(v.borrow().as_slice()[i], 1);\n-            }\n-            drop(v);\n+            DROP_VECTOR.with(|v| {\n+                for i in range(0u, 200) {\n+                    assert_eq!(v.borrow().as_slice()[i], 1);\n+                }\n+            });\n \n             for i in range(0u, 50) {\n                 let k = Dropable::new(i);\n                 let v = m.remove(&k);\n \n                 assert!(v.is_some());\n \n-                let v = drop_vector.get().unwrap();\n-                assert_eq!(v.borrow().as_slice()[i], 1);\n-                assert_eq!(v.borrow().as_slice()[i+100], 1);\n+                DROP_VECTOR.with(|v| {\n+                    assert_eq!(v.borrow().as_slice()[i], 1);\n+                    assert_eq!(v.borrow().as_slice()[i+100], 1);\n+                });\n             }\n \n-            let v = drop_vector.get().unwrap();\n-            for i in range(0u, 50) {\n-                assert_eq!(v.borrow().as_slice()[i], 0);\n-                assert_eq!(v.borrow().as_slice()[i+100], 0);\n-            }\n+            DROP_VECTOR.with(|v| {\n+                for i in range(0u, 50) {\n+                    assert_eq!(v.borrow().as_slice()[i], 0);\n+                    assert_eq!(v.borrow().as_slice()[i+100], 0);\n+                }\n \n-            for i in range(50u, 100) {\n-                assert_eq!(v.borrow().as_slice()[i], 1);\n-                assert_eq!(v.borrow().as_slice()[i+100], 1);\n-            }\n+                for i in range(50u, 100) {\n+                    assert_eq!(v.borrow().as_slice()[i], 1);\n+                    assert_eq!(v.borrow().as_slice()[i+100], 1);\n+                }\n+            });\n         }\n \n-        let v = drop_vector.get().unwrap();\n-        for i in range(0u, 200) {\n-            assert_eq!(v.borrow().as_slice()[i], 0);\n-        }\n+        DROP_VECTOR.with(|v| {\n+            for i in range(0u, 200) {\n+                assert_eq!(v.borrow().as_slice()[i], 0);\n+            }\n+        });\n     }\n \n     #[test]\n     fn test_move_iter_drops() {\n-        drop_vector.replace(Some(RefCell::new(Vec::from_elem(200, 0i))));\n+        DROP_VECTOR.with(|v| {\n+            *v.borrow_mut() = Vec::from_elem(200, 0i);\n+        });\n \n         let hm = {\n             let mut hm = HashMap::new();\n \n-            let v = drop_vector.get().unwrap();\n-            for i in range(0u, 200) {\n-                assert_eq!(v.borrow().as_slice()[i], 0);\n-            }\n-            drop(v);\n+            DROP_VECTOR.with(|v| {\n+                for i in range(0u, 200) {\n+                    assert_eq!(v.borrow().as_slice()[i], 0);\n+                }\n+            });\n \n             for i in range(0u, 100) {\n                 let d1 = Dropable::new(i);\n                 let d2 = Dropable::new(i+100);\n                 hm.insert(d1, d2);\n             }\n \n-            let v = drop_vector.get().unwrap();\n-            for i in range(0u, 200) {\n-                assert_eq!(v.borrow().as_slice()[i], 1);\n-            }\n-            drop(v);\n+            DROP_VECTOR.with(|v| {\n+                for i in range(0u, 200) {\n+                    assert_eq!(v.borrow().as_slice()[i], 1);\n+                }\n+            });\n \n             hm\n         };\n@@ -1588,31 +1597,33 @@ mod test_map {\n         {\n             let mut half = hm.into_iter().take(50);\n \n-            let v = drop_vector.get().unwrap();\n-            for i in range(0u, 200) {\n-                assert_eq!(v.borrow().as_slice()[i], 1);\n-            }\n-            drop(v);\n+            DROP_VECTOR.with(|v| {\n+                for i in range(0u, 200) {\n+                    assert_eq!(v.borrow().as_slice()[i], 1);\n+                }\n+            });\n \n             for _ in half {}\n \n-            let v = drop_vector.get().unwrap();\n-            let nk = range(0u, 100).filter(|&i| {\n-                v.borrow().as_slice()[i] == 1\n-            }).count();\n+            DROP_VECTOR.with(|v| {\n+                let nk = range(0u, 100).filter(|&i| {\n+                    v.borrow().as_slice()[i] == 1\n+                }).count();\n \n-            let nv = range(0u, 100).filter(|&i| {\n-                v.borrow().as_slice()[i+100] == 1\n-            }).count();\n+                let nv = range(0u, 100).filter(|&i| {\n+                    v.borrow().as_slice()[i+100] == 1\n+                }).count();\n \n-            assert_eq!(nk, 50);\n-            assert_eq!(nv, 50);\n+                assert_eq!(nk, 50);\n+                assert_eq!(nv, 50);\n+            });\n         };\n \n-        let v = drop_vector.get().unwrap();\n-        for i in range(0u, 200) {\n-            assert_eq!(v.borrow().as_slice()[i], 0);\n-        }\n+        DROP_VECTOR.with(|v| {\n+            for i in range(0u, 200) {\n+                assert_eq!(v.borrow().as_slice()[i], 0);\n+            }\n+        });\n     }\n \n     #[test]"}, {"sha": "32a8be2290297cbde781bd333194eaf587e40d49", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -12,10 +12,11 @@\n \n use alloc::boxed::Box;\n use any::{Any, AnyRefExt};\n+use cell::RefCell;\n use fmt;\n use io::{Writer, IoResult};\n use kinds::Send;\n-use option::{Some, None};\n+use option::{Some, None, Option};\n use result::Ok;\n use rt::backtrace;\n use rustrt::{Stderr, Stdio};\n@@ -25,7 +26,9 @@ use str::Str;\n use string::String;\n \n // Defined in this module instead of io::stdio so that the unwinding\n-local_data_key!(pub local_stderr: Box<Writer + Send>)\n+thread_local!(pub static LOCAL_STDERR: RefCell<Option<Box<Writer + Send>>> = {\n+    RefCell::new(None)\n+})\n \n impl Writer for Stdio {\n     fn write(&mut self, bytes: &[u8]) -> IoResult<()> {\n@@ -74,7 +77,8 @@ pub fn on_fail(obj: &Any + Send, file: &'static str, line: uint) {\n     {\n         let n = name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n \n-        match local_stderr.replace(None) {\n+        let prev = LOCAL_STDERR.with(|s| s.borrow_mut().take());\n+        match prev {\n             Some(mut stderr) => {\n                 // FIXME: what to do when the task printing panics?\n                 let _ = writeln!(stderr,\n@@ -83,7 +87,10 @@ pub fn on_fail(obj: &Any + Send, file: &'static str, line: uint) {\n                 if backtrace::log_enabled() {\n                     let _ = backtrace::write(&mut *stderr);\n                 }\n-                local_stderr.replace(Some(stderr));\n+                let mut s = Some(stderr);\n+                LOCAL_STDERR.with(|slot| {\n+                    *slot.borrow_mut() = s.take();\n+                });\n             }\n             None => {\n                 let _ = writeln!(&mut err, \"task '{}' panicked at '{}', {}:{}\","}, {"sha": "d450e9f1dce3eebc17ac01c42804464f61d87191", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -29,22 +29,24 @@ out.write(b\"Hello, world!\");\n \n use self::StdSource::*;\n \n-use failure::local_stderr;\n+use boxed::Box;\n+use cell::RefCell;\n+use failure::LOCAL_STDERR;\n use fmt;\n use io::{Reader, Writer, IoResult, IoError, OtherIoError,\n          standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n use iter::Iterator;\n use kinds::Send;\n use libc;\n+use mem;\n use option::{Option, Some, None};\n-use boxed::Box;\n-use sys::{fs, tty};\n use result::{Ok, Err};\n use rustrt;\n use rustrt::local::Local;\n use rustrt::task::Task;\n use slice::SlicePrelude;\n use str::StrPrelude;\n+use sys::{fs, tty};\n use uint;\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n@@ -87,7 +89,9 @@ fn src<T>(fd: libc::c_int, _readable: bool, f: |StdSource| -> T) -> T {\n     }\n }\n \n-local_data_key!(local_stdout: Box<Writer + Send>)\n+thread_local!(static LOCAL_STDOUT: RefCell<Option<Box<Writer + Send>>> = {\n+    RefCell::new(None)\n+})\n \n /// Creates a new non-blocking handle to the stdin of the current process.\n ///\n@@ -167,7 +171,10 @@ pub fn stderr_raw() -> StdWriter {\n /// Note that this does not need to be called for all new tasks; the default\n /// output handle is to the process's stdout stream.\n pub fn set_stdout(stdout: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n-    local_stdout.replace(Some(stdout)).and_then(|mut s| {\n+    let mut new = Some(stdout);\n+    LOCAL_STDOUT.with(|slot| {\n+        mem::replace(&mut *slot.borrow_mut(), new.take())\n+    }).and_then(|mut s| {\n         let _ = s.flush();\n         Some(s)\n     })\n@@ -182,7 +189,10 @@ pub fn set_stdout(stdout: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n /// Note that this does not need to be called for all new tasks; the default\n /// output handle is to the process's stderr stream.\n pub fn set_stderr(stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n-    local_stderr.replace(Some(stderr)).and_then(|mut s| {\n+    let mut new = Some(stderr);\n+    LOCAL_STDERR.with(|slot| {\n+        mem::replace(&mut *slot.borrow_mut(), new.take())\n+    }).and_then(|mut s| {\n         let _ = s.flush();\n         Some(s)\n     })\n@@ -200,11 +210,16 @@ pub fn set_stderr(stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n //  })\n fn with_task_stdout(f: |&mut Writer| -> IoResult<()>) {\n     let result = if Local::exists(None::<Task>) {\n-        let mut my_stdout = local_stdout.replace(None).unwrap_or_else(|| {\n+        let mut my_stdout = LOCAL_STDOUT.with(|slot| {\n+            slot.borrow_mut().take()\n+        }).unwrap_or_else(|| {\n             box stdout() as Box<Writer + Send>\n         });\n         let result = f(&mut *my_stdout);\n-        local_stdout.replace(Some(my_stdout));\n+        let mut var = Some(my_stdout);\n+        LOCAL_STDOUT.with(|slot| {\n+            *slot.borrow_mut() = var.take();\n+        });\n         result\n     } else {\n         let mut io = rustrt::Stdout;"}, {"sha": "77da727e94d319829ab174c1f4681c2ab5edccaf", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -170,7 +170,6 @@ pub use core_collections::string;\n pub use core_collections::vec;\n \n pub use rustrt::c_str;\n-pub use rustrt::local_data;\n \n pub use unicode::char;\n \n@@ -209,17 +208,25 @@ pub mod prelude;\n #[path = \"num/f32.rs\"]   pub mod f32;\n #[path = \"num/f64.rs\"]   pub mod f64;\n \n-pub mod rand;\n-\n pub mod ascii;\n \n-pub mod time;\n-\n /* Common traits */\n \n pub mod error;\n pub mod num;\n \n+/* Runtime and platform support */\n+\n+pub mod thread_local;\n+pub mod c_vec;\n+pub mod dynamic_lib;\n+pub mod fmt;\n+pub mod io;\n+pub mod os;\n+pub mod path;\n+pub mod rand;\n+pub mod time;\n+\n /* Common data structures */\n \n pub mod collections;\n@@ -230,15 +237,6 @@ pub mod hash;\n pub mod task;\n pub mod sync;\n \n-/* Runtime and platform support */\n-\n-pub mod c_vec;\n-pub mod dynamic_lib;\n-pub mod os;\n-pub mod io;\n-pub mod path;\n-pub mod fmt;\n-\n #[cfg(unix)]\n #[path = \"sys/unix/mod.rs\"] mod sys;\n #[cfg(windows)]\n@@ -263,10 +261,12 @@ mod std {\n     pub use error; // used for try!()\n     pub use fmt; // used for any formatting strings\n     pub use io; // used for println!()\n-    pub use local_data; // used for local_data_key!()\n     pub use option; // used for bitflags!{}\n     pub use rt; // used for panic!()\n     pub use vec; // used for vec![]\n+    pub use cell; // used for tls!\n+    pub use thread_local; // used for thread_local!\n+    pub use kinds; // used for tls!\n \n     // The test runner calls ::std::os::args() but really wants realstd\n     #[cfg(test)] pub use realstd::os as os;\n@@ -276,4 +276,5 @@ mod std {\n     pub use slice;\n \n     pub use boxed; // used for vec![]\n+\n }"}, {"sha": "c3260225d0a3f15ff2a59b7a5e897daba3b9c7f0", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -304,28 +304,6 @@ macro_rules! println(\n     ($($arg:tt)*) => (format_args!(::std::io::stdio::println_args, $($arg)*))\n )\n \n-/// Declare a task-local key with a specific type.\n-///\n-/// # Example\n-///\n-/// ```\n-/// local_data_key!(my_integer: int)\n-///\n-/// my_integer.replace(Some(2));\n-/// println!(\"{}\", my_integer.get().map(|a| *a));\n-/// ```\n-#[macro_export]\n-macro_rules! local_data_key(\n-    ($name:ident: $ty:ty) => (\n-        #[allow(non_upper_case_globals)]\n-        static $name: ::std::local_data::Key<$ty> = &::std::local_data::KeyValueKey;\n-    );\n-    (pub $name:ident: $ty:ty) => (\n-        #[allow(non_upper_case_globals)]\n-        pub static $name: ::std::local_data::Key<$ty> = &::std::local_data::KeyValueKey;\n-    );\n-)\n-\n /// Helper macro for unwrapping `Result` values while returning early with an\n /// error if the value of the expression is `Err`. For more information, see\n /// `std::io`."}, {"sha": "f9f9147b1071b757710520cc0802e40c41bf5782", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -226,7 +226,6 @@ use clone::Clone;\n use io::IoResult;\n use iter::Iterator;\n use mem;\n-use option::{Some, None};\n use rc::Rc;\n use result::{Ok, Err};\n use vec::Vec;\n@@ -337,24 +336,18 @@ pub struct TaskRng {\n /// explicitly select an RNG, e.g. `IsaacRng` or `Isaac64Rng`.\n pub fn task_rng() -> TaskRng {\n     // used to make space in TLS for a random number generator\n-    local_data_key!(TASK_RNG_KEY: Rc<RefCell<TaskRngInner>>)\n-\n-    match TASK_RNG_KEY.get() {\n-        None => {\n-            let r = match StdRng::new() {\n-                Ok(r) => r,\n-                Err(e) => panic!(\"could not initialize task_rng: {}\", e)\n-            };\n-            let rng = reseeding::ReseedingRng::new(r,\n-                                                   TASK_RNG_RESEED_THRESHOLD,\n-                                                   TaskRngReseeder);\n-            let rng = Rc::new(RefCell::new(rng));\n-            TASK_RNG_KEY.replace(Some(rng.clone()));\n-\n-            TaskRng { rng: rng }\n-        }\n-        Some(rng) => TaskRng { rng: rng.clone() }\n-    }\n+    thread_local!(static TASK_RNG_KEY: Rc<RefCell<TaskRngInner>> = {\n+        let r = match StdRng::new() {\n+            Ok(r) => r,\n+            Err(e) => panic!(\"could not initialize task_rng: {}\", e)\n+        };\n+        let rng = reseeding::ReseedingRng::new(r,\n+                                               TASK_RNG_RESEED_THRESHOLD,\n+                                               TaskRngReseeder);\n+        Rc::new(RefCell::new(rng))\n+    })\n+\n+    TaskRng { rng: TASK_RNG_KEY.with(|t| t.clone()) }\n }\n \n impl Rng for TaskRng {"}, {"sha": "3e1ba8cebf814261e94d373cc6c1d844b3487bfb", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -210,28 +210,4 @@ mod test {\n         });\n         assert_eq!(rx.recv(), expected);\n     }\n-\n-    #[test]\n-    fn test_dropped_future_doesnt_panic() {\n-        struct Bomb(Sender<bool>);\n-\n-        local_data_key!(LOCAL: Bomb)\n-\n-        impl Drop for Bomb {\n-            fn drop(&mut self) {\n-                let Bomb(ref tx) = *self;\n-                tx.send(task::failing());\n-            }\n-        }\n-\n-        // Spawn a future, but drop it immediately. When we receive the result\n-        // later on, we should never view the task as having panicked.\n-        let (tx, rx) = channel();\n-        drop(Future::spawn(proc() {\n-            LOCAL.replace(Some(Bomb(tx)));\n-        }));\n-\n-        // Make sure the future didn't panic the task.\n-        assert!(!rx.recv());\n-    }\n }"}, {"sha": "77edd7c5c4eb6db8ca3abb88cfc25ecfe021fa12", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -21,6 +21,7 @@ use collections;\n \n pub mod net;\n pub mod helper_thread;\n+pub mod thread_local;\n \n // common error constructors\n "}, {"sha": "9ad38cbaf656f2ca85dd5e5f937b5aef5e11ae4f", "filename": "src/libstd/sys/common/thread_local.rs", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -0,0 +1,306 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! OS-based thread local storage\n+//!\n+//! This module provides an implementation of OS-based thread local storage,\n+//! using the native OS-provided facilities (think `TlsAlloc` or\n+//! `pthread_setspecific`). The interface of this differs from the other types\n+//! of thread-local-storage provided in this crate in that OS-based TLS can only\n+//! get/set pointers,\n+//!\n+//! This module also provides two flavors of TLS. One is intended for static\n+//! initialization, and does not contain a `Drop` implementation to deallocate\n+//! the OS-TLS key. The other is a type which does implement `Drop` and hence\n+//! has a safe interface.\n+//!\n+//! # Usage\n+//!\n+//! This module should likely not be used directly unless other primitives are\n+//! being built on. types such as `thread_local::scoped::Key` are likely much\n+//! more useful in practice than this OS-based version which likely requires\n+//! unsafe code to interoperate with.\n+//!\n+//! # Example\n+//!\n+//! Using a dynamically allocated TLS key. Note that this key can be shared\n+//! among many threads via an `Arc`.\n+//!\n+//! ```rust,ignore\n+//! let key = Key::new(None);\n+//! assert!(key.get().is_null());\n+//! key.set(1 as *mut u8);\n+//! assert!(!key.get().is_null());\n+//!\n+//! drop(key); // deallocate this TLS slot.\n+//! ```\n+//!\n+//! Sometimes a statically allocated key is either required or easier to work\n+//! with, however.\n+//!\n+//! ```rust,ignore\n+//! static KEY: StaticKey = INIT;\n+//!\n+//! unsafe {\n+//!     assert!(KEY.get().is_null());\n+//!     KEY.set(1 as *mut u8);\n+//! }\n+//! ```\n+\n+#![allow(non_camel_case_types)]\n+\n+use prelude::*;\n+\n+use kinds::marker;\n+use mem;\n+use rustrt::exclusive::Exclusive;\n+use rustrt;\n+use sync::atomic::{mod, AtomicUint};\n+use sync::{Once, ONCE_INIT};\n+\n+use sys::thread_local as imp;\n+\n+/// A type for TLS keys that are statically allocated.\n+///\n+/// This type is entirely `unsafe` to use as it does not protect against\n+/// use-after-deallocation or use-during-deallocation.\n+///\n+/// The actual OS-TLS key is lazily allocated when this is used for the first\n+/// time. The key is also deallocated when the Rust runtime exits or `destroy`\n+/// is called, whichever comes first.\n+///\n+/// # Example\n+///\n+/// ```ignore\n+/// use tls::os::{StaticKey, INIT};\n+///\n+/// static KEY: StaticKey = INIT;\n+///\n+/// unsafe {\n+///     assert!(KEY.get().is_null());\n+///     KEY.set(1 as *mut u8);\n+/// }\n+/// ```\n+pub struct StaticKey {\n+    /// Inner static TLS key (internals), created with by `INIT_INNER` in this\n+    /// module.\n+    pub inner: StaticKeyInner,\n+    /// Destructor for the TLS value.\n+    ///\n+    /// See `Key::new` for information about when the destructor runs and how\n+    /// it runs.\n+    pub dtor: Option<unsafe extern fn(*mut u8)>,\n+}\n+\n+/// Inner contents of `StaticKey`, created by the `INIT_INNER` constant.\n+pub struct StaticKeyInner {\n+    key: AtomicUint,\n+    nc: marker::NoCopy,\n+}\n+\n+/// A type for a safely managed OS-based TLS slot.\n+///\n+/// This type allocates an OS TLS key when it is initialized and will deallocate\n+/// the key when it falls out of scope. When compared with `StaticKey`, this\n+/// type is entirely safe to use.\n+///\n+/// Implementations will likely, however, contain unsafe code as this type only\n+/// operates on `*mut u8`, an unsafe pointer.\n+///\n+/// # Example\n+///\n+/// ```rust,ignore\n+/// use tls::os::Key;\n+///\n+/// let key = Key::new(None);\n+/// assert!(key.get().is_null());\n+/// key.set(1 as *mut u8);\n+/// assert!(!key.get().is_null());\n+///\n+/// drop(key); // deallocate this TLS slot.\n+/// ```\n+pub struct Key {\n+    key: imp::Key,\n+}\n+\n+/// Constant initialization value for static TLS keys.\n+///\n+/// This value specifies no destructor by default.\n+pub const INIT: StaticKey = StaticKey {\n+    inner: INIT_INNER,\n+    dtor: None,\n+};\n+\n+/// Constant initialization value for the inner part of static TLS keys.\n+///\n+/// This value allows specific configuration of the destructor for a TLS key.\n+pub const INIT_INNER: StaticKeyInner = StaticKeyInner {\n+    key: atomic::INIT_ATOMIC_UINT,\n+    nc: marker::NoCopy,\n+};\n+\n+static INIT_KEYS: Once = ONCE_INIT;\n+static mut KEYS: *mut Exclusive<Vec<imp::Key>> = 0 as *mut _;\n+\n+impl StaticKey {\n+    /// Gets the value associated with this TLS key\n+    ///\n+    /// This will lazily allocate a TLS key from the OS if one has not already\n+    /// been allocated.\n+    #[inline]\n+    pub unsafe fn get(&self) -> *mut u8 { imp::get(self.key()) }\n+\n+    /// Sets this TLS key to a new value.\n+    ///\n+    /// This will lazily allocate a TLS key from the OS if one has not already\n+    /// been allocated.\n+    #[inline]\n+    pub unsafe fn set(&self, val: *mut u8) { imp::set(self.key(), val) }\n+\n+    /// Deallocates this OS TLS key.\n+    ///\n+    /// This function is unsafe as there is no guarantee that the key is not\n+    /// currently in use by other threads or will not ever be used again.\n+    ///\n+    /// Note that this does *not* run the user-provided destructor if one was\n+    /// specified at definition time. Doing so must be done manually.\n+    pub unsafe fn destroy(&self) {\n+        match self.inner.key.swap(0, atomic::SeqCst) {\n+            0 => {}\n+            n => { unregister_key(n as imp::Key); imp::destroy(n as imp::Key) }\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn key(&self) -> imp::Key {\n+        match self.inner.key.load(atomic::Relaxed) {\n+            0 => self.lazy_init() as imp::Key,\n+            n => n as imp::Key\n+        }\n+    }\n+\n+    unsafe fn lazy_init(&self) -> uint {\n+        let key = imp::create(self.dtor);\n+        assert!(key != 0);\n+        match self.inner.key.compare_and_swap(0, key as uint, atomic::SeqCst) {\n+            // The CAS succeeded, so we've created the actual key\n+            0 => {\n+                register_key(key);\n+                key as uint\n+            }\n+            // If someone beat us to the punch, use their key instead\n+            n => { imp::destroy(key); n }\n+        }\n+    }\n+}\n+\n+impl Key {\n+    /// Create a new managed OS TLS key.\n+    ///\n+    /// This key will be deallocated when the key falls out of scope.\n+    ///\n+    /// The argument provided is an optionally-specified destructor for the\n+    /// value of this TLS key. When a thread exits and the value for this key\n+    /// is non-null the destructor will be invoked. The TLS value will be reset\n+    /// to null before the destructor is invoked.\n+    ///\n+    /// Note that the destructor will not be run when the `Key` goes out of\n+    /// scope.\n+    #[inline]\n+    pub fn new(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+        Key { key: unsafe { imp::create(dtor) } }\n+    }\n+\n+    /// See StaticKey::get\n+    #[inline]\n+    pub fn get(&self) -> *mut u8 {\n+        unsafe { imp::get(self.key) }\n+    }\n+\n+    /// See StaticKey::set\n+    #[inline]\n+    pub fn set(&self, val: *mut u8) {\n+        unsafe { imp::set(self.key, val) }\n+    }\n+}\n+\n+impl Drop for Key {\n+    fn drop(&mut self) {\n+        unsafe { imp::destroy(self.key) }\n+    }\n+}\n+\n+fn init_keys() {\n+    let keys = box Exclusive::new(Vec::<imp::Key>::new());\n+    unsafe {\n+        KEYS = mem::transmute(keys);\n+    }\n+\n+    rustrt::at_exit(proc() unsafe {\n+        let keys: Box<Exclusive<Vec<imp::Key>>> = mem::transmute(KEYS);\n+        KEYS = 0 as *mut _;\n+        let keys = keys.lock();\n+        for key in keys.iter() {\n+            imp::destroy(*key);\n+        }\n+    });\n+}\n+\n+fn register_key(key: imp::Key) {\n+    INIT_KEYS.doit(init_keys);\n+    let mut keys = unsafe { (*KEYS).lock() };\n+    keys.push(key);\n+}\n+\n+fn unregister_key(key: imp::Key) {\n+    INIT_KEYS.doit(init_keys);\n+    let mut keys = unsafe { (*KEYS).lock() };\n+    keys.retain(|k| *k != key);\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+    use super::{Key, StaticKey, INIT_INNER};\n+\n+    fn assert_sync<T: Sync>() {}\n+    fn assert_send<T: Send>() {}\n+\n+    #[test]\n+    fn smoke() {\n+        assert_sync::<Key>();\n+        assert_send::<Key>();\n+\n+        let k1 = Key::new(None);\n+        let k2 = Key::new(None);\n+        assert!(k1.get().is_null());\n+        assert!(k2.get().is_null());\n+        k1.set(1 as *mut _);\n+        k2.set(2 as *mut _);\n+        assert_eq!(k1.get() as uint, 1);\n+        assert_eq!(k2.get() as uint, 2);\n+    }\n+\n+    #[test]\n+    fn statik() {\n+        static K1: StaticKey = StaticKey { inner: INIT_INNER, dtor: None };\n+        static K2: StaticKey = StaticKey { inner: INIT_INNER, dtor: None };\n+\n+        unsafe {\n+            assert!(K1.get().is_null());\n+            assert!(K2.get().is_null());\n+            K1.set(1 as *mut _);\n+            K2.set(2 as *mut _);\n+            assert_eq!(K1.get() as uint, 1);\n+            assert_eq!(K2.get() as uint, 2);\n+        }\n+    }\n+}\n+"}, {"sha": "7a5317b578d9346244e038de35b43617545cc13f", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -34,14 +34,15 @@ macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n \n pub mod c;\n pub mod fs;\n+pub mod helper_signal;\n pub mod os;\n-pub mod tcp;\n-pub mod udp;\n pub mod pipe;\n-pub mod helper_signal;\n pub mod process;\n+pub mod tcp;\n pub mod timer;\n+pub mod thread_local;\n pub mod tty;\n+pub mod udp;\n \n pub mod addrinfo {\n     pub use sys_common::net::get_host_addresses;"}, {"sha": "b300e93eeb602b3aabcebb213547f95107326abd", "filename": "src/libstd/sys/unix/thread_local.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread_local.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+use libc::c_int;\n+\n+pub type Key = pthread_key_t;\n+\n+#[inline]\n+pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    let mut key = 0;\n+    assert_eq!(pthread_key_create(&mut key, dtor), 0);\n+    return key;\n+}\n+\n+#[inline]\n+pub unsafe fn set(key: Key, value: *mut u8) {\n+    let r = pthread_setspecific(key, value);\n+    debug_assert_eq!(r, 0);\n+}\n+\n+#[inline]\n+pub unsafe fn get(key: Key) -> *mut u8 {\n+    pthread_getspecific(key)\n+}\n+\n+#[inline]\n+pub unsafe fn destroy(key: Key) {\n+    let r = pthread_key_delete(key);\n+    debug_assert_eq!(r, 0);\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+type pthread_key_t = ::libc::c_ulong;\n+\n+#[cfg(not(target_os = \"macos\"))]\n+type pthread_key_t = ::libc::c_uint;\n+\n+extern {\n+    fn pthread_key_create(key: *mut pthread_key_t,\n+                          dtor: Option<unsafe extern fn(*mut u8)>) -> c_int;\n+    fn pthread_key_delete(key: pthread_key_t) -> c_int;\n+    fn pthread_getspecific(key: pthread_key_t) -> *mut u8;\n+    fn pthread_setspecific(key: pthread_key_t, value: *mut u8) -> c_int;\n+}"}, {"sha": "a785ccfe80465ff8891518d3ccdf70098ef9ba3f", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -35,14 +35,15 @@ macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n \n pub mod c;\n pub mod fs;\n+pub mod helper_signal;\n pub mod os;\n-pub mod tcp;\n-pub mod udp;\n pub mod pipe;\n-pub mod helper_signal;\n pub mod process;\n+pub mod tcp;\n+pub mod thread_local;\n pub mod timer;\n pub mod tty;\n+pub mod udp;\n \n pub mod addrinfo {\n     pub use sys_common::net::get_host_addresses;"}, {"sha": "b841f6d3a2b2ff68199e83f1193ddec9cf5aa203", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -0,0 +1,238 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+\n+use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n+\n+use mem;\n+use rustrt;\n+use rustrt::exclusive::Exclusive;\n+use sync::{ONCE_INIT, Once};\n+\n+pub type Key = DWORD;\n+pub type Dtor = unsafe extern fn(*mut u8);\n+\n+// Turns out, like pretty much everything, Windows is pretty close the\n+// functionality that Unix provides, but slightly different! In the case of\n+// TLS, Windows does not provide an API to provide a destructor for a TLS\n+// variable. This ends up being pretty crucial to this implementation, so we\n+// need a way around this.\n+//\n+// The solution here ended up being a little obscure, but fear not, the\n+// internet has informed me [1][2] that this solution is not unique (no way\n+// I could have thought of it as well!). The key idea is to insert some hook\n+// somewhere to run arbitrary code on thread termination. With this in place\n+// we'll be able to run anything we like, including all TLS destructors!\n+//\n+// To accomplish this feat, we perform a number of tasks, all contained\n+// within this module:\n+//\n+// * All TLS destructors are tracked by *us*, not the windows runtime. This\n+//   means that we have a global list of destructors for each TLS key that\n+//   we know about.\n+// * When a TLS key is destroyed, we're sure to remove it from the dtor list\n+//   if it's in there.\n+// * When a thread exits, we run over the entire list and run dtors for all\n+//   non-null keys. This attempts to match Unix semantics in this regard.\n+//\n+// This ends up having the overhead of using a global list, having some\n+// locks here and there, and in general just adding some more code bloat. We\n+// attempt to optimize runtime by forgetting keys that don't have\n+// destructors, but this only gets us so far.\n+//\n+// For more details and nitty-gritty, see the code sections below!\n+//\n+// [1]: http://www.codeproject.com/Articles/8113/Thread-Local-Storage-The-C-Way\n+// [2]: https://github.com/ChromiumWebApps/chromium/blob/master/base\n+//                        /threading/thread_local_storage_win.cc#L42\n+\n+static INIT_DTORS: Once = ONCE_INIT;\n+static mut DTORS: *mut Exclusive<Vec<(Key, Dtor)>> = 0 as *mut _;\n+\n+// -------------------------------------------------------------------------\n+// Native bindings\n+//\n+// This section is just raw bindings to the native functions that Windows\n+// provides, There's a few extra calls to deal with destructors.\n+\n+#[inline]\n+pub unsafe fn create(dtor: Option<Dtor>) -> Key {\n+    const TLS_OUT_OF_INDEXES: DWORD = 0xFFFFFFFF;\n+    let key = TlsAlloc();\n+    assert!(key != TLS_OUT_OF_INDEXES);\n+    match dtor {\n+        Some(f) => register_dtor(key, f),\n+        None => {}\n+    }\n+    return key;\n+}\n+\n+#[inline]\n+pub unsafe fn set(key: Key, value: *mut u8) {\n+    let r = TlsSetValue(key, value as LPVOID);\n+    debug_assert!(r != 0);\n+}\n+\n+#[inline]\n+pub unsafe fn get(key: Key) -> *mut u8 {\n+    TlsGetValue(key) as *mut u8\n+}\n+\n+#[inline]\n+pub unsafe fn destroy(key: Key) {\n+    if unregister_dtor(key) {\n+        // FIXME: Currently if a key has a destructor associated with it we\n+        // can't actually ever unregister it. If we were to\n+        // unregister it, then any key destruction would have to be\n+        // serialized with respect to actually running destructors.\n+        //\n+        // We want to avoid a race where right before run_dtors runs\n+        // some destructors TlsFree is called. Allowing the call to\n+        // TlsFree would imply that the caller understands that *all\n+        // known threads* are not exiting, which is quite a difficult\n+        // thing to know!\n+        //\n+        // For now we just leak all keys with dtors to \"fix\" this.\n+        // Note that source [2] above shows precedent for this sort\n+        // of strategy.\n+    } else {\n+        let r = TlsFree(key);\n+        debug_assert!(r != 0);\n+    }\n+}\n+\n+extern \"system\" {\n+    fn TlsAlloc() -> DWORD;\n+    fn TlsFree(dwTlsIndex: DWORD) -> BOOL;\n+    fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n+    fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n+}\n+\n+// -------------------------------------------------------------------------\n+// Dtor registration\n+//\n+// These functions are associated with registering and unregistering\n+// destructors. They're pretty simple, they just push onto a vector and scan\n+// a vector currently.\n+//\n+// FIXME: This could probably be at least a little faster with a BTree.\n+\n+fn init_dtors() {\n+    let dtors = box Exclusive::new(Vec::<(Key, Dtor)>::new());\n+    unsafe {\n+        DTORS = mem::transmute(dtors);\n+    }\n+\n+    rustrt::at_exit(proc() unsafe {\n+        mem::transmute::<_, Box<Exclusive<Vec<(Key, Dtor)>>>>(DTORS);\n+        DTORS = 0 as *mut _;\n+    });\n+}\n+\n+unsafe fn register_dtor(key: Key, dtor: Dtor) {\n+    INIT_DTORS.doit(init_dtors);\n+    let mut dtors = (*DTORS).lock();\n+    dtors.push((key, dtor));\n+}\n+\n+unsafe fn unregister_dtor(key: Key) -> bool {\n+    if DTORS.is_null() { return false }\n+    let mut dtors = (*DTORS).lock();\n+    let before = dtors.len();\n+    dtors.retain(|&(k, _)| k != key);\n+    dtors.len() != before\n+}\n+\n+// -------------------------------------------------------------------------\n+// Where the Magic (TM) Happens\n+//\n+// If you're looking at this code, and wondering \"what is this doing?\",\n+// you're not alone! I'll try to break this down step by step:\n+//\n+// # What's up with CRT$XLB?\n+//\n+// For anything about TLS destructors to work on Windows, we have to be able\n+// to run *something* when a thread exits. To do so, we place a very special\n+// static in a very special location. If this is encoded in just the right\n+// way, the kernel's loader is apparently nice enough to run some function\n+// of ours whenever a thread exits! How nice of the kernel!\n+//\n+// Lots of detailed information can be found in source [1] above, but the\n+// gist of it is that this is leveraging a feature of Microsoft's PE format\n+// (executable format) which is not actually used by any compilers today.\n+// This apparently translates to any callbacks in the \".CRT$XLB\" section\n+// being run on certain events.\n+//\n+// So after all that, we use the compiler's #[link_section] feature to place\n+// a callback pointer into the magic section so it ends up being called.\n+//\n+// # What's up with this callback?\n+//\n+// The callback specified receives a number of parameters from... someone!\n+// (the kernel? the runtime? I'm not qute sure!) There are a few events that\n+// this gets invoked for, but we're currentl only interested on when a\n+// thread or a process \"detaches\" (exits). The process part happens for the\n+// last thread and the thread part happens for any normal thread.\n+//\n+// # Ok, what's up with running all these destructors?\n+//\n+// This will likely need to be improved over time, but this function\n+// attempts a \"poor man's\" destructor callback system. To do this we clone a\n+// local copy of the dtor list to start out with. This is our fudgy attempt\n+// to not hold the lock while destructors run and not worry about the list\n+// changing while we're looking at it.\n+//\n+// Once we've got a list of what to run, we iterate over all keys, check\n+// their values, and then run destructors if the values turn out to be non\n+// null (setting them to null just beforehand). We do this a few times in a\n+// loop to basically match Unix semantics. If we don't reach a fixed point\n+// after a short while then we just inevitably leak something most likely.\n+//\n+// # The article mentions crazy stuff about \"/INCLUDE\"?\n+//\n+// It sure does! This seems to work for now, so maybe we'll just run into\n+// that if we start linking with msvc?\n+\n+#[link_section = \".CRT$XLB\"]\n+#[linkage = \"external\"]\n+#[allow(warnings)]\n+pub static p_thread_callback: unsafe extern \"system\" fn(LPVOID, DWORD,\n+                                                        LPVOID) =\n+        on_tls_callback;\n+\n+#[allow(warnings)]\n+unsafe extern \"system\" fn on_tls_callback(h: LPVOID,\n+                                          dwReason: DWORD,\n+                                          pv: LPVOID) {\n+    const DLL_THREAD_DETACH: DWORD = 3;\n+    const DLL_PROCESS_DETACH: DWORD = 0;\n+    if dwReason == DLL_THREAD_DETACH || dwReason == DLL_PROCESS_DETACH {\n+        run_dtors();\n+    }\n+}\n+\n+unsafe fn run_dtors() {\n+    if DTORS.is_null() { return }\n+    let mut any_run = true;\n+    for _ in range(0, 5i) {\n+        if !any_run { break }\n+        any_run = false;\n+        let dtors = (*DTORS).lock().iter().map(|p| *p).collect::<Vec<_>>();\n+        for &(key, dtor) in dtors.iter() {\n+            let ptr = TlsGetValue(key);\n+            if !ptr.is_null() {\n+                TlsSetValue(key, 0 as *mut _);\n+                dtor(ptr as *mut _);\n+                any_run = true;\n+            }\n+        }\n+    }\n+}"}, {"sha": "e2e8461ea54d44d9aa356f0a2b3ac7ed6b4fcd4a", "filename": "src/libstd/thread_local/mod.rs", "status": "added", "additions": 634, "deletions": 0, "changes": 634, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -0,0 +1,634 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Thread local storage\n+//!\n+//! This module provides an implementation of thread local storage for Rust\n+//! programs. Thread local storage is a method of storing data into a global\n+//! variable which each thread in the program will have its own copy of.\n+//! Threads do not share this data, so accesses do not need to be synchronized.\n+//!\n+//! At a high level, this module provides two variants of storage:\n+//!\n+//! * Owning thread local storage. This is a type of thread local key which\n+//!   owns the value that it contains, and will destroy the value when the\n+//!   thread exits. This variant is created with the `thread_local!` macro and\n+//!   can contain any value which is `'static` (no borrowed pointers.\n+//!\n+//! * Scoped thread local storage. This type of key is used to store a reference\n+//!   to a value into local storage temporarily for the scope of a function\n+//!   call. There are no restrictions on what types of values can be placed\n+//!   into this key.\n+//!\n+//! Both forms of thread local storage provide an accessor function, `with`,\n+//! which will yield a shared reference to the value to the specified\n+//! closure. Thread local keys only allow shared access to values as there is no\n+//! way to guarantee uniqueness if a mutable borrow was allowed. Most values\n+//! will want to make use of some form of **interior mutability** through the\n+//! `Cell` or `RefCell` types.\n+\n+#![macro_escape]\n+#![experimental]\n+\n+use prelude::*;\n+\n+use cell::UnsafeCell;\n+\n+// Sure wish we had macro hygiene, no?\n+#[doc(hidden)] pub use self::imp::Key as KeyInner;\n+#[doc(hidden)] pub use self::imp::destroy_value;\n+#[doc(hidden)] pub use sys_common::thread_local::INIT_INNER as OS_INIT_INNER;\n+#[doc(hidden)] pub use sys_common::thread_local::StaticKey as OsStaticKey;\n+\n+pub mod scoped;\n+\n+/// A thread local storage key which owns its contents.\n+///\n+/// This key uses the fastest possible implementation available to it for the\n+/// target platform. It is instantiated with the `thread_local!` macro and the\n+/// primary method is the `with` method.\n+///\n+/// The `with` method yields a reference to the contained value which cannot be\n+/// sent across tasks or escape the given closure.\n+///\n+/// # Initialization and Destruction\n+///\n+/// Initialization is dynamically performed on the first call to `with()`\n+/// within a thread, and values support destructors which will be run when a\n+/// thread exits.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::cell::RefCell;\n+///\n+/// thread_local!(static FOO: RefCell<uint> = RefCell::new(1));\n+///\n+/// FOO.with(|f| {\n+///     assert_eq!(*f.borrow(), 1);\n+///     *f.borrow_mut() = 2;\n+/// });\n+///\n+/// // each thread starts out with the initial value of 1\n+/// spawn(proc() {\n+///     FOO.with(|f| {\n+///         assert_eq!(*f.borrow(), 1);\n+///         *f.borrow_mut() = 3;\n+///     });\n+/// });\n+///\n+/// // we retain our original value of 2 despite the child thread\n+/// FOO.with(|f| {\n+///     assert_eq!(*f.borrow(), 2);\n+/// });\n+/// ```\n+pub struct Key<T> {\n+    // The key itself may be tagged with #[thread_local], and this `Key` is\n+    // stored as a `static`, and it's not valid for a static to reference the\n+    // address of another thread_local static. For this reason we kinda wonkily\n+    // work around this by generating a shim function which will give us the\n+    // address of the inner TLS key at runtime.\n+    //\n+    // This is trivially devirtualizable by LLVM because we never store anything\n+    // to this field and rustc can declare the `static` as constant as well.\n+    #[doc(hidden)]\n+    pub inner: fn() -> &'static KeyInner<UnsafeCell<Option<T>>>,\n+\n+    // initialization routine to invoke to create a value\n+    #[doc(hidden)]\n+    pub init: fn() -> T,\n+}\n+\n+/// Declare a new thread local storage key of type `std::thread_local::Key`.\n+#[macro_export]\n+#[doc(hidden)]\n+macro_rules! thread_local(\n+    (static $name:ident: $t:ty = $init:expr) => (\n+        static $name: ::std::thread_local::Key<$t> = {\n+            use std::cell::UnsafeCell as __UnsafeCell;\n+            use std::thread_local::KeyInner as __KeyInner;\n+            use std::option::Option as __Option;\n+            use std::option::None as __None;\n+\n+            __thread_local_inner!(static __KEY: __UnsafeCell<__Option<$t>> = {\n+                __UnsafeCell { value: __None }\n+            })\n+            fn __init() -> $t { $init }\n+            fn __getit() -> &'static __KeyInner<__UnsafeCell<__Option<$t>>> {\n+                &__KEY\n+            }\n+            ::std::thread_local::Key { inner: __getit, init: __init }\n+        };\n+    );\n+    (pub static $name:ident: $t:ty = $init:expr) => (\n+        pub static $name: ::std::thread_local::Key<$t> = {\n+            use std::cell::UnsafeCell as __UnsafeCell;\n+            use std::thread_local::KeyInner as __KeyInner;\n+            use std::option::Option as __Option;\n+            use std::option::None as __None;\n+\n+            __thread_local_inner!(static __KEY: __UnsafeCell<__Option<$t>> = {\n+                __UnsafeCell { value: __None }\n+            })\n+            fn __init() -> $t { $init }\n+            fn __getit() -> &'static __KeyInner<__UnsafeCell<__Option<$t>>> {\n+                &__KEY\n+            }\n+            ::std::thread_local::Key { inner: __getit, init: __init }\n+        };\n+    );\n+)\n+\n+// Macro pain #4586:\n+//\n+// When cross compiling, rustc will load plugins and macros from the *host*\n+// platform before search for macros from the target platform. This is primarily\n+// done to detect, for example, plugins. Ideally the macro below would be\n+// defined once per module below, but unfortunately this means we have the\n+// following situation:\n+//\n+// 1. We compile libstd for x86_64-unknown-linux-gnu, this thread_local!() macro\n+//    will inject #[thread_local] statics.\n+// 2. We then try to compile a program for arm-linux-androideabi\n+// 3. The compiler has a host of linux and a target of android, so it loads\n+//    macros from the *linux* libstd.\n+// 4. The macro generates a #[thread_local] field, but the android libstd does\n+//    not use #[thread_local]\n+// 5. Compile error about structs with wrong fields.\n+//\n+// To get around this, we're forced to inject the #[cfg] logic into the macro\n+// itself. Woohoo.\n+\n+#[macro_export]\n+macro_rules! __thread_local_inner(\n+    (static $name:ident: $t:ty = $init:expr) => (\n+        #[cfg_attr(any(target_os = \"macos\", target_os = \"linux\"), thread_local)]\n+        static $name: ::std::thread_local::KeyInner<$t> =\n+            __thread_local_inner!($init, $t);\n+    );\n+    (pub static $name:ident: $t:ty = $init:expr) => (\n+        #[cfg_attr(any(target_os = \"macos\", target_os = \"linux\"), thread_local)]\n+        pub static $name: ::std::thread_local::KeyInner<$t> =\n+            __thread_local_inner!($init, $t);\n+    );\n+    ($init:expr, $t:ty) => ({\n+        #[cfg(any(target_os = \"macos\", target_os = \"linux\"))]\n+        const INIT: ::std::thread_local::KeyInner<$t> = {\n+            ::std::thread_local::KeyInner {\n+                inner: ::std::cell::UnsafeCell { value: $init },\n+                dtor_registered: ::std::cell::UnsafeCell { value: false },\n+                dtor_running: ::std::cell::UnsafeCell { value: false },\n+                marker: ::std::kinds::marker::NoCopy,\n+            }\n+        };\n+\n+        #[cfg(not(any(target_os = \"macos\", target_os = \"linux\")))]\n+        const INIT: ::std::thread_local::KeyInner<$t> = {\n+            unsafe extern fn __destroy(ptr: *mut u8) {\n+                ::std::thread_local::destroy_value::<$t>(ptr);\n+            }\n+            ::std::thread_local::KeyInner {\n+                inner: ::std::cell::UnsafeCell { value: $init },\n+                os: ::std::thread_local::OsStaticKey {\n+                    inner: ::std::thread_local::OS_INIT_INNER,\n+                    dtor: ::std::option::Some(__destroy),\n+                },\n+            }\n+        };\n+\n+        INIT\n+    });\n+)\n+\n+impl<T: 'static> Key<T> {\n+    /// Acquire a reference to the value in this TLS key.\n+    ///\n+    /// This will lazily initialize the value if this thread has not referenced\n+    /// this key yet.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will `panic!()` if the key currently has its\n+    /// destructor running, and it **may** panic if the destructor has\n+    /// previously been run for this thread.\n+    pub fn with<R>(&'static self, f: |&T| -> R) -> R {\n+        let slot = (self.inner)();\n+        unsafe {\n+            let slot = slot.get().expect(\"cannot access a TLS value during or \\\n+                                          after it is destroyed\");\n+            if (*slot.get()).is_none() {\n+                *slot.get() = Some((self.init)());\n+            }\n+            f((*slot.get()).as_ref().unwrap())\n+        }\n+    }\n+\n+    /// Test this TLS key to determine whether its value has been destroyed for\n+    /// the current thread or not.\n+    ///\n+    /// This will not initialize the key if it is not already initialized.\n+    pub fn destroyed(&'static self) -> bool {\n+        unsafe { (self.inner)().get().is_none() }\n+    }\n+}\n+\n+#[cfg(any(target_os = \"macos\", target_os = \"linux\"))]\n+mod imp {\n+    use prelude::*;\n+\n+    use cell::UnsafeCell;\n+    use intrinsics;\n+    use kinds::marker;\n+    use ptr;\n+\n+    #[doc(hidden)]\n+    pub struct Key<T> {\n+        // Place the inner bits in an `UnsafeCell` to currently get around the\n+        // \"only Sync statics\" restriction. This allows any type to be placed in\n+        // the cell.\n+        //\n+        // Note that all access requires `T: 'static` so it can't be a type with\n+        // any borrowed pointers still.\n+        pub inner: UnsafeCell<T>,\n+\n+        // Metadata to keep track of the state of the destructor. Remember that\n+        // these variables are thread-local, not global.\n+        pub dtor_registered: UnsafeCell<bool>, // should be Cell\n+        pub dtor_running: UnsafeCell<bool>, // should be Cell\n+\n+        // These shouldn't be copied around.\n+        pub marker: marker::NoCopy,\n+    }\n+\n+    #[doc(hidden)]\n+    impl<T> Key<T> {\n+        pub unsafe fn get(&'static self) -> Option<&'static T> {\n+            if intrinsics::needs_drop::<T>() && *self.dtor_running.get() {\n+                return None\n+            }\n+            self.register_dtor();\n+            Some(&*self.inner.get())\n+        }\n+\n+        unsafe fn register_dtor(&self) {\n+            if !intrinsics::needs_drop::<T>() || *self.dtor_registered.get() {\n+                return\n+            }\n+\n+            register_dtor(self as *const _ as *mut u8,\n+                          destroy_value::<T>);\n+            *self.dtor_registered.get() = true;\n+        }\n+    }\n+\n+    // Since what appears to be glibc 2.18 this symbol has been shipped which\n+    // GCC and clang both use to invoke destructors in thread_local globals, so\n+    // let's do the same!\n+    //\n+    // Note, however, that we run on lots older linuxes, as well as cross\n+    // compiling from a newer linux to an older linux, so we also have a\n+    // fallback implementation to use as well.\n+    //\n+    // Due to rust-lang/rust#18804, make sure this is not generic!\n+    #[cfg(target_os = \"linux\")]\n+    unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+        use mem;\n+        use libc;\n+        use sys_common::thread_local as os;\n+\n+        extern {\n+            static __dso_handle: *mut u8;\n+            #[linkage = \"extern_weak\"]\n+            static __cxa_thread_atexit_impl: *const ();\n+        }\n+        if !__cxa_thread_atexit_impl.is_null() {\n+            type F = unsafe extern fn(dtor: unsafe extern fn(*mut u8),\n+                                      arg: *mut u8,\n+                                      dso_handle: *mut u8) -> libc::c_int;\n+            mem::transmute::<*const (), F>(__cxa_thread_atexit_impl)\n+            (dtor, t, __dso_handle);\n+            return\n+        }\n+\n+        // The fallback implementation uses a vanilla OS-based TLS key to track\n+        // the list of destructors that need to be run for this thread. The key\n+        // then has its own destructor which runs all the other destructors.\n+        //\n+        // The destructor for DTORS is a little special in that it has a `while`\n+        // loop to continuously drain the list of registered destructors. It\n+        // *should* be the case that this loop always terminates because we\n+        // provide the guarantee that a TLS key cannot be set after it is\n+        // flagged for destruction.\n+        static DTORS: os::StaticKey = os::StaticKey {\n+            inner: os::INIT_INNER,\n+            dtor: Some(run_dtors),\n+        };\n+        type List = Vec<(*mut u8, unsafe extern fn(*mut u8))>;\n+        if DTORS.get().is_null() {\n+            let v: Box<List> = box Vec::new();\n+            DTORS.set(mem::transmute(v));\n+        }\n+        let list: &mut List = &mut *(DTORS.get() as *mut List);\n+        list.push((t, dtor));\n+\n+        unsafe extern fn run_dtors(mut ptr: *mut u8) {\n+            while !ptr.is_null() {\n+                let list: Box<List> = mem::transmute(ptr);\n+                for &(ptr, dtor) in list.iter() {\n+                    dtor(ptr);\n+                }\n+                ptr = DTORS.get();\n+                DTORS.set(0 as *mut _);\n+            }\n+        }\n+    }\n+\n+    // OSX's analog of the above linux function is this _tlv_atexit function.\n+    // The disassembly of thread_local globals in C++ (at least produced by\n+    // clang) will have this show up in the output.\n+    #[cfg(target_os = \"macos\")]\n+    unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n+        extern {\n+            fn _tlv_atexit(dtor: unsafe extern fn(*mut u8),\n+                           arg: *mut u8);\n+        }\n+        _tlv_atexit(dtor, t);\n+    }\n+\n+    #[doc(hidden)]\n+    pub unsafe extern fn destroy_value<T>(ptr: *mut u8) {\n+        let ptr = ptr as *mut Key<T>;\n+        // Right before we run the user destructor be sure to flag the\n+        // destructor as running for this thread so calls to `get` will return\n+        // `None`.\n+        *(*ptr).dtor_running.get() = true;\n+        ptr::read((*ptr).inner.get() as *const T);\n+    }\n+}\n+\n+#[cfg(not(any(target_os = \"macos\", target_os = \"linux\")))]\n+mod imp {\n+    use prelude::*;\n+\n+    use cell::UnsafeCell;\n+    use mem;\n+    use sys_common::thread_local::StaticKey as OsStaticKey;\n+\n+    #[doc(hidden)]\n+    pub struct Key<T> {\n+        // Statically allocated initialization expression, using an `UnsafeCell`\n+        // for the same reasons as above.\n+        pub inner: UnsafeCell<T>,\n+\n+        // OS-TLS key that we'll use to key off.\n+        pub os: OsStaticKey,\n+    }\n+\n+    struct Value<T: 'static> {\n+        key: &'static Key<T>,\n+        value: T,\n+    }\n+\n+    #[doc(hidden)]\n+    impl<T> Key<T> {\n+        pub unsafe fn get(&'static self) -> Option<&'static T> {\n+            self.ptr().map(|p| &*p)\n+        }\n+\n+        unsafe fn ptr(&'static self) -> Option<*mut T> {\n+            let ptr = self.os.get() as *mut Value<T>;\n+            if !ptr.is_null() {\n+                if ptr as uint == 1 {\n+                    return None\n+                }\n+                return Some(&mut (*ptr).value as *mut T);\n+            }\n+\n+            // If the lookup returned null, we haven't initialized our own local\n+            // copy, so do that now.\n+            //\n+            // Also note that this transmute_copy should be ok because the value\n+            // `inner` is already validated to be a valid `static` value, so we\n+            // should be able to freely copy the bits.\n+            let ptr: Box<Value<T>> = box Value {\n+                key: self,\n+                value: mem::transmute_copy(&self.inner),\n+            };\n+            let ptr: *mut Value<T> = mem::transmute(ptr);\n+            self.os.set(ptr as *mut u8);\n+            Some(&mut (*ptr).value as *mut T)\n+        }\n+    }\n+\n+    #[doc(hidden)]\n+    pub unsafe extern fn destroy_value<T: 'static>(ptr: *mut u8) {\n+        // The OS TLS ensures that this key contains a NULL value when this\n+        // destructor starts to run. We set it back to a sentinel value of 1 to\n+        // ensure that any future calls to `get` for this thread will return\n+        // `None`.\n+        //\n+        // Note that to prevent an infinite loop we reset it back to null right\n+        // before we return from the destructor ourselves.\n+        let ptr: Box<Value<T>> = mem::transmute(ptr);\n+        let key = ptr.key;\n+        key.os.set(1 as *mut u8);\n+        drop(ptr);\n+        key.os.set(0 as *mut u8);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+\n+    use cell::UnsafeCell;\n+    use rustrt::thread::Thread;\n+\n+    struct Foo(Sender<()>);\n+\n+    impl Drop for Foo {\n+        fn drop(&mut self) {\n+            let Foo(ref s) = *self;\n+            s.send(());\n+        }\n+    }\n+\n+    #[test]\n+    fn smoke_no_dtor() {\n+        thread_local!(static FOO: UnsafeCell<int> = UnsafeCell { value: 1 })\n+\n+        FOO.with(|f| unsafe {\n+            assert_eq!(*f.get(), 1);\n+            *f.get() = 2;\n+        });\n+        let (tx, rx) = channel();\n+        spawn(proc() {\n+            FOO.with(|f| unsafe {\n+                assert_eq!(*f.get(), 1);\n+            });\n+            tx.send(());\n+        });\n+        rx.recv();\n+\n+        FOO.with(|f| unsafe {\n+            assert_eq!(*f.get(), 2);\n+        });\n+    }\n+\n+    #[test]\n+    fn smoke_dtor() {\n+        thread_local!(static FOO: UnsafeCell<Option<Foo>> = UnsafeCell {\n+            value: None\n+        })\n+\n+        let (tx, rx) = channel();\n+        spawn(proc() unsafe {\n+            let mut tx = Some(tx);\n+            FOO.with(|f| {\n+                *f.get() = Some(Foo(tx.take().unwrap()));\n+            });\n+        });\n+        rx.recv();\n+    }\n+\n+    #[test]\n+    fn circular() {\n+        struct S1;\n+        struct S2;\n+        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell {\n+            value: None\n+        })\n+        thread_local!(static K2: UnsafeCell<Option<S2>> = UnsafeCell {\n+            value: None\n+        })\n+        static mut HITS: uint = 0;\n+\n+        impl Drop for S1 {\n+            fn drop(&mut self) {\n+                unsafe {\n+                    HITS += 1;\n+                    if K2.destroyed() {\n+                        assert_eq!(HITS, 3);\n+                    } else {\n+                        if HITS == 1 {\n+                            K2.with(|s| *s.get() = Some(S2));\n+                        } else {\n+                            assert_eq!(HITS, 3);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        impl Drop for S2 {\n+            fn drop(&mut self) {\n+                unsafe {\n+                    HITS += 1;\n+                    assert!(!K1.destroyed());\n+                    assert_eq!(HITS, 2);\n+                    K1.with(|s| *s.get() = Some(S1));\n+                }\n+            }\n+        }\n+\n+        Thread::start(proc() {\n+            drop(S1);\n+        }).join();\n+    }\n+\n+    #[test]\n+    fn self_referential() {\n+        struct S1;\n+        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell {\n+            value: None\n+        })\n+\n+        impl Drop for S1 {\n+            fn drop(&mut self) {\n+                assert!(K1.destroyed());\n+            }\n+        }\n+\n+        Thread::start(proc() unsafe {\n+            K1.with(|s| *s.get() = Some(S1));\n+        }).join();\n+    }\n+\n+    #[test]\n+    fn dtors_in_dtors_in_dtors() {\n+        struct S1(Sender<()>);\n+        thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell {\n+            value: None\n+        })\n+        thread_local!(static K2: UnsafeCell<Option<Foo>> = UnsafeCell {\n+            value: None\n+        })\n+\n+        impl Drop for S1 {\n+            fn drop(&mut self) {\n+                let S1(ref tx) = *self;\n+                unsafe {\n+                    if !K2.destroyed() {\n+                        K2.with(|s| *s.get() = Some(Foo(tx.clone())));\n+                    }\n+                }\n+            }\n+        }\n+\n+        let (tx, rx) = channel();\n+        spawn(proc() unsafe {\n+            let mut tx = Some(tx);\n+            K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n+        });\n+        rx.recv();\n+    }\n+}\n+\n+#[cfg(test)]\n+mod dynamic_tests {\n+    use prelude::*;\n+\n+    use cell::RefCell;\n+    use collections::HashMap;\n+\n+    #[test]\n+    fn smoke() {\n+        fn square(i: int) -> int { i * i }\n+        thread_local!(static FOO: int = square(3))\n+\n+        FOO.with(|f| {\n+            assert_eq!(*f, 9);\n+        });\n+    }\n+\n+    #[test]\n+    fn hashmap() {\n+        fn map() -> RefCell<HashMap<int, int>> {\n+            let mut m = HashMap::new();\n+            m.insert(1, 2);\n+            RefCell::new(m)\n+        }\n+        thread_local!(static FOO: RefCell<HashMap<int, int>> = map())\n+\n+        FOO.with(|map| {\n+            assert_eq!(map.borrow()[1], 2);\n+        });\n+    }\n+\n+    #[test]\n+    fn refcell_vec() {\n+        thread_local!(static FOO: RefCell<Vec<uint>> = RefCell::new(vec![1, 2, 3]))\n+\n+        FOO.with(|vec| {\n+            assert_eq!(vec.borrow().len(), 3);\n+            vec.borrow_mut().push(4);\n+            assert_eq!(vec.borrow()[3], 4);\n+        });\n+    }\n+}"}, {"sha": "11d539c4f9fa8e4adea6b13e420f1b114a62b54e", "filename": "src/libstd/thread_local/scoped.rs", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -0,0 +1,261 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Scoped thread-local storage\n+//!\n+//! This module provides the ability to generate *scoped* thread-local\n+//! variables. In this sense, scoped indicates that thread local storage\n+//! actually stores a reference to a value, and this reference is only placed\n+//! in storage for a scoped amount of time.\n+//!\n+//! There are no restrictions on what types can be placed into a scoped\n+//! variable, but all scoped variables are initialized to the equivalent of\n+//! null. Scoped thread local stor is useful when a value is present for a known\n+//! period of time and it is not required to relinquish ownership of the\n+//! contents.\n+//!\n+//! # Example\n+//!\n+//! ```\n+//! scoped_thread_local!(static FOO: uint)\n+//!\n+//! // Initially each scoped slot is empty.\n+//! assert!(!FOO.is_set());\n+//!\n+//! // When inserting a value, the value is only in place for the duration\n+//! // of the closure specified.\n+//! FOO.set(&1, || {\n+//!     FOO.with(|slot| {\n+//!         assert_eq!(*slot, 1);\n+//!     });\n+//! });\n+//! ```\n+\n+#![macro_escape]\n+\n+use prelude::*;\n+\n+// macro hygiene sure would be nice, wouldn't it?\n+#[doc(hidden)] pub use self::imp::KeyInner;\n+#[doc(hidden)] pub use sys_common::thread_local::INIT as OS_INIT;\n+\n+/// Type representing a thread local storage key corresponding to a reference\n+/// to the type parameter `T`.\n+///\n+/// Keys are statically allocated and can contain a reference to an instance of\n+/// type `T` scoped to a particular lifetime. Keys provides two methods, `set`\n+/// and `with`, both of which currently use closures to control the scope of\n+/// their contents.\n+pub struct Key<T> { #[doc(hidden)] pub inner: KeyInner<T> }\n+\n+/// Declare a new scoped thread local storage key.\n+///\n+/// This macro declares a `static` item on which methods are used to get and\n+/// set the value stored within.\n+#[macro_export]\n+macro_rules! scoped_thread_local(\n+    (static $name:ident: $t:ty) => (\n+        __scoped_thread_local_inner!(static $name: $t)\n+    );\n+    (pub static $name:ident: $t:ty) => (\n+        __scoped_thread_local_inner!(pub static $name: $t)\n+    );\n+)\n+\n+#[macro_export]\n+#[doc(hidden)]\n+macro_rules! __scoped_thread_local_inner(\n+    (static $name:ident: $t:ty) => (\n+        #[cfg_attr(not(any(windows, target_os = \"android\", target_os = \"ios\")),\n+                   thread_local)]\n+        static $name: ::std::thread_local::scoped::Key<$t> =\n+            __scoped_thread_local_inner!($t);\n+    );\n+    (pub static $name:ident: $t:ty) => (\n+        #[cfg_attr(not(any(windows, target_os = \"android\", target_os = \"ios\")),\n+                   thread_local)]\n+        pub static $name: ::std::thread_local::scoped::Key<$t> =\n+            __scoped_thread_local_inner!($t);\n+    );\n+    ($t:ty) => ({\n+        use std::thread_local::scoped::Key as __Key;\n+\n+        #[cfg(not(any(windows, target_os = \"android\", target_os = \"ios\")))]\n+        const INIT: __Key<$t> = __Key {\n+            inner: ::std::thread_local::scoped::KeyInner {\n+                inner: ::std::cell::UnsafeCell { value: 0 as *mut _ },\n+            }\n+        };\n+\n+        #[cfg(any(windows, target_os = \"android\", target_os = \"ios\"))]\n+        const INIT: __Key<$t> = __Key {\n+            inner: ::std::thread_local::scoped::KeyInner {\n+                inner: ::std::thread_local::scoped::OS_INIT,\n+                marker: ::std::kinds::marker::InvariantType,\n+            }\n+        };\n+\n+        INIT\n+    })\n+)\n+\n+impl<T> Key<T> {\n+    /// Insert a value into this scoped thread local storage slot for a\n+    /// duration of a closure.\n+    ///\n+    /// While `cb` is running, the value `t` will be returned by `get` unless\n+    /// this function is called recursively inside of `cb`.\n+    ///\n+    /// Upon return, this function will restore the previous value, if any\n+    /// was available.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// scoped_thread_local!(static FOO: uint)\n+    ///\n+    /// FOO.set(&100, || {\n+    ///     let val = FOO.with(|v| *v);\n+    ///     assert_eq!(val, 100);\n+    ///\n+    ///     // set can be called recursively\n+    ///     FOO.set(&101, || {\n+    ///         // ...\n+    ///     });\n+    ///\n+    ///     // Recursive calls restore the previous value.\n+    ///     let val = FOO.with(|v| *v);\n+    ///     assert_eq!(val, 100);\n+    /// });\n+    /// ```\n+    pub fn set<R>(&'static self, t: &T, cb: || -> R) -> R {\n+        struct Reset<'a, T: 'a> {\n+            key: &'a KeyInner<T>,\n+            val: *mut T,\n+        }\n+        #[unsafe_destructor]\n+        impl<'a, T> Drop for Reset<'a, T> {\n+            fn drop(&mut self) {\n+                unsafe { self.key.set(self.val) }\n+            }\n+        }\n+\n+        let prev = unsafe {\n+            let prev = self.inner.get();\n+            self.inner.set(t as *const T as *mut T);\n+            prev\n+        };\n+\n+        let _reset = Reset { key: &self.inner, val: prev };\n+        cb()\n+    }\n+\n+    /// Get a value out of this scoped variable.\n+    ///\n+    /// This function takes a closure which receives the value of this\n+    /// variable.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if `set` has not previously been called.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// scoped_thread_local!(static FOO: uint)\n+    ///\n+    /// FOO.with(|slot| {\n+    ///     // work with `slot`\n+    /// });\n+    /// ```\n+    pub fn with<R>(&'static self, cb: |&T| -> R) -> R {\n+        unsafe {\n+            let ptr = self.inner.get();\n+            assert!(!ptr.is_null(), \"cannot access a scoped thread local \\\n+                                     variable without calling `set` first\");\n+            cb(&*ptr)\n+        }\n+    }\n+\n+    /// Test whether this TLS key has been `set` for the current thread.\n+    pub fn is_set(&'static self) -> bool {\n+        unsafe { !self.inner.get().is_null() }\n+    }\n+}\n+\n+#[cfg(not(any(windows, target_os = \"android\", target_os = \"ios\")))]\n+mod imp {\n+    use std::cell::UnsafeCell;\n+\n+    // FIXME: Should be a `Cell`, but that's not `Sync`\n+    #[doc(hidden)]\n+    pub struct KeyInner<T> { pub inner: UnsafeCell<*mut T> }\n+\n+    #[doc(hidden)]\n+    impl<T> KeyInner<T> {\n+        #[doc(hidden)]\n+        pub unsafe fn set(&self, ptr: *mut T) { *self.inner.get() = ptr; }\n+        #[doc(hidden)]\n+        pub unsafe fn get(&self) -> *mut T { *self.inner.get() }\n+    }\n+}\n+\n+#[cfg(any(windows, target_os = \"android\", target_os = \"ios\"))]\n+mod imp {\n+    use kinds::marker;\n+    use sys_common::thread_local::StaticKey as OsStaticKey;\n+\n+    #[doc(hidden)]\n+    pub struct KeyInner<T> {\n+        pub inner: OsStaticKey,\n+        pub marker: marker::InvariantType<T>,\n+    }\n+\n+    #[doc(hidden)]\n+    impl<T> KeyInner<T> {\n+        #[doc(hidden)]\n+        pub unsafe fn set(&self, ptr: *mut T) { self.inner.set(ptr as *mut _) }\n+        #[doc(hidden)]\n+        pub unsafe fn get(&self) -> *mut T { self.inner.get() as *mut _ }\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use cell::Cell;\n+    use prelude::*;\n+\n+    #[test]\n+    fn smoke() {\n+        scoped_thread_local!(static BAR: uint)\n+\n+        assert!(!BAR.is_set());\n+        BAR.set(&1, || {\n+            assert!(BAR.is_set());\n+            BAR.with(|slot| {\n+                assert_eq!(*slot, 1);\n+            });\n+        });\n+        assert!(!BAR.is_set());\n+    }\n+\n+    #[test]\n+    fn cell_allowed() {\n+        scoped_thread_local!(static BAR: Cell<uint>)\n+\n+        BAR.set(&Cell::new(1), || {\n+            BAR.with(|slot| {\n+                assert_eq!(slot.get(), 1);\n+            });\n+        });\n+    }\n+}\n+"}, {"sha": "fdfa275549a2cc73a62fc5f9f19c6c2efb30a5ac", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -25,21 +25,20 @@ use parse::token::InternedString;\n use parse::token;\n use ptr::P;\n \n-use std::collections::HashSet;\n+use std::cell::{RefCell, Cell};\n use std::collections::BitvSet;\n+use std::collections::HashSet;\n \n-local_data_key!(used_attrs: BitvSet)\n+thread_local!(static USED_ATTRS: RefCell<BitvSet> = RefCell::new(BitvSet::new()))\n \n pub fn mark_used(attr: &Attribute) {\n-    let mut used = used_attrs.replace(None).unwrap_or_else(|| BitvSet::new());\n     let AttrId(id) = attr.node.id;\n-    used.insert(id);\n-    used_attrs.replace(Some(used));\n+    USED_ATTRS.with(|slot| slot.borrow_mut().insert(id));\n }\n \n pub fn is_used(attr: &Attribute) -> bool {\n     let AttrId(id) = attr.node.id;\n-    used_attrs.get().map_or(false, |used| used.contains(&id))\n+    USED_ATTRS.with(|slot| slot.borrow().contains(&id))\n }\n \n pub trait AttrMetaMethods {\n@@ -167,11 +166,14 @@ pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n     P(dummy_spanned(MetaWord(name)))\n }\n \n-local_data_key!(next_attr_id: uint)\n+thread_local!(static NEXT_ATTR_ID: Cell<uint> = Cell::new(0))\n \n pub fn mk_attr_id() -> AttrId {\n-    let id = next_attr_id.replace(None).unwrap_or(0);\n-    next_attr_id.replace(Some(id + 1));\n+    let id = NEXT_ATTR_ID.with(|slot| {\n+        let r = slot.get();\n+        slot.set(r + 1);\n+        r\n+    });\n     AttrId(id)\n }\n "}, {"sha": "5f4e675aad5d5676fc4b3f8c5f7cc6a2b085a435", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -18,31 +18,23 @@ use ext::build::AstBuilder;\n use parse::token;\n use ptr::P;\n \n-local_data_key!(registered_diagnostics: RefCell<HashMap<Name, Option<Name>>>)\n-local_data_key!(used_diagnostics: RefCell<HashMap<Name, Span>>)\n+thread_local!(static REGISTERED_DIAGNOSTICS: RefCell<HashMap<Name, Option<Name>>> = {\n+    RefCell::new(HashMap::new())\n+})\n+thread_local!(static USED_DIAGNOSTICS: RefCell<HashMap<Name, Span>> = {\n+    RefCell::new(HashMap::new())\n+})\n \n fn with_registered_diagnostics<T>(f: |&mut HashMap<Name, Option<Name>>| -> T) -> T {\n-    match registered_diagnostics.get() {\n-        Some(cell) => f(cell.borrow_mut().deref_mut()),\n-        None => {\n-            let mut map = HashMap::new();\n-            let value = f(&mut map);\n-            registered_diagnostics.replace(Some(RefCell::new(map)));\n-            value\n-        }\n-    }\n+    REGISTERED_DIAGNOSTICS.with(|slot| {\n+        f(&mut *slot.borrow_mut())\n+    })\n }\n \n fn with_used_diagnostics<T>(f: |&mut HashMap<Name, Span>| -> T) -> T {\n-    match used_diagnostics.get() {\n-        Some(cell) => f(cell.borrow_mut().deref_mut()),\n-        None => {\n-            let mut map = HashMap::new();\n-            let value = f(&mut map);\n-            used_diagnostics.replace(Some(RefCell::new(map)));\n-            value\n-        }\n-    }\n+    USED_DIAGNOSTICS.with(|slot| {\n+        f(&mut *slot.borrow_mut())\n+    })\n }\n \n pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,"}, {"sha": "e6d886e28ba7fcb113e4b535a2fafbf812bc721a", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 7, "deletions": 21, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -20,7 +20,6 @@ pub use self::SyntaxContext_::*;\n use ast::{Ident, Mrk, Name, SyntaxContext};\n \n use std::cell::RefCell;\n-use std::rc::Rc;\n use std::collections::HashMap;\n use std::collections::hash_map::{Occupied, Vacant};\n \n@@ -105,16 +104,8 @@ pub fn apply_renames(renames: &RenameList, ctxt: SyntaxContext) -> SyntaxContext\n \n /// Fetch the SCTable from TLS, create one if it doesn't yet exist.\n pub fn with_sctable<T>(op: |&SCTable| -> T) -> T {\n-    local_data_key!(sctable_key: Rc<SCTable>)\n-\n-    match sctable_key.get() {\n-        Some(ts) => op(&**ts),\n-        None => {\n-            let ts = Rc::new(new_sctable_internal());\n-            sctable_key.replace(Some(ts.clone()));\n-            op(&*ts)\n-        }\n-    }\n+    thread_local!(static SCTABLE_KEY: SCTable = new_sctable_internal())\n+    SCTABLE_KEY.with(|slot| op(slot))\n }\n \n // Make a fresh syntax context table with EmptyCtxt in slot zero\n@@ -165,16 +156,11 @@ type ResolveTable = HashMap<(Name,SyntaxContext),Name>;\n // okay, I admit, putting this in TLS is not so nice:\n // fetch the SCTable from TLS, create one if it doesn't yet exist.\n fn with_resolve_table_mut<T>(op: |&mut ResolveTable| -> T) -> T {\n-    local_data_key!(resolve_table_key: Rc<RefCell<ResolveTable>>)\n-\n-    match resolve_table_key.get() {\n-        Some(ts) => op(&mut *ts.borrow_mut()),\n-        None => {\n-            let ts = Rc::new(RefCell::new(HashMap::new()));\n-            resolve_table_key.replace(Some(ts.clone()));\n-            op(&mut *ts.borrow_mut())\n-        }\n-    }\n+    thread_local!(static RESOLVE_TABLE_KEY: RefCell<ResolveTable> = {\n+        RefCell::new(HashMap::new())\n+    })\n+\n+    RESOLVE_TABLE_KEY.with(|slot| op(&mut *slot.borrow_mut()))\n }\n \n /// Resolve a syntax object to a name, per MTWT."}, {"sha": "3a3407aedba9647ebc13677dddb614c75114bfef", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -560,15 +560,10 @@ pub type IdentInterner = StrInterner;\n // fresh one.\n // FIXME(eddyb) #8726 This should probably use a task-local reference.\n pub fn get_ident_interner() -> Rc<IdentInterner> {\n-    local_data_key!(key: Rc<::parse::token::IdentInterner>)\n-    match key.get() {\n-        Some(interner) => interner.clone(),\n-        None => {\n-            let interner = Rc::new(mk_fresh_ident_interner());\n-            key.replace(Some(interner.clone()));\n-            interner\n-        }\n-    }\n+    thread_local!(static KEY: Rc<::parse::token::IdentInterner> = {\n+        Rc::new(mk_fresh_ident_interner())\n+    })\n+    KEY.with(|k| k.clone())\n }\n \n /// Represents a string stored in the task-local interner. Because the"}, {"sha": "021eae90cf8005a51c740910e7796638b28aa6e2", "filename": "src/test/auxiliary/plugin_crate_outlive_expansion_phase.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -15,6 +15,7 @@\n extern crate rustc;\n \n use std::any::Any;\n+use std::cell::RefCell;\n use rustc::plugin::Registry;\n \n struct Foo {\n@@ -27,7 +28,7 @@ impl Drop for Foo {\n \n #[plugin_registrar]\n pub fn registrar(_: &mut Registry) {\n-    local_data_key!(foo: Box<Any+Send>);\n-    foo.replace(Some(box Foo { foo: 10 } as Box<Any+Send>));\n+    thread_local!(static FOO: RefCell<Option<Box<Any+Send>>> = RefCell::new(None));\n+    FOO.with(|s| *s.borrow_mut() = Some(box Foo { foo: 10 } as Box<Any+Send>));\n }\n "}, {"sha": "d77c552be034c60850fe070e74c322782773eb28", "filename": "src/test/compile-fail/core-tls-store-pointer.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Testing that we can't store a reference in task-local storage\n-\n-local_data_key!(key: Box<&int>)\n-//~^ ERROR missing lifetime specifier\n-\n-fn main() {}"}, {"sha": "3f2ecd86abe89a9a382aed808a2e2f89e0248b3f", "filename": "src/test/compile-fail/macro-local-data-key-priv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -11,10 +11,10 @@\n // check that the local data keys are private by default.\n \n mod bar {\n-    local_data_key!(baz: f64)\n+    thread_local!(static baz: f64 = 0.0)\n }\n \n fn main() {\n-    bar::baz.replace(Some(-10.0));\n+    bar::baz.with(|_| ());\n     //~^ ERROR static `baz` is private\n }"}, {"sha": "730b0b08d451abda2f3ba88e005a09303164d430", "filename": "src/test/run-pass/macro-local-data-key.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Ftest%2Frun-pass%2Fmacro-local-data-key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Ftest%2Frun-pass%2Fmacro-local-data-key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-local-data-key.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-local_data_key!(foo: int)\n-\n-mod bar {\n-    local_data_key!(pub baz: f64)\n-}\n-\n-pub fn main() {\n-    assert!(foo.get().is_none());\n-    assert!(bar::baz.get().is_none());\n-\n-    foo.replace(Some(3));\n-    bar::baz.replace(Some(-10.0));\n-\n-    assert_eq!(*foo.get().unwrap(), 3);\n-    assert_eq!(*bar::baz.get().unwrap(), -10.0);\n-}"}, {"sha": "2f0d6cf90aa5a16af38112ab00d13c1f21647e18", "filename": "src/test/run-pass/panic-during-tld-destroy.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Ftest%2Frun-pass%2Fpanic-during-tld-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5259503cd8aac9905c7ac6d68d0c4caab1d28c/src%2Ftest%2Frun-pass%2Fpanic-during-tld-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-during-tld-destroy.rs?ref=4e5259503cd8aac9905c7ac6d68d0c4caab1d28c", "patch": "@@ -1,33 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::task;\n-\n-static mut DROPS: uint = 0;\n-\n-struct Foo;\n-impl Drop for Foo {\n-    fn drop(&mut self) {\n-        unsafe { DROPS += 1; }\n-        panic!()\n-    }\n-}\n-\n-fn main() {\n-    let _ = task::try(proc() {\n-        local_data_key!(foo: Foo);\n-        foo.replace(Some(Foo));\n-    });\n-\n-    unsafe {\n-        assert_eq!(DROPS, 1);\n-    }\n-}\n-"}, {"sha": "683f7038ead7ac237be7356fa904e8c7e8d67ce6", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c1152c4bf72132806cb76045b3464d59db07da/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=a9c1152c4bf72132806cb76045b3464d59db07da", "patch": "@@ -17,8 +17,6 @@ use std::rt;\n \n use rustrt::unwind::try;\n \n-local_data_key!(foo: int)\n-\n #[start]\n fn start(argc: int, argv: *const *const u8) -> int {\n     if argc > 1 {\n@@ -30,8 +28,6 @@ fn start(argc: int, argv: *const *const u8) -> int {\n                 4 => assert!(try(|| panic!()).is_err()),\n                 5 => assert!(try(|| spawn(proc() {})).is_err()),\n                 6 => assert!(Command::new(\"test\").spawn().is_err()),\n-                7 => assert!(foo.get().is_none()),\n-                8 => assert!(try(|| { foo.replace(Some(3)); }).is_err()),\n                 _ => panic!()\n             }\n         }\n@@ -57,10 +53,6 @@ fn main() {\n     pass(Command::new(me).arg(x).output().unwrap());\n     let x: &[u8] = &[6u8];\n     pass(Command::new(me).arg(x).output().unwrap());\n-    let x: &[u8] = &[7u8];\n-    pass(Command::new(me).arg(x).output().unwrap());\n-    let x: &[u8] = &[8u8];\n-    pass(Command::new(me).arg(x).output().unwrap());\n }\n \n fn pass(output: ProcessOutput) {"}]}