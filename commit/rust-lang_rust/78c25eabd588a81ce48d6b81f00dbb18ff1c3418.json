{"sha": "78c25eabd588a81ce48d6b81f00dbb18ff1c3418", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4YzI1ZWFiZDU4OGE4MWNlNDhkNmI4MWYwMGRiYjE4ZmYxYzM0MTg=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-06-05T05:50:04Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-06-14T20:15:29Z"}, "message": "save-analysis: API-ify impls", "tree": {"sha": "eeb1552aa60aed273df7eec3432dbec04a3e391f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eeb1552aa60aed273df7eec3432dbec04a3e391f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78c25eabd588a81ce48d6b81f00dbb18ff1c3418", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78c25eabd588a81ce48d6b81f00dbb18ff1c3418", "html_url": "https://github.com/rust-lang/rust/commit/78c25eabd588a81ce48d6b81f00dbb18ff1c3418", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78c25eabd588a81ce48d6b81f00dbb18ff1c3418/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abe5f7b95a1d856b69eb68344426e29d30918aea", "url": "https://api.github.com/repos/rust-lang/rust/commits/abe5f7b95a1d856b69eb68344426e29d30918aea", "html_url": "https://github.com/rust-lang/rust/commit/abe5f7b95a1d856b69eb68344426e29d30918aea"}], "stats": {"total": 184, "additions": 131, "deletions": 53}, "files": [{"sha": "f61748afbc58a5421871f49c35422b1fd2dd182f", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 44, "deletions": 53, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/78c25eabd588a81ce48d6b81f00dbb18ff1c3418/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78c25eabd588a81ce48d6b81f00dbb18ff1c3418/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=78c25eabd588a81ce48d6b81f00dbb18ff1c3418", "patch": "@@ -419,19 +419,15 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                     id);\n     }\n \n-    fn process_trait_ref(&mut self,\n-                         trait_ref: &ast::TraitRef) {\n-        match self.lookup_type_ref(trait_ref.ref_id) {\n-            Some(id) => {\n-                let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n-                self.fmt.ref_str(recorder::TypeRef,\n-                                 trait_ref.path.span,\n-                                 sub_span,\n-                                 id,\n-                                 self.cur_scope);\n-                visit::walk_path(self, &trait_ref.path);\n-            },\n-            None => ()\n+    fn process_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n+        let trait_ref_data = self.save_ctxt.get_trait_ref_data(trait_ref, self.cur_scope);\n+        if let Some(trait_ref_data) = trait_ref_data {\n+            self.fmt.ref_str(recorder::TypeRef,\n+                             trait_ref.path.span,\n+                             Some(trait_ref_data.span),\n+                             trait_ref_data.ref_id,\n+                             trait_ref_data.scope);\n+            visit::walk_path(self, &trait_ref.path);\n         }\n     }\n \n@@ -600,8 +596,9 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                               Some(enum_data.span),\n                               enum_data.id,\n                               &enum_data.qualname,\n-                              self.cur_scope,\n+                              enum_data.scope,\n                               &enum_data.value);\n+\n             for variant in &enum_definition.variants {\n                 let name = &get_ident(variant.node.name);\n                 let mut qualname = enum_data.qualname.clone();\n@@ -618,7 +615,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                                    &qualname,\n                                                    &enum_data.qualname,\n                                                    &val,\n-                                                   item.id);\n+                                                   enum_data.id);\n                         for arg in args {\n                             self.visit_ty(&*arg.ty);\n                         }\n@@ -635,7 +632,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                                     &qualname,\n                                                     &enum_data.qualname,\n                                                     &val,\n-                                                    item.id);\n+                                                    enum_data.id);\n \n                         for field in &struct_def.fields {\n                             self.process_struct_field_def(field, variant.node.id);\n@@ -644,7 +641,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     }\n                 }\n             }\n-            self.process_generic_params(ty_params, item.span, &enum_data.qualname, item.id);\n+            self.process_generic_params(ty_params, item.span, &enum_data.qualname, enum_data.id);\n         } else {\n             self.sess.span_bug(item.span, \"expected EnumData\");\n         }\n@@ -656,43 +653,37 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                     trait_ref: &Option<ast::TraitRef>,\n                     typ: &ast::Ty,\n                     impl_items: &[P<ast::ImplItem>]) {\n-        let trait_id = trait_ref.as_ref().and_then(|tr| self.lookup_type_ref(tr.ref_id));\n-        match typ.node {\n-            // Common case impl for a struct or something basic.\n-            ast::TyPath(None, ref path) => {\n-                let sub_span = self.span.sub_span_for_type_name(path.span);\n-                let self_id = self.lookup_type_ref(typ.id).map(|id| {\n+        let impl_data = self.save_ctxt.get_item_data(item);\n+        if let super::Data::ImplData(impl_data) = impl_data {\n+            match impl_data.self_ref {\n+                Some(ref self_ref) => {\n                     self.fmt.ref_str(recorder::TypeRef,\n-                                     path.span,\n-                                     sub_span,\n-                                     id,\n-                                     self.cur_scope);\n-                    id\n-                });\n-                self.fmt.impl_str(path.span,\n-                                  sub_span,\n-                                  item.id,\n-                                  self_id,\n-                                  trait_id,\n-                                  self.cur_scope);\n-            },\n-            _ => {\n-                // Less useful case, impl for a compound type.\n-                self.visit_ty(&*typ);\n-\n-                let sub_span = self.span.sub_span_for_type_name(typ.span);\n-                self.fmt.impl_str(typ.span,\n-                                  sub_span,\n-                                  item.id,\n-                                  None,\n-                                  trait_id,\n-                                  self.cur_scope);\n+                                     item.span,\n+                                     Some(self_ref.span),\n+                                     self_ref.ref_id,\n+                                     self_ref.scope);\n+                }\n+                None => {\n+                    self.visit_ty(&typ);\n+                }\n+            }\n+            if let Some(ref trait_ref_data) = impl_data.trait_ref {\n+                self.fmt.ref_str(recorder::TypeRef,\n+                                 item.span,\n+                                 Some(trait_ref_data.span),\n+                                 trait_ref_data.ref_id,\n+                                 trait_ref_data.scope);\n+                visit::walk_path(self, &trait_ref.as_ref().unwrap().path);\n             }\n-        }\n \n-        match *trait_ref {\n-            Some(ref trait_ref) => self.process_trait_ref(trait_ref),\n-            None => (),\n+            self.fmt.impl_str(item.span,\n+                              Some(impl_data.span),\n+                              impl_data.id,\n+                              impl_data.self_ref.map(|data| data.ref_id),\n+                              impl_data.trait_ref.map(|data| data.ref_id),\n+                              impl_data.scope);\n+        } else {\n+            self.sess.span_bug(item.span, \"expected ImplData\");\n         }\n \n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n@@ -717,7 +708,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                            &val);\n \n         // super-traits\n-        for super_bound in trait_refs.iter() {\n+        for super_bound in &trait_refs {\n             let trait_ref = match *super_bound {\n                 ast::TraitTyParamBound(ref trait_ref, _) => {\n                     trait_ref\n@@ -1164,7 +1155,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 self.process_impl(item,\n                                   ty_params,\n                                   trait_ref,\n-                                  &**typ,\n+                                  &typ,\n                                   impl_items)\n             }\n             ast::ItemTrait(_, ref generics, ref trait_refs, ref methods) =>"}, {"sha": "76decc02a54ff6ea187959a698c22964db3201e2", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/78c25eabd588a81ce48d6b81f00dbb18ff1c3418/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78c25eabd588a81ce48d6b81f00dbb18ff1c3418/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=78c25eabd588a81ce48d6b81f00dbb18ff1c3418", "patch": "@@ -10,6 +10,7 @@\n \n use session::Session;\n use middle::ty;\n+use middle::def;\n \n use std::env;\n use std::fs::{self, File};\n@@ -55,10 +56,14 @@ pub enum Data {\n     ModData(ModData),\n     /// Data for Enums.\n     EnumData(EnumData),\n+    /// Data for impls.\n+    ImplData(ImplData),\n \n     /// Data for the use of some variable (e.g., the use of a local variable, which\n     /// will refere to that variables declaration).\n     VariableRefData(VariableRefData),\n+    /// Data for a reference to a type or trait.\n+    TypeRefData(TypeRefData),\n }\n \n /// Data for all kinds of functions and methods.\n@@ -98,6 +103,18 @@ pub struct EnumData {\n     pub value: String,\n     pub qualname: String,\n     pub span: Span,\n+    pub scope: NodeId,\n+}\n+\n+pub struct ImplData {\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub scope: NodeId,\n+    // FIXME: I'm not really sure inline data is the best way to do this. Seems\n+    // OK in this case, but generalising leads to returning chunks of AST, which\n+    // feels wrong.\n+    pub trait_ref: Option<TypeRefData>,\n+    pub self_ref: Option<TypeRefData>,\n }\n \n /// Data for the use of some item (e.g., the use of a local variable, which\n@@ -109,6 +126,13 @@ pub struct VariableRefData {\n     pub ref_id: DefId,\n }\n \n+/// Data for a reference to a type or trait.\n+pub struct TypeRefData {\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub ref_id: DefId,\n+}\n+\n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn new(sess: &'l Session,\n@@ -211,8 +235,42 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     value: val,\n                     span: sub_span.unwrap(),\n                     qualname: enum_name,\n+                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n                 })\n             },\n+            ast::ItemImpl(_, _, _, ref trait_ref, ref typ, _) => {\n+                let mut type_data = None;\n+                let sub_span;\n+\n+                let parent = self.analysis.ty_cx.map.get_parent(item.id);\n+\n+                match typ.node {\n+                    // Common case impl for a struct or something basic.\n+                    ast::TyPath(None, ref path) => {\n+                        sub_span = self.span_utils.sub_span_for_type_name(path.span);\n+                        type_data = self.lookup_ref_id(typ.id).map(|id| TypeRefData {\n+                            span: sub_span.unwrap(),\n+                            scope: parent,\n+                            ref_id: id,\n+                        });\n+                    },\n+                    _ => {\n+                        // Less useful case, impl for a compound type.\n+                        sub_span = self.span_utils.sub_span_for_type_name(typ.span);\n+                    }\n+                }\n+\n+                let trait_data =\n+                    trait_ref.as_ref().and_then(|tr| self.get_trait_ref_data(tr, parent));\n+\n+                Data::ImplData(ImplData {\n+                    id: item.id,\n+                    span: sub_span.unwrap(),\n+                    scope: parent,\n+                    trait_ref: trait_data,\n+                    self_ref: type_data,\n+                })\n+            }\n             _ => {\n                 // FIXME\n                 unimplemented!();\n@@ -247,6 +305,22 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n+    // FIXME: we ought to be able to get the parent id ourselves, but we can't\n+    // for now.\n+    pub fn get_trait_ref_data(&self,\n+                              trait_ref: &ast::TraitRef,\n+                              parent: NodeId)\n+                              -> Option<TypeRefData> {\n+        self.lookup_ref_id(trait_ref.ref_id).map(|def_id| {\n+            let sub_span = self.span_utils.sub_span_for_type_name(trait_ref.path.span);\n+            TypeRefData {\n+                span: sub_span.unwrap(),\n+                scope: parent,\n+                ref_id: def_id,\n+            }\n+        })\n+    }\n+\n     pub fn get_expr_data(&self, expr: &ast::Expr) -> Data {\n         match expr.node {\n             ast::ExprField(ref sub_ex, ident) => {\n@@ -286,6 +360,19 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         // FIXME\n         unimplemented!();\n     }\n+\n+    fn lookup_ref_id(&self, ref_id: NodeId) -> Option<DefId> {\n+        if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n+            self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n+                                  ref_id));\n+        }\n+        let def = self.analysis.ty_cx.def_map.borrow().get(&ref_id).unwrap().full_def();\n+        match def {\n+            def::DefPrimTy(_) => None,\n+            _ => Some(def.def_id()),\n+        }\n+    }\n+\n }\n \n // An AST visitor for collecting paths from patterns."}]}