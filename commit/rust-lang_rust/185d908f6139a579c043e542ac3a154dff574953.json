{"sha": "185d908f6139a579c043e542ac3a154dff574953", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4NWQ5MDhmNjEzOWE1NzljMDQzZTU0MmFjM2ExNTRkZmY1NzQ5NTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-25T06:32:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-25T06:32:31Z"}, "message": "Auto merge of #39277 - tedsta:fuchsia_std_process, r=alexcrichton\n\nUpdate Fuchsia support for std::process.\n\n- Adds support for try_wait.\n- Miscellaneous updates to keep up with Magenta changes.\n\nI'll begin `sys/fuchsia` soon, just been bogged down with my actual job lately (I'm not on the Fuchsia team).", "tree": {"sha": "0ca4094563425f5b7d51f02ac68af4ab42d308f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ca4094563425f5b7d51f02ac68af4ab42d308f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/185d908f6139a579c043e542ac3a154dff574953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/185d908f6139a579c043e542ac3a154dff574953", "html_url": "https://github.com/rust-lang/rust/commit/185d908f6139a579c043e542ac3a154dff574953", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/185d908f6139a579c043e542ac3a154dff574953/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0d0e68be4f8bb9d8522bd72a7a1b8ef95b84c6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0d0e68be4f8bb9d8522bd72a7a1b8ef95b84c6c", "html_url": "https://github.com/rust-lang/rust/commit/c0d0e68be4f8bb9d8522bd72a7a1b8ef95b84c6c"}, {"sha": "bbe419ff30a7a39289cb6f897522af5896afc1f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbe419ff30a7a39289cb6f897522af5896afc1f9", "html_url": "https://github.com/rust-lang/rust/commit/bbe419ff30a7a39289cb6f897522af5896afc1f9"}], "stats": {"total": 190, "additions": 167, "deletions": 23}, "files": [{"sha": "a81bedcad22ff6034b3b0261ec5bb761a80d9722", "filename": "src/libstd/sys/unix/process/magenta.rs", "status": "modified", "additions": 127, "deletions": 13, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/185d908f6139a579c043e542ac3a154dff574953/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/185d908f6139a579c043e542ac3a154dff574953/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs?ref=185d908f6139a579c043e542ac3a154dff574953", "patch": "@@ -41,8 +41,6 @@ pub type mx_object_info_topic_t = u32;\n \n pub const MX_INFO_PROCESS         : mx_object_info_topic_t = 3;\n \n-pub const MX_HND_TYPE_JOB: u32 = 6;\n-\n pub fn mx_cvt<T>(t: T) -> io::Result<T> where T: TryInto<mx_status_t>+Copy {\n     if let Ok(status) = TryInto::try_into(t) {\n         if status < 0 {\n@@ -104,6 +102,8 @@ pub struct mx_info_process_t {\n }\n \n extern {\n+    static __magenta_job_default: mx_handle_t;\n+\n     pub fn mx_task_kill(handle: mx_handle_t) -> mx_status_t;\n \n     pub fn mx_handle_close(handle: mx_handle_t) -> mx_status_t;\n@@ -119,21 +119,14 @@ extern {\n                               avail: *mut mx_size_t) -> mx_status_t;\n }\n \n-// Handle Info entries associate a type and optional\n-// argument with each handle included in the process\n-// arguments message.\n-pub fn mx_hnd_info(hnd_type: u32, arg: u32) -> u32 {\n-    (hnd_type & 0xFFFF) | ((arg & 0xFFFF) << 16)\n-}\n-\n-extern {\n-    pub fn mxio_get_startup_handle(id: u32) -> mx_handle_t;\n+pub fn mx_job_default() -> mx_handle_t {\n+    unsafe { return __magenta_job_default; }\n }\n \n // From `enum special_handles` in system/ulib/launchpad/launchpad.c\n-#[allow(unused)] pub const HND_LOADER_SVC: usize = 0;\n+// HND_LOADER_SVC = 0\n // HND_EXEC_VMO = 1\n-#[allow(unused)] pub const HND_SPECIAL_COUNT: usize = 2;\n+pub const HND_SPECIAL_COUNT: usize = 2;\n \n #[repr(C)]\n pub struct launchpad_t {\n@@ -188,3 +181,124 @@ extern {\n \n     pub fn launchpad_vmo_from_file(filename: *const c_char) -> mx_handle_t;\n }\n+\n+// Errors\n+\n+#[allow(unused)] pub const ERR_INTERNAL: mx_status_t = -1;\n+\n+// ERR_NOT_SUPPORTED: The operation is not implemented, supported,\n+// or enabled.\n+#[allow(unused)] pub const ERR_NOT_SUPPORTED: mx_status_t = -2;\n+\n+// ERR_NO_RESOURCES: The system was not able to allocate some resource\n+// needed for the operation.\n+#[allow(unused)] pub const ERR_NO_RESOURCES: mx_status_t = -5;\n+\n+// ERR_NO_MEMORY: The system was not able to allocate memory needed\n+// for the operation.\n+#[allow(unused)] pub const ERR_NO_MEMORY: mx_status_t = -4;\n+\n+// ERR_CALL_FAILED: The second phase of mx_channel_call(; did not complete\n+// successfully.\n+#[allow(unused)] pub const ERR_CALL_FAILED: mx_status_t = -53;\n+\n+// ======= Parameter errors =======\n+// ERR_INVALID_ARGS: an argument is invalid, ex. null pointer\n+#[allow(unused)] pub const ERR_INVALID_ARGS: mx_status_t = -10;\n+\n+// ERR_WRONG_TYPE: The subject of the operation is the wrong type to\n+// perform the operation.\n+// Example: Attempting a message_read on a thread handle.\n+#[allow(unused)] pub const ERR_WRONG_TYPE: mx_status_t = -54;\n+\n+// ERR_BAD_SYSCALL: The specified syscall number is invalid.\n+#[allow(unused)] pub const ERR_BAD_SYSCALL: mx_status_t = -11;\n+\n+// ERR_BAD_HANDLE: A specified handle value does not refer to a handle.\n+#[allow(unused)] pub const ERR_BAD_HANDLE: mx_status_t = -12;\n+\n+// ERR_OUT_OF_RANGE: An argument is outside the valid range for this\n+// operation.\n+#[allow(unused)] pub const ERR_OUT_OF_RANGE: mx_status_t = -13;\n+\n+// ERR_BUFFER_TOO_SMALL: A caller provided buffer is too small for\n+// this operation.\n+#[allow(unused)] pub const ERR_BUFFER_TOO_SMALL: mx_status_t = -14;\n+\n+// ======= Precondition or state errors =======\n+// ERR_BAD_STATE: operation failed because the current state of the\n+// object does not allow it, or a precondition of the operation is\n+// not satisfied\n+#[allow(unused)] pub const ERR_BAD_STATE: mx_status_t = -20;\n+\n+// ERR_NOT_FOUND: The requested entity is not found.\n+#[allow(unused)] pub const ERR_NOT_FOUND: mx_status_t = -3;\n+\n+// ERR_ALREADY_EXISTS: An object with the specified identifier\n+// already exists.\n+// Example: Attempting to create a file when a file already exists\n+// with that name.\n+#[allow(unused)] pub const ERR_ALREADY_EXISTS: mx_status_t = -15;\n+\n+// ERR_ALREADY_BOUND: The operation failed because the named entity\n+// is already owned or controlled by another entity. The operation\n+// could succeed later if the current owner releases the entity.\n+#[allow(unused)] pub const ERR_ALREADY_BOUND: mx_status_t = -16;\n+\n+// ERR_TIMED_OUT: The time limit for the operation elapsed before\n+// the operation completed.\n+#[allow(unused)] pub const ERR_TIMED_OUT: mx_status_t = -23;\n+\n+// ERR_HANDLE_CLOSED: a handle being waited on was closed\n+#[allow(unused)] pub const ERR_HANDLE_CLOSED: mx_status_t = -24;\n+\n+// ERR_REMOTE_CLOSED: The operation failed because the remote end\n+// of the subject of the operation was closed.\n+#[allow(unused)] pub const ERR_REMOTE_CLOSED: mx_status_t = -25;\n+\n+// ERR_UNAVAILABLE: The subject of the operation is currently unable\n+// to perform the operation.\n+// Note: This is used when there's no direct way for the caller to\n+// observe when the subject will be able to perform the operation\n+// and should thus retry.\n+#[allow(unused)] pub const ERR_UNAVAILABLE: mx_status_t = -26;\n+\n+// ERR_SHOULD_WAIT: The operation cannot be performed currently but\n+// potentially could succeed if the caller waits for a prerequisite\n+// to be satisfied, for example waiting for a handle to be readable\n+// or writable.\n+// Example: Attempting to read from a message pipe that has no\n+// messages waiting but has an open remote will return ERR_SHOULD_WAIT.\n+// Attempting to read from a message pipe that has no messages waiting\n+// and has a closed remote end will return ERR_REMOTE_CLOSED.\n+#[allow(unused)] pub const ERR_SHOULD_WAIT: mx_status_t = -27;\n+\n+// ======= Permission check errors =======\n+// ERR_ACCESS_DENIED: The caller did not have permission to perform\n+// the specified operation.\n+#[allow(unused)] pub const ERR_ACCESS_DENIED: mx_status_t = -30;\n+\n+// ======= Input-output errors =======\n+// ERR_IO: Otherwise unspecified error occurred during I/O.\n+#[allow(unused)] pub const ERR_IO: mx_status_t = -40;\n+\n+// ERR_REFUSED: The entity the I/O operation is being performed on\n+// rejected the operation.\n+// Example: an I2C device NAK'ing a transaction or a disk controller\n+// rejecting an invalid command.\n+#[allow(unused)] pub const ERR_IO_REFUSED: mx_status_t = -41;\n+\n+// ERR_IO_DATA_INTEGRITY: The data in the operation failed an integrity\n+// check and is possibly corrupted.\n+// Example: CRC or Parity error.\n+#[allow(unused)] pub const ERR_IO_DATA_INTEGRITY: mx_status_t = -42;\n+\n+// ERR_IO_DATA_LOSS: The data in the operation is currently unavailable\n+// and may be permanently lost.\n+// Example: A disk block is irrecoverably damaged.\n+#[allow(unused)] pub const ERR_IO_DATA_LOSS: mx_status_t = -43;\n+\n+// Filesystem specific errors\n+#[allow(unused)] pub const ERR_BAD_PATH: mx_status_t = -50;\n+#[allow(unused)] pub const ERR_NOT_DIR: mx_status_t = -51;\n+#[allow(unused)] pub const ERR_NOT_FILE: mx_status_t = -52;"}, {"sha": "87acb0ed9b977e4fe1dc9c7da72e27e0e8d1b2d7", "filename": "src/libstd/sys/unix/process/process_fuchsia.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/185d908f6139a579c043e542ac3a154dff574953/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/185d908f6139a579c043e542ac3a154dff574953/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=185d908f6139a579c043e542ac3a154dff574953", "patch": "@@ -54,7 +54,7 @@ impl Command {\n                       -> io::Result<(*mut launchpad_t, mx_handle_t)> {\n         use sys::process::magenta::*;\n \n-        let job_handle = mxio_get_startup_handle(mx_hnd_info(MX_HND_TYPE_JOB, 0));\n+        let job_handle = mx_job_default();\n         let envp = match *self.get_envp() {\n             Some(ref envp) => envp.as_ptr(),\n             None => ptr::null(),\n@@ -66,14 +66,14 @@ impl Command {\n             fn drop(&mut self) { unsafe { launchpad_destroy(self.0); } }\n         }\n \n-        let mut launchpad: *mut launchpad_t = ptr::null_mut();\n-        let launchpad_destructor = LaunchpadDestructor(launchpad);\n-\n         // Duplicate the job handle\n         let mut job_copy: mx_handle_t = MX_HANDLE_INVALID;\n         mx_cvt(mx_handle_duplicate(job_handle, MX_RIGHT_SAME_RIGHTS, &mut job_copy))?;\n         // Create a launchpad\n+        let mut launchpad: *mut launchpad_t = ptr::null_mut();\n         mx_cvt(launchpad_create(job_copy, self.get_argv()[0], &mut launchpad))?;\n+        let launchpad_destructor = LaunchpadDestructor(launchpad);\n+\n         // Set the process argv\n         mx_cvt(launchpad_arguments(launchpad, self.get_argv().len() as i32 - 1,\n                                    self.get_argv().as_ptr()))?;\n@@ -88,19 +88,19 @@ impl Command {\n \n         // Clone stdin, stdout, and stderr\n         if let Some(fd) = stdio.stdin.fd() {\n-            launchpad_transfer_fd(launchpad, fd, 0);\n+            mx_cvt(launchpad_transfer_fd(launchpad, fd, 0))?;\n         } else {\n-            launchpad_clone_fd(launchpad, 0, 0);\n+            mx_cvt(launchpad_clone_fd(launchpad, 0, 0))?;\n         }\n         if let Some(fd) = stdio.stdout.fd() {\n-            launchpad_transfer_fd(launchpad, fd, 1);\n+            mx_cvt(launchpad_transfer_fd(launchpad, fd, 1))?;\n         } else {\n-            launchpad_clone_fd(launchpad, 1, 1);\n+            mx_cvt(launchpad_clone_fd(launchpad, 1, 1))?;\n         }\n         if let Some(fd) = stdio.stderr.fd() {\n-            launchpad_transfer_fd(launchpad, fd, 2);\n+            mx_cvt(launchpad_transfer_fd(launchpad, fd, 2))?;\n         } else {\n-            launchpad_clone_fd(launchpad, 2, 2);\n+            mx_cvt(launchpad_clone_fd(launchpad, 2, 2))?;\n         }\n \n         // We don't want FileDesc::drop to be called on any stdio. It would close their fds. The\n@@ -164,6 +164,36 @@ impl Process {\n         }\n         Ok(ExitStatus::new(proc_info.rec.return_code))\n     }\n+\n+    pub fn try_wait(&mut self) -> io::Result<ExitStatus> {\n+        use default::Default;\n+        use sys::process::magenta::*;\n+\n+        let mut proc_info: mx_info_process_t = Default::default();\n+        let mut actual: mx_size_t = 0;\n+        let mut avail: mx_size_t = 0;\n+\n+        unsafe {\n+            let status = mx_handle_wait_one(self.handle.raw(), MX_TASK_TERMINATED,\n+                                            0, ptr::null_mut());\n+            match status {\n+                0 => { }, // Success\n+                x if x == ERR_TIMED_OUT => {\n+                    return Err(io::Error::from(io::ErrorKind::WouldBlock));\n+                },\n+                _ => { panic!(\"Failed to wait on process handle: {}\", status); },\n+            }\n+            mx_cvt(mx_object_get_info(self.handle.raw(), MX_INFO_PROCESS,\n+                                      &mut proc_info as *mut _ as *mut libc::c_void,\n+                                      mem::size_of::<mx_info_process_t>(), &mut actual,\n+                                      &mut avail))?;\n+        }\n+        if actual != 1 {\n+            return Err(io::Error::new(io::ErrorKind::InvalidData,\n+                                      \"Failed to get exit status of process\"));\n+        }\n+        Ok(ExitStatus::new(proc_info.rec.return_code))\n+    }\n }\n \n impl Drop for Process {"}]}