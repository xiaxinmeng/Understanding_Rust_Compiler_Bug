{"sha": "b33e234155b33ab6bce280fb2445b62b68622b61", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzM2UyMzQxNTViMzNhYjZiY2UyODBmYjI0NDViNjJiNjg2MjJiNjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-31T12:00:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-31T12:00:43Z"}, "message": "Auto merge of #79895 - Kerollmops:slice-group-by, r=m-ou-se\n\nThe return of the GroupBy and GroupByMut iterators on slice\n\nAccording to https://github.com/rust-lang/rfcs/pull/2477#issuecomment-742034372, I am opening this PR again, this time I implemented it in safe Rust only, it is therefore much easier to read and is completely safe.\n\nThis PR proposes to add two new methods to the slice, the `group_by` and `group_by_mut`. These two methods provide a way to iterate over non-overlapping sub-slices of a base slice that are separated by the predicate given by the user (e.g. `Partial::eq`, `|a, b| a.abs() < b.abs()`).\n\n```rust\nlet slice = &[1, 1, 1, 3, 3, 2, 2, 2];\n\nlet mut iter = slice.group_by(|a, b| a == b);\nassert_eq!(iter.next(), Some(&[1, 1, 1][..]));\nassert_eq!(iter.next(), Some(&[3, 3][..]));\nassert_eq!(iter.next(), Some(&[2, 2, 2][..]));\nassert_eq!(iter.next(), None);\n```\n\n[An RFC](https://github.com/rust-lang/rfcs/pull/2477) was open 2 years ago but wasn't necessary.", "tree": {"sha": "7bc7745058308478e364ed6cd20e2d5913305f9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bc7745058308478e364ed6cd20e2d5913305f9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b33e234155b33ab6bce280fb2445b62b68622b61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b33e234155b33ab6bce280fb2445b62b68622b61", "html_url": "https://github.com/rust-lang/rust/commit/b33e234155b33ab6bce280fb2445b62b68622b61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b33e234155b33ab6bce280fb2445b62b68622b61/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6bd5246da7806786b5c1f61d05a957c9ae68903", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6bd5246da7806786b5c1f61d05a957c9ae68903", "html_url": "https://github.com/rust-lang/rust/commit/a6bd5246da7806786b5c1f61d05a957c9ae68903"}, {"sha": "8b53be660444d736bb6a6e1c6ba42c8180c968e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b53be660444d736bb6a6e1c6ba42c8180c968e7", "html_url": "https://github.com/rust-lang/rust/commit/8b53be660444d736bb6a6e1c6ba42c8180c968e7"}], "stats": {"total": 330, "additions": 330, "deletions": 0}, "files": [{"sha": "e6db66ac57155b954e6c0367363d221638d1b0f8", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b33e234155b33ab6bce280fb2445b62b68622b61/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e234155b33ab6bce280fb2445b62b68622b61/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=b33e234155b33ab6bce280fb2445b62b68622b61", "patch": "@@ -139,6 +139,7 @@\n #![feature(try_trait)]\n #![feature(type_alias_impl_trait)]\n #![feature(associated_type_bounds)]\n+#![feature(slice_group_by)]\n // Allow testing this library\n \n #[cfg(test)]"}, {"sha": "cb015b949305c4d3e961ce1bfe6c35afdd3a47b5", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b33e234155b33ab6bce280fb2445b62b68622b61/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e234155b33ab6bce280fb2445b62b68622b61/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=b33e234155b33ab6bce280fb2445b62b68622b61", "patch": "@@ -110,6 +110,8 @@ pub use core::slice::{Chunks, Windows};\n pub use core::slice::{ChunksExact, ChunksExactMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{ChunksMut, Split, SplitMut};\n+#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+pub use core::slice::{GroupBy, GroupByMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{Iter, IterMut};\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]"}, {"sha": "cd4174ed4007a6443169357a4a24b592dd241607", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b33e234155b33ab6bce280fb2445b62b68622b61/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e234155b33ab6bce280fb2445b62b68622b61/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=b33e234155b33ab6bce280fb2445b62b68622b61", "patch": "@@ -20,6 +20,7 @@\n #![feature(iter_map_while)]\n #![feature(int_bits_const)]\n #![feature(vecdeque_binary_search)]\n+#![feature(slice_group_by)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "777c10b1bf740335ff5c6fbe195dbf3b584216dd", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b33e234155b33ab6bce280fb2445b62b68622b61/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e234155b33ab6bce280fb2445b62b68622b61/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=b33e234155b33ab6bce280fb2445b62b68622b61", "patch": "@@ -1898,3 +1898,61 @@ fn subslice_patterns() {\n     m!(&mut v, [..] => ());\n     m!(&mut v, [x, .., y] => c!((x, y), (&mut N, &mut N), (&mut N(0), &mut N(4))));\n }\n+\n+#[test]\n+fn test_group_by() {\n+    let slice = &[1, 1, 1, 3, 3, 2, 2, 2, 1, 0];\n+\n+    let mut iter = slice.group_by(|a, b| a == b);\n+    assert_eq!(iter.next(), Some(&[1, 1, 1][..]));\n+    assert_eq!(iter.next(), Some(&[3, 3][..]));\n+    assert_eq!(iter.next(), Some(&[2, 2, 2][..]));\n+    assert_eq!(iter.next(), Some(&[1][..]));\n+    assert_eq!(iter.next(), Some(&[0][..]));\n+    assert_eq!(iter.next(), None);\n+\n+    let mut iter = slice.group_by(|a, b| a == b);\n+    assert_eq!(iter.next_back(), Some(&[0][..]));\n+    assert_eq!(iter.next_back(), Some(&[1][..]));\n+    assert_eq!(iter.next_back(), Some(&[2, 2, 2][..]));\n+    assert_eq!(iter.next_back(), Some(&[3, 3][..]));\n+    assert_eq!(iter.next_back(), Some(&[1, 1, 1][..]));\n+    assert_eq!(iter.next_back(), None);\n+\n+    let mut iter = slice.group_by(|a, b| a == b);\n+    assert_eq!(iter.next(), Some(&[1, 1, 1][..]));\n+    assert_eq!(iter.next_back(), Some(&[0][..]));\n+    assert_eq!(iter.next(), Some(&[3, 3][..]));\n+    assert_eq!(iter.next_back(), Some(&[1][..]));\n+    assert_eq!(iter.next(), Some(&[2, 2, 2][..]));\n+    assert_eq!(iter.next_back(), None);\n+}\n+\n+#[test]\n+fn test_group_by_mut() {\n+    let slice = &mut [1, 1, 1, 3, 3, 2, 2, 2, 1, 0];\n+\n+    let mut iter = slice.group_by_mut(|a, b| a == b);\n+    assert_eq!(iter.next(), Some(&mut [1, 1, 1][..]));\n+    assert_eq!(iter.next(), Some(&mut [3, 3][..]));\n+    assert_eq!(iter.next(), Some(&mut [2, 2, 2][..]));\n+    assert_eq!(iter.next(), Some(&mut [1][..]));\n+    assert_eq!(iter.next(), Some(&mut [0][..]));\n+    assert_eq!(iter.next(), None);\n+\n+    let mut iter = slice.group_by_mut(|a, b| a == b);\n+    assert_eq!(iter.next_back(), Some(&mut [0][..]));\n+    assert_eq!(iter.next_back(), Some(&mut [1][..]));\n+    assert_eq!(iter.next_back(), Some(&mut [2, 2, 2][..]));\n+    assert_eq!(iter.next_back(), Some(&mut [3, 3][..]));\n+    assert_eq!(iter.next_back(), Some(&mut [1, 1, 1][..]));\n+    assert_eq!(iter.next_back(), None);\n+\n+    let mut iter = slice.group_by_mut(|a, b| a == b);\n+    assert_eq!(iter.next(), Some(&mut [1, 1, 1][..]));\n+    assert_eq!(iter.next_back(), Some(&mut [0][..]));\n+    assert_eq!(iter.next(), Some(&mut [3, 3][..]));\n+    assert_eq!(iter.next_back(), Some(&mut [1][..]));\n+    assert_eq!(iter.next(), Some(&mut [2, 2, 2][..]));\n+    assert_eq!(iter.next_back(), None);\n+}"}, {"sha": "a367b4737dbacbcaca403b26cf5aadbf2d9682ac", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/b33e234155b33ab6bce280fb2445b62b68622b61/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e234155b33ab6bce280fb2445b62b68622b61/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=b33e234155b33ab6bce280fb2445b62b68622b61", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n //! Definitions of a bunch of iterators for `[T]`.\n \n #[macro_use] // import iterator! and forward_iterator!\n@@ -2967,3 +2968,176 @@ unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n         false\n     }\n }\n+\n+/// An iterator over slice in (non-overlapping) chunks separated by a predicate.\n+///\n+/// This struct is created by the [`group_by`] method on [slices].\n+///\n+/// [`group_by`]: ../../std/primitive.slice.html#method.group_by\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+pub struct GroupBy<'a, T: 'a, P> {\n+    slice: &'a [T],\n+    predicate: P,\n+}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+impl<'a, T: 'a, P> GroupBy<'a, T, P> {\n+    pub(super) fn new(slice: &'a [T], predicate: P) -> Self {\n+        GroupBy { slice, predicate }\n+    }\n+}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+impl<'a, T: 'a, P> Iterator for GroupBy<'a, T, P>\n+where\n+    P: FnMut(&T, &T) -> bool,\n+{\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.slice.is_empty() {\n+            None\n+        } else {\n+            let mut len = 1;\n+            let mut iter = self.slice.windows(2);\n+            while let Some([l, r]) = iter.next() {\n+                if (self.predicate)(l, r) { len += 1 } else { break }\n+            }\n+            let (head, tail) = self.slice.split_at(len);\n+            self.slice = tail;\n+            Some(head)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.slice.is_empty() { (0, Some(0)) } else { (1, Some(self.slice.len())) }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+impl<'a, T: 'a, P> DoubleEndedIterator for GroupBy<'a, T, P>\n+where\n+    P: FnMut(&T, &T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.slice.is_empty() {\n+            None\n+        } else {\n+            let mut len = 1;\n+            let mut iter = self.slice.windows(2);\n+            while let Some([l, r]) = iter.next_back() {\n+                if (self.predicate)(l, r) { len += 1 } else { break }\n+            }\n+            let (head, tail) = self.slice.split_at(self.slice.len() - len);\n+            self.slice = head;\n+            Some(tail)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+impl<'a, T: 'a, P> FusedIterator for GroupBy<'a, T, P> where P: FnMut(&T, &T) -> bool {}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for GroupBy<'a, T, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"GroupBy\").field(\"slice\", &self.slice).finish()\n+    }\n+}\n+\n+/// An iterator over slice in (non-overlapping) mutable chunks separated\n+/// by a predicate.\n+///\n+/// This struct is created by the [`group_by_mut`] method on [slices].\n+///\n+/// [`group_by_mut`]: ../../std/primitive.slice.html#method.group_by_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+pub struct GroupByMut<'a, T: 'a, P> {\n+    slice: &'a mut [T],\n+    predicate: P,\n+}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+impl<'a, T: 'a, P> GroupByMut<'a, T, P> {\n+    pub(super) fn new(slice: &'a mut [T], predicate: P) -> Self {\n+        GroupByMut { slice, predicate }\n+    }\n+}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+impl<'a, T: 'a, P> Iterator for GroupByMut<'a, T, P>\n+where\n+    P: FnMut(&T, &T) -> bool,\n+{\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.slice.is_empty() {\n+            None\n+        } else {\n+            let mut len = 1;\n+            let mut iter = self.slice.windows(2);\n+            while let Some([l, r]) = iter.next() {\n+                if (self.predicate)(l, r) { len += 1 } else { break }\n+            }\n+            let slice = mem::take(&mut self.slice);\n+            let (head, tail) = slice.split_at_mut(len);\n+            self.slice = tail;\n+            Some(head)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.slice.is_empty() { (0, Some(0)) } else { (1, Some(self.slice.len())) }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+impl<'a, T: 'a, P> DoubleEndedIterator for GroupByMut<'a, T, P>\n+where\n+    P: FnMut(&T, &T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.slice.is_empty() {\n+            None\n+        } else {\n+            let mut len = 1;\n+            let mut iter = self.slice.windows(2);\n+            while let Some([l, r]) = iter.next_back() {\n+                if (self.predicate)(l, r) { len += 1 } else { break }\n+            }\n+            let slice = mem::take(&mut self.slice);\n+            let (head, tail) = slice.split_at_mut(slice.len() - len);\n+            self.slice = head;\n+            Some(tail)\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+impl<'a, T: 'a, P> FusedIterator for GroupByMut<'a, T, P> where P: FnMut(&T, &T) -> bool {}\n+\n+#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+impl<'a, T: 'a + fmt::Debug, P> fmt::Debug for GroupByMut<'a, T, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"GroupByMut\").field(\"slice\", &self.slice).finish()\n+    }\n+}"}, {"sha": "58bf74c8cf470252308a050b50d673e9ba334c2d", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b33e234155b33ab6bce280fb2445b62b68622b61/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e234155b33ab6bce280fb2445b62b68622b61/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=b33e234155b33ab6bce280fb2445b62b68622b61", "patch": "@@ -57,6 +57,9 @@ pub use iter::{ArrayChunks, ArrayChunksMut};\n #[unstable(feature = \"array_windows\", issue = \"75027\")]\n pub use iter::ArrayWindows;\n \n+#[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+pub use iter::{GroupBy, GroupByMut};\n+\n #[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n pub use iter::{SplitInclusive, SplitInclusiveMut};\n \n@@ -1208,6 +1211,96 @@ impl<T> [T] {\n         RChunksExactMut::new(self, chunk_size)\n     }\n \n+    /// Returns an iterator over the slice producing non-overlapping runs\n+    /// of elements using the predicate to separate them.\n+    ///\n+    /// The predicate is called on two elements following themselves,\n+    /// it means the predicate is called on `slice[0]` and `slice[1]`\n+    /// then on `slice[1]` and `slice[2]` and so on.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_group_by)]\n+    ///\n+    /// let slice = &[1, 1, 1, 3, 3, 2, 2, 2];\n+    ///\n+    /// let mut iter = slice.group_by(|a, b| a == b);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&[1, 1, 1][..]));\n+    /// assert_eq!(iter.next(), Some(&[3, 3][..]));\n+    /// assert_eq!(iter.next(), Some(&[2, 2, 2][..]));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// This method can be used to extract the sorted subslices:\n+    ///\n+    /// ```\n+    /// #![feature(slice_group_by)]\n+    ///\n+    /// let slice = &[1, 1, 2, 3, 2, 3, 2, 3, 4];\n+    ///\n+    /// let mut iter = slice.group_by(|a, b| a <= b);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&[1, 1, 2, 3][..]));\n+    /// assert_eq!(iter.next(), Some(&[2, 3][..]));\n+    /// assert_eq!(iter.next(), Some(&[2, 3, 4][..]));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+    #[inline]\n+    pub fn group_by<F>(&self, pred: F) -> GroupBy<'_, T, F>\n+    where\n+        F: FnMut(&T, &T) -> bool,\n+    {\n+        GroupBy::new(self, pred)\n+    }\n+\n+    /// Returns an iterator over the slice producing non-overlapping mutable\n+    /// runs of elements using the predicate to separate them.\n+    ///\n+    /// The predicate is called on two elements following themselves,\n+    /// it means the predicate is called on `slice[0]` and `slice[1]`\n+    /// then on `slice[1]` and `slice[2]` and so on.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_group_by)]\n+    ///\n+    /// let slice = &mut [1, 1, 1, 3, 3, 2, 2, 2];\n+    ///\n+    /// let mut iter = slice.group_by_mut(|a, b| a == b);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&mut [1, 1, 1][..]));\n+    /// assert_eq!(iter.next(), Some(&mut [3, 3][..]));\n+    /// assert_eq!(iter.next(), Some(&mut [2, 2, 2][..]));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    ///\n+    /// This method can be used to extract the sorted subslices:\n+    ///\n+    /// ```\n+    /// #![feature(slice_group_by)]\n+    ///\n+    /// let slice = &mut [1, 1, 2, 3, 2, 3, 2, 3, 4];\n+    ///\n+    /// let mut iter = slice.group_by_mut(|a, b| a <= b);\n+    ///\n+    /// assert_eq!(iter.next(), Some(&mut [1, 1, 2, 3][..]));\n+    /// assert_eq!(iter.next(), Some(&mut [2, 3][..]));\n+    /// assert_eq!(iter.next(), Some(&mut [2, 3, 4][..]));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[unstable(feature = \"slice_group_by\", issue = \"80552\")]\n+    #[inline]\n+    pub fn group_by_mut<F>(&mut self, pred: F) -> GroupByMut<'_, T, F>\n+    where\n+        F: FnMut(&T, &T) -> bool,\n+    {\n+        GroupByMut::new(self, pred)\n+    }\n+\n     /// Divides one slice into two at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding"}, {"sha": "e01aaa4cbf1793899f1163da673c0fb23e7badbf", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b33e234155b33ab6bce280fb2445b62b68622b61/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b33e234155b33ab6bce280fb2445b62b68622b61/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=b33e234155b33ab6bce280fb2445b62b68622b61", "patch": "@@ -72,6 +72,7 @@\n #![feature(nonzero_leading_trailing_zeros)]\n #![feature(const_option)]\n #![feature(integer_atomics)]\n+#![feature(slice_group_by)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;"}]}