{"sha": "b0280ac5385433bd663e825e24f6990a816a5f40", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMjgwYWM1Mzg1NDMzYmQ2NjNlODI1ZTI0ZjY5OTBhODE2YTVmNDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-27T09:21:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-27T09:21:31Z"}, "message": "auto merge of #11834 : huonw/rust/deriving-spans, r=alexcrichton\n\nI'd forgotten to update them when I changed this a while ago; it now displays error messages linked to the struct/variant field, rather than the `#[deriving(Trait)]` line, for all traits.\r\n\r\nThis also adds a very large number of autogenerated tests. I can easily remove/tone down that commit if necessary.", "tree": {"sha": "3a333ac3fc75a76e728985ab96c3be9fb158ca80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a333ac3fc75a76e728985ab96c3be9fb158ca80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0280ac5385433bd663e825e24f6990a816a5f40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0280ac5385433bd663e825e24f6990a816a5f40", "html_url": "https://github.com/rust-lang/rust/commit/b0280ac5385433bd663e825e24f6990a816a5f40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0280ac5385433bd663e825e24f6990a816a5f40/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b2fdfaaec1f405ac613a50d448e2dd3f22e3f10", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b2fdfaaec1f405ac613a50d448e2dd3f22e3f10", "html_url": "https://github.com/rust-lang/rust/commit/4b2fdfaaec1f405ac613a50d448e2dd3f22e3f10"}, {"sha": "d9a204bf4c32743fad187b5c660279c779643b3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9a204bf4c32743fad187b5c660279c779643b3f", "html_url": "https://github.com/rust-lang/rust/commit/d9a204bf4c32743fad187b5c660279c779643b3f"}], "stats": {"total": 1216, "additions": 1051, "deletions": 165}, "files": [{"sha": "e66b7113a451da32881560e201b506585ebb0197", "filename": "src/etc/generate-deriving-span-tests.py", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,131 @@\n+#!/usr/bin/env python\n+# xfail-license\n+# Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+\"\"\"\n+This script creates a pile of compile-fail tests check that all the\n+derivings have spans that point to the fields, rather than the\n+#[deriving(...)] line.\n+\n+sample usage: src/etc/generate-deriving-span-tests.py\n+\"\"\"\n+\n+import sys, os, datetime, stat\n+\n+TEST_DIR = os.path.abspath(\n+    os.path.join(os.path.dirname(__file__), '../test/compile-fail'))\n+\n+YEAR = datetime.datetime.now().year\n+\n+TEMPLATE = \"\"\"// Copyright {year} The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+{error_deriving}\n+struct Error;\n+{code}\n+fn main() {{}}\n+\"\"\"\n+\n+ENUM_STRING = \"\"\"\n+#[deriving({traits})]\n+enum Enum {{\n+   A(\n+     Error {errors}\n+     )\n+}}\n+\"\"\"\n+ENUM_STRUCT_VARIANT_STRING = \"\"\"\n+#[deriving({traits})]\n+enum Enum {{\n+   A {{\n+     x: Error {errors}\n+   }}\n+}}\n+\"\"\"\n+STRUCT_STRING = \"\"\"\n+#[deriving({traits})]\n+struct Struct {{\n+    x: Error {errors}\n+}}\n+\"\"\"\n+STRUCT_TUPLE_STRING = \"\"\"\n+#[deriving({traits})]\n+struct Struct(\n+    Error {errors}\n+);\n+\"\"\"\n+\n+ENUM_TUPLE, ENUM_STRUCT, STRUCT_FIELDS, STRUCT_TUPLE = range(4)\n+\n+def create_test_case(type, trait, super_traits, number_of_errors):\n+    string = [ENUM_STRING, ENUM_STRUCT_VARIANT_STRING, STRUCT_STRING, STRUCT_TUPLE_STRING][type]\n+    all_traits = ','.join([trait] + super_traits)\n+    super_traits = ','.join(super_traits)\n+    error_deriving = '#[deriving(%s)]' % super_traits if super_traits else ''\n+\n+    errors = '\\n'.join('//~%s ERROR' % ('^' * n) for n in range(error_count))\n+    code = string.format(traits = all_traits, errors = errors)\n+    return TEMPLATE.format(year = YEAR, error_deriving=error_deriving, code = code)\n+\n+def write_file(name, string):\n+    test_file = os.path.join(TEST_DIR, 'deriving-span-%s.rs' % name)\n+\n+    # set write permission if file exists, so it can be changed\n+    if os.path.exists(test_file):\n+        os.chmod(test_file, stat.S_IWUSR)\n+\n+    with open(test_file, 'wt') as f:\n+        f.write(string)\n+\n+    # mark file read-only\n+    os.chmod(test_file, stat.S_IRUSR|stat.S_IRGRP|stat.S_IROTH)\n+\n+\n+\n+ENUM = 1\n+STRUCT = 2\n+ALL = STRUCT | ENUM\n+\n+traits = {\n+    'Zero': (STRUCT, [], 1),\n+    'Default': (STRUCT, [], 1),\n+    'FromPrimitive': (0, [], 0), # only works for C-like enums\n+\n+    'Decodable': (0, [], 0), # FIXME: quoting gives horrible spans\n+    'Encodable': (0, [], 0), # FIXME: quoting gives horrible spans\n+}\n+\n+for (trait, supers, errs) in [('Rand', [], 1),\n+                              ('Clone', [], 1), ('DeepClone', ['Clone'], 1),\n+                              ('Eq', [], 2), ('Ord', [], 8),\n+                              ('TotalEq', [], 2), ('TotalOrd', ['TotalEq'], 2)]:\n+    traits[trait] = (ALL, supers, errs)\n+\n+for (trait, (types, super_traits, error_count)) in traits.items():\n+    mk = lambda ty: create_test_case(ty, trait, super_traits, error_count)\n+    if types & ENUM:\n+        write_file(trait + '-enum', mk(ENUM_TUPLE))\n+        write_file(trait + '-enum-struct-variant', mk(ENUM_STRUCT))\n+    if types & STRUCT:\n+        write_file(trait + '-struct', mk(STRUCT_FIELDS))\n+        write_file(trait + '-tuple-struct', mk(STRUCT_TUPLE))"}, {"sha": "567b89d3453f7e640f5201e499896c1d25a52429", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -74,13 +74,13 @@ pub fn expand_deriving_deep_clone(cx: &ExtCtxt,\n \n fn cs_clone(\n     name: &str,\n-    cx: &ExtCtxt, span: Span,\n+    cx: &ExtCtxt, trait_span: Span,\n     substr: &Substructure) -> @Expr {\n     let clone_ident = substr.method_ident;\n     let ctor_ident;\n     let all_fields;\n-    let subcall = |field|\n-        cx.expr_method_call(span, field, clone_ident, ~[]);\n+    let subcall = |field: &FieldInfo|\n+        cx.expr_method_call(field.span, field.self_, clone_ident, ~[]);\n \n     match *substr.fields {\n         Struct(ref af) => {\n@@ -91,37 +91,37 @@ fn cs_clone(\n             ctor_ident = variant.node.name;\n             all_fields = af;\n         },\n-        EnumNonMatching(..) => cx.span_bug(span,\n-                                          format!(\"Non-matching enum variants in `deriving({})`\",\n-                                               name)),\n-        StaticEnum(..) | StaticStruct(..) => cx.span_bug(span,\n-                                                       format!(\"Static method in `deriving({})`\",\n-                                                            name))\n+        EnumNonMatching(..) => cx.span_bug(trait_span,\n+                                           format!(\"Non-matching enum variants in `deriving({})`\",\n+                                                  name)),\n+        StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span,\n+                                                         format!(\"Static method in `deriving({})`\",\n+                                                                 name))\n     }\n \n     match *all_fields {\n         [FieldInfo { name: None, .. }, ..] => {\n             // enum-like\n-            let subcalls = all_fields.map(|field| subcall(field.self_));\n-            cx.expr_call_ident(span, ctor_ident, subcalls)\n+            let subcalls = all_fields.map(subcall);\n+            cx.expr_call_ident(trait_span, ctor_ident, subcalls)\n         },\n         _ => {\n             // struct-like\n             let fields = all_fields.map(|field| {\n                 let ident = match field.name {\n                     Some(i) => i,\n-                    None => cx.span_bug(span,\n+                    None => cx.span_bug(trait_span,\n                                         format!(\"unnamed field in normal struct in `deriving({})`\",\n-                                             name))\n+                                                name))\n                 };\n-                cx.field_imm(span, ident, subcall(field.self_))\n+                cx.field_imm(field.span, ident, subcall(field))\n             });\n \n             if fields.is_empty() {\n                 // no fields, so construct like `None`\n-                cx.expr_ident(span, ctor_ident)\n+                cx.expr_ident(trait_span, ctor_ident)\n             } else {\n-                cx.expr_struct_ident(span, ctor_ident, fields)\n+                cx.expr_struct_ident(trait_span, ctor_ident, fields)\n             }\n         }\n     }"}, {"sha": "a9268d85c91547e2c62a8ef6024fcb25c1a40558", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -51,7 +51,7 @@ pub fn expand_deriving_decodable(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn decodable_substructure(cx: &ExtCtxt, span: Span,\n+fn decodable_substructure(cx: &ExtCtxt, trait_span: Span,\n                           substr: &Substructure) -> @Expr {\n     let decoder = substr.nonself_args[0];\n     let recurse = ~[cx.ident_of(\"extra\"),\n@@ -60,9 +60,9 @@ fn decodable_substructure(cx: &ExtCtxt, span: Span,\n                     cx.ident_of(\"decode\")];\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_d\");\n-    let blkdecoder = cx.expr_ident(span, blkarg);\n-    let calldecode = cx.expr_call_global(span, recurse, ~[blkdecoder]);\n-    let lambdadecode = cx.lambda_expr_1(span, calldecode, blkarg);\n+    let blkdecoder = cx.expr_ident(trait_span, blkarg);\n+    let calldecode = cx.expr_call_global(trait_span, recurse, ~[blkdecoder]);\n+    let lambdadecode = cx.lambda_expr_1(trait_span, calldecode, blkarg);\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {\n@@ -73,7 +73,7 @@ fn decodable_substructure(cx: &ExtCtxt, span: Span,\n             let read_struct_field = cx.ident_of(\"read_struct_field\");\n \n             let result = decode_static_fields(cx,\n-                                              span,\n+                                              trait_span,\n                                               substr.type_ident,\n                                               summary,\n                                               |span, name, field| {\n@@ -82,10 +82,10 @@ fn decodable_substructure(cx: &ExtCtxt, span: Span,\n                                       cx.expr_uint(span, field),\n                                       lambdadecode])\n             });\n-            cx.expr_method_call(span, decoder, cx.ident_of(\"read_struct\"),\n-                                ~[cx.expr_str(span, cx.str_of(substr.type_ident)),\n-                                  cx.expr_uint(span, nfields),\n-                                  cx.lambda_expr_1(span, result, blkarg)])\n+            cx.expr_method_call(trait_span, decoder, cx.ident_of(\"read_struct\"),\n+                                ~[cx.expr_str(trait_span, cx.str_of(substr.type_ident)),\n+                                  cx.expr_uint(trait_span, nfields),\n+                                  cx.lambda_expr_1(trait_span, result, blkarg)])\n         }\n         StaticEnum(_, ref fields) => {\n             let variant = cx.ident_of(\"i\");\n@@ -94,12 +94,11 @@ fn decodable_substructure(cx: &ExtCtxt, span: Span,\n             let mut variants = ~[];\n             let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n \n-            for (i, f) in fields.iter().enumerate() {\n-                let (name, parts) = match *f { (i, ref p) => (i, p) };\n-                variants.push(cx.expr_str(span, cx.str_of(name)));\n+            for (i, &(name, v_span, ref parts)) in fields.iter().enumerate() {\n+                variants.push(cx.expr_str(v_span, cx.str_of(name)));\n \n                 let decoded = decode_static_fields(cx,\n-                                                   span,\n+                                                   v_span,\n                                                    name,\n                                                    parts,\n                                                    |span, _, field| {\n@@ -108,22 +107,22 @@ fn decodable_substructure(cx: &ExtCtxt, span: Span,\n                                           lambdadecode])\n                 });\n \n-                arms.push(cx.arm(span,\n-                                 ~[cx.pat_lit(span, cx.expr_uint(span, i))],\n+                arms.push(cx.arm(v_span,\n+                                 ~[cx.pat_lit(v_span, cx.expr_uint(v_span, i))],\n                                  decoded));\n             }\n \n-            arms.push(cx.arm_unreachable(span));\n+            arms.push(cx.arm_unreachable(trait_span));\n \n-            let result = cx.expr_match(span, cx.expr_ident(span, variant), arms);\n-            let lambda = cx.lambda_expr(span, ~[blkarg, variant], result);\n-            let variant_vec = cx.expr_vec(span, variants);\n-            let result = cx.expr_method_call(span, blkdecoder,\n+            let result = cx.expr_match(trait_span, cx.expr_ident(trait_span, variant), arms);\n+            let lambda = cx.lambda_expr(trait_span, ~[blkarg, variant], result);\n+            let variant_vec = cx.expr_vec(trait_span, variants);\n+            let result = cx.expr_method_call(trait_span, blkdecoder,\n                                              cx.ident_of(\"read_enum_variant\"),\n                                              ~[variant_vec, lambda]);\n-            cx.expr_method_call(span, decoder, cx.ident_of(\"read_enum\"),\n-                                ~[cx.expr_str(span, cx.str_of(substr.type_ident)),\n-                                  cx.lambda_expr_1(span, result, blkarg)])\n+            cx.expr_method_call(trait_span, decoder, cx.ident_of(\"read_enum\"),\n+                                ~[cx.expr_str(trait_span, cx.str_of(substr.type_ident)),\n+                                  cx.lambda_expr_1(trait_span, result, blkarg)])\n         }\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in deriving(Decodable)\")\n     };\n@@ -133,29 +132,29 @@ fn decodable_substructure(cx: &ExtCtxt, span: Span,\n /// - `outer_pat_ident` is the name of this enum variant/struct\n /// - `getarg` should retrieve the `uint`-th field with name `@str`.\n fn decode_static_fields(cx: &ExtCtxt,\n-                        outer_span: Span,\n+                        trait_span: Span,\n                         outer_pat_ident: Ident,\n                         fields: &StaticFields,\n                         getarg: |Span, @str, uint| -> @Expr)\n                         -> @Expr {\n     match *fields {\n         Unnamed(ref fields) => {\n             if fields.is_empty() {\n-                cx.expr_ident(outer_span, outer_pat_ident)\n+                cx.expr_ident(trait_span, outer_pat_ident)\n             } else {\n                 let fields = fields.iter().enumerate().map(|(i, &span)| {\n                     getarg(span, format!(\"_field{}\", i).to_managed(), i)\n                 }).collect();\n \n-                cx.expr_call_ident(outer_span, outer_pat_ident, fields)\n+                cx.expr_call_ident(trait_span, outer_pat_ident, fields)\n             }\n         }\n         Named(ref fields) => {\n             // use the field's span to get nicer error messages.\n             let fields = fields.iter().enumerate().map(|(i, &(name, span))| {\n                 cx.field_imm(span, name, getarg(span, cx.str_of(name), i))\n             }).collect();\n-            cx.expr_struct_ident(outer_span, outer_pat_ident, fields)\n+            cx.expr_struct_ident(trait_span, outer_pat_ident, fields)\n         }\n     }\n }"}, {"sha": "22f850d56090e845abc57488836a51dfe723f5ea", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -41,7 +41,7 @@ pub fn expand_deriving_default(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn default_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn default_substructure(cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let default_ident = ~[\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"default\"),\n@@ -55,25 +55,25 @@ fn default_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Exp\n             match *summary {\n                 Unnamed(ref fields) => {\n                     if fields.is_empty() {\n-                        cx.expr_ident(span, substr.type_ident)\n+                        cx.expr_ident(trait_span, substr.type_ident)\n                     } else {\n                         let exprs = fields.map(|sp| default_call(*sp));\n-                        cx.expr_call_ident(span, substr.type_ident, exprs)\n+                        cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n                     }\n                 }\n                 Named(ref fields) => {\n                     let default_fields = fields.map(|&(ident, span)| {\n                         cx.field_imm(span, ident, default_call(span))\n                     });\n-                    cx.expr_struct_ident(span, substr.type_ident, default_fields)\n+                    cx.expr_struct_ident(trait_span, substr.type_ident, default_fields)\n                 }\n             }\n         }\n         StaticEnum(..) => {\n-            cx.span_err(span, \"`Default` cannot be derived for enums, only structs\");\n+            cx.span_err(trait_span, \"`Default` cannot be derived for enums, only structs\");\n             // let compilation continue\n-            cx.expr_uint(span, 0)\n+            cx.expr_uint(trait_span, 0)\n         }\n-        _ => cx.bug(\"Non-static method in `deriving(Default)`\")\n+        _ => cx.span_bug(trait_span, \"Non-static method in `deriving(Default)`\")\n     };\n }"}, {"sha": "9a8861f2e70e2daf3bc8a0a6671c6152361fd5a2", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -113,24 +113,24 @@ pub fn expand_deriving_encodable(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn encodable_substructure(cx: &ExtCtxt, span: Span,\n+fn encodable_substructure(cx: &ExtCtxt, trait_span: Span,\n                           substr: &Substructure) -> @Expr {\n     let encoder = substr.nonself_args[0];\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_e\");\n-    let blkencoder = cx.expr_ident(span, blkarg);\n+    let blkencoder = cx.expr_ident(trait_span, blkarg);\n     let encode = cx.ident_of(\"encode\");\n \n     return match *substr.fields {\n         Struct(ref fields) => {\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n             let mut stmts = ~[];\n-            for (i, f) in fields.iter().enumerate() {\n-                let name = match f.name {\n+            for (i, &FieldInfo { name, self_, span, .. }) in fields.iter().enumerate() {\n+                let name = match name {\n                     Some(id) => cx.str_of(id),\n                     None => format!(\"_field{}\", i).to_managed()\n                 };\n-                let enc = cx.expr_method_call(span, f.self_, encode, ~[blkencoder]);\n+                let enc = cx.expr_method_call(span, self_, encode, ~[blkencoder]);\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n                 let call = cx.expr_method_call(span, blkencoder,\n                                                emit_struct_field,\n@@ -140,10 +140,10 @@ fn encodable_substructure(cx: &ExtCtxt, span: Span,\n                 stmts.push(cx.stmt_expr(call));\n             }\n \n-            let blk = cx.lambda_stmts_1(span, stmts, blkarg);\n-            cx.expr_method_call(span, encoder, cx.ident_of(\"emit_struct\"),\n-                                ~[cx.expr_str(span, cx.str_of(substr.type_ident)),\n-                                  cx.expr_uint(span, fields.len()),\n+            let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n+            cx.expr_method_call(trait_span, encoder, cx.ident_of(\"emit_struct\"),\n+                                ~[cx.expr_str(trait_span, cx.str_of(substr.type_ident)),\n+                                  cx.expr_uint(trait_span, fields.len()),\n                                   blk])\n         }\n \n@@ -152,12 +152,12 @@ fn encodable_substructure(cx: &ExtCtxt, span: Span,\n             // so we need to generate a unique local variable to take the\n             // mutable loan out on, otherwise we get conflicts which don't\n             // actually exist.\n-            let me = cx.stmt_let(span, false, blkarg, encoder);\n-            let encoder = cx.expr_ident(span, blkarg);\n+            let me = cx.stmt_let(trait_span, false, blkarg, encoder);\n+            let encoder = cx.expr_ident(trait_span, blkarg);\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n             let mut stmts = ~[];\n-            for (i, f) in fields.iter().enumerate() {\n-                let enc = cx.expr_method_call(span, f.self_, encode, ~[blkencoder]);\n+            for (i, &FieldInfo { self_, span, .. }) in fields.iter().enumerate() {\n+                let enc = cx.expr_method_call(span, self_, encode, ~[blkencoder]);\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n                 let call = cx.expr_method_call(span, blkencoder,\n                                                emit_variant_arg,\n@@ -166,21 +166,21 @@ fn encodable_substructure(cx: &ExtCtxt, span: Span,\n                 stmts.push(cx.stmt_expr(call));\n             }\n \n-            let blk = cx.lambda_stmts_1(span, stmts, blkarg);\n-            let name = cx.expr_str(span, cx.str_of(variant.node.name));\n-            let call = cx.expr_method_call(span, blkencoder,\n+            let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n+            let name = cx.expr_str(trait_span, cx.str_of(variant.node.name));\n+            let call = cx.expr_method_call(trait_span, blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),\n                                            ~[name,\n-                                             cx.expr_uint(span, idx),\n-                                             cx.expr_uint(span, fields.len()),\n+                                             cx.expr_uint(trait_span, idx),\n+                                             cx.expr_uint(trait_span, fields.len()),\n                                              blk]);\n-            let blk = cx.lambda_expr_1(span, call, blkarg);\n-            let ret = cx.expr_method_call(span, encoder,\n+            let blk = cx.lambda_expr_1(trait_span, call, blkarg);\n+            let ret = cx.expr_method_call(trait_span, encoder,\n                                           cx.ident_of(\"emit_enum\"),\n-                                          ~[cx.expr_str(span,\n+                                          ~[cx.expr_str(trait_span,\n                                             cx.str_of(substr.type_ident)),\n                                             blk]);\n-            cx.expr_block(cx.block(span, ~[me], Some(ret)))\n+            cx.expr_block(cx.block(trait_span, ~[me], Some(ret)))\n         }\n \n         _ => cx.bug(\"expected Struct or EnumMatching in deriving(Encodable)\")"}, {"sha": "1f778779fbd42a30f679681d41db6974ca3b71d7", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -68,6 +68,7 @@ enum C {\n     C0(int),\n     C1 { x: int }\n }\n+~~~\n \n The `int`s in `B` and `C0` don't have an identifier, so the\n `Option<ident>`s would be `None` for them.\n@@ -168,8 +169,9 @@ StaticStruct(<ast::StructDef of A>, Named(~[(<ident of x>, <span of x>)]))\n \n StaticStruct(<ast::StructDef of B>, Unnamed(~[<span of x>]))\n \n-StaticEnum(<ast::EnumDef of C>, ~[(<ident of C0>, Unnamed(~[<span of int>])),\n-                                  (<ident of C1>, Named(~[(<ident of x>, <span of x>)]))])\n+StaticEnum(<ast::EnumDef of C>, ~[(<ident of C0>, <span of C0>, Unnamed(~[<span of int>])),\n+                                  (<ident of C1>, <span of C1>,\n+                                   Named(~[(<ident of x>, <span of x>)]))])\n ~~~\n \n */\n@@ -290,7 +292,7 @@ pub enum SubstructureFields<'a> {\n     /// A static method where Self is a struct.\n     StaticStruct(&'a ast::StructDef, StaticFields),\n     /// A static method where Self is an enum.\n-    StaticEnum(&'a ast::EnumDef, ~[(Ident, StaticFields)])\n+    StaticEnum(&'a ast::EnumDef, ~[(Ident, Span, StaticFields)])\n }\n \n \n@@ -904,7 +906,7 @@ impl<'a> MethodDef<'a> {\n                     trait_.summarise_struct(struct_def)\n                 }\n             };\n-            (ident, summary)\n+            (ident, v.span, summary)\n         });\n         self.call_substructure_method(trait_, type_ident,\n                                       self_args, nonself_args,"}, {"sha": "d82e1ef1842614de0f044ff8a1df86af12691aa7", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -45,19 +45,20 @@ pub fn expand_deriving_iter_bytes(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn iter_bytes_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn iter_bytes_substructure(cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let (lsb0, f)= match substr.nonself_args {\n         [l, f] => (l, f),\n-        _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(IterBytes)`\")\n+        _ => cx.span_bug(trait_span, \"Incorrect number of arguments in `deriving(IterBytes)`\")\n     };\n     // Build the \"explicitly borrowed\" stack closure, \"|_buf| f(_buf)\".\n     let blk_arg = cx.ident_of(\"_buf\");\n     let borrowed_f =\n-        cx.lambda_expr_1(span, cx.expr_call(span, f, ~[cx.expr_ident(span, blk_arg)]),\n+        cx.lambda_expr_1(trait_span,\n+                         cx.expr_call(trait_span, f, ~[cx.expr_ident(trait_span, blk_arg)]),\n                          blk_arg);\n \n     let iter_bytes_ident = substr.method_ident;\n-    let call_iterbytes = |thing_expr| {\n+    let call_iterbytes = |span, thing_expr| {\n         cx.expr_method_call(span,\n                             thing_expr,\n                             iter_bytes_ident,\n@@ -74,25 +75,25 @@ fn iter_bytes_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @\n             // iteration function.\n             let discriminant = match variant.node.disr_expr {\n                 Some(d)=> d,\n-                None => cx.expr_uint(span, index)\n+                None => cx.expr_uint(trait_span, index)\n             };\n \n-            exprs.push(call_iterbytes(discriminant));\n+            exprs.push(call_iterbytes(trait_span, discriminant));\n \n             fields = fs;\n         }\n-        _ => cx.span_bug(span, \"Impossible substructure in `deriving(IterBytes)`\")\n+        _ => cx.span_bug(trait_span, \"Impossible substructure in `deriving(IterBytes)`\")\n     }\n \n-    for &FieldInfo { self_, .. } in fields.iter() {\n-        exprs.push(call_iterbytes(self_));\n+    for &FieldInfo { self_, span, .. } in fields.iter() {\n+        exprs.push(call_iterbytes(span, self_));\n     }\n \n     if exprs.len() == 0 {\n-        cx.span_bug(span, \"#[deriving(IterBytes)] needs at least one field\");\n+        cx.span_bug(trait_span, \"#[deriving(IterBytes)] needs at least one field\");\n     }\n \n     exprs.slice(1, exprs.len()).iter().fold(exprs[0], |prev, me| {\n-        cx.expr_binary(span, BiAnd, prev, *me)\n+        cx.expr_binary(trait_span, BiAnd, prev, *me)\n     })\n }"}, {"sha": "a4e606f53c0c2215ca313185c2c082020f4c925d", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -64,21 +64,22 @@ pub fn expand_deriving_from_primitive(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn cs_from(name: &str, cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn cs_from(name: &str, cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let n = match substr.nonself_args {\n         [n] => n,\n-        _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(FromPrimitive)`\")\n+        _ => cx.span_bug(trait_span, \"Incorrect number of arguments in `deriving(FromPrimitive)`\")\n     };\n \n     match *substr.fields {\n         StaticStruct(..) => {\n-            cx.span_err(span, \"`FromPrimitive` cannot be derived for structs\");\n-            return cx.expr_fail(span, @\"\");\n+            cx.span_err(trait_span, \"`FromPrimitive` cannot be derived for structs\");\n+            return cx.expr_fail(trait_span, @\"\");\n         }\n         StaticEnum(enum_def, _) => {\n             if enum_def.variants.is_empty() {\n-                cx.span_err(span, \"`FromPrimitive` cannot be derived for enums with no variants\");\n-                return cx.expr_fail(span, @\"\");\n+                cx.span_err(trait_span,\n+                            \"`FromPrimitive` cannot be derived for enums with no variants\");\n+                return cx.expr_fail(trait_span, @\"\");\n             }\n \n             let mut arms = ~[];\n@@ -87,10 +88,12 @@ fn cs_from(name: &str, cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr\n                 match variant.node.kind {\n                     ast::TupleVariantKind(ref args) => {\n                         if !args.is_empty() {\n-                            cx.span_err(span, \"`FromPrimitive` cannot be derived for \\\n-                                               enum variants with arguments\");\n-                            return cx.expr_fail(span, @\"\");\n+                            cx.span_err(trait_span,\n+                                        \"`FromPrimitive` cannot be derived for \\\n+                                        enum variants with arguments\");\n+                            return cx.expr_fail(trait_span, @\"\");\n                         }\n+                        let span = variant.span;\n \n                         // expr for `$n == $variant as $name`\n                         let variant = cx.expr_ident(span, variant.node.name);\n@@ -111,23 +114,24 @@ fn cs_from(name: &str, cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr\n                         arms.push(arm);\n                     }\n                     ast::StructVariantKind(_) => {\n-                        cx.span_err(span, \"`FromPrimitive` cannot be derived for enums \\\n-                                           with struct variants\");\n-                        return cx.expr_fail(span, @\"\");\n+                        cx.span_err(trait_span,\n+                                    \"`FromPrimitive` cannot be derived for enums \\\n+                                    with struct variants\");\n+                        return cx.expr_fail(trait_span, @\"\");\n                     }\n                 }\n             }\n \n             // arm for `_ => None`\n             let arm = ast::Arm {\n-                pats: ~[cx.pat_wild(span)],\n+                pats: ~[cx.pat_wild(trait_span)],\n                 guard: None,\n-                body: cx.block_expr(cx.expr_none(span)),\n+                body: cx.block_expr(cx.expr_none(trait_span)),\n             };\n             arms.push(arm);\n \n-            cx.expr_match(span, n, arms)\n+            cx.expr_match(trait_span, n, arms)\n         }\n-        _ => cx.bug(\"expected StaticEnum in deriving(FromPrimitive)\")\n+        _ => cx.span_bug(trait_span, \"expected StaticEnum in deriving(FromPrimitive)\")\n     }\n }"}, {"sha": "a22822c2ddcc5cde3f560f93268cf0c875215f54", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -50,7 +50,7 @@ pub fn expand_deriving_rand(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn rand_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn rand_substructure(cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let rng = match substr.nonself_args {\n         [rng] => ~[ rng ],\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n@@ -69,89 +69,85 @@ fn rand_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {\n-            rand_thing(cx, span, substr.type_ident, summary, rand_call)\n+            rand_thing(cx, trait_span, substr.type_ident, summary, rand_call)\n         }\n         StaticEnum(_, ref variants) => {\n             if variants.is_empty() {\n-                cx.span_err(span, \"`Rand` cannot be derived for enums with no variants\");\n+                cx.span_err(trait_span, \"`Rand` cannot be derived for enums with no variants\");\n                 // let compilation continue\n-                return cx.expr_uint(span, 0);\n+                return cx.expr_uint(trait_span, 0);\n             }\n \n-            let variant_count = cx.expr_uint(span, variants.len());\n+            let variant_count = cx.expr_uint(trait_span, variants.len());\n \n-            let rand_name = cx.path_all(span,\n+            let rand_name = cx.path_all(trait_span,\n                                         true,\n                                         rand_ident.clone(),\n                                         opt_vec::Empty,\n                                         ~[]);\n             let rand_name = cx.expr_path(rand_name);\n \n             // ::std::rand::Rand::rand(rng)\n-            let rv_call = cx.expr_call(span,\n+            let rv_call = cx.expr_call(trait_span,\n                                        rand_name,\n                                        ~[ rng[0] ]);\n \n             // need to specify the uint-ness of the random number\n-            let uint_ty = cx.ty_ident(span, cx.ident_of(\"uint\"));\n+            let uint_ty = cx.ty_ident(trait_span, cx.ident_of(\"uint\"));\n             let value_ident = cx.ident_of(\"__value\");\n-            let let_statement = cx.stmt_let_typed(span,\n+            let let_statement = cx.stmt_let_typed(trait_span,\n                                                   false,\n                                                   value_ident,\n                                                   uint_ty,\n                                                   rv_call);\n \n             // rand() % variants.len()\n-            let value_ref = cx.expr_ident(span, value_ident);\n-            let rand_variant = cx.expr_binary(span,\n+            let value_ref = cx.expr_ident(trait_span, value_ident);\n+            let rand_variant = cx.expr_binary(trait_span,\n                                               ast::BiRem,\n                                               value_ref,\n                                               variant_count);\n \n-            let mut arms = variants.iter().enumerate().map(|(i, id_sum)| {\n-                let i_expr = cx.expr_uint(span, i);\n-                let pat = cx.pat_lit(span, i_expr);\n+            let mut arms = variants.iter().enumerate().map(|(i, &(ident, v_span, ref summary))| {\n+                let i_expr = cx.expr_uint(v_span, i);\n+                let pat = cx.pat_lit(v_span, i_expr);\n \n-                match *id_sum {\n-                    (ident, ref summary) => {\n-                        cx.arm(span,\n-                               ~[ pat ],\n-                               rand_thing(cx, span, ident, summary, |sp| rand_call(sp)))\n-                    }\n-                }\n+                cx.arm(v_span,\n+                       ~[ pat ],\n+                       rand_thing(cx, v_span, ident, summary, |sp| rand_call(sp)))\n             }).collect::<~[ast::Arm]>();\n \n             // _ => {} at the end. Should never occur\n-            arms.push(cx.arm_unreachable(span));\n+            arms.push(cx.arm_unreachable(trait_span));\n \n-            let match_expr = cx.expr_match(span, rand_variant, arms);\n+            let match_expr = cx.expr_match(trait_span, rand_variant, arms);\n \n-            let block = cx.block(span, ~[ let_statement ], Some(match_expr));\n+            let block = cx.block(trait_span, ~[ let_statement ], Some(match_expr));\n             cx.expr_block(block)\n         }\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n     };\n \n     fn rand_thing(cx: &ExtCtxt,\n-                  span: Span,\n+                  trait_span: Span,\n                   ctor_ident: Ident,\n                   summary: &StaticFields,\n                   rand_call: |Span| -> @Expr)\n                   -> @Expr {\n         match *summary {\n             Unnamed(ref fields) => {\n                 if fields.is_empty() {\n-                    cx.expr_ident(span, ctor_ident)\n+                    cx.expr_ident(trait_span, ctor_ident)\n                 } else {\n                     let exprs = fields.map(|span| rand_call(*span));\n-                    cx.expr_call_ident(span, ctor_ident, exprs)\n+                    cx.expr_call_ident(trait_span, ctor_ident, exprs)\n                 }\n             }\n             Named(ref fields) => {\n                 let rand_fields = fields.map(|&(ident, span)| {\n                     cx.field_imm(span, ident, rand_call(span))\n                 });\n-                cx.expr_struct_ident(span, ctor_ident, rand_fields)\n+                cx.expr_struct_ident(trait_span, ctor_ident, rand_fields)\n             }\n         }\n     }"}, {"sha": "dd99e8216200544f59d4158c71e5005cdd35a617", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -57,7 +57,7 @@ pub fn expand_deriving_zero(cx: &ExtCtxt,\n     trait_def.expand(mitem, in_items)\n }\n \n-fn zero_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n+fn zero_substructure(cx: &ExtCtxt, trait_span: Span, substr: &Substructure) -> @Expr {\n     let zero_ident = ~[\n         cx.ident_of(\"std\"),\n         cx.ident_of(\"num\"),\n@@ -71,24 +71,24 @@ fn zero_substructure(cx: &ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n             match *summary {\n                 Unnamed(ref fields) => {\n                     if fields.is_empty() {\n-                        cx.expr_ident(span, substr.type_ident)\n+                        cx.expr_ident(trait_span, substr.type_ident)\n                     } else {\n                         let exprs = fields.map(|sp| zero_call(*sp));\n-                        cx.expr_call_ident(span, substr.type_ident, exprs)\n+                        cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n                     }\n                 }\n                 Named(ref fields) => {\n                     let zero_fields = fields.map(|&(ident, span)| {\n                         cx.field_imm(span, ident, zero_call(span))\n                     });\n-                    cx.expr_struct_ident(span, substr.type_ident, zero_fields)\n+                    cx.expr_struct_ident(trait_span, substr.type_ident, zero_fields)\n                 }\n             }\n         }\n         StaticEnum(..) => {\n-            cx.span_err(span, \"`Zero` cannot be derived for enums, only structs\");\n+            cx.span_err(trait_span, \"`Zero` cannot be derived for enums, only structs\");\n             // let compilation continue\n-            cx.expr_uint(span, 0)\n+            cx.expr_uint(trait_span, 0)\n         }\n         _ => cx.bug(\"Non-static method in `deriving(Zero)`\")\n     };"}, {"sha": "983156f9b4ffbb9654bb30b1f3182647e7e1782c", "filename": "src/test/compile-fail/deriving-span-Clone-enum-struct-variant.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-enum-struct-variant.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Clone)]\n+enum Enum {\n+   A {\n+     x: Error //~ ERROR\n+   }\n+}\n+\n+fn main() {}"}, {"sha": "e5ceef886e1d3af7b627b206113f9c4e8f37714f", "filename": "src/test/compile-fail/deriving-span-Clone-enum.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-enum.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Clone)]\n+enum Enum {\n+   A(\n+     Error //~ ERROR\n+     )\n+}\n+\n+fn main() {}"}, {"sha": "fd763df311c67340382e54649be58e59b98670ba", "filename": "src/test/compile-fail/deriving-span-Clone-struct.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Clone)]\n+struct Struct {\n+    x: Error //~ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "d444c5e3161684a4d5320e26a5eebc1a7576961a", "filename": "src/test/compile-fail/deriving-span-Clone-tuple-struct.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Clone-tuple-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Clone)]\n+struct Struct(\n+    Error //~ ERROR\n+);\n+\n+fn main() {}"}, {"sha": "0dc6266bec41b0919e3dbbf0227fe22ce1d2641f", "filename": "src/test/compile-fail/deriving-span-DeepClone-enum-struct-variant.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-DeepClone-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-DeepClone-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-DeepClone-enum-struct-variant.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+#[deriving(Clone)]\n+struct Error;\n+\n+#[deriving(DeepClone,Clone)]\n+enum Enum {\n+   A {\n+     x: Error //~ ERROR\n+   }\n+}\n+\n+fn main() {}"}, {"sha": "5b210d0ff7964181c538c787157b38b3c785dad9", "filename": "src/test/compile-fail/deriving-span-DeepClone-enum.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-DeepClone-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-DeepClone-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-DeepClone-enum.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+#[deriving(Clone)]\n+struct Error;\n+\n+#[deriving(DeepClone,Clone)]\n+enum Enum {\n+   A(\n+     Error //~ ERROR\n+     )\n+}\n+\n+fn main() {}"}, {"sha": "f063ed58dce5b1a33547300aef2f6d005aea1fb9", "filename": "src/test/compile-fail/deriving-span-DeepClone-struct.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-DeepClone-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-DeepClone-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-DeepClone-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+#[deriving(Clone)]\n+struct Error;\n+\n+#[deriving(DeepClone,Clone)]\n+struct Struct {\n+    x: Error //~ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "1b053897c0e016899ec25f14b1d1cc7879616005", "filename": "src/test/compile-fail/deriving-span-DeepClone-tuple-struct.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-DeepClone-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-DeepClone-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-DeepClone-tuple-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+#[deriving(Clone)]\n+struct Error;\n+\n+#[deriving(DeepClone,Clone)]\n+struct Struct(\n+    Error //~ ERROR\n+);\n+\n+fn main() {}"}, {"sha": "7c2edd8cb7bff2217daaff0f83c0d2ad589c7984", "filename": "src/test/compile-fail/deriving-span-Default-struct.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Default)]\n+struct Struct {\n+    x: Error //~ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "e0269a6aad3b2e4f26a97188664c3da0c6a24fc6", "filename": "src/test/compile-fail/deriving-span-Default-tuple-struct.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Default-tuple-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Default)]\n+struct Struct(\n+    Error //~ ERROR\n+);\n+\n+fn main() {}"}, {"sha": "abedb3e660f18ddbbe56cecb3bf8142f0ac821ed", "filename": "src/test/compile-fail/deriving-span-Eq-enum-struct-variant.rs", "status": "renamed", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Eq-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Eq-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Eq-enum-struct-variant.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,16 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n #[feature(struct_variant)];\n+extern mod extra;\n+\n \n-struct NotEq;\n+struct Error;\n \n #[deriving(Eq)]\n-enum Foo {\n-    Bar {\n-        x: NotEq //~ ERROR mismatched types\n-        //~^ ERROR failed to find an implementation of trait std::cmp::Eq for NotEq\n-    }\n+enum Enum {\n+   A {\n+     x: Error //~ ERROR\n+//~^ ERROR\n+   }\n }\n \n-pub fn main() {}\n+fn main() {}", "previous_filename": "src/test/compile-fail/deriving-field-span-enum-struct-variant.rs"}, {"sha": "3486d96205b4d75ea59793f20798b12b43edaae1", "filename": "src/test/compile-fail/deriving-span-Eq-enum.rs", "status": "renamed", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Eq-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Eq-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Eq-enum.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,15 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n #[feature(struct_variant)];\n+extern mod extra;\n+\n \n-struct NotEq;\n+struct Error;\n \n #[deriving(Eq)]\n-enum Foo {\n-    Bar(NotEq), //~ ERROR mismatched types\n-        //~^ ERROR failed to find an implementation of trait std::cmp::Eq for NotEq\n-    Baz { x: NotEq }\n+enum Enum {\n+   A(\n+     Error //~ ERROR\n+//~^ ERROR\n+     )\n }\n \n-pub fn main() {}\n+fn main() {}", "previous_filename": "src/test/compile-fail/deriving-field-span-enum.rs"}, {"sha": "32d2e78eabcefaf141313c4a97e25693b82be6ac", "filename": "src/test/compile-fail/deriving-span-Eq-struct.rs", "status": "renamed", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Eq-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Eq-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Eq-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct NotEq;\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n \n #[deriving(Eq)]\n-struct Foo {\n-    x: NotEq //~ ERROR mismatched types\n-        //~^ ERROR failed to find an implementation of trait std::cmp::Eq for NotEq\n+struct Struct {\n+    x: Error //~ ERROR\n+//~^ ERROR\n }\n \n-pub fn main() {}\n+fn main() {}", "previous_filename": "src/test/compile-fail/deriving-field-span-struct.rs"}, {"sha": "acc46a1002af1170cae9b0e3f23b7b6b86ff91ab", "filename": "src/test/compile-fail/deriving-span-Eq-tuple-struct.rs", "status": "renamed", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Eq-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Eq-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Eq-tuple-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct NotEq;\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n \n #[deriving(Eq)]\n-struct Foo (\n-    NotEq //~ ERROR mismatched types\n-        //~^ ERROR failed to find an implementation of trait std::cmp::Eq for NotEq\n-        );\n+struct Struct(\n+    Error //~ ERROR\n+//~^ ERROR\n+);\n \n-pub fn main() {}\n+fn main() {}", "previous_filename": "src/test/compile-fail/deriving-field-span-tuple-struct.rs"}, {"sha": "933da411db8b723d399949efa83372737c10a2c0", "filename": "src/test/compile-fail/deriving-span-Ord-enum-struct-variant.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Ord-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Ord-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Ord-enum-struct-variant.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Ord)]\n+enum Enum {\n+   A {\n+     x: Error //~ ERROR\n+//~^ ERROR\n+//~^^ ERROR\n+//~^^^ ERROR\n+//~^^^^ ERROR\n+//~^^^^^ ERROR\n+//~^^^^^^ ERROR\n+//~^^^^^^^ ERROR\n+   }\n+}\n+\n+fn main() {}"}, {"sha": "c310965cfa1b9559a87b8978c99ddf127f2db7bf", "filename": "src/test/compile-fail/deriving-span-Ord-enum.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Ord-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Ord-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Ord-enum.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Ord)]\n+enum Enum {\n+   A(\n+     Error //~ ERROR\n+//~^ ERROR\n+//~^^ ERROR\n+//~^^^ ERROR\n+//~^^^^ ERROR\n+//~^^^^^ ERROR\n+//~^^^^^^ ERROR\n+//~^^^^^^^ ERROR\n+     )\n+}\n+\n+fn main() {}"}, {"sha": "327ac73ff2d980d611e9f41669268f7915d268d7", "filename": "src/test/compile-fail/deriving-span-Ord-struct.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Ord-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Ord-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Ord-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Ord)]\n+struct Struct {\n+    x: Error //~ ERROR\n+//~^ ERROR\n+//~^^ ERROR\n+//~^^^ ERROR\n+//~^^^^ ERROR\n+//~^^^^^ ERROR\n+//~^^^^^^ ERROR\n+//~^^^^^^^ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "2a482f872c59a99429d86c19f9d9e5c5538a1235", "filename": "src/test/compile-fail/deriving-span-Ord-tuple-struct.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Ord-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Ord-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Ord-tuple-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Ord)]\n+struct Struct(\n+    Error //~ ERROR\n+//~^ ERROR\n+//~^^ ERROR\n+//~^^^ ERROR\n+//~^^^^ ERROR\n+//~^^^^^ ERROR\n+//~^^^^^^ ERROR\n+//~^^^^^^^ ERROR\n+);\n+\n+fn main() {}"}, {"sha": "ae0732e4db63484873fc0e51a69efe185052c32a", "filename": "src/test/compile-fail/deriving-span-Rand-enum-struct-variant.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-enum-struct-variant.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Rand)]\n+enum Enum {\n+   A {\n+     x: Error //~ ERROR\n+   }\n+}\n+\n+fn main() {}"}, {"sha": "ef29ce082923d9930a43f649f2bd00ead61722d3", "filename": "src/test/compile-fail/deriving-span-Rand-enum.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-enum.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Rand)]\n+enum Enum {\n+   A(\n+     Error //~ ERROR\n+     )\n+}\n+\n+fn main() {}"}, {"sha": "2ce4d49e721537c89600904484501aed38cf033d", "filename": "src/test/compile-fail/deriving-span-Rand-struct.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Rand)]\n+struct Struct {\n+    x: Error //~ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "3f6738fd306d4a9cf5cd31d425094067fd605b3d", "filename": "src/test/compile-fail/deriving-span-Rand-tuple-struct.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Rand-tuple-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Rand)]\n+struct Struct(\n+    Error //~ ERROR\n+);\n+\n+fn main() {}"}, {"sha": "22c9351e13a554082ad52d8080931e6e2c7227d2", "filename": "src/test/compile-fail/deriving-span-TotalEq-enum-struct-variant.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum-struct-variant.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(TotalEq)]\n+enum Enum {\n+   A {\n+     x: Error //~ ERROR\n+//~^ ERROR\n+   }\n+}\n+\n+fn main() {}"}, {"sha": "36028ebb82cfa9b3d3ebbf189f038292db7f6cc2", "filename": "src/test/compile-fail/deriving-span-TotalEq-enum.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-enum.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(TotalEq)]\n+enum Enum {\n+   A(\n+     Error //~ ERROR\n+//~^ ERROR\n+     )\n+}\n+\n+fn main() {}"}, {"sha": "f3e38b3df4e678c947dd052b2f5d98e77c5def73", "filename": "src/test/compile-fail/deriving-span-TotalEq-struct.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(TotalEq)]\n+struct Struct {\n+    x: Error //~ ERROR\n+//~^ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "7293da91471b55deac2669f1bfec12526cff58ad", "filename": "src/test/compile-fail/deriving-span-TotalEq-tuple-struct.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalEq-tuple-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(TotalEq)]\n+struct Struct(\n+    Error //~ ERROR\n+//~^ ERROR\n+);\n+\n+fn main() {}"}, {"sha": "27a6bea1b04b7f71241f8975d08fdaf6d1f8e672", "filename": "src/test/compile-fail/deriving-span-TotalOrd-enum-struct-variant.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum-struct-variant.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+#[deriving(TotalEq)]\n+struct Error;\n+\n+#[deriving(TotalOrd,TotalEq)]\n+enum Enum {\n+   A {\n+     x: Error //~ ERROR\n+//~^ ERROR\n+   }\n+}\n+\n+fn main() {}"}, {"sha": "84c691b0fadc2fcc713bf4730d9e10a8f37186a4", "filename": "src/test/compile-fail/deriving-span-TotalOrd-enum.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-enum.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+#[deriving(TotalEq)]\n+struct Error;\n+\n+#[deriving(TotalOrd,TotalEq)]\n+enum Enum {\n+   A(\n+     Error //~ ERROR\n+//~^ ERROR\n+     )\n+}\n+\n+fn main() {}"}, {"sha": "c3a83df67d4e6c0b47e6cbf061c881afdc2b5c97", "filename": "src/test/compile-fail/deriving-span-TotalOrd-struct.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+#[deriving(TotalEq)]\n+struct Error;\n+\n+#[deriving(TotalOrd,TotalEq)]\n+struct Struct {\n+    x: Error //~ ERROR\n+//~^ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "9d913727e6c1eb27b8242d45d26ce79154be1118", "filename": "src/test/compile-fail/deriving-span-TotalOrd-tuple-struct.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-TotalOrd-tuple-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+#[deriving(TotalEq)]\n+struct Error;\n+\n+#[deriving(TotalOrd,TotalEq)]\n+struct Struct(\n+    Error //~ ERROR\n+//~^ ERROR\n+);\n+\n+fn main() {}"}, {"sha": "2892938926b498a5b5cdc38ac78de481e0328f69", "filename": "src/test/compile-fail/deriving-span-Zero-struct.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Zero)]\n+struct Struct {\n+    x: Error //~ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "43d84a593edaede08af05c9c04e75defe3fb4981", "filename": "src/test/compile-fail/deriving-span-Zero-tuple-struct.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0280ac5385433bd663e825e24f6990a816a5f40/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Zero-tuple-struct.rs?ref=b0280ac5385433bd663e825e24f6990a816a5f40", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file was auto-generated using 'src/etc/generate-keyword-span-tests.py'\n+\n+#[feature(struct_variant)];\n+extern mod extra;\n+\n+\n+struct Error;\n+\n+#[deriving(Zero)]\n+struct Struct(\n+    Error //~ ERROR\n+);\n+\n+fn main() {}"}]}