{"sha": "02a369a5c8a9be35ddfa17b8af1d51459c4a6bc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYTM2OWE1YzhhOWJlMzVkZGZhMTdiOGFmMWQ1MTQ1OWM0YTZiYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-02T08:24:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-02T08:24:14Z"}, "message": "Auto merge of #52890 - djrenren:test-visibility, r=petrochenkov\n\nReexport tests without polluting namespaces\n\nThis should fix issue #52557.\n\nBasically now we gensym a new name for the test function and reexport that.\nThat way the test function's reexport name can't conflict because it was impossible for the test author to write it down.\nWe then use a `use` statement to expose the original name using the original visibility.", "tree": {"sha": "476ae2ee989e045e1e5a9256960c253d23877769", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/476ae2ee989e045e1e5a9256960c253d23877769"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02a369a5c8a9be35ddfa17b8af1d51459c4a6bc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02a369a5c8a9be35ddfa17b8af1d51459c4a6bc6", "html_url": "https://github.com/rust-lang/rust/commit/02a369a5c8a9be35ddfa17b8af1d51459c4a6bc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02a369a5c8a9be35ddfa17b8af1d51459c4a6bc6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db5476571d9b27c862b95c1e64764b0ac8980e23", "url": "https://api.github.com/repos/rust-lang/rust/commits/db5476571d9b27c862b95c1e64764b0ac8980e23", "html_url": "https://github.com/rust-lang/rust/commit/db5476571d9b27c862b95c1e64764b0ac8980e23"}, {"sha": "77f9aca2a3e30eb430ba5a506261ff126c2d3077", "url": "https://api.github.com/repos/rust-lang/rust/commits/77f9aca2a3e30eb430ba5a506261ff126c2d3077", "html_url": "https://github.com/rust-lang/rust/commit/77f9aca2a3e30eb430ba5a506261ff126c2d3077"}], "stats": {"total": 105, "additions": 100, "deletions": 5}, "files": [{"sha": "383813d73b188c748cb1b8bbe1bf5b5d5d682ff4", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 62, "deletions": 5, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/02a369a5c8a9be35ddfa17b8af1d51459c4a6bc6/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02a369a5c8a9be35ddfa17b8af1d51459c4a6bc6/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=02a369a5c8a9be35ddfa17b8af1d51459c4a6bc6", "patch": "@@ -15,6 +15,7 @@ use codemap::{ExpnInfo, MacroBang, MacroAttribute, dummy_spanned, respan};\n use config::{is_test_or_bench, StripUnconfigured};\n use errors::{Applicability, FatalError};\n use ext::base::*;\n+use ext::build::AstBuilder;\n use ext::derive::{add_derived_markers, collect_derives};\n use ext::hygiene::{self, Mark, SyntaxContext};\n use ext::placeholders::{placeholder, PlaceholderExpander};\n@@ -474,6 +475,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 cx: self.cx,\n                 invocations: Vec::new(),\n                 monotonic: self.monotonic,\n+                tests_nameable: true,\n             };\n             (fragment.fold_with(&mut collector), collector.invocations)\n         };\n@@ -1049,6 +1051,11 @@ struct InvocationCollector<'a, 'b: 'a> {\n     cfg: StripUnconfigured<'a>,\n     invocations: Vec<Invocation>,\n     monotonic: bool,\n+\n+    /// Test functions need to be nameable. Tests inside functions or in other\n+    /// unnameable locations need to be ignored. `tests_nameable` tracks whether\n+    /// any test functions found in the current context would be nameable.\n+    tests_nameable: bool,\n }\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n@@ -1066,6 +1073,20 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         placeholder(fragment_kind, NodeId::placeholder_from_mark(mark))\n     }\n \n+    /// Folds the item allowing tests to be expanded because they are still nameable.\n+    /// This should probably only be called with module items\n+    fn fold_nameable(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n+        fold::noop_fold_item(item, self)\n+    }\n+\n+    /// Folds the item but doesn't allow tests to occur within it\n+    fn fold_unnameable(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n+        let was_nameable = mem::replace(&mut self.tests_nameable, false);\n+        let items = fold::noop_fold_item(item, self);\n+        self.tests_nameable = was_nameable;\n+        items\n+    }\n+\n     fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: AstFragmentKind) -> AstFragment {\n         self.collect(kind, InvocationKind::Bang { mac: mac, ident: None, span: span })\n     }\n@@ -1306,7 +1327,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             }\n             ast::ItemKind::Mod(ast::Mod { inner, .. }) => {\n                 if item.ident == keywords::Invalid.ident() {\n-                    return noop_fold_item(item, self);\n+                    return self.fold_nameable(item);\n                 }\n \n                 let orig_directory_ownership = self.cx.current_expansion.directory_ownership;\n@@ -1346,22 +1367,58 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n                 let orig_module =\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n-                let result = noop_fold_item(item, self);\n+                let result = self.fold_nameable(item);\n                 self.cx.current_expansion.module = orig_module;\n                 self.cx.current_expansion.directory_ownership = orig_directory_ownership;\n                 result\n             }\n             // Ensure that test functions are accessible from the test harness.\n+            // #[test] fn foo() {}\n+            // becomes:\n+            // #[test] pub fn foo_gensym(){}\n+            // #[allow(unused)]\n+            // use foo_gensym as foo;\n             ast::ItemKind::Fn(..) if self.cx.ecfg.should_test => {\n-                if item.attrs.iter().any(|attr| is_test_or_bench(attr)) {\n+                if self.tests_nameable && item.attrs.iter().any(|attr| is_test_or_bench(attr)) {\n+                    let orig_ident = item.ident;\n+                    let orig_vis   = item.vis.clone();\n+\n+                    // Publicize the item under gensymed name to avoid pollution\n                     item = item.map(|mut item| {\n                         item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n+                        item.ident = item.ident.gensym();\n                         item\n                     });\n+\n+                    // Use the gensymed name under the item's original visibility\n+                    let mut use_item = self.cx.item_use_simple_(\n+                        item.ident.span,\n+                        orig_vis,\n+                        Some(orig_ident),\n+                        self.cx.path(item.ident.span,\n+                            vec![keywords::SelfValue.ident(), item.ident]));\n+\n+                    // #[allow(unused)] because the test function probably isn't being referenced\n+                    use_item = use_item.map(|mut ui| {\n+                        ui.attrs.push(\n+                            self.cx.attribute(DUMMY_SP, attr::mk_list_item(DUMMY_SP,\n+                                Ident::from_str(\"allow\"), vec![\n+                                    attr::mk_nested_word_item(Ident::from_str(\"unused\"))\n+                                ]\n+                            ))\n+                        );\n+\n+                        ui\n+                    });\n+\n+                    SmallVector::many(\n+                        self.fold_unnameable(item).into_iter()\n+                            .chain(self.fold_unnameable(use_item)))\n+                } else {\n+                    self.fold_unnameable(item)\n                 }\n-                noop_fold_item(item, self)\n             }\n-            _ => noop_fold_item(item, self),\n+            _ => self.fold_unnameable(item),\n         }\n     }\n "}, {"sha": "2b8dfe162cc3d397be48bcd073269a1be312170b", "filename": "src/test/run-pass/issue-52557.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/02a369a5c8a9be35ddfa17b8af1d51459c4a6bc6/src%2Ftest%2Frun-pass%2Fissue-52557.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02a369a5c8a9be35ddfa17b8af1d51459c4a6bc6/src%2Ftest%2Frun-pass%2Fissue-52557.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-52557.rs?ref=02a369a5c8a9be35ddfa17b8af1d51459c4a6bc6", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test checks for namespace pollution by private tests.\n+// Tests used to marked as public causing name conflicts with normal\n+// functions only in test builds.\n+\n+// compile-flags: --test\n+\n+mod a {\n+    pub fn foo() -> bool {\n+        true\n+    }\n+}\n+\n+mod b {\n+    #[test]\n+    fn foo() {\n+        local_name(); // ensure the local name still works\n+    }\n+\n+    #[test]\n+    fn local_name() {}\n+}\n+\n+use a::*;\n+use b::*;\n+\n+pub fn conflict() {\n+    let _: bool = foo();\n+}"}]}