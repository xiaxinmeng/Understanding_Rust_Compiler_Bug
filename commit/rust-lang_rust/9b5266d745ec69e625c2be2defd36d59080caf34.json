{"sha": "9b5266d745ec69e625c2be2defd36d59080caf34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNTI2NmQ3NDVlYzY5ZTYyNWMyYmUyZGVmZDM2ZDU5MDgwY2FmMzQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-14T00:11:52Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-14T00:12:35Z"}, "message": "libsyntax: Refactor item parsing so that items and view items are parsed in the same function.\n\nThis is a step on the way to \"extern mod foo;\" and replacing \"import\" with \"use\".", "tree": {"sha": "533c5000713653e51c4d313e3c5ff0eff879ab6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/533c5000713653e51c4d313e3c5ff0eff879ab6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b5266d745ec69e625c2be2defd36d59080caf34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b5266d745ec69e625c2be2defd36d59080caf34", "html_url": "https://github.com/rust-lang/rust/commit/9b5266d745ec69e625c2be2defd36d59080caf34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b5266d745ec69e625c2be2defd36d59080caf34/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91612dbb7e37b53223a57557a442e29a84f0f6bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/91612dbb7e37b53223a57557a442e29a84f0f6bf", "html_url": "https://github.com/rust-lang/rust/commit/91612dbb7e37b53223a57557a442e29a84f0f6bf"}], "stats": {"total": 143, "additions": 113, "deletions": 30}, "files": [{"sha": "b50d4be4ae0090eb91ec7b13f45585bb8fecdaa8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 113, "deletions": 30, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/9b5266d745ec69e625c2be2defd36d59080caf34/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5266d745ec69e625c2be2defd36d59080caf34/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9b5266d745ec69e625c2be2defd36d59080caf34", "patch": "@@ -70,6 +70,8 @@ export SOURCE_FILE;\n import parse_from_source_str;\n export parse_from_source_str;\n \n+export item_or_view_item, iovi_none, iovi_view_item, iovi_item;\n+\n enum restriction {\n     UNRESTRICTED,\n     RESTRICT_STMT_EXPR,\n@@ -103,6 +105,11 @@ enum class_contents { ctor_decl(fn_decl, ~[attribute], blk, codemap::span),\n type arg_or_capture_item = either<arg, capture_item>;\n type item_info = (ident, item_, option<~[attribute]>);\n \n+enum item_or_view_item {\n+    iovi_none,\n+    iovi_item(@item),\n+    iovi_view_item(@view_item)\n+}\n \n /* The expr situation is not as complex as I thought it would be.\n The important thing is to make sure that lookahead doesn't balk\n@@ -135,6 +142,13 @@ macro_rules! maybe_whole {\n       INTERPOLATED(token::$constructor(x)) => { $p.bump(); return some(x); }\n       _ => ()\n     }} ;\n+    {iovi $p:expr, $constructor:ident} => { match copy $p.token {\n+      INTERPOLATED(token::$constructor(x)) => {\n+        $p.bump();\n+        return iovi_item(x);\n+      }\n+      _ => ()\n+    }} ;\n     {pair_empty $p:expr, $constructor:ident} => { match copy $p.token {\n       INTERPOLATED(token::$constructor(x)) => { $p.bump(); return (~[], x); }\n       _ => ()\n@@ -2004,13 +2018,17 @@ class parser {\n \n             let item_attrs = vec::append(first_item_attrs, item_attrs);\n \n-            match self.parse_item(item_attrs) {\n-              some(i) => {\n+            match self.parse_item_or_view_item(item_attrs) {\n+              iovi_item(i) => {\n                 let mut hi = i.span.hi;\n                 let decl = @spanned(lo, hi, decl_item(i));\n                 return @spanned(lo, hi, stmt_decl(decl, self.get_id()));\n               }\n-              none() => { /* fallthrough */ }\n+              iovi_view_item(vi) => {\n+                self.span_fatal(vi.span, ~\"view items must be declared at \\\n+                                           the top of the block\");\n+              }\n+              iovi_none() => { /* fallthrough */ }\n             }\n \n             check_expected_item(self, item_attrs);\n@@ -2680,9 +2698,15 @@ class parser {\n                 attrs = vec::append(attrs_remaining, attrs);\n                 first = false;\n             }\n-            debug!{\"parse_mod_items: parse_item(attrs=%?)\", attrs};\n-            match self.parse_item(attrs) {\n-              some(i) => vec::push(items, i),\n+            debug!(\"parse_mod_items: parse_item_or_view_item(attrs=%?)\",\n+                   attrs);\n+            match self.parse_item_or_view_item(attrs) {\n+              iovi_item(item) => vec::push(items, item),\n+              iovi_view_item(view_item) => {\n+                self.span_fatal(view_item.span, ~\"view items must be \\\n+                                                  declared at the top of the \\\n+                                                  module\");\n+              }\n               _ => {\n                 self.fatal(~\"expected item but found `\" +\n                            token_to_str(self.reader, self.token) + ~\"`\");\n@@ -2969,8 +2993,8 @@ class parser {\n         }\n     }\n \n-    fn parse_item(+attrs: ~[attribute]) -> option<@item> {\n-        maybe_whole!{some self,nt_item};\n+    fn parse_item_or_view_item(+attrs: ~[attribute]) -> item_or_view_item {\n+        maybe_whole!{iovi self,nt_item};\n         let lo = self.span.lo;\n \n         let visibility;\n@@ -2982,41 +3006,90 @@ class parser {\n             visibility = inherited;\n         }\n \n-        let (ident, item_, extra_attrs) = if self.eat_keyword(~\"const\") {\n-            self.parse_item_const()\n+        pure fn maybe_append(+lhs: ~[attribute], rhs: option<~[attribute]>)\n+                          -> ~[attribute] {\n+            match rhs {\n+                none => lhs,\n+                some(attrs) => vec::append(lhs, attrs)\n+            }\n+        }\n+\n+        if self.eat_keyword(~\"const\") {\n+            let (ident, item_, extra_attrs) = self.parse_item_const();\n+            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n+                                          visibility,\n+                                          maybe_append(attrs, extra_attrs)));\n         } else if self.is_keyword(~\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n             self.bump();\n-            self.parse_item_fn(impure_fn)\n+            let (ident, item_, extra_attrs) = self.parse_item_fn(impure_fn);\n+            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n+                                          visibility,\n+                                          maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"pure\") {\n             self.expect_keyword(~\"fn\");\n-            self.parse_item_fn(pure_fn)\n+            let (ident, item_, extra_attrs) = self.parse_item_fn(pure_fn);\n+            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n+                                          visibility,\n+                                          maybe_append(attrs, extra_attrs)));\n         } else if self.is_keyword(~\"unsafe\")\n             && self.look_ahead(1u) != token::LBRACE {\n             self.bump();\n             self.expect_keyword(~\"fn\");\n-            self.parse_item_fn(unsafe_fn)\n+            let (ident, item_, extra_attrs) = self.parse_item_fn(unsafe_fn);\n+            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n+                                          visibility,\n+                                          maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"extern\") {\n+            // XXX: \"extern mod foo;\" syntax as a \"use\" replacement.\n             if self.eat_keyword(~\"fn\") {\n-                self.parse_item_fn(extern_fn)\n-            } else {\n-                self.parse_item_foreign_mod()\n+                let (ident, item_, extra_attrs) =\n+                    self.parse_item_fn(extern_fn);\n+                return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n+                                              item_, visibility,\n+                                              maybe_append(attrs,\n+                                                           extra_attrs)));\n             }\n+            let (ident, item_, extra_attrs) = self.parse_item_foreign_mod();\n+            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n+                                          visibility,\n+                                          maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"mod\") || self.eat_keyword(~\"module\") {\n-            self.parse_item_mod()\n+            let (ident, item_, extra_attrs) = self.parse_item_mod();\n+            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n+                                          visibility,\n+                                          maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"type\") {\n-            self.parse_item_type()\n+            let (ident, item_, extra_attrs) = self.parse_item_type();\n+            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n+                                          visibility,\n+                                          maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"enum\") {\n-            self.parse_item_enum()\n+            let (ident, item_, extra_attrs) = self.parse_item_enum();\n+            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n+                                          visibility,\n+                                          maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"iface\") {\n             self.warn(~\"`iface` is deprecated; use `trait`\");\n-            self.parse_item_trait()\n+            let (ident, item_, extra_attrs) = self.parse_item_trait();\n+            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n+                                          visibility,\n+                                          maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"trait\") {\n-            self.parse_item_trait()\n+            let (ident, item_, extra_attrs) = self.parse_item_trait();\n+            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n+                                          visibility,\n+                                          maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"impl\") {\n-            self.parse_item_impl()\n+            let (ident, item_, extra_attrs) = self.parse_item_impl();\n+            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n+                                          visibility,\n+                                          maybe_append(attrs, extra_attrs)));\n         } else if self.eat_keyword(~\"class\") || self.eat_keyword(~\"struct\") {\n-            self.parse_item_class()\n+            let (ident, item_, extra_attrs) = self.parse_item_class();\n+            return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n+                                          visibility,\n+                                          maybe_append(attrs, extra_attrs)));\n         } else if !self.is_any_keyword(copy self.token)\n             && self.look_ahead(1) == token::NOT\n             && is_plain_ident(self.look_ahead(2))\n@@ -3039,13 +3112,23 @@ class parser {\n                                span: {lo: self.span.lo,\n                                       hi: self.span.hi,\n                                       expn_info: none}};\n-            (id, item_mac(m), none)\n-        } else { return none; };\n-        some(self.mk_item(lo, self.last_span.hi, ident, item_, visibility,\n-                          match extra_attrs {\n-                              some(as) => vec::append(attrs, as),\n-                              none => attrs\n-                          }))\n+            let item_ = item_mac(m);\n+            return iovi_item(self.mk_item(lo, self.last_span.hi, id, item_,\n+                                          visibility, attrs));\n+        } else {\n+            return iovi_none;\n+        };\n+    }\n+\n+    fn parse_item(+attrs: ~[attribute]) -> option<@ast::item> {\n+        match self.parse_item_or_view_item(attrs) {\n+            iovi_none =>\n+                none,\n+            iovi_view_item(_) =>\n+                self.fatal(~\"view items are not allowed here\"),\n+            iovi_item(item) =>\n+                some(item)\n+        }\n     }\n \n     fn parse_use() -> view_item_ {"}]}