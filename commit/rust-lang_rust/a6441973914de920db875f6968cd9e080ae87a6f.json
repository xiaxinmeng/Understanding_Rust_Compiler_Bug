{"sha": "a6441973914de920db875f6968cd9e080ae87a6f", "node_id": "C_kwDOAAsO6NoAKGE2NDQxOTczOTE0ZGU5MjBkYjg3NWY2OTY4Y2Q5ZTA4MGFlODdhNmY", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-05-07T13:23:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-07T13:23:46Z"}, "message": "Rollup merge of #96760 - davidtwco:diagnostic-translation-vec, r=oli-obk\n\ndiagnostics: port more diagnostics to derive + add support for `Vec` fields\n\n- Port \"unconstrained opaque type\" diagnostic to using the derive.\n- Allow `Vec` fields in diagnostic derive - enables support for diagnostics that have multiple primary spans, or have subdiagnostics repeated at multiple locations. `Vec<..>` fields in the diagnostic derive become loops in the generated code.\n- Add `create_{err,warning}` - there wasn't a way to create a diagnostic from a struct and not emit it straight away.\n- Port \"explicit generic args w/ impl trait\" diagnostic to using the derive.\n\nr? `````@oli-obk`````\ncc `````@pvdrz`````", "tree": {"sha": "6951fef91a8c952feaade6d021611c9b0b62fc7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6951fef91a8c952feaade6d021611c9b0b62fc7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6441973914de920db875f6968cd9e080ae87a6f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJidnLiCRBK7hj4Ov3rIwAAcR8IAIK06tPB8bXp+ktSs4WxJhy/\nNnVjHVr6wyEixpCCVJ8cvFEtpjGfuivxH+EBrcbRMaVdU5pF5eY3Ix9MhbOrz1HO\ndNixAg8U6hnE7yKmvT2dVIvd7L9IyL2g3GgRabolIOH3Dd+3tB/0P7HAdK2Tm+O7\nzvpcs1XzOGhZOSGXImRSzV0eAhx04XbBueoAkFJ7FL5Vl0easXNoxFGVxp+5To1k\n7C5kgdNE6xV3XiajAeNEfUkPzZ2+DO4RumsaPLju/zsRdZtqD2QEd3NhyEQU1sSD\naiPKwNVJFIa2BTNv9RzdaWgdGj0vfULX1CRjHwQKSN5mZaGVDchgWLJP091DZNY=\n=jL6g\n-----END PGP SIGNATURE-----\n", "payload": "tree 6951fef91a8c952feaade6d021611c9b0b62fc7e\nparent 3346d11f4e8521894377636f145bfc68fad10bea\nparent af47257c0dfc5b38468417d36a465a613c675d6e\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1651929826 +0200\ncommitter GitHub <noreply@github.com> 1651929826 +0200\n\nRollup merge of #96760 - davidtwco:diagnostic-translation-vec, r=oli-obk\n\ndiagnostics: port more diagnostics to derive + add support for `Vec` fields\n\n- Port \"unconstrained opaque type\" diagnostic to using the derive.\n- Allow `Vec` fields in diagnostic derive - enables support for diagnostics that have multiple primary spans, or have subdiagnostics repeated at multiple locations. `Vec<..>` fields in the diagnostic derive become loops in the generated code.\n- Add `create_{err,warning}` - there wasn't a way to create a diagnostic from a struct and not emit it straight away.\n- Port \"explicit generic args w/ impl trait\" diagnostic to using the derive.\n\nr? `````@oli-obk`````\ncc `````@pvdrz`````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6441973914de920db875f6968cd9e080ae87a6f", "html_url": "https://github.com/rust-lang/rust/commit/a6441973914de920db875f6968cd9e080ae87a6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6441973914de920db875f6968cd9e080ae87a6f/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3346d11f4e8521894377636f145bfc68fad10bea", "url": "https://api.github.com/repos/rust-lang/rust/commits/3346d11f4e8521894377636f145bfc68fad10bea", "html_url": "https://github.com/rust-lang/rust/commit/3346d11f4e8521894377636f145bfc68fad10bea"}, {"sha": "af47257c0dfc5b38468417d36a465a613c675d6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/af47257c0dfc5b38468417d36a465a613c675d6e", "html_url": "https://github.com/rust-lang/rust/commit/af47257c0dfc5b38468417d36a465a613c675d6e"}], "stats": {"total": 235, "additions": 165, "deletions": 70}, "files": [{"sha": "aef18fcafaa05e5cb8267d432ffd27015abaaf14", "filename": "compiler/rustc_error_messages/locales/en-US/typeck.ftl", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ftypeck.ftl?ref=a6441973914de920db875f6968cd9e080ae87a6f", "patch": "@@ -90,3 +90,14 @@ typeck-add-return-type-missing-here = a return type might be missing here\n typeck-expected-default-return-type = expected `()` because of default return type\n \n typeck-expected-return-type = expected `{$expected}` because of return type\n+\n+typeck-unconstrained-opaque-type = unconstrained opaque type\n+    .note = `{$name}` must be used in combination with a concrete type within the same module\n+\n+typeck-explicit-generic-args-with-impl-trait =\n+    cannot provide explicit generic arguments when `impl Trait` is used in argument position\n+    .label = explicit generic argument not allowed\n+    .note = see issue #83701 <https://github.com/rust-lang/rust/issues/83701> for more information\n+\n+typeck-explicit-generic-args-with-impl-trait-feature =\n+    add `#![feature(explicit_generic_args_with_impl_trait)]` to the crate attributes to enable"}, {"sha": "83fc7bcde8ab47d385da4f3325726252aae1a5c2", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=a6441973914de920db875f6968cd9e080ae87a6f", "patch": "@@ -5,8 +5,8 @@ use crate::diagnostics::error::{\n     SessionDiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    option_inner_ty, report_error_if_not_applied_to_span, type_matches_path, Applicability,\n-    FieldInfo, HasFieldMap, SetOnce,\n+    report_error_if_not_applied_to_span, type_matches_path, Applicability, FieldInfo, FieldInnerTy,\n+    HasFieldMap, SetOnce,\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n@@ -353,35 +353,40 @@ impl SessionDiagnosticDeriveBuilder {\n         info: FieldInfo<'_>,\n     ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n         let field_binding = &info.binding.binding;\n-        let option_ty = option_inner_ty(&info.ty);\n-        let generated_code = self.generate_non_option_field_code(\n+\n+        let inner_ty = FieldInnerTy::from_type(&info.ty);\n+        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let (binding, needs_destructure) = match (name.as_str(), &inner_ty) {\n+            // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n+            (\"primary_span\", FieldInnerTy::Vec(_)) => (quote! { #field_binding.clone() }, false),\n+            _ => (quote! { *#field_binding }, true),\n+        };\n+\n+        let generated_code = self.generate_inner_field_code(\n             attr,\n             FieldInfo {\n                 vis: info.vis,\n                 binding: info.binding,\n-                ty: option_ty.unwrap_or(&info.ty),\n+                ty: inner_ty.inner_type().unwrap_or(&info.ty),\n                 span: info.span,\n             },\n+            binding,\n         )?;\n \n-        if option_ty.is_none() {\n-            Ok(quote! { #generated_code })\n+        if needs_destructure {\n+            Ok(inner_ty.with(field_binding, generated_code))\n         } else {\n-            Ok(quote! {\n-                if let Some(#field_binding) = #field_binding {\n-                    #generated_code\n-                }\n-            })\n+            Ok(generated_code)\n         }\n     }\n \n-    fn generate_non_option_field_code(\n+    fn generate_inner_field_code(\n         &mut self,\n         attr: &Attribute,\n         info: FieldInfo<'_>,\n+        binding: TokenStream,\n     ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n         let diag = &self.diag;\n-        let field_binding = &info.binding.binding;\n \n         let name = attr.path.segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n@@ -397,14 +402,14 @@ impl SessionDiagnosticDeriveBuilder {\n                 \"primary_span\" => {\n                     report_error_if_not_applied_to_span(attr, &info)?;\n                     Ok(quote! {\n-                        #diag.set_span(*#field_binding);\n+                        #diag.set_span(#binding);\n                     })\n                 }\n                 \"label\" | \"note\" | \"help\" => {\n                     report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(self.add_subdiagnostic(field_binding, name, name))\n+                    Ok(self.add_subdiagnostic(binding, name, name))\n                 }\n-                \"subdiagnostic\" => Ok(quote! { #diag.subdiagnostic(*#field_binding); }),\n+                \"subdiagnostic\" => Ok(quote! { #diag.subdiagnostic(#binding); }),\n                 _ => throw_invalid_attr!(attr, &meta, |diag| {\n                     diag\n                         .help(\"only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` are valid field attributes\")\n@@ -413,7 +418,7 @@ impl SessionDiagnosticDeriveBuilder {\n             Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(ref s), .. }) => match name {\n                 \"label\" | \"note\" | \"help\" => {\n                     report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(self.add_subdiagnostic(field_binding, name, &s.value()))\n+                    Ok(self.add_subdiagnostic(binding, name, &s.value()))\n                 }\n                 _ => throw_invalid_attr!(attr, &meta, |diag| {\n                     diag.help(\"only `label`, `note` and `help` are valid field attributes\")\n@@ -509,7 +514,7 @@ impl SessionDiagnosticDeriveBuilder {\n     /// `fluent_attr_identifier`.\n     fn add_subdiagnostic(\n         &self,\n-        field_binding: &proc_macro2::Ident,\n+        field_binding: TokenStream,\n         kind: &str,\n         fluent_attr_identifier: &str,\n     ) -> TokenStream {\n@@ -520,7 +525,7 @@ impl SessionDiagnosticDeriveBuilder {\n         let fn_name = format_ident!(\"span_{}\", kind);\n         quote! {\n             #diag.#fn_name(\n-                *#field_binding,\n+                #field_binding,\n                 rustc_errors::DiagnosticMessage::fluent_attr(#slug, #fluent_attr_identifier)\n             );\n         }"}, {"sha": "65b1328682f823243b4aefed836e2d5c969f11f8", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=a6441973914de920db875f6968cd9e080ae87a6f", "patch": "@@ -5,8 +5,8 @@ use crate::diagnostics::error::{\n     SessionDiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    option_inner_ty, report_error_if_not_applied_to_applicability,\n-    report_error_if_not_applied_to_span, Applicability, FieldInfo, HasFieldMap, SetOnce,\n+    report_error_if_not_applied_to_applicability, report_error_if_not_applied_to_span,\n+    Applicability, FieldInfo, FieldInnerTy, HasFieldMap, SetOnce,\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n@@ -301,11 +301,11 @@ impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n     ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n         let ast = binding.ast();\n \n-        let option_ty = option_inner_ty(&ast.ty);\n+        let inner_ty = FieldInnerTy::from_type(&ast.ty);\n         let info = FieldInfo {\n             vis: &ast.vis,\n             binding: binding,\n-            ty: option_ty.unwrap_or(&ast.ty),\n+            ty: inner_ty.inner_type().unwrap_or(&ast.ty),\n             span: &ast.span(),\n         };\n \n@@ -353,15 +353,7 @@ impl<'a> SessionSubdiagnosticDeriveBuilder<'a> {\n             );\n         };\n \n-        if option_ty.is_none() {\n-            Ok(quote! { #generated })\n-        } else {\n-            Ok(quote! {\n-                if let Some(#binding) = #binding {\n-                    #generated\n-                }\n-            })\n-        }\n+        Ok(inner_ty.with(binding, generated))\n     }\n \n     fn into_tokens(&mut self) -> Result<TokenStream, SessionDiagnosticDeriveError> {"}, {"sha": "aba861fc6aafa4a0954216f969e07e9da7812a39", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=a6441973914de920db875f6968cd9e080ae87a6f", "patch": "@@ -1,7 +1,7 @@\n use crate::diagnostics::error::{span_err, throw_span_err, SessionDiagnosticDeriveError};\n use proc_macro::Span;\n use proc_macro2::TokenStream;\n-use quote::{format_ident, quote};\n+use quote::{format_ident, quote, ToTokens};\n use std::collections::BTreeSet;\n use std::str::FromStr;\n use syn::{spanned::Spanned, Attribute, Meta, Type, Visibility};\n@@ -76,22 +76,71 @@ pub(crate) fn report_error_if_not_applied_to_span(\n     report_error_if_not_applied_to_ty(attr, info, &[\"rustc_span\", \"Span\"], \"Span\")\n }\n \n-/// If `ty` is an Option, returns `Some(inner type)`, otherwise returns `None`.\n-pub(crate) fn option_inner_ty(ty: &Type) -> Option<&Type> {\n-    if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n+/// Inner type of a field and type of wrapper.\n+pub(crate) enum FieldInnerTy<'ty> {\n+    /// Field is wrapped in a `Option<$inner>`.\n+    Option(&'ty Type),\n+    /// Field is wrapped in a `Vec<$inner>`.\n+    Vec(&'ty Type),\n+    /// Field isn't wrapped in an outer type.\n+    None,\n+}\n+\n+impl<'ty> FieldInnerTy<'ty> {\n+    /// Returns inner type for a field, if there is one.\n+    ///\n+    /// - If `ty` is an `Option`, returns `FieldInnerTy::Option { inner: (inner type) }`.\n+    /// - If `ty` is a `Vec`, returns `FieldInnerTy::Vec { inner: (inner type) }`.\n+    /// - Otherwise returns `None`.\n+    pub(crate) fn from_type(ty: &'ty Type) -> Self {\n+        let variant: &dyn Fn(&'ty Type) -> FieldInnerTy<'ty> =\n+            if type_matches_path(ty, &[\"std\", \"option\", \"Option\"]) {\n+                &FieldInnerTy::Option\n+            } else if type_matches_path(ty, &[\"std\", \"vec\", \"Vec\"]) {\n+                &FieldInnerTy::Vec\n+            } else {\n+                return FieldInnerTy::None;\n+            };\n+\n         if let Type::Path(ty_path) = ty {\n             let path = &ty_path.path;\n             let ty = path.segments.iter().last().unwrap();\n             if let syn::PathArguments::AngleBracketed(bracketed) = &ty.arguments {\n                 if bracketed.args.len() == 1 {\n                     if let syn::GenericArgument::Type(ty) = &bracketed.args[0] {\n-                        return Some(ty);\n+                        return variant(ty);\n                     }\n                 }\n             }\n         }\n+\n+        unreachable!();\n+    }\n+\n+    /// Returns `Option` containing inner type if there is one.\n+    pub(crate) fn inner_type(&self) -> Option<&'ty Type> {\n+        match self {\n+            FieldInnerTy::Option(inner) | FieldInnerTy::Vec(inner) => Some(inner),\n+            FieldInnerTy::None => None,\n+        }\n+    }\n+\n+    /// Surrounds `inner` with destructured wrapper type, exposing inner type as `binding`.\n+    pub(crate) fn with(&self, binding: impl ToTokens, inner: impl ToTokens) -> TokenStream {\n+        match self {\n+            FieldInnerTy::Option(..) => quote! {\n+                if let Some(#binding) = #binding {\n+                    #inner\n+                }\n+            },\n+            FieldInnerTy::Vec(..) => quote! {\n+                for #binding in #binding {\n+                    #inner\n+                }\n+            },\n+            FieldInnerTy::None => quote! { #inner },\n+        }\n     }\n-    None\n }\n \n /// Field information passed to the builder. Deliberately omits attrs to discourage the"}, {"sha": "6fb87e15a3303a6ce105be77189b2953f5fe6dc4", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=a6441973914de920db875f6968cd9e080ae87a6f", "patch": "@@ -289,12 +289,26 @@ impl ParseSess {\n         self.proc_macro_quoted_spans.lock().clone()\n     }\n \n+    pub fn create_err<'a>(\n+        &'a self,\n+        err: impl SessionDiagnostic<'a>,\n+    ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        err.into_diagnostic(self)\n+    }\n+\n     pub fn emit_err<'a>(&'a self, err: impl SessionDiagnostic<'a>) -> ErrorGuaranteed {\n-        err.into_diagnostic(self).emit()\n+        self.create_err(err).emit()\n+    }\n+\n+    pub fn create_warning<'a>(\n+        &'a self,\n+        warning: impl SessionDiagnostic<'a, ()>,\n+    ) -> DiagnosticBuilder<'a, ()> {\n+        warning.into_diagnostic(self)\n     }\n \n     pub fn emit_warning<'a>(&'a self, warning: impl SessionDiagnostic<'a, ()>) {\n-        warning.into_diagnostic(self).emit()\n+        self.create_warning(warning).emit()\n     }\n \n     pub fn struct_err("}, {"sha": "b2c23cda6aae545b1bcf2f893eb63dd671d90fa7", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=a6441973914de920db875f6968cd9e080ae87a6f", "patch": "@@ -413,9 +413,21 @@ impl Session {\n     pub fn err(&self, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         self.diagnostic().err(msg)\n     }\n+    pub fn create_err<'a>(\n+        &'a self,\n+        err: impl SessionDiagnostic<'a>,\n+    ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+        self.parse_sess.create_err(err)\n+    }\n     pub fn emit_err<'a>(&'a self, err: impl SessionDiagnostic<'a>) -> ErrorGuaranteed {\n         self.parse_sess.emit_err(err)\n     }\n+    pub fn create_warning<'a>(\n+        &'a self,\n+        err: impl SessionDiagnostic<'a, ()>,\n+    ) -> DiagnosticBuilder<'a, ()> {\n+        self.parse_sess.create_warning(err)\n+    }\n     pub fn emit_warning<'a>(&'a self, warning: impl SessionDiagnostic<'a, ()>) {\n         self.parse_sess.emit_warning(warning)\n     }"}, {"sha": "38c29d3874c9e169fbe4828fe6eb712574ec4459", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 6, "deletions": 22, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=a6441973914de920db875f6968cd9e080ae87a6f", "patch": "@@ -3,7 +3,10 @@ use crate::astconv::{\n     AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n     GenericArgCountResult, GenericArgPosition,\n };\n-use crate::errors::AssocTypeBindingNotAllowed;\n+use crate::errors::{\n+    AssocTypeBindingNotAllowed, ExplicitGenericArgsWithImplTrait,\n+    ExplicitGenericArgsWithImplTraitFeature,\n+};\n use crate::structured_errors::{GenericArgsInfo, StructuredDiagnostic, WrongNumberOfGenericArgs};\n use rustc_ast::ast::ParamKindOrd;\n use rustc_errors::{struct_span_err, Applicability, Diagnostic, MultiSpan};\n@@ -636,29 +639,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 })\n                 .collect::<Vec<_>>();\n \n-            let mut err = struct_span_err! {\n-                tcx.sess,\n-                spans.clone(),\n-                E0632,\n-                \"cannot provide explicit generic arguments when `impl Trait` is \\\n-                used in argument position\"\n-            };\n-\n-            for span in spans {\n-                err.span_label(span, \"explicit generic argument not allowed\");\n-            }\n-\n-            err.note(\n-                \"see issue #83701 <https://github.com/rust-lang/rust/issues/83701> \\\n-                 for more information\",\n-            );\n+            let mut err = tcx.sess.create_err(ExplicitGenericArgsWithImplTrait { spans });\n             if tcx.sess.is_nightly_build() {\n-                err.help(\n-                    \"add `#![feature(explicit_generic_args_with_impl_trait)]` \\\n-                     to the crate attributes to enable\",\n-                );\n+                err.subdiagnostic(ExplicitGenericArgsWithImplTraitFeature);\n             }\n-\n             err.emit();\n         }\n "}, {"sha": "4b6f80ce57a83eced8d248eeef0fe4cee04d1968", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=a6441973914de920db875f6968cd9e080ae87a6f", "patch": "@@ -14,6 +14,7 @@ use rustc_span::{Span, DUMMY_SP};\n \n use super::ItemCtxt;\n use super::{bad_placeholder, is_suggestable_infer_ty};\n+use crate::errors::UnconstrainedOpaqueType;\n \n /// Computes the relevant generic parameter for a potential generic const argument.\n ///\n@@ -682,13 +683,10 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n     match locator.found {\n         Some(hidden) => hidden.ty,\n         None => {\n-            let span = tcx.def_span(def_id);\n-            let name = tcx.item_name(tcx.local_parent(def_id).to_def_id());\n-            let label = format!(\n-                \"`{}` must be used in combination with a concrete type within the same module\",\n-                name\n-            );\n-            tcx.sess.struct_span_err(span, \"unconstrained opaque type\").note(&label).emit();\n+            tcx.sess.emit_err(UnconstrainedOpaqueType {\n+                span: tcx.def_span(def_id),\n+                name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n+            });\n             tcx.ty_error()\n         }\n     }"}, {"sha": "a3e7108caae00778eaae5f6b00ea552af5e62d11", "filename": "compiler/rustc_typeck/src/errors.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6441973914de920db875f6968cd9e080ae87a6f/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs?ref=a6441973914de920db875f6968cd9e080ae87a6f", "patch": "@@ -228,3 +228,25 @@ pub enum ExpectedReturnTypeLabel<'tcx> {\n         expected: Ty<'tcx>,\n     },\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error(slug = \"typeck-unconstrained-opaque-type\")]\n+#[note]\n+pub struct UnconstrainedOpaqueType {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0632\", slug = \"typeck-explicit-generic-args-with-impl-trait\")]\n+#[note]\n+pub struct ExplicitGenericArgsWithImplTrait {\n+    #[primary_span]\n+    #[label]\n+    pub spans: Vec<Span>,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[help(slug = \"typeck-explicit-generic-args-with-impl-trait-feature\")]\n+pub struct ExplicitGenericArgsWithImplTraitFeature;"}, {"sha": "c63410fa35bde6d91233d06a0b8c1ef003cf57f1", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6441973914de920db875f6968cd9e080ae87a6f/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6441973914de920db875f6968cd9e080ae87a6f/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=a6441973914de920db875f6968cd9e080ae87a6f", "patch": "@@ -474,3 +474,11 @@ struct Subdiagnostic {\n     #[subdiagnostic]\n     note: Note,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct VecField {\n+    #[primary_span]\n+    #[label]\n+    spans: Vec<Span>,\n+}"}]}